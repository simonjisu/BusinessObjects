{"sample_id": "train.64", "db_id": "student_assessment", "question": "List the id of students who attended some courses?", "rationale": ["We need to list the IDs of students who have attended courses, which is recorded in the 'Student_Course_Attendance' table.", "The relevant column for student IDs in this table is 'student_id'.", "To ensure that we get unique student IDs, we will use the DISTINCT keyword in our SQL query.", "The final SQL query will select distinct student IDs from the 'Student_Course_Attendance' table."], "gold_sql": "SELECT student_id FROM student_course_attendance", "source_tables": ["student_course_attendance"], "pred_sql": "SELECT DISTINCT student_id FROM Student_Course_Attendance;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the identifiers of students who have attended courses from the 'Student_Course_Attendance' table. The placeholder in the SELECT clause represents the unique identifier for each student.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_attendance\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of student identifiers from the 'Student_Course_Attendance' table for a specific course. The results are ordered by the date of attendance in descending order, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_attendance WHERE course_id = [PLACEHOLDER-TYPE:NUMBER] ORDER BY date_of_attendance DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the number of results returned is limited by a specified placeholder value.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.68", "db_id": "student_assessment", "question": "What details do we have on the students who registered for courses most recently?", "rationale": ["Identify the relevant tables: Students, People, Student_Course_Registrations, and Courses.", "We need to join these tables to get the details of students who registered for courses.", "The most recent registration date can be found using a subquery that selects the maximum registration date from the Student_Course_Registrations table.", "The final query selects the student ID, first name, last name, registration date, and course name for students who registered on the most recent date."], "gold_sql": "SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT 1", "source_tables": ["student_course_registrations", "students"], "pred_sql": "SELECT s.student_id, p.first_name, p.last_name, scr.registration_date, c.course_name \nFROM Students s \nJOIN People p ON s.student_id = p.person_id \nJOIN Student_Course_Registrations scr ON s.student_id = scr.student_id \nJOIN Courses c ON scr.course_id = c.course_id \nWHERE scr.registration_date = (SELECT MAX(registration_date) FROM Student_Course_Registrations)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the limit on the number of results returned can be specified using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the number of results returned is limited by a specified placeholder value.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of student identifiers from the 'Student_Course_Attendance' table for a specific course. The results are ordered by the date of attendance in descending order, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_attendance WHERE course_id = [PLACEHOLDER-TYPE:NUMBER] ORDER BY date_of_attendance DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.76", "db_id": "student_assessment", "question": "What is the id of the candidate who most recently accessed the course?", "rationale": ["We need to find the candidate who most recently accessed a course, which implies we need to look at the attendance records.", "Candidates are linked to people through the 'Candidates' and 'People' tables, where 'candidate_id' corresponds to 'person_id'.", "We will join the 'Candidates' table with the 'People' table to get the candidate's details.", "Next, we will join the 'Student_Course_Attendance' table to find the attendance records for these candidates.", "We will order the results by 'date_of_attendance' in descending order to get the most recent attendance first.", "Finally, we will limit the results to 1 to get only the most recent candidate."], "gold_sql": "SELECT candidate_id FROM candidate_assessments ORDER BY assessment_date DESC LIMIT 1", "source_tables": ["candidate_assessments"], "pred_sql": "SELECT c.candidate_id \nFROM Candidates c \nJOIN People p ON c.candidate_id = p.person_id \nJOIN Student_Course_Attendance sca ON p.person_id = sca.student_id \nORDER BY sca.date_of_attendance DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of student identifiers from the 'Student_Course_Attendance' table for a specific course. The results are ordered by the date of attendance in descending order, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_attendance WHERE course_id = [PLACEHOLDER-TYPE:NUMBER] ORDER BY date_of_attendance DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the identifiers of students who have attended courses from the 'Student_Course_Attendance' table. The placeholder in the SELECT clause represents the unique identifier for each student.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_attendance\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the limit on the number of results returned can be specified using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.78", "db_id": "student_assessment", "question": "What are the details of the student who registered for the most number of courses?", "rationale": ["Identify the table that contains student details, which is the 'Students' table.", "Determine the relationship between students and their course registrations, which is through the 'Student_Course_Registrations' table.", "Create a subquery to find the student_id of the student who registered for the most courses by grouping by student_id and ordering by the count of registrations in descending order, limiting the result to 1.", "Join the result of the subquery with the 'Students' table to get the details of the student who registered for the most courses."], "gold_sql": "SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_course_registrations", "students"], "pred_sql": "SELECT s.student_id, s.student_details \nFROM Students s \nJOIN (SELECT student_id \n      FROM Student_Course_Registrations \n      GROUP BY student_id \n      ORDER BY COUNT(*) DESC \n      LIMIT 1) AS most_courses \nON s.student_id = most_courses.student_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the limit on the number of results returned can be specified using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the number of results returned is limited by a specified placeholder value.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of student identifiers from the 'Student_Course_Attendance' table for a specific course. The results are ordered by the date of attendance in descending order, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_attendance WHERE course_id = [PLACEHOLDER-TYPE:NUMBER] ORDER BY date_of_attendance DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.82", "db_id": "student_assessment", "question": "For each course id, how many students are registered and what are the course names?", "rationale": ["We need to find the number of students registered for each course and the corresponding course names.", "To achieve this, we will join the 'Student_Course_Registrations' table with the 'Courses' table on the 'course_id'.", "We will select the 'course_id' from 'Student_Course_Registrations' and the 'course_name' from 'Courses'.", "To count the number of students registered for each course, we will use the COUNT() function on 'student_id'.", "We will group the results by 'course_id' and 'course_name' to get the count for each course."], "gold_sql": "SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id", "source_tables": ["courses", "student_course_registrations", "students"], "pred_sql": "SELECT sc.course_id, c.course_name, COUNT(sc.student_id) AS student_count\nFROM Student_Course_Registrations sc\nJOIN Courses c ON sc.course_id = c.course_id\nGROUP BY sc.course_id, c.course_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the number of results returned is limited by a specified placeholder value.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the limit on the number of results returned can be specified using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the identifiers of students who have attended courses from the 'Student_Course_Attendance' table. The placeholder in the SELECT clause represents the unique identifier for each student.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_attendance\"\n    }\n}\n"}
{"sample_id": "train.89", "db_id": "student_assessment", "question": "What is the id of the student who most recently registered course 301?", "rationale": ["Identify the relevant table: The 'Student_Course_Registrations' table contains the information about student registrations for courses.", "Filter by course_id: We need to filter the records to only include those where the course_id is '301'.", "Order by registration_date: To find the most recent registration, we will order the results by the 'registration_date' in descending order.", "Limit the results: Since we only want the most recent registration, we will limit the results to 1."], "gold_sql": "SELECT student_id FROM student_course_attendance WHERE course_id = 301 ORDER BY date_of_attendance DESC LIMIT 1", "source_tables": ["student_course_attendance"], "pred_sql": "SELECT student_id FROM Student_Course_Registrations WHERE course_id = '301' ORDER BY registration_date DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the number of results returned is limited by a specified placeholder value.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the limit on the number of results returned can be specified using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the identifiers of students who have attended courses from the 'Student_Course_Attendance' table. The placeholder in the SELECT clause represents the unique identifier for each student.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_attendance\"\n    }\n}\n"}
{"sample_id": "train.92", "db_id": "student_assessment", "question": "What are the different cities where people live?", "rationale": ["Identify the relevant table: The question asks about cities where people live, which relates to the Addresses table.", "Select the appropriate column: The 'city' column in the Addresses table contains the city names.", "Use DISTINCT to avoid duplicate city names: Since we want different cities, we will use the DISTINCT keyword to ensure each city is listed only once."], "gold_sql": "SELECT DISTINCT T1.city FROM addresses AS T1 JOIN people_addresses AS T2 ON T1.address_id = T2.address_id", "source_tables": ["addresses", "people_addresses"], "pred_sql": "SELECT DISTINCT city FROM Addresses;", "hint": "\n"}
{"sample_id": "train.105", "db_id": "student_assessment", "question": "List the id of students who registered course statistics in the order of registration date.", "rationale": ["Identify the relevant table for course registrations, which is 'Student_Course_Registrations'.", "Determine the specific course of interest, which is 'Statistics'.", "Use a subquery to find the course_id associated with the course name 'Statistics'.", "Select the student_id from 'Student_Course_Registrations' where the course_id matches the one found in the subquery.", "Order the results by the registration_date to get the students in the order they registered."], "gold_sql": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = 'statistics' ORDER BY T2.registration_date", "source_tables": ["courses", "student_course_registrations"], "pred_sql": "SELECT student_id FROM Student_Course_Registrations WHERE course_id = (SELECT course_id FROM Courses WHERE course_name = 'Statistics') ORDER BY registration_date;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the limit on the number of results returned can be specified using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the number of results returned is limited by a specified placeholder value.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of student identifiers from the 'Student_Course_Attendance' table for a specific course. The results are ordered by the date of attendance in descending order, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_attendance WHERE course_id = [PLACEHOLDER-TYPE:NUMBER] ORDER BY date_of_attendance DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.106", "db_id": "student_assessment", "question": "What are the ids of the students who registered course statistics by order of registration date?", "rationale": ["Identify the relevant table for course registrations, which is 'Student_Course_Registrations'.", "Determine the course of interest, which is 'Statistics'.", "Use a subquery to find the course_id associated with the course name 'Statistics'.", "Select the student_id from 'Student_Course_Registrations' where the course_id matches the one found in the subquery.", "Order the results by the registration_date to get the ids in the order of registration."], "gold_sql": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = 'statistics' ORDER BY T2.registration_date", "source_tables": ["courses", "student_course_registrations"], "pred_sql": "SELECT student_id FROM Student_Course_Registrations WHERE course_id = (SELECT course_id FROM Courses WHERE course_name = 'Statistics') ORDER BY registration_date;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the limit on the number of results returned can be specified using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the number of results returned is limited by a specified placeholder value.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of student identifiers from the 'Student_Course_Attendance' table for a specific course. The results are ordered by the date of attendance in descending order, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_attendance WHERE course_id = [PLACEHOLDER-TYPE:NUMBER] ORDER BY date_of_attendance DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.387", "db_id": "flight_1", "question": "Show origins of all flights with destination Honolulu.", "rationale": ["Identify the relevant table: The 'flight' table contains the information about flight origins and destinations.", "Determine the required data: We need to show the origins of all flights that have 'Honolulu' as their destination.", "Construct the SQL query: Use a SELECT statement to retrieve the 'origin' column from the 'flight' table where the 'destination' column matches 'Honolulu'."], "gold_sql": "SELECT origin FROM Flight WHERE destination  =  'Honolulu'", "source_tables": ["flight"], "pred_sql": "SELECT origin FROM flight WHERE destination = 'Honolulu'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of flight origins from the 'Flight' table, grouped by the origin location. The results are ordered by the number of flights departing from each origin in descending order, with a limit on the number of origins returned as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT origin FROM Flight GROUP BY origin ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the starting locations of flights from the 'Flight' table that are headed to a specific destination. The placeholder in the WHERE clause represents the destination's name.\",\n        \"virtual_table\": \"SELECT origin FROM Flight WHERE destination  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average distance and average price of flights originating from a specific location. The placeholder in the WHERE clause represents the origin of the flights.\",\n        \"virtual_table\": \"SELECT avg(distance) ,  avg(price) FROM Flight WHERE origin  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.390", "db_id": "flight_1", "question": "What are the departure and arrival dates of all flights from LA to Honolulu?", "rationale": ["Identify the relevant table: The 'flight' table contains the necessary information about flights, including departure and arrival dates.", "Determine the required columns: We need the 'departure_date' and 'arrival_date' for the flights.", "Specify the conditions: We are interested in flights that originate from 'LA' and have 'Honolulu' as their destination.", "Construct the SQL query: Using the SELECT statement to retrieve the specified columns from the 'flight' table with the appropriate WHERE clause to filter by origin and destination."], "gold_sql": "SELECT departure_date ,  arrival_date FROM Flight WHERE origin  =  'Los Angeles' AND destination  =  'Honolulu'", "source_tables": ["flight"], "pred_sql": "SELECT departure_date, arrival_date FROM flight WHERE origin = 'LA' AND destination = 'Honolulu';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of flight origins from the 'Flight' table, grouped by the origin location. The results are ordered by the number of flights departing from each origin in descending order, with a limit on the number of origins returned as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT origin FROM Flight GROUP BY origin ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the starting locations of flights from the 'Flight' table that are headed to a specific destination. The placeholder in the WHERE clause represents the destination's name.\",\n        \"virtual_table\": \"SELECT origin FROM Flight WHERE destination  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average ticket price for flights originating from a specific location and heading to a specific destination. The placeholders in the WHERE clause represent the origin and destination of the flights.\",\n        \"virtual_table\": \"SELECT avg(price) FROM Flight WHERE origin  =  [PLACEHOLDER-TYPE:STRING] AND destination  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.400", "db_id": "flight_1", "question": "What are the numbers of the shortest flights?", "rationale": ["Identify the relevant table: The 'flight' table contains information about flights, including their distances.", "Determine the requirement: The user wants to find the numbers of the shortest flights.", "To find the shortest flights, we need to order the flights by distance in ascending order.", "Use the ORDER BY clause to sort the flights by the 'distance' column.", "Limit the results to the shortest flight(s) using the LIMIT clause."], "gold_sql": "SELECT flno FROM Flight ORDER BY distance ASC LIMIT 3", "source_tables": ["flight"], "pred_sql": "SELECT flno FROM flight ORDER BY distance ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average distance and average price of flights originating from a specific location. The placeholder in the WHERE clause represents the origin of the flights.\",\n        \"virtual_table\": \"SELECT avg(distance) ,  avg(price) FROM Flight WHERE origin  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of flight origins from the 'Flight' table, grouped by the origin location. The results are ordered by the number of flights departing from each origin in descending order, with a limit on the number of origins returned as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT origin FROM Flight GROUP BY origin ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average ticket price for flights originating from a specific location and heading to a specific destination. The placeholders in the WHERE clause represent the origin and destination of the flights.\",\n        \"virtual_table\": \"SELECT avg(price) FROM Flight WHERE origin  =  [PLACEHOLDER-TYPE:STRING] AND destination  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.408", "db_id": "flight_1", "question": "What place has the most flights coming from there?", "rationale": ["The question asks for the place with the most flights coming from there, which means we need to look at the 'origin' column in the 'flight' table.", "To find the place with the most flights, we can group the results by 'origin' and count the number of flights for each origin.", "We will order the results in descending order based on the count of flights to get the origin with the highest number of flights at the top.", "Finally, we will limit the results to just one entry to get the top origin with the most flights."], "gold_sql": "SELECT origin FROM Flight GROUP BY origin ORDER BY count(*) DESC LIMIT 1", "source_tables": ["flight"], "pred_sql": "SELECT origin FROM flight GROUP BY origin ORDER BY count(*) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the starting locations of flights from the 'Flight' table that are headed to a specific destination. The placeholder in the WHERE clause represents the destination's name.\",\n        \"virtual_table\": \"SELECT origin FROM Flight WHERE destination  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of flight origins from the 'Flight' table, grouped by the origin location. The results are ordered by the number of flights departing from each origin in descending order, with a limit on the number of origins returned as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT origin FROM Flight GROUP BY origin ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average distance and average price of flights originating from a specific location. The placeholder in the WHERE clause represents the origin of the flights.\",\n        \"virtual_table\": \"SELECT avg(distance) ,  avg(price) FROM Flight WHERE origin  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.416", "db_id": "flight_1", "question": "What is the name of each aircraft and how many flights does each one complete?", "rationale": ["We need to find the name of each aircraft and the number of flights it completes.", "The relevant tables are 'aircraft' for aircraft names and 'flight' for flight details.", "We will use a LEFT JOIN to combine the 'aircraft' table with the 'flight' table on the aircraft ID (aid).", "We will count the number of flights (flno) for each aircraft, which will give us the number of flights completed by each aircraft.", "Finally, we will group the results by the aircraft name to get the count for each individual aircraft."], "gold_sql": "SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid", "source_tables": ["aircraft", "flight"], "pred_sql": "SELECT aircraft.name, COUNT(flight.flno) AS flight_count \nFROM aircraft \nLEFT JOIN flight ON aircraft.aid = flight.aid \nGROUP BY aircraft.name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of flight origins from the 'Flight' table, grouped by the origin location. The results are ordered by the number of flights departing from each origin in descending order, with a limit on the number of origins returned as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT origin FROM Flight GROUP BY origin ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the starting locations of flights from the 'Flight' table that are headed to a specific destination. The placeholder in the WHERE clause represents the destination's name.\",\n        \"virtual_table\": \"SELECT origin FROM Flight WHERE destination  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average distance and average price of flights originating from a specific location. The placeholder in the WHERE clause represents the origin of the flights.\",\n        \"virtual_table\": \"SELECT avg(distance) ,  avg(price) FROM Flight WHERE origin  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.429", "db_id": "flight_1", "question": "Show names for all employees who do not have certificate of Boeing 737-800.", "rationale": ["Identify the table that contains employee names, which is the 'employee' table.", "We need to find employees who do not have a certificate for a specific aircraft, in this case, the 'Boeing 737-800'.", "To do this, we first need to find the 'aid' (aircraft ID) for the 'Boeing 737-800' from the 'aircraft' table.", "Next, we will find all 'eid' (employee IDs) from the 'certificate' table that correspond to the 'aid' of the 'Boeing 737-800'.", "Finally, we will select the names of employees from the 'employee' table whose 'eid' is not in the list of 'eid' obtained from the previous step."], "gold_sql": "SELECT name FROM Employee EXCEPT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  'Boeing 737-800'", "source_tables": ["employee", "certificate", "aircraft"], "pred_sql": "SELECT name FROM employee WHERE eid NOT IN (SELECT eid FROM certificate WHERE aid = (SELECT aid FROM aircraft WHERE name = 'Boeing 737-800'));", "hint": "\n"}
{"sample_id": "train.433", "db_id": "flight_1", "question": "Show the name and distance of the aircrafts with more than 5000 distance and which at least 5 people have its certificate.", "rationale": ["We need to select the name and distance of aircrafts.", "The relevant table for aircraft information is the 'aircraft' table, which contains the columns 'name' and 'distance'.", "We also need to consider the 'certificate' table to filter aircrafts that have at least 5 certificates.", "To find the aircrafts with more than 5000 distance, we will use a HAVING clause after grouping the results by aircraft ID (aid).", "We will join the 'aircraft' table with the 'certificate' table on the aircraft ID (aid) to count the number of certificates for each aircraft.", "Finally, we will apply the conditions: distance greater than 5000 and at least 5 certificates."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  5000 GROUP BY T1.aid ORDER BY count(*)  >=  5", "source_tables": ["aircraft", "certificate"], "pred_sql": "SELECT a.name, a.distance \nFROM aircraft a \nJOIN certificate c ON a.aid = c.aid \nGROUP BY a.aid \nHAVING a.distance > 5000 AND COUNT(c.eid) >= 5;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average distance and average price of flights originating from a specific location. The placeholder in the WHERE clause represents the origin of the flights.\",\n        \"virtual_table\": \"SELECT avg(distance) ,  avg(price) FROM Flight WHERE origin  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of flight origins from the 'Flight' table, grouped by the origin location. The results are ordered by the number of flights departing from each origin in descending order, with a limit on the number of origins returned as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT origin FROM Flight GROUP BY origin ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.434", "db_id": "flight_1", "question": "What is the name and distance of every aircraft that can cover a distance of more than 5000 and which at least 5 people can fly?", "rationale": ["Identify the relevant table: The question asks for information about aircraft, so we will use the 'aircraft' table.", "Determine the columns needed: We need the 'name' and 'distance' of the aircraft.", "Set the condition for distance: The question specifies that we want aircraft that can cover a distance of more than 5000.", "Construct the SQL query: We will select the 'name' and 'distance' from the 'aircraft' table where the 'distance' is greater than 5000."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  5000 GROUP BY T1.aid ORDER BY count(*)  >=  5", "source_tables": ["aircraft", "certificate"], "pred_sql": "SELECT name, distance FROM aircraft WHERE distance > 5000", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average distance and average price of flights originating from a specific location. The placeholder in the WHERE clause represents the origin of the flights.\",\n        \"virtual_table\": \"SELECT avg(distance) ,  avg(price) FROM Flight WHERE origin  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of flight origins from the 'Flight' table, grouped by the origin location. The results are ordered by the number of flights departing from each origin in descending order, with a limit on the number of origins returned as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT origin FROM Flight GROUP BY origin ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the starting locations of flights from the 'Flight' table that are headed to a specific destination. The placeholder in the WHERE clause represents the destination's name.\",\n        \"virtual_table\": \"SELECT origin FROM Flight WHERE destination  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.437", "db_id": "flight_1", "question": "What is the salary and name of the employee who has the most number of certificates on aircrafts with distance more than 5000?", "rationale": ["Identify the tables needed: employee, certificate, and aircraft.", "We need to join these tables to get the employee's name and salary along with the aircraft distance.", "The condition specifies that we only want aircraft with a distance greater than 5000, so we will filter on the aircraft table.", "We need to count the number of certificates each employee has, so we will group by employee ID.", "To find the employee with the most certificates, we will order the results by the count of certificates in descending order.", "Finally, we will limit the results to just one employee, which will give us the one with the most certificates."], "gold_sql": "SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  5000 GROUP BY T1.eid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employee", "certificate", "aircraft"], "pred_sql": "SELECT e.name, e.salary\nFROM employee e\nJOIN certificate c ON e.eid = c.eid\nJOIN aircraft a ON c.aid = a.aid\nWHERE a.distance > 5000\nGROUP BY e.eid\nORDER BY COUNT(c.aid) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average distance and average price of flights originating from a specific location. The placeholder in the WHERE clause represents the origin of the flights.\",\n        \"virtual_table\": \"SELECT avg(distance) ,  avg(price) FROM Flight WHERE origin  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.448", "db_id": "allergy_1", "question": "What are all the different food allergies?", "rationale": ["The question asks for all the different food allergies, which implies we need to retrieve unique allergy names.", "We will use the 'Has_Allergy' table since it contains the allergies associated with students.", "To get distinct allergy names, we will use the SELECT DISTINCT statement on the 'Allergy' column from the 'Has_Allergy' table."], "gold_sql": "SELECT DISTINCT allergy FROM Allergy_type WHERE allergytype  =  'food'", "source_tables": ["allergy_type"], "pred_sql": "SELECT DISTINCT Allergy FROM Has_Allergy", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\",\n        \"virtual_table\": \"SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.\",\n        \"virtual_table\": \"SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the type or category of a specific allergy from the 'Allergy_Type' table. The placeholder in the WHERE clause represents the name of the allergy being queried.\",\n        \"virtual_table\": \"SELECT allergytype FROM Allergy_type WHERE allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.456", "db_id": "allergy_1", "question": "Which allergy type is most common?", "rationale": ["The question asks for the most common allergy type.", "To find the most common allergy type, we need to count how many times each allergy type appears in the Has_Allergy table.", "We will join the Has_Allergy table with the Allergy_Type table on the Allergy column to get the corresponding AllergyType for each allergy.", "We will use COUNT(*) to count the occurrences of each AllergyType.", "We will group the results by AllergyType to aggregate the counts for each type.", "Finally, we will order the results in descending order based on the count and limit the results to 1 to get the most common allergy type."], "gold_sql": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT 1", "source_tables": ["allergy_type"], "pred_sql": "SELECT AllergyType, COUNT(*) as AllergyCount FROM Has_Allergy JOIN Allergy_Type ON Has_Allergy.Allergy = Allergy_Type.Allergy GROUP BY AllergyType ORDER BY AllergyCount DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\",\n        \"virtual_table\": \"SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the type or category of a specific allergy from the 'Allergy_Type' table. The placeholder in the WHERE clause represents the name of the allergy being queried.\",\n        \"virtual_table\": \"SELECT allergytype FROM Allergy_type WHERE allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of distinct allergy types from the 'Allergy_Type' table. The result will indicate how many unique categories of allergies are present in the database.\",\n        \"virtual_table\": \"SELECT count(DISTINCT allergytype) FROM Allergy_type\"\n    }\n}\n"}
{"sample_id": "train.458", "db_id": "allergy_1", "question": "Which allergy type is the least common?", "rationale": ["Identify the need to find the least common allergy type.", "To find the least common allergy, we need to count the occurrences of each allergy in the Has_Allergy table.", "We will group the allergies by their name and order them by the count in ascending order to get the least common allergy.", "We will limit the result to 1 to get only the least common allergy.", "Once we have the least common allergy, we will use it to find its corresponding type from the Allergy_Type table."], "gold_sql": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) ASC LIMIT 1", "source_tables": ["allergy_type"], "pred_sql": "SELECT AllergyType FROM Allergy_Type WHERE Allergy IN (SELECT Allergy FROM Has_Allergy GROUP BY Allergy ORDER BY COUNT(*) ASC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\",\n        \"virtual_table\": \"SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the type or category of a specific allergy from the 'Allergy_Type' table. The placeholder in the WHERE clause represents the name of the allergy being queried.\",\n        \"virtual_table\": \"SELECT allergytype FROM Allergy_type WHERE allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of distinct allergy types from the 'Allergy_Type' table. The result will indicate how many unique categories of allergies are present in the database.\",\n        \"virtual_table\": \"SELECT count(DISTINCT allergytype) FROM Allergy_type\"\n    }\n}\n"}
{"sample_id": "train.462", "db_id": "allergy_1", "question": "What are the full names of all students", "rationale": ["Identify the required information: full names of all students, which includes first names and last names.", "Determine the relevant table: the 'Student' table contains the necessary columns (Fname and Lname).", "Construct the SQL query to select the first name (Fname) and last name (Lname) from the 'Student' table without any conditions, as we want all students."], "gold_sql": "SELECT Fname ,  Lname FROM Student", "source_tables": ["student"], "pred_sql": "SELECT Fname, Lname FROM Student", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first name, last name, and age of students from the 'Student' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the students.\",\n        \"virtual_table\": \"SELECT Fname ,  Lname ,  Age FROM Student WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.472", "db_id": "allergy_1", "question": "What are the student ids for all male students?", "rationale": ["Identify the relevant table: The 'Student' table contains the information about students, including their gender.", "Determine the required information: We need the student IDs (StuID) for all male students.", "Construct the SQL query: Use a SELECT statement to retrieve the StuID from the Student table where the Sex is 'Male'."], "gold_sql": "SELECT StuID FROM Student WHERE Sex  =  'M'", "source_tables": ["student"], "pred_sql": "SELECT StuID FROM Student WHERE Sex = 'Male'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the unique identifiers of students from the 'Student' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the students.\",\n        \"virtual_table\": \"SELECT StuID FROM Student WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first name, last name, and age of students from the 'Student' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the students.\",\n        \"virtual_table\": \"SELECT Fname ,  Lname ,  Age FROM Student WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.492", "db_id": "allergy_1", "question": "What is the largest major?", "rationale": ["Identify the table that contains the majors, which is the 'Student' table.", "We need to group the results by the 'Major' column to count how many students are in each major.", "Order the results in descending order based on the count of students in each major to find the largest major.", "Limit the results to 1 to get only the largest major."], "gold_sql": "SELECT major FROM Student GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Major FROM Student GROUP BY Major ORDER BY COUNT(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of academic majors from the 'Student' table, grouped by the major and ordered by the number of students in each major in descending order. The placeholder in the LIMIT clause represents the maximum number of majors to return.\",\n        \"virtual_table\": \"SELECT major FROM Student GROUP BY major ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.501", "db_id": "allergy_1", "question": "Which advisor has most number of students?", "rationale": ["Identify the relevant table: The 'Student' table contains information about students and their advisors.", "Determine the required information: We need to find out which advisor has the most students.", "Use the COUNT function: To count the number of students for each advisor, we will use COUNT(*) in the SELECT statement.", "Group the results: We will group the results by the advisor's name using GROUP BY Advisor.", "Order the results: To find the advisor with the most students, we will order the results in descending order based on the count of students.", "Limit the results: Since we only want the advisor with the most students, we will limit the results to 1."], "gold_sql": "SELECT advisor FROM Student GROUP BY advisor ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Advisor, COUNT(*) as StudentCount FROM Student GROUP BY Advisor ORDER BY StudentCount DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of academic advisors from the 'Student' table, grouped by the advisor's name. The results are ordered by the number of students assigned to each advisor in descending order, with a limit on the number of advisors returned, specified by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT advisor FROM Student GROUP BY advisor ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.504", "db_id": "allergy_1", "question": "How many students are affected by cat allergies?", "rationale": ["Identify the relevant table: The 'Has_Allergy' table contains information about which students have which allergies.", "Determine the specific allergy of interest: The question asks about students affected by cat allergies.", "Construct the SQL query: Use the COUNT function to count the number of entries in the 'Has_Allergy' table where the Allergy column matches 'cat'."], "gold_sql": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  'Cat'", "source_tables": ["has_allergy"], "pred_sql": "SELECT count(*) FROM Has_Allergy WHERE Allergy = 'cat'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of students who have a specific allergy from the 'Has_Allergy' table. The placeholder in the WHERE clause represents the name of the allergy.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of distinct allergy types from the 'Allergy_Type' table. The result will indicate how many unique categories of allergies are present in the database.\",\n        \"virtual_table\": \"SELECT count(DISTINCT allergytype) FROM Allergy_type\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\",\n        \"virtual_table\": \"SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.508", "db_id": "allergy_1", "question": "Which students are unaffected by allergies?", "rationale": ["To find students who are unaffected by allergies, we need to identify students who do not have any entries in the 'Has_Allergy' table.", "We can achieve this by selecting all students from the 'Student' table where their 'StuID' is not present in the 'StuID' column of the 'Has_Allergy' table.", "The SQL query uses a subquery to select all 'StuID' from 'Has_Allergy' and checks for those not in that list."], "gold_sql": "SELECT StuID FROM Student EXCEPT SELECT StuID FROM Has_allergy", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT * FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_Allergy);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of students who have a specific allergy from the 'Has_Allergy' table. The placeholder in the WHERE clause represents the name of the allergy.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\",\n        \"virtual_table\": \"SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.\",\n        \"virtual_table\": \"SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.509", "db_id": "allergy_1", "question": "How many female students have milk or egg allergies?", "rationale": ["We need to count the number of female students with specific allergies (milk or egg).", "To do this, we will join the 'Student' table with the 'Has_Allergy' table on the 'StuID' column, which is the unique identifier for students.", "We will filter the results to include only female students by adding a condition in the WHERE clause: s.Sex = 'Female'.", "Next, we will specify the allergies we are interested in (milk and egg) using the IN clause: ha.Allergy IN ('milk', 'egg').", "Finally, we will use COUNT(*) to get the total number of records that meet these criteria."], "gold_sql": "SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  'F' AND T1.allergy  =  'Milk' OR T1.allergy  =  'Eggs'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT COUNT(*) FROM Student s JOIN Has_Allergy ha ON s.StuID = ha.StuID WHERE s.Sex = 'Female' AND ha.Allergy IN ('milk', 'egg');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of students who have a specific allergy from the 'Has_Allergy' table. The placeholder in the WHERE clause represents the name of the allergy.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.\",\n        \"virtual_table\": \"SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\",\n        \"virtual_table\": \"SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.510", "db_id": "allergy_1", "question": "How many students who are female are allergic to milk or eggs?", "rationale": ["Identify the tables needed: We need to count students, so we will use the 'Student' table and the 'Has_Allergy' table to find students with specific allergies.", "We need to filter for female students, which requires checking the 'Sex' column in the 'Student' table.", "We are interested in students who are allergic to either milk or eggs, so we will use the 'IN' clause to specify these allergies in the 'Has_Allergy' table.", "We will join the 'Student' table with the 'Has_Allergy' table on the 'StuID' column to link students with their allergies.", "Finally, we will count the number of records that meet these criteria."], "gold_sql": "SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  'F' AND T1.allergy  =  'Milk' OR T1.allergy  =  'Eggs'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT COUNT(*) \nFROM Student \nJOIN Has_Allergy ON Student.StuID = Has_Allergy.StuID \nWHERE Student.Sex = 'Female' \nAND Has_Allergy.Allergy IN ('milk', 'eggs');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of students who have a specific allergy from the 'Has_Allergy' table. The placeholder in the WHERE clause represents the name of the allergy.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.\",\n        \"virtual_table\": \"SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\",\n        \"virtual_table\": \"SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.513", "db_id": "allergy_1", "question": "Which allergy has most number of students affected?", "rationale": ["We need to find out which allergy has the most number of students affected.", "To do this, we will query the 'Has_Allergy' table.", "We will group the results by the 'Allergy' column to count how many students have each allergy.", "Next, we will order the results in descending order based on the count of students for each allergy.", "Finally, we will limit the results to just one entry to get the allergy with the highest count."], "gold_sql": "SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT 1", "source_tables": ["has_allergy"], "pred_sql": "SELECT Allergy FROM Has_Allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of students who have a specific allergy from the 'Has_Allergy' table. The placeholder in the WHERE clause represents the name of the allergy.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\",\n        \"virtual_table\": \"SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.\",\n        \"virtual_table\": \"SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.518", "db_id": "allergy_1", "question": "How many students are affected by each allergy type?", "rationale": ["Identify the tables involved: Allergy_Type for allergy types and Has_Allergy for student allergies.", "We need to count the number of students affected by each allergy type, which requires joining the Allergy_Type table with the Has_Allergy table on the Allergy column.", "Use a LEFT JOIN to ensure we include all allergy types even if no students have that allergy.", "Group the results by AllergyType to get the count of students for each type.", "Count the number of distinct StuID from Has_Allergy for each AllergyType.", "Order the results by the count of students in descending order to see the most affected allergy types first."], "gold_sql": "SELECT T2.allergytype ,  count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy GROUP BY T2.allergytype", "source_tables": ["has_allergy", "allergy_type"], "pred_sql": "SELECT at.AllergyType, COUNT(ha.StuID) AS StudentCount\nFROM Allergy_Type at\nLEFT JOIN Has_Allergy ha ON at.Allergy = ha.Allergy\nGROUP BY at.AllergyType\nORDER BY StudentCount DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\",\n        \"virtual_table\": \"SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of students who have a specific allergy from the 'Has_Allergy' table. The placeholder in the WHERE clause represents the name of the allergy.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of distinct allergy types from the 'Allergy_Type' table. The result will indicate how many unique categories of allergies are present in the database.\",\n        \"virtual_table\": \"SELECT count(DISTINCT allergytype) FROM Allergy_type\"\n    }\n}\n"}
{"sample_id": "train.520", "db_id": "allergy_1", "question": "What are the last names and ages of the students who are allergic to milk and cat?", "rationale": ["Identify the tables needed: We need to retrieve student information (last names and ages) and their allergies, so we will use the Student and Has_Allergy tables.", "Determine the relationship: The Student table is linked to the Has_Allergy table through the StuID column, which is a foreign key in Has_Allergy.", "Select the required columns: We need to select the last names (LName) and ages (Age) of the students.", "Filter the results: We need to filter the students who have allergies to 'milk' and 'cat'. This can be done using a WHERE clause with the IN operator.", "Group the results: Since we are selecting from the Student table and joining with Has_Allergy, we should group by Student.StuID to avoid duplicates in the results."], "gold_sql": "SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT Student.LName, Student.Age \nFROM Student \nJOIN Has_Allergy ON Student.StuID = Has_Allergy.StuID \nWHERE Has_Allergy.Allergy IN ('milk', 'cat') \nGROUP BY Student.StuID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of students who have a specific allergy from the 'Has_Allergy' table. The placeholder in the WHERE clause represents the name of the allergy.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.\",\n        \"virtual_table\": \"SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\",\n        \"virtual_table\": \"SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.522", "db_id": "allergy_1", "question": "What are the allergies the girl named Lisa has? And what are the types of them? Order the result by allergy names.", "rationale": ["Identify the relevant tables: Student, Has_Allergy, and Allergy_Type.", "We need to find allergies for a student named Lisa, so we will filter the Student table by first name (Fname) and gender (Sex).", "Join the Has_Allergy table to get the allergies associated with the student using StuID.", "Join the Allergy_Type table to get the type of each allergy using the Allergy name.", "Select the Allergy name and its corresponding AllergyType.", "Order the results by the Allergy name."], "gold_sql": "SELECT T1.Allergy ,  T1.AllergyType FROM Allergy_type AS T1 JOIN Has_allergy AS T2 ON T1.Allergy  =  T2.Allergy JOIN Student AS T3 ON T3.StuID  =  T2.StuID WHERE T3.Fname  =  'Lisa' ORDER BY T1.Allergy", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT a.Allergy, at.AllergyType \nFROM Student s \nJOIN Has_Allergy a ON s.StuID = a.StuID \nJOIN Allergy_Type at ON a.Allergy = at.Allergy \nWHERE s.Fname = 'Lisa' AND s.Sex = 'Female' \nORDER BY a.Allergy;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\",\n        \"virtual_table\": \"SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.\",\n        \"virtual_table\": \"SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the type or category of a specific allergy from the 'Allergy_Type' table. The placeholder in the WHERE clause represents the name of the allergy being queried.\",\n        \"virtual_table\": \"SELECT allergytype FROM Allergy_type WHERE allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.525", "db_id": "allergy_1", "question": "Find the average age of the students who have allergies with food and animal types.", "rationale": ["Identify the tables involved: We need to get the average age of students, so we will primarily use the 'Student' table and the 'Has_Allergy' table to filter students based on their allergies.", "Determine the allergies of interest: We are looking for students with allergies categorized as 'food' and 'animal'. This requires a subquery to filter allergies from the 'Allergy_Type' table.", "Construct the subquery to find relevant allergies: We will select the 'Allergy' names from the 'Allergy_Type' table where the 'AllergyType' is either 'food' or 'animal'.", "Filter students based on allergies: We will use the 'Has_Allergy' table to find 'StuID's of students who have the specified allergies.", "Calculate the average age: Finally, we will calculate the average age of the filtered students by using the AVG function on the 'Age' column from the 'Student' table."], "gold_sql": "SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food' INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'animal')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT AVG(CAST(Age AS INTEGER)) AS average_age \nFROM Student \nWHERE StuID IN (\n    SELECT StuID \n    FROM Has_Allergy \n    WHERE Allergy IN (\n        SELECT Allergy \n        FROM Allergy_Type \n        WHERE AllergyType IN ('food', 'animal')\n    )\n);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\",\n        \"virtual_table\": \"SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of students who have a specific allergy from the 'Has_Allergy' table. The placeholder in the WHERE clause represents the name of the allergy.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of distinct allergy types from the 'Allergy_Type' table. The result will indicate how many unique categories of allergies are present in the database.\",\n        \"virtual_table\": \"SELECT count(DISTINCT allergytype) FROM Allergy_type\"\n    }\n}\n"}
{"sample_id": "train.527", "db_id": "allergy_1", "question": "List the first and last name of the students who do not have any food type allergy.", "rationale": ["Identify the tables involved: We need to retrieve student names from the 'Student' table and check their allergies in the 'Has_Allergy' table.", "We need to find students who do not have any food type allergies. This requires us to first identify which allergies are categorized as 'Food' in the 'Allergy_Type' table.", "We can use a subquery to get the list of allergies that are of type 'Food'.", "Next, we will find all students who have any of these food allergies by checking the 'Has_Allergy' table.", "Finally, we will select the first and last names of students from the 'Student' table whose IDs are not in the list of students with food allergies."], "gold_sql": "SELECT fname ,  lname FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT Fname, LName FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_Allergy WHERE Allergy IN (SELECT Allergy FROM Allergy_Type WHERE AllergyType = 'Food'));", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\",\n        \"virtual_table\": \"SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.\",\n        \"virtual_table\": \"SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of students who have a specific allergy from the 'Has_Allergy' table. The placeholder in the WHERE clause represents the name of the allergy.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.529", "db_id": "allergy_1", "question": "Find the number of male (sex is 'M') students who have some food type allery.", "rationale": ["Identify the tables needed: We need to access the Student, Has_Allergy, and Allergy_Type tables to get the required information about students and their allergies.", "We need to filter students based on their sex, specifically male students (Sex = 'M').", "We need to find students who have a specific type of allergy, which in this case is food allergies. This requires joining the Has_Allergy table with the Allergy_Type table to filter by AllergyType.", "We will use a JOIN operation to combine the Student table with the Has_Allergy table on StuID, and then join with the Allergy_Type table on Allergy.", "Finally, we will count the distinct StuID values to get the number of unique male students with food allergies."], "gold_sql": "SELECT count(*) FROM Student WHERE sex  =  'M' AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT COUNT(DISTINCT s.StuID) \nFROM Student s \nJOIN Has_Allergy ha ON s.StuID = ha.StuID \nJOIN Allergy_Type at ON ha.Allergy = at.Allergy \nWHERE s.Sex = 'M' AND at.AllergyType = 'Food';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of students who have a specific allergy from the 'Has_Allergy' table. The placeholder in the WHERE clause represents the name of the allergy.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of distinct allergy types from the 'Allergy_Type' table. The result will indicate how many unique categories of allergies are present in the database.\",\n        \"virtual_table\": \"SELECT count(DISTINCT allergytype) FROM Allergy_type\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of different allergies categorized under a specific type from the 'Allergy_Type' table. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Allergy_type WHERE allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.531", "db_id": "allergy_1", "question": "Find the different first names and cities of the students who have allergy to milk or cat.", "rationale": ["Identify the tables needed: We need data from the Student and Has_Allergy tables.", "Determine the columns to select: We want distinct first names (Fname) and city codes (city_code) of students.", "Establish the relationship: We need to join the Student table with the Has_Allergy table on the StuID column.", "Filter the results: We need to find students who have allergies to either 'milk' or 'cat'.", "Construct the SQL query using SELECT, JOIN, and WHERE clauses."], "gold_sql": "SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  'Milk' OR T2.Allergy  =  'Cat'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT DISTINCT Student.Fname, Student.city_code \nFROM Student \nJOIN Has_Allergy ON Student.StuID = Has_Allergy.StuID \nWHERE Has_Allergy.Allergy IN ('milk', 'cat');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.\",\n        \"virtual_table\": \"SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of students who have a specific allergy from the 'Has_Allergy' table. The placeholder in the WHERE clause represents the name of the allergy.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\",\n        \"virtual_table\": \"SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.533", "db_id": "allergy_1", "question": "Find the number of students who are older than 18 and do not have allergy to either food or animal.", "rationale": ["Identify the main requirement: count students older than 18 without allergies to food or animals.", "Use the Student table to filter students based on age.", "Use a subquery to find students who have allergies to either food or animals.", "The subquery selects StuID from Has_Allergy where the Allergy is either 'food' or 'animal'.", "The main query counts all students whose StuID is not in the result of the subquery, ensuring they do not have the specified allergies."], "gold_sql": "SELECT count(*) FROM Student WHERE age  >  18 AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food' OR T2.allergytype  =  'animal')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT COUNT(*) FROM Student WHERE Age > 18 AND StuID NOT IN (SELECT StuID FROM Has_Allergy WHERE Allergy IN ('food', 'animal'));", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of students who have a specific allergy from the 'Has_Allergy' table. The placeholder in the WHERE clause represents the name of the allergy.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of distinct allergy types from the 'Allergy_Type' table. The result will indicate how many unique categories of allergies are present in the database.\",\n        \"virtual_table\": \"SELECT count(DISTINCT allergytype) FROM Allergy_type\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.\",\n        \"virtual_table\": \"SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.535", "db_id": "allergy_1", "question": "Find the first name and major of the students who are not allegry to soy.", "rationale": ["Identify the required fields: first name (Fname) and major from the Student table.", "Determine the condition: students who do not have an allergy to soy.", "To find students without the soy allergy, we can use a subquery to select all StuID from the Has_Allergy table where the Allergy is 'soy'.", "Use the NOT IN clause to filter out those students from the main query that selects from the Student table."], "gold_sql": "SELECT fname ,  major FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Soy')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT Fname, Major FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_Allergy WHERE Allergy = 'soy')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first name, last name, and age of students from the 'Student' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the students.\",\n        \"virtual_table\": \"SELECT Fname ,  Lname ,  Age FROM Student WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.542", "db_id": "store_1", "question": "What are the names of the countries and average invoice size of the top countries by size?", "rationale": ["We need to find the names of the countries and the average invoice size.", "The relevant table for this information is the 'invoices' table, which contains the 'billing_country' and 'total' columns.", "To calculate the average invoice size for each country, we will use the AVG() function on the 'total' column.", "We will group the results by 'billing_country' to get the average for each country.", "Finally, we will order the results by average invoice size in descending order to get the top countries by size."], "gold_sql": "SELECT billing_country ,  AVG(total) FROM invoices GROUP BY billing_country ORDER BY AVG(total) DESC LIMIT 10;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_country, AVG(total) AS average_invoice_size\nFROM invoices\nGROUP BY billing_country\nORDER BY average_invoice_size DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of invoices and the total amount billed for a specific billing state from the 'invoices' table. The placeholder in the WHERE clause represents the billing state being queried.\",\n        \"virtual_table\": \"SELECT billing_state ,  COUNT(*) ,  SUM(total) FROM invoices WHERE billing_state  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.553", "db_id": "store_1", "question": "List every album ordered by album title in ascending order.", "rationale": ["Identify the table needed: The question asks for albums, so we will use the 'albums' table.", "Determine the columns to select: We need to list every album, which means we will select the 'title' column from the 'albums' table.", "Specify the order: The question specifies that the albums should be ordered by album title in ascending order, so we will use 'ORDER BY title ASC'.", "Construct the SQL query: Combine the selected column and the ordering clause to form the complete SQL query."], "gold_sql": "SELECT title FROM albums ORDER BY title;", "source_tables": ["albums"], "pred_sql": "SELECT title FROM albums ORDER BY title ASC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the titles of albums from the 'albums' table that match a specific pattern. The placeholder in the WHERE clause represents the title pattern to search for, allowing for flexible querying of album titles.\",\n        \"virtual_table\": \"SELECT title FROM albums WHERE title LIKE [PLACEHOLDER-TYPE:STRING] ORDER BY title;\"\n    }\n}\n"}
{"sample_id": "train.560", "db_id": "store_1", "question": "What are the total amount of money in the invoices billed from Chicago, Illinois?", "rationale": ["Identify the relevant table: The 'invoices' table contains the billing information including city and state.", "Determine the required fields: We need to count the total number of invoices and sum the total amount billed.", "Apply the necessary filters: We need to filter the invoices where the billing city is 'Chicago' and the billing state is 'Illinois'.", "Construct the SQL query: Using the SELECT statement to get the count and sum from the invoices table with the specified conditions."], "gold_sql": "SELECT sum(total) FROM invoices WHERE billing_city  =  'Chicago' AND billing_state  =  'IL';", "source_tables": ["invoices"], "pred_sql": "SELECT COUNT(*) AS total_invoices, SUM(total) AS total_amount FROM invoices WHERE billing_city = 'Chicago' AND billing_state = 'Illinois';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of invoices and the total amount billed for a specific billing state from the 'invoices' table. The placeholder in the WHERE clause represents the billing state being queried.\",\n        \"virtual_table\": \"SELECT billing_state ,  COUNT(*) ,  SUM(total) FROM invoices WHERE billing_state  =  [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the total number of customers from the 'customers' table who reside in a specific state. The placeholder in the WHERE clause represents the state name.\",\n        \"virtual_table\": \"SELECT count(*) FROM customers WHERE state = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.564", "db_id": "store_1", "question": "How many invoices were billed from each state?", "rationale": ["The question asks for the number of invoices billed from each state, which means we need to group the invoices by their billing state.", "We will use the 'invoices' table, which contains the 'billing_state' and 'id' of each invoice.", "To get the count of invoices for each state, we will use the COUNT() function.", "We will group the results by 'billing_state' to get the count for each state.", "The final SQL query will select the 'billing_state' and the count of invoices, using GROUP BY to aggregate the results."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_state, COUNT(*) AS invoice_count FROM invoices GROUP BY billing_state;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of invoices and the total amount billed for a specific billing state from the 'invoices' table. The placeholder in the WHERE clause represents the billing state being queried.\",\n        \"virtual_table\": \"SELECT billing_state ,  COUNT(*) ,  SUM(total) FROM invoices WHERE billing_state  =  [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the total number of customers from the 'customers' table who reside in a specific state. The placeholder in the WHERE clause represents the state name.\",\n        \"virtual_table\": \"SELECT count(*) FROM customers WHERE state = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.565", "db_id": "store_1", "question": "List the state in the US with the most invoices.", "rationale": ["We need to find the state in the US with the most invoices.", "To do this, we will query the 'invoices' table.", "We will group the results by 'billing_state' to count the number of invoices for each state.", "We will use the COUNT(*) function to count the number of invoices per state.", "To get the state with the most invoices, we will order the results in descending order based on the count of invoices.", "Finally, we will limit the results to 1 to get only the state with the highest count."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT 1;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_state, COUNT(*) AS invoice_count \nFROM invoices \nGROUP BY billing_state \nORDER BY invoice_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of invoices and the total amount billed for a specific billing state from the 'invoices' table. The placeholder in the WHERE clause represents the billing state being queried.\",\n        \"virtual_table\": \"SELECT billing_state ,  COUNT(*) ,  SUM(total) FROM invoices WHERE billing_state  =  [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the total number of customers from the 'customers' table who reside in a specific state. The placeholder in the WHERE clause represents the state name.\",\n        \"virtual_table\": \"SELECT count(*) FROM customers WHERE state = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.566", "db_id": "store_1", "question": "What are the states with the most invoices?", "rationale": ["Identify the relevant table: The 'invoices' table contains the billing state information and the invoice data.", "Group the results by 'billing_state' to count the number of invoices per state.", "Use the COUNT function to count the number of invoices for each state.", "Order the results in descending order to find the states with the most invoices."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT 1;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_state, COUNT(*) AS invoice_count \nFROM invoices \nGROUP BY billing_state \nORDER BY invoice_count DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of invoices and the total amount billed for a specific billing state from the 'invoices' table. The placeholder in the WHERE clause represents the billing state being queried.\",\n        \"virtual_table\": \"SELECT billing_state ,  COUNT(*) ,  SUM(total) FROM invoices WHERE billing_state  =  [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the total number of customers from the 'customers' table who reside in a specific state. The placeholder in the WHERE clause represents the state name.\",\n        \"virtual_table\": \"SELECT count(*) FROM customers WHERE state = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.567", "db_id": "store_1", "question": "List the number of invoices and the invoice total from California.", "rationale": ["The task is to list the number of invoices and the total invoice amount from California.", "We need to focus on the 'invoices' table since it contains the relevant information about invoices and their totals.", "The hint provides a virtual table that summarizes the total number of invoices and the total amount billed for a specific billing state.", "We will use the provided virtual table structure and replace the placeholder with 'California' to filter the results accordingly.", "The final SQL query will select the billing state, count the number of invoices, and sum the total amount for invoices where the billing state is 'California'."], "gold_sql": "SELECT billing_state ,  COUNT(*) ,  SUM(total) FROM invoices WHERE billing_state  =  'CA';", "source_tables": ["invoices"], "pred_sql": "SELECT billing_state, COUNT(*) AS number_of_invoices, SUM(total) AS total_invoice_amount FROM invoices WHERE billing_state = 'California';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of invoices and the total amount billed for a specific billing state from the 'invoices' table. The placeholder in the WHERE clause represents the billing state being queried.\",\n        \"virtual_table\": \"SELECT billing_state ,  COUNT(*) ,  SUM(total) FROM invoices WHERE billing_state  =  [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the total number of customers from the 'customers' table who reside in a specific state. The placeholder in the WHERE clause represents the state name.\",\n        \"virtual_table\": \"SELECT count(*) FROM customers WHERE state = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.575", "db_id": "store_1", "question": "What is Astrid Gruber's email and phone number?", "rationale": ["Identify the relevant table: The 'employees' table contains the information needed (email and phone number).", "Determine the specific employee: The question asks for Astrid Gruber, so we need to filter the results based on the first name 'Astrid' and last name 'Gruber'.", "Construct the SQL query: Using the SELECT statement to retrieve the 'email' and 'phone' columns from the 'employees' table, and applying a WHERE clause to filter by the specified first and last names."], "gold_sql": "SELECT email ,  phone FROM customers WHERE first_name = 'Astrid' AND last_name = 'Gruber';", "source_tables": ["customers"], "pred_sql": "SELECT email, phone FROM employees WHERE first_name = 'Astrid' AND last_name = 'Gruber';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the titles, phone numbers, and hire dates of employees from the 'employees' table who have a specific first and last name. The placeholders in the WHERE clause represent the first and last names of the employee.\",\n        \"virtual_table\": \"SELECT title ,  phone ,  hire_date FROM employees WHERE first_name = [PLACEHOLDER-TYPE:STRING] AND last_name = [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the addresses of employees from the 'employees' table based on their first and last names. The placeholders in the WHERE clause represent the specific first and last names of the employees being queried.\",\n        \"virtual_table\": \"SELECT address FROM employees WHERE first_name = [PLACEHOLDER-TYPE:STRING] AND last_name = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.593", "db_id": "store_1", "question": "Find the full name of employee who supported the most number of customers.", "rationale": ["We need to find the employee who supported the most number of customers.", "To do this, we will first count the number of customers for each support representative in the 'customers' table.", "We will group the results by 'support_rep_id' and order them in descending order to find the top support representative.", "We will limit the results to 1 to get the employee with the highest count.", "Next, we will join this result with the 'employees' table to get the first and last name of the employee.", "Finally, we will select the first and last name of the employee who is the top support representative."], "gold_sql": "SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employees", "customers"], "pred_sql": "SELECT e.first_name, e.last_name \nFROM employees e \nJOIN (SELECT support_rep_id, COUNT(*) as customer_count \n      FROM customers \n      GROUP BY support_rep_id \n      ORDER BY customer_count DESC \n      LIMIT 1) AS top_support ON e.id = top_support.support_rep_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of employees and their managers from the 'employees' table. It lists the first and last names of managers along with the count of employees reporting to each manager. The results are grouped by the manager's identifier and ordered by the number of reports in descending order, with a limit on the number of results specified by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T2.first_name , T2.last_name ,  count(T1.reports_to) FROM employees AS T1 JOIN employees AS T2 ON T1.reports_to = T2.id GROUP BY T1.reports_to ORDER BY count(T1.reports_to) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first and last names of employees who report to a specific manager from the 'employees' table. The placeholders in the WHERE clause represent the first and last names of the manager.\",\n        \"virtual_table\": \"SELECT T2.first_name , T2.last_name FROM employees AS T1 JOIN employees AS T2 ON T1.id = T2.reports_to WHERE T1.first_name = [PLACEHOLDER-TYPE:STRING] AND T1.last_name = [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the total number of customers from the 'customers' table who reside in a specific state. The placeholder in the WHERE clause represents the state name.\",\n        \"virtual_table\": \"SELECT count(*) FROM customers WHERE state = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.594", "db_id": "store_1", "question": "What is the full name of the employee who has the most customers?", "rationale": ["Identify the employees and their managers using a self-join on the employees table.", "Count the number of employees reporting to each manager using GROUP BY and ORDER BY to find the manager with the most reports.", "Limit the results to the top manager with the most reports.", "Join this result back to the employees table to get the full name of the employee who has the most customers."], "gold_sql": "SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employees", "customers"], "pred_sql": "SELECT e.first_name, e.last_name \nFROM employees e \nJOIN (\n    SELECT T2.first_name, T2.last_name, count(T1.reports_to) AS customer_count \n    FROM employees AS T1 \n    JOIN employees AS T2 ON T1.reports_to = T2.id \n    GROUP BY T1.reports_to \n    ORDER BY customer_count DESC \n    LIMIT 1\n) AS most_customers ON e.first_name = most_customers.first_name AND e.last_name = most_customers.last_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the titles, phone numbers, and hire dates of employees from the 'employees' table who have a specific first and last name. The placeholders in the WHERE clause represent the first and last names of the employee.\",\n        \"virtual_table\": \"SELECT title ,  phone ,  hire_date FROM employees WHERE first_name = [PLACEHOLDER-TYPE:STRING] AND last_name = [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first and last names of employees who report to a specific manager from the 'employees' table. The placeholders in the WHERE clause represent the first and last names of the manager.\",\n        \"virtual_table\": \"SELECT T2.first_name , T2.last_name FROM employees AS T1 JOIN employees AS T2 ON T1.id = T2.reports_to WHERE T1.first_name = [PLACEHOLDER-TYPE:STRING] AND T1.last_name = [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of employees and their managers from the 'employees' table. It lists the first and last names of managers along with the count of employees reporting to each manager. The results are grouped by the manager's identifier and ordered by the number of reports in descending order, with a limit on the number of results specified by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T2.first_name , T2.last_name ,  count(T1.reports_to) FROM employees AS T1 JOIN employees AS T2 ON T1.reports_to = T2.id GROUP BY T1.reports_to ORDER BY count(T1.reports_to) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.604", "db_id": "store_1", "question": "How many employees who are IT staff are from each city?", "rationale": ["Identify the relevant table: The 'employees' table contains information about employees, including their job titles and cities.", "Filter the employees: We need to focus on employees who are specifically in the IT staff category, which is indicated by the 'title' column.", "Group the results: To find out how many IT staff are from each city, we will group the results by the 'city' column.", "Count the employees: For each city, we will count the number of employees who meet the criteria.", "Construct the SQL query: Combine the SELECT statement with the WHERE clause for filtering, GROUP BY for aggregation, and COUNT for counting the employees."], "gold_sql": "SELECT count(*) ,  city FROM employees WHERE title  =  'IT Staff' GROUP BY city", "source_tables": ["employees"], "pred_sql": "SELECT city, COUNT(*) AS employee_count \nFROM employees \nWHERE title = 'IT staff' \nGROUP BY city;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of employees and their managers from the 'employees' table. It lists the first and last names of managers along with the count of employees reporting to each manager. The results are grouped by the manager's identifier and ordered by the number of reports in descending order, with a limit on the number of results specified by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T2.first_name , T2.last_name ,  count(T1.reports_to) FROM employees AS T1 JOIN employees AS T2 ON T1.reports_to = T2.id GROUP BY T1.reports_to ORDER BY count(T1.reports_to) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.624", "db_id": "store_1", "question": "What is the name of the album that has the track Ball to the Wall?", "rationale": ["Identify the relevant tables: We need to find the album title, which is in the 'albums' table, and we need to find the track name, which is in the 'tracks' table.", "Determine the relationship: The 'albums' table is related to the 'tracks' table through the 'album_id' foreign key in the 'tracks' table.", "Construct the SQL query: We will select the title from the 'albums' table and join it with the 'tracks' table on the album_id. We will filter the results where the track name is 'Ball to the Wall'."], "gold_sql": "SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T2.name = 'Balls to the Wall';", "source_tables": ["albums", "tracks"], "pred_sql": "SELECT albums.title \nFROM albums \nJOIN tracks ON albums.id = tracks.album_id \nWHERE tracks.name = 'Ball to the Wall';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the titles of albums from the 'albums' table that match a specific pattern. The placeholder in the WHERE clause represents the title pattern to search for, allowing for flexible querying of album titles.\",\n        \"virtual_table\": \"SELECT title FROM albums WHERE title LIKE [PLACEHOLDER-TYPE:STRING] ORDER BY title;\"\n    }\n}\n"}
{"sample_id": "train.632", "db_id": "store_1", "question": "What are the names of all tracks that belong to the Rock genre and whose media type is MPEG?", "rationale": ["Identify the tables needed: tracks, media_types, and genres.", "Determine the relationships: tracks has foreign keys to media_types and genres.", "Select the track names from the tracks table.", "Join the media_types table to filter by media type name 'MPEG'.", "Join the genres table to filter by genre name 'Rock'.", "Construct the SQL query to retrieve the desired track names based on the specified conditions."], "gold_sql": "SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = 'Rock' OR T3.name = 'MPEG audio file';", "source_tables": ["tracks", "genres", "media_types"], "pred_sql": "SELECT tracks.name \nFROM tracks \nJOIN media_types ON tracks.media_type_id = media_types.id \nJOIN genres ON tracks.genre_id = genres.id \nWHERE genres.name = 'Rock' AND media_types.name = 'MPEG';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of different media types from the 'media_types' table. The query retrieves all media type names without any filtering conditions.\",\n        \"virtual_table\": \"SELECT name FROM media_types;\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the titles of albums from the 'albums' table that match a specific pattern. The placeholder in the WHERE clause represents the title pattern to search for, allowing for flexible querying of album titles.\",\n        \"virtual_table\": \"SELECT title FROM albums WHERE title LIKE [PLACEHOLDER-TYPE:STRING] ORDER BY title;\"\n    }\n}\n"}
{"sample_id": "train.946", "db_id": "medicine_enzyme_interaction", "question": "What are the names and trade names of the medcines that are FDA approved?", "rationale": ["Identify the relevant table: The 'medicine' table contains the information about medicines, including their names, trade names, and FDA approval status.", "Determine the required columns: We need the 'name' and 'Trade_Name' columns from the 'medicine' table.", "Specify the condition: We only want medicines that are FDA approved, which is indicated by the 'FDA_approved' column being equal to 'yes'.", "Construct the SQL query: Combine the selected columns and the condition into a SQL SELECT statement."], "gold_sql": "SELECT name ,  trade_name FROM medicine WHERE FDA_approved  =  'Yes'", "source_tables": ["medicine"], "pred_sql": "SELECT name, Trade_Name FROM medicine WHERE FDA_approved = 'yes';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the types of interactions between medicines and enzymes from the 'medicine_enzyme_interaction' table. It counts the occurrences of each interaction type and orders them in descending order, allowing the user to specify a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT interaction_type ,  count(*) FROM medicine_enzyme_interaction GROUP BY interaction_type ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.951", "db_id": "medicine_enzyme_interaction", "question": "What are the ids, names and FDA approval status of medicines in descending order of the number of enzymes that it can interact with.", "rationale": ["Identify the relevant tables: medicine and medicine_enzyme_interaction.", "We need to retrieve the ids, names, and FDA approval status of medicines.", "To find the number of enzymes each medicine can interact with, we will join the medicine table with the medicine_enzyme_interaction table on the medicine_id.", "We will group the results by the medicine's id, name, and FDA approval status to count the number of interactions for each medicine.", "Finally, we will order the results in descending order based on the count of enzyme interactions."], "gold_sql": "SELECT T1.id ,  T1.Name ,  T1.FDA_approved FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id GROUP BY T1.id ORDER BY count(*) DESC", "source_tables": ["medicine", "medicine_enzyme_interaction"], "pred_sql": "SELECT m.id, m.name, m.FDA_approved \nFROM medicine m \nJOIN medicine_enzyme_interaction mei ON m.id = mei.medicine_id \nGROUP BY m.id, m.name, m.FDA_approved \nORDER BY COUNT(mei.enzyme_id) DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the types of interactions between medicines and enzymes from the 'medicine_enzyme_interaction' table. It counts the occurrences of each interaction type and orders them in descending order, allowing the user to specify a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT interaction_type ,  count(*) FROM medicine_enzyme_interaction GROUP BY interaction_type ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.953", "db_id": "medicine_enzyme_interaction", "question": "What is the id and name of the enzyme with most number of medicines that can interact as 'activator'?", "rationale": ["Identify the relevant tables: 'enzyme' and 'medicine_enzyme_interaction'.", "We need to find the enzyme that has the most interactions as an 'activator'.", "Join the 'enzyme' table with the 'medicine_enzyme_interaction' table on the enzyme ID.", "Filter the results to only include interactions where the interaction type is 'activator'.", "Group the results by enzyme ID and name to count the number of medicines that interact with each enzyme.", "Order the results in descending order based on the count of interacting medicines.", "Limit the results to only the top entry to get the enzyme with the most interactions."], "gold_sql": "SELECT T1.id ,  T1.name FROM enzyme AS T1 JOIN medicine_enzyme_interaction AS T2 ON T1.id  =  T2.enzyme_id WHERE T2.interaction_type  =  'activitor' GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["enzyme", "medicine_enzyme_interaction"], "pred_sql": "SELECT e.id, e.name \nFROM enzyme e \nJOIN medicine_enzyme_interaction mei ON e.id = mei.enzyme_id \nWHERE mei.interaction_type = 'activator' \nGROUP BY e.id, e.name \nORDER BY COUNT(mei.medicine_id) DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the types of interactions between medicines and enzymes from the 'medicine_enzyme_interaction' table. It counts the occurrences of each interaction type and orders them in descending order, allowing the user to specify a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT interaction_type ,  count(*) FROM medicine_enzyme_interaction GROUP BY interaction_type ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.968", "db_id": "medicine_enzyme_interaction", "question": "What are the medicine and trade names that can interact as an inhibitor and activitor with enzymes?", "rationale": ["Identify the relevant tables: medicine, enzyme, and medicine_enzyme_interaction.", "We need to retrieve the medicine names and their trade names, so we will select 'name' and 'Trade_Name' from the medicine table.", "To find interactions, we will join the medicine table with the medicine_enzyme_interaction table on the medicine ID.", "Next, we will join the enzyme table to ensure we are considering the enzymes involved in the interactions.", "We are specifically interested in interactions that are either 'inhibitor' or 'activator', so we will filter the results based on the 'interaction_type' column."], "gold_sql": "SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id WHERE interaction_type  =  'inhibitor' INTERSECT SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id WHERE interaction_type  =  'activitor'", "source_tables": ["medicine", "medicine_enzyme_interaction"], "pred_sql": "SELECT m.name, m.Trade_Name FROM medicine m JOIN medicine_enzyme_interaction mei ON m.id = mei.medicine_id JOIN enzyme e ON mei.enzyme_id = e.id WHERE mei.interaction_type IN ('inhibitor', 'activator');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the types of interactions between medicines and enzymes from the 'medicine_enzyme_interaction' table. It counts the occurrences of each interaction type and orders them in descending order, allowing the user to specify a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT interaction_type ,  count(*) FROM medicine_enzyme_interaction GROUP BY interaction_type ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.970", "db_id": "medicine_enzyme_interaction", "question": "What are the medicine and trade names that cannot interact with the enzyme with the product 'Heme'?", "rationale": ["Identify the relevant tables: medicine, enzyme, and medicine_enzyme_interaction.", "We need to find medicines that cannot interact with a specific enzyme product, which is 'Heme'.", "To do this, we will first find all medicine IDs that interact with the enzyme having the product 'Heme'.", "This requires a subquery that joins the medicine_enzyme_interaction table with the enzyme table to filter by the product 'Heme'.", "Next, we will select the names and trade names of medicines from the medicine table that are not in the list of medicine IDs obtained from the subquery.", "The final SQL query will use a NOT IN clause to exclude those medicines from the results."], "gold_sql": "SELECT name ,  trade_name FROM medicine EXCEPT SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id JOIN enzyme AS T3 ON T3.id  =  T2.enzyme_id WHERE T3.product  =  'Protoporphyrinogen IX'", "source_tables": ["enzyme", "medicine", "medicine_enzyme_interaction"], "pred_sql": "SELECT m.name, m.Trade_Name \nFROM medicine m \nWHERE m.id NOT IN (\n    SELECT mei.medicine_id \n    FROM medicine_enzyme_interaction mei \n    JOIN enzyme e ON mei.enzyme_id = e.id \n    WHERE e.Product = 'Heme'\n);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the types of interactions between medicines and enzymes from the 'medicine_enzyme_interaction' table. It counts the occurrences of each interaction type and orders them in descending order, allowing the user to specify a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT interaction_type ,  count(*) FROM medicine_enzyme_interaction GROUP BY interaction_type ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1355", "db_id": "college_2", "question": "What is the name of the department with an instructure who has a name like 'Soisalon'?", "rationale": ["Identify the relevant table: The 'instructor' table contains the names of instructors and their associated departments.", "Determine the required information: We need the 'dept_name' of the instructor whose name matches the pattern 'Soisalon'.", "Construct the SQL query: Use a SELECT statement to retrieve 'dept_name' from the 'instructor' table where the 'name' matches the specified pattern using the LIKE operator."], "gold_sql": "SELECT dept_name FROM instructor WHERE name LIKE '%Soisalon%'", "source_tables": ["instructor"], "pred_sql": "SELECT dept_name FROM instructor WHERE name LIKE 'Soisalon'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the titles of courses offered by one academic department that are not offered by another department. The placeholders in the WHERE clause represent the names of the departments being compared.\",\n        \"virtual_table\": \"SELECT title FROM course WHERE dept_name  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT title FROM course WHERE dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the minimum salary of instructors grouped by their respective departments, but only for those departments where the average salary of instructors exceeds the overall average salary of all instructors. The placeholders in the query represent the necessary values for filtering and aggregating the data.\",\n        \"virtual_table\": \"SELECT min(salary) ,  dept_name FROM instructor GROUP BY dept_name HAVING avg(salary)  >  (SELECT avg(salary) FROM instructor)\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the minimum salary of instructors grouped by their respective departments, but only for those departments where the average salary of instructors exceeds the overall average salary of all instructors. The placeholders in the query represent the necessary values for filtering and aggregating the data.\",\n        \"virtual_table\": \"SELECT min(salary) ,  dept_name FROM instructor GROUP BY dept_name HAVING avg(salary)  >  (SELECT avg(salary) FROM instructor)\"\n    }\n}\n"}
{"sample_id": "train.1365", "db_id": "college_2", "question": "What are the titles of courses that are in the Statistics department but not the Psychology department?", "rationale": ["Identify the relevant departments: Statistics and Psychology.", "Use the course table to find titles of courses offered by the Statistics department.", "Use the EXCEPT clause to exclude titles of courses offered by the Psychology department from the results of the Statistics department.", "Construct the SQL query using the identified conditions."], "gold_sql": "SELECT title FROM course WHERE dept_name  =  'Statistics' EXCEPT SELECT title FROM course WHERE dept_name  =  'Psychology'", "source_tables": ["course"], "pred_sql": "SELECT title FROM course WHERE dept_name = 'Statistics' EXCEPT SELECT title FROM course WHERE dept_name = 'Psychology'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the titles of courses offered by one academic department that are not offered by another department. The placeholders in the WHERE clause represent the names of the departments being compared.\",\n        \"virtual_table\": \"SELECT title FROM course WHERE dept_name  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT title FROM course WHERE dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the titles of courses from the 'course' table, sorted alphabetically by title and then by the number of credits awarded for each course. The sorting allows for an organized view of the available courses based on their titles and credits.\",\n        \"virtual_table\": \"SELECT title FROM course ORDER BY title ,  credits\"\n    }\n}\n"}
{"sample_id": "train.1424", "db_id": "college_2", "question": "Find the title of course whose prerequisite is course Differential Geometry.", "rationale": ["Identify the course ID for the course titled 'Differential Geometry' by querying the course table.", "Use the course ID obtained to find the prerequisite course IDs from the prereq table.", "Finally, retrieve the titles of the courses that have the identified prerequisite course IDs from the course table."], "gold_sql": "SELECT title FROM course WHERE course_id IN (SELECT T1.course_id FROM prereq AS T1 JOIN course AS T2 ON T1.prereq_id  =  T2.course_id WHERE T2.title  =  'Differential Geometry')", "source_tables": ["course", "prereq"], "pred_sql": "SELECT title FROM course WHERE course_id IN (SELECT course_id FROM prereq WHERE prereq_id = (SELECT course_id FROM course WHERE title = 'Differential Geometry'));", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the titles of courses offered by one academic department that are not offered by another department. The placeholders in the WHERE clause represent the names of the departments being compared.\",\n        \"virtual_table\": \"SELECT title FROM course WHERE dept_name  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT title FROM course WHERE dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the titles of courses from the 'course' table, sorted alphabetically by title and then by the number of credits awarded for each course. The sorting allows for an organized view of the available courses based on their titles and credits.\",\n        \"virtual_table\": \"SELECT title FROM course ORDER BY title ,  credits\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies the course IDs from the 'SECTION' table that are offered in two different semesters and years. The placeholders in the WHERE clauses represent the specific semesters and years for which the course IDs are being queried.\",\n        \"virtual_table\": \"SELECT course_id FROM SECTION WHERE semester  =  [PLACEHOLDER-TYPE:STRING] AND YEAR  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT course_id FROM SECTION WHERE semester  =  [PLACEHOLDER-TYPE:STRING] AND YEAR  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1426", "db_id": "college_2", "question": "Find the names of students who have taken any course in the fall semester of year 2003.", "rationale": ["Identify the tables involved: We need to find student names, so we will use the 'student' table and the 'takes' table to find which courses they have taken.", "We need to filter the courses based on the semester and year, specifically for the fall semester of 2003. This information is found in the 'section' table.", "We will create a subquery to select the course IDs from the 'section' table where the semester is 'Fall' and the year is '2003'.", "We will then join the 'student' table with the 'takes' table on the student ID to find the names of students who have taken any of the courses identified in the subquery."], "gold_sql": "SELECT name FROM student WHERE id IN (SELECT id FROM takes WHERE semester  =  'Fall' AND YEAR  =  2003)", "source_tables": ["student", "takes"], "pred_sql": "SELECT student.name \nFROM student \nJOIN takes ON student.ID = takes.ID \nWHERE takes.course_id IN (\n    SELECT course_id \n    FROM section \n    WHERE semester = 'Fall' AND year = '2003'\n);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the course IDs from the 'SECTION' table that are offered in two different semesters and years. The placeholders in the WHERE clauses represent the specific semesters and years for which the course IDs are being queried.\",\n        \"virtual_table\": \"SELECT course_id FROM SECTION WHERE semester  =  [PLACEHOLDER-TYPE:STRING] AND YEAR  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT course_id FROM SECTION WHERE semester  =  [PLACEHOLDER-TYPE:STRING] AND YEAR  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1435", "db_id": "college_2", "question": "What are the names of all instructors who advise students in the math depart sorted by total credits of the student.", "rationale": ["Identify the relevant tables: instructor, advisor, and student.", "We need to find instructors who advise students, so we will join the instructor table with the advisor table on the instructor's ID.", "Next, we join the advisor table with the student table on the student's ID to get the students being advised.", "We need to filter the results to only include students from the math department, so we add a WHERE clause for student.dept_name = 'math'.", "Finally, we want to sort the results by the total credits of the students, so we use ORDER BY student.tot_cred."], "gold_sql": "SELECT T2.name FROM advisor AS T1 JOIN instructor AS T2 ON T1.i_id  =  T2.id JOIN student AS T3 ON T1.s_id  =  T3.id WHERE T3.dept_name  =  'Math' ORDER BY T3.tot_cred", "source_tables": ["instructor", "student", "advisor"], "pred_sql": "SELECT instructor.name \nFROM instructor \nJOIN advisor ON instructor.ID = advisor.i_ID \nJOIN student ON advisor.s_ID = student.ID \nWHERE student.dept_name = 'math' \nORDER BY student.tot_cred;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the titles of courses from the 'course' table, sorted alphabetically by title and then by the number of credits awarded for each course. The sorting allows for an organized view of the available courses based on their titles and credits.\",\n        \"virtual_table\": \"SELECT title FROM course ORDER BY title ,  credits\"\n    }\n}\n"}
{"sample_id": "train.1436", "db_id": "college_2", "question": "What is the course title of the prerequisite of course Mobile Computing?", "rationale": ["Identify the course title of the prerequisite for the course 'Mobile Computing'.", "First, find the course_id for 'Mobile Computing' from the course table.", "Next, use this course_id to find the corresponding prerequisite course_id from the prereq table.", "Finally, retrieve the title of the course that corresponds to the prerequisite course_id found in the previous step from the course table."], "gold_sql": "SELECT title FROM course WHERE course_id IN (SELECT T1.prereq_id FROM prereq AS T1 JOIN course AS T2 ON T1.course_id  =  T2.course_id WHERE T2.title  =  'Mobile Computing')", "source_tables": ["course", "prereq"], "pred_sql": "SELECT title FROM course WHERE course_id IN (SELECT prereq_id FROM prereq WHERE course_id = (SELECT course_id FROM course WHERE title = 'Mobile Computing'))", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the titles of courses from the 'course' table, sorted alphabetically by title and then by the number of credits awarded for each course. The sorting allows for an organized view of the available courses based on their titles and credits.\",\n        \"virtual_table\": \"SELECT title FROM course ORDER BY title ,  credits\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the titles of courses offered by one academic department that are not offered by another department. The placeholders in the WHERE clause represent the names of the departments being compared.\",\n        \"virtual_table\": \"SELECT title FROM course WHERE dept_name  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT title FROM course WHERE dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies the course IDs from the 'SECTION' table that are offered in two different semesters and years. The placeholders in the WHERE clauses represent the specific semesters and years for which the course IDs are being queried.\",\n        \"virtual_table\": \"SELECT course_id FROM SECTION WHERE semester  =  [PLACEHOLDER-TYPE:STRING] AND YEAR  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT course_id FROM SECTION WHERE semester  =  [PLACEHOLDER-TYPE:STRING] AND YEAR  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1439", "db_id": "college_2", "question": "What is the name of the instructor who advises the student with the greatest number of total credits?", "rationale": ["Identify the relevant tables: instructor, advisor, and student.", "We need to find the instructor who advises a specific student.", "The student with the greatest number of total credits can be found using a subquery that selects the maximum total credits from the student table.", "Join the instructor table with the advisor table to link instructors to their advisees.", "Join the advisor table with the student table to get the total credits of each student advised by the instructor.", "Filter the results to only include the instructor advising the student with the maximum total credits."], "gold_sql": "SELECT T2.name FROM advisor AS T1 JOIN instructor AS T2 ON T1.i_id  =  T2.id JOIN student AS T3 ON T1.s_id  =  T3.id ORDER BY T3.tot_cred DESC LIMIT 1", "source_tables": ["instructor", "student", "advisor"], "pred_sql": "SELECT instructor.name \nFROM instructor \nJOIN advisor ON instructor.ID = advisor.i_ID \nJOIN student ON advisor.s_ID = student.ID \nWHERE student.tot_cred = (SELECT MAX(tot_cred) FROM student);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the titles of courses from the 'course' table, sorted alphabetically by title and then by the number of credits awarded for each course. The sorting allows for an organized view of the available courses based on their titles and credits.\",\n        \"virtual_table\": \"SELECT title FROM course ORDER BY title ,  credits\"\n    }\n}\n"}
{"sample_id": "train.1448", "db_id": "college_2", "question": "Find the number and averaged salary of all instructors who are in the department with the highest budget.", "rationale": ["Identify the department with the highest budget by ordering the 'department' table by 'budget' in descending order and selecting the top entry.", "Use a subquery to find the 'dept_name' of the department with the highest budget.", "Count the number of instructors and calculate the average salary from the 'instructor' table where the 'dept_name' matches the result from the subquery."], "gold_sql": "SELECT avg(T1.salary) ,  count(*) FROM instructor AS T1 JOIN department AS T2 ON T1.dept_name  =  T2.dept_name ORDER BY T2.budget DESC LIMIT 1", "source_tables": ["instructor", "department"], "pred_sql": "SELECT COUNT(ID) AS number_of_instructors, AVG(salary) AS average_salary \nFROM instructor \nWHERE dept_name = (SELECT dept_name \n                   FROM department \n                   ORDER BY budget DESC \n                   LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the minimum salary of instructors grouped by their respective departments, but only for those departments where the average salary of instructors exceeds the overall average salary of all instructors. The placeholders in the query represent the necessary values for filtering and aggregating the data.\",\n        \"virtual_table\": \"SELECT min(salary) ,  dept_name FROM instructor GROUP BY dept_name HAVING avg(salary)  >  (SELECT avg(salary) FROM instructor)\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the minimum salary of instructors grouped by their respective departments, but only for those departments where the average salary of instructors exceeds the overall average salary of all instructors. The placeholders in the query represent the necessary values for filtering and aggregating the data.\",\n        \"virtual_table\": \"SELECT min(salary) ,  dept_name FROM instructor GROUP BY dept_name HAVING avg(salary)  >  (SELECT avg(salary) FROM instructor)\"\n    }\n}\n"}
{"sample_id": "train.1449", "db_id": "college_2", "question": "How many instructors are in the department with the highest budget, and what is their average salary?", "rationale": ["Identify the department with the highest budget by ordering the department table by budget in descending order and selecting the top entry.", "Use a subquery to find the department name with the highest budget.", "Count the number of instructors in that department by filtering the instructor table based on the department name obtained from the subquery.", "Calculate the average salary of instructors in that department by using the AVG function on the salary column, while still filtering by the department name."], "gold_sql": "SELECT avg(T1.salary) ,  count(*) FROM instructor AS T1 JOIN department AS T2 ON T1.dept_name  =  T2.dept_name ORDER BY T2.budget DESC LIMIT 1", "source_tables": ["instructor", "department"], "pred_sql": "SELECT COUNT(ID) AS instructor_count, AVG(salary) AS average_salary\nFROM instructor\nWHERE dept_name = (SELECT dept_name FROM department ORDER BY budget DESC LIMIT 1);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the minimum salary of instructors grouped by their respective departments, but only for those departments where the average salary of instructors exceeds the overall average salary of all instructors. The placeholders in the query represent the necessary values for filtering and aggregating the data.\",\n        \"virtual_table\": \"SELECT min(salary) ,  dept_name FROM instructor GROUP BY dept_name HAVING avg(salary)  >  (SELECT avg(salary) FROM instructor)\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the minimum salary of instructors grouped by their respective departments, but only for those departments where the average salary of instructors exceeds the overall average salary of all instructors. The placeholders in the query represent the necessary values for filtering and aggregating the data.\",\n        \"virtual_table\": \"SELECT min(salary) ,  dept_name FROM instructor GROUP BY dept_name HAVING avg(salary)  >  (SELECT avg(salary) FROM instructor)\"\n    }\n}\n"}
{"sample_id": "train.1452", "db_id": "college_2", "question": "Find the name of students who didn't take any course from Biology department.", "rationale": ["Identify the students who have not taken any courses from the Biology department.", "To do this, we need to find the IDs of students who have taken courses in the Biology department.", "We can achieve this by selecting the course IDs from the course table where the department name is 'Biology'.", "Next, we will find the IDs of students who have taken these courses using the takes table.", "Finally, we will select the names of students from the student table whose IDs are not in the list of IDs obtained from the previous step."], "gold_sql": "SELECT name FROM student WHERE id NOT IN (SELECT T1.id FROM takes AS T1 JOIN course AS T2 ON T1.course_id  =  T2.course_id WHERE T2.dept_name  =  'Biology')", "source_tables": ["course", "student", "takes"], "pred_sql": "SELECT name FROM student WHERE ID NOT IN (SELECT ID FROM takes WHERE course_id IN (SELECT course_id FROM course WHERE dept_name = 'Biology'))", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the titles of courses offered by one academic department that are not offered by another department. The placeholders in the WHERE clause represent the names of the departments being compared.\",\n        \"virtual_table\": \"SELECT title FROM course WHERE dept_name  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT title FROM course WHERE dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.1458", "db_id": "college_2", "question": "Find the name and salary of instructors whose salary is below the average salary of the instructors in the Physics department.", "rationale": ["Identify the relevant tables: We need the 'instructor' table for instructor details and their salaries.", "Determine the condition: We want instructors whose salary is below the average salary of instructors in the Physics department.", "Calculate the average salary for the Physics department: This can be done using a subquery that selects the average salary from the 'instructor' table where the department is 'Physics'.", "Construct the main query: Select the name and salary from the 'instructor' table where the salary is less than the average salary calculated in the subquery."], "gold_sql": "SELECT name ,  salary FROM instructor WHERE salary  <  (SELECT avg(salary) FROM instructor WHERE dept_name  =  'Physics')", "source_tables": ["instructor"], "pred_sql": "SELECT name, salary FROM instructor WHERE salary < (SELECT avg(salary) FROM instructor WHERE dept_name = 'Physics')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the minimum salary of instructors grouped by their respective departments, but only for those departments where the average salary of instructors exceeds the overall average salary of all instructors. The placeholders in the query represent the necessary values for filtering and aggregating the data.\",\n        \"virtual_table\": \"SELECT min(salary) ,  dept_name FROM instructor GROUP BY dept_name HAVING avg(salary)  >  (SELECT avg(salary) FROM instructor)\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the minimum salary of instructors grouped by their respective departments, but only for those departments where the average salary of instructors exceeds the overall average salary of all instructors. The placeholders in the query represent the necessary values for filtering and aggregating the data.\",\n        \"virtual_table\": \"SELECT min(salary) ,  dept_name FROM instructor GROUP BY dept_name HAVING avg(salary)  >  (SELECT avg(salary) FROM instructor)\"\n    }\n}\n"}
{"sample_id": "train.1461", "db_id": "college_2", "question": "What are the names of students who have taken Statistics courses?", "rationale": ["Identify the relevant tables: We need to find student names, so we will use the 'student' table. We also need to know which courses they have taken, so we will use the 'takes' and 'course' tables.", "Determine the relationship between the tables: The 'takes' table links students to the courses they have taken through the student ID and course ID.", "Filter for Statistics courses: We will filter the courses by their title to find those that include 'Statistics'.", "Select distinct student names: We want to ensure that we only get unique names of students who have taken these courses."], "gold_sql": "SELECT T3.name FROM course AS T1 JOIN takes AS T2 ON T1.course_id  =  T2.course_id JOIN student AS T3 ON T2.id  =  T3.id WHERE T1.dept_name  =  'Statistics'", "source_tables": ["course", "student", "takes"], "pred_sql": "SELECT DISTINCT student.name \nFROM student \nJOIN takes ON student.ID = takes.ID \nJOIN course ON takes.course_id = course.course_id \nWHERE course.title LIKE '%Statistics%';", "hint": "\n"}
{"sample_id": "train.1464", "db_id": "college_2", "question": "Find the names of all instructors in computer science department", "rationale": ["Identify the table that contains instructor information, which is the 'instructor' table.", "Determine the relevant column for the instructor's name, which is 'name'.", "Identify the department of interest, which is 'computer science'.", "Construct the SQL query to select the names of instructors from the 'instructor' table where the 'dept_name' matches 'computer science'."], "gold_sql": "SELECT name FROM instructor WHERE dept_name  =  'Comp. Sci.'", "source_tables": ["instructor"], "pred_sql": "SELECT name FROM instructor WHERE dept_name = 'computer science'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the minimum salary of instructors grouped by their respective departments, but only for those departments where the average salary of instructors exceeds the overall average salary of all instructors. The placeholders in the query represent the necessary values for filtering and aggregating the data.\",\n        \"virtual_table\": \"SELECT min(salary) ,  dept_name FROM instructor GROUP BY dept_name HAVING avg(salary)  >  (SELECT avg(salary) FROM instructor)\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the minimum salary of instructors grouped by their respective departments, but only for those departments where the average salary of instructors exceeds the overall average salary of all instructors. The placeholders in the query represent the necessary values for filtering and aggregating the data.\",\n        \"virtual_table\": \"SELECT min(salary) ,  dept_name FROM instructor GROUP BY dept_name HAVING avg(salary)  >  (SELECT avg(salary) FROM instructor)\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the titles of courses offered by one academic department that are not offered by another department. The placeholders in the WHERE clause represent the names of the departments being compared.\",\n        \"virtual_table\": \"SELECT title FROM course WHERE dept_name  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT title FROM course WHERE dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.1480", "db_id": "college_2", "question": "Find courses that ran in Fall 2009 but not in Spring 2010.", "rationale": ["Identify the courses offered in Fall 2009 by querying the section table for course IDs with the specified semester and year.", "Use the EXCEPT operator to find courses that were not offered in Spring 2010 by querying the section table again for course IDs with the specified semester and year.", "Select the titles of the courses from the course table where the course IDs are in the result of the first query but not in the second query."], "gold_sql": "SELECT course_id FROM SECTION WHERE semester  =  'Fall' AND YEAR  =  2009 EXCEPT SELECT course_id FROM SECTION WHERE semester  =  'Spring' AND YEAR  =  2010", "source_tables": ["section"], "pred_sql": "SELECT title FROM course WHERE course_id IN (SELECT course_id FROM section WHERE semester = 'Fall' AND year = '2009') EXCEPT SELECT title FROM course WHERE course_id IN (SELECT course_id FROM section WHERE semester = 'Spring' AND year = '2010')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the titles of courses offered by one academic department that are not offered by another department. The placeholders in the WHERE clause represent the names of the departments being compared.\",\n        \"virtual_table\": \"SELECT title FROM course WHERE dept_name  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT title FROM course WHERE dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the course IDs from the 'SECTION' table that are offered in two different semesters and years. The placeholders in the WHERE clauses represent the specific semesters and years for which the course IDs are being queried.\",\n        \"virtual_table\": \"SELECT course_id FROM SECTION WHERE semester  =  [PLACEHOLDER-TYPE:STRING] AND YEAR  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT course_id FROM SECTION WHERE semester  =  [PLACEHOLDER-TYPE:STRING] AND YEAR  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of course identifiers from the 'section' table for two different instances of the same semester and year. The placeholders in the WHERE clauses represent the semester and year values that can be specified by the user.\",\n        \"virtual_table\": \"SELECT course_id FROM SECTION WHERE semester  =  [PLACEHOLDER-TYPE:STRING] AND YEAR  =  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT course_id FROM SECTION WHERE semester  =  [PLACEHOLDER-TYPE:STRING] AND YEAR  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1489", "db_id": "college_2", "question": "What are the names of instructors who earn more than at least one instructor from the Biology department?", "rationale": ["Identify the instructors who earn more than at least one instructor from the Biology department.", "To find the minimum salary of instructors in the Biology department, we can use a subquery that selects the minimum salary from the instructor table where the department is Biology.", "We will then compare the salary of all instructors against this minimum salary to find those who earn more.", "The final query selects the names of instructors whose salary is greater than the minimum salary found in the Biology department."], "gold_sql": "SELECT name FROM instructor WHERE salary  >  (SELECT min(salary) FROM instructor WHERE dept_name  =  'Biology')", "source_tables": ["instructor"], "pred_sql": "SELECT name FROM instructor WHERE salary > (SELECT min_salary FROM (SELECT min(salary) AS min_salary FROM instructor WHERE dept_name = 'Biology' GROUP BY dept_name))", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the minimum salary of instructors grouped by their respective departments, but only for those departments where the average salary of instructors exceeds the overall average salary of all instructors. The placeholders in the query represent the necessary values for filtering and aggregating the data.\",\n        \"virtual_table\": \"SELECT min(salary) ,  dept_name FROM instructor GROUP BY dept_name HAVING avg(salary)  >  (SELECT avg(salary) FROM instructor)\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the minimum salary of instructors grouped by their respective departments, but only for those departments where the average salary of instructors exceeds the overall average salary of all instructors. The placeholders in the query represent the necessary values for filtering and aggregating the data.\",\n        \"virtual_table\": \"SELECT min(salary) ,  dept_name FROM instructor GROUP BY dept_name HAVING avg(salary)  >  (SELECT avg(salary) FROM instructor)\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the titles of courses offered by one academic department that are not offered by another department. The placeholders in the WHERE clause represent the names of the departments being compared.\",\n        \"virtual_table\": \"SELECT title FROM course WHERE dept_name  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT title FROM course WHERE dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.1515", "db_id": "insurance_and_eClaims", "question": "Find the total and average amount paid in claim headers.", "rationale": ["Identify the relevant table: The 'Claim_Headers' table contains the 'Amount_Paid' column which is needed for the calculations.", "Determine the required calculations: We need to calculate both the total and average of the 'Amount_Paid' column.", "Use aggregate functions: Use SUM() to calculate the total amount paid and AVG() to calculate the average amount paid.", "Construct the SQL query: Combine the SELECT statement with the aggregate functions and specify the table from which to retrieve the data."], "gold_sql": "SELECT sum(amount_piad) ,  avg(amount_piad) FROM claim_headers", "source_tables": ["claim_headers"], "pred_sql": "SELECT SUM(Amount_Paid) AS Total_Amount_Paid, AVG(Amount_Paid) AS Average_Amount_Paid FROM Claim_Headers;", "hint": "\n"}
{"sample_id": "train.1516", "db_id": "insurance_and_eClaims", "question": "What are the total amount and average amount paid in claim headers?", "rationale": ["Identify the relevant table: The question pertains to claim headers, so we will use the Claim_Headers table.", "Determine the required calculations: We need to calculate the total amount paid and the average amount paid.", "Use aggregate functions: To get the total amount, we will use SUM(Amount_Paid), and for the average, we will use AVG(Amount_Paid).", "Construct the SQL query: We will select the total and average amounts from the Claim_Headers table."], "gold_sql": "SELECT sum(amount_piad) ,  avg(amount_piad) FROM claim_headers", "source_tables": ["claim_headers"], "pred_sql": "SELECT SUM(Amount_Paid) AS Total_Amount_Paid, AVG(Amount_Paid) AS Average_Amount_Paid\nFROM Claim_Headers;", "hint": "\n"}
{"sample_id": "train.1517", "db_id": "insurance_and_eClaims", "question": "Find the total amount claimed in the most recently created document.", "rationale": ["Identify the relevant tables: Claim_Headers for the amount claimed and Claims_Documents for the document creation date.", "We need to sum the 'Amount_Claimed' from the Claim_Headers table.", "Join Claim_Headers with Claims_Documents on the Claim_ID to link claims with their documents.", "Filter the results to only include claims associated with the most recently created document by using a subquery to find the maximum 'Created_Date' in the Claims_Documents table."], "gold_sql": "SELECT sum(t1.amount_claimed) FROM claim_headers AS t1 JOIN claims_documents AS t2 ON t1.claim_header_id  =  t2.claim_id WHERE t2.created_date  =  (SELECT created_date FROM claims_documents ORDER BY created_date LIMIT 1)", "source_tables": ["claims_documents", "claim_headers"], "pred_sql": "SELECT SUM(ch.Amount_Claimed) AS Total_Claimed\nFROM Claim_Headers ch\nJOIN Claims_Documents cd ON ch.Claim_Header_ID = cd.Claim_ID\nWHERE cd.Created_Date = (SELECT MAX(Created_Date) FROM Claims_Documents);", "hint": "\n"}
{"sample_id": "train.1519", "db_id": "insurance_and_eClaims", "question": "What is the name of the customer who has made the largest amount of claim in a single claim?", "rationale": ["Identify the relevant tables: Customers, Policies, and Claim_Headers.", "We need to find the customer who made the largest claim, so we will join the Customers table with the Policies table on Customer_ID, and then join the Claim_Headers table on Policy_ID.", "We will select the Customer_Details from the Customers table.", "To find the largest claim, we will order the results by Amount_Claimed in descending order.", "Finally, we will limit the results to 1 to get the customer with the largest claim."], "gold_sql": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_claimed  =  (SELECT max(amount_claimed) FROM claim_headers)", "source_tables": ["policies", "customers", "claim_headers"], "pred_sql": "SELECT c.Customer_Details \nFROM Customers c \nJOIN Policies p ON c.Customer_ID = p.Customer_ID \nJOIN Claim_Headers ch ON p.Policy_ID = ch.Policy_ID \nORDER BY ch.Amount_Claimed DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.1527", "db_id": "insurance_and_eClaims", "question": "What is the name of the claim processing stage that most of the claims are on?", "rationale": ["Identify the relevant table for claim processing stages, which is 'Claims_Processing_Stages'.", "Determine that we need to find the claim stage that has the most claims associated with it.", "Use the 'Claims_Processing' table to group by 'Claim_Stage_ID' and count the number of claims in each stage.", "Order the results by the count in descending order to find the stage with the most claims.", "Limit the results to 1 to get the top stage.", "Select the 'Claim_Status_Name' from 'Claims_Processing_Stages' where the 'Claim_Stage_ID' matches the most frequent stage from the previous step."], "gold_sql": "SELECT t2.claim_status_name FROM claims_processing AS t1 JOIN claims_processing_stages AS t2 ON t1.claim_stage_id  =  t2.claim_stage_id GROUP BY t1.claim_stage_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["claims_processing", "claims_processing_stages"], "pred_sql": "SELECT Claim_Status_Name FROM Claims_Processing_Stages WHERE Claim_Stage_ID IN (SELECT Claim_Stage_ID FROM Claims_Processing GROUP BY Claim_Stage_ID ORDER BY COUNT(*) DESC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the different types of insurance policies from the 'Policies' table, grouping them by their policy type code. The placeholder in the LIMIT clause allows the user to specify the maximum number of policy types to retrieve, sorted by the frequency of each type in descending order.\",\n        \"virtual_table\": \"SELECT policy_type_code FROM policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1535", "db_id": "insurance_and_eClaims", "question": "Find the names of all the customers and staff members.", "rationale": ["Identify the tables needed: Customers and Staff.", "Determine the columns to select: Customer_Details from Customers and Staff_Details from Staff.", "Use a SELECT statement to retrieve the desired columns.", "Since we want to find names from both tables, we can use a cross join (implicit join) by listing both tables in the FROM clause."], "gold_sql": "SELECT customer_details FROM customers UNION SELECT staff_details FROM staff", "source_tables": ["staff", "customers"], "pred_sql": "SELECT Customers.Customer_Details AS Customer_Name, Staff.Staff_Details AS Staff_Name \nFROM Customers, Staff;", "hint": "\n"}
{"sample_id": "train.1545", "db_id": "insurance_and_eClaims", "question": "Which customer is associated with the latest policy?", "rationale": ["Identify the relevant tables: We need to find the customer associated with the latest policy, so we will use the 'Customers' and 'Policies' tables.", "Determine the relationship: The 'Policies' table has a foreign key 'Customer_ID' that links to the 'Customers' table, allowing us to join these tables.", "Find the latest policy: We need to identify the latest policy by finding the maximum 'Start_Date' in the 'Policies' table.", "Construct the SQL query: We will select the 'Customer_ID' and 'Customer_Details' from the 'Customers' table, joining it with the 'Policies' table, and filter the results to only include the policy with the latest 'Start_Date'."], "gold_sql": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)", "source_tables": ["policies", "customers"], "pred_sql": "SELECT Customers.Customer_ID, Customers.Customer_Details \nFROM Policies \nJOIN Customers ON Policies.Customer_ID = Customers.Customer_ID \nWHERE Policies.Start_Date = (SELECT MAX(Start_Date) FROM Policies)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the different types of insurance policies from the 'Policies' table, grouping them by their policy type code. The placeholder in the LIMIT clause allows the user to specify the maximum number of policy types to retrieve, sorted by the frequency of each type in descending order.\",\n        \"virtual_table\": \"SELECT policy_type_code FROM policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique insurance policy types from the 'Policies' table that have been issued more than a specified number of times. The placeholder in the HAVING clause represents the minimum count of policies required to be included in the results.\",\n        \"virtual_table\": \"SELECT policy_type_code FROM policies GROUP BY policy_type_code HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1546", "db_id": "insurance_and_eClaims", "question": "Find the customer who started a policy most recently.", "rationale": ["To find the customer who started a policy most recently, we need to look at the 'Policies' table to identify the most recent 'Start_Date'.", "We will join the 'Customers' table with the 'Policies' table using the 'Customer_ID' to get the customer details associated with the policy.", "We will order the results by 'Start_Date' in descending order to get the most recent policy at the top.", "Finally, we will limit the results to 1 to get only the most recent customer who started a policy."], "gold_sql": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)", "source_tables": ["policies", "customers"], "pred_sql": "SELECT Customers.Customer_ID, Customers.Customer_Details, Policies.Start_Date \nFROM Customers \nJOIN Policies ON Customers.Customer_ID = Policies.Customer_ID \nORDER BY Policies.Start_Date DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique insurance policy types from the 'Policies' table that have been issued more than a specified number of times. The placeholder in the HAVING clause represents the minimum count of policies required to be included in the results.\",\n        \"virtual_table\": \"SELECT policy_type_code FROM policies GROUP BY policy_type_code HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the different types of insurance policies from the 'Policies' table, grouping them by their policy type code. The placeholder in the LIMIT clause allows the user to specify the maximum number of policy types to retrieve, sorted by the frequency of each type in descending order.\",\n        \"virtual_table\": \"SELECT policy_type_code FROM policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1553", "db_id": "customers_and_invoices", "question": "Show the id, the account name, and other account details for all accounts by the customer with first name 'Meaghan'.", "rationale": ["Identify the relevant tables: Accounts and Customers are needed to retrieve account information and filter by customer first name.", "Determine the columns to select: account_id, account_name, and other_account_details from the Accounts table.", "Establish the relationship between the tables: Use a JOIN to connect Accounts and Customers on customer_id.", "Apply the filter condition: Use a WHERE clause to filter customers by first name 'Meaghan'."], "gold_sql": "SELECT T1.account_id ,  T1.date_account_opened ,  T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  'Meaghan'", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT a.account_id, a.account_name, a.other_account_details \nFROM Accounts a \nJOIN Customers c ON a.customer_id = c.customer_id \nWHERE c.customer_first_name = 'Meaghan';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of unique customers who have opened accounts in the 'Accounts' table. The placeholder in the SELECT statement allows for potential filtering or additional conditions to be applied if needed.\",\n        \"virtual_table\": \"SELECT count(DISTINCT customer_id) FROM Accounts\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of financial transactions grouped by account ID from the 'Financial_Transactions' table. The placeholder in the SELECT clause represents the account ID for which the transaction count is being retrieved.\",\n        \"virtual_table\": \"SELECT count(*) ,  account_id FROM Financial_transactions\"\n    }\n}\n"}
{"sample_id": "train.1556", "db_id": "customers_and_invoices", "question": "What are the names and other details for accounts corresponding to the customer named Meaghan Keeling?", "rationale": ["Identify the relevant tables: Accounts and Customers are needed to get account details for a specific customer.", "Determine the relationship: The Accounts table has a foreign key (customer_id) that links to the Customers table.", "Select the required fields: We need account_id, date_account_opened, account_name, and other_account_details from the Accounts table.", "Filter the results: We need to filter the results based on the customer's first and last name, which are 'Meaghan' and 'Keeling' respectively.", "Construct the SQL query using JOIN to combine the Accounts and Customers tables based on the customer_id."], "gold_sql": "SELECT T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  'Meaghan' AND T2.customer_last_name  =  'Keeling'", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT a.account_id, a.date_account_opened, a.account_name, a.other_account_details \nFROM Accounts a \nJOIN Customers c ON a.customer_id = c.customer_id \nWHERE c.customer_first_name = 'Meaghan' AND c.customer_last_name = 'Keeling';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of unique customers who have opened accounts in the 'Accounts' table. The placeholder in the SELECT statement allows for potential filtering or additional conditions to be applied if needed.\",\n        \"virtual_table\": \"SELECT count(DISTINCT customer_id) FROM Accounts\"\n    }\n}\n"}
{"sample_id": "train.1558", "db_id": "customers_and_invoices", "question": "What are the full names of customers with the account name 900?", "rationale": ["Identify the relevant tables: Customers and Accounts are needed to get customer names and account details.", "We need to join the Customers table with the Accounts table on the customer_id field to link customers with their accounts.", "We need to filter the results to only include accounts with the name '900'.", "Select the full names of the customers by concatenating their first and last names."], "gold_sql": "SELECT T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T1.account_name  =  '900'", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT customer_first_name || ' ' || customer_last_name AS full_name \nFROM Customers \nJOIN Accounts ON Customers.customer_id = Accounts.customer_id \nWHERE Accounts.account_name = '900';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of unique customers who have opened accounts in the 'Accounts' table. The placeholder in the SELECT statement allows for potential filtering or additional conditions to be applied if needed.\",\n        \"virtual_table\": \"SELECT count(DISTINCT customer_id) FROM Accounts\"\n    }\n}\n"}
{"sample_id": "train.1569", "db_id": "customers_and_invoices", "question": "Show id, first name and last name for all customers and the number of accounts.", "rationale": ["Identify the required fields: customer_id, customer_first_name, customer_last_name from the Customers table and the count of accounts from the Accounts table.", "Use a LEFT JOIN to connect the Customers table with the Accounts table on the customer_id field, ensuring that all customers are included even if they have no accounts.", "Group the results by customer_id, customer_first_name, and customer_last_name to aggregate the account counts correctly for each customer.", "Use COUNT(a.account_id) to count the number of accounts associated with each customer, labeling this count as number_of_accounts."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT c.customer_id, c.customer_first_name, c.customer_last_name, COUNT(a.account_id) AS number_of_accounts\nFROM Customers c\nLEFT JOIN Accounts a ON c.customer_id = a.customer_id\nGROUP BY c.customer_id, c.customer_first_name, c.customer_last_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of unique customers who have opened accounts in the 'Accounts' table. The placeholder in the SELECT statement allows for potential filtering or additional conditions to be applied if needed.\",\n        \"virtual_table\": \"SELECT count(DISTINCT customer_id) FROM Accounts\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of financial transactions grouped by account ID from the 'Financial_Transactions' table. The placeholder in the SELECT clause represents the account ID for which the transaction count is being retrieved.\",\n        \"virtual_table\": \"SELECT count(*) ,  account_id FROM Financial_transactions\"\n    }\n}\n"}
{"sample_id": "train.1570", "db_id": "customers_and_invoices", "question": "What are the the full names and ids for all customers, and how many accounts does each have?", "rationale": ["We need to retrieve the full names and IDs of all customers, along with the count of accounts they have.", "The full name can be constructed by concatenating the first name and last name of the customer.", "We will select the customer ID from the Customers table.", "To count the number of accounts for each customer, we will use a LEFT JOIN between the Customers table and the Accounts table on the customer_id.", "Using COUNT on the account_id from the Accounts table will give us the number of accounts for each customer.", "We will group the results by customer_id to ensure we get a count for each individual customer."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT c.customer_first_name || ' ' || c.customer_last_name AS full_name, c.customer_id, COUNT(a.account_id) AS account_count\nFROM Customers c\nLEFT JOIN Accounts a ON c.customer_id = a.customer_id\nGROUP BY c.customer_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of unique customers who have opened accounts in the 'Accounts' table. The placeholder in the SELECT statement allows for potential filtering or additional conditions to be applied if needed.\",\n        \"virtual_table\": \"SELECT count(DISTINCT customer_id) FROM Accounts\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of financial transactions grouped by account ID from the 'Financial_Transactions' table. The placeholder in the SELECT clause represents the account ID for which the transaction count is being retrieved.\",\n        \"virtual_table\": \"SELECT count(*) ,  account_id FROM Financial_transactions\"\n    }\n}\n"}
{"sample_id": "train.1580", "db_id": "customers_and_invoices", "question": "Count the number of financial transactions that correspond to each account id.", "rationale": ["The task is to count the number of financial transactions for each account ID.", "We need to select the account_id from the Financial_Transactions table.", "We will use the COUNT(*) function to count the number of transactions for each account ID.", "To group the results by account ID, we will use the GROUP BY clause on account_id."], "gold_sql": "SELECT count(*) ,  account_id FROM Financial_transactions", "source_tables": ["financial_transactions"], "pred_sql": "SELECT account_id, COUNT(*) AS transaction_count FROM Financial_Transactions GROUP BY account_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of financial transactions grouped by account ID from the 'Financial_Transactions' table. The placeholder in the SELECT clause represents the account ID for which the transaction count is being retrieved.\",\n        \"virtual_table\": \"SELECT count(*) ,  account_id FROM Financial_transactions\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total number of financial transactions associated with each invoice from the 'Financial_Transactions' table. The placeholder in the SELECT clause represents the invoice number, while the count function aggregates the number of transactions for each invoice.\",\n        \"virtual_table\": \"SELECT invoice_number ,  count(*) FROM Financial_transactions GROUP BY invoice_number\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of unique customers who have opened accounts in the 'Accounts' table. The placeholder in the SELECT statement allows for potential filtering or additional conditions to be applied if needed.\",\n        \"virtual_table\": \"SELECT count(DISTINCT customer_id) FROM Accounts\"\n    }\n}\n"}
{"sample_id": "train.1607", "db_id": "customers_and_invoices", "question": "Show the order ids and the number of invoices for each order.", "rationale": ["We need to show the order ids and the number of invoices for each order.", "To achieve this, we will select the 'order_id' from the 'Orders' table.", "We will also need to count the number of invoices associated with each order, which can be done using the COUNT function on 'invoice_number' from the 'Invoices' table.", "To link the two tables, we will use a LEFT JOIN on the 'order_id' field, which is common to both tables.", "Finally, we will group the results by 'Orders.order_id' to get the count of invoices for each order."], "gold_sql": "SELECT order_id ,  count(*) FROM Invoices GROUP BY order_id", "source_tables": ["invoices"], "pred_sql": "SELECT Orders.order_id, COUNT(Invoices.invoice_number) AS number_of_invoices\nFROM Orders\nLEFT JOIN Invoices ON Orders.order_id = Invoices.order_id\nGROUP BY Orders.order_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of distinct products associated with each order from the 'Order_Items' table. The placeholder in the SELECT clause represents the unique order identifier, while the count function calculates the number of different products for each order.\",\n        \"virtual_table\": \"SELECT order_id ,  count(DISTINCT product_id) FROM Order_items GROUP BY order_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total number of financial transactions associated with each invoice from the 'Financial_Transactions' table. The placeholder in the SELECT clause represents the invoice number, while the count function aggregates the number of transactions for each invoice.\",\n        \"virtual_table\": \"SELECT invoice_number ,  count(*) FROM Financial_transactions GROUP BY invoice_number\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of unique customers who have opened accounts in the 'Accounts' table. The placeholder in the SELECT statement allows for potential filtering or additional conditions to be applied if needed.\",\n        \"virtual_table\": \"SELECT count(DISTINCT customer_id) FROM Accounts\"\n    }\n}\n"}
{"sample_id": "train.1617", "db_id": "customers_and_invoices", "question": "Show the order ids and the number of items in each order.", "rationale": ["The task is to show the order ids and the number of items in each order.", "To achieve this, we need to count the distinct products associated with each order.", "The relevant table for this information is 'Order_Items', which contains the 'order_id' and 'product_id'.", "We can use the COUNT function to count the distinct 'product_id' for each 'order_id'.", "We will group the results by 'order_id' to get the count of items for each order.", "The provided hint includes a virtual table that summarizes the total number of distinct products associated with each order, which we can directly use to form our SQL query."], "gold_sql": "SELECT order_id ,  count(*) FROM Order_items GROUP BY order_id", "source_tables": ["order_items"], "pred_sql": "SELECT order_id, count(DISTINCT product_id) AS number_of_items FROM Order_Items GROUP BY order_id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of distinct products associated with each order from the 'Order_Items' table. The placeholder in the SELECT clause represents the unique order identifier, while the count function calculates the number of different products for each order.\",\n        \"virtual_table\": \"SELECT order_id ,  count(DISTINCT product_id) FROM Order_items GROUP BY order_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of unique customers who have opened accounts in the 'Accounts' table. The placeholder in the SELECT statement allows for potential filtering or additional conditions to be applied if needed.\",\n        \"virtual_table\": \"SELECT count(DISTINCT customer_id) FROM Accounts\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total number of financial transactions associated with each invoice from the 'Financial_Transactions' table. The placeholder in the SELECT clause represents the invoice number, while the count function aggregates the number of transactions for each invoice.\",\n        \"virtual_table\": \"SELECT invoice_number ,  count(*) FROM Financial_transactions GROUP BY invoice_number\"\n    }\n}\n"}
{"sample_id": "train.1622", "db_id": "customers_and_invoices", "question": "What are teh names of the different products, as well as the number of customers who have ordered each product.", "rationale": ["Identify the tables needed: Products, Order_Items, and Orders.", "We need to get the product names from the Products table.", "We need to count the number of distinct customers who have ordered each product, which requires joining the Order_Items table to link products to orders, and then joining the Orders table to link orders to customers.", "Use COUNT(DISTINCT o.customer_id) to count unique customers for each product.", "Group the results by product name to get the count for each product."], "gold_sql": "SELECT T2.product_name ,  count(*) FROM Order_items AS T1 JOIN Products AS T2 ON T1.product_id  =  T2.product_id JOIN Orders AS T3 ON T3.order_id  =  T1.order_id GROUP BY T2.product_name", "source_tables": ["orders", "products", "order_items"], "pred_sql": "SELECT p.product_name, COUNT(DISTINCT o.customer_id) AS customer_count\nFROM Products p\nJOIN Order_Items oi ON p.product_id = oi.product_id\nJOIN Orders o ON oi.order_id = o.order_id\nGROUP BY p.product_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of distinct products associated with each order from the 'Order_Items' table. The placeholder in the SELECT clause represents the unique order identifier, while the count function calculates the number of different products for each order.\",\n        \"virtual_table\": \"SELECT order_id ,  count(DISTINCT product_id) FROM Order_items GROUP BY order_id\"\n    }\n}\n"}
{"sample_id": "train.2050", "db_id": "party_people", "question": "Which ministers are not a part of the Progress Party?", "rationale": ["Identify the relevant table: The 'party' table contains information about political parties and their associated ministers.", "Determine the required information: We need to find ministers who are not part of the 'Progress Party'.", "Use the provided hint to construct the SQL query: The hint suggests using a SELECT statement to retrieve ministers from the 'party' table while excluding the 'Progress Party'.", "Formulate the SQL query: The final SQL query selects the 'minister' column from the 'party' table where the 'Party_name' is not equal to 'Progress Party'."], "gold_sql": "SELECT minister FROM party WHERE party_name != 'Progress Party'", "source_tables": ["party"], "pred_sql": "SELECT minister FROM party WHERE Party_name != 'Progress Party'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the ministers associated with political parties from the 'party' table, excluding a specific party name. The placeholder in the WHERE clause represents the name of the party to be excluded.\",\n        \"virtual_table\": \"SELECT minister FROM party WHERE party_name != [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2057", "db_id": "party_people", "question": "Show all party names and the number of members in each party.", "rationale": ["Identify the tables needed: We need data from the 'party' table for party names and the 'member' table for counting members.", "Join the 'party' table with the 'member' table on the Party_ID to associate members with their respective parties.", "Use COUNT() function to count the number of members for each party.", "Group the results by party name to get the count of members for each party."], "gold_sql": "SELECT T2.party_name ,  count(*) FROM Member AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id", "source_tables": ["party", "member"], "pred_sql": "SELECT party.Party_name, COUNT(member.Member_ID) AS Number_of_Members\nFROM party\nLEFT JOIN member ON party.Party_ID = member.Party_ID\nGROUP BY party.Party_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the ministers associated with political parties from the 'party' table, excluding a specific party name. The placeholder in the WHERE clause represents the name of the party to be excluded.\",\n        \"virtual_table\": \"SELECT minister FROM party WHERE party_name != [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2072", "db_id": "party_people", "question": "How many events are there for each party?", "rationale": ["Identify the relevant tables: We need to gather information from the 'party' and 'party_events' tables.", "Determine the relationship: The 'party' table contains the party names, and the 'party_events' table contains the events associated with each party. We can join these tables on the 'Party_ID'.", "Count the events: We need to count the number of events for each party, which can be done using the COUNT() function.", "Group the results: To get the count of events for each party, we will group the results by the party name."], "gold_sql": "SELECT T2.party_name ,  count(*) FROM party_events AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id", "source_tables": ["party", "party_events"], "pred_sql": "SELECT party.Party_name, COUNT(party_events.Event_ID) AS Event_Count\nFROM party\nLEFT JOIN party_events ON party.Party_ID = party_events.Party_ID\nGROUP BY party.Party_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the ministers associated with political parties from the 'party' table, excluding a specific party name. The placeholder in the WHERE clause represents the name of the party to be excluded.\",\n        \"virtual_table\": \"SELECT minister FROM party WHERE party_name != [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2081", "db_id": "party_people", "question": "How many Annual Meeting events happened in the United Kingdom region?", "rationale": ["Identify the relevant tables: party_events, party, and region are needed to answer the question.", "We need to count the number of events, so we will use the COUNT() function.", "The event name we are interested in is 'Annual Meeting', so we will filter on this in the WHERE clause.", "We need to join the party_events table with the party table on Party_ID to get the region information.", "Next, we join the party table with the region table on Region_ID to filter by the United Kingdom region.", "Finally, we will select the count of events that match the criteria."], "gold_sql": "SELECT count(*) FROM region AS t1 JOIN party AS t2 ON t1.region_id  =  t2.region_id JOIN party_events AS t3 ON t2.party_id  =  t3.party_id WHERE t1.region_name  =  'United Kingdom' AND t3.Event_Name  =  'Annaual Meeting'", "source_tables": ["party", "party_events", "region"], "pred_sql": "SELECT COUNT(*) AS Annual_Meeting_Count\nFROM party_events pe\nJOIN party p ON pe.Party_ID = p.Party_ID\nJOIN region r ON p.Region_ID = r.Region_ID\nWHERE pe.Event_Name = 'Annual Meeting' AND r.Region_name = 'United Kingdom';", "hint": "\n"}
{"sample_id": "train.2167", "db_id": "formula_1", "question": "What is the id and family name of the driver who has the longest laptime?", "rationale": ["Identify the relevant tables: We need data from the 'results' table for lap times and the 'drivers' table for driver information.", "We need to find the driver with the longest lap time, which means we need to find the maximum time in the 'results' table.", "To get the driver's family name, we will join the 'results' table with the 'drivers' table on the driverId.", "The final query will select the driverId and surname of the driver whose lap time is the maximum."], "gold_sql": "SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT 1", "source_tables": ["laptimes", "drivers"], "pred_sql": "SELECT results.driverId, drivers.surname \nFROM results \nJOIN drivers ON results.driverId = drivers.driverId \nWHERE results.time = (SELECT MAX(time) FROM results);", "hint": "\n"}
{"sample_id": "train.2174", "db_id": "formula_1", "question": "How many drivers did not race in 2009?", "rationale": ["We need to find the number of drivers who did not participate in any races in the year 2009.", "To do this, we will use the 'drivers' table to get all drivers.", "We will perform a LEFT JOIN with the 'results' table on the driverId, filtering for the year 2009.", "The LEFT JOIN will allow us to include all drivers, even those who have no corresponding entries in the results for 2009.", "We will then filter the results to find those drivers where the result's driverId is NULL, indicating they did not race in 2009.", "Finally, we will count the distinct driverIds that meet this condition to get the total number of drivers who did not race in 2009."], "gold_sql": "SELECT count(DISTINCT driverId) FROM results WHERE raceId NOT IN( SELECT raceId FROM races WHERE YEAR != 2009 )", "source_tables": ["results", "races"], "pred_sql": "SELECT COUNT(DISTINCT d.driverId) AS drivers_not_raced_in_2009\nFROM drivers d\nLEFT JOIN results r ON d.driverId = r.driverId AND r.year = 2009\nWHERE r.driverId IS NULL;", "hint": "\n"}
{"sample_id": "train.2179", "db_id": "formula_1", "question": "Find the id and forenames of drivers who participated both the races with name Australian Grand Prix and the races with name Chinese Grand Prix?", "rationale": ["Identify the tables needed: We need the 'drivers' table for driver information and the 'results' and 'races' tables to link drivers to the races they participated in.", "Join the 'drivers' table with the 'results' table to get the races each driver participated in.", "Join the 'results' table with the 'races' table to filter races by their names (Australian Grand Prix and Chinese Grand Prix).", "Use two joins on the 'results' and 'races' tables to check for participation in both races.", "Filter the results to only include drivers who participated in both races by using a WHERE clause with the race names.", "Select the required fields: driverId and forename from the 'drivers' table."], "gold_sql": "SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = 'Australian Grand Prix' INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = 'Chinese Grand Prix'", "source_tables": ["races", "drivers", "results"], "pred_sql": "SELECT d.driverId, d.forename \nFROM drivers d \nJOIN results r1 ON d.driverId = r1.driverId \nJOIN races ra ON r1.raceId = ra.raceId \nJOIN results r2 ON d.driverId = r2.driverId \nJOIN races rb ON r2.raceId = rb.raceId \nWHERE ra.name = 'Australian Grand Prix' \nAND rb.name = 'Chinese Grand Prix' \nGROUP BY d.driverId, d.forename;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a distinct list of race names from the 'races' table, sorted in descending order. The placeholder in the ORDER BY clause indicates that the results will be organized based on the race names.\",\n        \"virtual_table\": \"SELECT DISTINCT name FROM races ORDER BY name DESC\"\n    }\n}\n"}
{"sample_id": "train.2180", "db_id": "formula_1", "question": "What is the id and first name of all the drivers who participated in the Australian Grand Prix and the Chinese Grand Prix?", "rationale": ["Identify the tables needed: drivers, results, and races.", "We need to get the driverId and forename from the drivers table.", "We need to join the results table to link drivers to the races they participated in.", "We also need to join the races table to filter for the specific races: Australian Grand Prix and Chinese Grand Prix.", "Use a WHERE clause to filter the races by their names.", "Group by driverId and forename to ensure unique results."], "gold_sql": "SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = 'Australian Grand Prix' INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = 'Chinese Grand Prix'", "source_tables": ["races", "drivers", "results"], "pred_sql": "SELECT d.driverId, d.forename \nFROM drivers d \nJOIN results r ON d.driverId = r.driverId \nJOIN races ra ON r.raceId = ra.raceId \nWHERE ra.name IN ('Australian Grand Prix', 'Chinese Grand Prix') \nGROUP BY d.driverId, d.forename;", "hint": "\n"}
{"sample_id": "train.2182", "db_id": "formula_1", "question": "What are the first and last names of all drivers who participated in the Australian Grand Prix but not the Chinese Grand Prix?", "rationale": ["Identify the tables needed: drivers, results, and races.", "We need to find drivers who participated in the Australian Grand Prix, so we will join the drivers table with the results table and then with the races table to filter by the race name.", "Next, we need to ensure these drivers did not participate in the Chinese Grand Prix. We can achieve this by using a subquery that selects driverIds from results for the Chinese Grand Prix.", "The final query will select the forename and surname of drivers who meet the criteria of participating in the Australian Grand Prix but not in the Chinese Grand Prix."], "gold_sql": "SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Australian Grand Prix' EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Chinese Grand Prix'", "source_tables": ["races", "drivers", "results"], "pred_sql": "SELECT d.forename, d.surname \nFROM drivers d \nJOIN results r1 ON d.driverId = r1.driverId \nJOIN races ra ON r1.raceId = ra.raceId \nWHERE ra.name = 'Australian Grand Prix' \nAND d.driverId NOT IN (\n    SELECT r2.driverId \n    FROM results r2 \n    JOIN races rb ON r2.raceId = rb.raceId \n    WHERE rb.name = 'Chinese Grand Prix'\n);", "hint": "\n"}
{"sample_id": "train.2190", "db_id": "formula_1", "question": "For each constructor id, how many races are there?", "rationale": ["The task is to count the number of races for each constructor id.", "The relevant table for this information is 'constructorStandings', which contains a record of standings for each constructor in various races.", "To get the count of races for each constructor, we can use the COUNT() function on the rows grouped by 'constructorId'.", "The SQL query will select the count of races and the constructorId, grouping the results by constructorId to get the total number of races for each constructor."], "gold_sql": "SELECT count(*) ,  constructorid FROM constructorStandings GROUP BY constructorid", "source_tables": ["constructorstandings"], "pred_sql": "SELECT COUNT(*) AS race_count, constructorId FROM constructorStandings GROUP BY constructorId", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of the total number of constructor standings for each constructor from the 'constructorStandings' table. The placeholder in the SELECT statement represents the constructor's identifier, which is grouped to show the total standings for each constructor.\",\n        \"virtual_table\": \"SELECT count(*) ,  constructorid FROM constructorStandings GROUP BY constructorid\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a distinct list of race names from the 'races' table, sorted in descending order. The placeholder in the ORDER BY clause indicates that the results will be organized based on the race names.\",\n        \"virtual_table\": \"SELECT DISTINCT name FROM races ORDER BY name DESC\"\n    }\n}\n"}
{"sample_id": "train.2194", "db_id": "formula_1", "question": "What are the names of all races held after 2000 in Spain?", "rationale": ["Identify the relevant tables: 'races' for race information and 'circuits' for circuit location.", "We need to filter races held after the year 2000, so we will use the 'year' column from the 'races' table.", "We also need to filter for races held in Spain, which requires joining the 'circuits' table to access the 'country' column.", "The join condition will be on 'circuitId' which is common in both 'races' and 'circuits' tables.", "We will select distinct race names to avoid duplicates and order the results by race name in descending order."], "gold_sql": "SELECT DISTINCT T1.name FROM races AS T1 JOIN circuits AS T2 ON T1.circuitid = T2.circuitid WHERE T2.country = 'Spain' AND T1.year > 2000", "source_tables": ["races", "circuits"], "pred_sql": "SELECT DISTINCT r.name \nFROM races r \nJOIN circuits c ON r.circuitId = c.circuitId \nWHERE r.year > 2000 AND c.country = 'Spain' \nORDER BY r.name DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a distinct list of race names from the 'races' table, sorted in descending order. The placeholder in the ORDER BY clause indicates that the results will be organized based on the race names.\",\n        \"virtual_table\": \"SELECT DISTINCT name FROM races ORDER BY name DESC\"\n    }\n}\n"}
{"sample_id": "train.2217", "db_id": "formula_1", "question": "Find the names of Japanese constructors that have once earned more than 5 points?", "rationale": ["We need to find the names of constructors from Japan that have earned more than 5 points.", "First, we will use the 'constructorStandings' table to sum the points for each constructor. We will group by 'constructorId' and use the HAVING clause to filter those with more than 5 points.", "Next, we will join this result with the 'constructors' table to get the names of the constructors.", "Finally, we will filter the constructors to only include those with a nationality of 'Japanese'."], "gold_sql": "SELECT T1.name FROM constructors AS T1 JOIN constructorstandings AS T2 ON T1.constructorid = T2.constructorid WHERE T1.nationality = 'Japanese' AND T2.points > 5", "source_tables": ["constructorstandings", "constructors"], "pred_sql": "SELECT c.name \nFROM constructors c \nJOIN (SELECT constructorId \n      FROM constructorStandings \n      GROUP BY constructorId \n      HAVING SUM(points) > 5) cs \nON c.constructorId = cs.constructorId \nWHERE c.nationality = 'Japanese';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of the total number of constructor standings for each constructor from the 'constructorStandings' table. The placeholder in the SELECT statement represents the constructor's identifier, which is grouped to show the total standings for each constructor.\",\n        \"virtual_table\": \"SELECT count(*) ,  constructorid FROM constructorStandings GROUP BY constructorid\"\n    }\n}\n"}
{"sample_id": "train.2218", "db_id": "formula_1", "question": "What are the names of all the Japanese constructors that have earned more than 5 points?", "rationale": ["Identify the relevant tables: We need to get constructor names and their points, so we will use the 'constructors' and 'constructorStandings' tables.", "We need to filter constructors based on their nationality, which is found in the 'constructors' table.", "We need to sum the points from the 'constructorStandings' table for each constructor and filter those with more than 5 points. This can be done using a subquery that groups by 'constructorId' and uses HAVING to filter the results.", "Join the results of the subquery with the 'constructors' table to get the names of the constructors that meet the criteria.", "Finally, filter the results to only include constructors from Japan."], "gold_sql": "SELECT T1.name FROM constructors AS T1 JOIN constructorstandings AS T2 ON T1.constructorid = T2.constructorid WHERE T1.nationality = 'Japanese' AND T2.points > 5", "source_tables": ["constructorstandings", "constructors"], "pred_sql": "SELECT c.name \nFROM constructors c \nJOIN (\n    SELECT constructorId \n    FROM constructorStandings \n    GROUP BY constructorId \n    HAVING SUM(points) > 5\n) cs ON c.constructorId = cs.constructorId \nWHERE c.nationality = 'Japanese';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of the total number of constructor standings for each constructor from the 'constructorStandings' table. The placeholder in the SELECT statement represents the constructor's identifier, which is grouped to show the total standings for each constructor.\",\n        \"virtual_table\": \"SELECT count(*) ,  constructorid FROM constructorStandings GROUP BY constructorid\"\n    }\n}\n"}
{"sample_id": "train.2220", "db_id": "formula_1", "question": "What is the average fastest lap speed for the Monaco Grand Prix in 2008?", "rationale": ["Identify the relevant tables: races, lapTimes, and circuits are needed to get the race information and lap times.", "We need to find the average fastest lap speed, so we will use the AVG() function on the fastestLapSpeed column from the lapTimes table.", "To filter for the Monaco Grand Prix in 2008, we will join the races table with the circuits table to get the circuit name and filter by the year in the races table.", "The WHERE clause will specify that the circuit name is 'Monaco Grand Prix' and the year is 2008."], "gold_sql": "SELECT avg(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "pred_sql": "SELECT AVG(lapTimes.fastestLapSpeed) AS average_fastest_lap_speed\nFROM races\nJOIN lapTimes ON races.raceId = lapTimes.raceId\nJOIN circuits ON races.circuitId = circuits.circuitId\nWHERE circuits.name = 'Monaco Grand Prix' AND races.year = 2008;", "hint": "\n"}
{"sample_id": "train.2222", "db_id": "formula_1", "question": "What is the maximum fastest lap speed in the Monaco Grand Prix in 2008?", "rationale": ["Identify the relevant tables: races, lapTimes, and circuits.", "We need to find the maximum fastest lap speed, so we will use the MAX() function on the fastestLapSpeed column from the lapTimes table.", "To get the fastest lap speed for the Monaco Grand Prix in 2008, we need to filter the races table for the year 2008 and the circuit name 'Monaco Grand Prix'.", "Join the races table with the lapTimes table on raceId to access the fastest lap speeds for each race.", "Join the races table with the circuits table on circuitId to filter by the circuit name.", "Construct the SQL query to select the maximum fastest lap speed with the appropriate joins and where conditions."], "gold_sql": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "pred_sql": "SELECT MAX(lapTimes.fastestLapSpeed) AS max_fastest_lap_speed\nFROM races\nJOIN lapTimes ON races.raceId = lapTimes.raceId\nJOIN circuits ON races.circuitId = circuits.circuitId\nWHERE circuits.name = 'Monaco Grand Prix' AND races.year = 2008;", "hint": "\n"}
{"sample_id": "train.2223", "db_id": "formula_1", "question": "What are the maximum fastest lap speed in races held after 2004 grouped by race name and ordered by year?", "rationale": ["Identify the relevant tables: races, results, and lapTimes are needed to get race names and fastest lap speeds.", "Join the races table with the results table on raceId to link races with their results.", "Join the results table with the lapTimes table on raceId and driverId to get the fastest lap speeds for each race.", "Filter the results to include only races held after the year 2004 using a WHERE clause.", "Group the results by race name to calculate the maximum fastest lap speed for each race using GROUP BY.", "Select the race name and the maximum fastest lap speed, and order the results by year."], "gold_sql": "SELECT max(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "pred_sql": "SELECT r.name, MAX(l.fastestLapSpeed) AS max_fastest_lap_speed\nFROM races r\nJOIN results res ON r.raceId = res.raceId\nJOIN lapTimes l ON res.raceId = l.raceId AND res.driverId = l.driverId\nWHERE r.year > 2004\nGROUP BY r.name\nORDER BY r.year;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a distinct list of race names from the 'races' table, sorted in descending order. The placeholder in the ORDER BY clause indicates that the results will be organized based on the race names.\",\n        \"virtual_table\": \"SELECT DISTINCT name FROM races ORDER BY name DESC\"\n    }\n}\n"}
{"sample_id": "train.2224", "db_id": "formula_1", "question": "For each race name, What is the maximum fastest lap speed for races after 2004 ordered by year?", "rationale": ["We need to find the maximum fastest lap speed for each race name after the year 2004.", "First, we will select the race names from the 'races' table and join it with the 'results' table to get the race results.", "Next, we will join the 'lapTimes' table to access the fastest lap speeds associated with each race.", "We will filter the results to include only those races that occurred after the year 2004 using a WHERE clause.", "To get the maximum fastest lap speed for each race, we will use the MAX() function and group the results by race name.", "Finally, we will order the results by year to meet the requirement of the query."], "gold_sql": "SELECT max(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "pred_sql": "SELECT r.name, MAX(l.fastestLapSpeed) AS max_fastest_lap_speed\nFROM races r\nJOIN results res ON r.raceId = res.raceId\nJOIN lapTimes l ON r.raceId = l.raceId\nWHERE r.year > 2004\nGROUP BY r.name\nORDER BY r.year;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a distinct list of race names from the 'races' table, sorted in descending order. The placeholder in the ORDER BY clause indicates that the results will be organized based on the race names.\",\n        \"virtual_table\": \"SELECT DISTINCT name FROM races ORDER BY name DESC\"\n    }\n}\n"}
{"sample_id": "train.2325", "db_id": "csu_1", "question": "What campuses are located in the county of Los Angeles?", "rationale": ["Identify the relevant table: The question pertains to campuses and their locations, so we will use the 'Campuses' table.", "Determine the filtering criteria: The user is interested in campuses located in the county of Los Angeles.", "Construct the SQL query: We will select the 'Campus' column from the 'Campuses' table where the 'County' column matches 'Los Angeles'."], "gold_sql": "SELECT campus FROM campuses WHERE county  =  'Los Angeles'", "source_tables": ["campuses"], "pred_sql": "SELECT Campus FROM Campuses WHERE County = 'Los Angeles'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the campuses located in a specific county from the 'Campuses' table. The placeholder in the WHERE clause represents the name of the county.\",\n        \"virtual_table\": \"SELECT campus FROM campuses WHERE county  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves the names of campuses located in a specific geographical location and county. The query combines results from two identical selections, allowing for the possibility of filtering by different criteria for the same location and county. The placeholders in the WHERE clauses represent the location and county names.\",\n        \"virtual_table\": \"SELECT campus FROM campuses WHERE LOCATION  =  [PLACEHOLDER-TYPE:STRING] AND county  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT campus FROM campuses WHERE LOCATION  =  [PLACEHOLDER-TYPE:STRING] AND county  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table retrieves the names of campuses located in a specific geographical location and county. The query combines results from two identical selections, allowing for the possibility of filtering by two different sets of location and county criteria. The placeholders in the WHERE clauses represent the specific location and county names to be provided by the user.\",\n        \"virtual_table\": \"SELECT campus FROM campuses WHERE LOCATION  =  [PLACEHOLDER-TYPE:STRING] AND county  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT campus FROM campuses WHERE LOCATION  =  [PLACEHOLDER-TYPE:STRING] AND county  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2347", "db_id": "csu_1", "question": "In what year was the most degrees conferred?", "rationale": ["Identify the relevant table: degrees, which contains information about the years when degrees were awarded.", "We need to find the year with the most degrees conferred, so we will group the results by Year.", "Count the number of degrees awarded for each year using COUNT(Degrees).", "Order the results in descending order to get the year with the highest count first.", "Limit the results to 1 to get only the year with the most degrees conferred."], "gold_sql": "SELECT YEAR FROM degrees GROUP BY YEAR ORDER BY sum(degrees) DESC LIMIT 1", "source_tables": ["degrees"], "pred_sql": "SELECT Year FROM degrees GROUP BY Year ORDER BY COUNT(Degrees) DESC LIMIT 1;", "hint": "\n"}
{"sample_id": "train.2348", "db_id": "csu_1", "question": "Which campus has the most degrees conferred in all times?", "rationale": ["Identify the relevant table for degrees conferred, which is the 'degrees' table.", "We need to count the number of degrees awarded for each campus, so we will use the COUNT function on the 'Degrees' column.", "Group the results by 'Campus' to aggregate the counts for each campus.", "Order the results in descending order to get the campus with the most degrees at the top.", "Limit the results to 1 to get only the campus with the highest count of degrees."], "gold_sql": "SELECT campus FROM degrees GROUP BY campus ORDER BY sum(degrees) DESC LIMIT 1", "source_tables": ["degrees"], "pred_sql": "SELECT Campus, COUNT(Degrees) AS TotalDegrees\nFROM degrees\nGROUP BY Campus\nORDER BY TotalDegrees DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of campuses from the 'Campuses' table that have records for a specific year. The placeholder in the WHERE clause represents the year for which the campus data is being queried.\",\n        \"virtual_table\": \"SELECT campus FROM campuses WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the campuses from the 'Campuses' table that are located in a specific geographical location. The placeholder in the WHERE clause represents the location of the campus.\",\n        \"virtual_table\": \"SELECT campus FROM campuses WHERE LOCATION  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2349", "db_id": "csu_1", "question": "What campus has the most degrees  conferrred over its entire existence?", "rationale": ["The question asks for the campus with the most degrees conferred over its entire existence, which implies we need to count the total degrees awarded for each campus.", "We will use the 'degrees' table, which contains the 'Campus' and 'Degrees' columns.", "To find the total number of degrees for each campus, we will use the COUNT function and group the results by 'Campus'.", "We will then order the results in descending order based on the total count of degrees to get the campus with the highest number.", "Finally, we will limit the results to 1 to get only the campus with the most degrees conferred."], "gold_sql": "SELECT campus FROM degrees GROUP BY campus ORDER BY sum(degrees) DESC LIMIT 1", "source_tables": ["degrees"], "pred_sql": "SELECT Campus, COUNT(Degrees) AS TotalDegrees\nFROM degrees\nGROUP BY Campus\nORDER BY TotalDegrees DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of campuses from the 'Campuses' table that have records for a specific year. The placeholder in the WHERE clause represents the year for which the campus data is being queried.\",\n        \"virtual_table\": \"SELECT campus FROM campuses WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the campuses from the 'Campuses' table that are located in a specific geographical location. The placeholder in the WHERE clause represents the location of the campus.\",\n        \"virtual_table\": \"SELECT campus FROM campuses WHERE LOCATION  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the campuses located in a specific county from the 'Campuses' table. The placeholder in the WHERE clause represents the name of the county.\",\n        \"virtual_table\": \"SELECT campus FROM campuses WHERE county  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2351", "db_id": "csu_1", "question": "What campus has the most faculties in 2003?", "rationale": ["Identify the relevant tables: 'Campuses' for campus names and 'faculty' for faculty counts.", "Join the 'Campuses' table with the 'faculty' table on the campus identifier.", "Filter the results to only include records from the year 2003.", "Order the results by the number of faculty in descending order to find the campus with the most faculty.", "Limit the results to 1 to get only the campus with the highest faculty count."], "gold_sql": "SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  2003 ORDER BY T2.faculty DESC LIMIT 1", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT c.Campus, f.Faculty \nFROM Campuses c \nJOIN faculty f ON c.Id = f.Campus \nWHERE f.Year = 2003 \nORDER BY f.Faculty DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of campuses from the 'Campuses' table that have records for a specific year. The placeholder in the WHERE clause represents the year for which the campus data is being queried.\",\n        \"virtual_table\": \"SELECT campus FROM campuses WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the campuses located in a specific county from the 'Campuses' table. The placeholder in the WHERE clause represents the name of the county.\",\n        \"virtual_table\": \"SELECT campus FROM campuses WHERE county  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the campuses from the 'Campuses' table that are located in a specific geographical location. The placeholder in the WHERE clause represents the location of the campus.\",\n        \"virtual_table\": \"SELECT campus FROM campuses WHERE LOCATION  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2358", "db_id": "csu_1", "question": "For each Orange county campus, report the number of degrees granted after 2000.", "rationale": ["Identify the relevant tables: We need to look at the 'degrees' table to find the number of degrees granted and the 'Campuses' table to filter campuses by county.", "Filter campuses: Use a subquery to select campuses located in 'Orange' county from the 'Campuses' table.", "Count degrees: Use the COUNT function to count the number of degrees awarded after the year 2000 for the selected campuses."], "gold_sql": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  'Orange' AND T2.year  >=  2000 GROUP BY T1.campus", "source_tables": ["degrees", "campuses"], "pred_sql": "SELECT COUNT(Degrees) AS NumberOfDegrees\nFROM degrees\nWHERE Campus IN (SELECT Id FROM Campuses WHERE County = 'Orange')\nAND Year > '2000';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the total count of campuses located in a specific county from the 'Campuses' table. The placeholder in the WHERE clause represents the name of the county.\",\n        \"virtual_table\": \"SELECT count(*) FROM campuses WHERE county  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the campuses located in a specific county from the 'Campuses' table. The placeholder in the WHERE clause represents the name of the county.\",\n        \"virtual_table\": \"SELECT campus FROM campuses WHERE county  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of campuses from the 'Campuses' table that have records for a specific year. The placeholder in the WHERE clause represents the year for which the campus data is being queried.\",\n        \"virtual_table\": \"SELECT campus FROM campuses WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2359", "db_id": "csu_1", "question": "What is the total number of degrees granted after 2000 for each Orange county campus?", "rationale": ["Identify the relevant tables: 'degrees' for degrees granted and 'Campuses' for campus information.", "We need to filter the degrees awarded after the year 2000, so we will use a WHERE clause on the 'Year' column in the 'degrees' table.", "We also need to filter the campuses located in Orange County, so we will join the 'degrees' table with the 'Campuses' table on the 'Campus' identifier and apply a WHERE clause for the 'County'.", "To get the total number of degrees for each campus, we will use the COUNT function and group the results by campus name.", "The final SQL query will select the campus name and the count of degrees, applying the necessary filters and grouping."], "gold_sql": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  'Orange' AND T2.year  >=  2000 GROUP BY T1.campus", "source_tables": ["degrees", "campuses"], "pred_sql": "SELECT c.Campus, COUNT(d.Degrees) AS TotalDegrees\nFROM degrees d\nJOIN Campuses c ON d.Campus = c.Id\nWHERE c.County = 'Orange' AND d.Year > '2000'\nGROUP BY c.Campus;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the total count of campuses located in a specific county from the 'Campuses' table. The placeholder in the WHERE clause represents the name of the county.\",\n        \"virtual_table\": \"SELECT count(*) FROM campuses WHERE county  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the campuses located in a specific county from the 'Campuses' table. The placeholder in the WHERE clause represents the name of the county.\",\n        \"virtual_table\": \"SELECT campus FROM campuses WHERE county  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2362", "db_id": "csu_1", "question": "What campus had more than 400 total enrollment but more than 200 full time enrollment in year 1956?", "rationale": ["Identify the relevant tables: Campuses and enrollments are needed to get campus names and their enrollment data.", "Join the Campuses table with the enrollments table on the campus identifier (Id).", "Filter the results for the year 1956 using the WHERE clause.", "Add conditions to filter campuses with total enrollment greater than 400 and full-time equivalent enrollment greater than 200."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN enrollments AS t2 ON t1.id  =  t2.campus WHERE t2.year  =  1956 AND totalenrollment_ay  >  400 AND FTE_AY  >  200", "source_tables": ["enrollments", "campuses"], "pred_sql": "SELECT c.Campus \nFROM Campuses c \nJOIN enrollments e ON c.Id = e.Campus \nWHERE e.Year = '1956' \nAND e.TotalEnrollment_AY > 400 \nAND e.FTE_AY > 200;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of campuses from the 'Campuses' table that have records for a specific year. The placeholder in the WHERE clause represents the year for which the campus data is being queried.\",\n        \"virtual_table\": \"SELECT campus FROM campuses WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the campuses located in a specific county from the 'Campuses' table. The placeholder in the WHERE clause represents the name of the county.\",\n        \"virtual_table\": \"SELECT campus FROM campuses WHERE county  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the total count of campuses located in a specific county from the 'Campuses' table. The placeholder in the WHERE clause represents the name of the county.\",\n        \"virtual_table\": \"SELECT count(*) FROM campuses WHERE county  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2367", "db_id": "csu_1", "question": "What campuses are in Los Angeles county?", "rationale": ["Identify the relevant table: The question asks about campuses, so we will use the 'Campuses' table.", "Determine the filtering criteria: The question specifies 'Los Angeles county', which means we need to filter the results based on the 'County' column.", "Construct the SQL query: We will select the 'Campus' column from the 'Campuses' table where the 'County' is 'Los Angeles'."], "gold_sql": "SELECT campus FROM campuses WHERE county  =  'Los Angeles'", "source_tables": ["campuses"], "pred_sql": "SELECT Campus FROM Campuses WHERE County = 'Los Angeles'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the campuses located in a specific county from the 'Campuses' table. The placeholder in the WHERE clause represents the name of the county.\",\n        \"virtual_table\": \"SELECT campus FROM campuses WHERE county  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves the names of campuses located in a specific geographical location and county. The query combines results from two identical selections, allowing for the possibility of filtering by different criteria for the same location and county. The placeholders in the WHERE clauses represent the location and county names.\",\n        \"virtual_table\": \"SELECT campus FROM campuses WHERE LOCATION  =  [PLACEHOLDER-TYPE:STRING] AND county  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT campus FROM campuses WHERE LOCATION  =  [PLACEHOLDER-TYPE:STRING] AND county  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table retrieves the names of campuses located in a specific geographical location and county. The query combines results from two identical selections, allowing for the possibility of filtering by two different sets of location and county criteria. The placeholders in the WHERE clauses represent the specific location and county names to be provided by the user.\",\n        \"virtual_table\": \"SELECT campus FROM campuses WHERE LOCATION  =  [PLACEHOLDER-TYPE:STRING] AND county  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT campus FROM campuses WHERE LOCATION  =  [PLACEHOLDER-TYPE:STRING] AND county  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2368", "db_id": "csu_1", "question": "How many degrees were conferred in \"San Jose State University\" in 2000?", "rationale": ["Identify the relevant tables: degrees and Campuses.", "We need to count the number of degrees conferred, which is represented in the degrees table.", "We need to filter the results for the specific campus 'San Jose State University' and the year 2000.", "Join the degrees table with the Campuses table on the Campus identifier to get the campus name.", "Use a SUM function to count the degrees for the specified campus and year."], "gold_sql": "SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  'San Jose State University' AND t2.year  =  2000", "source_tables": ["degrees", "campuses"], "pred_sql": "SELECT SUM(CASE WHEN degrees.Campus = campuses.Id THEN 1 ELSE 0 END) AS TotalDegrees\nFROM degrees\nJOIN Campuses ON degrees.Campus = Campuses.Id\nWHERE Campuses.Campus = 'San Jose State University' AND degrees.Year = '2000';", "hint": "\n"}
{"sample_id": "train.2377", "db_id": "csu_1", "question": "How many faculty lines are there at San Francisco State University in 2004?", "rationale": ["Identify the relevant table: The 'faculty' table contains the number of faculty members.", "Determine the specific campus: We need to find the Id for 'San Francisco State University' from the 'Campuses' table.", "Filter by year: We need to specify the year 2004 in our query.", "Construct the SQL query: Use a subquery to find the campus Id and filter the faculty data accordingly."], "gold_sql": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  2004 AND T2.campus  =  'San Francisco State University'", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT Faculty FROM faculty WHERE Campus = (SELECT Id FROM Campuses WHERE Campus = 'San Francisco State University') AND Year = 2004;", "hint": "\n"}
{"sample_id": "train.2378", "db_id": "csu_1", "question": "List the campus that have between 600 and 1000 faculty lines in year 2004.", "rationale": ["Identify the relevant table: The 'faculty' table contains the number of faculty members at each campus along with the year of the data record.", "Determine the filtering criteria: We need to filter for the year 2004 and for campuses that have between 600 and 1000 faculty members.", "Construct the SQL query: We will select the 'Campus' from the 'faculty' table where the 'Year' is 2004 and the 'Faculty' count is between 600 and 1000."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  600 AND t2.faculty  <=  1000 AND T1.year  =  2004", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT c.Campus \nFROM faculty c \nWHERE c.Year = 2004 AND c.Faculty BETWEEN 600 AND 1000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of campuses from the 'Campuses' table that have records for a specific year. The placeholder in the WHERE clause represents the year for which the campus data is being queried.\",\n        \"virtual_table\": \"SELECT campus FROM campuses WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the campuses from the 'Campuses' table that are located in a specific geographical location. The placeholder in the WHERE clause represents the location of the campus.\",\n        \"virtual_table\": \"SELECT campus FROM campuses WHERE LOCATION  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the campuses located in a specific county from the 'Campuses' table. The placeholder in the WHERE clause represents the name of the county.\",\n        \"virtual_table\": \"SELECT campus FROM campuses WHERE county  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2379", "db_id": "csu_1", "question": "What are the campuses that had between 600 and 1000 faculty members in 2004?", "rationale": ["Identify the relevant table: The 'faculty' table contains the number of faculty members per campus and year.", "Specify the year: We are interested in the year 2004, so we will filter the records for that year.", "Set the condition for faculty members: We need to find campuses with faculty members between 600 and 1000, which can be expressed using the BETWEEN clause in SQL.", "Construct the SQL query: Combine the selected columns and conditions to form the final SQL query."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  600 AND t2.faculty  <=  1000 AND T1.year  =  2004", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT Campus FROM faculty WHERE Year = 2004 AND Faculty BETWEEN 600 AND 1000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of campuses from the 'Campuses' table that have records for a specific year. The placeholder in the WHERE clause represents the year for which the campus data is being queried.\",\n        \"virtual_table\": \"SELECT campus FROM campuses WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the campuses from the 'Campuses' table that are located in a specific geographical location. The placeholder in the WHERE clause represents the location of the campus.\",\n        \"virtual_table\": \"SELECT campus FROM campuses WHERE LOCATION  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the campuses located in a specific county from the 'Campuses' table. The placeholder in the WHERE clause represents the name of the county.\",\n        \"virtual_table\": \"SELECT campus FROM campuses WHERE county  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2380", "db_id": "csu_1", "question": "How many faculty lines are there in the university that conferred the most number of degrees in year 2002?", "rationale": ["Identify the year of interest, which is 2002.", "Determine which campus conferred the most degrees in 2002 by grouping the degrees table by campus and counting the number of degrees awarded.", "Use a subquery to find the campus with the maximum number of degrees awarded in 2002.", "Join the faculty table with the degrees table on the campus identifier to count the number of faculty lines associated with that campus.", "Filter the results to only include the campus that conferred the most degrees in 2002."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2002 ORDER BY t3.degrees DESC LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "pred_sql": "SELECT COUNT(faculty.Campus) AS FacultyCount\nFROM faculty\nJOIN degrees ON faculty.Campus = degrees.Campus\nWHERE degrees.Year = '2002'\nAND degrees.Campus = (SELECT Campus\n                     FROM degrees\n                     WHERE Year = '2002'\n                     GROUP BY Campus\n                     ORDER BY COUNT(Degrees) DESC\n                     LIMIT 1);", "hint": "\n"}
{"sample_id": "train.2383", "db_id": "csu_1", "question": "How many faculty members are at the university that gave the least number of degrees in 2001?", "rationale": ["Identify the relevant tables: 'faculty' for faculty members and 'degrees' for the number of degrees awarded.", "We need to find the campus that awarded the least number of degrees in 2001, so we will filter the 'degrees' table for the year 2001.", "We will order the results by the number of degrees in ascending order to get the campus with the least degrees.", "We will join the 'faculty' table with the 'degrees' table on the 'Campus' identifier to get the faculty count for that campus.", "Finally, we will limit the results to 1 to get only the campus with the least degrees and select the corresponding faculty count."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2001 ORDER BY t3.degrees LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "pred_sql": "SELECT f.Faculty \nFROM faculty f \nJOIN degrees d ON f.Campus = d.Campus \nWHERE d.Year = '2001' \nORDER BY d.Degrees ASC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.2385", "db_id": "csu_1", "question": "How many undergraduates are there at San Jose State", "rationale": ["Identify the relevant table for undergraduate enrollments, which is 'discipline_enrollments'.", "We need to sum the 'Undergraduate' column to get the total number of undergraduates.", "To filter the results for 'San Jose State', we need to join the 'discipline_enrollments' table with the 'Campuses' table on the 'Campus' identifier.", "Use a WHERE clause to specify that we are only interested in the campus named 'San Jose State'.", "Construct the SQL query to select the sum of undergraduates from the joined tables."], "gold_sql": "SELECT sum(t1.undergraduate) FROM discipline_enrollments AS t1 JOIN campuses AS t2 ON t1.campus  =  t2.id WHERE t1.year  =  2004 AND t2.campus  =  'San Jose State University'", "source_tables": ["discipline_enrollments", "campuses"], "pred_sql": "SELECT SUM(Undergraduate) AS Total_Undergraduates \nFROM discipline_enrollments \nJOIN Campuses ON discipline_enrollments.Campus = Campuses.Id \nWHERE Campuses.Campus = 'San Jose State';", "hint": "\n"}
{"sample_id": "train.3131", "db_id": "assets_maintenance", "question": "Which engineer has visited the most times? Show the engineer id, first name and last name.", "rationale": ["Identify the relevant tables: Engineer_Visits and Maintenance_Engineers.", "We need to count the number of visits for each engineer, so we will use COUNT(*) to aggregate the visits.", "Join the Engineer_Visits table with the Maintenance_Engineers table on the engineer_id to get the first name and last name of the engineers.", "Group the results by engineer_id, first_name, and last_name to get the count of visits for each engineer.", "Order the results by the visit count in descending order to find the engineer with the most visits.", "Limit the results to 1 to get only the engineer with the highest visit count."], "gold_sql": "SELECT T1.engineer_id ,  T1.first_name ,  T1.last_name FROM Maintenance_Engineers AS T1 JOIN Engineer_Visits AS T2 GROUP BY T1.engineer_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["maintenance_engineers", "engineer_visits"], "pred_sql": "SELECT engineer_id, first_name, last_name, COUNT(*) as visit_count\nFROM Engineer_Visits\nJOIN Maintenance_Engineers ON Engineer_Visits.engineer_id = Maintenance_Engineers.engineer_id\nGROUP BY engineer_id, first_name, last_name\nORDER BY visit_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3139", "db_id": "assets_maintenance", "question": "How many fault status codes are recorded in the fault log parts table?", "rationale": ["Identify the table of interest: Fault_Log_Parts.", "Determine the column that contains the fault status codes: fault_status.", "To find the number of unique fault status codes, use the COUNT function with DISTINCT to avoid duplicates.", "Construct the SQL query to select the count of distinct fault status codes from the Fault_Log_Parts table."], "gold_sql": "SELECT DISTINCT fault_status FROM Fault_Log_Parts", "source_tables": ["fault_log_parts"], "pred_sql": "SELECT COUNT(DISTINCT fault_status) AS unique_fault_status_count FROM Fault_Log_Parts;", "hint": "\n"}
{"sample_id": "train.3143", "db_id": "assets_maintenance", "question": "Which part fault requires the most number of skills to fix? List part id and name.", "rationale": ["Identify the relevant tables: Part_Faults, Skills_Required_To_Fix, and Parts.", "Join Part_Faults with Skills_Required_To_Fix to find the number of skills required for each part fault.", "Join the result with Parts to get the part name associated with each part fault.", "Group the results by part_id and part_name to count the number of skills for each part fault.", "Order the results in descending order based on the count of skills to find the part fault that requires the most skills.", "Limit the results to 1 to get only the top part fault."], "gold_sql": "SELECT T1.part_id ,  T1.part_name FROM Parts AS T1 JOIN Part_Faults AS T2 ON T1.part_id  =  T2.part_id JOIN Skills_Required_To_Fix AS T3 ON T2.part_fault_id  =  T3.part_fault_id GROUP BY T1.part_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["part_faults", "parts", "skills_required_to_fix"], "pred_sql": "SELECT pf.part_id, p.part_name\nFROM Part_Faults pf\nJOIN Skills_Required_To_Fix srf ON pf.part_fault_id = srf.part_fault_id\nJOIN Parts p ON pf.part_id = p.part_id\nGROUP BY pf.part_id, p.part_name\nORDER BY COUNT(srf.skill_id) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3176", "db_id": "college_1", "question": "How many professors teach a class with the code ACCT-211?", "rationale": ["Identify the relevant table: The CLASS table contains information about classes and the professors teaching them.", "Determine the specific requirement: We need to count the distinct professors teaching a specific class identified by the class code 'ACCT-211'.", "Use the provided virtual table as a template: The virtual table suggests using a count of distinct professors from the CLASS table filtered by the course code.", "Construct the SQL query: Incorporate the course code 'ACCT-211' into the WHERE clause of the virtual table template."], "gold_sql": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["class"], "pred_sql": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE = 'ACCT-211'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of distinct professors teaching classes associated with a specific course code from the 'CLASS' table. The placeholder in the WHERE clause represents the course code being queried.\",\n        \"virtual_table\": \"SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree type being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY dept_code\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree type being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY dept_code\"\n    }\n}\n"}
{"sample_id": "train.3180", "db_id": "college_1", "question": "What are the first names and birthdates of the professors in charge of ACCT-211?", "rationale": ["Identify the relevant tables: PROFESSOR, EMPLOYEE, and CLASS.", "We need to find the first names and birthdates of professors, so we will select EMP_FNAME and EMP_DOB from the EMPLOYEE table.", "To link professors to classes, we will join the PROFESSOR table with the EMPLOYEE table on EMP_NUM.", "We also need to join the CLASS table to find which professors are in charge of the specific course ACCT-211.", "The condition for the course is specified in the WHERE clause, filtering for CLASS.CRS_CODE = 'ACCT-211'."], "gold_sql": "SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["employee", "class"], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME, EMPLOYEE.EMP_DOB \nFROM PROFESSOR \nJOIN EMPLOYEE ON PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM \nJOIN CLASS ON PROFESSOR.EMP_NUM = CLASS.PROF_NUM \nWHERE CLASS.CRS_CODE = 'ACCT-211';", "hint": "\n"}
{"sample_id": "train.3189", "db_id": "college_1", "question": "How many different locations does the school with code BUS has?", "rationale": ["Identify the school code we are interested in, which is 'BUS'.", "We need to find the distinct locations (classrooms) where classes are held for this school.", "To do this, we will first find the class codes associated with the school code 'BUS' from the DEPARTMENT table.", "Next, we will use these class codes to count the distinct class rooms from the CLASS table.", "The final SQL query will count the distinct CLASS_ROOM values for the classes associated with the school code 'BUS'."], "gold_sql": "SELECT count(DISTINCT dept_address) FROM department WHERE school_code  =  'BUS'", "source_tables": ["department"], "pred_sql": "SELECT COUNT(DISTINCT CLASS_ROOM) FROM CLASS WHERE CLASS_CODE IN (SELECT CLASS_CODE FROM DEPARTMENT WHERE SCHOOL_CODE = 'BUS')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of distinct professors teaching classes associated with a specific course code from the 'CLASS' table. The placeholder in the WHERE clause represents the course code being queried.\",\n        \"virtual_table\": \"SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the unique class codes from the 'CLASS' table that are held in a specific classroom. The placeholder in the WHERE clause represents the room where the class is conducted.\",\n        \"virtual_table\": \"SELECT class_code FROM CLASS WHERE class_room  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3190", "db_id": "college_1", "question": "What are the different locations of the school with the code BUS?", "rationale": ["Identify the relevant table: The question asks for locations of the school, which relates to the DEPARTMENT table that contains the DEPT_ADDRESS and SCHOOL_CODE.", "Determine the condition: We need to filter the departments by the SCHOOL_CODE 'BUS'.", "Use DISTINCT to ensure we get unique addresses, as there may be multiple departments under the same school code.", "Construct the SQL query: Combine the selected columns and conditions into a valid SQL statement."], "gold_sql": "SELECT count(DISTINCT dept_address) FROM department WHERE school_code  =  'BUS'", "source_tables": ["department"], "pred_sql": "SELECT DISTINCT DEPT_ADDRESS FROM DEPARTMENT WHERE SCHOOL_CODE = 'BUS';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the unique class codes from the 'CLASS' table that are held in a specific classroom. The placeholder in the WHERE clause represents the room where the class is conducted.\",\n        \"virtual_table\": \"SELECT class_code FROM CLASS WHERE class_room  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3206", "db_id": "college_1", "question": "How many classes are held in each department?", "rationale": ["To find out how many classes are held in each department, we need to count the number of classes associated with each department.", "The CLASS table contains the CLASS_CODE and CRS_CODE, which links to the COURSE table.", "The COURSE table contains the DEPT_CODE, which links to the DEPARTMENT table.", "We will perform a JOIN operation between the DEPARTMENT, COURSE, and CLASS tables to get the necessary information.", "We will group the results by DEPT_CODE to count the number of classes for each department using COUNT().", "The final SQL query will select the DEPT_CODE and the count of CLASS_CODE as class_count."], "gold_sql": "SELECT count(*) ,  dept_code FROM CLASS AS T1 JOIN course AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY dept_code", "source_tables": ["course", "class"], "pred_sql": "SELECT d.DEPT_CODE, COUNT(c.CLASS_CODE) AS class_count \nFROM DEPARTMENT d \nJOIN COURSE co ON d.DEPT_CODE = co.DEPT_CODE \nJOIN CLASS c ON co.CRS_CODE = c.CRS_CODE \nGROUP BY d.DEPT_CODE;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total credit hours for courses grouped by department code from the 'COURSE' table. The placeholder in the SELECT clause represents the credit hours for each course, while the GROUP BY clause organizes the results by department code.\",\n        \"virtual_table\": \"SELECT sum(crs_credit) ,  dept_code FROM course GROUP BY dept_code\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total credit hours for courses grouped by department code from the 'COURSE' table. The placeholder in the SELECT clause represents the credit hours for each course, while the GROUP BY clause organizes the results by department code.\",\n        \"virtual_table\": \"SELECT sum(crs_credit) ,  dept_code FROM course GROUP BY dept_code\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total credit hours completed by students, grouped by their respective departments. The placeholder in the SELECT clause represents the total credit hours, while the GROUP BY clause organizes the results by department code.\",\n        \"virtual_table\": \"SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code\"\n    }\n}\n"}
{"sample_id": "train.3209", "db_id": "college_1", "question": "What is the number of professors for different school?", "rationale": ["The question asks for the number of professors for different schools, which implies a need to group the results by school.", "To achieve this, we need to join the DEPARTMENT and PROFESSOR tables since the department is associated with the school and the professors belong to departments.", "We will count the distinct professors (using EMP_NUM) to avoid counting the same professor multiple times if they belong to the same department.", "The GROUP BY clause will be used to group the results by SCHOOL_CODE, which is present in the DEPARTMENT table."], "gold_sql": "SELECT count(*) ,  T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code", "source_tables": ["department", "professor"], "pred_sql": "SELECT COUNT(DISTINCT EMP_NUM) AS professor_count, SCHOOL_CODE FROM DEPARTMENT JOIN PROFESSOR ON DEPARTMENT.DEPT_CODE = PROFESSOR.DEPT_CODE GROUP BY SCHOOL_CODE;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree type being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY dept_code\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree type being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY dept_code\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of distinct professors teaching classes associated with a specific course code from the 'CLASS' table. The placeholder in the WHERE clause represents the course code being queried.\",\n        \"virtual_table\": \"SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3210", "db_id": "college_1", "question": "How many different professors are there for the different schools?", "rationale": ["Identify the goal: Count the number of different professors across different schools.", "Understand the schema: The PROFESSOR table contains the unique identifiers for professors (EMP_NUM) and their associated department codes (DEPT_CODE).", "To find the number of different professors, we can use the COUNT function with DISTINCT on the EMP_NUM column in the PROFESSOR table.", "The query will be: SELECT COUNT(DISTINCT EMP_NUM) FROM PROFESSOR, which counts the unique professors without needing to filter by department or school."], "gold_sql": "SELECT count(*) ,  T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code", "source_tables": ["department", "professor"], "pred_sql": "SELECT COUNT(DISTINCT EMP_NUM) FROM PROFESSOR", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree type being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY dept_code\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree type being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY dept_code\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of distinct professors teaching classes associated with a specific course code from the 'CLASS' table. The placeholder in the WHERE clause represents the course code being queried.\",\n        \"virtual_table\": \"SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3217", "db_id": "college_1", "question": "Find the number of students for each department.", "rationale": ["Identify the relevant table: The STUDENT table contains information about students, including their department code.", "Determine the required output: We need to count the number of students in each department.", "Use the COUNT() function to count the number of students (STU_NUM) for each department (DEPT_CODE).", "Group the results by DEPT_CODE to get the count for each department."], "gold_sql": "SELECT count(*) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT DEPT_CODE, COUNT(STU_NUM) AS student_count FROM STUDENT GROUP BY DEPT_CODE", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree type being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY dept_code\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree type being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY dept_code\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the academic performance of students by department. It calculates the maximum, average, and minimum GPA of students grouped by their respective department codes. The placeholders in the SELECT statement represent the GPA metrics and department code.\",\n        \"virtual_table\": \"SELECT max(stu_gpa) ,  avg(stu_gpa) ,  min(stu_gpa) ,  dept_code FROM student GROUP BY dept_code\"\n    }\n}\n"}
{"sample_id": "train.3218", "db_id": "college_1", "question": "How many students are in each department?", "rationale": ["The question asks for the number of students in each department, which indicates a need to count students grouped by their department.", "The relevant table for student information is the STUDENT table, which contains a column for department code (DEPT_CODE).", "To get the count of students per department, we can use the COUNT() function on the student records, grouping the results by DEPT_CODE.", "The final SQL query will select the count of students and the department code, grouping by the department code."], "gold_sql": "SELECT count(*) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT COUNT(*) AS student_count, dept_code FROM student GROUP BY dept_code", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the academic performance of students by department. It calculates the maximum, average, and minimum GPA of students grouped by their respective department codes. The placeholders in the SELECT statement represent the GPA metrics and department code.\",\n        \"virtual_table\": \"SELECT max(stu_gpa) ,  avg(stu_gpa) ,  min(stu_gpa) ,  dept_code FROM student GROUP BY dept_code\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total credit hours completed by students, grouped by their respective departments. The placeholder in the SELECT clause represents the total credit hours, while the GROUP BY clause organizes the results by department code.\",\n        \"virtual_table\": \"SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree type being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY dept_code\"\n    }\n}\n"}
{"sample_id": "train.3220", "db_id": "college_1", "question": "How many hours do the students spend studying in each department?", "rationale": ["The question asks for the total hours students spend studying in each department.", "To find this, we need to sum the total credit hours completed by students, which is represented by the 'STU_HRS' column in the 'STUDENT' table.", "We will group the results by the 'DEPT_CODE' column to get the total hours for each department.", "The SQL query will select the department code and the sum of student hours, grouping by department code."], "gold_sql": "SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT dept_code, sum(stu_hrs) AS total_study_hours FROM student GROUP BY dept_code;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total credit hours completed by students, grouped by their respective departments. The placeholder in the SELECT clause represents the total credit hours, while the GROUP BY clause organizes the results by department code.\",\n        \"virtual_table\": \"SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total credit hours for courses grouped by department code from the 'COURSE' table. The placeholder in the SELECT clause represents the credit hours for each course, while the GROUP BY clause organizes the results by department code.\",\n        \"virtual_table\": \"SELECT sum(crs_credit) ,  dept_code FROM course GROUP BY dept_code\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total credit hours for courses grouped by department code from the 'COURSE' table. The placeholder in the SELECT clause represents the credit hours for each course, while the GROUP BY clause organizes the results by department code.\",\n        \"virtual_table\": \"SELECT sum(crs_credit) ,  dept_code FROM course GROUP BY dept_code\"\n    }\n}\n"}
{"sample_id": "train.3222", "db_id": "college_1", "question": "What is the highest, lowest, and average student GPA for every department?", "rationale": ["The question asks for the highest, lowest, and average GPA of students for each department.", "To achieve this, we need to select the maximum, average, and minimum GPA from the STUDENT table.", "We will group the results by the department code to get the metrics for each department.", "The SQL query will use the aggregate functions max(), avg(), and min() on the stu_gpa column, and we will also select the dept_code to group by."], "gold_sql": "SELECT max(stu_gpa) ,  avg(stu_gpa) ,  min(stu_gpa) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT max(stu_gpa) AS highest_gpa, avg(stu_gpa) AS average_gpa, min(stu_gpa) AS lowest_gpa, dept_code FROM student GROUP BY dept_code;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the academic performance of students by department. It calculates the maximum, average, and minimum GPA of students grouped by their respective department codes. The placeholders in the SELECT statement represent the GPA metrics and department code.\",\n        \"virtual_table\": \"SELECT max(stu_gpa) ,  avg(stu_gpa) ,  min(stu_gpa) ,  dept_code FROM student GROUP BY dept_code\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total credit hours completed by students, grouped by their respective departments. The placeholder in the SELECT clause represents the total credit hours, while the GROUP BY clause organizes the results by department code.\",\n        \"virtual_table\": \"SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree type being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY dept_code\"\n    }\n}\n"}
{"sample_id": "train.3234", "db_id": "college_1", "question": "How many courses does the department of Computer Information Systmes offer?", "rationale": ["Identify the department code for 'Computer Information Systems' from the DEPARTMENT table.", "Use the identified department code to count the number of courses in the COURSE table that match this department code."], "gold_sql": "SELECT count(*) FROM department AS T1 JOIN course AS T2 ON T1.dept_code  =  T2.dept_code WHERE dept_name  =  'Computer Info. Systems'", "source_tables": ["course", "department"], "pred_sql": "SELECT COUNT(*) FROM COURSE WHERE DEPT_CODE = (SELECT DEPT_CODE FROM DEPARTMENT WHERE DEPT_NAME = 'Computer Information Systems')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total credit hours for courses grouped by department code from the 'COURSE' table. The placeholder in the SELECT clause represents the credit hours for each course, while the GROUP BY clause organizes the results by department code.\",\n        \"virtual_table\": \"SELECT sum(crs_credit) ,  dept_code FROM course GROUP BY dept_code\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total credit hours for courses grouped by department code from the 'COURSE' table. The placeholder in the SELECT clause represents the credit hours for each course, while the GROUP BY clause organizes the results by department code.\",\n        \"virtual_table\": \"SELECT sum(crs_credit) ,  dept_code FROM course GROUP BY dept_code\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total credit hours completed by students, grouped by their respective departments. The placeholder in the SELECT clause represents the total credit hours, while the GROUP BY clause organizes the results by department code.\",\n        \"virtual_table\": \"SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code\"\n    }\n}\n"}
{"sample_id": "train.3238", "db_id": "college_1", "question": "What are the total number of credits offered by each department?", "rationale": ["The question asks for the total number of credits offered by each department.", "To find this information, we need to sum the credit hours from the COURSE table, which contains the CRS_CREDIT column.", "We will group the results by the department code, which is found in both the COURSE and DEPARTMENT tables.", "We will join the COURSE table with the DEPARTMENT table on the DEPT_CODE to ensure we can associate each course with its respective department.", "The final SQL query will select the department code and the sum of the course credits, grouped by department code."], "gold_sql": "SELECT sum(T1.crs_credit) ,  T1.dept_code FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY T1.dept_code", "source_tables": ["course", "class"], "pred_sql": "SELECT DEPARTMENT.DEPT_CODE, SUM(COURSE.CRS_CREDIT) AS total_credits\nFROM COURSE\nJOIN DEPARTMENT ON COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE\nGROUP BY DEPARTMENT.DEPT_CODE;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total credit hours completed by students, grouped by their respective departments. The placeholder in the SELECT clause represents the total credit hours, while the GROUP BY clause organizes the results by department code.\",\n        \"virtual_table\": \"SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total credit hours for courses grouped by department code from the 'COURSE' table. The placeholder in the SELECT clause represents the credit hours for each course, while the GROUP BY clause organizes the results by department code.\",\n        \"virtual_table\": \"SELECT sum(crs_credit) ,  dept_code FROM course GROUP BY dept_code\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total credit hours for courses grouped by department code from the 'COURSE' table. The placeholder in the SELECT clause represents the credit hours for each course, while the GROUP BY clause organizes the results by department code.\",\n        \"virtual_table\": \"SELECT sum(crs_credit) ,  dept_code FROM course GROUP BY dept_code\"\n    }\n}\n"}
{"sample_id": "train.3243", "db_id": "college_1", "question": "What is the first name of each student enrolled in class ACCT-211?", "rationale": ["Identify the relevant tables: STUDENT, ENROLL, and CLASS.", "We need to find the first names of students, so we will select STUDENT.STU_FNAME.", "Students are enrolled in classes, so we will join the ENROLL table with the STUDENT table on the STU_NUM column.", "Next, we need to join the CLASS table to filter by the specific class code 'ACCT-211'.", "The final SQL query will select the first names of students who are enrolled in the specified class."], "gold_sql": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  'ACCT-211'", "source_tables": ["student", "class", "enroll"], "pred_sql": "SELECT STUDENT.STU_FNAME \nFROM STUDENT \nJOIN ENROLL ON STUDENT.STU_NUM = ENROLL.STU_NUM \nJOIN CLASS ON ENROLL.CLASS_CODE = CLASS.CLASS_CODE \nWHERE CLASS.CLASS_CODE = 'ACCT-211';", "hint": "\n"}
{"sample_id": "train.3253", "db_id": "college_1", "question": "What is the name of the department that has the largest number of students enrolled?", "rationale": ["To find the department with the largest number of students enrolled, we need to count the number of students in each department.", "We will join the DEPARTMENT table with the STUDENT table on the DEPT_CODE column to associate students with their respective departments.", "We will use the COUNT function to count the number of students (STU_NUM) for each department.", "We will group the results by DEPT_CODE to get the count for each department.", "To find the department with the largest number of students, we will order the results in descending order based on the count of students.", "Finally, we will limit the results to 1 to get only the department with the highest count."], "gold_sql": "SELECT T4.dept_name FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code GROUP BY T3.dept_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["course", "department", "class", "enroll"], "pred_sql": "SELECT d.dept_name\nFROM department d\nJOIN student s ON d.dept_code = s.dept_code\nGROUP BY d.dept_code\nORDER BY COUNT(s.stu_num) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the academic performance of students by department. It calculates the maximum, average, and minimum GPA of students grouped by their respective department codes. The placeholders in the SELECT statement represent the GPA metrics and department code.\",\n        \"virtual_table\": \"SELECT max(stu_gpa) ,  avg(stu_gpa) ,  min(stu_gpa) ,  dept_code FROM student GROUP BY dept_code\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total credit hours completed by students, grouped by their respective departments. The placeholder in the SELECT clause represents the total credit hours, while the GROUP BY clause organizes the results by department code.\",\n        \"virtual_table\": \"SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree type being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY dept_code\"\n    }\n}\n"}
{"sample_id": "train.3254", "db_id": "college_1", "question": "What is the name of the department with the most students enrolled?", "rationale": ["Identify the relevant tables: We need to find the department with the most students enrolled, which involves the ENROLL and DEPARTMENT tables.", "Count the number of students enrolled in each department: We can use the ENROLL table to group by dept_code and count the number of students (STU_NUM).", "Order the results by the count of students in descending order to find the department with the most students.", "Limit the results to 1 to get the department with the highest count.", "Join the DEPARTMENT table to get the department name corresponding to the dept_code with the highest student count."], "gold_sql": "SELECT T4.dept_name FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code GROUP BY T3.dept_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["course", "department", "class", "enroll"], "pred_sql": "SELECT dept_name FROM department WHERE dept_code = (SELECT dept_code FROM enroll GROUP BY dept_code ORDER BY COUNT(stu_num) DESC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the academic performance of students by department. It calculates the maximum, average, and minimum GPA of students grouped by their respective department codes. The placeholders in the SELECT statement represent the GPA metrics and department code.\",\n        \"virtual_table\": \"SELECT max(stu_gpa) ,  avg(stu_gpa) ,  min(stu_gpa) ,  dept_code FROM student GROUP BY dept_code\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree type being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY dept_code\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree type being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY dept_code\"\n    }\n}\n"}
{"sample_id": "train.3258", "db_id": "college_1", "question": "What are the codes of all the courses that are located in room KLR209?", "rationale": ["Identify the relevant table: The question asks for course codes related to a specific room, which means we need to look at the CLASS table where class information is stored.", "Determine the required columns: We need the course codes, which are found in the CRS_CODE column of the CLASS table.", "Apply the condition: We need to filter the results to only include classes held in room 'KLR209'. This is done using a WHERE clause that checks the CLASS_ROOM column.", "Construct the SQL query: Combine the selected columns and the condition into a complete SQL query."], "gold_sql": "SELECT class_code FROM CLASS WHERE class_room  =  'KLR209'", "source_tables": ["class"], "pred_sql": "SELECT CLASS.CRS_CODE FROM CLASS WHERE CLASS.CLASS_ROOM = 'KLR209'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the unique class codes from the 'CLASS' table that are held in a specific classroom. The placeholder in the WHERE clause represents the room where the class is conducted.\",\n        \"virtual_table\": \"SELECT class_code FROM CLASS WHERE class_room  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total credit hours for courses grouped by department code from the 'COURSE' table. The placeholder in the SELECT clause represents the credit hours for each course, while the GROUP BY clause organizes the results by department code.\",\n        \"virtual_table\": \"SELECT sum(crs_credit) ,  dept_code FROM course GROUP BY dept_code\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total credit hours for courses grouped by department code from the 'COURSE' table. The placeholder in the SELECT clause represents the credit hours for each course, while the GROUP BY clause organizes the results by department code.\",\n        \"virtual_table\": \"SELECT sum(crs_credit) ,  dept_code FROM course GROUP BY dept_code\"\n    }\n}\n"}
{"sample_id": "train.3267", "db_id": "college_1", "question": "What is the first name of students who got grade C in any class?", "rationale": ["We need to find the first names of students who received a grade of 'C'.", "To do this, we will query the STUDENT table to get the first names (STU_FNAME).", "Since the grades are stored in the ENROLL table, we need to join the STUDENT table with the ENROLL table on the student number (STU_NUM).", "The condition for the join will be that the ENROLL_GRADE must be 'C'.", "Thus, the SQL query will select the first names from the STUDENT table where the corresponding grade in the ENROLL table is 'C'."], "gold_sql": "SELECT DISTINCT stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE enroll_grade  =  'C'", "source_tables": ["enroll", "student"], "pred_sql": "SELECT STUDENT.STU_FNAME \nFROM STUDENT \nJOIN ENROLL ON STUDENT.STU_NUM = ENROLL.STU_NUM \nWHERE ENROLL.ENROLL_GRADE = 'C';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the academic performance of students by department. It calculates the maximum, average, and minimum GPA of students grouped by their respective department codes. The placeholders in the SELECT statement represent the GPA metrics and department code.\",\n        \"virtual_table\": \"SELECT max(stu_gpa) ,  avg(stu_gpa) ,  min(stu_gpa) ,  dept_code FROM student GROUP BY dept_code\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total credit hours completed by students, grouped by their respective departments. The placeholder in the SELECT clause represents the total credit hours, while the GROUP BY clause organizes the results by department code.\",\n        \"virtual_table\": \"SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code\"\n    }\n}\n"}
{"sample_id": "train.3273", "db_id": "college_1", "question": "What are the first names of the professors who do not teach a class.", "rationale": ["We need to find the first names of professors who do not teach any class.", "To do this, we will select the first names from the EMPLOYEE table where the employee is a professor.", "We will perform a LEFT JOIN between the EMPLOYEE table and the CLASS table on the condition that the professor's employee number matches the professor number in the CLASS table.", "Using a LEFT JOIN allows us to include all professors, even those who do not have a corresponding entry in the CLASS table.", "We will filter the results to include only those rows where CLASS.CLASS_CODE is NULL, indicating that the professor does not teach any class."], "gold_sql": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  'PROF' EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num", "source_tables": ["employee", "class"], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME \nFROM EMPLOYEE \nLEFT JOIN CLASS ON EMPLOYEE.EMP_NUM = CLASS.PROF_NUM \nWHERE CLASS.CLASS_CODE IS NULL;", "hint": "\n"}
{"sample_id": "train.3274", "db_id": "college_1", "question": "What are the first names of all professors not teaching any classes?", "rationale": ["Identify the table that contains professor information, which is the EMPLOYEE table.", "We need to find professors who are not teaching any classes, so we will look for professors whose EMP_NUM is not present in the CLASS table.", "The CLASS table has a column PROF_NUM that links to the EMP_NUM in the EMPLOYEE table, indicating which professors are teaching which classes.", "We will use a subquery to select all PROF_NUM from the CLASS table and then use the NOT IN clause to filter out those professors from the EMPLOYEE table.", "Finally, we will select the EMP_FNAME (first names) of the remaining professors who are not teaching any classes."], "gold_sql": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  'PROF' EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num", "source_tables": ["employee", "class"], "pred_sql": "SELECT EMP_FNAME \nFROM EMPLOYEE \nWHERE EMP_NUM NOT IN (\n    SELECT PROF_NUM \n    FROM CLASS\n);", "hint": "\n"}
{"sample_id": "train.3288", "db_id": "college_1", "question": "How many professors attained either Ph.D. or Masters degrees?", "rationale": ["The question asks for the count of professors who have either a Ph.D. or a Masters degree.", "We need to filter the professors based on their highest degree obtained, which is stored in the 'prof_high_degree' column of the PROFESSOR table.", "To get the count of professors with either degree, we can use the SQL 'IN' clause to specify both 'Ph.D.' and 'Masters'.", "The final SQL query will count all professors that meet this criteria."], "gold_sql": "SELECT count(*) FROM professor WHERE prof_high_degree  =  'Ph.D.' OR prof_high_degree  =  'MA'", "source_tables": ["professor"], "pred_sql": "SELECT count(*) FROM professor WHERE prof_high_degree IN ('Ph.D.', 'Masters')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree type being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY dept_code\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree type being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY dept_code\"\n    }\n}\n"}
{"sample_id": "train.3293", "db_id": "college_1", "question": "Find the first name of student who is taking classes from accounting and Computer Info. Systems departments", "rationale": ["Identify the tables needed: STUDENT and DEPARTMENT.", "We need to find students enrolled in specific departments, so we will join STUDENT with DEPARTMENT on DEPT_CODE.", "The condition specifies that we are interested in students from the Accounting and Computer Info. Systems departments.", "Use the DISTINCT keyword to ensure we only get unique first names of students.", "Select the STU_FNAME from the result of the join where the department name matches either 'Accounting' or 'Computer Info. Systems'."], "gold_sql": "SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Accounting' INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Computer Info. Systems'", "source_tables": ["course", "enroll", "department", "class", "student"], "pred_sql": "SELECT DISTINCT S.STU_FNAME \nFROM STUDENT S \nJOIN DEPARTMENT D ON S.DEPT_CODE = D.DEPT_CODE \nWHERE D.DEPT_NAME IN ('Accounting', 'Computer Info. Systems');", "hint": "\n"}
{"sample_id": "train.3300", "db_id": "college_1", "question": "What is the name of the department with the student that has the lowest GPA?", "rationale": ["Identify the student with the lowest GPA by ordering the students based on their GPA in ascending order and limiting the result to one.", "Extract the department code of that student.", "Use the department code to find the corresponding department name from the department table."], "gold_sql": "SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT 1", "source_tables": ["department", "student"], "pred_sql": "SELECT dept_name FROM department WHERE dept_code = (SELECT dept_code FROM student ORDER BY stu_gpa ASC LIMIT 1);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the academic performance of students by department. It calculates the maximum, average, and minimum GPA of students grouped by their respective department codes. The placeholders in the SELECT statement represent the GPA metrics and department code.\",\n        \"virtual_table\": \"SELECT max(stu_gpa) ,  avg(stu_gpa) ,  min(stu_gpa) ,  dept_code FROM student GROUP BY dept_code\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total credit hours completed by students, grouped by their respective departments. The placeholder in the SELECT clause represents the total credit hours, while the GROUP BY clause organizes the results by department code.\",\n        \"virtual_table\": \"SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree type being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY dept_code\"\n    }\n}\n"}
{"sample_id": "train.3314", "db_id": "college_1", "question": "What are the first names, office locations of all lecturers who have taught some course?", "rationale": ["Identify the required fields: first names of lecturers and their office locations.", "The first names are stored in the EMPLOYEE table under the column EMP_FNAME.", "The office locations are stored in the PROFESSOR table under the column PROF_OFFICE.", "To find lecturers who have taught some course, we need to join the EMPLOYEE and PROFESSOR tables on the EMP_NUM column, which is the unique identifier for employees and professors.", "The SQL query will select the EMP_FNAME from the EMPLOYEE table and the PROF_OFFICE from the PROFESSOR table, using a JOIN to connect the two tables."], "gold_sql": "SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num", "source_tables": ["course", "employee", "professor", "class"], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME, PROFESSOR.PROF_OFFICE \nFROM EMPLOYEE \nJOIN PROFESSOR ON EMPLOYEE.EMP_NUM = PROFESSOR.EMP_NUM;", "hint": "\n"}
{"sample_id": "train.3315", "db_id": "college_1", "question": "Find the first names and offices of all instructors who have taught some course and the course description and the department name.", "rationale": ["Identify the required fields: first names of instructors, their office locations, course descriptions, and department names.", "Instructors are represented in the EMPLOYEE and PROFESSOR tables, so we need to join these tables to get the first names and office locations.", "The COURSE table contains course descriptions, and it is linked to the PROFESSOR table through the DEPARTMENT table.", "The DEPARTMENT table provides the department names and is linked to the PROFESSOR table.", "The CLASS table is necessary to ensure that we only include instructors who have taught some course, linking it to the COURSE table.", "Construct the SQL query using JOINs to connect these tables based on their relationships."], "gold_sql": "SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description ,  T5.dept_name FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num JOIN department AS T5 ON T4.dept_code  =  T5.dept_code", "source_tables": ["course", "department", "professor", "class", "employee"], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME, PROFESSOR.PROF_OFFICE, COURSE.CRS_DESCRIPTION, DEPARTMENT.DEPT_NAME\nFROM EMPLOYEE\nJOIN PROFESSOR ON EMPLOYEE.EMP_NUM = PROFESSOR.EMP_NUM\nJOIN DEPARTMENT ON PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE\nJOIN COURSE ON PROFESSOR.DEPT_CODE = COURSE.DEPT_CODE\nJOIN CLASS ON COURSE.CRS_CODE = CLASS.CRS_CODE;", "hint": "\n"}
{"sample_id": "train.3333", "db_id": "college_1", "question": "Find the name of department that offers the class whose description has the word \"Statistics\".", "rationale": ["Identify the relevant tables: DEPARTMENT, COURSE, and CLASS are needed to find the department offering a specific class.", "The relationship between these tables is established through foreign keys: CLASS.CRS_CODE links to COURSE.CRS_CODE, and COURSE.DEPT_CODE links to DEPARTMENT.DEPT_CODE.", "To find the department name, we need to select DEPARTMENT.DEPT_NAME.", "We need to filter the courses based on their description containing the word 'Statistics', which can be done using a LIKE clause in the WHERE condition."], "gold_sql": "SELECT T2.dept_name FROM course AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.crs_description LIKE '%Statistics%'", "source_tables": ["course", "department"], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME \nFROM DEPARTMENT \nJOIN COURSE ON DEPARTMENT.DEPT_CODE = COURSE.DEPT_CODE \nJOIN CLASS ON COURSE.CRS_CODE = CLASS.CRS_CODE \nWHERE COURSE.CRS_DESCRIPTION LIKE '%Statistics%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree type being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY dept_code\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree type being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY dept_code\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the academic performance of students by department. It calculates the maximum, average, and minimum GPA of students grouped by their respective department codes. The placeholders in the SELECT statement represent the GPA metrics and department code.\",\n        \"virtual_table\": \"SELECT max(stu_gpa) ,  avg(stu_gpa) ,  min(stu_gpa) ,  dept_code FROM student GROUP BY dept_code\"\n    }\n}\n"}
{"sample_id": "train.3417", "db_id": "hr_1", "question": "display the full name (first and last), hire date, salary, and department number for those employees whose first name does not containing the letter M.", "rationale": ["Identify the required fields: first name, last name, hire date, salary, and department number from the employees table.", "Filter the employees whose first name does not contain the letter 'M'. This can be done using the NOT LIKE operator with a wildcard.", "Construct the SQL SELECT statement to retrieve the specified fields from the employees table with the appropriate WHERE clause for filtering.", "Order the results by department_id for better organization of the output."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%'", "source_tables": ["employees"], "pred_sql": "SELECT first_name, last_name, hire_date, salary, department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of employees' first names, last names, hire dates, salaries, and their department identifiers from the 'employees' table, excluding those whose first names match a specific pattern. The placeholder in the WHERE clause allows for filtering based on the first name criteria.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE [PLACEHOLDER-TYPE:STRING] ORDER BY department_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department identifiers from the 'employees' table. It specifically filters for employees who earn the minimum salary within their respective departments. The placeholder in the WHERE clause represents the salary criteria based on the minimum salary grouped by department.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  department_id FROM employees WHERE salary IN (SELECT MIN(salary) FROM employees GROUP BY department_id)\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the first names, last names, and salaries of employees from the 'employees' table whose first names match a specific pattern. The placeholder in the WHERE clause represents the pattern for the first name.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  salary FROM employees WHERE first_name LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3418", "db_id": "hr_1", "question": "What are the full name, hire date, salary, and department id for employees without the letter M in their first name?", "rationale": ["Identify the required fields: full name (first and last name), hire date, salary, and department id.", "To create the full name, concatenate first_name and last_name with a space in between.", "Filter employees whose first name does not contain the letter 'M'. This is done using the NOT LIKE operator with a wildcard.", "Select from the 'employees' table where the conditions are met and order the results by department_id."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%'", "source_tables": ["employees"], "pred_sql": "SELECT first_name || ' ' || last_name AS full_name, hire_date, salary, department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of employees' first names, last names, hire dates, salaries, and their department identifiers from the 'employees' table, excluding those whose first names match a specific pattern. The placeholder in the WHERE clause allows for filtering based on the first name criteria.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE [PLACEHOLDER-TYPE:STRING] ORDER BY department_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first and last names, along with the hire date of employees from the 'employees' table who belong to a specific department. The department is identified by the first name of an employee, which is used as a filter in a subquery to find the corresponding department ID.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  (SELECT department_id FROM employees WHERE first_name  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department identifiers from the 'employees' table. It specifically filters for employees who earn the minimum salary within their respective departments. The placeholder in the WHERE clause represents the salary criteria based on the minimum salary grouped by department.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  department_id FROM employees WHERE salary IN (SELECT MIN(salary) FROM employees GROUP BY department_id)\"\n    }\n}\n"}
{"sample_id": "train.3419", "db_id": "hr_1", "question": "display the full name (first and last), hire date, salary, and department number for those employees whose first name does not containing the letter M and make the result set in ascending order by department number.", "rationale": ["Identify the required fields: first name, last name, hire date, salary, and department number from the employees table.", "Filter the employees whose first name does not contain the letter 'M'. This is done using the NOT LIKE operator with a wildcard.", "Sort the results in ascending order by department number using the ORDER BY clause."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT first_name, last_name, hire_date, salary, department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id ASC", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of employees' first names, last names, hire dates, salaries, and their department identifiers from the 'employees' table, excluding those whose first names match a specific pattern. The placeholder in the WHERE clause allows for filtering based on the first name criteria.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE [PLACEHOLDER-TYPE:STRING] ORDER BY department_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department identifiers from the 'employees' table. It specifically filters for employees who earn the minimum salary within their respective departments. The placeholder in the WHERE clause represents the salary criteria based on the minimum salary grouped by department.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  department_id FROM employees WHERE salary IN (SELECT MIN(salary) FROM employees GROUP BY department_id)\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first and last names, along with the hire date of employees from the 'employees' table who belong to a specific department. The department is identified by the first name of an employee, which is used as a filter in a subquery to find the corresponding department ID.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  (SELECT department_id FROM employees WHERE first_name  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.3442", "db_id": "hr_1", "question": "Which job titles correspond to jobs with salaries over 9000?", "rationale": ["Identify the relevant table: The 'jobs' table contains job titles and their corresponding salary ranges.", "Determine the condition: We need to find job titles where the maximum salary exceeds 9000.", "Construct the SQL query: Use a SELECT statement to retrieve the JOB_TITLE from the jobs table where the MAX_SALARY is greater than 9000."], "gold_sql": "SELECT job_title FROM jobs WHERE min_salary  >  9000", "source_tables": ["jobs"], "pred_sql": "SELECT JOB_TITLE FROM jobs WHERE MAX_SALARY > 9000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of employees, including their unique identifiers, first names, last names, and job identifiers, who earn a salary greater than the maximum salary for a specified job. The placeholder in the subquery represents the job identifier for which the maximum salary is being compared.\",\n        \"virtual_table\": \"SELECT employee_id ,  first_name ,  last_name ,  job_id FROM employees WHERE salary  >  ( SELECT max(salary) FROM employees WHERE job_id  =  [PLACEHOLDER-TYPE:STRING] )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the average salary of employees grouped by their department. It filters out employees who have a specific commission percentage, represented by a placeholder for string values.\",\n        \"virtual_table\": \"SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != [PLACEHOLDER-TYPE:STRING] GROUP BY department_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the average salary of employees grouped by their department. The placeholder in the WHERE clause indicates that only employees with a non-null commission percentage are included in the calculation.\",\n        \"virtual_table\": \"SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != [PLACEHOLDER-TYPE:STRING] GROUP BY department_id\"\n    }\n}\n"}
{"sample_id": "train.3444", "db_id": "hr_1", "question": "What are the job titles, and range of salaries for jobs with maximum salary between 12000 and 18000?", "rationale": ["Identify the relevant table: The question asks for job titles and salary ranges, which are found in the 'jobs' table.", "Determine the columns needed: We need 'JOB_TITLE', 'MIN_SALARY', and 'MAX_SALARY' from the 'jobs' table.", "Apply the filter: The question specifies that we want jobs with a maximum salary between 12000 and 18000, so we will use a WHERE clause to filter 'MAX_SALARY' accordingly.", "Construct the SQL query: Combine the selected columns and the filter into a complete SQL statement."], "gold_sql": "SELECT job_title ,  max_salary - min_salary FROM jobs WHERE max_salary BETWEEN 12000 AND 18000", "source_tables": ["jobs"], "pred_sql": "SELECT JOB_TITLE, MIN_SALARY, MAX_SALARY FROM jobs WHERE MAX_SALARY BETWEEN 12000 AND 18000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of employees, including their unique identifiers, first names, last names, and job identifiers, who earn a salary greater than the maximum salary for a specified job. The placeholder in the subquery represents the job identifier for which the maximum salary is being compared.\",\n        \"virtual_table\": \"SELECT employee_id ,  first_name ,  last_name ,  job_id FROM employees WHERE salary  >  ( SELECT max(salary) FROM employees WHERE job_id  =  [PLACEHOLDER-TYPE:STRING] )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves all employee records from the 'employees' table whose salary falls within a specified range. The lower limit of the salary range is dynamically determined by selecting the minimum salary from the same table, while the upper limit is represented by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT * FROM employees WHERE salary BETWEEN (SELECT MIN(salary) FROM employees) AND [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the average salary of employees grouped by their department. It filters out employees who have a specific commission percentage, represented by a placeholder for string values.\",\n        \"virtual_table\": \"SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != [PLACEHOLDER-TYPE:STRING] GROUP BY department_id\"\n    }\n}\n"}
{"sample_id": "train.3448", "db_id": "hr_1", "question": "What are the employee ids for each employee and final dates of employment at their last job?", "rationale": ["The question asks for employee ids and their final dates of employment at their last job.", "To find the last job end date for each employee, we can use the 'job_history' table.", "We need to select the 'employee_id' and the maximum 'end_date' for each employee.", "Using the MAX function allows us to retrieve the latest end date for each employee's job history.", "We will group the results by 'employee_id' to ensure we get one result per employee."], "gold_sql": "SELECT employee_id ,  MAX(end_date) FROM job_history GROUP BY employee_id", "source_tables": ["job_history"], "pred_sql": "SELECT employee_id, MAX(end_date) AS last_job_end_date FROM job_history GROUP BY employee_id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the most recent job end dates for each employee from the 'job_history' table. The placeholder in the SELECT clause represents the employee's unique identifier, while the MAX function is used to retrieve the latest end date for each employee's job history.\",\n        \"virtual_table\": \"SELECT employee_id ,  MAX(end_date) FROM job_history GROUP BY employee_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first and last names, along with the hire date of employees from the 'employees' table who belong to a specific department. The department is identified by the first name of an employee, which is used as a filter in a subquery to find the corresponding department ID.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  (SELECT department_id FROM employees WHERE first_name  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of employees' first names, last names, hire dates, salaries, and their department identifiers from the 'employees' table, excluding those whose first names match a specific pattern. The placeholder in the WHERE clause allows for filtering based on the first name criteria.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE [PLACEHOLDER-TYPE:STRING] ORDER BY department_id\"\n    }\n}\n"}
{"sample_id": "train.3451", "db_id": "hr_1", "question": "Find the ids of the departments where any manager is managing 4 or more employees.", "rationale": ["Identify the relevant table: The 'employees' table contains information about employees and their departments.", "Group the results by department_id and manager_id: This allows us to count the number of employees managed by each manager in each department.", "Use the HAVING clause to filter departments: We want only those departments where the count of employees is 4 or more, hence we use HAVING COUNT(employee_id) >= 4."], "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"], "pred_sql": "SELECT department_id FROM employees GROUP BY department_id, manager_id HAVING COUNT(employee_id) >= 4", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists unique department identifiers from the 'employees' table, grouped by department and manager. It filters the results to include only those departments that have a specified minimum number of employees, represented by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the identifiers of departments from the 'employees' table that have more than a specified number of employees receiving a commission. The placeholder in the HAVING clause represents the minimum count of employees with a commission percentage.\",\n        \"virtual_table\": \"SELECT department_id FROM employees GROUP BY department_id HAVING COUNT(commission_pct) > [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the employee ID, first name, and last name of employees from the 'employees' table who belong to the same department as a specified employee. The placeholder in the WHERE clause allows for filtering based on the first name of the employee.\",\n        \"virtual_table\": \"SELECT employee_id ,  first_name ,  last_name FROM employees WHERE department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE [PLACEHOLDER-TYPE:STRING] )\"\n    }\n}\n"}
{"sample_id": "train.3457", "db_id": "hr_1", "question": "display job ID for those jobs that were done by two or more for more than 300 days.", "rationale": ["We need to find job IDs for jobs that were done by two or more employees for more than 300 days.", "To achieve this, we will use the 'job_history' table which contains records of employees' job durations.", "We will group the results by 'job_id' to aggregate the data for each job.", "Using the COUNT function, we will filter for jobs that have two or more employees associated with them.", "To calculate the duration of each job, we will use the difference between the maximum end date and the minimum start date for each job, which can be calculated using the JULIANDAY function.", "Finally, we will apply a HAVING clause to ensure that the count of employees is at least 2 and the duration is greater than 300 days."], "gold_sql": "SELECT job_id FROM job_history WHERE end_date - start_date  > 300 GROUP BY job_id HAVING COUNT(*) >= 2", "source_tables": ["job_history"], "pred_sql": "SELECT job_id\nFROM job_history\nGROUP BY job_id\nHAVING COUNT(employee_id) >= 2 AND (julianday(MAX(end_date)) - julianday(MIN(start_date))) > 300;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the most recent job end dates for each employee from the 'job_history' table. The placeholder in the SELECT clause represents the employee's unique identifier, while the MAX function is used to retrieve the latest end date for each employee's job history.\",\n        \"virtual_table\": \"SELECT employee_id ,  MAX(end_date) FROM job_history GROUP BY employee_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of employee IDs and their corresponding job IDs from the 'employees' table, specifically for those employees whose salary is less than the minimum salary for a specified job. The placeholder in the subquery represents the job identifier for which the minimum salary is being compared.\",\n        \"virtual_table\": \"SELECT employee_id ,  job_id FROM employees WHERE salary  <  ( SELECT min(salary) FROM employees WHERE job_id  =  [PLACEHOLDER-TYPE:STRING] )\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of employees, including their unique identifiers, first names, last names, and job identifiers, who earn a salary greater than the maximum salary for a specified job. The placeholder in the subquery represents the job identifier for which the maximum salary is being compared.\",\n        \"virtual_table\": \"SELECT employee_id ,  first_name ,  last_name ,  job_id FROM employees WHERE salary  >  ( SELECT max(salary) FROM employees WHERE job_id  =  [PLACEHOLDER-TYPE:STRING] )\"\n    }\n}\n"}
{"sample_id": "train.3458", "db_id": "hr_1", "question": "What are the job ids for jobs done more than once for a period of more than 300 days?", "rationale": ["We need to find job IDs for jobs that have been done more than once.", "To do this, we will use the 'job_history' table, which contains records of jobs held by employees over time.", "We will group the results by 'job_id' to count how many times each job has been done.", "We will use the HAVING clause to filter groups where the count of job occurrences is greater than 1.", "Additionally, we need to ensure that the duration of each job (from start to end) is more than 300 days.", "To calculate the duration, we will use the MAX(end_date) and MIN(start_date) for each job_id and check if the difference is greater than 300."], "gold_sql": "SELECT job_id FROM job_history WHERE end_date - start_date  > 300 GROUP BY job_id HAVING COUNT(*) >= 2", "source_tables": ["job_history"], "pred_sql": "SELECT job_id\nFROM job_history\nGROUP BY job_id\nHAVING COUNT(*) > 1 AND (MAX(end_date) - MIN(start_date)) > 300;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the most recent job end dates for each employee from the 'job_history' table. The placeholder in the SELECT clause represents the employee's unique identifier, while the MAX function is used to retrieve the latest end date for each employee's job history.\",\n        \"virtual_table\": \"SELECT employee_id ,  MAX(end_date) FROM job_history GROUP BY employee_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of employee IDs and their corresponding job IDs from the 'employees' table, specifically for those employees whose salary is less than the minimum salary for a specified job. The placeholder in the subquery represents the job identifier for which the minimum salary is being compared.\",\n        \"virtual_table\": \"SELECT employee_id ,  job_id FROM employees WHERE salary  <  ( SELECT min(salary) FROM employees WHERE job_id  =  [PLACEHOLDER-TYPE:STRING] )\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of employees, including their unique identifiers, first names, last names, and job identifiers, who earn a salary greater than the maximum salary for a specified job. The placeholder in the subquery represents the job identifier for which the maximum salary is being compared.\",\n        \"virtual_table\": \"SELECT employee_id ,  first_name ,  last_name ,  job_id FROM employees WHERE salary  >  ( SELECT max(salary) FROM employees WHERE job_id  =  [PLACEHOLDER-TYPE:STRING] )\"\n    }\n}\n"}
{"sample_id": "train.3463", "db_id": "hr_1", "question": "display the department name and number of employees in each of the department.", "rationale": ["We need to display the department name and the number of employees in each department.", "To achieve this, we will select the department name from the 'departments' table.", "We will also count the number of employees associated with each department from the 'employees' table.", "To link the two tables, we will use a LEFT JOIN on the 'DEPARTMENT_ID' column, which is common to both tables.", "Finally, we will group the results by the department name to get the count of employees for each department."], "gold_sql": "SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name", "source_tables": ["employees", "departments"], "pred_sql": "SELECT d.DEPARTMENT_NAME, COUNT(e.EMPLOYEE_ID) AS NUMBER_OF_EMPLOYEES\nFROM departments d\nLEFT JOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID\nGROUP BY d.DEPARTMENT_NAME;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists unique department identifiers from the 'employees' table, grouped by department and manager. It filters the results to include only those departments that have a specified minimum number of employees, represented by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first and last names of employees from the 'employees' table who belong to specific departments. The placeholders in the WHERE clause represent the identifiers of the departments being queried.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name FROM employees WHERE department_id  =  [PLACEHOLDER-TYPE:NUMBER] OR department_id  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department identifiers from the 'employees' table. It specifically filters for employees who earn the minimum salary within their respective departments. The placeholder in the WHERE clause represents the salary criteria based on the minimum salary grouped by department.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  department_id FROM employees WHERE salary IN (SELECT MIN(salary) FROM employees GROUP BY department_id)\"\n    }\n}\n"}
{"sample_id": "train.3470", "db_id": "hr_1", "question": "Provide the full names of employees earning more than the employee with id 163.", "rationale": ["Identify the employee with ID 163 to find their salary.", "Use a subquery to select the salary of the employee with ID 163.", "Select the first and last names of employees whose salary is greater than the salary obtained from the subquery."], "gold_sql": "SELECT first_name ,  last_name FROM employees WHERE salary  >  (SELECT salary FROM employees WHERE employee_id = 163 )", "source_tables": ["employees"], "pred_sql": "SELECT FIRST_NAME, LAST_NAME FROM employees WHERE SALARY > (SELECT SALARY FROM employees WHERE EMPLOYEE_ID = '163')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of employees, including their unique identifiers, first names, last names, and job identifiers, who earn a salary greater than the maximum salary for a specified job. The placeholder in the subquery represents the job identifier for which the maximum salary is being compared.\",\n        \"virtual_table\": \"SELECT employee_id ,  first_name ,  last_name ,  job_id FROM employees WHERE salary  >  ( SELECT max(salary) FROM employees WHERE job_id  =  [PLACEHOLDER-TYPE:STRING] )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first names, last names, and salaries of employees from the 'employees' table who earn less than a specified salary. The placeholder in the WHERE clause represents the salary threshold.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  salary FROM employees WHERE salary  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the first names, last names, and salaries of employees from the 'employees' table who earn less than a specified salary. The placeholder in the WHERE clause represents the salary threshold.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  salary FROM employees WHERE salary  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3471", "db_id": "hr_1", "question": "return the smallest salary for every departments.", "rationale": ["The task is to return the smallest salary for every department.", "To find the smallest salary in each department, we can use a subquery that selects the minimum salary grouped by department.", "The subquery will be: SELECT MIN(salary) FROM employees GROUP BY department_id, which gives us the minimum salary for each department.", "We then need to select the first name, last name, and department ID of employees whose salary matches the minimum salary found in the subquery.", "Thus, the final SQL query combines these elements to return the desired results."], "gold_sql": "SELECT MIN(salary) ,  department_id FROM employees GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT first_name, last_name, department_id FROM employees WHERE salary IN (SELECT MIN(salary) FROM employees GROUP BY department_id)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the average salary of employees grouped by their department. It filters out employees who have a specific commission percentage, represented by a placeholder for string values.\",\n        \"virtual_table\": \"SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != [PLACEHOLDER-TYPE:STRING] GROUP BY department_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the average salary of employees grouped by their department. The placeholder in the WHERE clause indicates that only employees with a non-null commission percentage are included in the calculation.\",\n        \"virtual_table\": \"SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != [PLACEHOLDER-TYPE:STRING] GROUP BY department_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department identifiers from the 'employees' table, specifically targeting those employees who earn the minimum salary within their respective departments. The subquery identifies the minimum salary for each department, and the placeholder in the WHERE clause allows for dynamic filtering based on salary criteria.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  department_id FROM employees WHERE salary IN (SELECT MIN(salary) FROM employees GROUP BY department_id)\"\n    }\n}\n"}
{"sample_id": "train.3472", "db_id": "hr_1", "question": "What is the minimum salary in each department?", "rationale": ["The question asks for the minimum salary in each department, which indicates that we need to group the results by department.", "To find the minimum salary, we can use the MIN() function on the salary column from the employees table.", "We will select the department_id and the minimum salary, and we will group the results by department_id to ensure we get the minimum salary for each department."], "gold_sql": "SELECT MIN(salary) ,  department_id FROM employees GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT department_id, MIN(salary) AS min_salary FROM employees GROUP BY department_id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the average salary of employees grouped by their department. It filters out employees who have a specific commission percentage, represented by a placeholder for string values.\",\n        \"virtual_table\": \"SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != [PLACEHOLDER-TYPE:STRING] GROUP BY department_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the average salary of employees grouped by their department. The placeholder in the WHERE clause indicates that only employees with a non-null commission percentage are included in the calculation.\",\n        \"virtual_table\": \"SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != [PLACEHOLDER-TYPE:STRING] GROUP BY department_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department identifiers from the 'employees' table, specifically targeting those employees who earn the minimum salary within their respective departments. The subquery identifies the minimum salary for each department, and the placeholder in the WHERE clause allows for dynamic filtering based on salary criteria.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  department_id FROM employees WHERE salary IN (SELECT MIN(salary) FROM employees GROUP BY department_id)\"\n    }\n}\n"}
{"sample_id": "train.3482", "db_id": "hr_1", "question": "What is all the information regarding employees who are managers?", "rationale": ["Identify the employees who are managers by checking the 'manager_id' field in the 'employees' table.", "Use a subquery to select distinct 'manager_id' values from the 'employees' table, ensuring that we only consider non-null values.", "The main query selects all columns from the 'employees' table where the 'EMPLOYEE_ID' is in the list of distinct 'manager_id' values from the subquery."], "gold_sql": "SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T1.employee_id  =  T2.manager_id", "source_tables": ["employees", "departments"], "pred_sql": "SELECT e.* FROM employees e WHERE e.EMPLOYEE_ID IN (SELECT DISTINCT manager_id FROM employees WHERE manager_id IS NOT NULL)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists unique department identifiers from the 'employees' table, grouped by department and manager. It filters the results to include only those departments that have a specified minimum number of employees, represented by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of employees' first names, last names, hire dates, salaries, and their department identifiers from the 'employees' table, excluding those whose first names match a specific pattern. The placeholder in the WHERE clause allows for filtering based on the first name criteria.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE [PLACEHOLDER-TYPE:STRING] ORDER BY department_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the average salary of employees grouped by their department. The placeholder in the WHERE clause indicates that only employees with a non-null commission percentage are included in the calculation.\",\n        \"virtual_table\": \"SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != [PLACEHOLDER-TYPE:STRING] GROUP BY department_id\"\n    }\n}\n"}
{"sample_id": "train.3488", "db_id": "hr_1", "question": "Give the distinct department ids of departments in which a manager is in charge of 4 or more employees?", "rationale": ["The task requires us to find distinct department IDs where a manager oversees 4 or more employees.", "We will use the 'employees' table, which contains information about employees and their respective departments and managers.", "To achieve this, we will group the results by 'department_id' and 'manager_id' to count the number of employees in each department managed by each manager.", "We will use the HAVING clause to filter the groups to only include those with a count of employees greater than or equal to 4.", "Finally, we will select distinct 'department_id' from the filtered results."], "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"], "pred_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id, manager_id HAVING COUNT(employee_id) >= 4", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists unique department identifiers from the 'employees' table, grouped by department and manager. It filters the results to include only those departments that have a specified minimum number of employees, represented by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the identifiers of departments from the 'employees' table that have more than a specified number of employees receiving a commission. The placeholder in the HAVING clause represents the minimum count of employees with a commission percentage.\",\n        \"virtual_table\": \"SELECT department_id FROM employees GROUP BY department_id HAVING COUNT(commission_pct) > [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the employee ID, first name, and last name of employees from the 'employees' table who belong to the same department as a specified employee. The placeholder in the WHERE clause allows for filtering based on the first name of the employee.\",\n        \"virtual_table\": \"SELECT employee_id ,  first_name ,  last_name FROM employees WHERE department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE [PLACEHOLDER-TYPE:STRING] )\"\n    }\n}\n"}
{"sample_id": "train.3497", "db_id": "hr_1", "question": "Find the ids of the employees who does not work in those departments where some employees works whose manager id within the range 100 and 200.", "rationale": ["Identify the employees whose department IDs are not in a specific set of department IDs.", "The set of department IDs is determined by selecting distinct department IDs from the employees table where the manager ID is between 100 and 200.", "Use a subquery to filter out the department IDs that have managers within the specified range.", "The final query selects the employee IDs from the employees table that do not belong to the filtered department IDs."], "gold_sql": "SELECT * FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN 100 AND 200)", "source_tables": ["employees", "departments"], "pred_sql": "SELECT EMPLOYEE_ID FROM employees WHERE DEPARTMENT_ID NOT IN (SELECT DISTINCT DEPARTMENT_ID FROM employees WHERE MANAGER_ID BETWEEN 100 AND 200)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists unique department identifiers from the 'employees' table, grouped by department and manager. It filters the results to include only those departments that have a specified minimum number of employees, represented by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the identifiers of departments from the 'employees' table that have more than a specified number of employees receiving a commission. The placeholder in the HAVING clause represents the minimum count of employees with a commission percentage.\",\n        \"virtual_table\": \"SELECT department_id FROM employees GROUP BY department_id HAVING COUNT(commission_pct) > [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first and last names of employees from the 'employees' table who belong to specific departments. The placeholders in the WHERE clause represent the identifiers of the departments being queried.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name FROM employees WHERE department_id  =  [PLACEHOLDER-TYPE:NUMBER] OR department_id  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3502", "db_id": "hr_1", "question": "What are the full names and hire dates for employees in the same department as someone with the first name Clara, not including Clara?", "rationale": ["Identify the requirement to find full names and hire dates of employees in the same department as Clara.", "Use a subquery to find the department_id of the employee named Clara.", "Filter the main query to select first names, last names, and hire dates of employees who belong to the same department as Clara.", "Exclude Clara from the results by adding a condition to ensure first_name is not equal to 'Clara'."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  ( SELECT department_id FROM employees WHERE first_name  =  'Clara') AND first_name != 'Clara'", "source_tables": ["employees"], "pred_sql": "SELECT first_name, last_name, hire_date FROM employees WHERE department_id = (SELECT department_id FROM employees WHERE first_name = 'Clara') AND first_name != 'Clara';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of employees' first names, last names, hire dates, salaries, and their department identifiers from the 'employees' table, excluding those whose first names match a specific pattern. The placeholder in the WHERE clause allows for filtering based on the first name criteria.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE [PLACEHOLDER-TYPE:STRING] ORDER BY department_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first and last names, along with the hire date of employees from the 'employees' table who belong to a specific department. The department is identified by the first name of an employee, which is used as a filter in a subquery to find the corresponding department ID.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  (SELECT department_id FROM employees WHERE first_name  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first and last names of employees from the 'employees' table who belong to specific departments. The placeholders in the WHERE clause represent the identifiers of the departments being queried.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name FROM employees WHERE department_id  =  [PLACEHOLDER-TYPE:NUMBER] OR department_id  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3506", "db_id": "hr_1", "question": "What are the ids, full names, and salaries for employees making more than average and who work in a department with employees who have the letter J in their first name?", "rationale": ["Identify the required fields: employee IDs, full names (first and last), and salaries.", "To get the full name, concatenate the first and last names using '||'.", "Filter employees whose salary is greater than the average salary. This requires a subquery to calculate the average salary from the employees table.", "Additionally, filter employees who work in departments that have at least one employee with 'J' in their first name. This requires another subquery that selects department IDs from employees where the first name contains 'J'.", "Combine these conditions in the WHERE clause of the main query."], "gold_sql": "SELECT employee_id ,  first_name ,  last_name ,  salary FROM employees WHERE salary  >  ( SELECT AVG (salary) FROM employees ) AND department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE '%J%')", "source_tables": ["employees"], "pred_sql": "SELECT e.EMPLOYEE_ID, e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.SALARY \nFROM employees e \nWHERE e.SALARY > (SELECT AVG(SALARY) FROM employees) \nAND e.DEPARTMENT_ID IN (SELECT d.DEPARTMENT_ID \n                       FROM employees d \n                       WHERE d.FIRST_NAME LIKE '%J%')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department identifiers from the 'employees' table, specifically targeting those employees who earn the minimum salary within their respective departments. The subquery identifies the minimum salary for each department, and the placeholder in the WHERE clause allows for dynamic filtering based on salary criteria.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  department_id FROM employees WHERE salary IN (SELECT MIN(salary) FROM employees GROUP BY department_id)\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department identifiers from the 'employees' table. It specifically filters for employees who earn the minimum salary within their respective departments. The placeholder in the WHERE clause represents the salary criteria based on the minimum salary grouped by department.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  department_id FROM employees WHERE salary IN (SELECT MIN(salary) FROM employees GROUP BY department_id)\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the average salary of employees grouped by their department. It filters out employees who have a specific commission percentage, represented by a placeholder for string values.\",\n        \"virtual_table\": \"SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != [PLACEHOLDER-TYPE:STRING] GROUP BY department_id\"\n    }\n}\n"}
{"sample_id": "train.3507", "db_id": "hr_1", "question": "display the employee number and job id for all employees whose salary is smaller than any salary of those employees whose job title is MK_MAN.", "rationale": ["Identify the main requirement: We need to display employee number and job id for employees whose salary is less than any salary of those with job title 'MK_MAN'.", "To achieve this, we need to find the minimum salary of employees with the job title 'MK_MAN'.", "We can do this by first selecting the job_id from the jobs table where job_title is 'MK_MAN'.", "Next, we will use this job_id to find the minimum salary from the employees table.", "Finally, we will select employee_id and job_id from the employees table where their salary is less than the minimum salary found in the previous step."], "gold_sql": "SELECT employee_id ,  job_id FROM employees WHERE salary  <  ( SELECT min(salary) FROM employees WHERE job_id  =  'MK_MAN' )", "source_tables": ["employees"], "pred_sql": "SELECT employee_id, job_id FROM employees WHERE salary < (SELECT MIN(salary) FROM employees WHERE job_id = (SELECT job_id FROM jobs WHERE job_title = 'MK_MAN'))", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of employee IDs and their corresponding job IDs from the 'employees' table, specifically for those employees whose salary is less than the minimum salary for a specified job. The placeholder in the subquery represents the job identifier for which the minimum salary is being compared.\",\n        \"virtual_table\": \"SELECT employee_id ,  job_id FROM employees WHERE salary  <  ( SELECT min(salary) FROM employees WHERE job_id  =  [PLACEHOLDER-TYPE:STRING] )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first names, last names, and salaries of employees from the 'employees' table who earn less than a specified salary. The placeholder in the WHERE clause represents the salary threshold.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  salary FROM employees WHERE salary  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the first names, last names, and salaries of employees from the 'employees' table who earn less than a specified salary. The placeholder in the WHERE clause represents the salary threshold.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  salary FROM employees WHERE salary  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3510", "db_id": "hr_1", "question": "What are the employee ids, full names, and job ids for employees who make more than the highest earning employee with title PU_MAN?", "rationale": ["Identify the required fields: employee ids, full names, and job ids.", "To get the full names, concatenate first_name and last_name with a space in between.", "We need to filter employees based on their salary being greater than the highest salary of employees with the job title 'PU_MAN'.", "Use a subquery to find the maximum salary for the job title 'PU_MAN'.", "The subquery will first find the job_id for 'PU_MAN' from the jobs table, and then use that job_id to find the maximum salary from the employees table.", "Combine all these elements into a single SQL query."], "gold_sql": "SELECT employee_id ,  first_name ,  last_name ,  job_id FROM employees WHERE salary  >  ( SELECT max(salary) FROM employees WHERE job_id  =  'PU_MAN' )", "source_tables": ["employees"], "pred_sql": "SELECT employee_id, first_name || ' ' || last_name AS full_name, job_id \nFROM employees \nWHERE salary > (SELECT max(salary) FROM employees WHERE job_id = (SELECT job_id FROM jobs WHERE job_title = 'PU_MAN'))", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of employees, including their unique identifiers, first names, last names, and job identifiers, who earn a salary greater than the maximum salary for a specified job. The placeholder in the subquery represents the job identifier for which the maximum salary is being compared.\",\n        \"virtual_table\": \"SELECT employee_id ,  first_name ,  last_name ,  job_id FROM employees WHERE salary  >  ( SELECT max(salary) FROM employees WHERE job_id  =  [PLACEHOLDER-TYPE:STRING] )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of employee IDs and their corresponding job IDs from the 'employees' table, specifically for those employees whose salary is less than the minimum salary for a specified job. The placeholder in the subquery represents the job identifier for which the minimum salary is being compared.\",\n        \"virtual_table\": \"SELECT employee_id ,  job_id FROM employees WHERE salary  <  ( SELECT min(salary) FROM employees WHERE job_id  =  [PLACEHOLDER-TYPE:STRING] )\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the first names, last names, and salaries of employees from the 'employees' table who earn less than a specified salary. The placeholder in the WHERE clause represents the salary threshold.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  salary FROM employees WHERE salary  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3512", "db_id": "hr_1", "question": "What are total salaries and department id for each department that has more than 2 employees?", "rationale": ["We need to find the total salaries and department IDs for departments with more than 2 employees.", "To achieve this, we will use the SUM function to calculate the total salary for each department.", "We will group the results by department_id to aggregate the salaries for each department.", "To filter departments with more than 2 employees, we will use the HAVING clause with COUNT(employee_id) > 2."], "gold_sql": "SELECT department_id ,  SUM(salary) FROM employees GROUP BY department_id HAVING count(*)  >=  2", "source_tables": ["employees"], "pred_sql": "SELECT department_id, SUM(salary) AS total_salaries \nFROM employees \nGROUP BY department_id \nHAVING COUNT(employee_id) > 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the average salary of employees grouped by their department. It filters out employees who have a specific commission percentage, represented by a placeholder for string values.\",\n        \"virtual_table\": \"SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != [PLACEHOLDER-TYPE:STRING] GROUP BY department_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the average salary of employees grouped by their department. The placeholder in the WHERE clause indicates that only employees with a non-null commission percentage are included in the calculation.\",\n        \"virtual_table\": \"SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != [PLACEHOLDER-TYPE:STRING] GROUP BY department_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department identifiers from the 'employees' table, specifically targeting those employees who earn the minimum salary within their respective departments. The subquery identifies the minimum salary for each department, and the placeholder in the WHERE clause allows for dynamic filtering based on salary criteria.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  department_id FROM employees WHERE salary IN (SELECT MIN(salary) FROM employees GROUP BY department_id)\"\n    }\n}\n"}
{"sample_id": "train.3515", "db_id": "hr_1", "question": "display the department ID, full name (first and last name), salary for those employees who is highest salary in every department.", "rationale": ["We need to display the department ID, full name (first and last name), and salary of employees who have the highest salary in their respective departments.", "To achieve this, we will select the DEPARTMENT_ID, concatenate FIRST_NAME and LAST_NAME to create a FULL_NAME, and select the SALARY from the employees table.", "To find the highest salary in each department, we will use a subquery that selects the MAX(SALARY) from the employees table, grouped by DEPARTMENT_ID.", "The main query will filter employees where their SALARY matches the maximum salary found in the subquery for their respective DEPARTMENT_ID."], "gold_sql": "SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT e.DEPARTMENT_ID, e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.SALARY \nFROM employees e \nWHERE e.SALARY = (SELECT MAX(SALARY) \n                   FROM employees \n                   WHERE DEPARTMENT_ID = e.DEPARTMENT_ID)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department identifiers from the 'employees' table. It specifically filters for employees who earn the minimum salary within their respective departments. The placeholder in the WHERE clause represents the salary criteria based on the minimum salary grouped by department.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  department_id FROM employees WHERE salary IN (SELECT MIN(salary) FROM employees GROUP BY department_id)\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department identifiers from the 'employees' table, specifically targeting those employees who earn the minimum salary within their respective departments. The subquery identifies the minimum salary for each department, and the placeholder in the WHERE clause allows for dynamic filtering based on salary criteria.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  department_id FROM employees WHERE salary IN (SELECT MIN(salary) FROM employees GROUP BY department_id)\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first and last names, along with the hire date of employees from the 'employees' table who belong to a specific department. The department is identified by the first name of an employee, which is used as a filter in a subquery to find the corresponding department ID.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  (SELECT department_id FROM employees WHERE first_name  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.3516", "db_id": "hr_1", "question": "What are the department ids, full names, and salaries for employees who make the most in their departments?", "rationale": ["Identify the required fields: department ids, full names, and salaries of employees.", "To get the full names, concatenate the first and last names from the employees table.", "To find the highest salary in each department, use a subquery that selects the maximum salary for each department.", "The main query selects from the employees table where the salary matches the maximum salary for the corresponding department."], "gold_sql": "SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT e.DEPARTMENT_ID, e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.SALARY \nFROM employees e \nWHERE e.SALARY = (SELECT MAX(salary) \n                  FROM employees \n                  WHERE DEPARTMENT_ID = e.DEPARTMENT_ID)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the average salary of employees grouped by their department. It filters out employees who have a specific commission percentage, represented by a placeholder for string values.\",\n        \"virtual_table\": \"SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != [PLACEHOLDER-TYPE:STRING] GROUP BY department_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department identifiers from the 'employees' table, specifically targeting those employees who earn the minimum salary within their respective departments. The subquery identifies the minimum salary for each department, and the placeholder in the WHERE clause allows for dynamic filtering based on salary criteria.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  department_id FROM employees WHERE salary IN (SELECT MIN(salary) FROM employees GROUP BY department_id)\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the average salary of employees grouped by their department. The placeholder in the WHERE clause indicates that only employees with a non-null commission percentage are included in the calculation.\",\n        \"virtual_table\": \"SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != [PLACEHOLDER-TYPE:STRING] GROUP BY department_id\"\n    }\n}\n"}
{"sample_id": "train.3520", "db_id": "hr_1", "question": "What are the full names and cities of employees who have the letter Z in their first names?", "rationale": ["Identify the relevant tables: 'employees' for employee names and 'locations' for cities.", "We need to select the first name and last name from the 'employees' table and concatenate them to form the full name.", "We also need to get the city from the 'locations' table.", "To link the 'employees' table with the 'locations' table, we need to join the 'departments' table since 'employees' has a foreign key to 'departments' and 'departments' has a foreign key to 'locations'.", "The condition specifies that we only want employees whose first names contain the letter 'Z', which can be achieved using the LIKE operator with a wildcard."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T3.city FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id WHERE T1.first_name LIKE '%z%'", "source_tables": ["employees", "departments", "locations"], "pred_sql": "SELECT first_name || ' ' || last_name AS full_name, city FROM employees JOIN locations ON employees.department_id = departments.department_id JOIN departments ON departments.location_id = locations.location_id WHERE first_name LIKE '%Z%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names, last names, and salaries of employees from the 'employees' table whose first names match a specific pattern. The placeholder in the WHERE clause represents the pattern for the first name.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  salary FROM employees WHERE first_name LIKE [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first and last names of employees from the 'employees' table who belong to specific departments. The placeholders in the WHERE clause represent the identifiers of the departments being queried.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name FROM employees WHERE department_id  =  [PLACEHOLDER-TYPE:NUMBER] OR department_id  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of employees' first names, last names, hire dates, salaries, and their department identifiers from the 'employees' table, excluding those whose first names match a specific pattern. The placeholder in the WHERE clause allows for filtering based on the first name criteria.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE [PLACEHOLDER-TYPE:STRING] ORDER BY department_id\"\n    }\n}\n"}
{"sample_id": "train.3523", "db_id": "hr_1", "question": "display the full name (first and last name ) of employee with ID and name of the country presently where (s)he is working.", "rationale": ["Identify the tables needed: employees, departments, locations, and countries.", "We need to join these tables to get the employee's full name and the country they are currently working in.", "The employees table contains the first and last names, while the countries table contains the country name.", "Join employees with departments on DEPARTMENT_ID to get department information.", "Join departments with locations on LOCATION_ID to get location information.", "Join locations with countries on COUNTRY_ID to get the country name.", "Use a WHERE clause to filter the results for a specific employee ID."], "gold_sql": "SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id", "source_tables": ["countries", "employees", "departments", "locations"], "pred_sql": "SELECT e.FIRST_NAME, e.LAST_NAME, c.COUNTRY_NAME \nFROM employees e \nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nJOIN locations l ON d.LOCATION_ID = l.LOCATION_ID \nJOIN countries c ON l.COUNTRY_ID = c.COUNTRY_ID \nWHERE e.EMPLOYEE_ID = ?", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the employee ID, first name, and last name of employees from the 'employees' table who belong to the same department as a specified employee. The placeholder in the WHERE clause allows for filtering based on the first name of the employee.\",\n        \"virtual_table\": \"SELECT employee_id ,  first_name ,  last_name FROM employees WHERE department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE [PLACEHOLDER-TYPE:STRING] )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the employee ID, first name, and last name of employees from the 'employees' table who belong to the same department as a specified employee. The placeholder in the WHERE clause allows for filtering based on the first name of the employee.\",\n        \"virtual_table\": \"SELECT employee_id ,  first_name ,  last_name FROM employees WHERE department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE [PLACEHOLDER-TYPE:STRING] )\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of employees' first names, last names, hire dates, salaries, and their department identifiers from the 'employees' table, excluding those whose first names match a specific pattern. The placeholder in the WHERE clause allows for filtering based on the first name criteria.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE [PLACEHOLDER-TYPE:STRING] ORDER BY department_id\"\n    }\n}\n"}
{"sample_id": "train.3525", "db_id": "hr_1", "question": "display the department name and number of employees in each of the department.", "rationale": ["We need to display the department name and the number of employees in each department.", "To achieve this, we will select the department name from the 'departments' table.", "We will also count the number of employees associated with each department from the 'employees' table.", "To link the two tables, we will use a LEFT JOIN on the 'DEPARTMENT_ID' column, which is common to both tables.", "Finally, we will group the results by the department name to get the count of employees for each department."], "gold_sql": "SELECT department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY department_name", "source_tables": ["employees", "departments"], "pred_sql": "SELECT d.DEPARTMENT_NAME, COUNT(e.EMPLOYEE_ID) AS NUMBER_OF_EMPLOYEES\nFROM departments d\nLEFT JOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID\nGROUP BY d.DEPARTMENT_NAME;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists unique department identifiers from the 'employees' table, grouped by department and manager. It filters the results to include only those departments that have a specified minimum number of employees, represented by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first and last names of employees from the 'employees' table who belong to specific departments. The placeholders in the WHERE clause represent the identifiers of the departments being queried.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name FROM employees WHERE department_id  =  [PLACEHOLDER-TYPE:NUMBER] OR department_id  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department identifiers from the 'employees' table. It specifically filters for employees who earn the minimum salary within their respective departments. The placeholder in the WHERE clause represents the salary criteria based on the minimum salary grouped by department.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  department_id FROM employees WHERE salary IN (SELECT MIN(salary) FROM employees GROUP BY department_id)\"\n    }\n}\n"}
{"sample_id": "train.3526", "db_id": "hr_1", "question": "What are the department names and how many employees work in each of them?", "rationale": ["We need to retrieve the names of departments and the count of employees in each department.", "The relevant tables for this query are 'departments' and 'employees'.", "We will perform a LEFT JOIN between 'departments' and 'employees' on the DEPARTMENT_ID column to ensure we get all departments even if they have no employees.", "We will use the COUNT function to count the number of employees in each department.", "Finally, we will group the results by department name to get the count for each department."], "gold_sql": "SELECT department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY department_name", "source_tables": ["employees", "departments"], "pred_sql": "SELECT d.DEPARTMENT_NAME, COUNT(e.EMPLOYEE_ID) AS employee_count\nFROM departments d\nLEFT JOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID\nGROUP BY d.DEPARTMENT_NAME;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists unique department identifiers from the 'employees' table, grouped by department and manager. It filters the results to include only those departments that have a specified minimum number of employees, represented by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first and last names of employees from the 'employees' table who belong to specific departments. The placeholders in the WHERE clause represent the identifiers of the departments being queried.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name FROM employees WHERE department_id  =  [PLACEHOLDER-TYPE:NUMBER] OR department_id  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department identifiers from the 'employees' table, specifically targeting those employees who earn the minimum salary within their respective departments. The subquery identifies the minimum salary for each department, and the placeholder in the WHERE clause allows for dynamic filtering based on salary criteria.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  department_id FROM employees WHERE salary IN (SELECT MIN(salary) FROM employees GROUP BY department_id)\"\n    }\n}\n"}
{"sample_id": "train.3528", "db_id": "hr_1", "question": "What are full names and salaries of employees working in the city of London?", "rationale": ["Identify the required information: full names (first and last) and salaries of employees.", "The data is stored in the 'employees' table, which contains first names, last names, and salaries.", "To find employees in a specific city, we need to join the 'employees' table with the 'departments' table to access the department information, including the location.", "Next, we join the 'departments' table with the 'locations' table to filter by city.", "The WHERE clause will specify that the city must be 'London'.", "Construct the SQL query using the SELECT statement to retrieve the first name, last name, and salary from the joined tables."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  'London'", "source_tables": ["employees", "departments", "locations"], "pred_sql": "SELECT e.FIRST_NAME, e.LAST_NAME, e.SALARY \nFROM employees e \nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nJOIN locations l ON d.LOCATION_ID = l.LOCATION_ID \nWHERE l.CITY = 'London';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names, last names, and salaries of employees from the 'employees' table whose first names match a specific pattern. The placeholder in the WHERE clause represents the pattern for the first name.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  salary FROM employees WHERE first_name LIKE [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first names, last names, and salaries of employees from the 'employees' table who earn less than a specified salary. The placeholder in the WHERE clause represents the salary threshold.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  salary FROM employees WHERE salary  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the first names, last names, and salaries of employees from the 'employees' table who earn less than a specified salary. The placeholder in the WHERE clause represents the salary threshold.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  salary FROM employees WHERE salary  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3641", "db_id": "baseball_1", "question": "In 2014, what are the id and rank of the team that has the largest average number of attendance?", "rationale": ["Identify the relevant table: The 'team' table contains the necessary information about teams, including their attendance and rank.", "Filter for the year 2014: We need to focus on the records from the year 2014.", "Order by attendance: To find the team with the largest average attendance, we will order the results by the 'attendance' column in descending order.", "Limit the results: Since we only want the team with the largest attendance, we will limit the results to 1."], "gold_sql": "SELECT T2.team_id ,  T2.rank FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id WHERE T1.year  =  2014 GROUP BY T1.team_id ORDER BY avg(T1.attendance) DESC LIMIT 1;", "source_tables": ["team", "home_game"], "pred_sql": "SELECT team_id, rank FROM team WHERE year = 2014 ORDER BY attendance DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.\",\n        \"virtual_table\": \"SELECT yearid ,  count(*) FROM hall_of_fame GROUP BY yearid;\"\n    }\n}\n"}
{"sample_id": "train.3647", "db_id": "baseball_1", "question": "Which 3 players won the most player awards? List their full name and id.", "rationale": ["Identify the relevant tables: We need to gather player information and their awards, so we will use the 'player' and 'player_award' tables.", "Join the 'player' table with the 'player_award' table on 'player_id' to associate players with their awards.", "Count the number of awards each player has won using COUNT() and group the results by 'player_id'.", "Order the results in descending order based on the count of awards to find the top players.", "Limit the results to the top 3 players with the most awards."], "gold_sql": "SELECT T1.name_first ,  T1.name_last ,  T1.player_id FROM player AS T1 JOIN player_award AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.player_id ORDER BY count(*) DESC LIMIT 3;", "source_tables": ["player_award", "player"], "pred_sql": "SELECT p.player_id, p.name_first, p.name_last, COUNT(pa.award_id) AS award_count \nFROM player p \nJOIN player_award pa ON p.player_id = pa.player_id \nGROUP BY p.player_id \nORDER BY award_count DESC \nLIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.\",\n        \"virtual_table\": \"SELECT yearid ,  count(*) FROM hall_of_fame GROUP BY yearid;\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first and last names of players from the 'player' table who have a recorded year of death. The placeholder in the WHERE clause represents the specific year of death being queried.\",\n        \"virtual_table\": \"SELECT name_first ,  name_last FROM player WHERE death_year = [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the first and last names of players from the 'player' table who either weigh more than a specified amount or are shorter than a specified height. The placeholders in the WHERE clause represent the weight and height criteria for filtering the players.\",\n        \"virtual_table\": \"SELECT name_first ,  name_last FROM player WHERE weight  >  [PLACEHOLDER-TYPE:NUMBER] OR height  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3649", "db_id": "baseball_1", "question": "List three countries which are the origins of the least players.", "rationale": ["We need to find the countries with the least number of players.", "The relevant table for player information is the 'player' table, which contains the 'birth_country' and 'player_id' columns.", "To count the number of players from each country, we will use the COUNT function on 'player_id' and group the results by 'birth_country'.", "To get the countries with the least players, we will order the results in ascending order based on the count of players.", "Finally, we will limit the results to the top 3 countries with the least players."], "gold_sql": "SELECT birth_country FROM player GROUP BY birth_country ORDER BY count(*) ASC LIMIT 3;", "source_tables": ["player"], "pred_sql": "SELECT birth_country, COUNT(player_id) AS player_count\nFROM player\nGROUP BY birth_country\nORDER BY player_count ASC\nLIMIT 3;", "hint": "\n"}
{"sample_id": "train.3650", "db_id": "baseball_1", "question": "What are the three countries that the least players are from?", "rationale": ["We need to find the countries with the least number of players.", "The relevant table for player information is the 'player' table, which contains the 'birth_country' and 'player_id' columns.", "To count the number of players from each country, we will use the COUNT() function and group the results by 'birth_country'.", "We will order the results in ascending order based on the count of players to get the countries with the least players first.", "Finally, we will limit the results to the top 3 countries using the LIMIT clause."], "gold_sql": "SELECT birth_country FROM player GROUP BY birth_country ORDER BY count(*) ASC LIMIT 3;", "source_tables": ["player"], "pred_sql": "SELECT birth_country, COUNT(player_id) AS player_count\nFROM player\nGROUP BY birth_country\nORDER BY player_count ASC\nLIMIT 3;", "hint": "\n"}
{"sample_id": "train.3651", "db_id": "baseball_1", "question": "Find all the players' first name and last name who have empty death record.", "rationale": ["Identify the relevant table: The 'player' table contains the first and last names of players as well as their death records.", "Determine the condition: We need to find players who have an empty death record, which corresponds to a NULL value in the 'death_year' column.", "Construct the SQL query: Use a SELECT statement to retrieve 'name_first' and 'name_last' from the 'player' table where 'death_year' is NULL."], "gold_sql": "SELECT name_first ,  name_last FROM player WHERE death_year = '';", "source_tables": ["player"], "pred_sql": "SELECT name_first, name_last FROM player WHERE death_year IS NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of players from the 'player' table who have a recorded year of death. The placeholder in the WHERE clause represents the specific year of death being queried.\",\n        \"virtual_table\": \"SELECT name_first ,  name_last FROM player WHERE death_year = [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the first and last names of players from the 'player' table who either weigh more than a specified amount or are shorter than a specified height. The placeholders in the WHERE clause represent the weight and height criteria for filtering the players.\",\n        \"virtual_table\": \"SELECT name_first ,  name_last FROM player WHERE weight  >  [PLACEHOLDER-TYPE:NUMBER] OR height  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the first and last names of players from the 'player' table who either weigh more than a specified amount or are shorter than a specified height. The placeholders in the WHERE clause represent the weight and height criteria for filtering the players.\",\n        \"virtual_table\": \"SELECT name_first ,  name_last FROM player WHERE weight  >  [PLACEHOLDER-TYPE:NUMBER] OR height  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3657", "db_id": "baseball_1", "question": "What is the highest salary among each team? List the team name, id and maximum salary.", "rationale": ["We need to find the highest salary for each team, which requires joining the 'salary' table with the 'team' table to get the team names and IDs.", "The 'salary' table contains the salary records, and we will use the MAX() function to find the maximum salary for each team.", "We will group the results by team ID and name to ensure we get one maximum salary per team.", "The final SQL query will select the team name, team ID, and the maximum salary from the joined tables."], "gold_sql": "SELECT T1.name ,  T1.team_id ,  max(T2.salary) FROM team AS T1 JOIN salary AS T2 ON T1.team_id  =  T2.team_id GROUP BY T1.team_id;", "source_tables": ["team", "salary"], "pred_sql": "SELECT team.name, team.team_id, MAX(salary.salary) AS max_salary\nFROM salary\nJOIN team ON salary.team_id = team.team_id\nGROUP BY team.team_id, team.name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the salary records from the 'salary' table for a specific year, sorted in descending order. The placeholders represent the year for which the salary data is requested and the limit on the number of records to return.\",\n        \"virtual_table\": \"SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY salary DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves the salary records for players in two specific years from the 'salary' table. The placeholders in the WHERE clause represent the years for which the salary data is being queried.\",\n        \"virtual_table\": \"SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3662", "db_id": "baseball_1", "question": "Which players won awards in both 1960 and 1961? Return their first names and last names.", "rationale": ["We need to find players who won awards in both 1960 and 1961.", "To do this, we will join the 'player' table with the 'player_award' table twice: once for the year 1960 and once for the year 1961.", "The join condition will be based on the player_id to ensure we are looking at the same player in both instances.", "Finally, we will select the first and last names of these players."], "gold_sql": "SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1960 INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1961", "source_tables": ["player_award", "player"], "pred_sql": "SELECT p.name_first, p.name_last \nFROM player p \nJOIN player_award pa1 ON p.player_id = pa1.player_id \nJOIN player_award pa2 ON p.player_id = pa2.player_id \nWHERE pa1.year = '1960' AND pa2.year = '1961';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of players from the 'player' table who have a recorded year of death. The placeholder in the WHERE clause represents the specific year of death being queried.\",\n        \"virtual_table\": \"SELECT name_first ,  name_last FROM player WHERE death_year = [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.\",\n        \"virtual_table\": \"SELECT yearid ,  count(*) FROM hall_of_fame GROUP BY yearid;\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the first and last names of players from the 'player' table who either weigh more than a specified amount or are shorter than a specified height. The placeholders in the WHERE clause represent the weight and height criteria for filtering the players.\",\n        \"virtual_table\": \"SELECT name_first ,  name_last FROM player WHERE weight  >  [PLACEHOLDER-TYPE:NUMBER] OR height  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3665", "db_id": "baseball_1", "question": "List the maximum scores of the team Boston Red Stockings when the team won in postseason?", "rationale": ["Identify the relevant tables: postseason and team.", "We need to find the maximum scores (wins) of the team Boston Red Stockings when they won in postseason.", "The postseason table contains the wins of the winning team, and the team table contains the team names.", "Join the postseason table with the team table on the winning team ID.", "Filter the results to only include rows where the team name is 'Boston Red Stockings'.", "Use the MAX function to get the maximum wins from the filtered results."], "gold_sql": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings';", "source_tables": ["postseason", "team"], "pred_sql": "SELECT MAX(p.wins) AS max_wins\nFROM postseason p\nJOIN team t ON p.team_id_winner = t.team_id\nWHERE t.name = 'Boston Red Stockings';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.\",\n        \"virtual_table\": \"SELECT yearid ,  count(*) FROM hall_of_fame GROUP BY yearid;\"\n    }\n}\n"}
{"sample_id": "train.3666", "db_id": "baseball_1", "question": "What are the maximum scores the team Boston Red Stockings got when the team won in postseason?", "rationale": ["Identify the relevant table: The 'postseason' table contains information about postseason games, including the winning team and the number of wins.", "Determine the condition for the team: We need to find the team ID for 'Boston Red Stockings' from the 'team' table.", "Use a subquery to get the team ID: The subquery selects the team_id from the 'team' table where the name is 'Boston Red Stockings'.", "Filter the postseason records: We filter the 'postseason' records to only include those where the winning team matches the team ID of 'Boston Red Stockings'.", "Calculate the maximum wins: We use the MAX function to find the maximum number of wins for the filtered records."], "gold_sql": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings';", "source_tables": ["postseason", "team"], "pred_sql": "SELECT MAX(wins) AS max_wins\nFROM postseason\nWHERE team_id_winner = (SELECT team_id FROM team WHERE name = 'Boston Red Stockings');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.\",\n        \"virtual_table\": \"SELECT yearid ,  count(*) FROM hall_of_fame GROUP BY yearid;\"\n    }\n}\n"}
{"sample_id": "train.3669", "db_id": "baseball_1", "question": "What are the name and id of the team with the most victories in 2008 postseason?", "rationale": ["Identify the relevant tables: We need the 'team' table for team names and IDs, and the 'postseason' table to find the winning teams and their victories.", "Join the 'team' table with the 'postseason' table on the winning team ID (team_id_winner).", "Filter the results to only include the year 2008 from the 'postseason' table.", "Order the results by the number of wins in descending order to get the team with the most victories.", "Limit the results to 1 to get only the top team."], "gold_sql": "SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  2008 GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["postseason", "team"], "pred_sql": "SELECT team.name, team.team_id \nFROM team \nJOIN postseason ON team.team_id = postseason.team_id_winner \nWHERE postseason.year = 2008 \nORDER BY postseason.wins DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.\",\n        \"virtual_table\": \"SELECT yearid ,  count(*) FROM hall_of_fame GROUP BY yearid;\"\n    }\n}\n"}
{"sample_id": "train.3673", "db_id": "baseball_1", "question": "What is the total number of postseason games that team Boston Red Stockings participated in?", "rationale": ["Identify the relevant table for postseason games, which is 'batting_postseason'.", "Determine the column that represents the total games played in postseason, which is 'g'.", "To find the total number of postseason games for the Boston Red Stockings, we need to filter by the team_id associated with that team.", "Use a subquery to select the team_id from the 'team' table where the name is 'Boston Red Stockings'.", "Sum the 'g' column for the filtered results to get the total number of postseason games."], "gold_sql": "SELECT count(*) FROM ( SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' UNION SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' );", "source_tables": ["postseason", "team"], "pred_sql": "SELECT SUM(g) AS total_postseason_games \nFROM batting_postseason \nWHERE team_id = (SELECT team_id FROM team WHERE name = 'Boston Red Stockings');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.\",\n        \"virtual_table\": \"SELECT yearid ,  count(*) FROM hall_of_fame GROUP BY yearid;\"\n    }\n}\n"}
{"sample_id": "train.3678", "db_id": "baseball_1", "question": "What is the total salary expenses of team Boston Red Stockings in 2010?", "rationale": ["Identify the relevant table for salary data, which is the 'salary' table.", "Determine the specific team for which we need to calculate the total salary expenses, which is 'Boston Red Stockings'.", "Find the team_id for 'Boston Red Stockings' in the year 2010 from the 'team' table.", "Use the team_id to filter the salary records in the 'salary' table for the year 2010.", "Sum the salary amounts for the identified team in the specified year."], "gold_sql": "SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings' AND T1.year  =  2010", "source_tables": ["team", "salary"], "pred_sql": "SELECT SUM(salary) AS total_salary_expenses \nFROM salary \nWHERE team_id = (SELECT team_id FROM team WHERE name = 'Boston Red Stockings' AND year = 2010) \nAND year = 2010;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the salary records for players in two specific years from the 'salary' table. The placeholders in the WHERE clause represent the years for which the salary data is being queried.\",\n        \"virtual_table\": \"SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3679", "db_id": "baseball_1", "question": "How many players were in the team Boston Red Stockings in 2000?", "rationale": ["Identify the team ID for the Boston Red Stockings in the year 2000 by querying the 'team' table.", "Use the identified team ID to count the distinct player IDs in the 'appearances' table for that team in the year 2000."], "gold_sql": "SELECT count(*) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings' AND T1.year  =  2000", "source_tables": ["team", "salary"], "pred_sql": "SELECT COUNT(DISTINCT player_id) FROM appearances WHERE team_id = (SELECT team_id FROM team WHERE name = 'Boston Red Stockings' AND year = 2000);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.\",\n        \"virtual_table\": \"SELECT yearid ,  count(*) FROM hall_of_fame GROUP BY yearid;\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first and last names of players from the 'player' table who have a recorded year of death. The placeholder in the WHERE clause represents the specific year of death being queried.\",\n        \"virtual_table\": \"SELECT name_first ,  name_last FROM player WHERE death_year = [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the first and last names of players from the 'player' table who either weigh more than a specified amount or are shorter than a specified height. The placeholders in the WHERE clause represent the weight and height criteria for filtering the players.\",\n        \"virtual_table\": \"SELECT name_first ,  name_last FROM player WHERE weight  >  [PLACEHOLDER-TYPE:NUMBER] OR height  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3681", "db_id": "baseball_1", "question": "List the 3 highest salaries of the players in 2001?", "rationale": ["Identify the relevant table: The 'salary' table contains the salary records for players.", "Specify the year: We need to filter the records for the year 2001.", "Order the results: To find the highest salaries, we will order the results in descending order based on the salary.", "Limit the results: We only want the top 3 highest salaries, so we will limit the results to 3."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2001 ORDER BY salary DESC LIMIT 3;", "source_tables": ["salary"], "pred_sql": "SELECT salary FROM salary WHERE year = 2001 ORDER BY salary DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the salary records for players in two specific years from the 'salary' table. The placeholders in the WHERE clause represent the years for which the salary data is being queried.\",\n        \"virtual_table\": \"SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.\",\n        \"virtual_table\": \"SELECT yearid ,  count(*) FROM hall_of_fame GROUP BY yearid;\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the first and last names of players from the 'player' table who have a recorded year of death. The placeholder in the WHERE clause represents the specific year of death being queried.\",\n        \"virtual_table\": \"SELECT name_first ,  name_last FROM player WHERE death_year = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.3684", "db_id": "baseball_1", "question": "List all the salary values players received in 2010 and 2001.", "rationale": ["Identify the relevant table: The 'salary' table contains the salary records for players.", "Determine the years of interest: The user wants salary values for the years 2010 and 2001.", "Construct the SQL query: Use the UNION operator to combine the results from both years, ensuring to select the salary column from the salary table for each specified year."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2010 UNION SELECT salary FROM salary WHERE YEAR  =  2001", "source_tables": ["salary"], "pred_sql": "SELECT salary FROM salary WHERE year = 2010 UNION SELECT salary FROM salary WHERE year = 2001;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the salary records for players in two specific years from the 'salary' table. The placeholders in the WHERE clause represent the years for which the salary data is being queried.\",\n        \"virtual_table\": \"SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.\",\n        \"virtual_table\": \"SELECT yearid ,  count(*) FROM hall_of_fame GROUP BY yearid;\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the salary records from the 'salary' table for a specific year, sorted in descending order. The placeholders represent the year for which the salary data is requested and the limit on the number of records to return.\",\n        \"virtual_table\": \"SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY salary DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3685", "db_id": "baseball_1", "question": "In which year did the least people enter hall of fame?", "rationale": ["To find the year with the least number of players inducted into the Hall of Fame, we need to count the number of inductees for each year.", "We can achieve this by using a GROUP BY clause on the 'yearid' column in the 'hall_of_fame' table and applying the COUNT function to count the number of inductees per year.", "Next, we need to order the results by the count of inductees in ascending order to get the year with the least inductees at the top.", "Finally, we can limit the results to just one record to get the year with the least inductees."], "gold_sql": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT 1;", "source_tables": ["hall_of_fame"], "pred_sql": "SELECT yearid FROM (SELECT yearid, COUNT(*) as inductee_count FROM hall_of_fame GROUP BY yearid) ORDER BY inductee_count ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.\",\n        \"virtual_table\": \"SELECT yearid ,  count(*) FROM hall_of_fame GROUP BY yearid;\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first and last names of players from the 'player' table who have a recorded year of death. The placeholder in the WHERE clause represents the specific year of death being queried.\",\n        \"virtual_table\": \"SELECT name_first ,  name_last FROM player WHERE death_year = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.3686", "db_id": "baseball_1", "question": "Find the year in which the least people enter hall of fame.", "rationale": ["To find the year with the least number of players inducted into the Hall of Fame, we need to count the number of inductees for each year.", "We can use the COUNT function to aggregate the total number of inductees per year from the 'hall_of_fame' table.", "We will group the results by the year of induction (yearid) to get the count for each year.", "To find the year with the least inductees, we will order the results in ascending order based on the count of inductees.", "Finally, we will limit the results to 1 to get only the year with the least number of inductees."], "gold_sql": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT 1;", "source_tables": ["hall_of_fame"], "pred_sql": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY COUNT(*) ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.\",\n        \"virtual_table\": \"SELECT yearid ,  count(*) FROM hall_of_fame GROUP BY yearid;\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first and last names of players from the 'player' table who have a recorded year of death. The placeholder in the WHERE clause represents the specific year of death being queried.\",\n        \"virtual_table\": \"SELECT name_first ,  name_last FROM player WHERE death_year = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.3689", "db_id": "baseball_1", "question": "How many games were played in park \"Columbia Park\" in 1907?", "rationale": ["Identify the relevant tables: 'home_game' for games played and 'park' for park details.", "We need to find the park_id for 'Columbia Park' from the 'park' table.", "Use a subquery to get the park_id for 'Columbia Park'.", "Filter the 'home_game' table for the year 1907 and the specific park_id.", "Sum the total games played in that park for the specified year."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 1907 AND T2.park_name = 'Columbia Park';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(games) FROM home_game WHERE park_id = (SELECT park_id FROM park WHERE park_name = 'Columbia Park') AND year = 1907;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the cities where parks are located, specifically those that have a number of parks within a specified range. The placeholders in the HAVING clause represent the minimum and maximum number of parks that should be present in those cities.\",\n        \"virtual_table\": \"SELECT city FROM park GROUP BY city HAVING count(*) BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.\",\n        \"virtual_table\": \"SELECT yearid ,  count(*) FROM hall_of_fame GROUP BY yearid;\"\n    }\n}\n"}
{"sample_id": "train.3690", "db_id": "baseball_1", "question": "Count the number of games taken place in park \"Columbia Park\" in 1907.", "rationale": ["Identify the relevant tables: 'home_game' for game records and 'park' for park details.", "We need to count the number of games, so we will use the COUNT() function.", "Filter the games by the specific park name 'Columbia Park' and the year 1907.", "To get the park_id for 'Columbia Park', we will use a subquery that selects the park_id from the 'park' table where the park_name matches.", "Combine these elements into a SQL query that counts the games in the specified park and year."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 1907 AND T2.park_name = 'Columbia Park';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT COUNT(*) FROM home_game WHERE park_id = (SELECT park_id FROM park WHERE park_name = 'Columbia Park') AND year = 1907;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.\",\n        \"virtual_table\": \"SELECT yearid ,  count(*) FROM hall_of_fame GROUP BY yearid;\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the cities where parks are located, specifically those that have a number of parks within a specified range. The placeholders in the HAVING clause represent the minimum and maximum number of parks that should be present in those cities.\",\n        \"virtual_table\": \"SELECT city FROM park GROUP BY city HAVING count(*) BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3691", "db_id": "baseball_1", "question": "How many games were played in city Atlanta in 2000?", "rationale": ["Identify the relevant tables: home_game and park.", "We need to find the total number of games played in Atlanta in the year 2000.", "The home_game table contains the number of games played, the year, and the team_id.", "The park table contains the city and team_id.", "First, filter the home_game table for the year 2000.", "Next, filter the park table for teams located in Atlanta.", "Join the results by matching team_id from both tables to get the total games played in Atlanta for that year."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year  =  2000 AND T2.city  =  'Atlanta';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(games) FROM home_game WHERE year = 2000 AND team_id IN (SELECT team_id FROM park WHERE city = 'Atlanta');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.\",\n        \"virtual_table\": \"SELECT yearid ,  count(*) FROM hall_of_fame GROUP BY yearid;\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the cities where parks are located, specifically those that have a number of parks within a specified range. The placeholders in the HAVING clause represent the minimum and maximum number of parks that should be present in those cities.\",\n        \"virtual_table\": \"SELECT city FROM park GROUP BY city HAVING count(*) BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3692", "db_id": "baseball_1", "question": "Find the number of games taken place in city Atlanta in 2000.", "rationale": ["Identify the relevant tables: home_game and team.", "We need to find the total number of games played in Atlanta in the year 2000.", "The home_game table contains the number of games played, while the team table contains the city information.", "First, filter the team table to get the team_id for teams located in Atlanta.", "Then, use this team_id to filter the home_game table for the year 2000 and sum the games played."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year  =  2000 AND T2.city  =  'Atlanta';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(games) FROM home_game WHERE year = 2000 AND team_id IN (SELECT team_id FROM team WHERE city = 'Atlanta');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.\",\n        \"virtual_table\": \"SELECT yearid ,  count(*) FROM hall_of_fame GROUP BY yearid;\"\n    }\n}\n"}
{"sample_id": "train.3697", "db_id": "baseball_1", "question": "List players' first name and last name who received salary from team Washington Nationals in both 2005 and 2007.", "rationale": ["Identify the relevant tables: 'player' for player names and 'salary' for salary records.", "Join the 'player' table with the 'salary' table on 'player_id' to get player names associated with their salaries.", "Filter the results to include only those players who received salaries from the 'Washington Nationals' team in the years 2005 and 2007.", "Use a subquery to find the 'team_id' for 'Washington Nationals'.", "Use the 'IN' clause to filter for the years 2005 and 2007.", "Group the results by 'player_id' to ensure we can count the distinct years.", "Use the HAVING clause to ensure that only players who have salary records for both years are included."], "gold_sql": "SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2005 AND T3.name = 'Washington Nationals' INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2007 AND T3.name = 'Washington Nationals'", "source_tables": ["team", "player", "salary"], "pred_sql": "SELECT p.name_first, p.name_last \nFROM player p \nJOIN salary s ON p.player_id = s.player_id \nWHERE s.team_id = (SELECT team_id FROM team WHERE name = 'Washington Nationals') \nAND s.year IN (2005, 2007) \nGROUP BY p.player_id \nHAVING COUNT(DISTINCT s.year) = 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the salary records for players in two specific years from the 'salary' table. The placeholders in the WHERE clause represent the years for which the salary data is being queried.\",\n        \"virtual_table\": \"SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first and last names of players from the 'player' table who have a recorded year of death. The placeholder in the WHERE clause represents the specific year of death being queried.\",\n        \"virtual_table\": \"SELECT name_first ,  name_last FROM player WHERE death_year = [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.\",\n        \"virtual_table\": \"SELECT yearid ,  count(*) FROM hall_of_fame GROUP BY yearid;\"\n    }\n}\n"}
{"sample_id": "train.3699", "db_id": "baseball_1", "question": "How many home games did the team Boston Red Stockings play from 1990 to 2000 in total?", "rationale": ["Identify the relevant table for home games, which is 'home_game'.", "Determine the columns needed: 'games' for total home games and 'year' for the date range.", "Filter the results for the team 'Boston Red Stockings' by using a subquery to find the corresponding 'team_id' from the 'team' table.", "Set the year range from 1990 to 2000 using the WHERE clause.", "Use the SUM function to aggregate the total number of home games played by the team in the specified years."], "gold_sql": "SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = 'Boston Red Stockings' AND T1.year BETWEEN 1990 AND 2000;", "source_tables": ["team", "home_game"], "pred_sql": "SELECT SUM(games) AS total_home_games\nFROM home_game\nWHERE team_id = (SELECT team_id FROM team WHERE name = 'Boston Red Stockings')\nAND year BETWEEN 1990 AND 2000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.\",\n        \"virtual_table\": \"SELECT yearid ,  count(*) FROM hall_of_fame GROUP BY yearid;\"\n    }\n}\n"}
{"sample_id": "train.3702", "db_id": "baseball_1", "question": "Find the team that attended the least number of home games in 1980.", "rationale": ["Identify the relevant table: The 'home_game' table contains information about home games played by teams, including the year and the number of games.", "Filter the data: We need to focus on the year 1980, so we will add a WHERE clause to filter for that year.", "Sort the results: To find the team with the least number of home games, we will order the results by the 'games' column in ascending order.", "Limit the results: Since we only want the team with the least number of home games, we will use LIMIT 1 to get only the top result."], "gold_sql": "SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = 1980 ORDER BY T1.attendance ASC LIMIT 1;", "source_tables": ["team", "home_game"], "pred_sql": "SELECT team_id, games FROM home_game WHERE year = 1980 ORDER BY games ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.\",\n        \"virtual_table\": \"SELECT yearid ,  count(*) FROM hall_of_fame GROUP BY yearid;\"\n    }\n}\n"}
{"sample_id": "train.3710", "db_id": "baseball_1", "question": "Which park did the most people attend in 2008?", "rationale": ["Identify the relevant tables: home_game and park.", "We need to find the park with the highest attendance in 2008, so we will join the home_game table with the park table on the park_id.", "Filter the results to only include records from the year 2008.", "Order the results by attendance in descending order to get the park with the most attendance at the top.", "Limit the results to 1 to get only the park with the highest attendance."], "gold_sql": "SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 2008 ORDER BY T1.attendance DESC LIMIT 1;", "source_tables": ["park", "home_game"], "pred_sql": "SELECT park.park_name, home_game.attendance \nFROM home_game \nJOIN park ON home_game.park_id = park.park_id \nWHERE home_game.year = 2008 \nORDER BY home_game.attendance DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the cities where parks are located, specifically those that have a number of parks within a specified range. The placeholders in the HAVING clause represent the minimum and maximum number of parks that should be present in those cities.\",\n        \"virtual_table\": \"SELECT city FROM park GROUP BY city HAVING count(*) BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3898", "db_id": "hospital_1", "question": "Which department has the largest number of employees?", "rationale": ["Identify the relevant tables: Department and Physician.", "We need to count the number of employees (physicians) in each department.", "Join the Department table with the Physician table on the Head of the department.", "Group the results by DepartmentID to get the count of physicians per department.", "Order the results by the count of physicians in descending order to find the department with the most employees.", "Limit the results to 1 to get only the department with the largest number of employees."], "gold_sql": "SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT 1;", "source_tables": ["department"], "pred_sql": "SELECT Department.Name, COUNT(Physician.EmployeeID) AS EmployeeCount\nFROM Department\nLEFT JOIN Physician ON Department.Head = Physician.EmployeeID\nGROUP BY Department.DepartmentID\nORDER BY EmployeeCount DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department heads from the 'Department' table, grouped by department ID. The result is ordered by the count of departments, and a placeholder is used to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT head FROM department GROUP BY departmentID ORDER BY count(departmentID) LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of department heads from the 'Department' table, grouped by their department identifiers. The result is ordered by the count of departments, and a placeholder is used to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT head FROM department GROUP BY departmentID ORDER BY count(departmentID) LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3899", "db_id": "hospital_1", "question": "Find the department with the most employees.", "rationale": ["To find the department with the most employees, we need to count the number of physicians associated with each department.", "We will join the 'Department' table with the 'Physician' table using the 'Head' field from the 'Department' table and the 'EmployeeID' from the 'Physician' table.", "We will group the results by 'DepartmentID' to get the count of physicians for each department.", "We will order the results by the count of physicians in descending order to get the department with the most employees at the top.", "Finally, we will limit the results to 1 to get only the department with the highest count."], "gold_sql": "SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT 1;", "source_tables": ["department"], "pred_sql": "SELECT Department.Name, COUNT(Physician.EmployeeID) AS EmployeeCount\nFROM Department\nLEFT JOIN Physician ON Department.Head = Physician.EmployeeID\nGROUP BY Department.DepartmentID\nORDER BY EmployeeCount DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department heads from the 'Department' table, grouped by department ID. The result is ordered by the count of departments, and a placeholder is used to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT head FROM department GROUP BY departmentID ORDER BY count(departmentID) LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of department heads from the 'Department' table, grouped by their department identifiers. The result is ordered by the count of departments, and a placeholder is used to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT head FROM department GROUP BY departmentID ORDER BY count(departmentID) LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3902", "db_id": "hospital_1", "question": "what is the name and position of the head whose department has least number of employees?", "rationale": ["Identify the head of each department by joining the 'Department' table with the 'Physician' table on the 'Head' column.", "To find the department with the least number of employees, use the 'Affiliated_With' table to count the number of physicians affiliated with each department.", "Group the results by 'DepartmentID' and order them by the count of physicians in ascending order, limiting the result to the first entry to get the department with the least number of employees.", "Use the 'DepartmentID' from the previous step to filter the 'Department' table and get the corresponding head's name and position from the 'Physician' table."], "gold_sql": "SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["physician", "department"], "pred_sql": "SELECT Physician.Name, Physician.Position \nFROM Department \nJOIN Physician ON Department.Head = Physician.EmployeeID \nWHERE Department.DepartmentID = \n    (SELECT DepartmentID \n     FROM Affiliated_With \n     GROUP BY DepartmentID \n     ORDER BY COUNT(Physician) \n     LIMIT 1);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department heads from the 'Department' table, grouped by their department identifiers. The result is ordered by the count of departments, and a placeholder is used to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT head FROM department GROUP BY departmentID ORDER BY count(departmentID) LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of department heads from the 'Department' table, grouped by department ID. The result is ordered by the count of departments, and a placeholder is used to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT head FROM department GROUP BY departmentID ORDER BY count(departmentID) LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3904", "db_id": "hospital_1", "question": "What are names of patients who made an appointment?", "rationale": ["Identify the relevant tables: Patient and Appointment.", "We need to find the names of patients who have made appointments, which means we need to join the Patient table with the Appointment table.", "The common field between these two tables is Patient.SSN and Appointment.Patient.", "We will select the distinct names of patients from the Patient table who have corresponding entries in the Appointment table."], "gold_sql": "SELECT name FROM appointment AS T1 JOIN patient AS T2 ON T1.patient  =  T2.ssn", "source_tables": ["patient", "appointment"], "pred_sql": "SELECT DISTINCT Patient.Name \nFROM Patient \nJOIN Appointment ON Patient.SSN = Appointment.Patient;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the patients who have undergone procedures, ordered by the date of the procedures. The placeholder in the LIMIT clause represents the maximum number of patients to be displayed.\",\n        \"virtual_table\": \"SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of patients who have undergone medical procedures, sorted by the date of the procedures. The placeholder in the LIMIT clause allows for specifying the maximum number of patients to retrieve.\",\n        \"virtual_table\": \"SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of patients currently staying in a specific room, ordered by the start date of their stay in descending order. The placeholders represent the room number and the limit on the number of patients to retrieve.\",\n        \"virtual_table\": \"SELECT patient FROM stay WHERE room  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY staystart DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3905", "db_id": "hospital_1", "question": "List the names of patients who have made appointments.", "rationale": ["Identify the relevant tables: Patient and Appointment.", "We need to retrieve the names of patients who have made appointments, which means we need to join the Patient table with the Appointment table.", "The join condition will be based on the Patient's SSN matching the Appointment's Patient identifier.", "We will select the distinct names of patients to avoid duplicates, as a patient may have multiple appointments."], "gold_sql": "SELECT name FROM appointment AS T1 JOIN patient AS T2 ON T1.patient  =  T2.ssn", "source_tables": ["patient", "appointment"], "pred_sql": "SELECT DISTINCT Patient.Name FROM Patient JOIN Appointment ON Patient.SSN = Appointment.Patient;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the patients who have undergone procedures, ordered by the date of the procedures. The placeholder in the LIMIT clause represents the maximum number of patients to be displayed.\",\n        \"virtual_table\": \"SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of patients currently staying in a specific room, ordered by the start date of their stay in descending order. The placeholders represent the room number and the limit on the number of patients to retrieve.\",\n        \"virtual_table\": \"SELECT patient FROM stay WHERE room  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY staystart DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of patients who have undergone medical procedures, sorted by the date of the procedures. The placeholder in the LIMIT clause allows for specifying the maximum number of patients to retrieve.\",\n        \"virtual_table\": \"SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3914", "db_id": "hospital_1", "question": "Find the names of all physicians and their primary affiliated departments' names.", "rationale": ["Identify the tables needed: Physician, Affiliated_With, and Department.", "We need to select the names of physicians and their affiliated departments, so we will select Physician.Name and Department.Name.", "To link physicians with their departments, we will use the Affiliated_With table, which connects Physician and Department.", "We will perform a JOIN operation between Physician and Affiliated_With on the EmployeeID and Physician columns, respectively.", "Next, we will JOIN the Department table on the DepartmentID from Affiliated_With to get the department names.", "Since we are interested in primary affiliations, we will filter the results where Affiliated_With.PrimaryAffiliation is 'Yes'."], "gold_sql": "SELECT T1.name ,  T3.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T2.PrimaryAffiliation  =  1", "source_tables": ["physician", "department", "affiliated_with"], "pred_sql": "SELECT Physician.Name AS PhysicianName, Department.Name AS DepartmentName\nFROM Physician\nJOIN Affiliated_With ON Physician.EmployeeID = Affiliated_With.Physician\nJOIN Department ON Affiliated_With.Department = Department.DepartmentID\nWHERE Affiliated_With.PrimaryAffiliation = 'Yes';", "hint": "\n"}
{"sample_id": "train.3915", "db_id": "hospital_1", "question": "What are the name and primarily affiliated department name of each physician?", "rationale": ["Identify the relevant tables: Physician, Affiliated_With, and Department.", "We need to retrieve the physician's name and the name of their primarily affiliated department.", "Join the Physician table with the Affiliated_With table on the EmployeeID and Physician columns.", "Join the resulting table with the Department table on the DepartmentID and Department columns.", "Filter the results to include only those records where the PrimaryAffiliation is marked as 'Yes'.", "Select the Physician's name and the Department's name in the final output."], "gold_sql": "SELECT T1.name ,  T3.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T2.PrimaryAffiliation  =  1", "source_tables": ["physician", "department", "affiliated_with"], "pred_sql": "SELECT Physician.Name AS PhysicianName, Department.Name AS DepartmentName\nFROM Physician\nJOIN Affiliated_With ON Physician.EmployeeID = Affiliated_With.Physician\nJOIN Department ON Affiliated_With.Department = Department.DepartmentID\nWHERE Affiliated_With.PrimaryAffiliation = 'Yes';", "hint": "\n"}
{"sample_id": "train.3929", "db_id": "hospital_1", "question": "Return the name of each physician and the number of patients he or she treats.", "rationale": ["We need to return the name of each physician and the number of patients they treat.", "To achieve this, we will select the physician's name from the Physician table.", "We will count the number of patients associated with each physician, which can be done by counting the Patient.SSN from the Patient table.", "To link physicians with patients, we will use the Prescribes table, which connects physicians to the patients they prescribe medication to.", "We will perform a LEFT JOIN between the Physician table and the Prescribes table on the Physician's EmployeeID and the Prescribes' Physician field.", "Next, we will perform another LEFT JOIN between the Prescribes table and the Patient table on the Patient's SSN.", "Finally, we will group the results by the physician's name to get the count of patients for each physician."], "gold_sql": "SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid", "source_tables": ["physician", "patient"], "pred_sql": "SELECT Physician.Name, COUNT(Patient.SSN) AS NumberOfPatients\nFROM Physician\nLEFT JOIN Prescribes ON Physician.EmployeeID = Prescribes.Physician\nLEFT JOIN Patient ON Prescribes.Patient = Patient.SSN\nGROUP BY Physician.Name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the patients who have undergone procedures, ordered by the date of the procedures. The placeholder in the LIMIT clause represents the maximum number of patients to be displayed.\",\n        \"virtual_table\": \"SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of patients who have undergone medical procedures, sorted by the date of the procedures. The placeholder in the LIMIT clause allows for specifying the maximum number of patients to retrieve.\",\n        \"virtual_table\": \"SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of patients currently staying in a specific room, ordered by the start date of their stay in descending order. The placeholders represent the room number and the limit on the number of patients to retrieve.\",\n        \"virtual_table\": \"SELECT patient FROM stay WHERE room  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY staystart DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3930", "db_id": "hospital_1", "question": "Find the name of physicians who are in charge of more than one patient.", "rationale": ["We need to find physicians who are in charge of more than one patient.", "To do this, we will join the Physician table with the Prescribes table, as the Prescribes table contains information about which physician prescribed medication to which patient.", "We will group the results by the physician's EmployeeID to aggregate the data for each physician.", "Using the COUNT function, we will count the distinct patients associated with each physician.", "Finally, we will use the HAVING clause to filter the results to only include physicians who have prescribed to more than one distinct patient."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  1", "source_tables": ["physician", "patient"], "pred_sql": "SELECT Physician.Name\nFROM Physician\nJOIN Prescribes ON Physician.EmployeeID = Prescribes.Physician\nGROUP BY Physician.EmployeeID\nHAVING COUNT(DISTINCT Prescribes.Patient) > 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the patients who have undergone procedures, ordered by the date of the procedures. The placeholder in the LIMIT clause represents the maximum number of patients to be displayed.\",\n        \"virtual_table\": \"SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of patients who have undergone medical procedures, sorted by the date of the procedures. The placeholder in the LIMIT clause allows for specifying the maximum number of patients to retrieve.\",\n        \"virtual_table\": \"SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of nurses who are on call, filtered by specific conditions related to blocked floors and blocked codes. The placeholders in the WHERE clause represent the identifiers for the blocked floor and blocked code statuses.\",\n        \"virtual_table\": \"SELECT nurse FROM on_call WHERE blockfloor  =  [PLACEHOLDER-TYPE:NUMBER] AND blockcode  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3931", "db_id": "hospital_1", "question": "Which physicians are in charge of more than one patient? Give me their names.", "rationale": ["We need to find physicians who are in charge of more than one patient.", "To do this, we will use the 'Physician' table to get the names of the physicians.", "We will join the 'Prescribes' table to link physicians with the patients they have prescribed medication to.", "We will group the results by the physician's EmployeeID to count the number of distinct patients for each physician.", "Finally, we will use the HAVING clause to filter out those physicians who have more than one distinct patient."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  1", "source_tables": ["physician", "patient"], "pred_sql": "SELECT Physician.Name\nFROM Physician\nJOIN Prescribes ON Physician.EmployeeID = Prescribes.Physician\nGROUP BY Physician.EmployeeID\nHAVING COUNT(DISTINCT Prescribes.Patient) > 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the patients who have undergone procedures, ordered by the date of the procedures. The placeholder in the LIMIT clause represents the maximum number of patients to be displayed.\",\n        \"virtual_table\": \"SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of patients who have undergone medical procedures, sorted by the date of the procedures. The placeholder in the LIMIT clause allows for specifying the maximum number of patients to retrieve.\",\n        \"virtual_table\": \"SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of nurses who are on call, filtered by specific conditions related to blocked floors and blocked codes. The placeholders in the WHERE clause represent the identifiers for the blocked floor and blocked code statuses.\",\n        \"virtual_table\": \"SELECT nurse FROM on_call WHERE blockfloor  =  [PLACEHOLDER-TYPE:NUMBER] AND blockcode  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3934", "db_id": "hospital_1", "question": "Find the number of rooms for different block code?", "rationale": ["The question asks for the number of rooms for different block codes.", "We need to count the number of rooms grouped by their block code status.", "The Room table contains the BlockCode column and the RoomNumber column.", "We will use the COUNT() function to count the number of rooms for each BlockCode.", "The SQL query will select the BlockCode and the count of RoomNumber, grouping the results by BlockCode."], "gold_sql": "SELECT count(*) ,  T1.blockcode FROM BLOCK AS T1 JOIN room AS T2 ON T1.blockfloor  =  T2.blockfloor AND T1.blockcode  =  T2.blockcode GROUP BY T1.blockcode", "source_tables": ["block", "room"], "pred_sql": "SELECT BlockCode, COUNT(RoomNumber) AS NumberOfRooms FROM Room GROUP BY BlockCode;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of nurses who are on call, filtered by specific conditions related to blocked floors and blocked codes. The placeholders in the WHERE clause represent the identifiers for the blocked floor and blocked code statuses.\",\n        \"virtual_table\": \"SELECT nurse FROM on_call WHERE blockfloor  =  [PLACEHOLDER-TYPE:NUMBER] AND blockcode  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of patients currently staying in a specific room, ordered by the start date of their stay in descending order. The placeholders represent the room number and the limit on the number of patients to retrieve.\",\n        \"virtual_table\": \"SELECT patient FROM stay WHERE room  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY staystart DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3944", "db_id": "hospital_1", "question": "Find the number of medications prescribed for each brand.", "rationale": ["We need to find the number of medications prescribed for each brand.", "The relevant tables are 'Medication' and 'Prescribes'.", "We will join these two tables on the medication code, which is the common field between them.", "We will group the results by the 'Brand' column from the 'Medication' table.", "Finally, we will count the number of medications prescribed for each brand using COUNT() function."], "gold_sql": "SELECT count(*) ,  T1.name FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand", "source_tables": ["prescribes", "medication"], "pred_sql": "SELECT m.Brand, COUNT(p.Medication) AS NumberOfMedications\nFROM Medication m\nJOIN Prescribes p ON m.Code = p.Medication\nGROUP BY m.Brand;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the patients who have undergone procedures, ordered by the date of the procedures. The placeholder in the LIMIT clause represents the maximum number of patients to be displayed.\",\n        \"virtual_table\": \"SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3959", "db_id": "hospital_1", "question": "Find the physician who prescribed the highest dose. What is his or her name?", "rationale": ["Identify the relevant tables: Prescribes for prescriptions and Physician for physician details.", "We need to find the physician who prescribed the highest dose, so we will order the results by the Dose column in descending order.", "Join the Prescribes table with the Physician table on the Physician identifier to get the physician's name.", "Limit the results to 1 to get only the physician with the highest dose."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT 1", "source_tables": ["physician", "prescribes"], "pred_sql": "SELECT p.Name\nFROM Prescribes AS pr\nJOIN Physician AS p ON pr.Physician = p.EmployeeID\nORDER BY pr.Dose DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the patients who have undergone procedures, ordered by the date of the procedures. The placeholder in the LIMIT clause represents the maximum number of patients to be displayed.\",\n        \"virtual_table\": \"SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3960", "db_id": "hospital_1", "question": "List the physicians' employee ids together with their primary affiliation departments' ids.", "rationale": ["Identify the relevant tables: Physician and Affiliated_With.", "We need to select the EmployeeID from the Physician table and the Department from the Affiliated_With table.", "To link these two tables, we will use a JOIN on the Physician's EmployeeID and the Affiliated_With's Physician.", "We need to filter the results to only include primary affiliations, which is indicated by the PrimaryAffiliation column in the Affiliated_With table."], "gold_sql": "SELECT physician ,  department FROM affiliated_with WHERE primaryaffiliation  =  1", "source_tables": ["affiliated_with"], "pred_sql": "SELECT Physician.EmployeeID, Affiliated_With.Department \nFROM Physician \nJOIN Affiliated_With ON Physician.EmployeeID = Affiliated_With.Physician \nWHERE Affiliated_With.PrimaryAffiliation = 'Yes';", "hint": "\n"}
{"sample_id": "train.3961", "db_id": "hospital_1", "question": "What are each physician's employee id and department id primarily affiliated.", "rationale": ["Identify the required fields: EmployeeID from Physician and Department from Affiliated_With.", "Determine the relationship between the tables: Physician is linked to Affiliated_With through the Physician identifier.", "Use a JOIN clause to combine the Physician and Affiliated_With tables based on the matching EmployeeID and Physician fields.", "Filter the results to include only those records where the PrimaryAffiliation is marked as 'Yes' to get the primary affiliations."], "gold_sql": "SELECT physician ,  department FROM affiliated_with WHERE primaryaffiliation  =  1", "source_tables": ["affiliated_with"], "pred_sql": "SELECT Physician.EmployeeID, Affiliated_With.Department \nFROM Physician \nJOIN Affiliated_With ON Physician.EmployeeID = Affiliated_With.Physician \nWHERE Affiliated_With.PrimaryAffiliation = 'Yes';", "hint": "\n"}
{"sample_id": "train.3970", "db_id": "hospital_1", "question": "Find the three most expensive procedures.", "rationale": ["Identify the table that contains the procedures and their costs, which is the Procedures table.", "To find the most expensive procedures, we need to order the results by the Cost column in descending order.", "We want to limit the results to the top three most expensive procedures, so we will use the LIMIT clause with a value of 3."], "gold_sql": "SELECT name FROM procedures ORDER BY cost LIMIT 3", "source_tables": ["procedures"], "pred_sql": "SELECT Name, Cost FROM Procedures ORDER BY Cost DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the patients who have undergone procedures, ordered by the date of the procedures. The placeholder in the LIMIT clause represents the maximum number of patients to be displayed.\",\n        \"virtual_table\": \"SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of patients who have undergone medical procedures, sorted by the date of the procedures. The placeholder in the LIMIT clause allows for specifying the maximum number of patients to retrieve.\",\n        \"virtual_table\": \"SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3971", "db_id": "hospital_1", "question": "What are the three most costly procedures?", "rationale": ["Identify the table that contains the procedures and their costs, which is the Procedures table.", "We need to select the Name and Cost columns from the Procedures table.", "To find the most costly procedures, we will order the results by the Cost column in descending order.", "Finally, we will limit the results to the top three entries to get the three most costly procedures."], "gold_sql": "SELECT name FROM procedures ORDER BY cost LIMIT 3", "source_tables": ["procedures"], "pred_sql": "SELECT Name, Cost FROM Procedures ORDER BY Cost DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the patients who have undergone procedures, ordered by the date of the procedures. The placeholder in the LIMIT clause represents the maximum number of patients to be displayed.\",\n        \"virtual_table\": \"SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of patients who have undergone medical procedures, sorted by the date of the procedures. The placeholder in the LIMIT clause allows for specifying the maximum number of patients to retrieve.\",\n        \"virtual_table\": \"SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3973", "db_id": "hospital_1", "question": "Which physicians are trained in procedures that are more expensive than 5000?", "rationale": ["Identify the relevant tables: Physician, Trained_In, and Procedures.", "We need to find physicians who are trained in certain procedures, so we will join the Physician table with the Trained_In table on the Physician's EmployeeID.", "Next, we will join the Trained_In table with the Procedures table on the procedure code to access the cost of the procedures.", "We will filter the results to include only those procedures that have a cost greater than 5000.", "Finally, we will select the distinct names of the physicians who meet this criterion."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  5000", "source_tables": ["physician", "procedures", "trained_in"], "pred_sql": "SELECT DISTINCT Physician.Name\nFROM Physician\nJOIN Trained_In ON Physician.EmployeeID = Trained_In.Physician\nJOIN Procedures ON Trained_In.Treatment = Procedures.Code\nWHERE Procedures.Cost > 5000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the patients who have undergone procedures, ordered by the date of the procedures. The placeholder in the LIMIT clause represents the maximum number of patients to be displayed.\",\n        \"virtual_table\": \"SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of patients who have undergone medical procedures, sorted by the date of the procedures. The placeholder in the LIMIT clause allows for specifying the maximum number of patients to retrieve.\",\n        \"virtual_table\": \"SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3974", "db_id": "hospital_1", "question": "Find the physician who was trained in the most expensive procedure?", "rationale": ["Identify the relevant tables: Physician, Trained_In, and Procedures.", "We need to find the physician who was trained in the most expensive procedure, so we will join the Physician table with the Trained_In table to get the treatments they are trained in.", "Next, we will join the Procedures table to get the cost of those procedures.", "To find the most expensive procedure, we will use a subquery to select the maximum cost from the Procedures table.", "Finally, we will filter the results to only include the physician(s) trained in that most expensive procedure and select their names."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment ORDER BY T3.cost DESC LIMIT 1", "source_tables": ["physician", "procedures", "trained_in"], "pred_sql": "SELECT p.Name\nFROM Physician p\nJOIN Trained_In t ON p.EmployeeID = t.Physician\nJOIN Procedures pr ON t.Treatment = pr.Code\nWHERE pr.Cost = (SELECT MAX(Cost) FROM Procedures)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the patients who have undergone procedures, ordered by the date of the procedures. The placeholder in the LIMIT clause represents the maximum number of patients to be displayed.\",\n        \"virtual_table\": \"SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of patients who have undergone medical procedures, sorted by the date of the procedures. The placeholder in the LIMIT clause allows for specifying the maximum number of patients to retrieve.\",\n        \"virtual_table\": \"SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3985", "db_id": "hospital_1", "question": "What procedures cost less than 5000 and have John Wen as a trained physician?", "rationale": ["Identify the relevant tables: Procedures and Trained_In, as we need to check the cost of procedures and the physicians trained in them.", "Join the Procedures table with the Trained_In table on the procedure code to link procedures with the physicians who are trained in them.", "Join the resulting table with the Physician table to filter by the physician's name, which is 'John Wen'.", "Add a WHERE clause to filter procedures that cost less than 5000.", "Select the name of the procedures that meet the criteria."], "gold_sql": "SELECT name FROM procedures WHERE cost  <  5000 INTERSECT SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  'John Wen'", "source_tables": ["procedures", "physician", "trained_in"], "pred_sql": "SELECT Procedures.Name \nFROM Procedures \nJOIN Trained_In ON Procedures.Code = Trained_In.Treatment \nJOIN Physician ON Trained_In.Physician = Physician.EmployeeID \nWHERE Procedures.Cost < 5000 \nAND Physician.Name = 'John Wen';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the patients who have undergone procedures, ordered by the date of the procedures. The placeholder in the LIMIT clause represents the maximum number of patients to be displayed.\",\n        \"virtual_table\": \"SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of patients who have undergone medical procedures, sorted by the date of the procedures. The placeholder in the LIMIT clause allows for specifying the maximum number of patients to retrieve.\",\n        \"virtual_table\": \"SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of nurses who are on call, filtered by specific conditions related to blocked floors and blocked codes. The placeholders in the WHERE clause represent the identifiers for the blocked floor and blocked code statuses.\",\n        \"virtual_table\": \"SELECT nurse FROM on_call WHERE blockfloor  =  [PLACEHOLDER-TYPE:NUMBER] AND blockcode  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4321", "db_id": "tracking_grants_for_research", "question": "What are the different grant amounts for documents sent before '1986-08-26 20:49:27' and after the grant ended on '1989-03-16 18:27:16'?", "rationale": ["Identify the relevant tables: Grants and Documents are needed to get grant amounts and filter by document sent dates.", "Join the Grants table with the Documents table on the grant_id to link documents to their respective grants.", "Filter the results to include only those documents sent before '1986-08-26 20:49:27'.", "Also, filter the grants to ensure that the grant end date is before '1989-03-16 18:27:16'.", "Select distinct grant amounts to avoid duplicates in the results."], "gold_sql": "SELECT T1.grant_amount FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id WHERE T2.sent_date  <  '1986-08-26 20:49:27' INTERSECT SELECT grant_amount FROM grants WHERE grant_end_date  >  '1989-03-16 18:27:16'", "source_tables": ["grants", "documents"], "pred_sql": "SELECT DISTINCT Grants.grant_amount \nFROM Grants \nJOIN Documents ON Grants.grant_id = Documents.grant_id \nWHERE Documents.sent_date < '1986-08-26 20:49:27' \nAND Grants.grant_end_date < '1989-03-16 18:27:16';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\",\n        \"virtual_table\": \"SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the start and end dates of staff members' involvement in projects from the 'Project_Staff' table, filtered by a specific role code. The placeholder in the WHERE clause represents the role of the staff member.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4322", "db_id": "tracking_grants_for_research", "question": "List the project details of the project both producing patent and paper as outcomes.", "rationale": ["Identify the outcomes that are relevant to the query, which are 'patent' and 'paper'.", "Find the project IDs that have these outcomes by querying the Project_Outcomes table and filtering by the outcome codes that match the descriptions of 'patent' and 'paper'.", "Select the project details from the Projects table where the project ID is in the list obtained from the previous step."], "gold_sql": "SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  'Paper' INTERSECT SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  'Patent'", "source_tables": ["project_outcomes", "projects"], "pred_sql": "SELECT project_details FROM Projects WHERE project_id IN ( SELECT project_id FROM Project_Outcomes WHERE outcome_code IN (SELECT outcome_code FROM Research_Outcomes WHERE outcome_description IN ('patent', 'paper')) )", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\",\n        \"virtual_table\": \"SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.\",\n        \"virtual_table\": \"SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] )\"\n    }\n}\n"}
{"sample_id": "train.4324", "db_id": "tracking_grants_for_research", "question": "What is the total grant amount of the organisations described as research?", "rationale": ["Identify the relevant tables: Grants and Organisations are needed to find the total grant amount for organisations described as research.", "Determine the relationship between the tables: Grants has a foreign key to Organisations via organisation_id.", "Filter the organisations based on their type: We need to find organisations where the organisation_type matches the description 'research'.", "Use a subquery to get the organisation_type that corresponds to the description 'research' from the Organisation_Types table.", "Sum the grant_amount from the Grants table for the filtered organisations."], "gold_sql": "SELECT sum(grant_amount) FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id JOIN organisation_Types AS T3 ON T2.organisation_type  =  T3.organisation_type WHERE T3.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations"], "pred_sql": "SELECT SUM(grant_amount) AS total_grant_amount \nFROM Grants \nJOIN Organisations ON Grants.organisation_id = Organisations.organisation_id \nWHERE Organisations.organisation_type = (SELECT organisation_type FROM Organisation_Types WHERE organisation_type_description = 'research');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.\",\n        \"virtual_table\": \"SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4327", "db_id": "tracking_grants_for_research", "question": "From what date and to what date do the staff work on a project that has the most staff and has staff in a leader role?", "rationale": ["Identify the requirement to find the dates of staff involvement in a project with the most staff members and specifically those in a leader role.", "Use a subquery to find the project_id of the project that has the most staff members by grouping the Project_Staff table by project_id and ordering by the count of staff members, limiting the result to 1.", "Filter the main query to select date_from and date_to from Project_Staff where the project_id matches the one found in the subquery and the role_code is 'leader'."], "gold_sql": "SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT 1 ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  'leader'", "source_tables": ["project_staff"], "pred_sql": "SELECT date_from, date_to FROM Project_Staff WHERE project_id IN (SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT 1) AND role_code = 'leader'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\",\n        \"virtual_table\": \"SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the start and end dates of staff members' involvement in projects from the 'Project_Staff' table, filtered by a specific role code. The placeholder in the WHERE clause represents the role of the staff member.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4330", "db_id": "tracking_grants_for_research", "question": "What is the organisation type and id of the organisation which has the most number of research staff?", "rationale": ["Identify the relevant tables: Research_Staff, Organisations, and Organisation_Types.", "We need to find the organisation with the most research staff, so we will count the number of staff members per organisation.", "Join the Research_Staff table with the Organisations table on the employer_organisation_id to get the organisation details.", "Join the Organisations table with the Organisation_Types table to get the organisation type description.", "Group the results by organisation ID and organisation type to count the number of research staff for each organisation.", "Order the results by the count of research staff in descending order to get the organisation with the most staff at the top.", "Limit the results to 1 to get only the top organisation."], "gold_sql": "SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT Organisations.organisation_id, Organisation_Types.organisation_type \nFROM Research_Staff \nJOIN Organisations ON Research_Staff.employer_organisation_id = Organisations.organisation_id \nJOIN Organisation_Types ON Organisations.organisation_type = Organisation_Types.organisation_type \nGROUP BY Organisations.organisation_id, Organisation_Types.organisation_type \nORDER BY COUNT(Research_Staff.staff_id) DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of details about research staff members from the 'Research_Staff' table, sorted in ascending order. The placeholder in the ORDER BY clause indicates that the user can specify how they want to sort the staff details.\",\n        \"virtual_table\": \"SELECT staff_details FROM Research_Staff ORDER BY staff_details ASC\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of details about research staff members from the 'Research_Staff' table, sorted in ascending order. The placeholder in the ORDER BY clause indicates that the user can specify how they want to sort the staff details.\",\n        \"virtual_table\": \"SELECT staff_details FROM Research_Staff ORDER BY staff_details ASC\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4334", "db_id": "tracking_grants_for_research", "question": "Find out the send dates of the documents with the grant amount of more than 5000 were granted by organisation type described", "rationale": ["Identify the relevant tables: Documents, Grants, Organisations, and Organisation_Types.", "We need to find the send dates of documents, so we will select the 'sent_date' column from the Documents table.", "To filter documents based on grant amount, we need to join the Documents table with the Grants table using the 'grant_id' foreign key.", "Next, we need to join the Grants table with the Organisations table to access the organisation details.", "Finally, we will filter the results where the grant amount is greater than 5000."], "gold_sql": "SELECT T1.sent_date FROM documents AS T1 JOIN Grants AS T2 ON T1.grant_id  =  T2.grant_id JOIN Organisations AS T3 ON T2.organisation_id  =  T3.organisation_id JOIN organisation_Types AS T4 ON T3.organisation_type  =  T4.organisation_type WHERE T2.grant_amount  >  5000 AND T4.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations", "documents"], "pred_sql": "SELECT D.sent_date \nFROM Documents D \nJOIN Grants G ON D.grant_id = G.grant_id \nJOIN Organisations O ON G.organisation_id = O.organisation_id \nJOIN Organisation_Types OT ON O.organisation_type = OT.organisation_type \nWHERE G.grant_amount > 5000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.\",\n        \"virtual_table\": \"SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] )\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\",\n        \"virtual_table\": \"SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4338", "db_id": "tracking_grants_for_research", "question": "List the project details of the projects which did not hire any staff for a researcher role.", "rationale": ["Identify the relevant tables: Projects and Project_Staff are needed to get project details and staff roles.", "Use a LEFT JOIN to include all projects and their associated staff, even if there are no staff members hired.", "Filter the results to include only those projects where the role_code is NULL (indicating no staff hired) or where the role_code does not match the Researcher role.", "The Researcher role can be identified by querying the Staff_Roles table for the specific role description."], "gold_sql": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_Staff WHERE role_code  =  'researcher' )", "source_tables": ["project_staff", "projects"], "pred_sql": "SELECT p.project_details \nFROM Projects p \nLEFT JOIN Project_Staff ps ON p.project_id = ps.project_id \nWHERE ps.role_code IS NULL OR ps.role_code != (SELECT role_code FROM Staff_Roles WHERE role_description = 'Researcher')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\",\n        \"virtual_table\": \"SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of staff members associated with projects, filtered by a specific role code or by their involvement start date. The placeholders in the WHERE clause represent the role code and the date from which to consider staff involvement.\",\n        \"virtual_table\": \"SELECT count(*) FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING] OR date_from  <  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4339", "db_id": "tracking_grants_for_research", "question": "What are the details for all projects that did not hire any staff in a research role?", "rationale": ["Identify the main table to query: Projects, as we need details for all projects.", "Determine the condition: Projects that did not hire any staff in a research role.", "To find projects with research staff, we need to check the Project_Staff table for entries with a role_code that corresponds to research roles.", "Use a subquery to select project_ids from Project_Staff where the role_code matches research roles.", "Use another subquery to filter out those project_ids from the main Projects table, ensuring we only get projects without any research staff."], "gold_sql": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_Staff WHERE role_code  =  'researcher' )", "source_tables": ["project_staff", "projects"], "pred_sql": "SELECT * FROM Projects WHERE project_id NOT IN (SELECT project_id FROM Project_Staff WHERE role_code IN (SELECT role_code FROM Staff_Roles WHERE role_description LIKE '%research%'));", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\",\n        \"virtual_table\": \"SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of staff members associated with projects, filtered by a specific role code or by their involvement start date. The placeholders in the WHERE clause represent the role code and the date from which to consider staff involvement.\",\n        \"virtual_table\": \"SELECT count(*) FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING] OR date_from  <  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4342", "db_id": "tracking_grants_for_research", "question": "When do all the researcher role staff start to work, and when do they stop working?", "rationale": ["Identify the relevant role codes for researcher staff members by querying the Staff_Roles table.", "Use the identified role codes to filter the Project_Staff table for their start and end dates of involvement in projects.", "Construct the final SQL query to select the start (date_from) and end (date_to) dates for all researcher role staff."], "gold_sql": "SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  'researcher'", "source_tables": ["project_staff"], "pred_sql": "SELECT date_from, date_to FROM Project_Staff WHERE role_code IN (SELECT role_code FROM Staff_Roles WHERE role_description LIKE '%researcher%')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\",\n        \"virtual_table\": \"SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the start and end dates of staff members' involvement in projects from the 'Project_Staff' table, filtered by a specific role code. The placeholder in the WHERE clause represents the role of the staff member.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4350", "db_id": "tracking_grants_for_research", "question": "How many staff does each project has? List the project id and the number in an ascending order.", "rationale": ["Identify the relevant tables: The 'Project_Staff' table contains information about staff members associated with projects.", "Determine the required information: We need to count the number of staff members for each project.", "Use the COUNT() function to count staff members grouped by project_id.", "Group the results by project_id to get the count for each project.", "Order the results in ascending order based on the staff count."], "gold_sql": "SELECT T1.project_id ,  count(*) FROM Project_Staff AS T1 JOIN Projects AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) ASC", "source_tables": ["project_staff", "projects"], "pred_sql": "SELECT project_id, COUNT(staff_id) AS staff_count \nFROM Project_Staff \nGROUP BY project_id \nORDER BY staff_count ASC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of staff members associated with projects, filtered by a specific role code or by their involvement start date. The placeholders in the WHERE clause represent the role code and the date from which to consider staff involvement.\",\n        \"virtual_table\": \"SELECT count(*) FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING] OR date_from  <  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.\",\n        \"virtual_table\": \"SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] )\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4351", "db_id": "tracking_grants_for_research", "question": "For each project id, how many staff does it have? List them in increasing order.", "rationale": ["Identify the relevant table: The 'Project_Staff' table contains information about staff members associated with projects.", "Determine the required information: We need to count the number of staff members for each project.", "Use the COUNT() function to count staff members grouped by project_id.", "Group the results by project_id to get the count for each project.", "Order the results in increasing order of staff count using ORDER BY."], "gold_sql": "SELECT T1.project_id ,  count(*) FROM Project_Staff AS T1 JOIN Projects AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) ASC", "source_tables": ["project_staff", "projects"], "pred_sql": "SELECT project_id, COUNT(staff_id) AS staff_count FROM Project_Staff GROUP BY project_id ORDER BY staff_count ASC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of staff members associated with projects, filtered by a specific role code or by their involvement start date. The placeholders in the WHERE clause represent the role code and the date from which to consider staff involvement.\",\n        \"virtual_table\": \"SELECT count(*) FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING] OR date_from  <  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\",\n        \"virtual_table\": \"SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4356", "db_id": "tracking_grants_for_research", "question": "Which project made the most number of outcomes? List the project details and the project id.", "rationale": ["Identify the relevant tables: Projects and Project_Outcomes are needed to get project details and their outcomes.", "Determine the relationship: Project_Outcomes is linked to Projects through project_id.", "Count the outcomes for each project: Use GROUP BY on project_id in Project_Outcomes to count the number of outcomes per project.", "Order the results: Use ORDER BY count(*) DESC to sort projects by the number of outcomes in descending order.", "Limit the results: Use LIMIT 1 to get the project with the most outcomes.", "Select the required fields: Retrieve project_id and project_details from the Projects table for the project identified in the previous step."], "gold_sql": "SELECT T1.project_details ,  T1.project_id FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "projects"], "pred_sql": "SELECT project_id, project_details FROM Projects WHERE project_id IN ( SELECT project_id FROM Project_Outcomes GROUP BY project_id ORDER BY count(*) DESC LIMIT 1 )", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.\",\n        \"virtual_table\": \"SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of staff members associated with projects, filtered by a specific role code or by their involvement start date. The placeholders in the WHERE clause represent the role code and the date from which to consider staff involvement.\",\n        \"virtual_table\": \"SELECT count(*) FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING] OR date_from  <  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4359", "db_id": "tracking_grants_for_research", "question": "What are the details of the project with no outcomes?", "rationale": ["Identify the main table of interest, which is 'Projects', as we want details of projects.", "To find projects with no outcomes, we need to check the 'Project_Outcomes' table.", "We can use a subquery to select all project_ids from 'Project_Outcomes'.", "The main query will select all columns from 'Projects' where the project_id is not in the list of project_ids returned by the subquery."], "gold_sql": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_outcomes )", "source_tables": ["project_outcomes", "projects"], "pred_sql": "SELECT * FROM Projects WHERE project_id NOT IN (SELECT project_id FROM Project_Outcomes)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.\",\n        \"virtual_table\": \"SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\",\n        \"virtual_table\": \"SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4360", "db_id": "tracking_grants_for_research", "question": "Which organisation hired the most number of research staff? List the organisation id, type and detail.", "rationale": ["Identify the relevant tables: We need to find information about organisations and the research staff they hired, so we will use the Organisations and Research_Staff tables.", "Join the tables: We will join the Organisations table with the Research_Staff table on the organisation_id to link each research staff member to their respective organisation.", "Group the results: We will group the results by organisation_id, organisation_type, and organisation_details to count the number of research staff for each organisation.", "Count the research staff: We will use COUNT(rs.staff_id) to count the number of research staff members for each organisation.", "Order the results: We will order the results in descending order based on the count of research staff to find the organisation with the most hires.", "Limit the results: We will limit the results to 1 to get only the organisation that hired the most research staff."], "gold_sql": "SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT o.organisation_id, o.organisation_type, o.organisation_details\nFROM Organisations o\nJOIN Research_Staff rs ON o.organisation_id = rs.employer_organisation_id\nGROUP BY o.organisation_id, o.organisation_type, o.organisation_details\nORDER BY COUNT(rs.staff_id) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of details about research staff members from the 'Research_Staff' table, sorted in ascending order. The placeholder in the ORDER BY clause indicates that the user can specify how they want to sort the staff details.\",\n        \"virtual_table\": \"SELECT staff_details FROM Research_Staff ORDER BY staff_details ASC\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of details about research staff members from the 'Research_Staff' table, sorted in ascending order. The placeholder in the ORDER BY clause indicates that the user can specify how they want to sort the staff details.\",\n        \"virtual_table\": \"SELECT staff_details FROM Research_Staff ORDER BY staff_details ASC\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4363", "db_id": "tracking_grants_for_research", "question": "For each staff id, what is the description of the role that is involved with the most number of projects?", "rationale": ["Identify the relevant tables: Project_Staff for staff involvement in projects and Staff_Roles for role descriptions.", "We need to find the role involved with the most number of projects, so we will count the number of projects each role is associated with.", "Use a subquery to select the project_id of the project with the maximum number of staff members involved.", "Join the Project_Staff table with the Staff_Roles table to get the role descriptions for the staff members.", "Select the staff_id and the corresponding role description for the role involved in the most projects."], "gold_sql": "SELECT T1.role_description ,  T2.staff_id FROM Staff_Roles AS T1 JOIN Project_Staff AS T2 ON T1.role_code  =  T2.role_code JOIN Project_outcomes AS T3 ON T2.project_id  =  T3.project_id GROUP BY T2.staff_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "project_staff", "staff_roles"], "pred_sql": "SELECT ps.staff_id, sr.role_description\nFROM Project_Staff ps\nJOIN Staff_Roles sr ON ps.role_code = sr.role_code\nWHERE ps.project_id IN (\n    SELECT project_id\n    FROM Project_Staff\n    GROUP BY project_id\n    ORDER BY COUNT(*) DESC\n    LIMIT 1\n)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\",\n        \"virtual_table\": \"SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of staff members associated with projects, filtered by a specific role code or by their involvement start date. The placeholders in the WHERE clause represent the role code and the date from which to consider staff involvement.\",\n        \"virtual_table\": \"SELECT count(*) FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING] OR date_from  <  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4364", "db_id": "tracking_grants_for_research", "question": "Which document type is described with the prefix 'Initial'?", "rationale": ["Identify the table that contains document types, which is 'Document_Types'.", "Determine the relevant columns needed: 'document_type_code' and 'document_description'.", "The question asks for document types with descriptions that start with the prefix 'Initial'.", "Use the SQL 'LIKE' operator to filter results where 'document_description' starts with 'Initial'.", "Construct the SQL query to select the required columns from the 'Document_Types' table with the appropriate condition."], "gold_sql": "SELECT document_type_code FROM Document_Types WHERE document_description LIKE 'Initial%'", "source_tables": ["document_types"], "pred_sql": "SELECT document_type_code, document_description FROM Document_Types WHERE document_description LIKE 'Initial%';", "hint": "\n"}
{"sample_id": "train.4369", "db_id": "tracking_grants_for_research", "question": "For each grant id, how many documents does it have, and which one has the most?", "rationale": ["We need to count the number of documents associated with each grant id.", "To do this, we will join the Grants table with the Documents table on the grant_id.", "We will use COUNT(d.document_id) to count the number of documents for each grant.", "We will group the results by grant_id to get the count for each grant.", "To find the grant with the most documents, we will order the results by the document count in descending order.", "Finally, we will limit the results to 1 to get the grant with the most documents."], "gold_sql": "SELECT grant_id ,  count(*) FROM Documents GROUP BY grant_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["documents"], "pred_sql": "SELECT g.grant_id, COUNT(d.document_id) AS document_count, d.document_id\nFROM Grants g\nLEFT JOIN Documents d ON g.grant_id = d.grant_id\nGROUP BY g.grant_id\nHAVING COUNT(d.document_id) > 0\nORDER BY document_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.4374", "db_id": "tracking_grants_for_research", "question": "How many Patent outcomes are generated from all the projects?", "rationale": ["Identify the relevant tables: Project_Outcomes and Research_Outcomes.", "Determine the relationship between project outcomes and research outcomes based on the outcome_code.", "Filter the research outcomes to find those that are related to patents by checking the outcome_description for the keyword 'Patent'.", "Count the number of project outcomes that match the filtered patent outcomes."], "gold_sql": "SELECT count(*) FROM Project_outcomes WHERE outcome_code  =  'Patent'", "source_tables": ["project_outcomes"], "pred_sql": "SELECT COUNT(*) AS patent_outcomes_count \nFROM Project_Outcomes \nWHERE outcome_code IN (SELECT outcome_code FROM Research_Outcomes WHERE outcome_description LIKE '%Patent%');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.\",\n        \"virtual_table\": \"SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4376", "db_id": "tracking_grants_for_research", "question": "How many project staff worked as leaders or started working before '1989-04-24 23:51:54'?", "rationale": ["Identify the relevant table: Project_Staff contains information about staff members and their roles.", "Determine the conditions: We need to count staff members who are leaders or started working before a specific date.", "Use the count function to get the total number of staff members that meet either condition.", "Construct the SQL query using the identified table and conditions."], "gold_sql": "SELECT count(*) FROM Project_Staff WHERE role_code  =  'leader' OR date_from  <  '1989-04-24 23:51:54'", "source_tables": ["project_staff"], "pred_sql": "SELECT count(*) FROM Project_Staff WHERE role_code = 'leader' OR date_from < '1989-04-24 23:51:54'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\",\n        \"virtual_table\": \"SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of staff members associated with projects, filtered by a specific role code or by their involvement start date. The placeholders in the WHERE clause represent the role code and the date from which to consider staff involvement.\",\n        \"virtual_table\": \"SELECT count(*) FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING] OR date_from  <  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4380", "db_id": "tracking_grants_for_research", "question": "What are the result description of the project whose detail is 'sint'?", "rationale": ["Identify the table that contains project details, which is the 'Projects' table.", "Formulate a query to select the 'project_id' from the 'Projects' table where the 'project_details' match the input 'sint'.", "The final SQL query retrieves the project ID for the project with the specified details."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code JOIN Projects AS T3 ON T2.project_id  =  T3.project_id WHERE T3.project_details  =  'sint'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "pred_sql": "SELECT project_id FROM Projects WHERE project_details = 'sint';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.\",\n        \"virtual_table\": \"SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\",\n        \"virtual_table\": \"SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of staff members associated with projects, filtered by a specific role code or by their involvement start date. The placeholders in the WHERE clause represent the role code and the date from which to consider staff involvement.\",\n        \"virtual_table\": \"SELECT count(*) FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING] OR date_from  <  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4381", "db_id": "tracking_grants_for_research", "question": "What is the description for the results whose project detail is 'sint'?", "rationale": ["Identify the relevant table for project details, which is the 'Projects' table.", "We need to find the project_id associated with the project detail 'sint'.", "Use a subquery to select project_id from the 'Projects' table where project_details matches 'sint'.", "Next, we need to retrieve the outcome details from the 'Project_Outcomes' table that correspond to the project_id found in the previous step.", "Construct the final SQL query to select outcome_details from 'Project_Outcomes' using the project_id from the subquery."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code JOIN Projects AS T3 ON T2.project_id  =  T3.project_id WHERE T3.project_details  =  'sint'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "pred_sql": "SELECT outcome_details FROM Project_Outcomes WHERE project_id IN (SELECT project_id FROM Projects WHERE project_details = 'sint')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.\",\n        \"virtual_table\": \"SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\",\n        \"virtual_table\": \"SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4385", "db_id": "tracking_grants_for_research", "question": "What are the details for the projects which were launched by the organization with the most projects?", "rationale": ["Identify the organisation with the most projects by grouping the Projects table by organisation_id and counting the number of projects for each organisation.", "Order the results in descending order based on the project count to get the organisation with the highest number of projects at the top.", "Limit the results to 1 to get only the organisation with the most projects.", "Use the organisation_id from the previous step to filter the Projects table and retrieve all details for the projects associated with that organisation."], "gold_sql": "SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT 1 )", "source_tables": ["projects"], "pred_sql": "SELECT * FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT 1 )", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.\",\n        \"virtual_table\": \"SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\",\n        \"virtual_table\": \"SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4391", "db_id": "tracking_grants_for_research", "question": "For each project id, how many tasks are there?", "rationale": ["The question asks for the number of tasks associated with each project id.", "To achieve this, we need to select the project_id from the Tasks table.", "We will use the COUNT() function to count the number of task_id entries for each project_id.", "We will group the results by project_id to get the count for each individual project."], "gold_sql": "SELECT count(*) ,  T1.project_details FROM Projects AS T1 JOIN Tasks AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id", "source_tables": ["tasks", "projects"], "pred_sql": "SELECT project_id, COUNT(task_id) AS task_count FROM Tasks GROUP BY project_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.\",\n        \"virtual_table\": \"SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of staff members associated with projects, filtered by a specific role code or by their involvement start date. The placeholders in the WHERE clause represent the role code and the date from which to consider staff involvement.\",\n        \"virtual_table\": \"SELECT count(*) FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING] OR date_from  <  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\",\n        \"virtual_table\": \"SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4392", "db_id": "tracking_grants_for_research", "question": "What are the staff roles of the staff who", "rationale": ["The user wants to know the staff roles of the staff members.", "The relevant table for staff roles is 'Project_Staff', which contains the 'role_code' column.", "To get the staff roles, we can directly select the 'role_code' from the 'Project_Staff' table."], "gold_sql": "SELECT role_code FROM Project_Staff WHERE date_from  >  '2003-04-19 15:06:20' AND date_to  <  '2016-03-15 00:33:18'", "source_tables": ["project_staff"], "pred_sql": "SELECT role_code FROM Project_Staff", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\",\n        \"virtual_table\": \"SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of staff members associated with projects, filtered by a specific role code or by their involvement start date. The placeholders in the WHERE clause represent the role code and the date from which to consider staff involvement.\",\n        \"virtual_table\": \"SELECT count(*) FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING] OR date_from  <  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4397", "db_id": "tracking_grants_for_research", "question": "What is the most common role for the staff?", "rationale": ["To find the most common role for the staff, we need to count the occurrences of each role in the Project_Staff table.", "We will use the COUNT function to count the number of staff members for each role_code.", "We will group the results by role_code to aggregate the counts for each role.", "To determine the most common role, we will order the results in descending order based on the count of staff members.", "Finally, we will limit the results to 1 to get only the most common role."], "gold_sql": "SELECT role_code FROM Project_Staff GROUP BY role_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_staff"], "pred_sql": "SELECT role_code, COUNT(*) as role_count \nFROM Project_Staff \nGROUP BY role_code \nORDER BY role_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\",\n        \"virtual_table\": \"SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of staff members associated with projects, filtered by a specific role code or by their involvement start date. The placeholders in the WHERE clause represent the role code and the date from which to consider staff involvement.\",\n        \"virtual_table\": \"SELECT count(*) FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING] OR date_from  <  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5534", "db_id": "products_gen_characteristics", "question": "Find the number of products with category \"Spices\" and typically sold above 1000.", "rationale": ["Identify the relevant tables: Products and Ref_Product_Categories.", "Determine the condition for product category: We need to find the product category code for 'Spices'.", "Use a subquery to get the product_category_code from Ref_Product_Categories where the description is 'Spices'.", "Set the condition for typical selling price to be greater than 1000.", "Combine these conditions in the main query to count the number of products that meet both criteria."], "gold_sql": "SELECT count(*) FROM products WHERE product_category_code  =  'Spices' AND typical_buying_price  >  1000", "source_tables": ["products"], "pred_sql": "SELECT count(*) FROM Products WHERE product_category_code = (SELECT product_category_code FROM Ref_Product_Categories WHERE product_category_description = 'Spices') AND typical_selling_price > 1000", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of products from the 'Products' table that belong to a specific product category and have a typical buying price above a certain threshold. The placeholders in the WHERE clause represent the product category code and the minimum buying price.\",\n        \"virtual_table\": \"SELECT count(*) FROM products WHERE product_category_code  =  [PLACEHOLDER-TYPE:STRING] AND typical_buying_price  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5543", "db_id": "products_gen_characteristics", "question": "What are the descriptions of the categories that products with product descriptions that contain the letter t are in?", "rationale": ["Identify the relevant tables: We need to get product category descriptions, so we will use the Ref_Product_Categories table.", "Join the Products table with the Ref_Product_Categories table on the product_category_code to link products with their respective categories.", "Filter the products to only include those whose product descriptions contain the letter 't'. This can be done using the LIKE operator with a wildcard.", "Select distinct product category descriptions to avoid duplicates in the results."], "gold_sql": "SELECT T1.product_category_description FROM ref_product_categories AS T1 JOIN products AS T2 ON T1.product_category_code  =  T2.product_category_code WHERE T2.product_description LIKE '%t%'", "source_tables": ["products", "ref_product_categories"], "pred_sql": "SELECT DISTINCT rpc.product_category_description \nFROM Ref_Product_Categories rpc \nJOIN Products p ON rpc.product_category_code = p.product_category_code \nWHERE p.product_description LIKE '%t%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of products from the 'Products' table that belong to a specific product category and have a typical buying price above a certain threshold. The placeholders in the WHERE clause represent the product category code and the minimum buying price.\",\n        \"virtual_table\": \"SELECT count(*) FROM products WHERE product_category_code  =  [PLACEHOLDER-TYPE:STRING] AND typical_buying_price  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5576", "db_id": "products_gen_characteristics", "question": "Count the products that have the color description \"white\" or have the characteristic name \"hot\".", "rationale": ["We need to count the products based on two conditions: color description and characteristic name.", "First, we will select from the Products table.", "To check the color description, we will join the Ref_Colors table on the color_code.", "To check the characteristic name, we will join the Product_Characteristics table with the Characteristics table on their respective IDs.", "In the WHERE clause, we will specify the conditions: color description should be 'white' or characteristic name should be 'hot'.", "Finally, we will use COUNT(*) to get the total number of products that meet either of the conditions."], "gold_sql": "SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  'white' OR t3.characteristic_name  =  'hot'", "source_tables": ["products", "ref_colors", "characteristics", "product_characteristics"], "pred_sql": "SELECT COUNT(*) FROM Products p\nLEFT JOIN Ref_Colors c ON p.color_code = c.color_code\nLEFT JOIN Product_Characteristics pc ON p.product_id = pc.product_id\nLEFT JOIN Characteristics ch ON pc.characteristic_id = ch.characteristic_id\nWHERE c.color_description = 'white' OR ch.characteristic_name = 'hot';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of products from the 'Products' table that belong to a specific product category and have a typical buying price above a certain threshold. The placeholders in the WHERE clause represent the product category code and the minimum buying price.\",\n        \"virtual_table\": \"SELECT count(*) FROM products WHERE product_category_code  =  [PLACEHOLDER-TYPE:STRING] AND typical_buying_price  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5579", "db_id": "products_gen_characteristics", "question": "Return the unit of measure for 'Herb' products.", "rationale": ["Identify the relevant tables: We need to find the unit of measure for 'Herb' products, which involves the Products and Ref_Product_Categories tables.", "Determine the relationship: The Products table has a foreign key linking to the Ref_Product_Categories table through the product_category_code.", "Filter the Products table: We need to filter the Products table to find products that have 'Herb' in their name.", "Subquery for product category: Use a subquery to get the product_category_code from the Products table where the product_name contains 'Herb'.", "Select the unit of measure: Finally, select the unit_of_measure from the Ref_Product_Categories table using the product_category_code obtained from the subquery."], "gold_sql": "SELECT unit_of_measure FROM ref_product_categories WHERE product_category_code  =  'Herbs'", "source_tables": ["ref_product_categories"], "pred_sql": "SELECT unit_of_measure FROM Ref_Product_Categories WHERE product_category_code = (SELECT product_category_code FROM Products WHERE product_name LIKE '%Herb%')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of products from the 'Products' table that belong to a specific product category and have a typical buying price above a certain threshold. The placeholders in the WHERE clause represent the product category code and the minimum buying price.\",\n        \"virtual_table\": \"SELECT count(*) FROM products WHERE product_category_code  =  [PLACEHOLDER-TYPE:STRING] AND typical_buying_price  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5586", "db_id": "products_gen_characteristics", "question": "Find the unit of measurement and product category code of product named \"chervil\".", "rationale": ["Identify the relevant tables: We need to retrieve the unit of measurement and product category code for a specific product, which involves the 'Products' and 'Ref_Product_Categories' tables.", "Determine the necessary columns: We need 'unit_of_measure' from 'Ref_Product_Categories' and 'product_category_code' from the same table.", "Establish the relationship: The 'Products' table has a foreign key 'product_category_code' that links to 'Ref_Product_Categories'.", "Filter the results: We need to filter the products to find the one named 'chervil'.", "Construct the SQL query: Using a JOIN to connect 'Products' and 'Ref_Product_Categories' on 'product_category_code', and applying a WHERE clause to filter by product name."], "gold_sql": "SELECT t2.unit_of_measure ,  t2.product_category_code FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code WHERE t1.product_name  =  'chervil'", "source_tables": ["products", "ref_product_categories"], "pred_sql": "SELECT Ref_Product_Categories.unit_of_measure, Ref_Product_Categories.product_category_code \nFROM Products \nJOIN Ref_Product_Categories ON Products.product_category_code = Ref_Product_Categories.product_category_code \nWHERE Products.product_name = 'chervil';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of products from the 'Products' table that belong to a specific product category and have a typical buying price above a certain threshold. The placeholders in the WHERE clause represent the product category code and the minimum buying price.\",\n        \"virtual_table\": \"SELECT count(*) FROM products WHERE product_category_code  =  [PLACEHOLDER-TYPE:STRING] AND typical_buying_price  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5589", "db_id": "products_gen_characteristics", "question": "What are the names of products that are not 'white' in color and are not measured by the unit 'Handful'?", "rationale": ["Identify the relevant tables: Products, Ref_Colors, and Ref_Product_Categories.", "We need to select the product names from the Products table.", "Filter out products that are 'white' in color. This requires a subquery to get the color_code for 'white' from the Ref_Colors table.", "Also, filter out products that are measured by the unit 'Handful'. This requires another subquery to get the product_category_code for 'Handful' from the Ref_Product_Categories table.", "Combine these conditions in the WHERE clause using the NOT EQUAL operator (!=) for both filters."], "gold_sql": "SELECT t1.product_name FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code JOIN ref_colors AS t3 ON t1.color_code  =  t3.color_code WHERE t3.color_description  =  'white' AND t2.unit_of_measure != 'Handful'", "source_tables": ["products", "ref_colors", "ref_product_categories"], "pred_sql": "SELECT product_name \nFROM Products \nWHERE color_code != (SELECT color_code FROM Ref_Colors WHERE color_description = 'white') \nAND product_category_code != (SELECT product_category_code FROM Ref_Product_Categories WHERE unit_of_measure = 'Handful');", "hint": "\n"}
{"sample_id": "train.5592", "db_id": "products_gen_characteristics", "question": "What is the description of the color used by least products?", "rationale": ["We need to find the description of the color used by the least number of products.", "To do this, we will join the 'Ref_Colors' table with the 'Products' table on the 'color_code'.", "Next, we will group the results by 'color_code' to count how many products are associated with each color.", "We will then order the results in ascending order based on the count of products, so that the color with the least products comes first.", "Finally, we will limit the results to just one entry to get the color description used by the least products."], "gold_sql": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) ASC LIMIT 1", "source_tables": ["products", "ref_colors"], "pred_sql": "SELECT rc.color_description\nFROM Ref_Colors rc\nJOIN Products p ON rc.color_code = p.color_code\nGROUP BY rc.color_code\nORDER BY COUNT(p.product_id) ASC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of products from the 'Products' table that belong to a specific product category and have a typical buying price above a certain threshold. The placeholders in the WHERE clause represent the product category code and the minimum buying price.\",\n        \"virtual_table\": \"SELECT count(*) FROM products WHERE product_category_code  =  [PLACEHOLDER-TYPE:STRING] AND typical_buying_price  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5599", "db_id": "products_gen_characteristics", "question": "Give the names of characteristics that are in two or more products?", "rationale": ["We need to find the names of characteristics that are associated with two or more products.", "To do this, we will join the 'Characteristics' table with the 'Product_Characteristics' table on the characteristic_id.", "Next, we will group the results by characteristic_name to aggregate the data for each characteristic.", "We will use the HAVING clause to filter the groups, ensuring that we only include those characteristics that are linked to two or more distinct products (using COUNT(DISTINCT Product_Characteristics.product_id))."], "gold_sql": "SELECT t3.characteristic_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id GROUP BY t3.characteristic_name HAVING count(*)  >= 2", "source_tables": ["products", "characteristics", "product_characteristics"], "pred_sql": "SELECT characteristic_name \nFROM Characteristics \nJOIN Product_Characteristics ON Characteristics.characteristic_id = Product_Characteristics.characteristic_id \nGROUP BY characteristic_name \nHAVING COUNT(DISTINCT Product_Characteristics.product_id) >= 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique characteristic names from the 'Characteristics' table. The use of DISTINCT ensures that each characteristic name appears only once in the result set.\",\n        \"virtual_table\": \"SELECT DISTINCT characteristic_name FROM CHARACTERISTICS\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of products from the 'Products' table that belong to a specific product category and have a typical buying price above a certain threshold. The placeholders in the WHERE clause represent the product category code and the minimum buying price.\",\n        \"virtual_table\": \"SELECT count(*) FROM products WHERE product_category_code  =  [PLACEHOLDER-TYPE:STRING] AND typical_buying_price  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5669", "db_id": "dorm_1", "question": "What are the names of the all-female dorms?", "rationale": ["Identify the relevant table: The question asks for dorm names, so we need to look at the Dorm table.", "Determine the criteria: The question specifies 'all-female dorms', which indicates we need to filter by the gender column in the Dorm table.", "Construct the SQL query: We will select the dorm_name from the Dorm table where the gender is 'F' (for female)."], "gold_sql": "SELECT dorm_name FROM dorm WHERE gender  =  'F'", "source_tables": ["dorm"], "pred_sql": "SELECT dorm_name FROM Dorm WHERE gender = 'F'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the number of students and their average age, grouped by the city code, for a specific gender. The placeholder in the WHERE clause represents the gender of the students being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,  avg(age) ,  city_code FROM student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] GROUP BY city_code\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of last names of students from the 'Student' table based on specific criteria. It includes students of a certain gender residing in a specific city, as well as students of the same gender who are younger than a specified age. The placeholders in the WHERE clauses represent the gender, city code, and age criteria.\",\n        \"virtual_table\": \"SELECT lname FROM student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND city_code  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT lname FROM student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND age  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of last names of students from the 'Student' table based on specific criteria. It includes students of a certain gender residing in a specific city, as well as students of the same gender who are younger than a specified age. The placeholders in the WHERE clauses represent the gender, city code, and age criteria.\",\n        \"virtual_table\": \"SELECT lname FROM student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND city_code  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT lname FROM student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND age  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5688", "db_id": "dorm_1", "question": "Find the average and total capacity of dorms for the students with gender X.", "rationale": ["Identify the tables involved: Dorm, Lives_in, and Student.", "We need to calculate the total and average capacity of dorms, so we will use the 'student_capacity' column from the Dorm table.", "To find the relevant dorms, we need to join the Lives_in table to connect students to their dorms.", "We also need to join the Student table to filter by gender.", "The WHERE clause will filter students based on the specified gender 'X'.", "Finally, we will use SUM() to get the total capacity and AVG() to get the average capacity of the dorms."], "gold_sql": "SELECT avg(student_capacity) ,  sum(student_capacity) FROM dorm WHERE gender  =  'X'", "source_tables": ["dorm"], "pred_sql": "SELECT SUM(Dorm.student_capacity) AS total_capacity, AVG(Dorm.student_capacity) AS average_capacity \nFROM Dorm \nJOIN Lives_in ON Dorm.dormid = Lives_in.dormid \nJOIN Student ON Lives_in.stuid = Student.StuID \nWHERE Student.Sex = 'X';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the number of students and their average age, grouped by the city code, for a specific gender. The placeholder in the WHERE clause represents the gender of the students being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,  avg(age) ,  city_code FROM student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] GROUP BY city_code\"\n    }\n}\n"}
{"sample_id": "train.5699", "db_id": "dorm_1", "question": "What are the names and types of the dorms that have a capacity greater than 300 or less than 100?", "rationale": ["Identify the relevant table: The question pertains to dormitories, so we will use the Dorm table.", "Determine the columns needed: We need the names of the dorms (dorm_name) and their capacities (student_capacity).", "Formulate the condition: We need to filter dorms based on their capacity, specifically those with a capacity greater than 300 or less than 100.", "Construct the SQL query: Using the SELECT statement to retrieve the required columns from the Dorm table with the specified conditions in the WHERE clause."], "gold_sql": "SELECT dorm_name ,  gender FROM dorm WHERE student_capacity  >  300 OR student_capacity  <  100", "source_tables": ["dorm"], "pred_sql": "SELECT dorm_name, student_capacity \nFROM Dorm \nWHERE student_capacity > 300 OR student_capacity < 100;", "hint": "\n"}
{"sample_id": "train.5747", "db_id": "dorm_1", "question": "What are the total number of students who are living in a male dorm?", "rationale": ["Identify the tables involved: We need to find students living in male dorms, so we will use the Lives_in and Dorm tables.", "Determine the relationship: The Lives_in table links students to their dorms, and the Dorm table contains information about the dorms, including their gender designation.", "Filter for male dorms: We will filter the results to only include dorms where the gender is 'male'.", "Count the number of students: We will use the COUNT function to get the total number of students living in these male dorms."], "gold_sql": "SELECT count(*) FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T3.gender  =  'M'", "source_tables": ["student", "lives_in", "dorm"], "pred_sql": "SELECT COUNT(*) FROM Lives_in li JOIN Dorm d ON li.dormid = d.dormid WHERE d.gender = 'male';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the number of students and their average age, grouped by the city code, for a specific gender. The placeholder in the WHERE clause represents the gender of the students being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,  avg(age) ,  city_code FROM student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] GROUP BY city_code\"\n    }\n}\n"}
{"sample_id": "train.5755", "db_id": "dorm_1", "question": "What is the most common amenity in the dorms?", "rationale": ["To find the most common amenity in the dorms, we need to count the occurrences of each amenity.", "We will join the Dorm_amenity table with the Has_amenity table to link amenities to dorms.", "Next, we will join the resulting table with the Dorm table to ensure we are counting amenities associated with dorms.", "We will group the results by amenity name to count how many times each amenity appears.", "Finally, we will order the results in descending order based on the count and limit the output to the top result to get the most common amenity."], "gold_sql": "SELECT T1.amenity_name FROM dorm_amenity AS T1 JOIN has_amenity AS T2 ON T1.amenid  =  T2.amenid GROUP BY T2.amenid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["has_amenity", "dorm_amenity"], "pred_sql": "SELECT amenity_name, COUNT(*) as amenity_count \nFROM Dorm_amenity \nJOIN Has_amenity ON Dorm_amenity.amenid = Has_amenity.amenid \nJOIN Dorm ON Has_amenity.dormid = Dorm.dormid \nGROUP BY amenity_name \nORDER BY amenity_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the number of students and their average age, grouped by the city code, for a specific gender. The placeholder in the WHERE clause represents the gender of the students being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,  avg(age) ,  city_code FROM student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] GROUP BY city_code\"\n    }\n}\n"}
{"sample_id": "train.5757", "db_id": "dorm_1", "question": "What are the first names of all students who live in the dorm with the most amenities?", "rationale": ["Identify the dormitory with the most amenities by counting the number of amenities for each dormitory using the Has_amenity table.", "Use a subquery to select the dormid of the dormitory that has the maximum count of amenities, ordering the results in descending order and limiting to the top result.", "Select the student IDs (stuid) from the Lives_in table where the dormid matches the dormitory identified in the previous step.", "Finally, select the first names (Fname) of students from the Student table whose IDs are in the list obtained from the Lives_in table."], "gold_sql": "SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["has_amenity", "lives_in", "student", "dorm_amenity", "dorm"], "pred_sql": "SELECT Fname FROM Student WHERE StuID IN (SELECT stuid FROM Lives_in WHERE dormid IN (SELECT dormid FROM Has_amenity GROUP BY dormid ORDER BY COUNT(amenid) DESC LIMIT 1));", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of last names of students from the 'Student' table based on specific criteria. It includes students of a certain gender residing in a specific city, as well as students of the same gender who are younger than a specified age. The placeholders in the WHERE clauses represent the gender, city code, and age criteria.\",\n        \"virtual_table\": \"SELECT lname FROM student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND city_code  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT lname FROM student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND age  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of last names of students from the 'Student' table based on specific criteria. It includes students of a certain gender residing in a specific city, as well as students of the same gender who are younger than a specified age. The placeholders in the WHERE clauses represent the gender, city code, and age criteria.\",\n        \"virtual_table\": \"SELECT lname FROM student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND city_code  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT lname FROM student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND age  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5776", "db_id": "customer_complaints", "question": "Find the emails of customers who has filed a complaints of the product with the most complaints.", "rationale": ["Identify the main goal: Find the emails of customers who have filed complaints about the product with the most complaints.", "To achieve this, we need to join the Customers table with the Complaints table on the customer_id.", "Next, we need to determine which product has the most complaints. This can be done by grouping the Complaints table by product_id and counting the number of complaints for each product.", "We will order the results of this count in descending order and limit the results to 1 to get the product with the most complaints.", "Finally, we will use the product_id obtained from the subquery to filter the customers who complained about that product and select their email addresses."], "gold_sql": "SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "customers"], "pred_sql": "SELECT c.email_address \nFROM Customers c \nJOIN Complaints cmp ON c.customer_id = cmp.customer_id \nWHERE cmp.product_id = (\n    SELECT product_id \n    FROM Complaints \n    GROUP BY product_id \n    ORDER BY COUNT(*) DESC \n    LIMIT 1\n)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table summarizes the different complaint status codes from the 'Complaints' table, specifically focusing on those status codes that have a count exceeding a specified number. The placeholder in the HAVING clause represents the minimum count of complaints required for a status code to be included in the results.\",\n        \"virtual_table\": \"SELECT complaint_status_code FROM complaints GROUP BY complaint_status_code HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of customers grouped by their type, allowing for an analysis of the distribution of different customer types. The placeholder in the LIMIT clause represents the maximum number of customer types to display, enabling users to specify how many top customer types they wish to see.\",\n        \"virtual_table\": \"SELECT count(*) FROM customers GROUP BY customer_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5777", "db_id": "customer_complaints", "question": "What are the emails of customers who have filed complaints on the product which has had the greatest number of complaints?", "rationale": ["Identify the main goal: Retrieve the emails of customers who have filed complaints on the product with the greatest number of complaints.", "To find the product with the greatest number of complaints, a subquery is needed that counts complaints grouped by product_id and orders them in descending order, limiting the result to the top product.", "Join the Customers table with the Complaints table on customer_id to access customer emails related to complaints.", "Filter the results to only include complaints for the product identified in the subquery.", "Select the email_address from the Customers table for the filtered results."], "gold_sql": "SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "customers"], "pred_sql": "SELECT c.email_address \nFROM Customers c \nJOIN Complaints cmp ON c.customer_id = cmp.customer_id \nWHERE cmp.product_id = (\n    SELECT product_id \n    FROM Complaints \n    GROUP BY product_id \n    ORDER BY COUNT(*) DESC \n    LIMIT 1\n)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table summarizes the different complaint status codes from the 'Complaints' table, specifically focusing on those status codes that have a count exceeding a specified number. The placeholder in the HAVING clause represents the minimum count of complaints required for a status code to be included in the results.\",\n        \"virtual_table\": \"SELECT complaint_status_code FROM complaints GROUP BY complaint_status_code HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of customers grouped by their type, allowing for an analysis of the distribution of different customer types. The placeholder in the LIMIT clause represents the maximum number of customer types to display, enabling users to specify how many top customer types they wish to see.\",\n        \"virtual_table\": \"SELECT count(*) FROM customers GROUP BY customer_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5779", "db_id": "customer_complaints", "question": "Return the names of products that have had complaints filed by the customer who has filed the fewest complaints.", "rationale": ["Identify the main goal: to return the names of products that have had complaints filed by the customer who has filed the fewest complaints.", "To find the customer who has filed the fewest complaints, we need to group the complaints by customer_id and count the number of complaints for each customer.", "We will use a subquery to select the customer_id of the customer with the minimum count of complaints. This is done by ordering the counts in ascending order and limiting the result to 1.", "Next, we need to join the Products table with the Complaints table to get the product names associated with the complaints.", "The final query will select the product names from the Products table where the customer_id matches the one found in the subquery."], "gold_sql": "SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "products", "customers"], "pred_sql": "SELECT p.product_name \nFROM Products p \nJOIN Complaints c ON p.product_id = c.product_id \nWHERE c.customer_id = (\n    SELECT customer_id \n    FROM Complaints \n    GROUP BY customer_id \n    ORDER BY COUNT(*) ASC \n    LIMIT 1\n)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table summarizes the different complaint status codes from the 'Complaints' table, specifically focusing on those status codes that have a count exceeding a specified number. The placeholder in the HAVING clause represents the minimum count of complaints required for a status code to be included in the results.\",\n        \"virtual_table\": \"SELECT complaint_status_code FROM complaints GROUP BY complaint_status_code HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5795", "db_id": "customer_complaints", "question": "What is the last name of the staff member in charge of the complaint on the product with the lowest price?", "rationale": ["Identify the relevant tables: Complaints, Products, and Staff.", "We need to find the staff member in charge of a complaint related to the product with the lowest price.", "To do this, we will join the Complaints table with the Products table on product_id to access product details, and then join with the Staff table on staff_id to get staff details.", "We need to filter the results to only include the product with the lowest price. This can be done using a subquery that selects the minimum product price from the Products table.", "Finally, we select the last name of the staff member from the Staff table."], "gold_sql": "SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT 1", "source_tables": ["complaints", "products", "staff"], "pred_sql": "SELECT Staff.last_name \nFROM Complaints \nJOIN Products ON Complaints.product_id = Products.product_id \nJOIN Staff ON Complaints.staff_id = Staff.staff_id \nWHERE Products.product_price = (\n    SELECT MIN(product_price) \n    FROM Products\n);", "hint": "\n"}
{"sample_id": "train.5800", "db_id": "customer_complaints", "question": "How many customers are there in the customer type with the most customers?", "rationale": ["Identify the need to count customers based on their type.", "Use the COUNT() function to count the number of customers for each customer type.", "Group the results by 'customer_type_code' to get the count for each type.", "Order the results in descending order to find the type with the most customers.", "Limit the results to 1 to get only the customer type with the highest count."], "gold_sql": "SELECT count(*) FROM customers GROUP BY customer_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers"], "pred_sql": "SELECT customer_type_code, COUNT(*) as customer_count FROM Customers GROUP BY customer_type_code ORDER BY customer_count DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of customers grouped by their type, allowing for an analysis of the distribution of different customer types. The placeholder in the LIMIT clause represents the maximum number of customer types to display, enabling users to specify how many top customer types they wish to see.\",\n        \"virtual_table\": \"SELECT count(*) FROM customers GROUP BY customer_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique town or city names from the 'Customers' table, filtered by a specific customer type code. The results are grouped by town or city and ordered by the number of occurrences, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the customer type code and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT town_city FROM customers WHERE customer_type_code  =  [PLACEHOLDER-TYPE:STRING] GROUP BY town_city ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5810", "db_id": "customer_complaints", "question": "What is first names of the top 5 staff who have handled the greatest number of complaints?", "rationale": ["Identify the relevant tables: Staff and Complaints.", "We need to find the first names of staff members, so we will select the 'first_name' column from the Staff table.", "To determine how many complaints each staff member has handled, we will join the Staff table with the Complaints table on the 'staff_id' column.", "We will group the results by 'staff_id' to aggregate the number of complaints handled by each staff member.", "We will use the COUNT function to count the number of complaints for each staff member.", "To get the top 5 staff members who handled the greatest number of complaints, we will order the results in descending order based on the count of complaints and limit the results to 5."], "gold_sql": "SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT 5", "source_tables": ["complaints", "staff"], "pred_sql": "SELECT first_name \nFROM Staff \nJOIN Complaints ON Staff.staff_id = Complaints.staff_id \nGROUP BY Staff.staff_id \nORDER BY COUNT(Complaints.complaint_id) DESC \nLIMIT 5;", "hint": "\n"}
{"sample_id": "train.5812", "db_id": "customer_complaints", "question": "Which state has the most customers?", "rationale": ["Identify the relevant table: The question asks about customers, so we will focus on the Customers table.", "Determine the required information: We need to find out which state has the most customers, which implies counting the number of customers per state.", "Use the COUNT function: We will count the number of customers in each state using COUNT(*).", "Group the results: We will group the results by the 'state' column to get the count of customers in each state.", "Order the results: To find the state with the most customers, we will order the results in descending order based on the count of customers.", "Limit the results: Since we only want the state with the most customers, we will limit the results to 1."], "gold_sql": "SELECT state FROM customers GROUP BY state ORDER BY count(*) LIMIT 1", "source_tables": ["customers"], "pred_sql": "SELECT state, COUNT(*) as customer_count FROM Customers GROUP BY state ORDER BY customer_count DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of customers grouped by their type, allowing for an analysis of the distribution of different customer types. The placeholder in the LIMIT clause represents the maximum number of customer types to display, enabling users to specify how many top customer types they wish to see.\",\n        \"virtual_table\": \"SELECT count(*) FROM customers GROUP BY customer_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique town or city names from the 'Customers' table, filtered by a specific customer type code. The results are grouped by town or city and ordered by the number of occurrences, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the customer type code and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT town_city FROM customers WHERE customer_type_code  =  [PLACEHOLDER-TYPE:STRING] GROUP BY town_city ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5813", "db_id": "customer_complaints", "question": "Give the state that has the most customers.", "rationale": ["Identify the relevant table: The question asks for information about customers, so we will use the Customers table.", "Determine the required information: We need to find the state with the most customers, which means we need to count the number of customers in each state.", "Group the results: To count the customers by state, we will use the GROUP BY clause on the 'state' column.", "Order the results: To find the state with the most customers, we will order the results in descending order based on the count of customers.", "Limit the results: Since we only want the state with the most customers, we will use the LIMIT clause to restrict the output to 1."], "gold_sql": "SELECT state FROM customers GROUP BY state ORDER BY count(*) LIMIT 1", "source_tables": ["customers"], "pred_sql": "SELECT state, COUNT(*) as customer_count FROM Customers GROUP BY state ORDER BY customer_count DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of customers grouped by their type, allowing for an analysis of the distribution of different customer types. The placeholder in the LIMIT clause represents the maximum number of customer types to display, enabling users to specify how many top customer types they wish to see.\",\n        \"virtual_table\": \"SELECT count(*) FROM customers GROUP BY customer_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique town or city names from the 'Customers' table, filtered by a specific customer type code. The results are grouped by town or city and ordered by the number of occurrences, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the customer type code and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT town_city FROM customers WHERE customer_type_code  =  [PLACEHOLDER-TYPE:STRING] GROUP BY town_city ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5865", "db_id": "tracking_share_transactions", "question": "What are the lot details of lots associated with transactions whose share count is bigger than 100 and whose type code is \"PUR\"?", "rationale": ["Identify the tables involved: We need to get lot details, which are in the 'Lots' table, and we need to filter based on transactions, which are in the 'Transactions' table.", "Determine the relationship between tables: The 'Lots' table is linked to the 'Transactions' table through the 'Transactions_Lots' table. We will need to join these tables to access the required data.", "Set the conditions for filtering: We need to filter transactions where the share count is greater than 100 and the transaction type code is 'PUR'.", "Construct the SQL query: Start with selecting the lot details from the 'Lots' table, then join with 'Transactions_Lots' and 'Transactions' tables, applying the necessary filters in the WHERE clause."], "gold_sql": "SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON  T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  >  100 AND T3.transaction_type_code  =  'PUR'", "source_tables": ["lots", "transactions_lots", "transactions"], "pred_sql": "SELECT Lots.lot_details \nFROM Lots \nJOIN Transactions_Lots ON Lots.lot_id = Transactions_Lots.lot_id \nJOIN Transactions ON Transactions_Lots.transaction_id = Transactions.transaction_id \nWHERE Transactions.share_count > 100 \nAND Transactions.transaction_type_code = 'PUR';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the maximum and minimum share counts for each type of transaction recorded in the 'Transactions' table. The placeholder in the SELECT clause represents the transaction type code, while the aggregation functions calculate the maximum and minimum share counts for each group of transaction types.\",\n        \"virtual_table\": \"SELECT transaction_type_code ,  max(share_count) ,  min(share_count) FROM TRANSACTIONS GROUP BY transaction_type_code\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the dates of transactions from the 'Transactions' table that correspond to a specific type of transaction. The placeholder in the WHERE clause represents the transaction type code.\",\n        \"virtual_table\": \"SELECT date_of_transaction FROM TRANSACTIONS WHERE transaction_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5866", "db_id": "tracking_share_transactions", "question": "Show the average transaction amount for different transaction types.", "rationale": ["Identify the tables involved: We need to get transaction amounts and their types, so we will use the Transactions and Ref_Transaction_Types tables.", "Determine the necessary columns: We need the transaction type code from Ref_Transaction_Types and the amount of transaction from Transactions.", "Join the tables: We will join Transactions with Ref_Transaction_Types on the transaction_type_code to relate transaction amounts to their types.", "Use aggregation: We will use the AVG() function to calculate the average transaction amount for each transaction type.", "Group the results: We will group the results by transaction_type_code to get the average for each type."], "gold_sql": "SELECT transaction_type_code ,  avg(amount_of_transaction) FROM TRANSACTIONS GROUP BY transaction_type_code", "source_tables": ["transactions"], "pred_sql": "SELECT Ref_Transaction_Types.transaction_type_code, AVG(Transactions.amount_of_transaction) AS average_transaction_amount\nFROM Transactions\nJOIN Ref_Transaction_Types ON Transactions.transaction_type_code = Ref_Transaction_Types.transaction_type_code\nGROUP BY Ref_Transaction_Types.transaction_type_code;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the maximum and minimum share counts for each type of transaction recorded in the 'Transactions' table. The placeholder in the SELECT clause represents the transaction type code, while the aggregation functions calculate the maximum and minimum share counts for each group of transaction types.\",\n        \"virtual_table\": \"SELECT transaction_type_code ,  max(share_count) ,  min(share_count) FROM TRANSACTIONS GROUP BY transaction_type_code\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the dates of transactions from the 'Transactions' table that correspond to a specific type of transaction. The placeholder in the WHERE clause represents the transaction type code.\",\n        \"virtual_table\": \"SELECT date_of_transaction FROM TRANSACTIONS WHERE transaction_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5873", "db_id": "tracking_share_transactions", "question": "Show the number of transactions with transaction type code \"SALE\" for different investors if it is larger than 0.", "rationale": ["We need to count the number of transactions for each investor where the transaction type code is 'SALE'.", "To do this, we will join the 'Investors' table with the 'Transactions' table on the 'investor_id'.", "We will filter the transactions to only include those with the transaction type code 'SALE'.", "We will group the results by 'investor_id' to get the count of transactions for each investor.", "Finally, we will use the HAVING clause to filter out any investors with a transaction count of 0."], "gold_sql": "SELECT investor_id ,  COUNT(*) FROM TRANSACTIONS WHERE transaction_type_code  =  'SALE' GROUP BY investor_id", "source_tables": ["transactions"], "pred_sql": "SELECT Investors.investor_id, COUNT(Transactions.transaction_id) AS transaction_count \nFROM Investors \nJOIN Transactions ON Investors.investor_id = Transactions.investor_id \nWHERE Transactions.transaction_type_code = 'SALE' \nGROUP BY Investors.investor_id \nHAVING transaction_count > 0;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the maximum and minimum share counts for each type of transaction recorded in the 'Transactions' table. The placeholder in the SELECT clause represents the transaction type code, while the aggregation functions calculate the maximum and minimum share counts for each group of transaction types.\",\n        \"virtual_table\": \"SELECT transaction_type_code ,  max(share_count) ,  min(share_count) FROM TRANSACTIONS GROUP BY transaction_type_code\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the dates of transactions from the 'Transactions' table that correspond to a specific type of transaction. The placeholder in the WHERE clause represents the transaction type code.\",\n        \"virtual_table\": \"SELECT date_of_transaction FROM TRANSACTIONS WHERE transaction_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides detailed information about investors from the 'Investors' table. The query selects the 'Investor_details' column, which contains specific information regarding each investor.\",\n        \"virtual_table\": \"SELECT Investor_details FROM INVESTORS\"\n    }\n}\n"}
{"sample_id": "train.5876", "db_id": "tracking_share_transactions", "question": "Show the transaction type code that occurs the most frequently.", "rationale": ["To find the transaction type code that occurs the most frequently, we need to count the occurrences of each transaction type code in the Transactions table.", "We will use the COUNT() function to count the number of transactions for each transaction type code.", "We will group the results by transaction_type_code using GROUP BY to aggregate the counts for each type.", "To get the most frequent transaction type code, we will order the results in descending order of frequency using ORDER BY frequency DESC.", "Finally, we will limit the results to only the top result using LIMIT 1."], "gold_sql": "SELECT transaction_type_code FROM TRANSACTIONS GROUP BY transaction_type_code ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["transactions"], "pred_sql": "SELECT transaction_type_code, COUNT(*) as frequency FROM Transactions GROUP BY transaction_type_code ORDER BY frequency DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates of transactions from the 'Transactions' table that correspond to a specific type of transaction. The placeholder in the WHERE clause represents the transaction type code.\",\n        \"virtual_table\": \"SELECT date_of_transaction FROM TRANSACTIONS WHERE transaction_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the maximum and minimum share counts for each type of transaction recorded in the 'Transactions' table. The placeholder in the SELECT clause represents the transaction type code, while the aggregation functions calculate the maximum and minimum share counts for each group of transaction types.\",\n        \"virtual_table\": \"SELECT transaction_type_code ,  max(share_count) ,  min(share_count) FROM TRANSACTIONS GROUP BY transaction_type_code\"\n    }\n}\n"}
{"sample_id": "train.5884", "db_id": "tracking_share_transactions", "question": "What are the details of the lots which are not used in any transactions?", "rationale": ["Identify the main goal: We need to find details of lots that are not used in any transactions.", "Understand the schema: The Lots table contains the details of the lots, and the Transactions_Lots table links transactions to lots.", "To find lots not used in any transactions, we can use a subquery that selects all lot_ids from the Transactions_Lots table.", "The main query will select all columns from the Lots table where the lot_id is not in the list of lot_ids returned by the subquery."], "gold_sql": "SELECT lot_details FROM Lots EXCEPT SELECT T1.lot_details FROM Lots AS T1 JOIN transactions_lots AS T2 ON T1.lot_id  =  T2.lot_id", "source_tables": ["lots", "transactions_lots"], "pred_sql": "SELECT * FROM Lots WHERE lot_id NOT IN (SELECT lot_id FROM Transactions_Lots)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the maximum and minimum share counts for each type of transaction recorded in the 'Transactions' table. The placeholder in the SELECT clause represents the transaction type code, while the aggregation functions calculate the maximum and minimum share counts for each group of transaction types.\",\n        \"virtual_table\": \"SELECT transaction_type_code ,  max(share_count) ,  min(share_count) FROM TRANSACTIONS GROUP BY transaction_type_code\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the dates of transactions from the 'Transactions' table that correspond to a specific type of transaction. The placeholder in the WHERE clause represents the transaction type code.\",\n        \"virtual_table\": \"SELECT date_of_transaction FROM TRANSACTIONS WHERE transaction_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5893", "db_id": "cre_Theme_park", "question": "Show details of all visitors.", "rationale": ["The user wants to show details of all visitors, which corresponds to retrieving all records from the Visitors table.", "To achieve this, we will use a SELECT statement to select all columns from the Visitors table.", "The SQL query will be 'SELECT * FROM Visitors;' which retrieves all details of the visitors."], "gold_sql": "SELECT Tourist_Details FROM VISITORS", "source_tables": ["visitors"], "pred_sql": "SELECT * FROM Visitors;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides details about tourists from the 'Visitors' table. The placeholder in the SELECT clause represents the specific details related to each tourist.\",\n        \"virtual_table\": \"SELECT Tourist_Details FROM VISITORS\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides additional details about hotels from the 'Hotels' table, sorted by their price range in descending order. The placeholder in the LIMIT clause represents the maximum number of hotel details to retrieve.\",\n        \"virtual_table\": \"SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5901", "db_id": "cre_Theme_park", "question": "What is the detail of the location UK Gallery?", "rationale": ["Identify the table that contains location details, which is the 'Locations' table.", "Determine the columns needed: 'Address' and 'Other_Details' for the location details.", "Use a WHERE clause to filter the results to only include the location named 'UK Gallery'."], "gold_sql": "SELECT Other_Details FROM LOCATIONS WHERE Location_Name  =  'UK Gallery'", "source_tables": ["locations"], "pred_sql": "SELECT Address, Other_Details FROM Locations WHERE Location_Name = 'UK Gallery'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides details about tourists from the 'Visitors' table. The placeholder in the SELECT clause represents the specific details related to each tourist.\",\n        \"virtual_table\": \"SELECT Tourist_Details FROM VISITORS\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of location names from the 'Locations' table that match a specific pattern. The placeholder in the WHERE clause allows for flexible searching of location names based on user input.\",\n        \"virtual_table\": \"SELECT Location_Name FROM LOCATIONS WHERE Location_Name LIKE [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides details about hotels, specifically their additional information and star rating codes. The results are ordered by the price range of the hotels in ascending order, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5902", "db_id": "cre_Theme_park", "question": "Return the detail of the location named \"UK Gallery\".", "rationale": ["Identify the table that contains location details, which is the 'Locations' table.", "Determine the specific column that holds the name of the location, which is 'Location_Name'.", "Formulate a SQL query to select all columns from the 'Locations' table where the 'Location_Name' matches 'UK Gallery'."], "gold_sql": "SELECT Other_Details FROM LOCATIONS WHERE Location_Name  =  'UK Gallery'", "source_tables": ["locations"], "pred_sql": "SELECT * FROM Locations WHERE Location_Name = 'UK Gallery';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides details about tourists from the 'Visitors' table. The placeholder in the SELECT clause represents the specific details related to each tourist.\",\n        \"virtual_table\": \"SELECT Tourist_Details FROM VISITORS\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides details about hotels, specifically their additional information and star rating codes. The results are ordered by the price range of the hotels in ascending order, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of location names from the 'Locations' table that match a specific pattern. The placeholder in the WHERE clause allows for flexible searching of location names based on user input.\",\n        \"virtual_table\": \"SELECT Location_Name FROM LOCATIONS WHERE Location_Name LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5914", "db_id": "cre_Theme_park", "question": "Give me the star rating descriptions of the hotels that cost more than 10000.", "rationale": ["Identify the relevant tables: We need to retrieve star rating descriptions from the Ref_Hotel_Star_Ratings table and filter hotels based on their price from the Hotels table.", "Determine the relationship between the tables: The Hotels table has a foreign key 'star_rating_code' that links to the Ref_Hotel_Star_Ratings table.", "Construct the SQL query: We will select the 'star_rating_description' from the Ref_Hotel_Star_Ratings table, joining it with the Hotels table on 'star_rating_code'.", "Add the condition to filter hotels with a price greater than 10000 in the WHERE clause."], "gold_sql": "SELECT T2.star_rating_description FROM HOTELS AS T1 JOIN Ref_Hotel_Star_Ratings AS T2 ON T1.star_rating_code  =  T2.star_rating_code WHERE T1.price_range  >  10000", "source_tables": ["ref_hotel_star_ratings", "hotels"], "pred_sql": "SELECT Ref_Hotel_Star_Ratings.star_rating_description \nFROM Hotels \nJOIN Ref_Hotel_Star_Ratings ON Hotels.star_rating_code = Ref_Hotel_Star_Ratings.star_rating_code \nWHERE Hotels.price_range > '10000';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides details about hotels, specifically their additional information and star rating codes. The results are ordered by the price range of the hotels in ascending order, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average price range of hotels from the 'Hotels' table that have a specific star rating and indicate whether pets are allowed. The placeholders in the WHERE clause represent the star rating code and the pets allowed status.\",\n        \"virtual_table\": \"SELECT avg(price_range) FROM HOTELS WHERE star_rating_code  =  [PLACEHOLDER-TYPE:STRING] AND pets_allowed_yn  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average price range of hotels from the 'Hotels' table that have a specific star rating and indicate whether pets are allowed. The placeholders in the WHERE clause represent the star rating code and the pets allowed status.\",\n        \"virtual_table\": \"SELECT avg(price_range) FROM HOTELS WHERE star_rating_code  =  [PLACEHOLDER-TYPE:STRING] AND pets_allowed_yn  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5915", "db_id": "cre_Theme_park", "question": "What are the details and opening hours of the museums?", "rationale": ["Identify the relevant table: Museums contains the details and opening hours of museums.", "Select the columns needed: Museum_Details and Opening_Hours are the required fields.", "Construct the SQL query using SELECT to retrieve the specified columns from the Museums table."], "gold_sql": "SELECT T1.Museum_Details ,  T2.Opening_Hours FROM MUSEUMS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Museum_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["tourist_attractions", "museums"], "pred_sql": "SELECT Museum_Details, Opening_Hours FROM Museums", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides details about tourists from the 'Visitors' table. The placeholder in the SELECT clause represents the specific details related to each tourist.\",\n        \"virtual_table\": \"SELECT Tourist_Details FROM VISITORS\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides details about hotels, specifically their additional information and star rating codes. The results are ordered by the price range of the hotels in ascending order, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides additional details about hotels from the 'Hotels' table, sorted by their price range in descending order. The placeholder in the LIMIT clause represents the maximum number of hotel details to retrieve.\",\n        \"virtual_table\": \"SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5922", "db_id": "cre_Theme_park", "question": "Which tourist attractions are related to royal family? Tell me their details and how we can get there.", "rationale": ["Identify the relevant tables: Tourist_Attractions and Royal_Family.", "Determine the relationship between the tables: Tourist_Attractions has a foreign key that links to Royal_Family.", "Select the desired columns: Name, Description, and How_to_Get_There from Tourist_Attractions.", "Construct the SQL query using a JOIN to combine the two tables based on their relationship."], "gold_sql": "SELECT T1.Royal_Family_Details ,  T2.How_to_Get_There FROM ROYAL_FAMILY AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Royal_Family_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["royal_family", "tourist_attractions"], "pred_sql": "SELECT ta.Name, ta.Description, ta.How_to_Get_There \nFROM Tourist_Attractions ta \nJOIN Royal_Family rf ON ta.Tourist_Attraction_ID = rf.Royal_Family_ID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides details about tourists from the 'Visitors' table. The placeholder in the SELECT clause represents the specific details related to each tourist.\",\n        \"virtual_table\": \"SELECT Tourist_Details FROM VISITORS\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides details about hotels, specifically their additional information and star rating codes. The results are ordered by the price range of the hotels in ascending order, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides additional details about hotels from the 'Hotels' table, sorted by their price range in descending order. The placeholder in the LIMIT clause represents the maximum number of hotel details to retrieve.\",\n        \"virtual_table\": \"SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5924", "db_id": "cre_Theme_park", "question": "Find the details of the shops that can be reached by walk.", "rationale": ["Identify the Shops table which contains the details of shops.", "Determine that we need to find shops that can be reached by walking.", "This requires checking the Tourist_Attractions table for attractions that have 'walk' in their 'How_to_Get_There' description.", "Use a subquery to select the Tourist_Attraction_IDs from the Tourist_Attractions table where the How_to_Get_There field contains 'walk'.", "Finally, select the Shop_Details from the Shops table where the Shop_ID matches the Tourist_Attraction_IDs from the subquery."], "gold_sql": "SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  'walk'", "source_tables": ["shops", "tourist_attractions"], "pred_sql": "SELECT Shop_Details FROM Shops WHERE Shop_ID IN (SELECT Tourist_Attraction_ID FROM Tourist_Attractions WHERE How_to_Get_There LIKE '%walk%')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides details about hotels, specifically their additional information and star rating codes. The results are ordered by the price range of the hotels in ascending order, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides additional details about hotels from the 'Hotels' table, sorted by their price range in descending order. The placeholder in the LIMIT clause represents the maximum number of hotel details to retrieve.\",\n        \"virtual_table\": \"SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides details about tourists from the 'Visitors' table. The placeholder in the SELECT clause represents the specific details related to each tourist.\",\n        \"virtual_table\": \"SELECT Tourist_Details FROM VISITORS\"\n    }\n}\n"}
{"sample_id": "train.5927", "db_id": "cre_Theme_park", "question": "What are the details of the markets that can be accessed by walk or bus?", "rationale": ["Identify the relevant table for street markets, which is 'Street_Markets'.", "Determine the column that contains the details of the markets, which is 'Market_Details'.", "Identify the relationship between street markets and tourist attractions, which is through the 'Tourist_Attraction_ID'.", "Find the 'Tourist_Attractions' table to check how to get to the attractions, specifically looking for those that can be accessed by 'walk' or 'bus'.", "Use a subquery to filter 'Tourist_Attraction_ID' from 'Tourist_Attractions' where 'How_to_Get_There' contains 'walk' or 'bus'.", "Combine the results to get the details of the markets that can be accessed by walk or bus."], "gold_sql": "SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  'walk' OR  T2.How_to_Get_There  =  'bus'", "source_tables": ["street_markets", "tourist_attractions"], "pred_sql": "SELECT Market_Details FROM Street_Markets WHERE Market_ID IN (SELECT Tourist_Attraction_ID FROM Tourist_Attractions WHERE How_to_Get_There LIKE '%walk%' OR How_to_Get_There LIKE '%bus%')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides details about hotels, specifically their additional information and star rating codes. The results are ordered by the price range of the hotels in ascending order, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides details about tourists from the 'Visitors' table. The placeholder in the SELECT clause represents the specific details related to each tourist.\",\n        \"virtual_table\": \"SELECT Tourist_Details FROM VISITORS\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides additional details about hotels from the 'Hotels' table, sorted by their price range in descending order. The placeholder in the LIMIT clause represents the maximum number of hotel details to retrieve.\",\n        \"virtual_table\": \"SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5928", "db_id": "cre_Theme_park", "question": "Find the details of all the markets that are accessible by walk or bus.", "rationale": ["Identify the relevant table for street markets, which is 'Street_Markets'.", "Determine the column that contains the details of the markets, which is 'Market_Details'.", "Identify the relationship between street markets and tourist attractions, which is through the 'Tourist_Attraction_ID'.", "Find the 'Tourist_Attraction_ID' from the 'Tourist_Attractions' table where the 'How_to_Get_There' column indicates accessibility by walk or bus.", "Use a subquery to filter the 'Market_ID' in the 'Street_Markets' table based on the results from the 'Tourist_Attractions' table."], "gold_sql": "SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  'walk' OR  T2.How_to_Get_There  =  'bus'", "source_tables": ["street_markets", "tourist_attractions"], "pred_sql": "SELECT Market_Details FROM Street_Markets WHERE Market_ID IN (SELECT Tourist_Attraction_ID FROM Tourist_Attractions WHERE How_to_Get_There LIKE '%walk%' OR How_to_Get_There LIKE '%bus%')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides details about hotels, specifically their additional information and star rating codes. The results are ordered by the price range of the hotels in ascending order, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides details about tourists from the 'Visitors' table. The placeholder in the SELECT clause represents the specific details related to each tourist.\",\n        \"virtual_table\": \"SELECT Tourist_Details FROM VISITORS\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides additional details about hotels from the 'Hotels' table, sorted by their price range in descending order. The placeholder in the LIMIT clause represents the maximum number of hotel details to retrieve.\",\n        \"virtual_table\": \"SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5942", "db_id": "cre_Theme_park", "question": "What are the details of the three most expensive hotels?", "rationale": ["Identify the table that contains hotel details, which is the 'Hotels' table.", "Determine the columns needed: 'other_hotel_details' for additional information and 'star_rating_code' for the star rating.", "To find the most expensive hotels, order the results by 'price_range' in descending order.", "Limit the results to the top three entries to get the three most expensive hotels."], "gold_sql": "SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT 3", "source_tables": ["hotels"], "pred_sql": "SELECT other_hotel_details, star_rating_code FROM Hotels ORDER BY price_range DESC LIMIT 3", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides details about hotels, specifically their additional information and star rating codes. The results are ordered by the price range of the hotels in ascending order, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides additional details about hotels from the 'Hotels' table, sorted by their price range in descending order. The placeholder in the LIMIT clause represents the maximum number of hotel details to retrieve.\",\n        \"virtual_table\": \"SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average price range of hotels from the 'Hotels' table that have a specific star rating and indicate whether pets are allowed. The placeholders in the WHERE clause represent the star rating code and the pets allowed status.\",\n        \"virtual_table\": \"SELECT avg(price_range) FROM HOTELS WHERE star_rating_code  =  [PLACEHOLDER-TYPE:STRING] AND pets_allowed_yn  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5943", "db_id": "cre_Theme_park", "question": "Show the details and star ratings of the 3 least expensive hotels.", "rationale": ["Identify the required information: details and star ratings of the least expensive hotels.", "Determine the relevant table: the Hotels table contains the necessary columns for hotel details and star ratings.", "Use the ORDER BY clause to sort the hotels by price range in ascending order to find the least expensive ones.", "Limit the results to 3 to get only the three least expensive hotels."], "gold_sql": "SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT 3", "source_tables": ["hotels"], "pred_sql": "SELECT other_hotel_details, star_rating_code FROM Hotels ORDER BY price_range ASC LIMIT 3", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides details about hotels, specifically their additional information and star rating codes. The results are ordered by the price range of the hotels in ascending order, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average price range of hotels from the 'Hotels' table that have a specific star rating and indicate whether pets are allowed. The placeholders in the WHERE clause represent the star rating code and the pets allowed status.\",\n        \"virtual_table\": \"SELECT avg(price_range) FROM HOTELS WHERE star_rating_code  =  [PLACEHOLDER-TYPE:STRING] AND pets_allowed_yn  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average price range of hotels from the 'Hotels' table that have a specific star rating and indicate whether pets are allowed. The placeholders in the WHERE clause represent the star rating code and the pets allowed status.\",\n        \"virtual_table\": \"SELECT avg(price_range) FROM HOTELS WHERE star_rating_code  =  [PLACEHOLDER-TYPE:STRING] AND pets_allowed_yn  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5945", "db_id": "cre_Theme_park", "question": "Show the transportation method most people choose to get to tourist attractions.", "rationale": ["Identify the relevant tables: We need to find out how tourists get to attractions, which involves the Tourist_Attractions and Visits tables.", "Determine the necessary columns: We need the 'How_to_Get_There' column from the Tourist_Attractions table to understand the transportation methods.", "Count the number of visits for each transportation method: We will use COUNT(*) to count how many times each method was used, linking the Visits table to the Tourist_Attractions table.", "Group the results by transportation method: We will use GROUP BY on the 'How_to_Get_There' column to aggregate the counts for each method.", "Order the results to find the most popular method: We will order the results in descending order based on the count of visits.", "Limit the results to the top entry: We will use LIMIT 1 to get the most chosen transportation method."], "gold_sql": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["tourist_attractions"], "pred_sql": "SELECT How_to_Get_There, COUNT(*) as Number_of_Visits \nFROM Tourist_Attractions \nJOIN Visits ON Tourist_Attractions.Tourist_Attraction_ID = Visits.Tourist_Attraction_ID \nGROUP BY How_to_Get_There \nORDER BY Number_of_Visits DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides details about tourists from the 'Visitors' table. The placeholder in the SELECT clause represents the specific details related to each tourist.\",\n        \"virtual_table\": \"SELECT Tourist_Details FROM VISITORS\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides details about hotels, specifically their additional information and star rating codes. The results are ordered by the price range of the hotels in ascending order, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5946", "db_id": "cre_Theme_park", "question": "Which transportation method is used the most often to get to tourist attractions?", "rationale": ["Identify the relevant table: The question pertains to transportation methods used to get to tourist attractions, which suggests we need to look at the 'Tourist_Attractions' table.", "Determine the relevant column: The 'How_to_Get_There' column in the 'Tourist_Attractions' table likely contains the transportation methods used to reach the attractions.", "Count occurrences: We need to count how many times each transportation method is mentioned, which can be done using the COUNT() function.", "Group by transportation method: To get the count for each method, we will use GROUP BY on the 'How_to_Get_There' column.", "Order by usage: To find the most used transportation method, we will order the results in descending order based on the count.", "Limit the results: Since we only want the most used method, we will limit the results to 1."], "gold_sql": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["tourist_attractions"], "pred_sql": "SELECT How_to_Get_There, COUNT(*) as usage_count \nFROM Tourist_Attractions \nGROUP BY How_to_Get_There \nORDER BY usage_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides details about tourists from the 'Visitors' table. The placeholder in the SELECT clause represents the specific details related to each tourist.\",\n        \"virtual_table\": \"SELECT Tourist_Details FROM VISITORS\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides details about hotels, specifically their additional information and star rating codes. The results are ordered by the price range of the hotels in ascending order, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5951", "db_id": "cre_Theme_park", "question": "Show different tourist attractions' names, ids, and the corresponding number of visits.", "rationale": ["Identify the relevant tables: Tourist_Attractions and Visits are needed to get the attraction names and the number of visits.", "Select the columns: Tourist_Attraction_ID and Name from Tourist_Attractions, and count the Visit_ID from Visits to get the number of visits.", "Use a LEFT JOIN to connect Tourist_Attractions with Visits on the Tourist_Attraction_ID to ensure all attractions are included, even those with zero visits.", "Group the results by Tourist_Attraction_ID and Name to aggregate the visit counts for each attraction."], "gold_sql": "SELECT T1.Name ,  T2.Tourist_Attraction_ID ,   COUNT(*) FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID", "source_tables": ["visits", "tourist_attractions"], "pred_sql": "SELECT Tourist_Attraction_ID, Name, COUNT(Visit_ID) AS Number_of_Visits \nFROM Tourist_Attractions \nLEFT JOIN Visits ON Tourist_Attractions.Tourist_Attraction_ID = Visits.Tourist_Attraction_ID \nGROUP BY Tourist_Attraction_ID, Name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides details about tourists from the 'Visitors' table. The placeholder in the SELECT clause represents the specific details related to each tourist.\",\n        \"virtual_table\": \"SELECT Tourist_Details FROM VISITORS\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides details about hotels, specifically their additional information and star rating codes. The results are ordered by the price range of the hotels in ascending order, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5959", "db_id": "cre_Theme_park", "question": "What are the names of the tourist attractions that have parking or shopping as their feature details?", "rationale": ["Identify the relevant tables: Tourist_Attractions, Tourist_Attraction_Features, and Features.", "We need to select the names of tourist attractions, so we will select the 'Name' column from the Tourist_Attractions table.", "To find attractions with specific features, we will join the Tourist_Attractions table with the Tourist_Attraction_Features table on the Tourist_Attraction_ID.", "Next, we will join the Features table to get the feature details associated with each attraction.", "We will filter the results using a WHERE clause to include only those attractions that have 'parking' or 'shopping' as their feature details."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'park' UNION SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'shopping'", "source_tables": ["features", "tourist_attractions", "tourist_attraction_features"], "pred_sql": "SELECT Name FROM Tourist_Attractions \nJOIN Tourist_Attraction_Features ON Tourist_Attractions.Tourist_Attraction_ID = Tourist_Attraction_Features.Tourist_Attraction_ID \nJOIN Features ON Tourist_Attraction_Features.Feature_ID = Features.Feature_ID \nWHERE Features.Feature_Details IN ('parking', 'shopping');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides details about tourists from the 'Visitors' table. The placeholder in the SELECT clause represents the specific details related to each tourist.\",\n        \"virtual_table\": \"SELECT Tourist_Details FROM VISITORS\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides details about hotels, specifically their additional information and star rating codes. The results are ordered by the price range of the hotels in ascending order, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides additional details about hotels from the 'Hotels' table, sorted by their price range in descending order. The placeholder in the LIMIT clause represents the maximum number of hotel details to retrieve.\",\n        \"virtual_table\": \"SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5960", "db_id": "cre_Theme_park", "question": "Find the tourist attractions that have parking or shopping as their feature details. What are the names of the attractions?", "rationale": ["Identify the relevant tables: Tourist_Attractions, Tourist_Attraction_Features, and Features.", "We need to find the names of tourist attractions that have specific features (parking or shopping).", "Join the Tourist_Attractions table with the Tourist_Attraction_Features table to link attractions with their features.", "Then, join the Features table to get the details of those features.", "Use a WHERE clause to filter the results to only include attractions that have 'parking' or 'shopping' as their feature details."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'park' UNION SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'shopping'", "source_tables": ["features", "tourist_attractions", "tourist_attraction_features"], "pred_sql": "SELECT Tourist_Attractions.Name \nFROM Tourist_Attractions \nJOIN Tourist_Attraction_Features ON Tourist_Attractions.Tourist_Attraction_ID = Tourist_Attraction_Features.Tourist_Attraction_ID \nJOIN Features ON Tourist_Attraction_Features.Feature_ID = Features.Feature_ID \nWHERE Features.Feature_Details IN ('parking', 'shopping');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides details about tourists from the 'Visitors' table. The placeholder in the SELECT clause represents the specific details related to each tourist.\",\n        \"virtual_table\": \"SELECT Tourist_Details FROM VISITORS\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides details about hotels, specifically their additional information and star rating codes. The results are ordered by the price range of the hotels in ascending order, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of location names from the 'Locations' table that match a specific pattern. The placeholder in the WHERE clause allows for flexible searching of location names based on user input.\",\n        \"virtual_table\": \"SELECT Location_Name FROM LOCATIONS WHERE Location_Name LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5964", "db_id": "cre_Theme_park", "question": "Which tourist attractions do the tourists Vincent and Marcelle visit? Tell me the names of the attractions.", "rationale": ["Identify the tables involved: We need to find tourist attractions visited by specific tourists, so we will use the 'Visits', 'Visitors', and 'Tourist_Attractions' tables.", "Join the tables: We will join 'Visits' with 'Visitors' to filter by the tourists' names and then join with 'Tourist_Attractions' to get the names of the attractions.", "Filter by tourist names: We will use a WHERE clause to specify that we are only interested in the tourists named Vincent and Marcelle.", "Select the attraction names: Finally, we will select the names of the tourist attractions from the resulting joined table."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  'Vincent' INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  'Marcelle'", "source_tables": ["visits", "visitors", "tourist_attractions"], "pred_sql": "SELECT Tourist_Attractions.Name \nFROM Visits \nJOIN Visitors ON Visits.Tourist_ID = Visitors.Tourist_ID \nJOIN Tourist_Attractions ON Visits.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID \nWHERE Visitors.Tourist_Details IN ('Vincent', 'Marcelle');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides details about tourists from the 'Visitors' table. The placeholder in the SELECT clause represents the specific details related to each tourist.\",\n        \"virtual_table\": \"SELECT Tourist_Details FROM VISITORS\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides details about hotels, specifically their additional information and star rating codes. The results are ordered by the price range of the hotels in ascending order, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6059", "db_id": "customers_and_addresses", "question": "What is the average amount of items ordered in each order?", "rationale": ["The question asks for the average amount of items ordered in each order.", "To find the average, we need to calculate the average of the 'order_quantity' from the 'Order_Items' table.", "The hint provides a virtual table that already calculates the average quantity of products ordered from the 'Order_Items' table.", "Thus, the SQL query to get the average amount of items ordered in each order is: SELECT avg(order_quantity) FROM Order_Items."], "gold_sql": "SELECT avg(order_quantity) FROM order_items", "source_tables": ["order_items"], "pred_sql": "SELECT avg(order_quantity) FROM Order_Items", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average quantity of products ordered from the 'Order_Items' table. The result provides insights into the typical order size for products.\",\n        \"virtual_table\": \"SELECT avg(order_quantity) FROM order_items\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the preferred payment methods used by customers from the 'Customers' table. It groups the results by payment method and orders them by the frequency of each method, allowing the user to specify a limit on the number of payment methods returned.\",\n        \"virtual_table\": \"SELECT payment_method FROM customers GROUP BY payment_method ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6066", "db_id": "customers_and_addresses", "question": "Find the payment method that is used most frequently.", "rationale": ["Identify the relevant table: The 'Customers' table contains the 'payment_method' column which we need to analyze.", "Group the results: We need to group the results by 'payment_method' to count how many times each payment method is used.", "Count occurrences: Use the COUNT function to count the number of occurrences of each payment method.", "Order by frequency: We will order the results in descending order based on the count to get the most frequently used payment method at the top.", "Limit the results: Since we only want the most frequently used payment method, we will limit the results to 1."], "gold_sql": "SELECT payment_method FROM customers GROUP BY payment_method ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers"], "pred_sql": "SELECT payment_method FROM Customers GROUP BY payment_method ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the preferred payment methods used by customers from the 'Customers' table. It groups the results by payment method and orders them by the frequency of each method, allowing the user to specify a limit on the number of payment methods returned.\",\n        \"virtual_table\": \"SELECT payment_method FROM customers GROUP BY payment_method ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average quantity of products ordered from the 'Order_Items' table. The result provides insights into the typical order size for products.\",\n        \"virtual_table\": \"SELECT avg(order_quantity) FROM order_items\"\n    }\n}\n"}
{"sample_id": "train.6085", "db_id": "customers_and_addresses", "question": "Which city has the most customers living in?", "rationale": ["Identify the relevant tables: We need to find the city with the most customers, so we will use the Customer_Addresses and Addresses tables.", "Join the tables: We will join Customer_Addresses with Addresses on the address_id to get the city information for each customer.", "Count distinct customers: We will count the distinct customer_id for each city to avoid counting the same customer multiple times.", "Group by city: We will group the results by city to aggregate the customer counts for each city.", "Order the results: We will order the results in descending order based on the customer count to find the city with the most customers.", "Limit the results: We will limit the results to 1 to get only the city with the highest count."], "gold_sql": "SELECT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id GROUP BY t3.city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "customers", "customer_addresses"], "pred_sql": "SELECT city, COUNT(DISTINCT customer_id) AS customer_count\nFROM Customer_Addresses\nJOIN Addresses ON Customer_Addresses.address_id = Addresses.address_id\nGROUP BY city\nORDER BY customer_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6098", "db_id": "customers_and_addresses", "question": "Find the contact channel code that was used by the customer named \"Tillman Ernser\".", "rationale": ["Identify the customer ID for 'Tillman Ernser' from the Customers table.", "Use the identified customer ID to find the corresponding contact channel code from the Customer_Contact_Channels table.", "Ensure to filter for the most recent active contact channel by checking if active_to_date is NULL, indicating it is currently active."], "gold_sql": "SELECT DISTINCT channel_code FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  'Tillman Ernser'", "source_tables": ["customer_contact_channels", "customers"], "pred_sql": "SELECT channel_code, contact_number FROM Customer_Contact_Channels WHERE customer_id = (SELECT customer_id FROM Customers WHERE customer_name = 'Tillman Ernser') AND active_to_date IS NULL", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the channel codes and associated contact numbers from the 'Customer_Contact_Channels' table for the most recently active contact channel based on the duration of activity. The placeholder in the LIMIT clause allows for specifying the number of records to retrieve based on the longest active duration.\",\n        \"virtual_table\": \"SELECT channel_code ,  contact_number FROM customer_contact_channels WHERE active_to_date - active_from_date  =  (SELECT active_to_date - active_from_date FROM customer_contact_channels ORDER BY (active_to_date - active_from_date) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.6099", "db_id": "customers_and_addresses", "question": "What is the \"active to date\" of the latest contact channel used by \"Tillman Ernser\"?", "rationale": ["Identify the customer ID for 'Tillman Ernser' from the Customers table.", "Use the identified customer ID to find the contact channels in the Customer_Contact_Channels table.", "Order the contact channels by the duration of activity (active_to_date - active_from_date) in descending order to get the latest one.", "Limit the results to 1 to get only the latest contact channel's 'active to date'."], "gold_sql": "SELECT max(t2.active_to_date) FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  'Tillman Ernser'", "source_tables": ["customer_contact_channels", "customers"], "pred_sql": "SELECT active_to_date FROM Customer_Contact_Channels WHERE customer_id = (SELECT customer_id FROM Customers WHERE customer_name = 'Tillman Ernser') ORDER BY (active_to_date - active_from_date) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the channel codes and associated contact numbers from the 'Customer_Contact_Channels' table for the most recently active contact channel based on the duration of activity. The placeholder in the LIMIT clause allows for specifying the number of records to retrieve based on the longest active duration.\",\n        \"virtual_table\": \"SELECT channel_code ,  contact_number FROM customer_contact_channels WHERE active_to_date - active_from_date  =  (SELECT active_to_date - active_from_date FROM customer_contact_channels ORDER BY (active_to_date - active_from_date) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.6100", "db_id": "customers_and_addresses", "question": "Return the the \"active to date\" of the latest contact channel used by the customer named \"Tillman Ernser\".", "rationale": ["Identify the customer ID for 'Tillman Ernser' from the Customers table.", "Use the identified customer ID to find the active contact channels from the Customer_Contact_Channels table.", "Order the results by the duration of activity (active_to_date - active_from_date) in descending order to get the latest contact channel.", "Limit the results to 1 to get only the latest contact channel's 'active_to_date'."], "gold_sql": "SELECT max(t2.active_to_date) FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  'Tillman Ernser'", "source_tables": ["customer_contact_channels", "customers"], "pred_sql": "SELECT active_to_date FROM Customer_Contact_Channels WHERE customer_id = (SELECT customer_id FROM Customers WHERE customer_name = 'Tillman Ernser') ORDER BY (active_to_date - active_from_date) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the channel codes and associated contact numbers from the 'Customer_Contact_Channels' table for the most recently active contact channel based on the duration of activity. The placeholder in the LIMIT clause allows for specifying the number of records to retrieve based on the longest active duration.\",\n        \"virtual_table\": \"SELECT channel_code ,  contact_number FROM customer_contact_channels WHERE active_to_date - active_from_date  =  (SELECT active_to_date - active_from_date FROM customer_contact_channels ORDER BY (active_to_date - active_from_date) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.6101", "db_id": "customers_and_addresses", "question": "What is the average time span of contact channels in the database?", "rationale": ["Identify the relevant table: Customer_Contact_Channels contains the contact channel information including active dates.", "Determine the calculation needed: We need to calculate the average time span of contact channels, which involves the difference between active_to_date and active_from_date.", "Use the AVG function to compute the average of the calculated time spans.", "Construct the SQL query to select the average time span from the Customer_Contact_Channels table."], "gold_sql": "SELECT avg(active_to_date - active_from_date) FROM customer_contact_channels", "source_tables": ["customer_contact_channels"], "pred_sql": "SELECT AVG(active_to_date - active_from_date) AS average_time_span FROM Customer_Contact_Channels", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the channel codes and associated contact numbers from the 'Customer_Contact_Channels' table for the most recently active contact channel based on the duration of activity. The placeholder in the LIMIT clause allows for specifying the number of records to retrieve based on the longest active duration.\",\n        \"virtual_table\": \"SELECT channel_code ,  contact_number FROM customer_contact_channels WHERE active_to_date - active_from_date  =  (SELECT active_to_date - active_from_date FROM customer_contact_channels ORDER BY (active_to_date - active_from_date) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average quantity of products ordered from the 'Order_Items' table. The result provides insights into the typical order size for products.\",\n        \"virtual_table\": \"SELECT avg(order_quantity) FROM order_items\"\n    }\n}\n"}
{"sample_id": "train.6102", "db_id": "customers_and_addresses", "question": "Compute the average active time span of contact channels.", "rationale": ["Identify the relevant table: Customer_Contact_Channels contains the active time span for contact channels.", "Determine the columns needed: active_from_date and active_to_date are required to calculate the duration of activity.", "Calculate the duration: The duration can be calculated by subtracting active_from_date from active_to_date.", "Use the AVG function: To compute the average of these durations, the AVG function is applied to the calculated duration."], "gold_sql": "SELECT avg(active_to_date - active_from_date) FROM customer_contact_channels", "source_tables": ["customer_contact_channels"], "pred_sql": "SELECT AVG(active_to_date - active_from_date) AS average_active_time_span FROM Customer_Contact_Channels", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the channel codes and associated contact numbers from the 'Customer_Contact_Channels' table for the most recently active contact channel based on the duration of activity. The placeholder in the LIMIT clause allows for specifying the number of records to retrieve based on the longest active duration.\",\n        \"virtual_table\": \"SELECT channel_code ,  contact_number FROM customer_contact_channels WHERE active_to_date - active_from_date  =  (SELECT active_to_date - active_from_date FROM customer_contact_channels ORDER BY (active_to_date - active_from_date) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average quantity of products ordered from the 'Order_Items' table. The result provides insights into the typical order size for products.\",\n        \"virtual_table\": \"SELECT avg(order_quantity) FROM order_items\"\n    }\n}\n"}
{"sample_id": "train.6104", "db_id": "customers_and_addresses", "question": "Return the channel code and contact number of the customer contact channel whose active duration was the longest.", "rationale": ["Identify the relevant table: Customer_Contact_Channels contains the channel codes and contact numbers.", "Determine the columns needed: channel_code and contact_number are required as per the query.", "Calculate the duration of activity: Use the difference between active_to_date and active_from_date to find the duration.", "Find the maximum duration: Use a subquery to find the maximum duration of activity across all contact channels.", "Filter the results: Select the channel_code and contact_number where the duration equals the maximum duration found."], "gold_sql": "SELECT channel_code ,  contact_number FROM customer_contact_channels WHERE active_to_date - active_from_date  =  (SELECT active_to_date - active_from_date FROM customer_contact_channels ORDER BY (active_to_date - active_from_date) DESC LIMIT 1)", "source_tables": ["customer_contact_channels"], "pred_sql": "SELECT channel_code, contact_number FROM Customer_Contact_Channels WHERE (julianday(active_to_date) - julianday(active_from_date)) = (SELECT MAX(julianday(active_to_date) - julianday(active_from_date)) FROM Customer_Contact_Channels)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the channel codes and associated contact numbers from the 'Customer_Contact_Channels' table for the most recently active contact channel based on the duration of activity. The placeholder in the LIMIT clause allows for specifying the number of records to retrieve based on the longest active duration.\",\n        \"virtual_table\": \"SELECT channel_code ,  contact_number FROM customer_contact_channels WHERE active_to_date - active_from_date  =  (SELECT active_to_date - active_from_date FROM customer_contact_channels ORDER BY (active_to_date - active_from_date) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the preferred payment methods used by customers from the 'Customers' table. It groups the results by payment method and orders them by the frequency of each method, allowing the user to specify a limit on the number of payment methods returned.\",\n        \"virtual_table\": \"SELECT payment_method FROM customers GROUP BY payment_method ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6105", "db_id": "customers_and_addresses", "question": "Find the name and active date of the customer that use email as the contact channel.", "rationale": ["Identify the relevant tables: Customers and Customer_Contact_Channels.", "We need to retrieve the customer name and the active date of the customer using email as the contact channel.", "Join the Customers table with the Customer_Contact_Channels table on customer_id to link customers with their contact channels.", "Filter the results to include only those records where the channel_code is 'email'.", "To get the active date, we can use the active_from_date from the Customer_Contact_Channels table.", "Ensure that we only select customers with an active email channel, which may involve checking if active_to_date is NULL (indicating it is currently active)."], "gold_sql": "SELECT t1.customer_name ,  t2.active_from_date FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t2.channel_code  =  'Email'", "source_tables": ["customer_contact_channels", "customers"], "pred_sql": "SELECT c.customer_name, ccc.active_from_date \nFROM Customers c \nJOIN Customer_Contact_Channels ccc ON c.customer_id = ccc.customer_id \nWHERE ccc.channel_code = 'email' \nAND ccc.active_to_date IS NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the channel codes and associated contact numbers from the 'Customer_Contact_Channels' table for the most recently active contact channel based on the duration of activity. The placeholder in the LIMIT clause allows for specifying the number of records to retrieve based on the longest active duration.\",\n        \"virtual_table\": \"SELECT channel_code ,  contact_number FROM customer_contact_channels WHERE active_to_date - active_from_date  =  (SELECT active_to_date - active_from_date FROM customer_contact_channels ORDER BY (active_to_date - active_from_date) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.6127", "db_id": "customers_and_addresses", "question": "Who made the latest order?", "rationale": ["Identify the table that contains order information, which is 'Customer_Orders'.", "To find the latest order, we need to sort the orders by 'order_date' in descending order.", "We will select the 'customer_id' of the most recent order by limiting the results to 1 after sorting."], "gold_sql": "SELECT t1.customer_name FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id ORDER BY t2.order_date DESC LIMIT 1", "source_tables": ["customer_orders", "customers"], "pred_sql": "SELECT customer_id FROM Customer_Orders ORDER BY order_date DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average quantity of products ordered from the 'Order_Items' table. The result provides insights into the typical order size for products.\",\n        \"virtual_table\": \"SELECT avg(order_quantity) FROM order_items\"\n    }\n}\n"}
{"sample_id": "train.6131", "db_id": "customers_and_addresses", "question": "Find the name and ID of the product whose total order quantity is the largest.", "rationale": ["To find the product with the largest total order quantity, we need to sum the order quantities for each product.", "We will use the 'Order_Items' table, which contains the 'product_id' and 'order_quantity'.", "We will group the results by 'product_id' to get the total quantity for each product.", "Next, we will order the results in descending order based on the total quantity to get the product with the highest quantity at the top.", "Finally, we will limit the results to 1 to get only the product with the largest total order quantity."], "gold_sql": "SELECT t2.product_details ,  t2.product_id FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY sum(t1.order_quantity) LIMIT 1", "source_tables": ["products", "order_items"], "pred_sql": "SELECT oi.product_id, SUM(oi.order_quantity) AS total_quantity\nFROM Order_Items oi\nGROUP BY oi.product_id\nORDER BY total_quantity DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average quantity of products ordered from the 'Order_Items' table. The result provides insights into the typical order size for products.\",\n        \"virtual_table\": \"SELECT avg(order_quantity) FROM order_items\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves the product details from the 'Products' table that match specific criteria. The placeholders in the WHERE clause represent the patterns to search for in the product details.\",\n        \"virtual_table\": \"SELECT product_details FROM products WHERE product_details LIKE [PLACEHOLDER-TYPE:STRING] OR product_details LIKE [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a unique list of product specifications from the 'Products' table. The placeholder in the SELECT clause represents the product details that can be filtered or modified as needed.\",\n        \"virtual_table\": \"SELECT DISTINCT product_details FROM products\"\n    }\n}\n"}
{"sample_id": "train.6133", "db_id": "customers_and_addresses", "question": "Find all the addresses in East Julianaside, Texas or in Gleasonmouth, Arizona.", "rationale": ["Identify the relevant table: The question asks for addresses, so we will use the 'Addresses' table.", "Determine the filtering criteria: We need to find addresses in two specific cities (East Julianaside and Gleasonmouth) and their corresponding states (Texas and Arizona).", "Construct the WHERE clause: We will use an OR condition to combine the two sets of criteria for the cities and states.", "Formulate the SQL query: We will select all columns from the 'Addresses' table where the conditions are met."], "gold_sql": "SELECT address_content FROM addresses WHERE city  =  'East Julianaside' AND state_province_county  =  'Texas' UNION SELECT address_content FROM addresses WHERE city  =  'Gleasonmouth' AND state_province_county  =  'Arizona'", "source_tables": ["addresses"], "pred_sql": "SELECT * FROM Addresses WHERE (city = 'East Julianaside' AND state_province_county = 'Texas') OR (city = 'Gleasonmouth' AND state_province_county = 'Arizona');", "hint": "\n"}
{"sample_id": "train.6134", "db_id": "customers_and_addresses", "question": "What are all the addresses in East Julianaside, Texas or in Gleasonmouth, Arizona.", "rationale": ["Identify the relevant table: The question asks for addresses, so we will use the 'Addresses' table.", "Determine the filtering criteria: We need to filter addresses based on the city and state. The cities are 'East Julianaside' and 'Gleasonmouth', and the states are 'Texas' and 'Arizona'.", "Construct the WHERE clause: We will use an OR condition to include addresses from either of the specified cities and states.", "Formulate the SQL query: We will select all columns from the 'Addresses' table where the conditions in the WHERE clause are met."], "gold_sql": "SELECT address_content FROM addresses WHERE city  =  'East Julianaside' AND state_province_county  =  'Texas' UNION SELECT address_content FROM addresses WHERE city  =  'Gleasonmouth' AND state_province_county  =  'Arizona'", "source_tables": ["addresses"], "pred_sql": "SELECT * FROM Addresses WHERE (city = 'East Julianaside' AND state_province_county = 'Texas') OR (city = 'Gleasonmouth' AND state_province_county = 'Arizona');", "hint": "\n"}
{"sample_id": "train.6271", "db_id": "city_record", "question": "What is the match id of the competition called \"1994 FIFA World Cup qualification\"?", "rationale": ["Identify the table that contains the competition information, which is the 'match' table.", "Determine the column that holds the competition name, which is 'Competition'.", "Formulate a subquery to find the Competition ID for '1994 FIFA World Cup qualification'.", "Use the result of the subquery to select the Match_ID from the 'match' table."], "gold_sql": "SELECT match_id FROM MATCH WHERE competition = '1994 FIFA World Cup qualification'", "source_tables": ["match"], "pred_sql": "SELECT Match_ID FROM match WHERE Competition = (SELECT Competition FROM match WHERE Competition = '1994 FIFA World Cup qualification');", "hint": "\n"}
{"sample_id": "train.6275", "db_id": "city_record", "question": "Find the city that hosted the most events.", "rationale": ["To find the city that hosted the most events, we need to look at the 'hosting_city' table which contains the 'Host_City' and the 'Match_ID'.", "We will count the number of matches hosted by each city using the COUNT() function.", "We will group the results by 'Host_City' to aggregate the counts for each city.", "To determine which city hosted the most events, we will order the results in descending order based on the count of events.", "Finally, we will limit the results to just one city using LIMIT 1 to get the city with the highest count."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["hosting_city", "city"], "pred_sql": "SELECT Host_City, COUNT(*) as Event_Count FROM hosting_city GROUP BY Host_City ORDER BY Event_Count DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of cities from the 'city' table that have a regional population greater than a specified number and also those that have a regional population less than another specified number. The placeholders in the WHERE clauses represent the population thresholds.\",\n        \"virtual_table\": \"SELECT city FROM city WHERE regional_population  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT city FROM city WHERE regional_population  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves the names of cities from the 'city' table where the regional population is either greater than or less than specified numeric values. The placeholders in the WHERE clauses represent the population thresholds for filtering the cities.\",\n        \"virtual_table\": \"SELECT city FROM city WHERE regional_population  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT city FROM city WHERE regional_population  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6282", "db_id": "city_record", "question": "Which three cities have the largest regional population?", "rationale": ["Identify the relevant table: The 'city' table contains the information about cities and their regional populations.", "Determine the required information: We need to find the names of the three cities with the largest regional populations.", "Use the ORDER BY clause to sort the cities by their regional population in descending order.", "Limit the results to the top three cities using the LIMIT clause."], "gold_sql": "SELECT city FROM city ORDER BY regional_population DESC LIMIT 3", "source_tables": ["city"], "pred_sql": "SELECT City FROM city ORDER BY Regional_Population DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of cities from the 'city' table that have a regional population greater than a specified number and also those that have a regional population less than another specified number. The placeholders in the WHERE clauses represent the population thresholds.\",\n        \"virtual_table\": \"SELECT city FROM city WHERE regional_population  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT city FROM city WHERE regional_population  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves the names of cities from the 'city' table where the regional population is either greater than or less than specified numeric values. The placeholders in the WHERE clauses represent the population thresholds for filtering the cities.\",\n        \"virtual_table\": \"SELECT city FROM city WHERE regional_population  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT city FROM city WHERE regional_population  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6283", "db_id": "city_record", "question": "What are the three largest cities in terms of regional population?", "rationale": ["Identify the relevant table: The 'city' table contains the information about cities and their regional populations.", "Determine the required columns: We need the 'City' name and 'Regional_Population' for the output.", "Sort the cities by population: Use 'ORDER BY Regional_Population DESC' to sort the cities in descending order based on their population.", "Limit the results: Use 'LIMIT 3' to get only the top three cities with the largest populations."], "gold_sql": "SELECT city FROM city ORDER BY regional_population DESC LIMIT 3", "source_tables": ["city"], "pred_sql": "SELECT City, Regional_Population FROM city ORDER BY Regional_Population DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of cities from the 'city' table that have a regional population greater than a specified number and also those that have a regional population less than another specified number. The placeholders in the WHERE clauses represent the population thresholds.\",\n        \"virtual_table\": \"SELECT city FROM city WHERE regional_population  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT city FROM city WHERE regional_population  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves the names of cities from the 'city' table where the regional population is either greater than or less than specified numeric values. The placeholders in the WHERE clauses represent the population thresholds for filtering the cities.\",\n        \"virtual_table\": \"SELECT city FROM city WHERE regional_population  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT city FROM city WHERE regional_population  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6286", "db_id": "city_record", "question": "Which city has the highest temperature in February?", "rationale": ["Identify the relevant tables: We need data from the 'city' table for city names and the 'temperature' table for February temperatures.", "Join the 'city' table with the 'temperature' table on the City_ID to combine city names with their corresponding February temperatures.", "Order the results by the February temperature in descending order to get the highest temperature at the top.", "Limit the results to 1 to get only the city with the highest temperature in February."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id ORDER BY T2.Feb DESC LIMIT 1", "source_tables": ["city", "temperature"], "pred_sql": "SELECT c.City FROM city c JOIN temperature t ON c.City_ID = t.City_ID ORDER BY t.Feb DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of cities from the 'city' table that have a regional population greater than a specified number and also those that have a regional population less than another specified number. The placeholders in the WHERE clauses represent the population thresholds.\",\n        \"virtual_table\": \"SELECT city FROM city WHERE regional_population  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT city FROM city WHERE regional_population  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves the names of cities from the 'city' table where the regional population is either greater than or less than specified numeric values. The placeholders in the WHERE clauses represent the population thresholds for filtering the cities.\",\n        \"virtual_table\": \"SELECT city FROM city WHERE regional_population  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT city FROM city WHERE regional_population  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6288", "db_id": "city_record", "question": "Give me a list of cities whose temperature in March is lower than that in July or higher than that in Oct?", "rationale": ["Identify the tables involved: We need data from the 'city' table for city names and the 'temperature' table for temperature data.", "Determine the conditions: We want cities where the temperature in March is lower than in July or higher than in October.", "Join the 'city' and 'temperature' tables on 'City_ID' to access both city names and their corresponding temperatures.", "Use a SELECT statement to retrieve the city names that meet the specified temperature conditions.", "Construct the WHERE clause to filter cities based on the temperature conditions: t.Mar < t.Jul OR t.Mar > t.Oct."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul OR T2.Mar  >  T2.Oct", "source_tables": ["city", "temperature"], "pred_sql": "SELECT c.City \nFROM city c \nJOIN temperature t ON c.City_ID = t.City_ID \nWHERE t.Mar < t.Jul OR t.Mar > t.Oct;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of cities from the 'city' table that have a regional population greater than a specified number and also those that have a regional population less than another specified number. The placeholders in the WHERE clauses represent the population thresholds.\",\n        \"virtual_table\": \"SELECT city FROM city WHERE regional_population  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT city FROM city WHERE regional_population  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves the names of cities from the 'city' table where the regional population is either greater than or less than specified numeric values. The placeholders in the WHERE clauses represent the population thresholds for filtering the cities.\",\n        \"virtual_table\": \"SELECT city FROM city WHERE regional_population  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT city FROM city WHERE regional_population  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6290", "db_id": "city_record", "question": "Give me a list of cities whose temperature in Mar is lower than that in July and which have also served as host cities?", "rationale": ["Identify the tables needed: We need data from the 'city', 'temperature', and 'hosting_city' tables.", "We need to filter cities based on temperature in March and July, so we will join the 'city' table with the 'temperature' table on 'City_ID'.", "We also need to ensure that the cities have hosted matches, so we will join the 'hosting_city' table on 'Host_City'.", "The condition for filtering is that the temperature in March (t.Mar) should be lower than the temperature in July (t.Jul).", "Finally, we select the city names from the resulting joined table."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul INTERSECT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "pred_sql": "SELECT c.City \nFROM city c \nJOIN temperature t ON c.City_ID = t.City_ID \nJOIN hosting_city h ON c.City_ID = h.Host_City \nWHERE t.Mar < t.Jul;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of cities from the 'city' table that have a regional population greater than a specified number and also those that have a regional population less than another specified number. The placeholders in the WHERE clauses represent the population thresholds.\",\n        \"virtual_table\": \"SELECT city FROM city WHERE regional_population  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT city FROM city WHERE regional_population  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves the names of cities from the 'city' table where the regional population is either greater than or less than specified numeric values. The placeholders in the WHERE clauses represent the population thresholds for filtering the cities.\",\n        \"virtual_table\": \"SELECT city FROM city WHERE regional_population  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT city FROM city WHERE regional_population  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6293", "db_id": "city_record", "question": "Which cities have lower temperature in March than in Dec and have never served as host cities?", "rationale": ["Identify the relevant tables: We need data from the 'city' and 'temperature' tables, and we also need to check against the 'hosting_city' table to find cities that have never hosted a match.", "Join the 'city' and 'temperature' tables on 'City_ID' to access temperature data for each city.", "Filter the results to find cities where the average temperature in March (t.Mar) is lower than in December (t.Dec).", "Use a subquery to exclude cities that appear in the 'hosting_city' table as 'Host_City', ensuring we only get cities that have never hosted a match."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "pred_sql": "SELECT c.City \nFROM city c \nJOIN temperature t ON c.City_ID = t.City_ID \nWHERE t.Mar < t.Dec \nAND c.City_ID NOT IN (SELECT Host_City FROM hosting_city)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of cities from the 'city' table that have a regional population greater than a specified number and also those that have a regional population less than another specified number. The placeholders in the WHERE clauses represent the population thresholds.\",\n        \"virtual_table\": \"SELECT city FROM city WHERE regional_population  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT city FROM city WHERE regional_population  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves the names of cities from the 'city' table where the regional population is either greater than or less than specified numeric values. The placeholders in the WHERE clauses represent the population thresholds for filtering the cities.\",\n        \"virtual_table\": \"SELECT city FROM city WHERE regional_population  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT city FROM city WHERE regional_population  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6295", "db_id": "city_record", "question": "Which cities have higher temperature in Feb than in Jun or have once served as host cities?", "rationale": ["Identify the relevant tables: We need data from the 'city', 'temperature', and 'hosting_city' tables.", "Join the 'city' table with the 'temperature' table on 'City_ID' to access temperature data for each city.", "Join the 'city' table with the 'hosting_city' table on 'Host_City' to find cities that have hosted matches.", "Use a WHERE clause to filter cities where the temperature in February is higher than in June or where the city has hosted a match.", "Select distinct city names to avoid duplicates in the result."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Feb  >  T2.Jun UNION SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "pred_sql": "SELECT DISTINCT c.City \nFROM city c \nLEFT JOIN temperature t ON c.City_ID = t.City_ID \nLEFT JOIN hosting_city h ON c.City_ID = h.Host_City \nWHERE (t.Feb > t.Jun) OR (h.Host_City IS NOT NULL);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of cities from the 'city' table that have a regional population greater than a specified number and also those that have a regional population less than another specified number. The placeholders in the WHERE clauses represent the population thresholds.\",\n        \"virtual_table\": \"SELECT city FROM city WHERE regional_population  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT city FROM city WHERE regional_population  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves the names of cities from the 'city' table where the regional population is either greater than or less than specified numeric values. The placeholders in the WHERE clauses represent the population thresholds for filtering the cities.\",\n        \"virtual_table\": \"SELECT city FROM city WHERE regional_population  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT city FROM city WHERE regional_population  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6324", "db_id": "e_government", "question": "Find the last name of the first ever contact person of the organization with the highest UK Vat number.", "rationale": ["Identify the organization with the highest UK VAT number by using a subquery to select the maximum value from the Organizations table.", "Join the Organizations table with the Organization_Contact_Individuals table to link organizations with their contact individuals.", "Join the Individuals table to get the last names of the individuals who are contacts for the organization.", "Filter the results to only include the organization with the highest UK VAT number.", "Order the results by the date of contact to find the first contact person.", "Limit the results to 1 to get only the first contact person's last name."], "gold_sql": "SELECT t3.individual_last_name FROM organizations AS t1 JOIN organization_contact_individuals AS t2 ON t1.organization_id  =  t2.organization_id JOIN individuals AS t3 ON t2.individual_id  =  t3.individual_id WHERE t1.uk_vat_number  =  (SELECT max(uk_vat_number) FROM organizations) ORDER BY t2.date_contact_to ASC LIMIT 1", "source_tables": ["organizations", "organization_contact_individuals", "individuals"], "pred_sql": "SELECT i.individual_last_name \nFROM Organizations o \nJOIN Organization_Contact_Individuals oci ON o.organization_id = oci.organization_id \nJOIN Individuals i ON oci.individual_id = i.individual_id \nWHERE o.uk_vat_number = (SELECT MAX(uk_vat_number) FROM Organizations) \nORDER BY oci.date_contact_from ASC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6328", "db_id": "e_government", "question": "Find name of the services that has never been used.", "rationale": ["Identify the table that contains the service names, which is the Services table.", "We need to find services that have never been used, which means we need to check against the Party_Services table where service bookings are recorded.", "To find services that have never been used, we can select service names from the Services table where the service_id is not present in the Party_Services table.", "Construct the SQL query using a subquery to filter out the used services from the Services table."], "gold_sql": "SELECT service_name FROM services EXCEPT SELECT t1.service_name FROM services AS t1 JOIN party_services AS t2 ON t1.service_id  =  t2.service_id", "source_tables": ["services", "party_services"], "pred_sql": "SELECT service_name \nFROM Services \nWHERE service_id NOT IN (SELECT service_id FROM Party_Services);", "hint": "\n"}
{"sample_id": "train.6330", "db_id": "e_government", "question": "Find the name of all the cities and states.", "rationale": ["Identify the relevant table: The question asks for cities and states, which are found in the Addresses table.", "Select the appropriate columns: We need to select 'town_city' for cities and 'state_province_county' for states.", "Use DISTINCT to avoid duplicate entries: Since we want the names of all cities and states, using DISTINCT will ensure that we only get unique combinations.", "Construct the SQL query: Combine the selected columns and the table name in a SELECT statement."], "gold_sql": "SELECT town_city FROM addresses UNION SELECT state_province_county FROM addresses", "source_tables": ["addresses"], "pred_sql": "SELECT DISTINCT town_city, state_province_county FROM Addresses;", "hint": "\n"}
{"sample_id": "train.6331", "db_id": "e_government", "question": "What are the names of all cities and states?", "rationale": ["Identify the relevant table: The question asks for city and state names, which are found in the Addresses table.", "Select the appropriate columns: We need to select 'town_city' and 'state_province_county' from the Addresses table.", "Use DISTINCT to avoid duplicate entries: Since cities and states may repeat, we use DISTINCT to get unique combinations.", "Construct the SQL query: Combine the selected columns and table into a SQL SELECT statement."], "gold_sql": "SELECT town_city FROM addresses UNION SELECT state_province_county FROM addresses", "source_tables": ["addresses"], "pred_sql": "SELECT DISTINCT town_city, state_province_county FROM Addresses;", "hint": "\n"}
{"sample_id": "train.6346", "db_id": "e_government", "question": "Find the last name of the individuals that have been contact individuals of an organization.", "rationale": ["Identify the relevant tables: We need to find individuals who are contact individuals for organizations, so we will use the Organization_Contact_Individuals and Individuals tables.", "Determine the relationship: The Organization_Contact_Individuals table has a foreign key 'individual_id' that links to the Individuals table.", "Select the required field: We need the last names of the individuals, which is in the Individuals table under 'individual_last_name'.", "Construct the SQL query: We will use a JOIN to combine the Organization_Contact_Individuals and Individuals tables on the 'individual_id' field and select the 'individual_last_name' from the Individuals table."], "gold_sql": "SELECT DISTINCT t1.individual_last_name FROM individuals AS t1 JOIN organization_contact_individuals AS t2 ON t1.individual_id  =  t2.individual_id", "source_tables": ["organization_contact_individuals", "individuals"], "pred_sql": "SELECT Individuals.individual_last_name \nFROM Organization_Contact_Individuals \nJOIN Individuals ON Organization_Contact_Individuals.individual_id = Individuals.individual_id;", "hint": "\n"}
{"sample_id": "train.6723", "db_id": "activity_1", "question": "Show the first name, last name, and phone number for all female faculty members.", "rationale": ["Identify the relevant table: Faculty.", "Determine the columns needed: Fname, Lname, Phone.", "Filter the results based on the gender of faculty members, specifically for females."], "gold_sql": "SELECT Fname ,  Lname ,  phone FROM Faculty WHERE Sex  =  'F'", "source_tables": ["faculty"], "pred_sql": "SELECT Fname, Lname, Phone FROM Faculty WHERE Sex = 'Female'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names, last names, and contact phone numbers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.\",\n        \"virtual_table\": \"SELECT Fname ,  Lname ,  phone FROM Faculty WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the count of faculty members by gender from the 'Faculty' table, filtered by a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty members.\",\n        \"virtual_table\": \"SELECT sex ,  count(*) FROM Faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] GROUP BY sex\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the unique identifiers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.\",\n        \"virtual_table\": \"SELECT FacID FROM Faculty WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6725", "db_id": "activity_1", "question": "Show ids for all the male faculty.", "rationale": ["The user wants to show ids for all male faculty members.", "We need to query the 'Faculty' table to get the unique identifiers of faculty members.", "The relevant column for the unique identifier is 'FacID'.", "We need to filter the results based on the gender, which is represented by the 'Sex' column.", "To get only male faculty members, we will use the condition 'Sex = 'Male''."], "gold_sql": "SELECT FacID FROM Faculty WHERE Sex  =  'M'", "source_tables": ["faculty"], "pred_sql": "SELECT FacID FROM Faculty WHERE Sex = 'Male'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the count of faculty members by gender from the 'Faculty' table, filtered by a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty members.\",\n        \"virtual_table\": \"SELECT sex ,  count(*) FROM Faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] GROUP BY sex\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the unique identifiers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.\",\n        \"virtual_table\": \"SELECT FacID FROM Faculty WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the first names, last names, and contact phone numbers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.\",\n        \"virtual_table\": \"SELECT Fname ,  Lname ,  phone FROM Faculty WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6738", "db_id": "activity_1", "question": "Find the building that has the largest number of faculty members.", "rationale": ["We need to find the building with the largest number of faculty members.", "To do this, we can select the 'building' column from the 'Faculty' table.", "We will group the results by 'building' to count the number of faculty members in each building.", "Next, we will order the results in descending order based on the count of faculty members.", "Finally, we will limit the results to 1 to get the building with the largest number of faculty members."], "gold_sql": "SELECT building FROM Faculty GROUP BY building ORDER BY count(*) DESC LIMIT 1", "source_tables": ["faculty"], "pred_sql": "SELECT building FROM Faculty GROUP BY building ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of buildings where faculty members of a specific academic rank are located. The query groups the results by building and filters to include only those buildings that have a certain number of faculty members, as indicated by the placeholders.\",\n        \"virtual_table\": \"SELECT building FROM Faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] GROUP BY building HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of buildings where faculty members have their offices, grouped by building name. The results are ordered by the number of faculty members in each building, allowing users to see which buildings have the most faculty presence. The placeholder in the LIMIT clause represents the maximum number of buildings to return.\",\n        \"virtual_table\": \"SELECT building FROM Faculty GROUP BY building ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the count of faculty members by gender from the 'Faculty' table, filtered by a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty members.\",\n        \"virtual_table\": \"SELECT sex ,  count(*) FROM Faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] GROUP BY sex\"\n    }\n}\n"}
{"sample_id": "train.6740", "db_id": "activity_1", "question": "In which buildings are there at least ten professors?", "rationale": ["The question asks for buildings with at least ten professors, which means we need to count the number of faculty members in each building.", "We will use the Faculty table to get the building information and count the number of faculty members in each building.", "We will group the results by the building name to aggregate the count of faculty members per building.", "Finally, we will use the HAVING clause to filter the results to only include buildings that have a count of faculty members greater than or equal to 10."], "gold_sql": "SELECT building FROM Faculty WHERE rank  =  'Professor' GROUP BY building HAVING count(*)  >=  10", "source_tables": ["faculty"], "pred_sql": "SELECT Building FROM Faculty GROUP BY Building HAVING COUNT(*) >= 10", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of buildings where faculty members of a specific academic rank are located. The query groups the results by building and filters to include only those buildings that have a certain number of faculty members, as indicated by the placeholders.\",\n        \"virtual_table\": \"SELECT building FROM Faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] GROUP BY building HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of buildings where faculty members have their offices, grouped by building name. The results are ordered by the number of faculty members in each building, allowing users to see which buildings have the most faculty presence. The placeholder in the LIMIT clause represents the maximum number of buildings to return.\",\n        \"virtual_table\": \"SELECT building FROM Faculty GROUP BY building ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the count of faculty members by gender from the 'Faculty' table, filtered by a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty members.\",\n        \"virtual_table\": \"SELECT sex ,  count(*) FROM Faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] GROUP BY sex\"\n    }\n}\n"}
{"sample_id": "train.6747", "db_id": "activity_1", "question": "Show the number of male and female assistant professors.", "rationale": ["Identify the relevant table: Faculty, which contains information about faculty members including their rank and gender.", "Determine the specific rank we are interested in: Assistant Professor.", "Use the COUNT function to count the number of faculty members grouped by their gender.", "Construct the SQL query to select the gender (Sex) and the count of faculty members, applying a WHERE clause to filter by the rank of 'Assistant Professor'.", "Group the results by gender to get the count of male and female assistant professors."], "gold_sql": "SELECT sex ,  count(*) FROM Faculty WHERE rank  =  'AsstProf' GROUP BY sex", "source_tables": ["faculty"], "pred_sql": "SELECT Sex, COUNT(*) FROM Faculty WHERE Rank = 'Assistant Professor' GROUP BY Sex", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the count of faculty members by gender from the 'Faculty' table, filtered by a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty members.\",\n        \"virtual_table\": \"SELECT sex ,  count(*) FROM Faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] GROUP BY sex\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the unique identifiers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.\",\n        \"virtual_table\": \"SELECT FacID FROM Faculty WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the first names, last names, and contact phone numbers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.\",\n        \"virtual_table\": \"SELECT Fname ,  Lname ,  phone FROM Faculty WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6750", "db_id": "activity_1", "question": "Who is the advisor of Linda Smith? Give me the first name and last name.", "rationale": ["Identify the Student table as it contains information about students including their advisors.", "Filter the Student table to find the record for Linda Smith by using the first name and last name.", "Select the Advisor column from the filtered result to get the advisor's ID."], "gold_sql": "SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T2.fname  =  'Linda' AND T2.lname  =  'Smith'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT Advisor FROM Student WHERE Fname = 'Linda' AND Lname = 'Smith';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of faculty members from the 'Faculty' table who hold a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.\",\n        \"virtual_table\": \"SELECT fname ,  lname FROM Faculty WHERE Rank  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first and last names of faculty members from the 'Faculty' table who hold a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.\",\n        \"virtual_table\": \"SELECT fname ,  lname FROM Faculty WHERE Rank  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the first names, last names, and contact phone numbers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.\",\n        \"virtual_table\": \"SELECT Fname ,  Lname ,  phone FROM Faculty WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6751", "db_id": "activity_1", "question": "Show the ids of students whose advisors are professors.", "rationale": ["Identify the tables involved: We need to find students and their advisors, which involves the Student and Faculty tables.", "Determine the relationship: The Student table has a column 'Advisor' that references 'FacID' in the Faculty table, indicating which faculty member is the advisor for each student.", "Construct the SQL query: We will select the distinct student IDs from the Student table where the advisor is a faculty member. This requires a JOIN between the Student and Faculty tables on the Advisor and FacID columns."], "gold_sql": "SELECT T2.StuID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.rank  =  'Professor'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT DISTINCT Student.StuID \nFROM Student \nJOIN Faculty ON Student.Advisor = Faculty.FacID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of buildings where faculty members of a specific academic rank are located. The query groups the results by building and filters to include only those buildings that have a certain number of faculty members, as indicated by the placeholders.\",\n        \"virtual_table\": \"SELECT building FROM Faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] GROUP BY building HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the count of faculty members by gender from the 'Faculty' table, filtered by a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty members.\",\n        \"virtual_table\": \"SELECT sex ,  count(*) FROM Faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] GROUP BY sex\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the first and last names of faculty members from the 'Faculty' table who hold a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.\",\n        \"virtual_table\": \"SELECT fname ,  lname FROM Faculty WHERE Rank  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6753", "db_id": "activity_1", "question": "Show first name and last name for all the students advised by Michael Goodrich.", "rationale": ["Identify the faculty member by name (Michael Goodrich) to find their unique identifier (FacID) from the Faculty table.", "Use the FacID obtained to filter students in the Student table who are advised by this faculty member.", "Select the first name (Fname) and last name (LName) of the students who meet the criteria."], "gold_sql": "SELECT T2.fname ,  T2.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.fname  =  'Michael' AND T1.lname  =  'Goodrich'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT Fname, LName FROM Student WHERE Advisor = (SELECT FacID FROM Faculty WHERE Fname = 'Michael' AND Lname = 'Goodrich')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names, last names, and contact phone numbers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.\",\n        \"virtual_table\": \"SELECT Fname ,  Lname ,  phone FROM Faculty WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first and last names of faculty members from the 'Faculty' table who hold a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.\",\n        \"virtual_table\": \"SELECT fname ,  lname FROM Faculty WHERE Rank  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the first and last names of faculty members from the 'Faculty' table who hold a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.\",\n        \"virtual_table\": \"SELECT fname ,  lname FROM Faculty WHERE Rank  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6759", "db_id": "activity_1", "question": "What are the first and last name of the faculty who has the most students?", "rationale": ["Identify the tables involved: Faculty, Faculty_Participates_in, and Participates_in.", "We need to find the faculty members who have the most students participating in activities they are involved in.", "Join the Faculty table with Faculty_Participates_in on FacID to link faculty to their activities.", "Join the Faculty_Participates_in table with Participates_in on actid to link activities to students.", "Group the results by faculty ID to count the number of students associated with each faculty member.", "Order the results by the count of students in descending order to get the faculty member with the most students at the top.", "Limit the results to 1 to get only the faculty member with the most students."], "gold_sql": "SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID ORDER BY count(*) DESC LIMIT 1", "source_tables": ["faculty", "student"], "pred_sql": "SELECT F.Fname, F.Lname\nFROM Faculty F\nJOIN Faculty_Participates_in FPI ON F.FacID = FPI.FacID\nJOIN Participates_in PI ON FPI.actid = PI.actid\nGROUP BY F.FacID\nORDER BY COUNT(PI.stuid) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of faculty members from the 'Faculty' table who hold a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.\",\n        \"virtual_table\": \"SELECT fname ,  lname FROM Faculty WHERE Rank  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first and last names of faculty members from the 'Faculty' table who hold a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.\",\n        \"virtual_table\": \"SELECT fname ,  lname FROM Faculty WHERE Rank  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the first names, last names, and contact phone numbers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.\",\n        \"virtual_table\": \"SELECT Fname ,  Lname ,  phone FROM Faculty WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6765", "db_id": "activity_1", "question": "What activities do we have?", "rationale": ["Identify the table that contains the information about activities, which is the 'Activity' table.", "Determine the column that holds the names of the activities, which is 'activity_name'.", "Construct a SQL query to select the 'activity_name' from the 'Activity' table."], "gold_sql": "SELECT activity_name FROM Activity", "source_tables": ["activity"], "pred_sql": "SELECT activity_name FROM Activity;", "hint": "\n"}
{"sample_id": "train.6766", "db_id": "activity_1", "question": "List all the activities we have.", "rationale": ["Identify the table that contains the activities, which is the 'Activity' table.", "To list all activities, we need to select all columns from the 'Activity' table.", "The SQL query to achieve this is 'SELECT * FROM Activity;'"], "gold_sql": "SELECT activity_name FROM Activity", "source_tables": ["activity"], "pred_sql": "SELECT * FROM Activity;", "hint": "\n"}
{"sample_id": "train.6780", "db_id": "activity_1", "question": "What is the first and last name of the faculty members who participated in at least one activity? For each of them, also show the number of activities they participated in.", "rationale": ["We need to find the first and last names of faculty members who participated in at least one activity.", "To do this, we will join the 'Faculty' table with the 'Faculty_Participates_in' table on the 'FacID' column.", "We will select the first name (Fname) and last name (Lname) from the 'Faculty' table.", "We also need to count the number of activities each faculty member participated in, which can be done using COUNT() on the 'actid' from the 'Faculty_Participates_in' table.", "We will group the results by the faculty member's ID, first name, and last name to ensure we get a count for each individual faculty member.", "Finally, we will use HAVING to filter the results to only include faculty members who have participated in at least one activity (i.e., COUNT(FPI.actid) > 0)."], "gold_sql": "SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID", "source_tables": ["faculty", "faculty_participates_in"], "pred_sql": "SELECT F.Fname, F.Lname, COUNT(FPI.actid) AS activity_count\nFROM Faculty F\nJOIN Faculty_Participates_in FPI ON F.FacID = FPI.FacID\nGROUP BY F.FacID, F.Fname, F.Lname\nHAVING COUNT(FPI.actid) > 0;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of faculty members from the 'Faculty' table who hold a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.\",\n        \"virtual_table\": \"SELECT fname ,  lname FROM Faculty WHERE Rank  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first and last names of faculty members from the 'Faculty' table who hold a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.\",\n        \"virtual_table\": \"SELECT fname ,  lname FROM Faculty WHERE Rank  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the first names, last names, and contact phone numbers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.\",\n        \"virtual_table\": \"SELECT Fname ,  Lname ,  phone FROM Faculty WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6781", "db_id": "activity_1", "question": "Show all the activity names and the number of faculty involved in each activity.", "rationale": ["Identify the tables needed: We need the 'Activity' table to get activity names and the 'Faculty_Participates_in' table to count faculty involved in each activity.", "Join the 'Activity' table with the 'Faculty_Participates_in' table on the 'actid' column to associate activities with their participating faculty members.", "Use a LEFT JOIN to ensure that we include all activities, even those with no faculty participation.", "Count the number of faculty members for each activity using COUNT(Faculty_Participates_in.FacID).", "Group the results by activity name to get the count of faculty for each activity."], "gold_sql": "SELECT T1.activity_name ,  count(*) FROM Activity AS T1 JOIN Faculty_participates_in AS T2 ON T1.actID  =  T2.actID GROUP BY T1.actID", "source_tables": ["activity", "faculty_participates_in"], "pred_sql": "SELECT Activity.activity_name, COUNT(Faculty_Participates_in.FacID) AS faculty_count\nFROM Activity\nLEFT JOIN Faculty_Participates_in ON Activity.actid = Faculty_Participates_in.actid\nGROUP BY Activity.activity_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the count of faculty members by gender from the 'Faculty' table, filtered by a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty members.\",\n        \"virtual_table\": \"SELECT sex ,  count(*) FROM Faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] GROUP BY sex\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of buildings where faculty members of a specific academic rank are located. The query groups the results by building and filters to include only those buildings that have a certain number of faculty members, as indicated by the placeholders.\",\n        \"virtual_table\": \"SELECT building FROM Faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] GROUP BY building HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6782", "db_id": "activity_1", "question": "How many faculty members participate in each activity? Return the activity names and the number of faculty members.", "rationale": ["Identify the tables needed: We need the 'Activity' table for activity names and the 'Faculty_Participates_in' table to count faculty participation.", "Join the 'Activity' table with the 'Faculty_Participates_in' table on the 'actid' column to link activities with faculty participation.", "Use COUNT() to count the number of faculty members participating in each activity.", "Group the results by 'Activity.activity_name' to get the count of faculty members for each activity."], "gold_sql": "SELECT T1.activity_name ,  count(*) FROM Activity AS T1 JOIN Faculty_participates_in AS T2 ON T1.actID  =  T2.actID GROUP BY T1.actID", "source_tables": ["activity", "faculty_participates_in"], "pred_sql": "SELECT Activity.activity_name, COUNT(Faculty_FacID) AS faculty_count\nFROM Activity\nLEFT JOIN Faculty_Participates_in ON Activity.actid = Faculty_Participates_in.actid\nGROUP BY Activity.activity_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the count of faculty members by gender from the 'Faculty' table, filtered by a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty members.\",\n        \"virtual_table\": \"SELECT sex ,  count(*) FROM Faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] GROUP BY sex\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of buildings where faculty members of a specific academic rank are located. The query groups the results by building and filters to include only those buildings that have a certain number of faculty members, as indicated by the placeholders.\",\n        \"virtual_table\": \"SELECT building FROM Faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] GROUP BY building HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of buildings where faculty members have their offices, grouped by building name. The results are ordered by the number of faculty members in each building, allowing users to see which buildings have the most faculty presence. The placeholder in the LIMIT clause represents the maximum number of buildings to return.\",\n        \"virtual_table\": \"SELECT building FROM Faculty GROUP BY building ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6789", "db_id": "activity_1", "question": "Show the ids for all the students who participate in an activity and are under 20.", "rationale": ["Identify the relevant tables: Participates_in and Student.", "We need to find students who participate in activities, so we will use the Participates_in table to get student IDs (stuid).", "Next, we need to filter these students based on their age, which is found in the Student table.", "We will create a subquery to select student IDs from the Student table where Age is less than 20.", "Finally, we will use this subquery in the main query to select student IDs from the Participates_in table that match the IDs from the subquery."], "gold_sql": "SELECT StuID FROM Participates_in INTERSECT SELECT StuID FROM Student WHERE age  <  20", "source_tables": ["student", "participates_in"], "pred_sql": "SELECT stuid FROM Participates_in WHERE stuid IN (SELECT StuID FROM Student WHERE Age < 20);", "hint": "\n"}
{"sample_id": "train.6795", "db_id": "activity_1", "question": "Find the first names of the faculty members who are playing Canoeing or Kayaking.", "rationale": ["Identify the tables needed: Faculty, Faculty_Participates_in, and Activity.", "We need to find faculty members who participate in specific activities (Canoeing or Kayaking).", "Join the Faculty table with Faculty_Participates_in on FacID to get the activities they participate in.", "Join the result with the Activity table on actid to filter by activity names.", "Use a WHERE clause to specify that the activity_name should be either 'Canoeing' or 'Kayaking'.", "Select the first names (Fname) of the faculty members who meet these criteria."], "gold_sql": "SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT F.Fname \nFROM Faculty F \nJOIN Faculty_Participates_in FPI ON F.FacID = FPI.FacID \nJOIN Activity A ON FPI.actid = A.actid \nWHERE A.activity_name IN ('Canoeing', 'Kayaking');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of faculty members from the 'Faculty' table who hold a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.\",\n        \"virtual_table\": \"SELECT fname ,  lname FROM Faculty WHERE Rank  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first and last names of faculty members from the 'Faculty' table who hold a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.\",\n        \"virtual_table\": \"SELECT fname ,  lname FROM Faculty WHERE Rank  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the first names, last names, and contact phone numbers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.\",\n        \"virtual_table\": \"SELECT Fname ,  Lname ,  phone FROM Faculty WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6796", "db_id": "activity_1", "question": "Which faculty members are playing either Canoeing or Kayaking? Tell me their first names.", "rationale": ["Identify the relevant tables: Faculty, Faculty_Participates_in, and Activity.", "We need to find faculty members who participate in specific activities (Canoeing or Kayaking).", "Join the Faculty table with the Faculty_Participates_in table on FacID to link faculty members with their activities.", "Join the resulting table with the Activity table on actid to access the activity names.", "Filter the results to include only those activities that are either 'Canoeing' or 'Kayaking'.", "Select the first names of the faculty members from the final result."], "gold_sql": "SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT F.Fname \nFROM Faculty F \nJOIN Faculty_Participates_in FPI ON F.FacID = FPI.FacID \nJOIN Activity A ON FPI.actid = A.actid \nWHERE A.activity_name IN ('Canoeing', 'Kayaking');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of faculty members from the 'Faculty' table who hold a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.\",\n        \"virtual_table\": \"SELECT fname ,  lname FROM Faculty WHERE Rank  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first and last names of faculty members from the 'Faculty' table who hold a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.\",\n        \"virtual_table\": \"SELECT fname ,  lname FROM Faculty WHERE Rank  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the first names, last names, and contact phone numbers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.\",\n        \"virtual_table\": \"SELECT Fname ,  Lname ,  phone FROM Faculty WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6798", "db_id": "activity_1", "question": "What are the first names of the professors who do not play Canoeing or Kayaking as activities?", "rationale": ["Identify the relevant tables: Faculty and Faculty_Participates_in.", "We need to find faculty members who do not participate in specific activities (Canoeing and Kayaking).", "First, we will find the activity IDs for Canoeing and Kayaking from the Activity table.", "Next, we will find the faculty IDs from the Faculty_Participates_in table that correspond to these activity IDs.", "Finally, we will select the first names of faculty members from the Faculty table whose IDs are not in the list of faculty IDs obtained in the previous step."], "gold_sql": "SELECT lname FROM faculty WHERE rank  =  'Professor' EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT Fname FROM Faculty WHERE FacID NOT IN (SELECT FacID FROM Faculty_Participates_in WHERE actid IN (SELECT actid FROM Activity WHERE activity_name IN ('Canoeing', 'Kayaking')));", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of faculty members from the 'Faculty' table who hold a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.\",\n        \"virtual_table\": \"SELECT fname ,  lname FROM Faculty WHERE Rank  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first and last names of faculty members from the 'Faculty' table who hold a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.\",\n        \"virtual_table\": \"SELECT fname ,  lname FROM Faculty WHERE Rank  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the first names, last names, and contact phone numbers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.\",\n        \"virtual_table\": \"SELECT Fname ,  Lname ,  phone FROM Faculty WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6801", "db_id": "activity_1", "question": "Find the ids of the students who participate in Canoeing and Kayaking.", "rationale": ["Identify the tables involved: We need to find student IDs from the Participates_in table and the activity names from the Activity table.", "Determine the relationship: The Participates_in table has a foreign key actid that links to the Activity table's actid.", "Filter the activities: We are specifically looking for students who participate in 'Canoeing' and 'Kayaking'.", "Construct the SQL query: Use a SELECT statement to get the student IDs, join the Participates_in table with the Activity table on actid, and filter the results based on the activity names."], "gold_sql": "SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  'Canoeing' INTERSECT SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  'Kayaking'", "source_tables": ["activity", "participates_in"], "pred_sql": "SELECT p.stuid \nFROM Participates_in p \nJOIN Activity a ON p.actid = a.actid \nWHERE a.activity_name IN ('Canoeing', 'Kayaking');", "hint": "\n"}
{"sample_id": "dev.95", "db_id": "car_1", "question": "Which model of the car has the minimum horsepower?", "rationale": ["Identify the relevant tables: We need to find the car model with the minimum horsepower, so we will use the 'cars_data' and 'model_list' tables.", "Determine the necessary columns: We need the 'ModelId', 'Maker', and 'Model' from the 'model_list' table, and we need to access the 'Horsepower' from the 'cars_data' table.", "Find the minimum horsepower: We can use a subquery to find the minimum horsepower from the 'cars_data' table.", "Join the tables: We will join 'model_list' and 'cars_data' on the appropriate keys to link car models with their horsepower.", "Construct the final query: We will select the model details where the horsepower matches the minimum horsepower found in the subquery."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT ModelId, Maker, Model FROM model_list WHERE Maker = (SELECT Maker FROM model_list JOIN cars_data ON model_list.ModelId = cars_data.Id ORDER BY Horsepower ASC LIMIT 1);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of cars from the 'cars_data' table that have an acceleration time greater than the acceleration time of the top specified number of cars sorted by horsepower. The placeholder in the subquery represents the number of top cars to consider for the comparison.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM CARS_DATA WHERE Accelerate  >  ( SELECT Accelerate FROM CARS_DATA ORDER BY Horsepower DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] );\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table describes the relationship between car makers and their respective car models from the 'model_list' table. The placeholders represent the identifiers for the car makers and models.\",\n        \"virtual_table\": \"SELECT Maker ,  Model FROM MODEL_LIST;\"\n    }\n}\n"}
{"sample_id": "dev.97", "db_id": "car_1", "question": "Find the model of the car whose weight is below the average weight.", "rationale": ["Identify the requirement: We need to find the model of the car whose weight is below the average weight.", "To find the average weight, we can use the AVG() function on the Weight column from the cars_data table.", "We will then compare each car's weight to this average weight in the WHERE clause.", "Finally, we will select the Model from the cars_data table where the weight is less than the average weight."], "gold_sql": "SELECT T1.model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Weight  <  (SELECT avg(Weight) FROM CARS_DATA)", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT Model FROM cars_data WHERE Weight < (SELECT AVG(Weight) FROM cars_data);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of cars from the 'cars_data' table that have an acceleration time greater than the acceleration time of the top specified number of cars sorted by horsepower. The placeholder in the subquery represents the number of top cars to consider for the comparison.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM CARS_DATA WHERE Accelerate  >  ( SELECT Accelerate FROM CARS_DATA ORDER BY Horsepower DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] );\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table describes the relationship between car makers and their respective car models from the 'model_list' table. The placeholders represent the identifiers for the car makers and models.\",\n        \"virtual_table\": \"SELECT Maker ,  Model FROM MODEL_LIST;\"\n    }\n}\n"}
{"sample_id": "dev.111", "db_id": "car_1", "question": "What is the accelerate of the car make amc hornet sportabout (sw)?", "rationale": ["Identify the relevant tables: We need to find the accelerate time of a specific car make, which involves the 'cars_data', 'car_names', 'model_list', and 'car_makers' tables.", "Determine the relationships: 'cars_data' is linked to 'car_names' through 'MakeId', 'car_names' is linked to 'model_list' through 'Model', and 'model_list' is linked to 'car_makers' through 'Maker'.", "Filter the results: We need to filter the results to only include the car make 'amc hornet sportabout (sw)'.", "Select the desired column: We want to select the 'Accelerate' column from the 'cars_data' table."], "gold_sql": "SELECT T1.Accelerate FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Make  =  'amc hornet sportabout (sw)';", "source_tables": ["cars_data", "car_names"], "pred_sql": "SELECT cars_data.Accelerate \nFROM cars_data \nJOIN car_names ON cars_data.Id = car_names.MakeId \nJOIN model_list ON car_names.Model = model_list.Model \nJOIN car_makers ON model_list.Maker = car_makers.Id \nWHERE car_names.Make = 'amc hornet sportabout (sw)';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of cars from the 'cars_data' table that have an acceleration time greater than the acceleration time of the top specified number of cars sorted by horsepower. The placeholder in the subquery represents the number of top cars to consider for the comparison.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM CARS_DATA WHERE Accelerate  >  ( SELECT Accelerate FROM CARS_DATA ORDER BY Horsepower DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] );\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table describes the relationship between car makers and their respective car models from the 'model_list' table. The placeholders represent the identifiers for the car makers and models.\",\n        \"virtual_table\": \"SELECT Maker ,  Model FROM MODEL_LIST;\"\n    }\n}\n"}
{"sample_id": "dev.112", "db_id": "car_1", "question": "How much does the car accelerate that makes amc hornet sportabout (sw)?", "rationale": ["Identify the car model and maker from the user query, which is 'amc hornet sportabout'.", "Use the 'car_names' table to find the 'MakeId' corresponding to the specified model and maker.", "Use the 'cars_data' table to retrieve the 'Accelerate' value for the car with the identified 'MakeId'."], "gold_sql": "SELECT T1.Accelerate FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Make  =  'amc hornet sportabout (sw)';", "source_tables": ["cars_data", "car_names"], "pred_sql": "SELECT Accelerate FROM cars_data WHERE Id = (SELECT MakeId FROM car_names WHERE Model = 'hornet sportabout' AND Make = 'amc');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of cars from the 'cars_data' table that have an acceleration time greater than the acceleration time of the top specified number of cars sorted by horsepower. The placeholder in the subquery represents the number of top cars to consider for the comparison.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM CARS_DATA WHERE Accelerate  >  ( SELECT Accelerate FROM CARS_DATA ORDER BY Horsepower DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] );\"\n    }\n}\n"}
{"sample_id": "dev.113", "db_id": "car_1", "question": "How many car makers are there in france?", "rationale": ["Identify the table that contains car makers, which is 'car_makers'.", "Determine the relevant column in 'car_makers' that indicates the country, which is 'Country'.", "Next, identify the table that contains country information, which is 'countries'.", "Find the column in 'countries' that corresponds to the country name, which is 'CountryName'.", "To get the count of car makers in France, we need to filter 'car_makers' by the country identifier that corresponds to France in the 'countries' table.", "Construct the SQL query to count the number of car makers where the country matches the identifier for France."], "gold_sql": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  'france';", "source_tables": ["car_makers", "countries"], "pred_sql": "SELECT COUNT(*) FROM car_makers WHERE Country = (SELECT CountryId FROM countries WHERE CountryName = 'France');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the relationship between car makers and their respective car models from the 'model_list' table. The placeholders represent the identifiers for the car makers and models.\",\n        \"virtual_table\": \"SELECT Maker ,  Model FROM MODEL_LIST;\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of cars from the 'cars_data' table that have an acceleration time greater than the acceleration time of the top specified number of cars sorted by horsepower. The placeholder in the subquery represents the number of top cars to consider for the comparison.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM CARS_DATA WHERE Accelerate  >  ( SELECT Accelerate FROM CARS_DATA ORDER BY Horsepower DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] );\"\n    }\n}\n"}
{"sample_id": "dev.121", "db_id": "car_1", "question": "What are all the makers and models?", "rationale": ["Identify the tables involved: We need to retrieve information about car makers and their models, which are stored in the 'model_list' table.", "Determine the relevant columns: The columns we need are 'Maker' and 'Model' from the 'model_list' table.", "Construct the SQL query: We will select the 'Maker' and 'Model' columns from the 'model_list' table."], "gold_sql": "SELECT Maker ,  Model FROM MODEL_LIST;", "source_tables": ["model_list"], "pred_sql": "SELECT Maker, Model FROM model_list;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the relationship between car makers and their respective car models from the 'model_list' table. The placeholders represent the identifiers for the car makers and models.\",\n        \"virtual_table\": \"SELECT Maker ,  Model FROM MODEL_LIST;\"\n    }\n}\n"}
{"sample_id": "dev.129", "db_id": "car_1", "question": "Which countries in europe have at least 3 car manufacturers?", "rationale": ["Identify the relevant tables: countries, car_makers, and continents.", "We need to filter countries that are in Europe, so we will join the countries table with the continents table to get the ContId for Europe.", "Next, we will join the car_makers table to the countries table to find out how many car manufacturers are in each country.", "We will group the results by country name to count the number of car manufacturers per country.", "Finally, we will use the HAVING clause to filter countries that have at least 3 car manufacturers."], "gold_sql": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  'europe' GROUP BY T1.CountryName HAVING count(*)  >=  3;", "source_tables": ["continents", "car_makers", "countries"], "pred_sql": "SELECT c.CountryName\nFROM countries c\nJOIN car_makers cm ON c.CountryId = cm.Country\nWHERE c.Continent = (SELECT ContId FROM continents WHERE Continent = 'Europe')\nGROUP BY c.CountryName\nHAVING COUNT(cm.Id) >= 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the relationship between car makers and their respective car models from the 'model_list' table. The placeholders represent the identifiers for the car makers and models.\",\n        \"virtual_table\": \"SELECT Maker ,  Model FROM MODEL_LIST;\"\n    }\n}\n"}
{"sample_id": "dev.130", "db_id": "car_1", "question": "What are the names of all European countries with at least 3 manufacturers?", "rationale": ["Identify the relevant tables: countries, car_makers, and continents.", "We need to filter for European countries, so we will join the countries table with the continents table to get the continent names.", "Next, we will join the car_makers table to count the number of manufacturers per country.", "We will group the results by country name to aggregate the count of manufacturers.", "Finally, we will use the HAVING clause to filter countries that have at least 3 manufacturers."], "gold_sql": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  'europe' GROUP BY T1.CountryName HAVING count(*)  >=  3;", "source_tables": ["continents", "car_makers", "countries"], "pred_sql": "SELECT c.CountryName \nFROM countries c \nJOIN car_makers cm ON c.CountryId = cm.Country \nJOIN continents con ON c.Continent = con.ContId \nWHERE con.Continent = 'Europe' \nGROUP BY c.CountryName \nHAVING COUNT(cm.Id) >= 3;", "hint": "\n"}
{"sample_id": "dev.131", "db_id": "car_1", "question": "What is the maximum horsepower and the make of the car models with 3 cylinders?", "rationale": ["Identify the relevant tables: 'cars_data' for horsepower and cylinders, and 'car_names' for the make of the car.", "We need to find the maximum horsepower for car models with 3 cylinders, so we will use the MAX() function on the 'Horsepower' column from the 'cars_data' table.", "We will filter the results to include only those cars that have 3 cylinders using a WHERE clause.", "To get the make of the car, we will join the 'cars_data' table with the 'car_names' table on the 'Id' and 'MakeId' columns.", "Finally, we will select the maximum horsepower and the corresponding make of the car."], "gold_sql": "SELECT T2.horsepower ,  T1.Make FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.cylinders  =  3 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT MAX(cars_data.Horsepower) AS MaxHorsepower, car_names.Make \nFROM cars_data \nJOIN car_names ON cars_data.Id = car_names.MakeId \nWHERE cars_data.Cylinders = 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of cars from the 'cars_data' table that have an acceleration time greater than the acceleration time of the top specified number of cars sorted by horsepower. The placeholder in the subquery represents the number of top cars to consider for the comparison.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM CARS_DATA WHERE Accelerate  >  ( SELECT Accelerate FROM CARS_DATA ORDER BY Horsepower DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] );\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table describes the relationship between car makers and their respective car models from the 'model_list' table. The placeholders represent the identifiers for the car makers and models.\",\n        \"virtual_table\": \"SELECT Maker ,  Model FROM MODEL_LIST;\"\n    }\n}\n"}
{"sample_id": "dev.141", "db_id": "car_1", "question": "Which model has the most version(make) of cars?", "rationale": ["Identify the relevant tables: We need to find the car models and their respective versions (makes). The 'model_list' table contains the models and the 'car_names' table contains the makes associated with those models.", "Join the 'model_list' and 'car_names' tables on the Model column to associate each model with its make.", "Group the results by Model to count the number of makes for each model.", "Use COUNT(*) to count the number of versions (makes) for each model.", "Order the results in descending order based on the count of versions to find the model with the most versions.", "Limit the results to 1 to get only the top model with the most versions."], "gold_sql": "SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["car_names"], "pred_sql": "SELECT Model, COUNT(*) AS VersionCount \nFROM model_list \nJOIN car_names ON model_list.Model = car_names.Model \nGROUP BY Model \nORDER BY VersionCount DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the relationship between car makers and their respective car models from the 'model_list' table. The placeholders represent the identifiers for the car makers and models.\",\n        \"virtual_table\": \"SELECT Maker ,  Model FROM MODEL_LIST;\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of cars from the 'cars_data' table that have an acceleration time greater than the acceleration time of the top specified number of cars sorted by horsepower. The placeholder in the subquery represents the number of top cars to consider for the comparison.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM CARS_DATA WHERE Accelerate  >  ( SELECT Accelerate FROM CARS_DATA ORDER BY Horsepower DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] );\"\n    }\n}\n"}
{"sample_id": "dev.142", "db_id": "car_1", "question": "What model has the most different versions?", "rationale": ["Identify the table that contains car models, which is 'model_list'.", "We need to count the number of different versions for each model, so we will use the COUNT() function.", "Group the results by the 'Model' column to aggregate the counts for each model.", "Order the results in descending order based on the count of versions to find the model with the most versions.", "Limit the results to 1 to get only the model with the highest count."], "gold_sql": "SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["car_names"], "pred_sql": "SELECT Model, COUNT(*) as VersionCount \nFROM model_list \nGROUP BY Model \nORDER BY VersionCount DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the relationship between car makers and their respective car models from the 'model_list' table. The placeholders represent the identifiers for the car makers and models.\",\n        \"virtual_table\": \"SELECT Maker ,  Model FROM MODEL_LIST;\"\n    }\n}\n"}
{"sample_id": "dev.150", "db_id": "car_1", "question": "What are the names and ids of all makers with more than 3 models?", "rationale": ["Identify the relevant tables: We need to look at the 'model_list' table for car models and the 'car_makers' table for car makers.", "Join the 'model_list' table with the 'car_makers' table on the Maker ID to get the names and IDs of the makers.", "Group the results by the Maker to count the number of models each maker has.", "Use the HAVING clause to filter the groups to only include those with more than 3 models."], "gold_sql": "SELECT T1.FullName ,  T1.Id FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >  3;", "source_tables": ["car_makers", "model_list"], "pred_sql": "SELECT ml.Maker, cm.Id\nFROM model_list ml\nJOIN car_makers cm ON ml.Maker = cm.Id\nGROUP BY ml.Maker\nHAVING COUNT(ml.Model) > 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the relationship between car makers and their respective car models from the 'model_list' table. The placeholders represent the identifiers for the car makers and models.\",\n        \"virtual_table\": \"SELECT Maker ,  Model FROM MODEL_LIST;\"\n    }\n}\n"}
{"sample_id": "dev.161", "db_id": "car_1", "question": "How many countries has more than 2 car makers ?", "rationale": ["We need to count the number of countries that have more than 2 car makers.", "To do this, we will join the 'countries' table with the 'car_makers' table on the country identifier.", "We will group the results by the country identifier to count the number of car makers per country.", "Using the HAVING clause, we will filter the groups to include only those with more than 2 car makers.", "Finally, we will count the distinct countries that meet this criterion."], "gold_sql": "select count(*) from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  2", "source_tables": ["car_makers", "countries"], "pred_sql": "SELECT COUNT(DISTINCT c.CountryId) AS CountryCount\nFROM countries c\nJOIN car_makers cm ON c.CountryId = cm.Country\nGROUP BY c.CountryId\nHAVING COUNT(cm.Id) > 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the relationship between car makers and their respective car models from the 'model_list' table. The placeholders represent the identifiers for the car makers and models.\",\n        \"virtual_table\": \"SELECT Maker ,  Model FROM MODEL_LIST;\"\n    }\n}\n"}
{"sample_id": "dev.165", "db_id": "car_1", "question": "For the cars with 4 cylinders, which model has the largest horsepower?", "rationale": ["Identify the relevant table: 'cars_data' contains the information about cars including horsepower and the number of cylinders.", "Filter the cars to only include those with 4 cylinders using the condition 'Cylinders = 4'.", "To find the model with the largest horsepower, sort the results by 'Horsepower' in descending order.", "Limit the results to 1 to get the model with the highest horsepower."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  4 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT Model, Horsepower FROM cars_data WHERE Cylinders = 4 ORDER BY Horsepower DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of cars from the 'cars_data' table that have an acceleration time greater than the acceleration time of the top specified number of cars sorted by horsepower. The placeholder in the subquery represents the number of top cars to consider for the comparison.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM CARS_DATA WHERE Accelerate  >  ( SELECT Accelerate FROM CARS_DATA ORDER BY Horsepower DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] );\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table describes the relationship between car makers and their respective car models from the 'model_list' table. The placeholders represent the identifiers for the car makers and models.\",\n        \"virtual_table\": \"SELECT Maker ,  Model FROM MODEL_LIST;\"\n    }\n}\n"}
{"sample_id": "dev.171", "db_id": "car_1", "question": "Which models are lighter than 3500 but not built by the 'Ford Motor Company'?", "rationale": ["Identify the relevant tables: model_list, car_makers, car_names, and cars_data are needed to get the car models and their weights.", "Join the model_list table with the car_makers table to get the maker information for each model.", "Join the car_names table to link the models to their respective makes.", "Join the cars_data table to access the weight of each car model.", "Filter the results to include only those models with a weight less than 3500.", "Exclude models made by 'Ford Motor Company' by adding a condition in the WHERE clause."], "gold_sql": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.Model  =  T2.Model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.Id JOIN CAR_MAKERS AS T4 ON T1.Maker  =  T4.Id WHERE T3.weight  <  3500 AND T4.FullName != 'Ford Motor Company';", "source_tables": ["car_makers", "model_list", "car_names", "cars_data"], "pred_sql": "SELECT model_list.Model \nFROM model_list \nJOIN car_makers ON model_list.Maker = car_makers.Id \nJOIN car_names ON model_list.Model = car_names.Model \nJOIN cars_data ON car_names.MakeId = cars_data.Id \nWHERE cars_data.Weight < 3500 \nAND car_makers.FullName != 'Ford Motor Company';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the relationship between car makers and their respective car models from the 'model_list' table. The placeholders represent the identifiers for the car makers and models.\",\n        \"virtual_table\": \"SELECT Maker ,  Model FROM MODEL_LIST;\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of cars from the 'cars_data' table that have an acceleration time greater than the acceleration time of the top specified number of cars sorted by horsepower. The placeholder in the subquery represents the number of top cars to consider for the comparison.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM CARS_DATA WHERE Accelerate  >  ( SELECT Accelerate FROM CARS_DATA ORDER BY Horsepower DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] );\"\n    }\n}\n"}
{"sample_id": "dev.175", "db_id": "car_1", "question": "Which are the car makers which produce at least 2 models and more than 3 car makers ? List the id and the maker .", "rationale": ["Identify the relevant tables: car_makers and model_list.", "We need to find car makers that produce at least 2 models, so we will join car_makers with model_list on the Maker ID.", "Group the results by car maker ID and name to aggregate the models produced by each maker.", "Use the HAVING clause to filter groups that have at least 2 models.", "Additionally, we need to ensure that there are more than 3 distinct car makers in the result set."], "gold_sql": "select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker group by t1.id having count(*)  >=  2 intersect select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker join car_names as t3 on t2.model  =  t3.model group by t1.id having count(*)  >  3;", "source_tables": ["car_makers", "car_names", "model_list"], "pred_sql": "SELECT cm.Id, cm.Maker \nFROM car_makers cm \nJOIN model_list ml ON cm.Id = ml.Maker \nGROUP BY cm.Id, cm.Maker \nHAVING COUNT(ml.Model) >= 2 \nAND COUNT(DISTINCT cm.Id) > 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the relationship between car makers and their respective car models from the 'model_list' table. The placeholders represent the identifiers for the car makers and models.\",\n        \"virtual_table\": \"SELECT Maker ,  Model FROM MODEL_LIST;\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of cars from the 'cars_data' table that have an acceleration time greater than the acceleration time of the top specified number of cars sorted by horsepower. The placeholder in the subquery represents the number of top cars to consider for the comparison.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM CARS_DATA WHERE Accelerate  >  ( SELECT Accelerate FROM CARS_DATA ORDER BY Horsepower DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] );\"\n    }\n}\n"}
{"sample_id": "dev.176", "db_id": "car_1", "question": "What are the ids and makers of all car makers that produce at least 2 models and make more than 3 cars?", "rationale": ["Identify the relevant tables: car_makers, model_list, car_names, and cars_data.", "We need to join these tables to get the necessary information about car makers and their models.", "Join car_makers with model_list on the Maker ID to get the models produced by each maker.", "Join model_list with car_names to link the models to their respective makes.", "Join car_names with cars_data to count the number of cars produced by each maker.", "Group the results by car maker ID and name to aggregate the counts.", "Use HAVING clause to filter for car makers that produce at least 2 models and have more than 3 cars."], "gold_sql": "SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >=  2 INTERSECT SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker JOIN CAR_NAMES AS T3 ON T2.model  =  T3.model GROUP BY T1.Id HAVING count(*)  >  3;", "source_tables": ["car_makers", "car_names", "model_list"], "pred_sql": "SELECT cm.Id, cm.Maker \nFROM car_makers cm \nJOIN model_list ml ON cm.Id = ml.Maker \nJOIN car_names cn ON ml.Model = cn.Model \nJOIN cars_data cd ON cn.MakeId = cd.Id \nGROUP BY cm.Id, cm.Maker \nHAVING COUNT(DISTINCT ml.Model) >= 2 AND COUNT(cd.Id) > 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the relationship between car makers and their respective car models from the 'model_list' table. The placeholders represent the identifiers for the car makers and models.\",\n        \"virtual_table\": \"SELECT Maker ,  Model FROM MODEL_LIST;\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of cars from the 'cars_data' table that have an acceleration time greater than the acceleration time of the top specified number of cars sorted by horsepower. The placeholder in the subquery represents the number of top cars to consider for the comparison.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM CARS_DATA WHERE Accelerate  >  ( SELECT Accelerate FROM CARS_DATA ORDER BY Horsepower DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] );\"\n    }\n}\n"}
{"sample_id": "dev.526", "db_id": "student_transcripts_tracking", "question": "What are the names and ids of every course with less than 2 sections?", "rationale": ["Identify the relevant tables: Courses and Sections.", "We need to find courses with less than 2 sections, so we will join the Courses table with the Sections table on the course_id.", "Use a LEFT JOIN to ensure we include courses that may not have any sections.", "Group the results by course_id and course_name to aggregate the section counts for each course.", "Use the HAVING clause to filter groups where the count of sections is less than 2."], "gold_sql": "SELECT T1.course_name ,  T1.course_id FROM Courses AS T1 JOIN Sections AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_id HAVING count(*)  <=  2", "source_tables": ["courses", "sections"], "pred_sql": "SELECT c.course_id, c.course_name \nFROM Courses c \nLEFT JOIN Sections s ON c.course_id = s.course_id \nGROUP BY c.course_id, c.course_name \nHAVING COUNT(s.section_id) < 2;", "hint": "\n"}
{"sample_id": "dev.534", "db_id": "student_transcripts_tracking", "question": "What are the first, middle, and last names, along with the ids, of all students who enrolled in 2 degree programs in one semester?", "rationale": ["Identify the relevant tables: Students and Student_Enrolment.", "We need to select the first, middle, and last names of students, along with their IDs, so we will select 'student_id', 'first_name', 'middle_name', and 'last_name' from the Students table.", "We need to join the Students table with the Student_Enrolment table to access the degree program information for each student.", "Group the results by 'student_id' to aggregate the enrolment records for each student.", "Use the HAVING clause to filter the groups to only those students who have enrolled in exactly 2 distinct degree programs."], "gold_sql": "SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  2", "source_tables": ["student_enrolment", "students"], "pred_sql": "SELECT s.student_id, s.first_name, s.middle_name, s.last_name\nFROM Students s\nJOIN Student_Enrolment se ON s.student_id = se.student_id\nGROUP BY s.student_id\nHAVING COUNT(DISTINCT se.degree_program_id) = 2;", "hint": "\n"}
{"sample_id": "dev.535", "db_id": "student_transcripts_tracking", "question": "Who is enrolled in a Bachelor degree program? List the first name, middle name, last name.", "rationale": ["Identify the relevant tables: Students, Student_Enrolment, and Degree_Programs.", "We need to join these tables to connect students with their enrolment records and the degree programs they are enrolled in.", "The Students table contains the names of the students, while the Degree_Programs table contains the degree program details.", "We are specifically looking for students enrolled in a Bachelor degree program, so we will filter the results based on the degree_summary_name column in the Degree_Programs table.", "Use a SQL SELECT statement to retrieve the first name, middle name, and last name of the students who meet the criteria."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  'Bachelor'", "source_tables": ["student_enrolment", "degree_programs", "students"], "pred_sql": "SELECT s.first_name, s.middle_name, s.last_name\nFROM Students s\nJOIN Student_Enrolment se ON s.student_id = se.student_id\nJOIN Degree_Programs dp ON se.degree_program_id = dp.degree_program_id\nWHERE dp.degree_summary_name LIKE '%Bachelor%';", "hint": "\n"}
{"sample_id": "dev.539", "db_id": "student_transcripts_tracking", "question": "Find the program which most number of students are enrolled in. List both the id and the summary.", "rationale": ["Identify the relevant tables: Degree_Programs and Student_Enrolment are needed to find the degree program with the most students enrolled.", "Join the Degree_Programs table with the Student_Enrolment table on the degree_program_id to associate students with their respective programs.", "Group the results by degree_program_id to count the number of students enrolled in each program.", "Order the results by the count of students in descending order to find the program with the most enrollments.", "Limit the results to 1 to get only the program with the highest number of students."], "gold_sql": "SELECT T1.degree_program_id ,  T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_program_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "degree_programs"], "pred_sql": "SELECT dp.degree_program_id, dp.degree_summary_name\nFROM Degree_Programs dp\nJOIN Student_Enrolment se ON dp.degree_program_id = se.degree_program_id\nGROUP BY dp.degree_program_id\nORDER BY COUNT(se.student_id) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of how many times each student course appears in the 'Transcript_Contents' table, grouped by the course identifier. The results are ordered by the count in descending order, allowing users to see the most frequently recorded courses. The placeholder in the LIMIT clause represents the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT count(*) ,  student_course_id FROM Transcript_Contents GROUP BY student_course_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.541", "db_id": "student_transcripts_tracking", "question": "Which student has enrolled for the most times in any program? List the id, first name, middle name, last name, the number of enrollments and student id.", "rationale": ["Identify the relevant tables: Students and Student_Enrolment.", "We need to count the number of enrollments for each student, so we will join the Students table with the Student_Enrolment table on the student_id.", "Use COUNT() function to count the number of enrollments for each student.", "Group the results by student_id to aggregate the counts for each student.", "Order the results by the count of enrollments in descending order to find the student with the most enrollments.", "Limit the results to 1 to get only the student with the highest number of enrollments."], "gold_sql": "SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "students"], "pred_sql": "SELECT s.student_id, s.first_name, s.middle_name, s.last_name, COUNT(se.student_enrolment_id) AS number_of_enrollments\nFROM Students s\nJOIN Student_Enrolment se ON s.student_id = se.student_id\nGROUP BY s.student_id\nORDER BY number_of_enrollments DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "dev.547", "db_id": "student_transcripts_tracking", "question": "What's the name of the course with most number of enrollments?", "rationale": ["Identify the relevant tables: Courses, Student_Enrolment_Courses, and Transcript_Contents are needed to find the course with the most enrollments.", "Use the Transcript_Contents table to count how many times each course appears, which indicates the number of enrollments.", "Join the Courses table to get the course names corresponding to the course IDs.", "Group the results by course ID to aggregate the counts of enrollments for each course.", "Order the results by the count of enrollments in descending order to get the course with the most enrollments at the top.", "Limit the results to 1 to get only the course with the highest number of enrollments."], "gold_sql": "SELECT  T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["courses", "student_enrolment_courses"], "pred_sql": "SELECT C.course_name \nFROM Courses C \nJOIN Student_Enrolment_Courses SEC ON C.course_id = SEC.course_id \nJOIN Transcript_Contents TC ON SEC.student_course_id = TC.student_course_id \nGROUP BY C.course_id \nORDER BY COUNT(TC.transcript_id) DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of how many times each student course appears in the 'Transcript_Contents' table, grouped by the course identifier. The results are ordered by the count in descending order, allowing users to see the most frequently recorded courses. The placeholder in the LIMIT clause represents the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT count(*) ,  student_course_id FROM Transcript_Contents GROUP BY student_course_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.548", "db_id": "student_transcripts_tracking", "question": "What is the name of the course with the most students enrolled?", "rationale": ["We need to find the course with the most students enrolled, which implies counting the number of enrollments for each course.", "The hint provides a virtual table that counts occurrences of student courses in the 'Transcript_Contents' table, which is useful for determining how many students are enrolled in each course.", "To get the course name, we need to join the 'Courses' table with the 'Student_Enrolment_Courses' table and the 'Transcript_Contents' table.", "We will group the results by course ID to count the number of enrollments for each course.", "Finally, we will order the results by the count of enrollments in descending order and limit the results to 1 to get the course with the most students."], "gold_sql": "SELECT  T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["courses", "student_enrolment_courses"], "pred_sql": "SELECT C.course_name \nFROM Courses C \nJOIN Student_Enrolment_Courses SEC ON C.course_id = SEC.course_id \nJOIN Transcript_Contents TC ON SEC.student_course_id = TC.student_course_id \nGROUP BY C.course_id \nORDER BY COUNT(TC.transcript_id) DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of how many times each student course appears in the 'Transcript_Contents' table, grouped by the course identifier. The results are ordered by the count in descending order, allowing users to see the most frequently recorded courses. The placeholder in the LIMIT clause represents the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT count(*) ,  student_course_id FROM Transcript_Contents GROUP BY student_course_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.550", "db_id": "student_transcripts_tracking", "question": "What are the last name of the students who live in North Carolina but have not registered in any degree programs?", "rationale": ["Identify the relevant table: Students, which contains the last names of students and their address information.", "Identify the Addresses table to filter students based on their state of residence (North Carolina).", "Use a subquery to find all address_ids in North Carolina from the Addresses table.", "Use another subquery to find all student_ids that are enrolled in any degree programs from the Student_Enrolment table.", "Combine these conditions to select last names of students who live in North Carolina and are not in the list of enrolled students."], "gold_sql": "SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  'NorthCarolina' EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id", "source_tables": ["addresses", "student_enrolment", "students"], "pred_sql": "SELECT last_name \nFROM Students \nWHERE current_address_id IN (\n    SELECT address_id \n    FROM Addresses \n    WHERE state_province_county = 'North Carolina'\n) \nAND student_id NOT IN (\n    SELECT student_id \n    FROM Student_Enrolment\n);", "hint": "\n"}
{"sample_id": "dev.554", "db_id": "student_transcripts_tracking", "question": "What is the mobile phone number of the student named Timmothy Ward ?", "rationale": ["Identify the relevant table: The question asks for the mobile phone number of a student, which is found in the 'Students' table.", "Determine the columns needed: We need the 'cell_mobile_number' column to get the mobile phone number.", "Filter the results: We need to filter the results based on the student's name, specifically the first name 'Timmothy' and last name 'Ward'.", "Construct the SQL query: Using the SELECT statement to retrieve the 'cell_mobile_number' from the 'Students' table with the specified conditions."], "gold_sql": "select cell_mobile_number from students where first_name  =  'timmothy' and last_name  =  'ward'", "source_tables": ["students"], "pred_sql": "SELECT cell_mobile_number FROM Students WHERE first_name = 'Timmothy' AND last_name = 'Ward';", "hint": "\n"}
{"sample_id": "dev.561", "db_id": "student_transcripts_tracking", "question": "Which address holds the most number of students currently? List the address id and all lines.", "rationale": ["We need to find the address that holds the most number of students currently.", "The relevant tables are 'Addresses' and 'Students'.", "We will join the 'Addresses' table with the 'Students' table on the current address ID.", "We will group the results by address ID and the address lines to count the number of students associated with each address.", "We will order the results by the count of students in descending order to get the address with the most students at the top.", "Finally, we will limit the results to 1 to get only the address with the highest count."], "gold_sql": "SELECT T1.address_id ,  T1.line_1 ,  T1.line_2 FROM Addresses AS T1 JOIN Students AS T2 ON T1.address_id  =  T2.current_address_id GROUP BY T1.address_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "students"], "pred_sql": "SELECT a.address_id, a.line_1, a.line_2, a.line_3 \nFROM Addresses a \nJOIN Students s ON a.address_id = s.current_address_id \nGROUP BY a.address_id, a.line_1, a.line_2, a.line_3 \nORDER BY COUNT(s.student_id) DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "dev.578", "db_id": "student_transcripts_tracking", "question": "What are the different addresses that have students living there?", "rationale": ["Identify the relevant tables: We need to look at the Addresses table to get the address details and the Students table to find out which students live at those addresses.", "Determine the relationship: Students have a current address which is linked to the Addresses table through the current_address_id.", "Construct the SQL query: We will select distinct addresses from the Addresses table that have students associated with them by joining the Addresses table with the Students table on the address_id and current_address_id fields."], "gold_sql": "SELECT count(DISTINCT current_address_id) FROM Students", "source_tables": ["students"], "pred_sql": "SELECT DISTINCT a.* FROM Addresses a JOIN Students s ON a.address_id = s.current_address_id;", "hint": "\n"}
{"sample_id": "dev.581", "db_id": "student_transcripts_tracking", "question": "Describe the section h.", "rationale": ["The user wants to describe a specific section identified by the name 'h'.", "To retrieve information about a section, we need to select all columns from the Sections table.", "We will use a WHERE clause to filter the results to only include the section with the name 'h'."], "gold_sql": "SELECT section_description FROM Sections WHERE section_name  =  'h'", "source_tables": ["sections"], "pred_sql": "SELECT * FROM Sections WHERE section_name = 'h';", "hint": "\n"}
{"sample_id": "dev.705", "db_id": "world_1", "question": "How many countries have governments that are republics?", "rationale": ["The user wants to know how many countries have governments that are republics.", "We can use the provided virtual table that counts countries based on their government form.", "The relevant virtual table is: SELECT count(*) FROM country WHERE GovernmentForm = [PLACEHOLDER-TYPE:STRING].", "We replace the placeholder with 'Republic' to specify the type of government we are interested in."], "gold_sql": "SELECT count(*) FROM country WHERE GovernmentForm  =  'Republic'", "source_tables": ["country"], "pred_sql": "SELECT count(*) FROM country WHERE GovernmentForm = 'Republic'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM country WHERE GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of countries, displaying their names, surface areas, and the year they gained independence. The results are ordered by the population of the countries, and the number of entries returned is limited by a specified placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total population of countries grouped by their government form, filtering for those government forms where the average life expectancy exceeds a specified threshold. The placeholder in the HAVING clause represents the minimum average life expectancy value.\",\n        \"virtual_table\": \"SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.723", "db_id": "world_1", "question": "How many people live in Asia, and what is the largest GNP among them?", "rationale": ["Identify the continent of interest, which is Asia.", "We need to calculate the total population of countries in Asia, so we will use the SUM function on the Population column.", "We also need to find the largest GNP among these countries, so we will use the MAX function on the GNP column.", "The query will filter the countries by the continent 'Asia' to ensure we are only considering relevant countries."], "gold_sql": "SELECT sum(Population) ,  max(GNP) FROM country WHERE Continent  =  'Asia'", "source_tables": ["country"], "pred_sql": "SELECT sum(Population) AS TotalPopulation, max(GNP) AS LargestGNP FROM country WHERE Continent = 'Asia'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the average Gross National Product (GNP) and the total population of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.\",\n        \"virtual_table\": \"SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total population and average life expectancy of countries grouped by continent. It filters the results to only include continents where the average life expectancy is below a specified threshold. The placeholder in the HAVING clause represents the life expectancy limit.\",\n        \"virtual_table\": \"SELECT sum(Population) ,  avg(LifeExpectancy) ,  Continent FROM country GROUP BY Continent HAVING avg(LifeExpectancy)  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total population of countries grouped by their government form, filtering for those government forms where the average life expectancy exceeds a specified threshold. The placeholder in the HAVING clause represents the minimum average life expectancy value.\",\n        \"virtual_table\": \"SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.724", "db_id": "world_1", "question": "What is the average life expectancy in African countries that are republics?", "rationale": ["Identify the relevant tables: We need to use the 'country' table to get the average life expectancy and filter by continent and government form.", "Determine the conditions: We are interested in African countries, so we will filter by 'Continent = 'Africa''. Additionally, we need to filter for countries that are republics, so we will add 'GovernmentForm = 'Republic''.", "Select the average life expectancy: We will use the AVG() function to calculate the average life expectancy of the filtered countries.", "Construct the SQL query: Combine the SELECT statement with the WHERE conditions to form the complete SQL query."], "gold_sql": "SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  'Africa' AND GovernmentForm  =  'Republic'", "source_tables": ["country"], "pred_sql": "SELECT avg(LifeExpectancy) FROM country WHERE Continent = 'Africa' AND GovernmentForm = 'Republic'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total population and average life expectancy of countries grouped by continent. It filters the results to only include continents where the average life expectancy is below a specified threshold. The placeholder in the HAVING clause represents the life expectancy limit.\",\n        \"virtual_table\": \"SELECT sum(Population) ,  avg(LifeExpectancy) ,  Continent FROM country GROUP BY Continent HAVING avg(LifeExpectancy)  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total population of countries grouped by their government form, filtering for those government forms where the average life expectancy exceeds a specified threshold. The placeholder in the HAVING clause represents the minimum average life expectancy value.\",\n        \"virtual_table\": \"SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the average Gross National Product (GNP) and the total population of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.\",\n        \"virtual_table\": \"SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.725", "db_id": "world_1", "question": "Give the average life expectancy for countries in Africa which are republics?", "rationale": ["Identify the relevant table: The 'country' table contains the necessary information about countries, including their continent, government form, and life expectancy.", "Filter for the continent: We need to focus on countries in Africa, so we will add a WHERE clause to filter for 'Continent = 'Africa'\".", "Filter for the government form: We are specifically interested in republics, so we will add another condition to the WHERE clause: 'GovernmentForm = 'Republic'\".", "Select the average life expectancy: We will use the AVG() function to calculate the average life expectancy of the filtered countries."], "gold_sql": "SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  'Africa' AND GovernmentForm  =  'Republic'", "source_tables": ["country"], "pred_sql": "SELECT avg(LifeExpectancy) FROM country WHERE Continent = 'Africa' AND GovernmentForm = 'Republic'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total population and average life expectancy of countries grouped by continent. It filters the results to only include continents where the average life expectancy is below a specified threshold. The placeholder in the HAVING clause represents the life expectancy limit.\",\n        \"virtual_table\": \"SELECT sum(Population) ,  avg(LifeExpectancy) ,  Continent FROM country GROUP BY Continent HAVING avg(LifeExpectancy)  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total population of countries grouped by their government form, filtering for those government forms where the average life expectancy exceeds a specified threshold. The placeholder in the HAVING clause represents the minimum average life expectancy value.\",\n        \"virtual_table\": \"SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the average Gross National Product (GNP) and the total population of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.\",\n        \"virtual_table\": \"SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.731", "db_id": "world_1", "question": "Give the mean GNP and total population of nations which are considered US territory.", "rationale": ["Identify the required data: mean GNP and total population of nations considered US territory.", "Refer to the provided hint about the virtual table that calculates average GNP and total population based on government form.", "Use the structure of the virtual table: SELECT avg(GNP), sum(population) FROM country WHERE GovernmentForm = [PLACEHOLDER-TYPE:STRING].", "Replace the placeholder with 'US territory' to filter the countries accordingly."], "gold_sql": "SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  'US Territory'", "source_tables": ["country"], "pred_sql": "SELECT avg(GNP), sum(Population) FROM country WHERE GovernmentForm = 'US territory'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the average Gross National Product (GNP) and the total population of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.\",\n        \"virtual_table\": \"SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of countries, displaying their names, surface areas, and the year they gained independence. The results are ordered by the population of the countries, and the number of entries returned is limited by a specified placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the total population and average surface area of countries located in a specific continent that have a surface area greater than a specified value. The placeholders in the WHERE clause represent the continent's name and the minimum surface area.\",\n        \"virtual_table\": \"select sum(population) ,  avg(surfacearea) from country where continent  =  [PLACEHOLDER-TYPE:STRING] and surfacearea  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.735", "db_id": "world_1", "question": "How many different forms of governments are there in Africa?", "rationale": ["Identify the need to count distinct forms of government in Africa.", "Refer to the provided hint about the virtual table that counts distinct government forms in countries within a specific continent.", "Replace the placeholder in the virtual table with 'Africa' to specify the continent of interest."], "gold_sql": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  'Africa'", "source_tables": ["country"], "pred_sql": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent = 'Africa'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of distinct government forms present in countries located within a specific continent. The placeholder in the WHERE clause represents the continent's name.\",\n        \"virtual_table\": \"SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM country WHERE GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total population of countries grouped by their government form, filtering for those government forms where the average life expectancy exceeds a specified threshold. The placeholder in the HAVING clause represents the minimum average life expectancy value.\",\n        \"virtual_table\": \"SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.754", "db_id": "world_1", "question": "What are the countries where either English or Dutch is the official language ?", "rationale": ["Identify the relevant tables: We need to look at the 'country' and 'countrylanguage' tables to find countries with specific official languages.", "Join the tables: We will join the 'country' table with the 'countrylanguage' table on the 'Code' and 'CountryCode' fields to get the country names along with their languages.", "Filter for official languages: We need to filter the results to include only those rows where 'IsOfficial' is 'T' (true) to ensure we are only considering official languages.", "Specify the languages: We will add a condition to check if the language is either 'English' or 'Dutch'.", "Select distinct country names: Finally, we will select distinct country names to avoid duplicates in the result."], "gold_sql": "select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  'english' and isofficial  =  't' union select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  'dutch' and isofficial  =  't'", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT DISTINCT c.Name \nFROM country c \nJOIN countrylanguage cl ON c.Code = cl.CountryCode \nWHERE cl.IsOfficial = 'T' AND (cl.Language = 'English' OR cl.Language = 'Dutch');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.\",\n        \"virtual_table\": \"SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of the number of countries and the maximum percentage of speakers for a specific language from the 'countrylanguage' table. The placeholder in the WHERE clause represents the language name being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,   max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING] GROUP BY CountryCode\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of the number of countries and the maximum percentage of speakers for a specific language from the 'countrylanguage' table. The placeholder in the WHERE clause represents the language name being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,   max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING] GROUP BY CountryCode\"\n    }\n}\n"}
{"sample_id": "dev.755", "db_id": "world_1", "question": "Which countries have either English or Dutch as an official language?", "rationale": ["The question asks for countries that have either English or Dutch as an official language.", "To find this information, we need to join the 'country' table with the 'countrylanguage' table on the 'CountryCode'.", "We will filter the results to include only those rows where the 'Language' is either 'English' or 'Dutch'.", "Additionally, we need to ensure that the language is marked as official, which is indicated by 'IsOfficial' being 'T'.", "Finally, we select the distinct names of the countries that meet these criteria."], "gold_sql": "SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English' AND IsOfficial  =  'T' UNION SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'Dutch' AND IsOfficial  =  'T'", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT DISTINCT c.Name FROM country c JOIN countrylanguage cl ON c.Code = cl.CountryCode WHERE cl.Language IN ('English', 'Dutch') AND cl.IsOfficial = 'T';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.\",\n        \"virtual_table\": \"SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of the number of countries and the maximum percentage of speakers for a specific language from the 'countrylanguage' table. The placeholder in the WHERE clause represents the language name being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,   max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING] GROUP BY CountryCode\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of the number of countries and the maximum percentage of speakers for a specific language from the 'countrylanguage' table. The placeholder in the WHERE clause represents the language name being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,   max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING] GROUP BY CountryCode\"\n    }\n}\n"}
{"sample_id": "dev.758", "db_id": "world_1", "question": "Which languages are spoken by only one country in republic governments?", "rationale": ["Identify the languages spoken by only one country.", "To find languages spoken by only one country, we can use a subquery that groups by CountryCode and filters those with a count of 1.", "Join the countrylanguage table with the country table to access the GovernmentForm column.", "Filter the results to include only those countries with a 'Republic' government form."], "gold_sql": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.GovernmentForm  =  'Republic' GROUP BY T2.Language HAVING COUNT(*)  =  1", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT cl.Language \nFROM countrylanguage cl \nJOIN country c ON cl.CountryCode = c.Code \nWHERE cl.CountryCode IN (\n    SELECT CountryCode \n    FROM countrylanguage \n    GROUP BY CountryCode \n    HAVING COUNT(*) = 1\n) \nAND c.GovernmentForm = 'Republic';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.\",\n        \"virtual_table\": \"SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of the number of countries and the maximum percentage of speakers for a specific language from the 'countrylanguage' table. The placeholder in the WHERE clause represents the language name being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,   max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING] GROUP BY CountryCode\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of the number of countries and the maximum percentage of speakers for a specific language from the 'countrylanguage' table. The placeholder in the WHERE clause represents the language name being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,   max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING] GROUP BY CountryCode\"\n    }\n}\n"}
{"sample_id": "dev.759", "db_id": "world_1", "question": "What languages are only used by a single country with a republic government?", "rationale": ["Identify the relevant tables: We need to use the 'countrylanguage' table to find languages and the 'country' table to check the government form.", "Join the 'countrylanguage' table with the 'country' table on the CountryCode to access both language and government form information.", "Group the results by language to count how many countries speak each language.", "Use the HAVING clause to filter for languages that are spoken by only one country (COUNT(DISTINCT c.Code) = 1) and that country has a republic government (c.GovernmentForm = 'Republic')."], "gold_sql": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.GovernmentForm  =  'Republic' GROUP BY T2.Language HAVING COUNT(*)  =  1", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT cl.Language\nFROM countrylanguage cl\nJOIN country c ON cl.CountryCode = c.Code\nGROUP BY cl.Language\nHAVING COUNT(DISTINCT c.Code) = 1 AND c.GovernmentForm = 'Republic';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.\",\n        \"virtual_table\": \"SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM country WHERE GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of countries, displaying their names, surface areas, and the year they gained independence. The results are ordered by the population of the countries, and the number of entries returned is limited by a specified placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.760", "db_id": "world_1", "question": "Find the city with the largest population that uses English.", "rationale": ["Identify the language of interest, which is 'English'.", "Use the 'countrylanguage' table to find the country codes where English is spoken.", "Filter the 'city' table to find cities that belong to those country codes.", "Order the results by population in descending order to find the city with the largest population.", "Limit the results to 1 to get only the city with the largest population."], "gold_sql": "SELECT T1.Name ,  T1.Population FROM city AS T1 JOIN countrylanguage AS T2 ON T1.CountryCode  =  T2.CountryCode WHERE T2.Language  =  'English' ORDER BY T1.Population DESC LIMIT 1", "source_tables": ["city", "countrylanguage"], "pred_sql": "SELECT Name FROM city WHERE CountryCode IN (SELECT CountryCode FROM countrylanguage WHERE Language = 'English') ORDER BY Population DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of the number of countries and the maximum percentage of speakers for a specific language from the 'countrylanguage' table. The placeholder in the WHERE clause represents the language name being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,   max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING] GROUP BY CountryCode\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of the number of countries and the maximum percentage of speakers for a specific language from the 'countrylanguage' table. The placeholder in the WHERE clause represents the language name being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,   max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING] GROUP BY CountryCode\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.\",\n        \"virtual_table\": \"SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.766", "db_id": "world_1", "question": "What is the total number of people living in the nations that do not use English?", "rationale": ["Identify the countries that do not use English as an official language.", "Use the virtual table provided to find the country codes of countries where English is spoken.", "The virtual table indicates using EXCEPT to exclude countries where English is an official language.", "Once we have the country codes that do not use English, we can sum the populations of these countries from the 'country' table.", "The final SQL query sums the population of countries whose codes are not in the list of countries that use English."], "gold_sql": "SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English')", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT SUM(Population) FROM country WHERE Code NOT IN (SELECT CountryCode FROM countrylanguage WHERE Language = 'English')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.\",\n        \"virtual_table\": \"SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of the number of countries and the maximum percentage of speakers for a specific language from the 'countrylanguage' table. The placeholder in the WHERE clause represents the language name being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,   max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING] GROUP BY CountryCode\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of the number of countries and the maximum percentage of speakers for a specific language from the 'countrylanguage' table. The placeholder in the WHERE clause represents the language name being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,   max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING] GROUP BY CountryCode\"\n    }\n}\n"}
{"sample_id": "dev.774", "db_id": "world_1", "question": "What are the African countries that have a  population less than any country in Asia?", "rationale": ["Identify the countries in Africa by filtering the 'country' table where Continent is 'Africa'.", "Determine the maximum population of countries in Asia by using a subquery that selects the maximum population from the 'country' table where Continent is 'Asia'.", "Combine these two conditions to find African countries whose population is less than the maximum population of any Asian country."], "gold_sql": "SELECT Name FROM country WHERE Continent  =  'Africa'  AND population  <  (SELECT max(population) FROM country WHERE Continent  =  'Asia')", "source_tables": ["country"], "pred_sql": "SELECT Name FROM country WHERE Continent = 'Africa' AND Population < (SELECT MAX(Population) FROM country WHERE Continent = 'Asia');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total population and average life expectancy of countries grouped by continent. It filters the results to only include continents where the average life expectancy is below a specified threshold. The placeholder in the HAVING clause represents the life expectancy limit.\",\n        \"virtual_table\": \"SELECT sum(Population) ,  avg(LifeExpectancy) ,  Continent FROM country GROUP BY Continent HAVING avg(LifeExpectancy)  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of countries, displaying their names, surface areas, and the year they gained independence. The results are ordered by the population of the countries, and the number of entries returned is limited by a specified placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the total population and average surface area of countries located in a specific continent that have a surface area greater than a specified value. The placeholders in the WHERE clause represent the continent's name and the minimum surface area.\",\n        \"virtual_table\": \"select sum(population) ,  avg(surfacearea) from country where continent  =  [PLACEHOLDER-TYPE:STRING] and surfacearea  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.777", "db_id": "world_1", "question": "What are the Asian countries which have a population larger than that of any country in Africa?", "rationale": ["Identify the countries in Asia by filtering the 'country' table for the continent 'Asia'.", "Determine the population of these Asian countries by selecting the 'Population' column.", "To find countries in Asia with a population larger than any country in Africa, we need to compare their populations.", "Use a subquery to find the maximum population of countries in Africa by filtering the 'country' table for the continent 'Africa' and selecting the maximum value of the 'Population' column.", "Combine the results by using a WHERE clause to filter Asian countries where their population is greater than the maximum population found in the African countries."], "gold_sql": "SELECT Name FROM country WHERE Continent  =  'Asia'  AND population  >  (SELECT min(population) FROM country WHERE Continent  =  'Africa')", "source_tables": ["country"], "pred_sql": "SELECT Name FROM country WHERE Continent = 'Asia' AND Population > (SELECT MAX(Population) FROM country WHERE Continent = 'Africa');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the total population and average surface area of countries located in a specific continent that have a surface area greater than a specified value. The placeholders in the WHERE clause represent the continent's name and the minimum surface area.\",\n        \"virtual_table\": \"select sum(population) ,  avg(surfacearea) from country where continent  =  [PLACEHOLDER-TYPE:STRING] and surfacearea  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of countries, displaying their names, surface areas, and the year they gained independence. The results are ordered by the population of the countries, and the number of entries returned is limited by a specified placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total population of countries grouped by their government form, filtering for those government forms where the average life expectancy exceeds a specified threshold. The placeholder in the HAVING clause represents the minimum average life expectancy value.\",\n        \"virtual_table\": \"SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.778", "db_id": "world_1", "question": "What are the country codes for countries that do not speak English?", "rationale": ["Identify the requirement: We need to find country codes for countries that do not speak English.", "Use the 'countrylanguage' table to find all country codes where English is spoken.", "We can use a subquery to select all CountryCodes from the 'countrylanguage' table where the Language is 'English'.", "Then, we can use the NOT IN clause to filter out these country codes from the 'country' table.", "Finally, select the Code from the 'country' table that meets the criteria."], "gold_sql": "SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  'English'", "source_tables": ["countrylanguage"], "pred_sql": "SELECT Code FROM country WHERE Code NOT IN (SELECT CountryCode FROM countrylanguage WHERE Language = 'English')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.\",\n        \"virtual_table\": \"SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of the number of countries and the maximum percentage of speakers for a specific language from the 'countrylanguage' table. The placeholder in the WHERE clause represents the language name being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,   max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING] GROUP BY CountryCode\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of the number of countries and the maximum percentage of speakers for a specific language from the 'countrylanguage' table. The placeholder in the WHERE clause represents the language name being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,   max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING] GROUP BY CountryCode\"\n    }\n}\n"}
{"sample_id": "dev.786", "db_id": "world_1", "question": "Which unique cities are in Asian countries where Chinese is the official language ?", "rationale": ["Identify the tables needed: city, country, and countrylanguage.", "We need to find unique cities, so we will use SELECT DISTINCT on city.Name.", "Join the city table with the country table on the CountryCode to get country details.", "Join the country table with the countrylanguage table to filter by language.", "Filter the results to include only cities in Asian countries by checking the Continent column in the country table.", "Filter the results to include only those countries where Chinese is an official language by checking the Language and IsOfficial columns in the countrylanguage table."], "gold_sql": "select distinct t3.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode join city as t3 on t1.code  =  t3.countrycode where t2.isofficial  =  't' and t2.language  =  'chinese' and t1.continent  =  'asia'", "source_tables": ["country", "city", "countrylanguage"], "pred_sql": "SELECT DISTINCT city.Name \nFROM city \nJOIN country ON city.CountryCode = country.Code \nJOIN countrylanguage ON country.Code = countrylanguage.CountryCode \nWHERE country.Continent = 'Asia' \nAND countrylanguage.Language = 'Chinese' \nAND countrylanguage.IsOfficial = 'T';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.\",\n        \"virtual_table\": \"SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of the number of countries and the maximum percentage of speakers for a specific language from the 'countrylanguage' table. The placeholder in the WHERE clause represents the language name being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,   max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING] GROUP BY CountryCode\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of the number of countries and the maximum percentage of speakers for a specific language from the 'countrylanguage' table. The placeholder in the WHERE clause represents the language name being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,   max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING] GROUP BY CountryCode\"\n    }\n}\n"}
{"sample_id": "dev.789", "db_id": "world_1", "question": "Give the name, year of independence, and surface area of the country that has the lowest population.", "rationale": ["Identify the required fields: Name, year of independence (IndepYear), and surface area (SurfaceArea) from the country table.", "Determine the condition: We need the country with the lowest population, which means we need to order the results by the Population column in ascending order.", "Use the ORDER BY clause to sort the countries by their population.", "Limit the results to only one entry using the LIMIT clause to get the country with the lowest population."], "gold_sql": "SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT 1", "source_tables": ["country"], "pred_sql": "SELECT Name, IndepYear, SurfaceArea FROM country ORDER BY Population LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of countries, displaying their names, surface areas, and the year they gained independence. The results are ordered by the population of the countries, and the number of entries returned is limited by a specified placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of country names along with their surface areas, sorted in descending order by surface area. The placeholder in the LIMIT clause allows the user to specify the number of countries to retrieve.\",\n        \"virtual_table\": \"SELECT Name ,  SurfaceArea FROM country ORDER BY SurfaceArea DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the total population and the average surface area of countries from the 'country' table that are located in a specific continent and have a surface area greater than a specified value. The placeholders in the WHERE clause represent the continent's name and the minimum surface area.\",\n        \"virtual_table\": \"select sum(population) ,  avg(surfacearea) from country where continent  =  [PLACEHOLDER-TYPE:STRING] and surfacearea  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.793", "db_id": "world_1", "question": "What are the names of countries that speak more than 2 languages, as well as how many languages they speak?", "rationale": ["Identify the relevant tables: We need to use the 'country' table to get country names and the 'countrylanguage' table to count the languages spoken in each country.", "Join the 'country' and 'countrylanguage' tables on the 'Code' and 'CountryCode' columns respectively to associate each country with its languages.", "Group the results by country code to aggregate the language counts for each country.", "Use the COUNT function to count the number of languages spoken in each country.", "Filter the results using the HAVING clause to include only those countries that speak more than 2 languages."], "gold_sql": "SELECT COUNT(T2.Language) ,  T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Name HAVING COUNT(*)  >  2", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT c.Name, COUNT(cl.Language) AS LanguageCount \nFROM country c \nJOIN countrylanguage cl ON c.Code = cl.CountryCode \nGROUP BY c.Code \nHAVING COUNT(cl.Language) > 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.\",\n        \"virtual_table\": \"SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of the number of countries and the maximum percentage of speakers for a specific language from the 'countrylanguage' table. The placeholder in the WHERE clause represents the language name being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,   max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING] GROUP BY CountryCode\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of the number of countries and the maximum percentage of speakers for a specific language from the 'countrylanguage' table. The placeholder in the WHERE clause represents the language name being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,   max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING] GROUP BY CountryCode\"\n    }\n}\n"}
{"sample_id": "dev.797", "db_id": "world_1", "question": "What are the different government forms and what is the total population of each for government forms that have an average life expectancy greater than 72?", "rationale": ["Identify the columns needed: GovernmentForm and Population.", "We need to sum the population for each government form, so we will use SUM(Population).", "We need to filter the results based on average life expectancy greater than 72, so we will include a WHERE clause for LifeExpectancy.", "Group the results by GovernmentForm to get the total population for each form of government.", "Construct the SQL query using the identified components."], "gold_sql": "SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  72", "source_tables": ["country"], "pred_sql": "SELECT GovernmentForm, SUM(Population) AS TotalPopulation \nFROM country \nWHERE LifeExpectancy > 72 \nGROUP BY GovernmentForm;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total population of countries grouped by their government form, filtering for those government forms where the average life expectancy exceeds a specified threshold. The placeholder in the HAVING clause represents the minimum average life expectancy value.\",\n        \"virtual_table\": \"SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total population and average life expectancy of countries grouped by continent. It filters the results to only include continents where the average life expectancy is below a specified threshold. The placeholder in the HAVING clause represents the life expectancy limit.\",\n        \"virtual_table\": \"SELECT sum(Population) ,  avg(LifeExpectancy) ,  Continent FROM country GROUP BY Continent HAVING avg(LifeExpectancy)  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the average Gross National Product (GNP) and the total population of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.\",\n        \"virtual_table\": \"SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.812", "db_id": "world_1", "question": "What are the cities whose population is between 160000 and 900000?", "rationale": ["Identify the table to query: The 'city' table contains the population data.", "Determine the condition for filtering: We need cities with a population between 160000 and 900000.", "Construct the SQL query using the SELECT statement to retrieve all columns from the 'city' table where the population meets the specified range."], "gold_sql": "SELECT name FROM city WHERE Population BETWEEN 160000 AND 900000", "source_tables": ["city"], "pred_sql": "SELECT * FROM city WHERE Population BETWEEN '160000' AND '900000';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the total population and average surface area of countries located in a specific continent that have a surface area greater than a specified value. The placeholders in the WHERE clause represent the continent's name and the minimum surface area.\",\n        \"virtual_table\": \"select sum(population) ,  avg(surfacearea) from country where continent  =  [PLACEHOLDER-TYPE:STRING] and surfacearea  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the average Gross National Product (GNP) and the total population of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.\",\n        \"virtual_table\": \"SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total population of countries grouped by their government form, filtering for those government forms where the average life expectancy exceeds a specified threshold. The placeholder in the HAVING clause represents the minimum average life expectancy value.\",\n        \"virtual_table\": \"SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.820", "db_id": "world_1", "question": "What are the codes of countries where Spanish is spoken by the largest percentage of people?", "rationale": ["Identify the language of interest: Spanish.", "We need to find the country codes where Spanish is spoken by the largest percentage of people.", "Use the 'countrylanguage' table to filter for the language 'Spanish'.", "To find the maximum percentage of speakers for Spanish, we can use a subquery that selects the maximum percentage from the 'countrylanguage' table for Spanish.", "Finally, we select the CountryCode from the 'countrylanguage' table where the language is Spanish and the percentage matches the maximum percentage found in the subquery."], "gold_sql": "SELECT CountryCode ,  max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  'Spanish' GROUP BY CountryCode", "source_tables": ["countrylanguage"], "pred_sql": "SELECT CountryCode FROM countrylanguage WHERE Language = 'Spanish' AND Percentage = (SELECT max(Percentage) FROM countrylanguage WHERE Language = 'Spanish')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.\",\n        \"virtual_table\": \"SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of the number of countries and the maximum percentage of speakers for a specific language from the 'countrylanguage' table. The placeholder in the WHERE clause represents the language name being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,   max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING] GROUP BY CountryCode\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of the number of countries and the maximum percentage of speakers for a specific language from the 'countrylanguage' table. The placeholder in the WHERE clause represents the language name being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,   max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING] GROUP BY CountryCode\"\n    }\n}\n"}
{"sample_id": "dev.821", "db_id": "world_1", "question": "Return the codes of countries for which Spanish is the predominantly spoken language.", "rationale": ["Identify the table to query: countrylanguage.", "Determine the relevant columns: CountryCode and Language.", "Filter for the language 'Spanish'.", "Check if Spanish is the official language by filtering IsOfficial = 'Yes'.", "Construct the SQL query to select the CountryCode for countries where Spanish is predominantly spoken."], "gold_sql": "SELECT CountryCode ,  max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  'Spanish' GROUP BY CountryCode", "source_tables": ["countrylanguage"], "pred_sql": "SELECT CountryCode FROM countrylanguage WHERE Language = 'Spanish' AND IsOfficial = 'Yes'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.\",\n        \"virtual_table\": \"SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of the number of countries and the maximum percentage of speakers for a specific language from the 'countrylanguage' table. The placeholder in the WHERE clause represents the language name being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,   max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING] GROUP BY CountryCode\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of the number of countries and the maximum percentage of speakers for a specific language from the 'countrylanguage' table. The placeholder in the WHERE clause represents the language name being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,   max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING] GROUP BY CountryCode\"\n    }\n}\n"}
{"sample_id": "dev.920", "db_id": "dog_kennels", "question": "What is the average age of the dogs who have gone through any treatments?", "rationale": ["Identify the relevant tables: Dogs and Treatments.", "We need to find the average age of dogs that have undergone treatments, so we will join the Dogs table with the Treatments table on the dog_id.", "Select the age of the dogs from the Dogs table and calculate the average using the AVG() function.", "Return the average age as a single result."], "gold_sql": "SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )", "source_tables": ["dogs", "treatments"], "pred_sql": "SELECT AVG(D.age) AS average_age\nFROM Dogs D\nJOIN Treatments T ON D.dog_id = T.dog_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a unique list of breed codes and size codes for dogs from the 'Dogs' table. The placeholders represent the breed and size categories associated with the dogs.\",\n        \"virtual_table\": \"SELECT DISTINCT breed_code ,  size_code FROM dogs\"\n    }\n}\n"}
{"sample_id": "dev.936", "db_id": "dog_kennels", "question": "Which owner has paid for the most treatments on his or her dogs? List the owner id and last name.", "rationale": ["Identify the relevant tables: Owners, Dogs, and Treatments.", "Join the Owners table with the Dogs table on owner_id to link owners to their dogs.", "Join the resulting table with the Treatments table on dog_id to link treatments to the respective dogs.", "Group the results by owner_id and last_name to aggregate the treatment counts for each owner.", "Count the number of treatments for each owner using COUNT(Treatments.treatment_id).", "Order the results in descending order to find the owner with the most treatments.", "Limit the results to 1 to get only the top owner."], "gold_sql": "SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["owners", "dogs", "treatments"], "pred_sql": "SELECT Owners.owner_id, Owners.last_name\nFROM Owners\nJOIN Dogs ON Owners.owner_id = Dogs.owner_id\nJOIN Treatments ON Dogs.dog_id = Treatments.dog_id\nGROUP BY Owners.owner_id, Owners.last_name\nORDER BY COUNT(Treatments.treatment_id) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a unique list of breed codes and size codes for dogs from the 'Dogs' table. The placeholders represent the breed and size categories associated with the dogs.\",\n        \"virtual_table\": \"SELECT DISTINCT breed_code ,  size_code FROM dogs\"\n    }\n}\n"}
{"sample_id": "dev.942", "db_id": "dog_kennels", "question": "Which professionals have done at least two types of treatments? List the professional id and cell phone.", "rationale": ["Identify the relevant tables: Professionals and Treatments.", "We need to find professionals who have administered treatments, so we will join the Professionals table with the Treatments table on the professional_id.", "We want to count the number of distinct treatment types each professional has administered, so we will use COUNT(DISTINCT t.treatment_type_code).", "To ensure we only get professionals who have done at least two types of treatments, we will use the HAVING clause with a condition that the count is greater than or equal to 2.", "Finally, we will select the professional_id and cell_number from the Professionals table."], "gold_sql": "SELECT T1.professional_id ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  2", "source_tables": ["professionals", "treatments"], "pred_sql": "SELECT p.professional_id, p.cell_number\nFROM Professionals p\nJOIN Treatments t ON p.professional_id = t.professional_id\nGROUP BY p.professional_id\nHAVING COUNT(DISTINCT t.treatment_type_code) >= 2;", "hint": "\n"}
{"sample_id": "dev.944", "db_id": "dog_kennels", "question": "What are the first name and last name of the professionals who have done treatment with cost below average?", "rationale": ["Identify the relevant tables: Professionals and Treatments.", "We need to select the first name and last name of professionals, so we will select 'first_name' and 'last_name' from the Professionals table.", "To find professionals who have done treatments, we need to join the Professionals table with the Treatments table on the 'professional_id'.", "We need to filter the results to include only those treatments where the cost is below the average cost of treatments.", "To calculate the average cost of treatments, we will use a subquery that selects the average of 'cost_of_treatment' from the Treatments table."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T1.last_name FROM Professionals AS T1 JOIN Treatments AS T2 WHERE cost_of_treatment  <  ( SELECT avg(cost_of_treatment) FROM Treatments )", "source_tables": ["professionals", "treatments"], "pred_sql": "SELECT Professionals.first_name, Professionals.last_name\nFROM Professionals\nJOIN Treatments ON Professionals.professional_id = Treatments.professional_id\nWHERE Treatments.cost_of_treatment < (SELECT AVG(cost_of_treatment) FROM Treatments);", "hint": "\n"}
{"sample_id": "dev.950", "db_id": "dog_kennels", "question": "List each owner's first name, last name, and the size of his for her dog.", "rationale": ["We need to list each owner's first name and last name, which are found in the Owners table.", "We also need the size of the dog, which is found in the Sizes table.", "To get the size of the dog, we need to join the Dogs table with the Sizes table using the size_code.", "We also need to join the Owners table with the Dogs table using the owner_id to link each dog to its owner.", "The final query will select the first name and last name from the Owners table and the size description from the Sizes table."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id", "source_tables": ["owners", "dogs"], "pred_sql": "SELECT Owners.first_name, Owners.last_name, Sizes.size_description \nFROM Owners \nJOIN Dogs ON Owners.owner_id = Dogs.owner_id \nJOIN Sizes ON Dogs.size_code = Sizes.size_code;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a unique list of breed codes and size codes for dogs from the 'Dogs' table. The placeholders represent the breed and size categories associated with the dogs.\",\n        \"virtual_table\": \"SELECT DISTINCT breed_code ,  size_code FROM dogs\"\n    }\n}\n"}
{"sample_id": "dev.951", "db_id": "dog_kennels", "question": "What are each owner's first name, last name, and the size of their dog?", "rationale": ["Identify the required information: owner's first name, last name, and the size of their dog.", "The relevant tables are Owners, Dogs, and Sizes.", "Owners table contains the owner's first and last names.", "Dogs table contains the size_code that links to the Sizes table.", "Sizes table contains the size_description that describes the size of the dog.", "To get the desired information, we need to join these tables based on their relationships: Owners to Dogs (owner_id) and Dogs to Sizes (size_code).", "Construct the SQL query using SELECT to retrieve the required fields and JOIN to connect the tables."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id", "source_tables": ["owners", "dogs"], "pred_sql": "SELECT Owners.first_name, Owners.last_name, Sizes.size_description \nFROM Owners \nJOIN Dogs ON Owners.owner_id = Dogs.owner_id \nJOIN Sizes ON Dogs.size_code = Sizes.size_code;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a unique list of breed codes and size codes for dogs from the 'Dogs' table. The placeholders represent the breed and size categories associated with the dogs.\",\n        \"virtual_table\": \"SELECT DISTINCT breed_code ,  size_code FROM dogs\"\n    }\n}\n"}
{"sample_id": "dev.958", "db_id": "dog_kennels", "question": "What are the arriving date and the departing date of the dogs who have gone through a treatment?", "rationale": ["Identify the relevant tables: Dogs and Treatments.", "We need the arriving date and departing date of dogs, which are in the Dogs table.", "We also need to filter dogs that have gone through a treatment, which is indicated by the Treatments table.", "To link the Dogs and Treatments tables, we can use the dog_id column, which is common to both tables.", "Construct the SQL query to select the date_arrived and date_departed from the Dogs table, joining it with the Treatments table on dog_id."], "gold_sql": "SELECT DISTINCT T1.date_arrived ,  T1.date_departed FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id", "source_tables": ["dogs", "treatments"], "pred_sql": "SELECT d.date_arrived, d.date_departed \nFROM Dogs d \nJOIN Treatments t ON d.dog_id = t.dog_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a unique list of breed codes and size codes for dogs from the 'Dogs' table. The placeholders represent the breed and size categories associated with the dogs.\",\n        \"virtual_table\": \"SELECT DISTINCT breed_code ,  size_code FROM dogs\"\n    }\n}\n"}
{"sample_id": "dev.961", "db_id": "dog_kennels", "question": "Who owns the youngest dog? Give me his or her last name.", "rationale": ["Identify the relevant tables: We need information from the Dogs table to find the youngest dog and the Owners table to get the owner's last name.", "Determine the criteria: We want to find the youngest dog, which means we need to order the dogs by age in ascending order.", "Join the Dogs and Owners tables: We need to join these tables on the owner_id to link each dog to its owner.", "Select the last name of the owner: After joining, we will select the last name of the owner associated with the youngest dog.", "Limit the results: Since we only want the owner of the youngest dog, we will limit the results to 1."], "gold_sql": "SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )", "source_tables": ["owners", "dogs"], "pred_sql": "SELECT Owners.last_name \nFROM Dogs \nJOIN Owners ON Dogs.owner_id = Owners.owner_id \nORDER BY Dogs.age ASC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a unique list of breed codes and size codes for dogs from the 'Dogs' table. The placeholders represent the breed and size categories associated with the dogs.\",\n        \"virtual_table\": \"SELECT DISTINCT breed_code ,  size_code FROM dogs\"\n    }\n}\n"}
{"sample_id": "dev.997", "db_id": "dog_kennels", "question": "Find the distinct breed type and size type combinations for dogs.", "rationale": ["Identify the tables involved: The 'Dogs' table contains the breed and size information for each dog.", "Determine the required output: We need distinct combinations of breed types and size types.", "Use the SELECT statement to retrieve the breed_code and size_code from the Dogs table.", "Apply the DISTINCT keyword to ensure that only unique combinations of breed_code and size_code are returned."], "gold_sql": "SELECT DISTINCT breed_code ,  size_code FROM dogs", "source_tables": ["dogs"], "pred_sql": "SELECT DISTINCT breed_code, size_code FROM Dogs;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a unique list of breed codes and size codes for dogs from the 'Dogs' table. The placeholders represent the breed and size categories associated with the dogs.\",\n        \"virtual_table\": \"SELECT DISTINCT breed_code ,  size_code FROM dogs\"\n    }\n}\n"}
{"sample_id": "dev.999", "db_id": "dog_kennels", "question": "What are each professional's first name and description of the treatment they have performed?", "rationale": ["Identify the required information: professional's first name and treatment description.", "Determine the relevant tables: Professionals and Treatment_Types.", "Recognize that the Treatments table links Professionals and Treatment_Types through their respective IDs.", "Construct a SQL query that selects the first name from the Professionals table and the treatment description from the Treatment_Types table.", "Use JOIN clauses to connect the Treatments table with the Professionals and Treatment_Types tables based on their foreign key relationships."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code", "source_tables": ["professionals", "treatments", "treatment_types"], "pred_sql": "SELECT Professionals.first_name, Treatment_Types.treatment_type_description\nFROM Treatments\nJOIN Professionals ON Treatments.professional_id = Professionals.professional_id\nJOIN Treatment_Types ON Treatments.treatment_type_code = Treatment_Types.treatment_type_code;", "hint": "\n"}
