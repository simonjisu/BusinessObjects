{"sample_id": "train.64", "db_id": "student_assessment", "question": "List the id of students who attended some courses?", "rationale": ["We need to list the IDs of students who have attended courses.", "The relevant table for this information is 'Student_Course_Attendance', which contains the 'student_id' of students who attended courses.", "To get unique student IDs, we will use the DISTINCT keyword to avoid duplicates in the results."], "gold_sql": "SELECT student_id FROM student_course_attendance", "source_tables": ["student_course_attendance"], "pred_sql": "SELECT DISTINCT student_id FROM Student_Course_Attendance;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the identifiers of students who have attended courses from the 'Student_Course_Attendance' table. The placeholder in the SELECT clause represents the unique identifier for each student.\"\n}\n"}
{"sample_id": "train.68", "db_id": "student_assessment", "question": "What details do we have on the students who registered for courses most recently?", "rationale": ["Identify the relevant tables: Students and Student_Course_Registrations.", "We need to retrieve details about students and their registration dates for courses.", "Join the Students table with the Student_Course_Registrations table on the student_id field to get the necessary details.", "Select the student_id, student_details, and registration_date from the joined tables.", "Order the results by registration_date in descending order to get the most recent registrations first.", "Limit the results to a reasonable number (e.g., 10) to avoid overwhelming output."], "gold_sql": "SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT 1", "source_tables": ["student_course_registrations", "students"], "pred_sql": "SELECT s.student_id, s.student_details, scr.registration_date \nFROM Students s \nJOIN Student_Course_Registrations scr ON s.student_id = scr.student_id \nORDER BY scr.registration_date DESC \nLIMIT 10;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the limit on the number of results returned can be specified using a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.76", "db_id": "student_assessment", "question": "What is the id of the candidate who most recently accessed the course?", "rationale": ["Identify the relevant tables: Candidates and Student_Course_Attendance.", "We need to find the candidate who most recently accessed a course, which implies looking for the latest attendance record.", "The Student_Course_Attendance table contains the student_id and date_of_attendance, so we will order this table by date_of_attendance in descending order to get the most recent attendance.", "We will limit the results to 1 to get only the most recent record.", "Next, we will use the student_id from the most recent attendance to find the corresponding candidate_id in the Candidates table.", "The final query will select the candidate_id from Candidates where the candidate_id matches the student_id from the most recent attendance."], "gold_sql": "SELECT candidate_id FROM candidate_assessments ORDER BY assessment_date DESC LIMIT 1", "source_tables": ["candidate_assessments"], "pred_sql": "SELECT candidate_id FROM Candidates WHERE candidate_id IN (SELECT student_id FROM Student_Course_Attendance ORDER BY date_of_attendance DESC LIMIT 1)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of student identifiers from the 'Student_Course_Attendance' table for a specific course. The results are ordered by the date of attendance in descending order, and the number of results returned is limited by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.78", "db_id": "student_assessment", "question": "What are the details of the student who registered for the most number of courses?", "rationale": ["Identify the relevant tables: Students and Student_Course_Registrations.", "We need to join these tables on the student_id to get the details of the students along with their course registrations.", "Group the results by student_id to count the number of courses each student is registered for.", "Order the results in descending order based on the count of course registrations to find the student with the most registrations.", "Limit the results to 1 to get only the student with the highest number of course registrations."], "gold_sql": "SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_course_registrations", "students"], "pred_sql": "SELECT s.student_id, s.student_details \nFROM Students s \nJOIN Student_Course_Registrations scr ON s.student_id = scr.student_id \nGROUP BY s.student_id, s.student_details \nORDER BY COUNT(scr.course_id) DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the limit on the number of results returned can be specified using a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.82", "db_id": "student_assessment", "question": "For each course id, how many students are registered and what are the course names?", "rationale": ["We need to retrieve the course ID and course names along with the count of registered students for each course.", "To achieve this, we will use a SELECT statement to get the course_id and course_name from the Courses table.", "We will also need to count the number of students registered for each course, which can be done using the COUNT() function on the student_id from the Student_Course_Registrations table.", "To link the Courses table with the Student_Course_Registrations table, we will use a LEFT JOIN on the course_id.", "We will group the results by course_id and course_name to ensure we get the count of students for each course."], "gold_sql": "SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id", "source_tables": ["courses", "student_course_registrations", "students"], "pred_sql": "SELECT Courses.course_id, COUNT(Student_Course_Registrations.student_id) AS student_count, Courses.course_name \nFROM Courses \nLEFT JOIN Student_Course_Registrations ON Courses.course_id = Student_Course_Registrations.course_id \nGROUP BY Courses.course_id, Courses.course_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the number of results returned is limited by a specified placeholder value.\"\n}\n"}
{"sample_id": "train.89", "db_id": "student_assessment", "question": "What is the id of the student who most recently registered course 301?", "rationale": ["Identify the relevant table: The question pertains to student registrations for a specific course, so we will use the 'Student_Course_Registrations' table.", "Filter by course_id: We need to filter the records to only include those where the course_id is '301'.", "Order by registration_date: To find the most recent registration, we will order the results by the 'registration_date' in descending order.", "Limit the results: Since we only need the most recent registration, we will limit the results to 1."], "gold_sql": "SELECT student_id FROM student_course_attendance WHERE course_id = 301 ORDER BY date_of_attendance DESC LIMIT 1", "source_tables": ["student_course_attendance"], "pred_sql": "SELECT student_id FROM Student_Course_Registrations WHERE course_id = '301' ORDER BY registration_date DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the number of results returned is limited by a specified placeholder value.\"\n}\n"}
{"sample_id": "train.92", "db_id": "student_assessment", "question": "What are the different cities where people live?", "rationale": ["Identify the relevant table: The question asks about cities where people live, which relates to the Addresses table.", "Select the appropriate column: The 'city' column in the Addresses table contains the city names.", "Use DISTINCT to avoid duplicate city names: Since we want different cities, we will use the DISTINCT keyword to ensure each city is listed only once."], "gold_sql": "SELECT DISTINCT T1.city FROM addresses AS T1 JOIN people_addresses AS T2 ON T1.address_id = T2.address_id", "source_tables": ["addresses", "people_addresses"], "pred_sql": "SELECT DISTINCT city FROM Addresses;", "hint": "\n"}
{"sample_id": "train.105", "db_id": "student_assessment", "question": "List the id of students who registered course statistics in the order of registration date.", "rationale": ["Identify the relevant table: 'Student_Course_Registrations' contains the information about student registrations for courses.", "Filter the registrations to only include those for the course named 'Statistics'.", "Select the 'student_id' from the filtered results.", "Order the results by 'registration_date' to get the students in the order they registered."], "gold_sql": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = 'statistics' ORDER BY T2.registration_date", "source_tables": ["courses", "student_course_registrations"], "pred_sql": "SELECT student_id FROM Student_Course_Registrations WHERE course_id = (SELECT course_id FROM Courses WHERE course_name = 'Statistics') ORDER BY registration_date;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the limit on the number of results returned can be specified using a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.106", "db_id": "student_assessment", "question": "What are the ids of the students who registered course statistics by order of registration date?", "rationale": ["Identify the relevant table: 'Student_Course_Registrations' contains the registration details of students for various courses.", "Filter the registrations to only include those for the course 'Statistics'.", "Select the 'student_id' from the filtered results.", "Order the results by 'registration_date' to get the ids in the order they registered."], "gold_sql": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = 'statistics' ORDER BY T2.registration_date", "source_tables": ["courses", "student_course_registrations"], "pred_sql": "SELECT student_id FROM Student_Course_Registrations WHERE course_id = (SELECT course_id FROM Courses WHERE course_name = 'Statistics') ORDER BY registration_date;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the limit on the number of results returned can be specified using a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.387", "db_id": "flight_1", "question": "Show origins of all flights with destination Honolulu.", "rationale": ["Identify the relevant table: The 'flight' table contains the information about flights, including their origins and destinations.", "Determine the required information: We need to find the origins of all flights that have Honolulu as their destination.", "Construct the SQL query: We will select the 'origin' column from the 'flight' table where the 'destination' is 'Honolulu'.", "Group the results by 'origin' to ensure we get unique origins.", "Order the results by the count of flights from each origin in descending order to prioritize the most common origins."], "gold_sql": "SELECT origin FROM Flight WHERE destination  =  'Honolulu'", "source_tables": ["flight"], "pred_sql": "SELECT origin FROM flight WHERE destination = 'Honolulu' GROUP BY origin ORDER BY COUNT(*) DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of flight origins from the 'Flight' table, grouped by the origin location. The results are ordered by the number of flights departing from each origin in descending order, with a limit on the number of origins returned as specified by the placeholder.\"\n}\n"}
{"sample_id": "train.390", "db_id": "flight_1", "question": "What are the departure and arrival dates of all flights from LA to Honolulu?", "rationale": ["Identify the relevant table: The 'flight' table contains the information about flights, including departure and arrival dates.", "Determine the required columns: We need the 'departure_date' and 'arrival_date' for the flights.", "Specify the conditions: We want flights that originate from 'LA' and have 'Honolulu' as their destination.", "Construct the SQL query: Use a SELECT statement to retrieve the specified columns from the 'flight' table with the appropriate WHERE clause."], "gold_sql": "SELECT departure_date ,  arrival_date FROM Flight WHERE origin  =  'Los Angeles' AND destination  =  'Honolulu'", "source_tables": ["flight"], "pred_sql": "SELECT departure_date, arrival_date FROM flight WHERE origin = 'LA' AND destination = 'Honolulu';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of flight origins from the 'Flight' table, grouped by the origin location. The results are ordered by the number of flights departing from each origin in descending order, with a limit on the number of origins returned as specified by the placeholder.\"\n}\n"}
{"sample_id": "train.400", "db_id": "flight_1", "question": "What are the numbers of the shortest flights?", "rationale": ["Identify the relevant table: The 'flight' table contains information about flights, including their distances.", "Determine the required information: We need the flight numbers of the shortest flights.", "Sort the flights by distance: Use ORDER BY distance ASC to sort the flights in ascending order based on their distance.", "Limit the results: Use LIMIT 1 to get only the shortest flight."], "gold_sql": "SELECT flno FROM Flight ORDER BY distance ASC LIMIT 3", "source_tables": ["flight"], "pred_sql": "SELECT flno FROM flight ORDER BY distance ASC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average distance and average price of flights originating from a specific location. The placeholder in the WHERE clause represents the origin of the flights.\"\n}\n"}
{"sample_id": "train.408", "db_id": "flight_1", "question": "What place has the most flights coming from there?", "rationale": ["Identify the relevant table: The 'flight' table contains information about flights, including their origin.", "Determine the required information: We need to find the place (origin) with the most flights.", "Use the COUNT function: To count the number of flights from each origin, we will use COUNT(*) and group the results by the 'origin' column.", "Group the results: Use GROUP BY to group the results by the 'origin' column to get the count of flights for each origin.", "Order the results: To find the origin with the most flights, we will order the results in descending order based on the flight count.", "Limit the results: Since we only want the place with the most flights, we will limit the results to 1."], "gold_sql": "SELECT origin FROM Flight GROUP BY origin ORDER BY count(*) DESC LIMIT 1", "source_tables": ["flight"], "pred_sql": "SELECT origin, COUNT(*) AS flight_count\nFROM flight\nGROUP BY origin\nORDER BY flight_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the starting locations of flights from the 'Flight' table that are headed to a specific destination. The placeholder in the WHERE clause represents the destination's name.\"\n}\n"}
{"sample_id": "train.416", "db_id": "flight_1", "question": "What is the name of each aircraft and how many flights does each one complete?", "rationale": ["Identify the tables involved: 'aircraft' for aircraft names and 'flight' for flight details.", "We need to count the number of flights for each aircraft, which requires a join between the 'aircraft' and 'flight' tables on the aircraft ID ('aid').", "Use a LEFT JOIN to ensure we include all aircraft, even those with no flights.", "Select the aircraft name and count the number of flights (using COUNT function) for each aircraft.", "Group the results by aircraft name to get the count for each individual aircraft."], "gold_sql": "SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid", "source_tables": ["aircraft", "flight"], "pred_sql": "SELECT aircraft.name, COUNT(flight.flno) AS flight_count \nFROM aircraft \nLEFT JOIN flight ON aircraft.aid = flight.aid \nGROUP BY aircraft.name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of flight origins from the 'Flight' table, grouped by the origin location. The results are ordered by the number of flights departing from each origin in descending order, with a limit on the number of origins returned as specified by the placeholder.\"\n}\n"}
{"sample_id": "train.429", "db_id": "flight_1", "question": "Show names for all employees who do not have certificate of Boeing 737-800.", "rationale": ["Identify the table that contains employee names, which is the 'employee' table.", "We need to find employees who do not have a certificate for a specific aircraft, 'Boeing 737-800'.", "To do this, we first need to find the aircraft ID (aid) for 'Boeing 737-800' from the 'aircraft' table.", "Next, we will find all employee IDs (eid) from the 'certificate' table that are associated with this aircraft ID.", "Finally, we will select the names of employees from the 'employee' table whose IDs are not in the list of IDs obtained from the previous step."], "gold_sql": "SELECT name FROM Employee EXCEPT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  'Boeing 737-800'", "source_tables": ["employee", "certificate", "aircraft"], "pred_sql": "SELECT name FROM employee WHERE eid NOT IN (SELECT eid FROM certificate WHERE aid = (SELECT aid FROM aircraft WHERE name = 'Boeing 737-800'));", "hint": "\n"}
{"sample_id": "train.433", "db_id": "flight_1", "question": "Show the name and distance of the aircrafts with more than 5000 distance and which at least 5 people have its certificate.", "rationale": ["We need to select the name and distance of aircrafts.", "The aircrafts must have a distance greater than 5000.", "We also need to ensure that at least 5 people have a certificate for each aircraft.", "To achieve this, we will join the 'aircraft' table with the 'certificate' table on the aircraft ID (aid).", "We will group the results by the aircraft ID to count the number of certificates for each aircraft.", "Finally, we will use the HAVING clause to filter the results based on the distance and the count of certificates."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  5000 GROUP BY T1.aid ORDER BY count(*)  >=  5", "source_tables": ["aircraft", "certificate"], "pred_sql": "SELECT a.name, a.distance \nFROM aircraft a \nJOIN certificate c ON a.aid = c.aid \nGROUP BY a.aid \nHAVING a.distance > 5000 AND COUNT(c.eid) >= 5;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average distance and average price of flights originating from a specific location. The placeholder in the WHERE clause represents the origin of the flights.\"\n}\n"}
{"sample_id": "train.434", "db_id": "flight_1", "question": "What is the name and distance of every aircraft that can cover a distance of more than 5000 and which at least 5 people can fly?", "rationale": ["Identify the relevant table: The question pertains to aircraft, so we will focus on the 'aircraft' table.", "Determine the conditions: We need aircraft that can cover a distance of more than 5000.", "Select the required columns: We need the 'name' and 'distance' of the aircraft that meet the distance condition.", "Construct the SQL query: Using the SELECT statement to retrieve 'name' and 'distance' from the 'aircraft' table with the specified condition."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  5000 GROUP BY T1.aid ORDER BY count(*)  >=  5", "source_tables": ["aircraft", "certificate"], "pred_sql": "SELECT name, distance FROM aircraft WHERE distance > 5000", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average distance and average price of flights originating from a specific location. The placeholder in the WHERE clause represents the origin of the flights.\"\n}\n"}
{"sample_id": "train.437", "db_id": "flight_1", "question": "What is the salary and name of the employee who has the most number of certificates on aircrafts with distance more than 5000?", "rationale": ["Identify the relevant tables: employee, certificate, and aircraft.", "We need to find employees who have certificates for aircrafts with a distance greater than 5000.", "Join the employee table with the certificate table on employee ID (eid) and then join with the aircraft table on aircraft ID (aid).", "Filter the results to include only those aircrafts where the distance is greater than 5000.", "Group the results by employee ID to count the number of certificates each employee has.", "Order the results by the count of certificates in descending order to find the employee with the most certificates.", "Limit the results to 1 to get only the top employee."], "gold_sql": "SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  5000 GROUP BY T1.eid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employee", "certificate", "aircraft"], "pred_sql": "SELECT e.name, e.salary\nFROM employee e\nJOIN certificate c ON e.eid = c.eid\nJOIN aircraft a ON c.aid = a.aid\nWHERE a.distance > 5000\nGROUP BY e.eid\nORDER BY COUNT(c.aid) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average distance and average price of flights originating from a specific location. The placeholder in the WHERE clause represents the origin of the flights.\"\n}\n"}
{"sample_id": "train.448", "db_id": "allergy_1", "question": "What are all the different food allergies?", "rationale": ["The question asks for all the different food allergies, which implies we need to retrieve unique allergy names.", "We will use the 'Allergy_Type' table to get the list of allergies.", "Using SELECT DISTINCT will ensure that we only get unique allergy names without duplicates."], "gold_sql": "SELECT DISTINCT allergy FROM Allergy_type WHERE allergytype  =  'food'", "source_tables": ["allergy_type"], "pred_sql": "SELECT DISTINCT Allergy FROM Allergy_Type;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\"\n}\n"}
{"sample_id": "train.456", "db_id": "allergy_1", "question": "Which allergy type is most common?", "rationale": ["We need to find the most common allergy type, which requires counting occurrences of each allergy type.", "To do this, we will join the 'Allergy_Type' table with the 'Has_Allergy' table on the 'Allergy' column.", "We will group the results by 'AllergyType' to count how many times each type appears.", "We will order the results in descending order based on the count of allergies to get the most common type at the top.", "Finally, we will limit the results to just one entry to get the most common allergy type."], "gold_sql": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT 1", "source_tables": ["allergy_type"], "pred_sql": "SELECT AllergyType, COUNT(*) as AllergyCount \nFROM Allergy_Type \nJOIN Has_Allergy ON Allergy_Type.Allergy = Has_Allergy.Allergy \nGROUP BY AllergyType \nORDER BY AllergyCount DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\"\n}\n"}
{"sample_id": "train.458", "db_id": "allergy_1", "question": "Which allergy type is the least common?", "rationale": ["Identify the relevant tables: Allergy_Type and Has_Allergy.", "We need to find the least common allergy type, which requires counting occurrences of each allergy in the Has_Allergy table.", "Group the results by Allergy to count how many students have each allergy.", "Order the results by the count in ascending order to find the least common allergy.", "Limit the results to 1 to get only the least common allergy.", "Join the result with the Allergy_Type table to get the corresponding AllergyType for the least common allergy."], "gold_sql": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) ASC LIMIT 1", "source_tables": ["allergy_type"], "pred_sql": "SELECT AllergyType FROM Allergy_Type WHERE Allergy IN (SELECT Allergy FROM Has_Allergy GROUP BY Allergy ORDER BY COUNT(*) ASC LIMIT 1);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\"\n}\n"}
{"sample_id": "train.462", "db_id": "allergy_1", "question": "What are the full names of all students", "rationale": ["Identify the table that contains student names, which is the 'Student' table.", "To get the full names, we need to concatenate the 'Fname' and 'LName' columns.", "Use the SQL SELECT statement to retrieve the concatenated names from the 'Student' table."], "gold_sql": "SELECT Fname ,  Lname FROM Student", "source_tables": ["student"], "pred_sql": "SELECT Fname || ' ' || LName AS FullName FROM Student;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first name, last name, and age of students from the 'Student' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the students.\"\n}\n"}
{"sample_id": "train.472", "db_id": "allergy_1", "question": "What are the student ids for all male students?", "rationale": ["Identify the relevant table: The 'Student' table contains the information about students, including their gender.", "Determine the required information: We need the student IDs (StuID) for male students.", "Construct the SQL query: Use a SELECT statement to retrieve the StuID from the Student table where the Sex column matches 'Male'."], "gold_sql": "SELECT StuID FROM Student WHERE Sex  =  'M'", "source_tables": ["student"], "pred_sql": "SELECT StuID FROM Student WHERE Sex = 'Male';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the unique identifiers of students from the 'Student' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the students.\"\n}\n"}
{"sample_id": "train.492", "db_id": "allergy_1", "question": "What is the largest major?", "rationale": ["Identify the table that contains the majors, which is the 'Student' table.", "Group the results by the 'Major' column to count the number of students in each major.", "Order the results in descending order based on the count of students to find the largest major.", "Limit the results to 1 to get only the largest major."], "gold_sql": "SELECT major FROM Student GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Major FROM Student GROUP BY Major ORDER BY COUNT(StuID) DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of academic majors from the 'Student' table, grouped by the major and ordered by the number of students in each major in descending order. The placeholder in the LIMIT clause represents the maximum number of majors to return.\"\n}\n"}
{"sample_id": "train.501", "db_id": "allergy_1", "question": "Which advisor has most number of students?", "rationale": ["We need to find out which advisor has the most number of students.", "To do this, we will select the 'Advisor' column from the 'Student' table.", "We will count the number of students (StuID) for each advisor using COUNT(StuID).", "We will group the results by 'Advisor' to aggregate the student counts for each advisor.", "To find the advisor with the most students, we will order the results by the count of students in descending order.", "Finally, we will limit the results to 1 to get only the advisor with the highest count."], "gold_sql": "SELECT advisor FROM Student GROUP BY advisor ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Advisor, COUNT(StuID) AS StudentCount \nFROM Student \nGROUP BY Advisor \nORDER BY StudentCount DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of academic advisors from the 'Student' table, grouped by the advisor's name. The results are ordered by the number of students assigned to each advisor in descending order, with a limit on the number of advisors returned, specified by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.504", "db_id": "allergy_1", "question": "How many students are affected by cat allergies?", "rationale": ["Identify the relevant tables: We need to look at the 'Has_Allergy' table to find students with specific allergies.", "Determine the specific allergy: The question asks about 'cat allergies'.", "Count the distinct students: We need to count the unique student IDs (StuID) who have the specified allergy.", "Construct the SQL query: Use COUNT and DISTINCT to get the number of unique students with 'cat' as their allergy."], "gold_sql": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  'Cat'", "source_tables": ["has_allergy"], "pred_sql": "SELECT COUNT(DISTINCT Has_Allergy.StuID) AS StudentCount\nFROM Has_Allergy\nWHERE Allergy = 'cat';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of students who have a specific allergy from the 'Has_Allergy' table. The placeholder in the WHERE clause represents the name of the allergy.\"\n}\n"}
{"sample_id": "train.508", "db_id": "allergy_1", "question": "Which students are unaffected by allergies?", "rationale": ["Identify the main goal: to find students who are unaffected by allergies.", "To determine which students are unaffected, we need to select students from the 'Student' table whose IDs are not present in the 'Has_Allergy' table.", "The 'Has_Allergy' table contains the 'StuID' of students who have allergies, so we can use a subquery to find all 'StuID's in 'Has_Allergy'.", "Using the NOT IN clause allows us to filter out those students from the 'Student' table who have allergies."], "gold_sql": "SELECT StuID FROM Student EXCEPT SELECT StuID FROM Has_allergy", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT * FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_Allergy)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of students who have a specific allergy from the 'Has_Allergy' table. The placeholder in the WHERE clause represents the name of the allergy.\"\n}\n"}
{"sample_id": "train.509", "db_id": "allergy_1", "question": "How many female students have milk or egg allergies?", "rationale": ["We need to count the number of female students with specific allergies (milk or egg).", "First, we will select from the 'Student' table to filter by gender (female).", "Next, we will join the 'Has_Allergy' table to link students with their allergies using the StuID.", "We will then filter the results to include only those students who have either 'Milk' or 'Egg' allergies using the IN clause.", "Finally, we will use COUNT(DISTINCT Student.StuID) to get the unique count of female students with these allergies."], "gold_sql": "SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  'F' AND T1.allergy  =  'Milk' OR T1.allergy  =  'Eggs'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT COUNT(DISTINCT Student.StuID) \nFROM Student \nJOIN Has_Allergy ON Student.StuID = Has_Allergy.StuID \nWHERE Student.Sex = 'Female' \nAND Has_Allergy.Allergy IN ('Milk', 'Egg');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of students who have a specific allergy from the 'Has_Allergy' table. The placeholder in the WHERE clause represents the name of the allergy.\"\n}\n"}
{"sample_id": "train.510", "db_id": "allergy_1", "question": "How many students who are female are allergic to milk or eggs?", "rationale": ["Identify the tables needed: We need to get information from the Student and Has_Allergy tables.", "We need to count the number of distinct students, so we will use COUNT(DISTINCT Student.StuID).", "We need to filter the students based on their gender, specifically female, so we will add a WHERE clause for Student.Sex = 'Female'.", "We also need to filter the allergies to only include 'milk' and 'eggs', so we will use the IN clause in the WHERE condition for Has_Allergy.Allergy.", "We will join the Student table with the Has_Allergy table on the StuID to link students with their allergies."], "gold_sql": "SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  'F' AND T1.allergy  =  'Milk' OR T1.allergy  =  'Eggs'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT COUNT(DISTINCT Student.StuID) \nFROM Student \nJOIN Has_Allergy ON Student.StuID = Has_Allergy.StuID \nWHERE Student.Sex = 'Female' \nAND Has_Allergy.Allergy IN ('milk', 'eggs');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of students who have a specific allergy from the 'Has_Allergy' table. The placeholder in the WHERE clause represents the name of the allergy.\"\n}\n"}
{"sample_id": "train.513", "db_id": "allergy_1", "question": "Which allergy has most number of students affected?", "rationale": ["We need to find out which allergy has the most number of students affected.", "To do this, we will count the number of students (StuID) for each allergy in the Has_Allergy table.", "We will use the COUNT function to count the number of occurrences of each allergy.", "We will group the results by the Allergy column to get the count for each allergy.", "To find the allergy with the most students, we will order the results in descending order based on the count of students.", "Finally, we will limit the results to just one record to get the allergy with the highest count."], "gold_sql": "SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT 1", "source_tables": ["has_allergy"], "pred_sql": "SELECT Allergy, COUNT(StuID) AS StudentCount\nFROM Has_Allergy\nGROUP BY Allergy\nORDER BY StudentCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of students who have a specific allergy from the 'Has_Allergy' table. The placeholder in the WHERE clause represents the name of the allergy.\"\n}\n"}
{"sample_id": "train.518", "db_id": "allergy_1", "question": "How many students are affected by each allergy type?", "rationale": ["Identify the tables involved: Allergy_Type, Has_Allergy, and Student.", "We need to count the number of students affected by each allergy type, which means we need to join the Allergy_Type table with the Has_Allergy table.", "Use a LEFT JOIN to ensure we include all allergy types even if no students have that allergy.", "Group the results by AllergyType to get the count of students for each type.", "Count the number of unique StuID from the Has_Allergy table for each AllergyType.", "Order the results by the count of students in descending order to see the most affected allergy types first."], "gold_sql": "SELECT T2.allergytype ,  count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy GROUP BY T2.allergytype", "source_tables": ["has_allergy", "allergy_type"], "pred_sql": "SELECT at.AllergyType, COUNT(ha.StuID) AS StudentCount\nFROM Allergy_Type at\nLEFT JOIN Has_Allergy ha ON at.Allergy = ha.Allergy\nGROUP BY at.AllergyType\nORDER BY StudentCount DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\"\n}\n"}
{"sample_id": "train.520", "db_id": "allergy_1", "question": "What are the last names and ages of the students who are allergic to milk and cat?", "rationale": ["Identify the relevant tables: Student and Has_Allergy.", "We need to retrieve the last names and ages of students, so we will select Student.LName and Student.Age.", "We need to join the Student table with the Has_Allergy table on the StuID column to link students with their allergies.", "We are interested in students who are allergic to both 'milk' and 'cat'. Therefore, we will use a WHERE clause to filter allergies.", "To ensure we only get students who have both allergies, we will use GROUP BY on Student.StuID and use HAVING to count distinct allergies, ensuring it equals 2."], "gold_sql": "SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT Student.LName, Student.Age \nFROM Student \nJOIN Has_Allergy ON Student.StuID = Has_Allergy.StuID \nWHERE Has_Allergy.Allergy IN ('milk', 'cat') \nGROUP BY Student.StuID \nHAVING COUNT(DISTINCT Has_Allergy.Allergy) = 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of students who have a specific allergy from the 'Has_Allergy' table. The placeholder in the WHERE clause represents the name of the allergy.\"\n}\n"}
{"sample_id": "train.522", "db_id": "allergy_1", "question": "What are the allergies the girl named Lisa has? And what are the types of them? Order the result by allergy names.", "rationale": ["Identify the relevant tables: Student, Has_Allergy, and Allergy_Type.", "We need to find allergies for a student named Lisa, so we will filter the Student table by first name and gender (female).", "Join the Has_Allergy table to link students with their allergies using StuID.", "Join the Allergy_Type table to get the type of each allergy using the Allergy name.", "Select the Allergy and AllergyType columns from the Allergy_Type table.", "Order the results by the Allergy name."], "gold_sql": "SELECT T1.Allergy ,  T1.AllergyType FROM Allergy_type AS T1 JOIN Has_allergy AS T2 ON T1.Allergy  =  T2.Allergy JOIN Student AS T3 ON T3.StuID  =  T2.StuID WHERE T3.Fname  =  'Lisa' ORDER BY T1.Allergy", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT a.Allergy, a.AllergyType \nFROM Student s \nJOIN Has_Allergy ha ON s.StuID = ha.StuID \nJOIN Allergy_Type a ON ha.Allergy = a.Allergy \nWHERE s.Fname = 'Lisa' AND s.Sex = 'Female' \nORDER BY a.Allergy;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\"\n}\n"}
{"sample_id": "train.525", "db_id": "allergy_1", "question": "Find the average age of the students who have allergies with food and animal types.", "rationale": ["Identify the tables needed: We need to get student ages and their allergies, so we will use the Student, Has_Allergy, and Allergy_Type tables.", "Join the tables: We will join the Student table with the Has_Allergy table on StuID, and then join the Has_Allergy table with the Allergy_Type table on Allergy.", "Filter the allergies: We need to filter the results to include only those students who have allergies categorized as 'food' or 'animal'.", "Calculate the average age: We will use the AVG function to calculate the average age of the filtered students. Since age is stored as text, we will cast it to INTEGER for the calculation."], "gold_sql": "SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food' INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'animal')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT AVG(CAST(S.Age AS INTEGER)) AS Average_Age\nFROM Student S\nJOIN Has_Allergy HA ON S.StuID = HA.StuID\nJOIN Allergy_Type AT ON HA.Allergy = AT.Allergy\nWHERE AT.AllergyType IN ('food', 'animal');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\"\n}\n"}
{"sample_id": "train.527", "db_id": "allergy_1", "question": "List the first and last name of the students who do not have any food type allergy.", "rationale": ["Identify the tables needed: We need to retrieve student names from the Student table and check their allergies from the Has_Allergy table.", "We need to find students who do not have any food type allergies. This requires a subquery to find students with food allergies.", "The subquery will select StuID from Has_Allergy where the allergy type is 'Food'.", "The main query will select the first and last names of students whose StuID is not in the list returned by the subquery."], "gold_sql": "SELECT fname ,  lname FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT Fname, LName \nFROM Student \nWHERE StuID NOT IN (\n    SELECT StuID \n    FROM Has_Allergy \n    JOIN Allergy_Type ON Has_Allergy.Allergy = Allergy_Type.Allergy \n    WHERE AllergyType = 'Food'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\"\n}\n"}
{"sample_id": "train.529", "db_id": "allergy_1", "question": "Find the number of male (sex is 'M') students who have some food type allery.", "rationale": ["Identify the tables needed: Student, Has_Allergy, and Allergy_Type.", "We need to count distinct students, so we will use COUNT(DISTINCT Student.StuID).", "We need to filter students by sex, specifically those who are male (Sex = 'M').", "We need to join the Has_Allergy table to find which allergies the students have.", "We also need to join the Allergy_Type table to filter for allergies that are of type 'food'.", "Construct the SQL query using the SELECT statement, JOINs, and WHERE clause to apply the filters."], "gold_sql": "SELECT count(*) FROM Student WHERE sex  =  'M' AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT COUNT(DISTINCT Student.StuID) \nFROM Student \nJOIN Has_Allergy ON Student.StuID = Has_Allergy.StuID \nJOIN Allergy_Type ON Has_Allergy.Allergy = Allergy_Type.Allergy \nWHERE Student.Sex = 'M' AND Allergy_Type.AllergyType = 'food';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of students who have a specific allergy from the 'Has_Allergy' table. The placeholder in the WHERE clause represents the name of the allergy.\"\n}\n"}
{"sample_id": "train.531", "db_id": "allergy_1", "question": "Find the different first names and cities of the students who have allergy to milk or cat.", "rationale": ["Identify the tables needed: We need information from the Student table and the Has_Allergy table.", "Determine the relationship: The Has_Allergy table links students to their allergies via StuID.", "Select the required fields: We need the first names (Fname) and city codes (city_code) of the students.", "Filter the results: We want only those students who have allergies to either 'milk' or 'cat'.", "Use DISTINCT to ensure we get unique combinations of first names and city codes."], "gold_sql": "SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  'Milk' OR T2.Allergy  =  'Cat'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT DISTINCT Student.Fname, Student.city_code \nFROM Student \nJOIN Has_Allergy ON Student.StuID = Has_Allergy.StuID \nWHERE Has_Allergy.Allergy IN ('milk', 'cat');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.\"\n}\n"}
{"sample_id": "train.533", "db_id": "allergy_1", "question": "Find the number of students who are older than 18 and do not have allergy to either food or animal.", "rationale": ["We need to count the number of students who are older than 18 and do not have allergies to food or animals.", "First, we will select from the 'Student' table and apply a condition to filter students older than 18.", "Next, we need to exclude students who have allergies to either food or animals. We can do this by using a subquery that selects 'StuID' from the 'Has_Allergy' table where the 'Allergy' is either 'food' or 'animal'.", "We will use the NOT IN clause to ensure that we only count students whose 'StuID' is not in the list returned by the subquery.", "Finally, we will use COUNT(*) to get the total number of students that meet these criteria."], "gold_sql": "SELECT count(*) FROM Student WHERE age  >  18 AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food' OR T2.allergytype  =  'animal')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT COUNT(*) \nFROM Student \nWHERE Age > 18 \nAND StuID NOT IN (\n    SELECT StuID \n    FROM Has_Allergy \n    WHERE Allergy IN ('food', 'animal')\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of students who have a specific allergy from the 'Has_Allergy' table. The placeholder in the WHERE clause represents the name of the allergy.\"\n}\n"}
{"sample_id": "train.535", "db_id": "allergy_1", "question": "Find the first name and major of the students who are not allegry to soy.", "rationale": ["Identify the required fields: first name (Fname) and major (Major) of students.", "Determine the source table: the Student table contains the required fields.", "Identify the condition: we need students who do not have an allergy to soy.", "To find students without a soy allergy, we can use a subquery to select all StuIDs from the Has_Allergy table where the Allergy is 'soy'.", "Use the NOT IN clause to filter out those students from the main query on the Student table."], "gold_sql": "SELECT fname ,  major FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Soy')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT Fname, Major \nFROM Student \nWHERE StuID NOT IN (\n    SELECT StuID \n    FROM Has_Allergy \n    WHERE Allergy = 'soy'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first name, last name, and age of students from the 'Student' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the students.\"\n}\n"}
{"sample_id": "train.542", "db_id": "store_1", "question": "What are the names of the countries and average invoice size of the top countries by size?", "rationale": ["We need to find the names of the countries and the average invoice size.", "The relevant table for this information is the 'invoices' table, which contains the 'billing_country' and 'total' columns.", "To calculate the average invoice size for each country, we will use the AVG() function on the 'total' column.", "We will group the results by 'billing_country' to get the average for each country.", "Finally, we will order the results in descending order of average invoice size to get the top countries by size."], "gold_sql": "SELECT billing_country ,  AVG(total) FROM invoices GROUP BY billing_country ORDER BY AVG(total) DESC LIMIT 10;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_country, AVG(total) AS average_invoice_size\nFROM invoices\nGROUP BY billing_country\nORDER BY average_invoice_size DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of invoices and the total amount billed for a specific billing state from the 'invoices' table. The placeholder in the WHERE clause represents the billing state being queried.\"\n}\n"}
{"sample_id": "train.553", "db_id": "store_1", "question": "List every album ordered by album title in ascending order.", "rationale": ["Identify the table needed: The question asks for albums, so we will use the 'albums' table.", "Determine the columns to select: We want to list every album, so we will select all columns using '*'.", "Specify the ordering: The albums should be ordered by the album title in ascending order, which can be done using 'ORDER BY title ASC'.", "Combine these elements into a complete SQL query."], "gold_sql": "SELECT title FROM albums ORDER BY title;", "source_tables": ["albums"], "pred_sql": "SELECT * FROM albums ORDER BY title ASC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the titles of albums from the 'albums' table that match a specific pattern. The placeholder in the WHERE clause represents the title pattern to search for, allowing for flexible querying of album titles.\"\n}\n"}
{"sample_id": "train.560", "db_id": "store_1", "question": "What are the total amount of money in the invoices billed from Chicago, Illinois?", "rationale": ["Identify the relevant table: The 'invoices' table contains the billing information.", "Determine the required fields: We need to count the total number of invoices and sum the total amount billed.", "Apply the necessary filters: We need to filter the invoices based on the billing city (Chicago) and billing state (Illinois).", "Construct the SQL query: Use COUNT() to get the total number of invoices and SUM() to calculate the total amount billed, applying the WHERE clause for the specified city and state."], "gold_sql": "SELECT sum(total) FROM invoices WHERE billing_city  =  'Chicago' AND billing_state  =  'IL';", "source_tables": ["invoices"], "pred_sql": "SELECT COUNT(id) AS total_invoices, SUM(total) AS total_amount_billed FROM invoices WHERE billing_city = 'Chicago' AND billing_state = 'Illinois';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of invoices and the total amount billed for a specific billing state from the 'invoices' table. The placeholder in the WHERE clause represents the billing state being queried.\"\n}\n"}
{"sample_id": "train.564", "db_id": "store_1", "question": "How many invoices were billed from each state?", "rationale": ["We need to count the number of invoices for each state.", "The relevant table for this information is the 'invoices' table, which contains a 'billing_state' column.", "To get the count of invoices per state, we will use the COUNT() function.", "We will group the results by 'billing_state' to get the count for each state."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_state, COUNT(*) AS total_invoices\nFROM invoices\nGROUP BY billing_state;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of invoices and the total amount billed for a specific billing state from the 'invoices' table. The placeholder in the WHERE clause represents the billing state being queried.\"\n}\n"}
{"sample_id": "train.565", "db_id": "store_1", "question": "List the state in the US with the most invoices.", "rationale": ["We need to find the state in the US with the most invoices.", "To do this, we will query the 'invoices' table.", "We will group the results by 'billing_state' to count the number of invoices for each state.", "We will use the COUNT() function to count the invoices per state.", "To find the state with the most invoices, we will order the results in descending order based on the count of invoices.", "Finally, we will limit the results to 1 to get the state with the highest count."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT 1;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_state, COUNT(*) AS invoice_count \nFROM invoices \nGROUP BY billing_state \nORDER BY invoice_count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of invoices and the total amount billed for a specific billing state from the 'invoices' table. The placeholder in the WHERE clause represents the billing state being queried.\"\n}\n"}
{"sample_id": "train.566", "db_id": "store_1", "question": "What are the states with the most invoices?", "rationale": ["Identify the relevant table: The 'invoices' table contains the billing state and invoice information.", "Determine the required information: We need to count the number of invoices and sum the total amount billed for each state.", "Group the results by billing state to aggregate the invoice counts and totals.", "Order the results by the count of invoices in descending order to find the states with the most invoices."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT 1;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_state, COUNT(*) AS invoice_count, SUM(total) AS total_billed \nFROM invoices \nGROUP BY billing_state \nORDER BY invoice_count DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of invoices and the total amount billed for a specific billing state from the 'invoices' table. The placeholder in the WHERE clause represents the billing state being queried.\"\n}\n"}
{"sample_id": "train.567", "db_id": "store_1", "question": "List the number of invoices and the invoice total from California.", "rationale": ["Identify the relevant table: The 'invoices' table contains the necessary information about invoices and their totals.", "Determine the required fields: We need to count the number of invoices and sum the total amount, which corresponds to the 'id' and 'total' columns in the 'invoices' table.", "Apply the filter: We need to filter the results to only include invoices from California, which can be done using a WHERE clause on the 'billing_state' column.", "Construct the SQL query: Combine the COUNT and SUM functions with the appropriate SELECT statement and WHERE clause to form the complete SQL query."], "gold_sql": "SELECT billing_state ,  COUNT(*) ,  SUM(total) FROM invoices WHERE billing_state  =  'CA';", "source_tables": ["invoices"], "pred_sql": "SELECT COUNT(id) AS number_of_invoices, SUM(total) AS total_invoice_amount FROM invoices WHERE billing_state = 'California';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of invoices and the total amount billed for a specific billing state from the 'invoices' table. The placeholder in the WHERE clause represents the billing state being queried.\"\n}\n"}
{"sample_id": "train.575", "db_id": "store_1", "question": "What is Astrid Gruber's email and phone number?", "rationale": ["Identify the relevant table: The question asks for information about an employee, so we will use the 'employees' table.", "Determine the required fields: The user wants the email and phone number of Astrid Gruber, so we will select the 'email' and 'phone' columns.", "Filter the results: We need to find the specific employee by their first and last name, which are 'Astrid' and 'Gruber'.", "Construct the SQL query: Combine the SELECT statement with the WHERE clause to filter by the specified names."], "gold_sql": "SELECT email ,  phone FROM customers WHERE first_name = 'Astrid' AND last_name = 'Gruber';", "source_tables": ["customers"], "pred_sql": "SELECT email, phone FROM employees WHERE first_name = 'Astrid' AND last_name = 'Gruber';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the titles, phone numbers, and hire dates of employees from the 'employees' table who have a specific first and last name. The placeholders in the WHERE clause represent the first and last names of the employee.\"\n}\n"}
{"sample_id": "train.593", "db_id": "store_1", "question": "Find the full name of employee who supported the most number of customers.", "rationale": ["Identify the relevant tables: employees and customers.", "We need to find the employee who supported the most customers, which means we need to join the employees table with the customers table on the support_rep_id.", "We will group the results by the employee's id to count how many customers each employee supports.", "We will order the results by the count of customers in descending order to get the employee with the most customers at the top.", "Finally, we will limit the results to 1 to get only the top employee.", "We will select the full name of the employee by concatenating their first and last names."], "gold_sql": "SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employees", "customers"], "pred_sql": "SELECT e.first_name || ' ' || e.last_name AS full_name\nFROM employees e\nJOIN customers c ON e.id = c.support_rep_id\nGROUP BY e.id\nORDER BY COUNT(c.id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of employees and their managers from the 'employees' table. It lists the first and last names of managers along with the count of employees reporting to each manager. The results are grouped by the manager's identifier and ordered by the number of reports in descending order, with a limit on the number of results specified by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.594", "db_id": "store_1", "question": "What is the full name of the employee who has the most customers?", "rationale": ["Identify the relevant tables: 'employees' and 'customers'.", "We need to find the employee who has the most customers, which means we need to join the 'employees' table with the 'customers' table on the 'support_rep_id'.", "Use a GROUP BY clause to group the results by employee ID, which will allow us to count the number of customers each employee has.", "Use COUNT(c.id) to count the number of customers for each employee.", "Order the results in descending order based on the count of customers to get the employee with the most customers at the top.", "Limit the results to 1 to get only the employee with the most customers.", "Select the full name of the employee by concatenating the first name and last name."], "gold_sql": "SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employees", "customers"], "pred_sql": "SELECT e.first_name || ' ' || e.last_name AS full_name\nFROM employees e\nJOIN customers c ON e.id = c.support_rep_id\nGROUP BY e.id\nORDER BY COUNT(c.id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the titles, phone numbers, and hire dates of employees from the 'employees' table who have a specific first and last name. The placeholders in the WHERE clause represent the first and last names of the employee.\"\n}\n"}
{"sample_id": "train.604", "db_id": "store_1", "question": "How many employees who are IT staff are from each city?", "rationale": ["Identify the relevant table: The 'employees' table contains information about employees, including their job titles and cities.", "Filter for IT staff: Use a WHERE clause to filter employees whose title includes 'IT'.", "Group by city: To get the count of IT staff from each city, use GROUP BY on the 'city' column.", "Count the employees: Use COUNT(*) to count the number of employees in each city who meet the criteria."], "gold_sql": "SELECT count(*) ,  city FROM employees WHERE title  =  'IT Staff' GROUP BY city", "source_tables": ["employees"], "pred_sql": "SELECT city, COUNT(*) AS employee_count \nFROM employees \nWHERE title LIKE '%IT%' \nGROUP BY city;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of employees and their managers from the 'employees' table. It lists the first and last names of managers along with the count of employees reporting to each manager. The results are grouped by the manager's identifier and ordered by the number of reports in descending order, with a limit on the number of results specified by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.624", "db_id": "store_1", "question": "What is the name of the album that has the track Ball to the Wall?", "rationale": ["Identify the relevant tables: 'albums' and 'tracks' are needed to find the album title associated with a specific track.", "Determine the relationship between the tables: 'albums' has a foreign key 'id' that corresponds to 'album_id' in 'tracks'.", "Formulate the SQL query to select the album title from the 'albums' table where the track name matches 'Ball to the Wall'.", "Use a JOIN clause to connect 'albums' and 'tracks' based on the album ID, and filter the results using a WHERE clause for the track name."], "gold_sql": "SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T2.name = 'Balls to the Wall';", "source_tables": ["albums", "tracks"], "pred_sql": "SELECT albums.title \nFROM albums \nJOIN tracks ON albums.id = tracks.album_id \nWHERE tracks.name = 'Ball to the Wall';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the titles of albums from the 'albums' table that match a specific pattern. The placeholder in the WHERE clause represents the title pattern to search for, allowing for flexible querying of album titles.\"\n}\n"}
{"sample_id": "train.632", "db_id": "store_1", "question": "What are the names of all tracks that belong to the Rock genre and whose media type is MPEG?", "rationale": ["Identify the relevant tables: tracks, genres, and media_types.", "Join the tracks table with the genres table on genre_id to filter tracks by genre.", "Join the tracks table with the media_types table on media_type_id to filter tracks by media type.", "Use a WHERE clause to specify that the genre name must be 'Rock' and the media type name must be 'MPEG'.", "Select the name of the tracks that meet these criteria."], "gold_sql": "SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = 'Rock' OR T3.name = 'MPEG audio file';", "source_tables": ["tracks", "genres", "media_types"], "pred_sql": "SELECT tracks.name \nFROM tracks \nJOIN genres ON tracks.genre_id = genres.id \nJOIN media_types ON tracks.media_type_id = media_types.id \nWHERE genres.name = 'Rock' AND media_types.name = 'MPEG';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of different media types from the 'media_types' table. The query retrieves all media type names without any filtering conditions.\"\n}\n"}
{"sample_id": "train.946", "db_id": "medicine_enzyme_interaction", "question": "What are the names and trade names of the medcines that are FDA approved?", "rationale": ["Identify the relevant table: The 'medicine' table contains the information about medicines.", "Determine the required columns: We need the 'name' and 'Trade_Name' columns from the 'medicine' table.", "Specify the condition: We only want medicines that are FDA approved, which is indicated by the 'FDA_approved' column being equal to 'yes'.", "Construct the SQL query: Use a SELECT statement to retrieve the specified columns from the 'medicine' table with the appropriate WHERE clause."], "gold_sql": "SELECT name ,  trade_name FROM medicine WHERE FDA_approved  =  'Yes'", "source_tables": ["medicine"], "pred_sql": "SELECT name, Trade_Name FROM medicine WHERE FDA_approved = 'yes';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the types of interactions between medicines and enzymes from the 'medicine_enzyme_interaction' table. It counts the occurrences of each interaction type and orders them in descending order, allowing the user to specify a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.951", "db_id": "medicine_enzyme_interaction", "question": "What are the ids, names and FDA approval status of medicines in descending order of the number of enzymes that it can interact with.", "rationale": ["Identify the relevant tables: medicine and medicine_enzyme_interaction.", "We need to select the medicine's id, name, and FDA approval status.", "To find the number of enzymes each medicine can interact with, we will join the medicine table with the medicine_enzyme_interaction table on the medicine_id.", "We will group the results by the medicine's id, name, and FDA approval status to count the number of interactions for each medicine.", "Finally, we will order the results in descending order based on the count of enzyme interactions."], "gold_sql": "SELECT T1.id ,  T1.Name ,  T1.FDA_approved FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id GROUP BY T1.id ORDER BY count(*) DESC", "source_tables": ["medicine", "medicine_enzyme_interaction"], "pred_sql": "SELECT m.id, m.name, m.FDA_approved\nFROM medicine m\nJOIN medicine_enzyme_interaction mei ON m.id = mei.medicine_id\nGROUP BY m.id, m.name, m.FDA_approved\nORDER BY COUNT(mei.enzyme_id) DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the types of interactions between medicines and enzymes from the 'medicine_enzyme_interaction' table. It counts the occurrences of each interaction type and orders them in descending order, allowing the user to specify a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.953", "db_id": "medicine_enzyme_interaction", "question": "What is the id and name of the enzyme with most number of medicines that can interact as 'activator'?", "rationale": ["Identify the relevant tables: 'enzyme' and 'medicine_enzyme_interaction'.", "We need to find the enzyme that has the most medicines interacting with it as 'activator'.", "Join the 'enzyme' table with the 'medicine_enzyme_interaction' table on the enzyme ID.", "Filter the results to only include interactions where the interaction type is 'activator'.", "Group the results by enzyme ID and name to count the number of medicines for each enzyme.", "Order the results in descending order based on the count of medicines.", "Limit the results to only the top entry to get the enzyme with the most activator interactions."], "gold_sql": "SELECT T1.id ,  T1.name FROM enzyme AS T1 JOIN medicine_enzyme_interaction AS T2 ON T1.id  =  T2.enzyme_id WHERE T2.interaction_type  =  'activitor' GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["enzyme", "medicine_enzyme_interaction"], "pred_sql": "SELECT e.id, e.name\nFROM enzyme e\nJOIN medicine_enzyme_interaction mei ON e.id = mei.enzyme_id\nWHERE mei.interaction_type = 'activator'\nGROUP BY e.id, e.name\nORDER BY COUNT(mei.medicine_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the types of interactions between medicines and enzymes from the 'medicine_enzyme_interaction' table. It counts the occurrences of each interaction type and orders them in descending order, allowing the user to specify a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.968", "db_id": "medicine_enzyme_interaction", "question": "What are the medicine and trade names that can interact as an inhibitor and activitor with enzymes?", "rationale": ["Identify the relevant tables: medicine and medicine_enzyme_interaction.", "We need to retrieve the medicine names and their trade names, so we will select the 'name' and 'Trade_Name' columns from the medicine table.", "To find the interactions, we will join the medicine table with the medicine_enzyme_interaction table on the medicine ID.", "We are specifically interested in interactions that are either 'inhibitor' or 'activator', so we will filter the results using a WHERE clause that checks for these interaction types."], "gold_sql": "SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id WHERE interaction_type  =  'inhibitor' INTERSECT SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id WHERE interaction_type  =  'activitor'", "source_tables": ["medicine", "medicine_enzyme_interaction"], "pred_sql": "SELECT m.name AS medicine_name, m.Trade_Name AS trade_name\nFROM medicine m\nJOIN medicine_enzyme_interaction mei ON m.id = mei.medicine_id\nWHERE mei.interaction_type IN ('inhibitor', 'activator');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the types of interactions between medicines and enzymes from the 'medicine_enzyme_interaction' table. It counts the occurrences of each interaction type and orders them in descending order, allowing the user to specify a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.970", "db_id": "medicine_enzyme_interaction", "question": "What are the medicine and trade names that cannot interact with the enzyme with the product 'Heme'?", "rationale": ["Identify the tables involved: medicine, enzyme, and medicine_enzyme_interaction.", "We need to find medicines that cannot interact with a specific enzyme product, which is 'Heme'.", "First, we need to find the medicine IDs that interact with the enzyme that has the product 'Heme'.", "This requires a subquery that joins the medicine_enzyme_interaction table with the enzyme table to filter by the product 'Heme'.", "Next, we will select the medicine names and trade names from the medicine table where the medicine ID is not in the list of IDs returned by the subquery.", "The final SQL query will select the required fields from the medicine table while excluding those that interact with the specified enzyme product."], "gold_sql": "SELECT name ,  trade_name FROM medicine EXCEPT SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id JOIN enzyme AS T3 ON T3.id  =  T2.enzyme_id WHERE T3.product  =  'Protoporphyrinogen IX'", "source_tables": ["enzyme", "medicine", "medicine_enzyme_interaction"], "pred_sql": "SELECT m.name, m.Trade_Name \nFROM medicine m \nWHERE m.id NOT IN (\n    SELECT mei.medicine_id \n    FROM medicine_enzyme_interaction mei \n    JOIN enzyme e ON mei.enzyme_id = e.id \n    WHERE e.Product = 'Heme'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the types of interactions between medicines and enzymes from the 'medicine_enzyme_interaction' table. It counts the occurrences of each interaction type and orders them in descending order, allowing the user to specify a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.1355", "db_id": "college_2", "question": "What is the name of the department with an instructure who has a name like 'Soisalon'?", "rationale": ["We need to find the name of the department that has an instructor with a name like 'Soisalon'.", "To do this, we will join the 'department' table with the 'instructor' table on the 'dept_name' column, since the instructor belongs to a department.", "We will then filter the results using a WHERE clause to find instructors whose names match the pattern '%Soisalon%', which means any name containing 'Soisalon'.", "Finally, we will select the distinct department names from the results to avoid duplicates."], "gold_sql": "SELECT dept_name FROM instructor WHERE name LIKE '%Soisalon%'", "source_tables": ["instructor"], "pred_sql": "SELECT DISTINCT department.dept_name \nFROM department \nJOIN instructor ON department.dept_name = instructor.dept_name \nWHERE instructor.name LIKE '%Soisalon%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the titles of courses offered by one academic department that are not offered by another department. The placeholders in the WHERE clause represent the names of the departments being compared.\"\n}\n"}
{"sample_id": "train.1365", "db_id": "college_2", "question": "What are the titles of courses that are in the Statistics department but not the Psychology department?", "rationale": ["Identify the relevant table: The 'course' table contains the titles of courses and their associated departments.", "Determine the condition: We need to find courses in the 'Statistics' department and exclude those in the 'Psychology' department.", "Construct the SQL query: Use a SELECT statement to retrieve the 'title' from the 'course' table where 'dept_name' is 'Statistics' and not 'Psychology'."], "gold_sql": "SELECT title FROM course WHERE dept_name  =  'Statistics' EXCEPT SELECT title FROM course WHERE dept_name  =  'Psychology'", "source_tables": ["course"], "pred_sql": "SELECT title FROM course WHERE dept_name = 'Statistics' AND dept_name != 'Psychology';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the titles of courses offered by one academic department that are not offered by another department. The placeholders in the WHERE clause represent the names of the departments being compared.\"\n}\n"}
{"sample_id": "train.1424", "db_id": "college_2", "question": "Find the title of course whose prerequisite is course Differential Geometry.", "rationale": ["Identify the course title we need to find, which is linked to a prerequisite course.", "We need to join the 'course' table with the 'prereq' table to find courses that have 'Differential Geometry' as a prerequisite.", "To do this, we will select the 'title' from the 'course' table where the 'course_id' matches the 'course_id' in the 'prereq' table.", "We will filter the results by checking if the 'prereq_id' in the 'prereq' table corresponds to the 'course_id' of 'Differential Geometry'.", "This requires a subquery to first find the 'course_id' of 'Differential Geometry' from the 'course' table."], "gold_sql": "SELECT title FROM course WHERE course_id IN (SELECT T1.course_id FROM prereq AS T1 JOIN course AS T2 ON T1.prereq_id  =  T2.course_id WHERE T2.title  =  'Differential Geometry')", "source_tables": ["course", "prereq"], "pred_sql": "SELECT c.title \nFROM course c \nJOIN prereq p ON c.course_id = p.course_id \nWHERE p.prereq_id = (SELECT course_id FROM course WHERE title = 'Differential Geometry');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the titles of courses offered by one academic department that are not offered by another department. The placeholders in the WHERE clause represent the names of the departments being compared.\"\n}\n"}
{"sample_id": "train.1426", "db_id": "college_2", "question": "Find the names of students who have taken any course in the fall semester of year 2003.", "rationale": ["Identify the relevant tables: student, takes, and section.", "We need to find students who have taken courses in the fall semester of 2003, so we will join the student table with the takes table on the student ID.", "Next, we will join the section table to the result to filter by semester and year.", "The WHERE clause will specify that we are looking for sections offered in the 'Fall' semester of the year '2003'.", "Finally, we will select the names of the students from the resulting joined table."], "gold_sql": "SELECT name FROM student WHERE id IN (SELECT id FROM takes WHERE semester  =  'Fall' AND YEAR  =  2003)", "source_tables": ["student", "takes"], "pred_sql": "SELECT student.name \nFROM student \nJOIN takes ON student.ID = takes.ID \nJOIN section ON takes.course_id = section.course_id AND takes.sec_id = section.sec_id \nWHERE section.semester = 'Fall' AND section.year = '2003';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the course IDs from the 'SECTION' table that are offered in two different semesters and years. The placeholders in the WHERE clauses represent the specific semesters and years for which the course IDs are being queried.\"\n}\n"}
{"sample_id": "train.1435", "db_id": "college_2", "question": "What are the names of all instructors who advise students in the math depart sorted by total credits of the student.", "rationale": ["Identify the tables involved: instructor, advisor, and student.", "We need to find instructors who advise students, so we will join the instructor table with the advisor table on the instructor's ID.", "Next, we join the advisor table with the student table on the student's ID to get the students being advised.", "We need to filter the results to only include students from the math department, so we add a WHERE clause for student.dept_name.", "Finally, we want to sort the results by the total credits of the students, so we use ORDER BY on student.tot_cred."], "gold_sql": "SELECT T2.name FROM advisor AS T1 JOIN instructor AS T2 ON T1.i_id  =  T2.id JOIN student AS T3 ON T1.s_id  =  T3.id WHERE T3.dept_name  =  'Math' ORDER BY T3.tot_cred", "source_tables": ["instructor", "student", "advisor"], "pred_sql": "SELECT instructor.name \nFROM instructor \nJOIN advisor ON instructor.ID = advisor.i_ID \nJOIN student ON advisor.s_ID = student.ID \nWHERE student.dept_name = 'math' \nORDER BY student.tot_cred;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the titles of courses from the 'course' table, sorted alphabetically by title and then by the number of credits awarded for each course. The sorting allows for an organized view of the available courses based on their titles and credits.\"\n}\n"}
{"sample_id": "train.1436", "db_id": "college_2", "question": "What is the course title of the prerequisite of course Mobile Computing?", "rationale": ["Identify the course for which we need the prerequisite, which is 'Mobile Computing'.", "Find the course_id of 'Mobile Computing' from the course table.", "Join the course table with the prereq table to find the prerequisite course_id.", "Select the title of the course from the course table where the course_id matches the prerequisite course_id found in the previous step."], "gold_sql": "SELECT title FROM course WHERE course_id IN (SELECT T1.prereq_id FROM prereq AS T1 JOIN course AS T2 ON T1.course_id  =  T2.course_id WHERE T2.title  =  'Mobile Computing')", "source_tables": ["course", "prereq"], "pred_sql": "SELECT c.title \nFROM course c \nJOIN prereq p ON c.course_id = p.prereq_id \nWHERE p.course_id = (SELECT course_id FROM course WHERE title = 'Mobile Computing');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the titles of courses from the 'course' table, sorted alphabetically by title and then by the number of credits awarded for each course. The sorting allows for an organized view of the available courses based on their titles and credits.\"\n}\n"}
{"sample_id": "train.1439", "db_id": "college_2", "question": "What is the name of the instructor who advises the student with the greatest number of total credits?", "rationale": ["Identify the tables involved: instructor, advisor, and student.", "We need to find the instructor who advises a student with the greatest number of total credits.", "To do this, we will join the instructor table with the advisor table on the instructor's ID and the advisor's ID.", "Next, we will join the result with the student table on the student's ID and the advisor's student ID.", "We need to filter the results to find the student with the maximum total credits, which can be done using a subquery that selects the maximum total credits from the student table.", "Finally, we will select the name of the instructor from the resulting joined table."], "gold_sql": "SELECT T2.name FROM advisor AS T1 JOIN instructor AS T2 ON T1.i_id  =  T2.id JOIN student AS T3 ON T1.s_id  =  T3.id ORDER BY T3.tot_cred DESC LIMIT 1", "source_tables": ["instructor", "student", "advisor"], "pred_sql": "SELECT instructor.name \nFROM instructor \nJOIN advisor ON instructor.ID = advisor.i_ID \nJOIN student ON advisor.s_ID = student.ID \nWHERE student.tot_cred = (SELECT MAX(tot_cred) FROM student);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the titles of courses from the 'course' table, sorted alphabetically by title and then by the number of credits awarded for each course. The sorting allows for an organized view of the available courses based on their titles and credits.\"\n}\n"}
{"sample_id": "train.1448", "db_id": "college_2", "question": "Find the number and averaged salary of all instructors who are in the department with the highest budget.", "rationale": ["Identify the department with the highest budget by ordering the departments based on their budget in descending order and limiting the result to the top one.", "Use a subquery to find the department name that corresponds to the highest budget.", "Count the number of instructors and calculate the average salary for those instructors who belong to the identified department."], "gold_sql": "SELECT avg(T1.salary) ,  count(*) FROM instructor AS T1 JOIN department AS T2 ON T1.dept_name  =  T2.dept_name ORDER BY T2.budget DESC LIMIT 1", "source_tables": ["instructor", "department"], "pred_sql": "SELECT COUNT(ID) AS number_of_instructors, AVG(salary) AS average_salary\nFROM instructor\nWHERE dept_name = (\n    SELECT dept_name\n    FROM department\n    ORDER BY budget DESC\n    LIMIT 1\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the minimum salary of instructors grouped by their respective departments, but only for those departments where the average salary of instructors exceeds the overall average salary of all instructors. The placeholders in the query represent the necessary values for filtering and aggregating the data.\"\n}\n"}
{"sample_id": "train.1449", "db_id": "college_2", "question": "How many instructors are in the department with the highest budget, and what is their average salary?", "rationale": ["Identify the department with the highest budget by using a subquery to select the maximum budget from the department table.", "Join the instructor table with the department table on the dept_name to associate instructors with their respective departments.", "Filter the results to only include instructors from the department that has the highest budget.", "Count the number of instructors in that department and calculate their average salary using COUNT() and AVG() functions."], "gold_sql": "SELECT avg(T1.salary) ,  count(*) FROM instructor AS T1 JOIN department AS T2 ON T1.dept_name  =  T2.dept_name ORDER BY T2.budget DESC LIMIT 1", "source_tables": ["instructor", "department"], "pred_sql": "SELECT COUNT(i.ID) AS instructor_count, AVG(i.salary) AS average_salary\nFROM instructor i\nJOIN department d ON i.dept_name = d.dept_name\nWHERE d.budget = (SELECT MAX(budget) FROM department);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the minimum salary of instructors grouped by their respective departments, but only for those departments where the average salary of instructors exceeds the overall average salary of all instructors. The placeholders in the query represent the necessary values for filtering and aggregating the data.\"\n}\n"}
{"sample_id": "train.1452", "db_id": "college_2", "question": "Find the name of students who didn't take any course from Biology department.", "rationale": ["Identify the students who are enrolled in departments other than Biology.", "Use a subquery to find all student IDs that have taken courses from the Biology department.", "Select the names of students whose IDs are not in the list of students who have taken Biology courses."], "gold_sql": "SELECT name FROM student WHERE id NOT IN (SELECT T1.id FROM takes AS T1 JOIN course AS T2 ON T1.course_id  =  T2.course_id WHERE T2.dept_name  =  'Biology')", "source_tables": ["course", "student", "takes"], "pred_sql": "SELECT name FROM student WHERE dept_name != 'Biology' AND ID NOT IN (SELECT ID FROM takes WHERE course_id IN (SELECT course_id FROM course WHERE dept_name = 'Biology'));", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the titles of courses offered by one academic department that are not offered by another department. The placeholders in the WHERE clause represent the names of the departments being compared.\"\n}\n"}
{"sample_id": "train.1458", "db_id": "college_2", "question": "Find the name and salary of instructors whose salary is below the average salary of the instructors in the Physics department.", "rationale": ["Identify the relevant table: The 'instructor' table contains the information about instructors, including their names and salaries.", "Determine the condition for filtering: We need to find instructors in the 'Physics' department whose salary is below the average salary of instructors in that department.", "Calculate the average salary: Use a subquery to calculate the average salary of instructors in the 'Physics' department using AVG(salary).", "Combine the conditions: Use a SELECT statement to retrieve the name and salary of instructors where the department is 'Physics' and their salary is less than the calculated average salary."], "gold_sql": "SELECT name ,  salary FROM instructor WHERE salary  <  (SELECT avg(salary) FROM instructor WHERE dept_name  =  'Physics')", "source_tables": ["instructor"], "pred_sql": "SELECT name, salary FROM instructor WHERE dept_name = 'Physics' AND salary < (SELECT AVG(salary) FROM instructor WHERE dept_name = 'Physics')", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the minimum salary of instructors grouped by their respective departments, but only for those departments where the average salary of instructors exceeds the overall average salary of all instructors. The placeholders in the query represent the necessary values for filtering and aggregating the data.\"\n}\n"}
{"sample_id": "train.1461", "db_id": "college_2", "question": "What are the names of students who have taken Statistics courses?", "rationale": ["Identify the relevant tables: We need to find student names, so we will use the 'student' table. We also need to know which courses they have taken, so we will use the 'takes' and 'course' tables.", "Determine the relationship between the tables: The 'takes' table links students to the courses they have taken through the student ID and course ID.", "Filter for Statistics courses: We need to filter the courses to only include those that have 'Statistics' in their title. This can be done using a WHERE clause with a LIKE condition.", "Select distinct student names: Since a student may have taken multiple Statistics courses, we will use DISTINCT to ensure each name appears only once in the result."], "gold_sql": "SELECT T3.name FROM course AS T1 JOIN takes AS T2 ON T1.course_id  =  T2.course_id JOIN student AS T3 ON T2.id  =  T3.id WHERE T1.dept_name  =  'Statistics'", "source_tables": ["course", "student", "takes"], "pred_sql": "SELECT DISTINCT student.name \nFROM student \nJOIN takes ON student.ID = takes.ID \nJOIN course ON takes.course_id = course.course_id \nWHERE course.title LIKE '%Statistics%';", "hint": "\n"}
{"sample_id": "train.1464", "db_id": "college_2", "question": "Find the names of all instructors in computer science department", "rationale": ["Identify the table that contains instructor information, which is the 'instructor' table.", "Determine the relevant column for instructor names, which is 'name'.", "Identify the condition needed to filter instructors by department, specifically for the 'computer science' department.", "Construct the SQL query using the SELECT statement to retrieve the names of instructors from the 'instructor' table where the 'dept_name' matches 'computer science'."], "gold_sql": "SELECT name FROM instructor WHERE dept_name  =  'Comp. Sci.'", "source_tables": ["instructor"], "pred_sql": "SELECT name FROM instructor WHERE dept_name = 'computer science';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the minimum salary of instructors grouped by their respective departments, but only for those departments where the average salary of instructors exceeds the overall average salary of all instructors. The placeholders in the query represent the necessary values for filtering and aggregating the data.\"\n}\n"}
{"sample_id": "train.1480", "db_id": "college_2", "question": "Find courses that ran in Fall 2009 but not in Spring 2010.", "rationale": ["Identify the courses offered in Fall 2009 by joining the 'course' and 'section' tables on 'course_id'.", "Filter the results to only include sections from Fall 2009 using the WHERE clause.", "To find courses that were not offered in Spring 2010, create a subquery that selects 'course_id' from the 'section' table for Spring 2010.", "Use the NOT IN clause to exclude any courses from the main query that appear in the subquery results."], "gold_sql": "SELECT course_id FROM SECTION WHERE semester  =  'Fall' AND YEAR  =  2009 EXCEPT SELECT course_id FROM SECTION WHERE semester  =  'Spring' AND YEAR  =  2010", "source_tables": ["section"], "pred_sql": "SELECT DISTINCT c.title \nFROM course c \nJOIN section s1 ON c.course_id = s1.course_id \nWHERE s1.semester = 'Fall' AND s1.year = '2009' \nAND c.course_id NOT IN (\n    SELECT s2.course_id \n    FROM section s2 \n    WHERE s2.semester = 'Spring' AND s2.year = '2010'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the titles of courses offered by one academic department that are not offered by another department. The placeholders in the WHERE clause represent the names of the departments being compared.\"\n}\n"}
{"sample_id": "train.1489", "db_id": "college_2", "question": "What are the names of instructors who earn more than at least one instructor from the Biology department?", "rationale": ["Identify the requirement: We need the names of instructors who earn more than at least one instructor from the Biology department.", "To find this, we need to compare the salaries of instructors in the instructor table with the salaries of instructors in the Biology department.", "We can use a subquery to find the minimum salary of instructors in the Biology department.", "The subquery will be: SELECT MIN(salary) FROM instructor WHERE dept_name = 'Biology'.", "The main query will select the names of instructors from the instructor table where their salary is greater than the result of the subquery."], "gold_sql": "SELECT name FROM instructor WHERE salary  >  (SELECT min(salary) FROM instructor WHERE dept_name  =  'Biology')", "source_tables": ["instructor"], "pred_sql": "SELECT name FROM instructor WHERE salary > (SELECT MIN(salary) FROM instructor WHERE dept_name = 'Biology')", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the minimum salary of instructors grouped by their respective departments, but only for those departments where the average salary of instructors exceeds the overall average salary of all instructors. The placeholders in the query represent the necessary values for filtering and aggregating the data.\"\n}\n"}
{"sample_id": "train.1515", "db_id": "insurance_and_eClaims", "question": "Find the total and average amount paid in claim headers.", "rationale": ["Identify the relevant table: The 'Claim_Headers' table contains the 'Amount_Paid' column which is needed for the calculations.", "Determine the required calculations: We need to calculate both the total and average of the 'Amount_Paid' column.", "Use aggregate functions: Use SUM() to calculate the total amount paid and AVG() to calculate the average amount paid.", "Construct the SQL query: Combine the SELECT statement with the aggregate functions and specify the table from which to retrieve the data."], "gold_sql": "SELECT sum(amount_piad) ,  avg(amount_piad) FROM claim_headers", "source_tables": ["claim_headers"], "pred_sql": "SELECT SUM(Amount_Paid) AS Total_Amount_Paid, AVG(Amount_Paid) AS Average_Amount_Paid FROM Claim_Headers;", "hint": "\n"}
{"sample_id": "train.1516", "db_id": "insurance_and_eClaims", "question": "What are the total amount and average amount paid in claim headers?", "rationale": ["Identify the relevant table: The question pertains to claim headers, so we will use the Claim_Headers table.", "Determine the required calculations: We need to calculate the total amount paid and the average amount paid.", "Use aggregate functions: To get the total amount, we will use SUM(Amount_Paid), and for the average, we will use AVG(Amount_Paid).", "Construct the SQL query: We will select the total and average amounts from the Claim_Headers table."], "gold_sql": "SELECT sum(amount_piad) ,  avg(amount_piad) FROM claim_headers", "source_tables": ["claim_headers"], "pred_sql": "SELECT SUM(Amount_Paid) AS Total_Amount_Paid, AVG(Amount_Paid) AS Average_Amount_Paid\nFROM Claim_Headers;", "hint": "\n"}
{"sample_id": "train.1517", "db_id": "insurance_and_eClaims", "question": "Find the total amount claimed in the most recently created document.", "rationale": ["Identify the relevant tables: Claim_Headers for the amount claimed and Claims_Documents for the document creation date.", "We need to sum the 'Amount_Claimed' from the Claim_Headers table.", "Join Claim_Headers with Claims_Documents on the Claim_ID to link claims with their documents.", "Filter the results to only include claims associated with the most recently created document by using a subquery to find the maximum 'Created_Date' in the Claims_Documents table."], "gold_sql": "SELECT sum(t1.amount_claimed) FROM claim_headers AS t1 JOIN claims_documents AS t2 ON t1.claim_header_id  =  t2.claim_id WHERE t2.created_date  =  (SELECT created_date FROM claims_documents ORDER BY created_date LIMIT 1)", "source_tables": ["claims_documents", "claim_headers"], "pred_sql": "SELECT SUM(ch.Amount_Claimed) AS Total_Amount_Claimed\nFROM Claim_Headers ch\nJOIN Claims_Documents cd ON ch.Claim_Header_ID = cd.Claim_ID\nWHERE cd.Created_Date = (SELECT MAX(Created_Date) FROM Claims_Documents);", "hint": "\n"}
{"sample_id": "train.1519", "db_id": "insurance_and_eClaims", "question": "What is the name of the customer who has made the largest amount of claim in a single claim?", "rationale": ["Identify the relevant tables: Customers, Policies, and Claim_Headers.", "Join the Customers table with the Policies table on Customer_ID to link customers to their policies.", "Join the resulting table with the Claim_Headers table on Policy_ID to access claim information for each customer.", "Order the results by the Amount_Claimed in descending order to find the largest claim.", "Limit the results to 1 to get the customer with the largest claim."], "gold_sql": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_claimed  =  (SELECT max(amount_claimed) FROM claim_headers)", "source_tables": ["policies", "customers", "claim_headers"], "pred_sql": "SELECT c.Customer_Details \nFROM Customers c \nJOIN Policies p ON c.Customer_ID = p.Customer_ID \nJOIN Claim_Headers ch ON p.Policy_ID = ch.Policy_ID \nORDER BY ch.Amount_Claimed DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.1527", "db_id": "insurance_and_eClaims", "question": "What is the name of the claim processing stage that most of the claims are on?", "rationale": ["Identify the relevant tables: Claims_Processing and Claims_Processing_Stages are needed to find the claim processing stages.", "Join Claims_Processing with Claims_Headers to link claims to their headers.", "Join the result with Claims_Processing_Stages to get the names of the claim processing stages.", "Group the results by Claim_Status_Name to count how many claims are in each stage.", "Order the results by the count of claims in descending order to find the stage with the most claims.", "Limit the results to 1 to get only the stage with the highest count."], "gold_sql": "SELECT t2.claim_status_name FROM claims_processing AS t1 JOIN claims_processing_stages AS t2 ON t1.claim_stage_id  =  t2.claim_stage_id GROUP BY t1.claim_stage_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["claims_processing", "claims_processing_stages"], "pred_sql": "SELECT cps.Claim_Status_Name, COUNT(*) as Claim_Count\nFROM Claims_Processing cp\nJOIN Claims_Headers ch ON cp.Claim_ID = ch.Claim_Header_ID\nJOIN Claims_Processing_Stages cps ON cp.Claim_Stage_ID = cps.Claim_Stage_ID\nGROUP BY cps.Claim_Status_Name\nORDER BY Claim_Count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the different types of insurance policies from the 'Policies' table, grouping them by their policy type code. The placeholder in the LIMIT clause allows the user to specify the maximum number of policy types to retrieve, sorted by the frequency of each type in descending order.\"\n}\n"}
{"sample_id": "train.1535", "db_id": "insurance_and_eClaims", "question": "Find the names of all the customers and staff members.", "rationale": ["Identify the tables needed: Customers and Staff.", "Determine the columns to select: Customer_Details from Customers and Staff_Details from Staff.", "Use a SELECT statement to retrieve the desired columns.", "Since we want to find names from both tables, we can use a cross join (implicit join) by listing both tables in the FROM clause."], "gold_sql": "SELECT customer_details FROM customers UNION SELECT staff_details FROM staff", "source_tables": ["staff", "customers"], "pred_sql": "SELECT Customers.Customer_Details AS Customer_Name, Staff.Staff_Details AS Staff_Name \nFROM Customers, Staff;", "hint": "\n"}
{"sample_id": "train.1545", "db_id": "insurance_and_eClaims", "question": "Which customer is associated with the latest policy?", "rationale": ["Identify the relevant tables: Customers and Policies.", "We need to find the customer associated with the latest policy, which means we need to look at the Policies table for the latest Start_Date.", "Join the Customers table with the Policies table on Customer_ID to get customer details.", "Use a subquery to find the maximum Start_Date from the Policies table to identify the latest policy.", "Select the Customer_ID and Customer_Details from the Customers table where the Start_Date matches the latest policy's Start_Date."], "gold_sql": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)", "source_tables": ["policies", "customers"], "pred_sql": "SELECT Customers.Customer_ID, Customers.Customer_Details \nFROM Policies \nJOIN Customers ON Policies.Customer_ID = Customers.Customer_ID \nWHERE Policies.Start_Date = (SELECT MAX(Start_Date) FROM Policies)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the different types of insurance policies from the 'Policies' table, grouping them by their policy type code. The placeholder in the LIMIT clause allows the user to specify the maximum number of policy types to retrieve, sorted by the frequency of each type in descending order.\"\n}\n"}
{"sample_id": "train.1546", "db_id": "insurance_and_eClaims", "question": "Find the customer who started a policy most recently.", "rationale": ["Identify the relevant tables: We need to find information from the Customers and Policies tables.", "Determine the relationship: The Policies table has a foreign key linking to the Customers table via Customer_ID.", "Select the necessary fields: We want to retrieve the Customer_ID and Customer_Details from the Customers table.", "Sort the policies by Start_Date in descending order to get the most recent policy first.", "Limit the results to 1 to get only the most recent customer."], "gold_sql": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)", "source_tables": ["policies", "customers"], "pred_sql": "SELECT Customers.Customer_ID, Customers.Customer_Details \nFROM Policies \nJOIN Customers ON Policies.Customer_ID = Customers.Customer_ID \nORDER BY Policies.Start_Date DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique insurance policy types from the 'Policies' table that have been issued more than a specified number of times. The placeholder in the HAVING clause represents the minimum count of policies required to be included in the results.\"\n}\n"}
{"sample_id": "train.1553", "db_id": "customers_and_invoices", "question": "Show the id, the account name, and other account details for all accounts by the customer with first name 'Meaghan'.", "rationale": ["Identify the relevant tables: Accounts and Customers.", "Determine the columns needed: account_id, account_name, and other_account_details from Accounts; customer_id from Customers for the join.", "Join the Accounts table with the Customers table on customer_id to link accounts to customers.", "Filter the results to include only those accounts belonging to the customer with the first name 'Meaghan'.", "Construct the SQL SELECT statement to retrieve the specified columns from the joined tables."], "gold_sql": "SELECT T1.account_id ,  T1.date_account_opened ,  T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  'Meaghan'", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT a.account_id, a.account_name, a.other_account_details \nFROM Accounts a \nJOIN Customers c ON a.customer_id = c.customer_id \nWHERE c.customer_first_name = 'Meaghan';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of unique customers who have opened accounts in the 'Accounts' table. The placeholder in the SELECT statement allows for potential filtering or additional conditions to be applied if needed.\"\n}\n"}
{"sample_id": "train.1556", "db_id": "customers_and_invoices", "question": "What are the names and other details for accounts corresponding to the customer named Meaghan Keeling?", "rationale": ["Identify the relevant tables: Accounts and Customers.", "We need to join these two tables on the customer_id to link accounts to customers.", "Filter the results to only include the customer named Meaghan Keeling by checking both first and last names.", "Select the account_name and other_account_details from the Accounts table."], "gold_sql": "SELECT T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  'Meaghan' AND T2.customer_last_name  =  'Keeling'", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT a.account_name, a.other_account_details \nFROM Accounts a \nJOIN Customers c ON a.customer_id = c.customer_id \nWHERE c.customer_first_name = 'Meaghan' AND c.customer_last_name = 'Keeling';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of unique customers who have opened accounts in the 'Accounts' table. The placeholder in the SELECT statement allows for potential filtering or additional conditions to be applied if needed.\"\n}\n"}
{"sample_id": "train.1558", "db_id": "customers_and_invoices", "question": "What are the full names of customers with the account name 900?", "rationale": ["Identify the relevant tables: Customers and Accounts.", "We need to join these tables on the customer_id to access customer information along with their account details.", "The requirement is to filter customers based on the account name, which is found in the Accounts table.", "We will select the full name of the customers, which is a concatenation of their first and last names.", "The final SQL query will include a WHERE clause to filter by the account name '900'."], "gold_sql": "SELECT T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T1.account_name  =  '900'", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT customer_first_name || ' ' || customer_last_name AS full_name\nFROM Customers\nJOIN Accounts ON Customers.customer_id = Accounts.customer_id\nWHERE Accounts.account_name = '900';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of unique customers who have opened accounts in the 'Accounts' table. The placeholder in the SELECT statement allows for potential filtering or additional conditions to be applied if needed.\"\n}\n"}
{"sample_id": "train.1569", "db_id": "customers_and_invoices", "question": "Show id, first name and last name for all customers and the number of accounts.", "rationale": ["We need to select the customer ID, first name, and last name from the Customers table.", "We also need to count the number of accounts associated with each customer from the Accounts table.", "To achieve this, we will perform a LEFT JOIN between the Customers table and the Accounts table on the customer_id field.", "We will group the results by customer ID, first name, and last name to ensure we get the count of accounts for each customer."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT c.customer_id, c.customer_first_name, c.customer_last_name, COUNT(a.account_id) AS number_of_accounts\nFROM Customers c\nLEFT JOIN Accounts a ON c.customer_id = a.customer_id\nGROUP BY c.customer_id, c.customer_first_name, c.customer_last_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of unique customers who have opened accounts in the 'Accounts' table. The placeholder in the SELECT statement allows for potential filtering or additional conditions to be applied if needed.\"\n}\n"}
{"sample_id": "train.1570", "db_id": "customers_and_invoices", "question": "What are the the full names and ids for all customers, and how many accounts does each have?", "rationale": ["Identify the required fields: customer_id, full name (combination of first and last name), and account count.", "To get the full name, concatenate the first name and last name using '||'.", "Use a LEFT JOIN to connect the Customers table with the Accounts table on customer_id, ensuring all customers are included even if they have no accounts.", "Count the number of accounts for each customer using COUNT(a.account_id).", "Group the results by customer_id and the full name to ensure accurate counting of accounts per customer."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT c.customer_id, c.customer_first_name || ' ' || c.customer_last_name AS full_name, COUNT(a.account_id) AS account_count\nFROM Customers c\nLEFT JOIN Accounts a ON c.customer_id = a.customer_id\nGROUP BY c.customer_id, c.customer_first_name, c.customer_last_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of unique customers who have opened accounts in the 'Accounts' table. The placeholder in the SELECT statement allows for potential filtering or additional conditions to be applied if needed.\"\n}\n"}
{"sample_id": "train.1580", "db_id": "customers_and_invoices", "question": "Count the number of financial transactions that correspond to each account id.", "rationale": ["Identify the table to query: Financial_Transactions.", "Determine the columns needed: account_id and transaction_id.", "Use COUNT() function to count the number of transactions for each account_id.", "Group the results by account_id to get the count for each account."], "gold_sql": "SELECT count(*) ,  account_id FROM Financial_transactions", "source_tables": ["financial_transactions"], "pred_sql": "SELECT account_id, COUNT(transaction_id) AS transaction_count \nFROM Financial_Transactions \nGROUP BY account_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of financial transactions grouped by account ID from the 'Financial_Transactions' table. The placeholder in the SELECT clause represents the account ID for which the transaction count is being retrieved.\"\n}\n"}
{"sample_id": "train.1607", "db_id": "customers_and_invoices", "question": "Show the order ids and the number of invoices for each order.", "rationale": ["We need to retrieve the order ids and the number of invoices for each order.", "The 'Orders' table contains the order ids, so we will select 'Orders.order_id'.", "To count the number of invoices for each order, we will use the COUNT function on 'Invoices.invoice_number'.", "We will join the 'Orders' table with the 'Invoices' table on the common column 'order_id'.", "Since an order may not have any invoices, we will use a LEFT JOIN to ensure all orders are included in the result.", "Finally, we will group the results by 'Orders.order_id' to get the count of invoices for each order."], "gold_sql": "SELECT order_id ,  count(*) FROM Invoices GROUP BY order_id", "source_tables": ["invoices"], "pred_sql": "SELECT Orders.order_id, COUNT(Invoices.invoice_number) AS number_of_invoices\nFROM Orders\nLEFT JOIN Invoices ON Orders.order_id = Invoices.order_id\nGROUP BY Orders.order_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of distinct products associated with each order from the 'Order_Items' table. The placeholder in the SELECT clause represents the unique order identifier, while the count function calculates the number of different products for each order.\"\n}\n"}
{"sample_id": "train.1617", "db_id": "customers_and_invoices", "question": "Show the order ids and the number of items in each order.", "rationale": ["We need to retrieve the order ids and the number of items in each order.", "The 'Order_Items' table contains the 'order_id' and 'order_item_id' which we can use to count the number of items per order.", "We will use the COUNT function to count the distinct 'order_item_id' for each 'order_id'.", "To get the total number of items for each order, we will group the results by 'order_id'."], "gold_sql": "SELECT order_id ,  count(*) FROM Order_items GROUP BY order_id", "source_tables": ["order_items"], "pred_sql": "SELECT order_id, COUNT(order_item_id) AS number_of_items\nFROM Order_Items\nGROUP BY order_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of distinct products associated with each order from the 'Order_Items' table. The placeholder in the SELECT clause represents the unique order identifier, while the count function calculates the number of different products for each order.\"\n}\n"}
{"sample_id": "train.1622", "db_id": "customers_and_invoices", "question": "What are teh names of the different products, as well as the number of customers who have ordered each product.", "rationale": ["Identify the relevant tables: Products, Order_Items, and Orders are needed to get product names and customer counts.", "Join the Products table with the Order_Items table on product_id to link products with their orders.", "Join the resulting table with the Orders table on order_id to associate orders with customers.", "Use COUNT(DISTINCT o.customer_id) to count the number of unique customers who ordered each product.", "Group the results by product name to get the count of customers for each product."], "gold_sql": "SELECT T2.product_name ,  count(*) FROM Order_items AS T1 JOIN Products AS T2 ON T1.product_id  =  T2.product_id JOIN Orders AS T3 ON T3.order_id  =  T1.order_id GROUP BY T2.product_name", "source_tables": ["orders", "products", "order_items"], "pred_sql": "SELECT p.product_name, COUNT(DISTINCT o.customer_id) AS customer_count\nFROM Products p\nJOIN Order_Items oi ON p.product_id = oi.product_id\nJOIN Orders o ON oi.order_id = o.order_id\nGROUP BY p.product_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of distinct products associated with each order from the 'Order_Items' table. The placeholder in the SELECT clause represents the unique order identifier, while the count function calculates the number of different products for each order.\"\n}\n"}
{"sample_id": "train.2050", "db_id": "party_people", "question": "Which ministers are not a part of the Progress Party?", "rationale": ["We need to find ministers who are not part of the Progress Party.", "The relevant tables are 'member' and 'party', as ministers are associated with political parties.", "We will join the 'member' table with the 'party' table on the Party_ID column to get the names of the ministers along with their party information.", "We will filter the results using a WHERE clause to exclude those who belong to the 'Progress Party'.", "Finally, we will select distinct member names to avoid duplicates."], "gold_sql": "SELECT minister FROM party WHERE party_name != 'Progress Party'", "source_tables": ["party"], "pred_sql": "SELECT DISTINCT m.Member_Name \nFROM member m \nJOIN party p ON m.Party_ID = p.Party_ID \nWHERE p.Party_name != 'Progress Party';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the ministers associated with political parties from the 'party' table, excluding a specific party name. The placeholder in the WHERE clause represents the name of the party to be excluded.\"\n}\n"}
{"sample_id": "train.2057", "db_id": "party_people", "question": "Show all party names and the number of members in each party.", "rationale": ["We need to retrieve the names of all political parties and the count of their members.", "To do this, we will select the 'Party_name' from the 'party' table.", "We will also need to count the 'Member_ID' from the 'member' table to get the number of members in each party.", "Since a party can have multiple members, we will use a LEFT JOIN to connect the 'party' table with the 'member' table on the 'Party_ID'.", "To get the count of members for each party, we will use the COUNT() function and group the results by 'Party_name'."], "gold_sql": "SELECT T2.party_name ,  count(*) FROM Member AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id", "source_tables": ["party", "member"], "pred_sql": "SELECT party.Party_name, COUNT(member.Member_ID) AS Number_of_Members\nFROM party\nLEFT JOIN member ON party.Party_ID = member.Party_ID\nGROUP BY party.Party_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the ministers associated with political parties from the 'party' table, excluding a specific party name. The placeholder in the WHERE clause represents the name of the party to be excluded.\"\n}\n"}
{"sample_id": "train.2072", "db_id": "party_people", "question": "How many events are there for each party?", "rationale": ["We need to count the number of events for each political party.", "To do this, we will select the party name from the 'party' table.", "We will use a LEFT JOIN to connect the 'party' table with the 'party_events' table on the Party_ID column.", "Using COUNT(party_events.Event_ID) will allow us to count the number of events associated with each party.", "We will group the results by party name to get the count for each individual party."], "gold_sql": "SELECT T2.party_name ,  count(*) FROM party_events AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id", "source_tables": ["party", "party_events"], "pred_sql": "SELECT party.Party_name, COUNT(party_events.Event_ID) AS Event_Count\nFROM party\nLEFT JOIN party_events ON party.Party_ID = party_events.Party_ID\nGROUP BY party.Party_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the ministers associated with political parties from the 'party' table, excluding a specific party name. The placeholder in the WHERE clause represents the name of the party to be excluded.\"\n}\n"}
{"sample_id": "train.2081", "db_id": "party_people", "question": "How many Annual Meeting events happened in the United Kingdom region?", "rationale": ["Identify the relevant tables: party_events, party, and region.", "We need to count the number of events, so we will use the COUNT() function.", "Filter the events to only include those named 'Annual Meeting'.", "Join the party_events table with the party table on Party_ID to get the region information.", "Join the party table with the region table on Region_ID to filter by the United Kingdom region.", "Construct the SQL query to count the filtered events."], "gold_sql": "SELECT count(*) FROM region AS t1 JOIN party AS t2 ON t1.region_id  =  t2.region_id JOIN party_events AS t3 ON t2.party_id  =  t3.party_id WHERE t1.region_name  =  'United Kingdom' AND t3.Event_Name  =  'Annaual Meeting'", "source_tables": ["party", "party_events", "region"], "pred_sql": "SELECT COUNT(*) AS Annual_Meeting_Count\nFROM party_events pe\nJOIN party p ON pe.Party_ID = p.Party_ID\nJOIN region r ON p.Region_ID = r.Region_ID\nWHERE pe.Event_Name = 'Annual Meeting' AND r.Region_name = 'United Kingdom';", "hint": "\n"}
{"sample_id": "train.2167", "db_id": "formula_1", "question": "What is the id and family name of the driver who has the longest laptime?", "rationale": ["Identify the relevant tables: We need data from the 'results' table for lap times and the 'drivers' table for driver information.", "We need to find the driver with the longest lap time, which means we need to look for the maximum value in the 'time' column of the 'results' table.", "To get the driver's family name, we will join the 'results' table with the 'drivers' table on the 'driverId' column.", "The final query will select the 'driverId' and 'surname' of the driver whose lap time is equal to the maximum lap time found in the subquery."], "gold_sql": "SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT 1", "source_tables": ["laptimes", "drivers"], "pred_sql": "SELECT results.driverId, drivers.surname \nFROM results \nJOIN drivers ON results.driverId = drivers.driverId \nWHERE results.time = (SELECT MAX(time) FROM results);", "hint": "\n"}
{"sample_id": "train.2174", "db_id": "formula_1", "question": "How many drivers did not race in 2009?", "rationale": ["We need to find the number of drivers who did not participate in any races in the year 2009.", "To do this, we will use the 'drivers' table to get all drivers.", "We will perform a LEFT JOIN with the 'results' table on the driverId, filtering for the year 2009.", "The LEFT JOIN will allow us to include all drivers, even those who have no corresponding entries in the results for 2009.", "We will then filter the results to find those drivers where the result's driverId is NULL, indicating they did not race in 2009.", "Finally, we will count the distinct driverIds that meet this condition to get the total number of drivers who did not race in 2009."], "gold_sql": "SELECT count(DISTINCT driverId) FROM results WHERE raceId NOT IN( SELECT raceId FROM races WHERE YEAR != 2009 )", "source_tables": ["results", "races"], "pred_sql": "SELECT COUNT(DISTINCT d.driverId) AS drivers_not_raced_in_2009\nFROM drivers d\nLEFT JOIN results r ON d.driverId = r.driverId AND r.year = 2009\nWHERE r.driverId IS NULL;", "hint": "\n"}
{"sample_id": "train.2179", "db_id": "formula_1", "question": "Find the id and forenames of drivers who participated both the races with name Australian Grand Prix and the races with name Chinese Grand Prix?", "rationale": ["Identify the tables involved: We need the 'drivers' table for driver information and the 'results' and 'races' tables to link drivers to races.", "We need to find drivers who participated in both the 'Australian Grand Prix' and 'Chinese Grand Prix'.", "First, we will join the 'drivers' table with the 'results' table to get the driver IDs for the races they participated in.", "Next, we will join the 'results' table with the 'races' table to filter for the 'Australian Grand Prix'.", "We will use a subquery to find driver IDs from the 'results' table for the 'Chinese Grand Prix'.", "The main query will filter drivers who are in both the results of the 'Australian Grand Prix' and the subquery results for the 'Chinese Grand Prix'.", "Finally, we will select the driver ID and forename from the 'drivers' table."], "gold_sql": "SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = 'Australian Grand Prix' INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = 'Chinese Grand Prix'", "source_tables": ["races", "drivers", "results"], "pred_sql": "SELECT d.driverId, d.forename\nFROM drivers d\nJOIN results r1 ON d.driverId = r1.driverId\nJOIN races ra ON r1.raceId = ra.raceId\nWHERE ra.name = 'Australian Grand Prix'\nAND d.driverId IN (\n    SELECT r2.driverId\n    FROM results r2\n    JOIN races rb ON r2.raceId = rb.raceId\n    WHERE rb.name = 'Chinese Grand Prix'\n)\nGROUP BY d.driverId, d.forename;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a distinct list of race names from the 'races' table, sorted in descending order. The placeholder in the ORDER BY clause indicates that the results will be organized based on the race names.\"\n}\n"}
{"sample_id": "train.2180", "db_id": "formula_1", "question": "What is the id and first name of all the drivers who participated in the Australian Grand Prix and the Chinese Grand Prix?", "rationale": ["Identify the tables needed: drivers, results, and races.", "We need to get the driverId and forename from the drivers table.", "We need to join the results table to link drivers to the races they participated in.", "We also need to join the races table to filter for the specific races: Australian Grand Prix and Chinese Grand Prix.", "Use a WHERE clause to filter the races by their names.", "Since we want unique drivers, we can use GROUP BY on driverId and forename."], "gold_sql": "SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = 'Australian Grand Prix' INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = 'Chinese Grand Prix'", "source_tables": ["races", "drivers", "results"], "pred_sql": "SELECT d.driverId, d.forename \nFROM drivers d \nJOIN results r ON d.driverId = r.driverId \nJOIN races ra ON r.raceId = ra.raceId \nWHERE ra.name = 'Australian Grand Prix' OR ra.name = 'Chinese Grand Prix' \nGROUP BY d.driverId, d.forename;", "hint": "\n"}
{"sample_id": "train.2182", "db_id": "formula_1", "question": "What are the first and last names of all drivers who participated in the Australian Grand Prix but not the Chinese Grand Prix?", "rationale": ["Identify the tables needed: drivers, results, and races.", "We need to find drivers who participated in the Australian Grand Prix, so we will join the drivers table with the results table and then with the races table to filter by the race name.", "Next, we need to ensure these drivers did not participate in the Chinese Grand Prix. We can achieve this by using a subquery that selects driverIds from results where the race name is 'Chinese Grand Prix'.", "The final query will select the forename and surname of drivers who meet the criteria."], "gold_sql": "SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Australian Grand Prix' EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Chinese Grand Prix'", "source_tables": ["races", "drivers", "results"], "pred_sql": "SELECT d.forename, d.surname \nFROM drivers d \nJOIN results r1 ON d.driverId = r1.driverId \nJOIN races ra ON r1.raceId = ra.raceId \nWHERE ra.name = 'Australian Grand Prix' \nAND d.driverId NOT IN (\n    SELECT r2.driverId \n    FROM results r2 \n    JOIN races rb ON r2.raceId = rb.raceId \n    WHERE rb.name = 'Chinese Grand Prix'\n);", "hint": "\n"}
{"sample_id": "train.2190", "db_id": "formula_1", "question": "For each constructor id, how many races are there?", "rationale": ["We need to count the number of races for each constructor id.", "The relevant table for this information is 'constructorStandings', which contains a record for each constructor's performance in each race.", "We will select the 'constructorId' and use the COUNT function to count the number of entries for each constructor.", "To get the count for each constructor, we will group the results by 'constructorId'."], "gold_sql": "SELECT count(*) ,  constructorid FROM constructorStandings GROUP BY constructorid", "source_tables": ["constructorstandings"], "pred_sql": "SELECT constructorId, COUNT(*) AS total_races\nFROM constructorStandings\nGROUP BY constructorId;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of the total number of constructor standings for each constructor from the 'constructorStandings' table. The placeholder in the SELECT statement represents the constructor's identifier, which is grouped to show the total standings for each constructor.\"\n}\n"}
{"sample_id": "train.2194", "db_id": "formula_1", "question": "What are the names of all races held after 2000 in Spain?", "rationale": ["Identify the relevant tables: 'races' for race information and 'circuits' for circuit location.", "We need to filter races held after the year 2000, so we will use the 'year' column from the 'races' table.", "To find races held in Spain, we will join the 'races' table with the 'circuits' table on the 'circuitId' column and filter by the 'country' column in the 'circuits' table.", "Select the 'name' of the races from the 'races' table.", "Sort the results in descending order by race name as indicated in the hint."], "gold_sql": "SELECT DISTINCT T1.name FROM races AS T1 JOIN circuits AS T2 ON T1.circuitid = T2.circuitid WHERE T2.country = 'Spain' AND T1.year > 2000", "source_tables": ["races", "circuits"], "pred_sql": "SELECT r.name \nFROM races r \nJOIN circuits c ON r.circuitId = c.circuitId \nWHERE r.year > 2000 AND c.country = 'Spain' \nORDER BY r.name DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a distinct list of race names from the 'races' table, sorted in descending order. The placeholder in the ORDER BY clause indicates that the results will be organized based on the race names.\"\n}\n"}
{"sample_id": "train.2217", "db_id": "formula_1", "question": "Find the names of Japanese constructors that have once earned more than 5 points?", "rationale": ["Identify the relevant tables: constructors and constructorStandings.", "We need to find constructors that are Japanese, so we will filter the constructors table by nationality.", "We will join the constructors table with the constructorStandings table on the constructorId to access the points earned by each constructor.", "We will group the results by constructorId to aggregate the points earned by each constructor.", "Finally, we will use the HAVING clause to filter out constructors that have earned more than 5 points."], "gold_sql": "SELECT T1.name FROM constructors AS T1 JOIN constructorstandings AS T2 ON T1.constructorid = T2.constructorid WHERE T1.nationality = 'Japanese' AND T2.points > 5", "source_tables": ["constructorstandings", "constructors"], "pred_sql": "SELECT c.name \nFROM constructors c \nJOIN constructorStandings cs ON c.constructorId = cs.constructorId \nWHERE c.nationality = 'Japanese' \nGROUP BY c.constructorId \nHAVING SUM(cs.points) > 5;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of the total number of constructor standings for each constructor from the 'constructorStandings' table. The placeholder in the SELECT statement represents the constructor's identifier, which is grouped to show the total standings for each constructor.\"\n}\n"}
{"sample_id": "train.2218", "db_id": "formula_1", "question": "What are the names of all the Japanese constructors that have earned more than 5 points?", "rationale": ["Identify the relevant tables: constructors and constructorStandings.", "We need to find constructors that are Japanese, so we will filter by nationality in the constructors table.", "We need to sum the points from the constructorStandings table for each constructor.", "Join the constructors table with the constructorStandings table on the constructorId.", "Group the results by constructorId to aggregate the points.", "Use the HAVING clause to filter out constructors with a total point sum greater than 5."], "gold_sql": "SELECT T1.name FROM constructors AS T1 JOIN constructorstandings AS T2 ON T1.constructorid = T2.constructorid WHERE T1.nationality = 'Japanese' AND T2.points > 5", "source_tables": ["constructorstandings", "constructors"], "pred_sql": "SELECT c.name \nFROM constructors c \nJOIN constructorStandings cs ON c.constructorId = cs.constructorId \nWHERE c.nationality = 'Japanese' \nGROUP BY c.constructorId \nHAVING SUM(cs.points) > 5;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of the total number of constructor standings for each constructor from the 'constructorStandings' table. The placeholder in the SELECT statement represents the constructor's identifier, which is grouped to show the total standings for each constructor.\"\n}\n"}
{"sample_id": "train.2220", "db_id": "formula_1", "question": "What is the average fastest lap speed for the Monaco Grand Prix in 2008?", "rationale": ["Identify the relevant tables: races, lapTimes, and circuits are needed to get the average fastest lap speed for a specific race.", "We need to join the races table with the lapTimes table on raceId to access the fastest lap speeds.", "We also need to join the circuits table to filter for the Monaco Grand Prix.", "The WHERE clause will specify the circuit name as 'Monaco Grand Prix' and the year as 2008.", "Finally, we will use the AVG() function to calculate the average of the fastest lap speeds."], "gold_sql": "SELECT avg(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "pred_sql": "SELECT AVG(lapTimes.fastestLapSpeed) AS average_fastest_lap_speed\nFROM races\nJOIN lapTimes ON races.raceId = lapTimes.raceId\nJOIN circuits ON races.circuitId = circuits.circuitId\nWHERE circuits.name = 'Monaco Grand Prix' AND races.year = 2008;", "hint": "\n"}
{"sample_id": "train.2222", "db_id": "formula_1", "question": "What is the maximum fastest lap speed in the Monaco Grand Prix in 2008?", "rationale": ["Identify the relevant tables: races, lapTimes, and circuits.", "We need to find the maximum fastest lap speed, so we will use the MAX() function on the fastestLapSpeed column from the lapTimes table.", "To get the correct race, we need to filter by the circuit name (Monaco Grand Prix) and the year (2008).", "Join the races table with lapTimes on raceId to access the fastest lap speeds for each race.", "Join the races table with circuits on circuitId to filter by the circuit name.", "Construct the SQL query to select the maximum fastest lap speed for the specified circuit and year."], "gold_sql": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "pred_sql": "SELECT MAX(lapTimes.fastestLapSpeed) AS max_fastest_lap_speed\nFROM races\nJOIN lapTimes ON races.raceId = lapTimes.raceId\nJOIN circuits ON races.circuitId = circuits.circuitId\nWHERE circuits.name = 'Monaco Grand Prix' AND races.year = 2008;", "hint": "\n"}
{"sample_id": "train.2223", "db_id": "formula_1", "question": "What are the maximum fastest lap speed in races held after 2004 grouped by race name and ordered by year?", "rationale": ["Identify the relevant tables: 'races' for race information and 'lapTimes' for fastest lap speeds.", "We need to find the maximum fastest lap speed for races held after 2004, so we will filter the 'races' table by year.", "Join the 'races' table with the 'lapTimes' table on the raceId to access the fastest lap speeds associated with each race.", "Use the MAX() function to get the maximum fastest lap speed for each race.", "Group the results by race name to get the maximum speed for each race.", "Order the results by year to see the races chronologically."], "gold_sql": "SELECT max(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "pred_sql": "SELECT r.name AS race_name, MAX(l.fastestLapSpeed) AS max_fastest_lap_speed\nFROM races r\nJOIN lapTimes l ON r.raceId = l.raceId\nWHERE r.year > 2004\nGROUP BY r.name\nORDER BY r.year;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a distinct list of race names from the 'races' table, sorted in descending order. The placeholder in the ORDER BY clause indicates that the results will be organized based on the race names.\"\n}\n"}
{"sample_id": "train.2224", "db_id": "formula_1", "question": "For each race name, What is the maximum fastest lap speed for races after 2004 ordered by year?", "rationale": ["Identify the relevant tables: 'races' for race names and years, and 'lapTimes' for fastest lap speeds.", "Join the 'races' table with the 'lapTimes' table on the raceId to associate each lap time with its corresponding race.", "Filter the results to include only races that occurred after the year 2004 using the WHERE clause.", "Group the results by race name to calculate the maximum fastest lap speed for each race using the MAX function.", "Select the race name and the maximum fastest lap speed, and order the results by year."], "gold_sql": "SELECT max(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "pred_sql": "SELECT r.name, MAX(l.fastestLapSpeed) AS max_fastest_lap_speed\nFROM races r\nJOIN lapTimes l ON r.raceId = l.raceId\nWHERE r.year > 2004\nGROUP BY r.name\nORDER BY r.year;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a distinct list of race names from the 'races' table, sorted in descending order. The placeholder in the ORDER BY clause indicates that the results will be organized based on the race names.\"\n}\n"}
{"sample_id": "train.2325", "db_id": "csu_1", "question": "What campuses are located in the county of Los Angeles?", "rationale": ["Identify the relevant table: The question asks about campuses, which are listed in the 'Campuses' table.", "Determine the filtering condition: The user is interested in campuses located in 'Los Angeles', which is a specific county.", "Construct the SQL query: Use a SELECT statement to retrieve all columns from the 'Campuses' table where the 'County' column matches 'Los Angeles'."], "gold_sql": "SELECT campus FROM campuses WHERE county  =  'Los Angeles'", "source_tables": ["campuses"], "pred_sql": "SELECT * FROM Campuses WHERE County = 'Los Angeles';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the campuses located in a specific county from the 'Campuses' table. The placeholder in the WHERE clause represents the name of the county.\"\n}\n"}
{"sample_id": "train.2347", "db_id": "csu_1", "question": "In what year was the most degrees conferred?", "rationale": ["Identify the relevant table: degrees, which contains information about the years when degrees were awarded.", "We need to find the year with the most degrees conferred, so we will group the results by Year.", "Count the number of degrees awarded for each year using COUNT(Degrees).", "Order the results in descending order to get the year with the highest count first.", "Limit the results to 1 to get only the year with the most degrees conferred."], "gold_sql": "SELECT YEAR FROM degrees GROUP BY YEAR ORDER BY sum(degrees) DESC LIMIT 1", "source_tables": ["degrees"], "pred_sql": "SELECT Year FROM degrees GROUP BY Year ORDER BY COUNT(Degrees) DESC LIMIT 1;", "hint": "\n"}
{"sample_id": "train.2348", "db_id": "csu_1", "question": "Which campus has the most degrees conferred in all times?", "rationale": ["Identify the relevant table for degrees conferred, which is the 'degrees' table.", "We need to count the number of degrees awarded for each campus, so we will use the COUNT() function.", "Group the results by 'Campus' to aggregate the degree counts for each campus.", "Order the results in descending order based on the total degrees conferred to find the campus with the most degrees.", "Limit the results to 1 to get only the campus with the highest count."], "gold_sql": "SELECT campus FROM degrees GROUP BY campus ORDER BY sum(degrees) DESC LIMIT 1", "source_tables": ["degrees"], "pred_sql": "SELECT Campus, COUNT(Degrees) AS TotalDegrees\nFROM degrees\nGROUP BY Campus\nORDER BY TotalDegrees DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of campuses from the 'Campuses' table that have records for a specific year. The placeholder in the WHERE clause represents the year for which the campus data is being queried.\"\n}\n"}
{"sample_id": "train.2349", "db_id": "csu_1", "question": "What campus has the most degrees  conferrred over its entire existence?", "rationale": ["Identify the relevant table: The 'degrees' table contains information about the degrees awarded at each campus.", "Count the total number of degrees awarded for each campus: Use COUNT(Degrees) to aggregate the number of degrees per campus.", "Group the results by campus: Use GROUP BY Campus to ensure the count is calculated for each individual campus.", "Order the results to find the campus with the most degrees: Use ORDER BY TotalDegrees DESC to sort the campuses by the total number of degrees in descending order.", "Limit the results to the top campus: Use LIMIT 1 to return only the campus with the highest count of degrees."], "gold_sql": "SELECT campus FROM degrees GROUP BY campus ORDER BY sum(degrees) DESC LIMIT 1", "source_tables": ["degrees"], "pred_sql": "SELECT Campus, COUNT(Degrees) AS TotalDegrees\nFROM degrees\nGROUP BY Campus\nORDER BY TotalDegrees DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of campuses from the 'Campuses' table that have records for a specific year. The placeholder in the WHERE clause represents the year for which the campus data is being queried.\"\n}\n"}
{"sample_id": "train.2351", "db_id": "csu_1", "question": "What campus has the most faculties in 2003?", "rationale": ["Identify the relevant tables: 'Campuses' for campus names and 'faculty' for faculty counts.", "Join the 'Campuses' table with the 'faculty' table on the campus identifier.", "Filter the results to only include records from the year 2003.", "Order the results by the number of faculty in descending order to find the campus with the most faculty.", "Limit the results to 1 to get only the campus with the highest faculty count."], "gold_sql": "SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  2003 ORDER BY T2.faculty DESC LIMIT 1", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT c.Campus, f.Faculty \nFROM Campuses c \nJOIN faculty f ON c.Id = f.Campus \nWHERE f.Year = 2003 \nORDER BY f.Faculty DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of campuses from the 'Campuses' table that have records for a specific year. The placeholder in the WHERE clause represents the year for which the campus data is being queried.\"\n}\n"}
{"sample_id": "train.2358", "db_id": "csu_1", "question": "For each Orange county campus, report the number of degrees granted after 2000.", "rationale": ["Identify the relevant tables: 'degrees' for degrees granted and 'Campuses' for campus information.", "We need to filter campuses located in 'Orange' county, so we will join the 'degrees' table with the 'Campuses' table on the campus identifier.", "We need to count the number of degrees granted after the year 2000, so we will apply a condition on the 'Year' column in the 'degrees' table.", "The final SQL query will select the count of degrees from the joined tables with the specified conditions."], "gold_sql": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  'Orange' AND T2.year  >=  2000 GROUP BY T1.campus", "source_tables": ["degrees", "campuses"], "pred_sql": "SELECT COUNT(degrees.Degrees) AS DegreesGranted\nFROM degrees\nJOIN Campuses ON degrees.Campus = Campuses.Id\nWHERE Campuses.County = 'Orange' AND degrees.Year > '2000';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the total count of campuses located in a specific county from the 'Campuses' table. The placeholder in the WHERE clause represents the name of the county.\"\n}\n"}
{"sample_id": "train.2359", "db_id": "csu_1", "question": "What is the total number of degrees granted after 2000 for each Orange county campus?", "rationale": ["Identify the relevant tables: 'Campuses' for campus information and 'degrees' for degree information.", "We need to count the total degrees granted after the year 2000, so we will filter the 'degrees' table based on the 'Year' column.", "We also need to filter the campuses to only include those located in 'Orange' county, which is done using the 'County' column in the 'Campuses' table.", "To get the total number of degrees for each campus, we will use a JOIN between 'Campuses' and 'degrees' on the campus identifier.", "Finally, we will group the results by campus name and count the degrees for each campus."], "gold_sql": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  'Orange' AND T2.year  >=  2000 GROUP BY T1.campus", "source_tables": ["degrees", "campuses"], "pred_sql": "SELECT c.Campus, COUNT(d.Degrees) AS TotalDegrees\nFROM Campuses c\nJOIN degrees d ON c.Id = d.Campus\nWHERE c.County = 'Orange' AND d.Year > '2000'\nGROUP BY c.Campus;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the total count of campuses located in a specific county from the 'Campuses' table. The placeholder in the WHERE clause represents the name of the county.\"\n}\n"}
{"sample_id": "train.2362", "db_id": "csu_1", "question": "What campus had more than 400 total enrollment but more than 200 full time enrollment in year 1956?", "rationale": ["Identify the relevant table for total enrollment and full-time equivalent (FTE) data, which is the 'enrollments' table.", "Determine the conditions specified in the query: total enrollment must be greater than 400 and full-time enrollment must be greater than 200.", "Specify the year of interest, which is 1956, to filter the results accordingly.", "Construct the SQL SELECT statement to retrieve the 'Campus' names that meet the specified criteria."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN enrollments AS t2 ON t1.id  =  t2.campus WHERE t2.year  =  1956 AND totalenrollment_ay  >  400 AND FTE_AY  >  200", "source_tables": ["enrollments", "campuses"], "pred_sql": "SELECT Campus \nFROM enrollments \nWHERE TotalEnrollment_AY > 400 \nAND FTE_AY > 200 \nAND Year = '1956';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of campuses from the 'Campuses' table that have records for a specific year. The placeholder in the WHERE clause represents the year for which the campus data is being queried.\"\n}\n"}
{"sample_id": "train.2367", "db_id": "csu_1", "question": "What campuses are in Los Angeles county?", "rationale": ["Identify the relevant table: The question pertains to campuses, so we will use the 'Campuses' table.", "Determine the filtering condition: We need to filter campuses based on the county, specifically 'Los Angeles'.", "Construct the SQL query: We will select all columns from the 'Campuses' table where the 'County' column matches 'Los Angeles'."], "gold_sql": "SELECT campus FROM campuses WHERE county  =  'Los Angeles'", "source_tables": ["campuses"], "pred_sql": "SELECT * FROM Campuses WHERE County = 'Los Angeles';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the campuses located in a specific county from the 'Campuses' table. The placeholder in the WHERE clause represents the name of the county.\"\n}\n"}
{"sample_id": "train.2368", "db_id": "csu_1", "question": "How many degrees were conferred in \"San Jose State University\" in 2000?", "rationale": ["Identify the relevant tables: degrees and Campuses.", "We need to count the number of degrees conferred, which is represented in the degrees table.", "We need to filter the results for the specific campus 'San Jose State University' and the year 2000.", "Join the degrees table with the Campuses table on the Campus identifier to get the campus name.", "Use a SUM function to count the degrees for the specified campus and year."], "gold_sql": "SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  'San Jose State University' AND t2.year  =  2000", "source_tables": ["degrees", "campuses"], "pred_sql": "SELECT SUM(CASE WHEN degrees.Campus = campuses.Id THEN 1 ELSE 0 END) AS TotalDegrees\nFROM degrees\nJOIN Campuses AS campuses ON degrees.Campus = campuses.Id\nWHERE campuses.Campus = 'San Jose State University' AND degrees.Year = '2000';", "hint": "\n"}
{"sample_id": "train.2377", "db_id": "csu_1", "question": "How many faculty lines are there at San Francisco State University in 2004?", "rationale": ["Identify the relevant table: The 'faculty' table contains the number of faculty members.", "Determine the specific campus: We need to find the Id for 'San Francisco State University' from the 'Campuses' table.", "Filter by year: We are interested in the year 2004.", "Construct the SQL query to select the Faculty count for the specified campus and year."], "gold_sql": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  2004 AND T2.campus  =  'San Francisco State University'", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT Faculty FROM faculty WHERE Campus = (SELECT Id FROM Campuses WHERE Campus = 'San Francisco State University') AND Year = 2004;", "hint": "\n"}
{"sample_id": "train.2378", "db_id": "csu_1", "question": "List the campus that have between 600 and 1000 faculty lines in year 2004.", "rationale": ["Identify the relevant tables: 'Campuses' and 'faculty'.", "We need to list campuses, so we will select the 'Campus' column from the 'Campuses' table.", "We need to filter the results based on the year 2004, which is a condition on the 'faculty' table.", "We also need to filter the faculty count to be between 600 and 1000, which is a condition on the 'faculty' table as well.", "Join the 'Campuses' table with the 'faculty' table on the campus identifier to combine the relevant data.", "Construct the SQL query using SELECT, JOIN, and WHERE clauses to meet the specified conditions."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  600 AND t2.faculty  <=  1000 AND T1.year  =  2004", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT Campuses.Campus \nFROM Campuses \nJOIN faculty ON Campuses.Id = faculty.Campus \nWHERE faculty.Year = 2004 \nAND faculty.Faculty BETWEEN 600 AND 1000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of campuses from the 'Campuses' table that have records for a specific year. The placeholder in the WHERE clause represents the year for which the campus data is being queried.\"\n}\n"}
{"sample_id": "train.2379", "db_id": "csu_1", "question": "What are the campuses that had between 600 and 1000 faculty members in 2004?", "rationale": ["Identify the relevant tables: Campuses and faculty.", "We need to find campuses with a specific number of faculty members in a specific year (2004).", "Join the Campuses table with the faculty table on the Campus identifier.", "Filter the results to only include records from the year 2004.", "Apply a condition to filter campuses that have between 600 and 1000 faculty members."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  600 AND t2.faculty  <=  1000 AND T1.year  =  2004", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT c.Campus \nFROM Campuses c \nJOIN faculty f ON c.Id = f.Campus \nWHERE f.Year = 2004 AND f.Faculty BETWEEN 600 AND 1000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of campuses from the 'Campuses' table that have records for a specific year. The placeholder in the WHERE clause represents the year for which the campus data is being queried.\"\n}\n"}
{"sample_id": "train.2380", "db_id": "csu_1", "question": "How many faculty lines are there in the university that conferred the most number of degrees in year 2002?", "rationale": ["Identify the year of interest, which is 2002.", "Determine which campus conferred the most degrees in 2002 by grouping the degrees table by campus and counting the number of degrees awarded.", "Use a subquery to find the campus with the maximum number of degrees awarded in 2002.", "Join the faculty table with the degrees table on the campus identifier to count the number of faculty lines associated with that campus.", "Filter the results to only include the campus that conferred the most degrees in 2002."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2002 ORDER BY t3.degrees DESC LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "pred_sql": "SELECT COUNT(faculty.Campus) AS FacultyCount\nFROM faculty\nJOIN degrees ON faculty.Campus = degrees.Campus\nWHERE degrees.Year = '2002'\nAND degrees.Campus = (SELECT Campus\n                     FROM degrees\n                     WHERE Year = '2002'\n                     GROUP BY Campus\n                     ORDER BY COUNT(Degrees) DESC\n                     LIMIT 1);", "hint": "\n"}
{"sample_id": "train.2383", "db_id": "csu_1", "question": "How many faculty members are at the university that gave the least number of degrees in 2001?", "rationale": ["Identify the relevant tables: 'faculty' for faculty members and 'degrees' for the number of degrees awarded.", "We need to find the campus that awarded the least number of degrees in 2001, so we will filter the 'degrees' table for the year 2001.", "We will then order the results by the number of degrees in ascending order to get the campus with the least degrees.", "Next, we will join the 'faculty' table with the 'degrees' table on the 'Campus' identifier to get the faculty count for that campus.", "Finally, we will limit the results to 1 to get the faculty count for the campus with the least degrees awarded."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2001 ORDER BY t3.degrees LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "pred_sql": "SELECT f.Faculty \nFROM faculty f \nJOIN degrees d ON f.Campus = d.Campus \nWHERE d.Year = '2001' \nORDER BY d.Degrees ASC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.2385", "db_id": "csu_1", "question": "How many undergraduates are there at San Jose State", "rationale": ["Identify the relevant table for undergraduate enrollments, which is 'discipline_enrollments'.", "We need to sum the number of undergraduates, so we will use the SUM function on the 'Undergraduate' column.", "To filter the results for San Jose State, we will join the 'discipline_enrollments' table with the 'Campuses' table on the campus identifier.", "We will use a WHERE clause to specify that we only want records where the campus name is 'San Jose State'."], "gold_sql": "SELECT sum(t1.undergraduate) FROM discipline_enrollments AS t1 JOIN campuses AS t2 ON t1.campus  =  t2.id WHERE t1.year  =  2004 AND t2.campus  =  'San Jose State University'", "source_tables": ["discipline_enrollments", "campuses"], "pred_sql": "SELECT SUM(Undergraduate) AS Total_Undergraduates \nFROM discipline_enrollments \nJOIN Campuses ON discipline_enrollments.Campus = Campuses.Id \nWHERE Campuses.Campus = 'San Jose State';", "hint": "\n"}
{"sample_id": "train.3131", "db_id": "assets_maintenance", "question": "Which engineer has visited the most times? Show the engineer id, first name and last name.", "rationale": ["Identify the relevant tables: Engineer_Visits and Maintenance_Engineers.", "We need to count the number of visits for each engineer, so we will use COUNT(*) to aggregate the visits.", "Join the Engineer_Visits table with the Maintenance_Engineers table on the engineer_id to get the first name and last name of the engineers.", "Group the results by engineer_id, first_name, and last_name to get the count of visits for each engineer.", "Order the results by the visit count in descending order to find the engineer with the most visits.", "Limit the results to 1 to get only the engineer with the highest visit count."], "gold_sql": "SELECT T1.engineer_id ,  T1.first_name ,  T1.last_name FROM Maintenance_Engineers AS T1 JOIN Engineer_Visits AS T2 GROUP BY T1.engineer_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["maintenance_engineers", "engineer_visits"], "pred_sql": "SELECT engineer_id, first_name, last_name, COUNT(*) as visit_count\nFROM Engineer_Visits\nJOIN Maintenance_Engineers ON Engineer_Visits.engineer_id = Maintenance_Engineers.engineer_id\nGROUP BY engineer_id, first_name, last_name\nORDER BY visit_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3139", "db_id": "assets_maintenance", "question": "How many fault status codes are recorded in the fault log parts table?", "rationale": ["Identify the table of interest: Fault_Log_Parts.", "Determine the column that contains the fault status codes: fault_status.", "To find the number of unique fault status codes, use the COUNT function with DISTINCT to avoid duplicates.", "Construct the SQL query to select the count of distinct fault status codes from the Fault_Log_Parts table."], "gold_sql": "SELECT DISTINCT fault_status FROM Fault_Log_Parts", "source_tables": ["fault_log_parts"], "pred_sql": "SELECT COUNT(DISTINCT fault_status) AS unique_fault_status_count FROM Fault_Log_Parts;", "hint": "\n"}
{"sample_id": "train.3143", "db_id": "assets_maintenance", "question": "Which part fault requires the most number of skills to fix? List part id and name.", "rationale": ["Identify the relevant tables: Part_Faults, Skills_Required_To_Fix, and Parts.", "Join Part_Faults with Skills_Required_To_Fix to associate each part fault with its required skills.", "Join the result with Parts to get the part name corresponding to each part fault.", "Group the results by part_id and part_name to count the number of skills required for each part fault.", "Order the results in descending order based on the count of skills to find the part fault that requires the most skills.", "Limit the results to 1 to get only the top part fault."], "gold_sql": "SELECT T1.part_id ,  T1.part_name FROM Parts AS T1 JOIN Part_Faults AS T2 ON T1.part_id  =  T2.part_id JOIN Skills_Required_To_Fix AS T3 ON T2.part_fault_id  =  T3.part_fault_id GROUP BY T1.part_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["part_faults", "parts", "skills_required_to_fix"], "pred_sql": "SELECT pf.part_id, p.part_name\nFROM Part_Faults pf\nJOIN Skills_Required_To_Fix srf ON pf.part_fault_id = srf.part_fault_id\nJOIN Parts p ON pf.part_id = p.part_id\nGROUP BY pf.part_id, p.part_name\nORDER BY COUNT(srf.skill_id) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3176", "db_id": "college_1", "question": "How many professors teach a class with the code ACCT-211?", "rationale": ["Identify the relevant tables: CLASS and PROFESSOR are needed to find professors teaching a specific class.", "Use a JOIN to connect CLASS and PROFESSOR on the common key PROFESSOR.EMP_NUM and CLASS.PROF_NUM.", "Filter the results to only include classes with the code 'ACCT-211' using a WHERE clause.", "Count the distinct professors using COUNT(DISTINCT PROFESSOR.EMP_NUM) to avoid duplicates."], "gold_sql": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["class"], "pred_sql": "SELECT COUNT(DISTINCT PROFESSOR.EMP_NUM) \nFROM CLASS \nJOIN PROFESSOR ON CLASS.PROF_NUM = PROFESSOR.EMP_NUM \nWHERE CLASS.CRS_CODE = 'ACCT-211';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of distinct professors teaching classes associated with a specific course code from the 'CLASS' table. The placeholder in the WHERE clause represents the course code being queried.\"\n}\n"}
{"sample_id": "train.3180", "db_id": "college_1", "question": "What are the first names and birthdates of the professors in charge of ACCT-211?", "rationale": ["Identify the relevant tables: PROFESSOR, EMPLOYEE, and CLASS.", "We need to find professors associated with the class ACCT-211, so we will join the CLASS table with the PROFESSOR table using the PROF_NUM foreign key.", "Next, we will join the EMPLOYEE table to get the first names and birthdates of the professors using the EMP_NUM foreign key.", "Select the EMP_FNAME and EMP_DOB columns from the EMPLOYEE table where the CRS_CODE in the CLASS table matches 'ACCT-211'."], "gold_sql": "SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["employee", "class"], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME, EMPLOYEE.EMP_DOB \nFROM PROFESSOR \nJOIN EMPLOYEE ON PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM \nJOIN CLASS ON PROFESSOR.EMP_NUM = CLASS.PROF_NUM \nWHERE CLASS.CRS_CODE = 'ACCT-211';", "hint": "\n"}
{"sample_id": "train.3189", "db_id": "college_1", "question": "How many different locations does the school with code BUS has?", "rationale": ["Identify the relevant tables: CLASS and DEPARTMENT are needed to find class locations associated with the school code BUS.", "We need to count distinct locations (CLASS_ROOM) from the CLASS table.", "Join the CLASS table with the DEPARTMENT table on the appropriate foreign key (PROF_NUM to EMP_NUM) to filter by the school code.", "Use a WHERE clause to specify that we are only interested in the school with code 'BUS'.", "Use COUNT(DISTINCT CLASS_ROOM) to get the number of unique locations."], "gold_sql": "SELECT count(DISTINCT dept_address) FROM department WHERE school_code  =  'BUS'", "source_tables": ["department"], "pred_sql": "SELECT COUNT(DISTINCT CLASS_ROOM) AS unique_locations\nFROM CLASS\nJOIN DEPARTMENT ON CLASS.PROF_NUM = EMPLOYEE.EMP_NUM\nWHERE DEPARTMENT.SCHOOL_CODE = 'BUS';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the unique class codes from the 'CLASS' table that are held in a specific classroom. The placeholder in the WHERE clause represents the room where the class is conducted.\"\n}\n"}
{"sample_id": "train.3190", "db_id": "college_1", "question": "What are the different locations of the school with the code BUS?", "rationale": ["Identify the table that contains the school locations, which is the DEPARTMENT table.", "The DEPARTMENT table has a column DEPT_ADDRESS that holds the addresses of the departments.", "To find the locations associated with the school code 'BUS', we need to filter the DEPARTMENT table using the SCHOOL_CODE column.", "Using DISTINCT ensures that we get unique addresses without duplicates."], "gold_sql": "SELECT count(DISTINCT dept_address) FROM department WHERE school_code  =  'BUS'", "source_tables": ["department"], "pred_sql": "SELECT DISTINCT DEPT_ADDRESS FROM DEPARTMENT WHERE SCHOOL_CODE = 'BUS';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the unique class codes from the 'CLASS' table that are held in a specific classroom. The placeholder in the WHERE clause represents the room where the class is conducted.\"\n}\n"}
{"sample_id": "train.3206", "db_id": "college_1", "question": "How many classes are held in each department?", "rationale": ["We need to count the number of classes held in each department.", "To do this, we will join the CLASS table with the COURSE table using the CRS_CODE, since CLASS has a reference to the course it belongs to.", "Next, we will join the COURSE table with the DEPARTMENT table using the DEPT_CODE, as each course is associated with a department.", "After joining these tables, we can group the results by DEPARTMENT.DEPT_CODE to get the count of classes for each department.", "Finally, we will select the DEPARTMENT.DEPT_CODE and the count of CLASS.CLASS_CODE, which will give us the total number of classes per department."], "gold_sql": "SELECT count(*) ,  dept_code FROM CLASS AS T1 JOIN course AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY dept_code", "source_tables": ["course", "class"], "pred_sql": "SELECT DEPARTMENT.DEPT_CODE, COUNT(CLASS.CLASS_CODE) AS total_classes\nFROM CLASS\nJOIN COURSE ON CLASS.CRS_CODE = COURSE.CRS_CODE\nJOIN DEPARTMENT ON COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE\nGROUP BY DEPARTMENT.DEPT_CODE;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total credit hours for courses grouped by department code from the 'COURSE' table. The placeholder in the SELECT clause represents the credit hours for each course, while the GROUP BY clause organizes the results by department code.\"\n}\n"}
{"sample_id": "train.3209", "db_id": "college_1", "question": "What is the number of professors for different school?", "rationale": ["Identify the tables needed: PROFESSOR and DEPARTMENT are required to get the number of professors and their associated school.", "Join the PROFESSOR table with the DEPARTMENT table on the DEPT_CODE to associate professors with their respective departments.", "Use the COUNT function to count the number of professors (using EMP_NUM) for each school.", "Group the results by SCHOOL_CODE to get the count of professors for each school."], "gold_sql": "SELECT count(*) ,  T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code", "source_tables": ["department", "professor"], "pred_sql": "SELECT DEPARTMENT.SCHOOL_CODE, COUNT(PROFESSOR.EMP_NUM) AS NUMBER_OF_PROFESSORS\nFROM PROFESSOR\nJOIN DEPARTMENT ON PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE\nGROUP BY DEPARTMENT.SCHOOL_CODE;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree type being queried.\"\n}\n"}
{"sample_id": "train.3210", "db_id": "college_1", "question": "How many different professors are there for the different schools?", "rationale": ["We need to count the number of different professors across different schools.", "Professors are associated with departments, and each department belongs to a school.", "To get the count of different professors, we will use the COUNT function with DISTINCT on the EMP_NUM from the PROFESSOR table.", "We will join the PROFESSOR table with the DEPARTMENT table on the DEPT_CODE to access the SCHOOL_CODE.", "Finally, we will group the results by SCHOOL_CODE to ensure we count professors per school."], "gold_sql": "SELECT count(*) ,  T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code", "source_tables": ["department", "professor"], "pred_sql": "SELECT COUNT(DISTINCT PROFESSOR.EMP_NUM) AS different_professors\nFROM PROFESSOR\nJOIN DEPARTMENT ON PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE\nGROUP BY DEPARTMENT.SCHOOL_CODE;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree type being queried.\"\n}\n"}
{"sample_id": "train.3217", "db_id": "college_1", "question": "Find the number of students for each department.", "rationale": ["To find the number of students for each department, we need to count the students grouped by their department.", "The relevant tables are DEPARTMENT and STUDENT, as we need to relate students to their respective departments.", "We will perform a LEFT JOIN between DEPARTMENT and STUDENT on the DEPT_CODE column to ensure we include all departments, even those with no students.", "We will use the COUNT function to count the number of students (STU_NUM) for each department.", "Finally, we will group the results by DEPARTMENT.DEPT_CODE and DEPARTMENT.DEPT_NAME to get the count for each department."], "gold_sql": "SELECT count(*) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT DEPARTMENT.DEPT_CODE, DEPARTMENT.DEPT_NAME, COUNT(STUDENT.STU_NUM) AS NUM_STUDENTS\nFROM DEPARTMENT\nLEFT JOIN STUDENT ON DEPARTMENT.DEPT_CODE = STUDENT.DEPT_CODE\nGROUP BY DEPARTMENT.DEPT_CODE, DEPARTMENT.DEPT_NAME;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree type being queried.\"\n}\n"}
{"sample_id": "train.3218", "db_id": "college_1", "question": "How many students are in each department?", "rationale": ["We need to find out how many students are in each department, which requires counting the number of students per department.", "The relevant tables for this query are STUDENT and DEPARTMENT, as we need to relate students to their respective departments.", "We will join the STUDENT table with the DEPARTMENT table on the DEPT_CODE column, which is common to both tables.", "We will use the COUNT function to count the number of students (STU_NUM) in each department.", "Finally, we will group the results by DEPARTMENT.DEPT_CODE to get the count of students for each department."], "gold_sql": "SELECT count(*) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT DEPARTMENT.DEPT_CODE, COUNT(STUDENT.STU_NUM) AS student_count\nFROM STUDENT\nJOIN DEPARTMENT ON STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE\nGROUP BY DEPARTMENT.DEPT_CODE;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the academic performance of students by department. It calculates the maximum, average, and minimum GPA of students grouped by their respective department codes. The placeholders in the SELECT statement represent the GPA metrics and department code.\"\n}\n"}
{"sample_id": "train.3220", "db_id": "college_1", "question": "How many hours do the students spend studying in each department?", "rationale": ["Identify the relevant tables: STUDENT and DEPARTMENT are needed to get the total credit hours by department.", "The STUDENT table contains the total credit hours completed by each student (STU_HRS) and the department code (DEPT_CODE).", "The DEPARTMENT table contains the department code (DEPT_CODE) which we will use to group the results.", "We need to sum the total credit hours (STU_HRS) for each department, so we will use the SUM function in SQL.", "We will join the STUDENT table with the DEPARTMENT table on the DEPT_CODE to associate students with their respective departments.", "Finally, we will group the results by DEPARTMENT.DEPT_CODE to get the total hours for each department."], "gold_sql": "SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT DEPARTMENT.DEPT_CODE, SUM(STUDENT.STU_HRS) AS TOTAL_HOURS\nFROM STUDENT\nJOIN DEPARTMENT ON STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE\nGROUP BY DEPARTMENT.DEPT_CODE;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total credit hours completed by students, grouped by their respective departments. The placeholder in the SELECT clause represents the total credit hours, while the GROUP BY clause organizes the results by department code.\"\n}\n"}
{"sample_id": "train.3222", "db_id": "college_1", "question": "What is the highest, lowest, and average student GPA for every department?", "rationale": ["We need to find the highest, lowest, and average GPA of students for each department.", "To do this, we will use the STUDENT table to access the GPA data and the DEPARTMENT table to group the results by department.", "We will join the STUDENT table with the DEPARTMENT table on the DEPT_CODE column to associate each student with their respective department.", "We will use aggregate functions: MAX() to find the highest GPA, MIN() to find the lowest GPA, and AVG() to calculate the average GPA.", "Finally, we will group the results by DEPARTMENT.DEPT_CODE to get the metrics for each department."], "gold_sql": "SELECT max(stu_gpa) ,  avg(stu_gpa) ,  min(stu_gpa) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT DEPARTMENT.DEPT_CODE, MAX(STUDENT.STU_GPA) AS Highest_GPA, MIN(STUDENT.STU_GPA) AS Lowest_GPA, AVG(STUDENT.STU_GPA) AS Average_GPA\nFROM STUDENT\nJOIN DEPARTMENT ON STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE\nGROUP BY DEPARTMENT.DEPT_CODE;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the academic performance of students by department. It calculates the maximum, average, and minimum GPA of students grouped by their respective department codes. The placeholders in the SELECT statement represent the GPA metrics and department code.\"\n}\n"}
{"sample_id": "train.3234", "db_id": "college_1", "question": "How many courses does the department of Computer Information Systmes offer?", "rationale": ["Identify the relevant table: The 'COURSE' table contains information about courses and their associated department codes.", "Determine the condition: We need to filter the courses by the department of 'Computer Information Systems'.", "Use a subquery to find the department code for 'Computer Information Systems' from the 'DEPARTMENT' table.", "Count the number of courses that match the department code using COUNT(*) and alias the result as 'total_courses'."], "gold_sql": "SELECT count(*) FROM department AS T1 JOIN course AS T2 ON T1.dept_code  =  T2.dept_code WHERE dept_name  =  'Computer Info. Systems'", "source_tables": ["course", "department"], "pred_sql": "SELECT COUNT(*) AS total_courses \nFROM COURSE \nWHERE DEPT_CODE = (SELECT DEPT_CODE FROM DEPARTMENT WHERE DEPT_NAME = 'Computer Information Systems');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total credit hours for courses grouped by department code from the 'COURSE' table. The placeholder in the SELECT clause represents the credit hours for each course, while the GROUP BY clause organizes the results by department code.\"\n}\n"}
{"sample_id": "train.3238", "db_id": "college_1", "question": "What are the total number of credits offered by each department?", "rationale": ["Identify the relevant tables: DEPARTMENT and COURSE are needed to get the department information and the credit hours for courses offered by each department.", "Determine the relationship between the tables: DEPARTMENT has a foreign key relationship with COURSE through DEPT_CODE.", "Select the necessary columns: We need DEPARTMENT.DEPT_CODE for grouping and the sum of COURSE.CRS_CREDIT for total credits.", "Use the SUM function to calculate the total credits for each department.", "Group the results by DEPARTMENT.DEPT_CODE to get the total credits per department."], "gold_sql": "SELECT sum(T1.crs_credit) ,  T1.dept_code FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY T1.dept_code", "source_tables": ["course", "class"], "pred_sql": "SELECT DEPARTMENT.DEPT_CODE, SUM(CAST(COURSE.CRS_CREDIT AS INTEGER)) AS TOTAL_CREDITS\nFROM DEPARTMENT\nJOIN COURSE ON DEPARTMENT.DEPT_CODE = COURSE.DEPT_CODE\nGROUP BY DEPARTMENT.DEPT_CODE;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total credit hours completed by students, grouped by their respective departments. The placeholder in the SELECT clause represents the total credit hours, while the GROUP BY clause organizes the results by department code.\"\n}\n"}
{"sample_id": "train.3243", "db_id": "college_1", "question": "What is the first name of each student enrolled in class ACCT-211?", "rationale": ["Identify the tables involved: STUDENT, ENROLL, and CLASS.", "Determine the relationship between the tables: STUDENT is linked to ENROLL through STU_NUM, and ENROLL is linked to CLASS through CLASS_CODE.", "Select the first name of the students, which is in the STUDENT table (STU_FNAME).", "Filter the results to only include students enrolled in the class with CLASS_CODE 'ACCT-211'.", "Construct the SQL query using SELECT, JOIN, and WHERE clauses."], "gold_sql": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  'ACCT-211'", "source_tables": ["student", "class", "enroll"], "pred_sql": "SELECT STUDENT.STU_FNAME \nFROM STUDENT \nJOIN ENROLL ON STUDENT.STU_NUM = ENROLL.STU_NUM \nJOIN CLASS ON ENROLL.CLASS_CODE = CLASS.CLASS_CODE \nWHERE CLASS.CLASS_CODE = 'ACCT-211';", "hint": "\n"}
{"sample_id": "train.3253", "db_id": "college_1", "question": "What is the name of the department that has the largest number of students enrolled?", "rationale": ["We need to find the department with the largest number of students enrolled.", "To do this, we will join the DEPARTMENT table with the STUDENT table on the DEPT_CODE column.", "We will group the results by DEPT_CODE to count the number of students in each department.", "We will order the results in descending order based on the count of students.", "Finally, we will limit the results to 1 to get the department with the largest number of students."], "gold_sql": "SELECT T4.dept_name FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code GROUP BY T3.dept_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["course", "department", "class", "enroll"], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME\nFROM DEPARTMENT\nJOIN STUDENT ON DEPARTMENT.DEPT_CODE = STUDENT.DEPT_CODE\nGROUP BY DEPARTMENT.DEPT_CODE\nORDER BY COUNT(STUDENT.STU_NUM) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the academic performance of students by department. It calculates the maximum, average, and minimum GPA of students grouped by their respective department codes. The placeholders in the SELECT statement represent the GPA metrics and department code.\"\n}\n"}
{"sample_id": "train.3254", "db_id": "college_1", "question": "What is the name of the department with the most students enrolled?", "rationale": ["We need to find the department with the most students enrolled.", "To do this, we will join the DEPARTMENT table with the STUDENT table on the DEPT_CODE column.", "We will group the results by DEPARTMENT.DEPT_CODE to count the number of students in each department.", "We will use COUNT(STUDENT.STU_NUM) to count the number of students in each department.", "To find the department with the most students, we will order the results in descending order based on the count of students.", "Finally, we will limit the results to 1 to get the department with the highest count."], "gold_sql": "SELECT T4.dept_name FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code GROUP BY T3.dept_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["course", "department", "class", "enroll"], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME\nFROM DEPARTMENT\nJOIN STUDENT ON DEPARTMENT.DEPT_CODE = STUDENT.DEPT_CODE\nGROUP BY DEPARTMENT.DEPT_CODE\nORDER BY COUNT(STUDENT.STU_NUM) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the academic performance of students by department. It calculates the maximum, average, and minimum GPA of students grouped by their respective department codes. The placeholders in the SELECT statement represent the GPA metrics and department code.\"\n}\n"}
{"sample_id": "train.3258", "db_id": "college_1", "question": "What are the codes of all the courses that are located in room KLR209?", "rationale": ["Identify the relevant table: The question pertains to courses, which are linked to the CLASS table.", "Determine the necessary columns: We need the course codes (CRS_CODE) from the CLASS table.", "Apply the condition: We need to filter the results to only include classes held in room 'KLR209'.", "Construct the SQL query: Use SELECT DISTINCT to get unique course codes from the CLASS table where CLASS_ROOM matches 'KLR209'."], "gold_sql": "SELECT class_code FROM CLASS WHERE class_room  =  'KLR209'", "source_tables": ["class"], "pred_sql": "SELECT DISTINCT CRS_CODE FROM CLASS WHERE CLASS_ROOM = 'KLR209';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the unique class codes from the 'CLASS' table that are held in a specific classroom. The placeholder in the WHERE clause represents the room where the class is conducted.\"\n}\n"}
{"sample_id": "train.3267", "db_id": "college_1", "question": "What is the first name of students who got grade C in any class?", "rationale": ["Identify the relevant tables: STUDENT and ENROLL are needed to find students and their grades.", "We need to select the first names of students, which is in the STUDENT table under the column STU_FNAME.", "To find students who received a grade of 'C', we need to filter the results based on the ENROLL table's ENROLL_GRADE column.", "Join the STUDENT table with the ENROLL table on the common key STU_NUM to correlate students with their grades.", "Construct the SQL query to select the first names of students where the grade is 'C'."], "gold_sql": "SELECT DISTINCT stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE enroll_grade  =  'C'", "source_tables": ["enroll", "student"], "pred_sql": "SELECT STUDENT.STU_FNAME \nFROM STUDENT \nJOIN ENROLL ON STUDENT.STU_NUM = ENROLL.STU_NUM \nWHERE ENROLL.ENROLL_GRADE = 'C';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the academic performance of students by department. It calculates the maximum, average, and minimum GPA of students grouped by their respective department codes. The placeholders in the SELECT statement represent the GPA metrics and department code.\"\n}\n"}
{"sample_id": "train.3273", "db_id": "college_1", "question": "What are the first names of the professors who do not teach a class.", "rationale": ["We need to find the first names of professors who do not teach any class.", "To do this, we will select the first names from the EMPLOYEE table.", "We will perform a LEFT JOIN between the EMPLOYEE table and the CLASS table on the condition that the professor's employee number matches the professor number in the CLASS table.", "Using a LEFT JOIN allows us to include all professors, even those who do not have a corresponding entry in the CLASS table.", "To filter out the professors who do not teach any class, we will check for NULL values in the CLASS_CODE column from the CLASS table, which indicates that there is no class associated with that professor."], "gold_sql": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  'PROF' EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num", "source_tables": ["employee", "class"], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME \nFROM EMPLOYEE \nLEFT JOIN CLASS ON EMPLOYEE.EMP_NUM = CLASS.PROF_NUM \nWHERE CLASS.CLASS_CODE IS NULL;", "hint": "\n"}
{"sample_id": "train.3274", "db_id": "college_1", "question": "What are the first names of all professors not teaching any classes?", "rationale": ["Identify the table that contains professor information, which is the EMPLOYEE table.", "We need to find professors who are not teaching any classes, so we will look for professors whose EMP_NUM is not present in the CLASS table.", "The CLASS table has a column PROF_NUM that links to the EMP_NUM in the EMPLOYEE table, indicating which professors are teaching which classes.", "We will use a subquery to select all PROF_NUM from the CLASS table and then use the NOT IN clause to filter out those professors from the EMPLOYEE table.", "Finally, we will select the first names (EMP_FNAME) of the remaining professors who are not teaching any classes."], "gold_sql": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  'PROF' EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num", "source_tables": ["employee", "class"], "pred_sql": "SELECT EMP_FNAME \nFROM EMPLOYEE \nWHERE EMP_NUM NOT IN (\n    SELECT PROF_NUM \n    FROM CLASS\n);", "hint": "\n"}
{"sample_id": "train.3288", "db_id": "college_1", "question": "How many professors attained either Ph.D. or Masters degrees?", "rationale": ["Identify the table that contains information about professors, which is the PROFESSOR table.", "Determine the relevant column that indicates the highest degree attained by professors, which is PROF_HIGH_DEGREE.", "We need to count the number of professors who have either a Ph.D. or a Masters degree.", "Use the COUNT function to get the total number of professors that meet the criteria.", "Construct the SQL query to select the count from the PROFESSOR table where the PROF_HIGH_DEGREE is either 'Ph.D.' or 'Masters'."], "gold_sql": "SELECT count(*) FROM professor WHERE prof_high_degree  =  'Ph.D.' OR prof_high_degree  =  'MA'", "source_tables": ["professor"], "pred_sql": "SELECT COUNT(*) AS professor_count \nFROM PROFESSOR \nWHERE PROF_HIGH_DEGREE IN ('Ph.D.', 'Masters');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree type being queried.\"\n}\n"}
{"sample_id": "train.3293", "db_id": "college_1", "question": "Find the first name of student who is taking classes from accounting and Computer Info. Systems departments", "rationale": ["Identify the tables needed: STUDENT and DEPARTMENT.", "We need to find students enrolled in specific departments, so we will join STUDENT with DEPARTMENT on DEPT_CODE.", "The departments of interest are 'Accounting' and 'Computer Info. Systems'.", "Use a WHERE clause to filter the results based on the department names.", "Select the distinct first names of the students who meet the criteria."], "gold_sql": "SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Accounting' INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Computer Info. Systems'", "source_tables": ["course", "enroll", "department", "class", "student"], "pred_sql": "SELECT DISTINCT S.STU_FNAME \nFROM STUDENT S \nJOIN DEPARTMENT D ON S.DEPT_CODE = D.DEPT_CODE \nWHERE D.DEPT_NAME IN ('Accounting', 'Computer Info. Systems');", "hint": "\n"}
{"sample_id": "train.3300", "db_id": "college_1", "question": "What is the name of the department with the student that has the lowest GPA?", "rationale": ["Identify the relevant tables: DEPARTMENT and STUDENT are needed to find the department name associated with the student having the lowest GPA.", "The DEPARTMENT table contains the department names, while the STUDENT table contains the GPA information.", "To find the student with the lowest GPA, a subquery is used to select the minimum GPA from the STUDENT table.", "The main query joins the DEPARTMENT and STUDENT tables on the DEPT_CODE to link students to their respective departments.", "The WHERE clause filters the results to only include the department of the student with the lowest GPA."], "gold_sql": "SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT 1", "source_tables": ["department", "student"], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME \nFROM DEPARTMENT \nJOIN STUDENT ON DEPARTMENT.DEPT_CODE = STUDENT.DEPT_CODE \nWHERE STUDENT.STU_GPA = (SELECT MIN(STU_GPA) FROM STUDENT);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the academic performance of students by department. It calculates the maximum, average, and minimum GPA of students grouped by their respective department codes. The placeholders in the SELECT statement represent the GPA metrics and department code.\"\n}\n"}
{"sample_id": "train.3314", "db_id": "college_1", "question": "What are the first names, office locations of all lecturers who have taught some course?", "rationale": ["Identify the required fields: first names and office locations of lecturers.", "The relevant tables are EMPLOYEE (for first names) and PROFESSOR (for office locations).", "Establish a relationship between the EMPLOYEE and PROFESSOR tables using the EMP_NUM field, which is a foreign key in PROFESSOR referencing EMPLOYEE.", "Use a JOIN operation to combine the two tables based on the EMP_NUM field.", "Select the EMP_FNAME from EMPLOYEE and PROF_OFFICE from PROFESSOR."], "gold_sql": "SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num", "source_tables": ["course", "employee", "professor", "class"], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME, PROFESSOR.PROF_OFFICE \nFROM EMPLOYEE \nJOIN PROFESSOR ON EMPLOYEE.EMP_NUM = PROFESSOR.EMP_NUM;", "hint": "\n"}
{"sample_id": "train.3315", "db_id": "college_1", "question": "Find the first names and offices of all instructors who have taught some course and the course description and the department name.", "rationale": ["Identify the required fields: first names of instructors, their office locations, course descriptions, and department names.", "Instructors are represented by the PROFESSOR table, which links to EMPLOYEE for their first names and office locations.", "The COURSE table provides course descriptions and is linked to the DEPARTMENT table for department names.", "Classes are linked to courses, so we need to join the CLASS table to ensure we only get instructors who have taught courses.", "Construct the SQL query using JOINs to connect these tables based on their relationships."], "gold_sql": "SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description ,  T5.dept_name FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num JOIN department AS T5 ON T4.dept_code  =  T5.dept_code", "source_tables": ["course", "department", "professor", "class", "employee"], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME, PROFESSOR.PROF_OFFICE, COURSE.CRS_DESCRIPTION, DEPARTMENT.DEPT_NAME\nFROM EMPLOYEE\nJOIN PROFESSOR ON EMPLOYEE.EMP_NUM = PROFESSOR.EMP_NUM\nJOIN DEPARTMENT ON PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE\nJOIN COURSE ON PROFESSOR.DEPT_CODE = COURSE.DEPT_CODE\nJOIN CLASS ON COURSE.CRS_CODE = CLASS.CRS_CODE;", "hint": "\n"}
{"sample_id": "train.3333", "db_id": "college_1", "question": "Find the name of department that offers the class whose description has the word \"Statistics\".", "rationale": ["Identify the relevant tables: DEPARTMENT, COURSE, and CLASS are needed to find the department offering a specific class.", "The relationship between these tables is established through foreign keys: CLASS.CRS_CODE links to COURSE.CRS_CODE, and COURSE.DEPT_CODE links to DEPARTMENT.DEPT_CODE.", "To find the department name, we need to select DEPARTMENT.DEPT_NAME.", "We need to filter the courses based on their description containing the word 'Statistics', which can be done using a LIKE clause in the WHERE statement."], "gold_sql": "SELECT T2.dept_name FROM course AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.crs_description LIKE '%Statistics%'", "source_tables": ["course", "department"], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME \nFROM DEPARTMENT \nJOIN COURSE ON DEPARTMENT.DEPT_CODE = COURSE.DEPT_CODE \nJOIN CLASS ON COURSE.CRS_CODE = CLASS.CRS_CODE \nWHERE COURSE.CRS_DESCRIPTION LIKE '%Statistics%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree type being queried.\"\n}\n"}
{"sample_id": "train.3417", "db_id": "hr_1", "question": "display the full name (first and last), hire date, salary, and department number for those employees whose first name does not containing the letter M.", "rationale": ["Identify the required fields: full name (first and last), hire date, salary, and department number.", "To create the full name, concatenate the FIRST_NAME and LAST_NAME fields with a space in between.", "Select the HIRE_DATE, SALARY, and DEPARTMENT_ID directly from the employees table.", "Apply a filter to exclude employees whose FIRST_NAME contains the letter 'M' using the NOT LIKE operator."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%'", "source_tables": ["employees"], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, HIRE_DATE, SALARY, DEPARTMENT_ID \nFROM employees \nWHERE FIRST_NAME NOT LIKE '%M%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of employees' first names, last names, hire dates, salaries, and their department identifiers from the 'employees' table, excluding those whose first names match a specific pattern. The placeholder in the WHERE clause allows for filtering based on the first name criteria.\"\n}\n"}
{"sample_id": "train.3418", "db_id": "hr_1", "question": "What are the full name, hire date, salary, and department id for employees without the letter M in their first name?", "rationale": ["Identify the required fields: full name (concatenation of first and last name), hire date, salary, and department id.", "Use the 'employees' table as it contains all the necessary information about employees.", "To create the full name, concatenate the FIRST_NAME and LAST_NAME fields with a space in between.", "Filter the results to exclude employees whose first name contains the letter 'M'. This can be done using the NOT LIKE operator in the WHERE clause."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%'", "source_tables": ["employees"], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, HIRE_DATE, SALARY, DEPARTMENT_ID \nFROM employees \nWHERE FIRST_NAME NOT LIKE '%M%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of employees' first names, last names, hire dates, salaries, and their department identifiers from the 'employees' table, excluding those whose first names match a specific pattern. The placeholder in the WHERE clause allows for filtering based on the first name criteria.\"\n}\n"}
{"sample_id": "train.3419", "db_id": "hr_1", "question": "display the full name (first and last), hire date, salary, and department number for those employees whose first name does not containing the letter M and make the result set in ascending order by department number.", "rationale": ["Identify the required fields: full name (first and last), hire date, salary, and department number.", "To get the full name, concatenate FIRST_NAME and LAST_NAME with a space in between.", "Filter the employees whose first name does not contain the letter 'M'. This can be done using the NOT LIKE operator with a wildcard.", "Sort the results in ascending order by DEPARTMENT_ID.", "Construct the SQL SELECT statement with the identified fields, filtering condition, and ordering."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, HIRE_DATE, SALARY, DEPARTMENT_ID \nFROM employees \nWHERE FIRST_NAME NOT LIKE '%M%' \nORDER BY DEPARTMENT_ID ASC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of employees' first names, last names, hire dates, salaries, and their department identifiers from the 'employees' table, excluding those whose first names match a specific pattern. The placeholder in the WHERE clause allows for filtering based on the first name criteria.\"\n}\n"}
{"sample_id": "train.3442", "db_id": "hr_1", "question": "Which job titles correspond to jobs with salaries over 9000?", "rationale": ["Identify the relevant table: The 'jobs' table contains job titles and salary information.", "Determine the condition: We need to find job titles where the maximum salary is greater than 9000.", "Construct the SQL query: Use a SELECT statement to retrieve the JOB_TITLE from the jobs table where the MAX_SALARY exceeds 9000."], "gold_sql": "SELECT job_title FROM jobs WHERE min_salary  >  9000", "source_tables": ["jobs"], "pred_sql": "SELECT JOB_TITLE FROM jobs WHERE MAX_SALARY > 9000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of employees, including their unique identifiers, first names, last names, and job identifiers, who earn a salary greater than the maximum salary for a specified job. The placeholder in the subquery represents the job identifier for which the maximum salary is being compared.\"\n}\n"}
{"sample_id": "train.3444", "db_id": "hr_1", "question": "What are the job titles, and range of salaries for jobs with maximum salary between 12000 and 18000?", "rationale": ["Identify the relevant table: The question asks for job titles and salary ranges, which are found in the 'jobs' table.", "Select the required columns: We need to select 'JOB_TITLE', 'MIN_SALARY', and 'MAX_SALARY' from the 'jobs' table.", "Apply the filter condition: We need to filter the results to include only those jobs where the 'MAX_SALARY' is between 12000 and 18000.", "Construct the SQL query: Combine the selected columns and the filter condition into a complete SQL query."], "gold_sql": "SELECT job_title ,  max_salary - min_salary FROM jobs WHERE max_salary BETWEEN 12000 AND 18000", "source_tables": ["jobs"], "pred_sql": "SELECT JOB_TITLE, MIN_SALARY, MAX_SALARY \nFROM jobs \nWHERE MAX_SALARY BETWEEN 12000 AND 18000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of employees, including their unique identifiers, first names, last names, and job identifiers, who earn a salary greater than the maximum salary for a specified job. The placeholder in the subquery represents the job identifier for which the maximum salary is being compared.\"\n}\n"}
{"sample_id": "train.3448", "db_id": "hr_1", "question": "What are the employee ids for each employee and final dates of employment at their last job?", "rationale": ["Identify the relevant table: The 'job_history' table contains the employment history of employees, including their end dates.", "Determine the required fields: We need the employee IDs and the final dates of employment, which corresponds to the maximum end date for each employee.", "Use the MAX function: To get the last job end date for each employee, we will use the MAX function on the END_DATE column.", "Group by employee: Since we want the last end date for each employee, we will group the results by EMPLOYEE_ID."], "gold_sql": "SELECT employee_id ,  MAX(end_date) FROM job_history GROUP BY employee_id", "source_tables": ["job_history"], "pred_sql": "SELECT EMPLOYEE_ID, MAX(END_DATE) AS LAST_JOB_END_DATE\nFROM job_history\nGROUP BY EMPLOYEE_ID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the most recent job end dates for each employee from the 'job_history' table. The placeholder in the SELECT clause represents the employee's unique identifier, while the MAX function is used to retrieve the latest end date for each employee's job history.\"\n}\n"}
{"sample_id": "train.3451", "db_id": "hr_1", "question": "Find the ids of the departments where any manager is managing 4 or more employees.", "rationale": ["We need to find departments where any manager is managing 4 or more employees.", "To do this, we will use the 'employees' table, which contains information about employees and their respective departments and managers.", "We will group the results by 'DEPARTMENT_ID' and 'MANAGER_ID' to count the number of employees under each manager in each department.", "Using the HAVING clause, we will filter the groups to include only those where the count of employees is 4 or more."], "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"], "pred_sql": "SELECT DEPARTMENT_ID\nFROM employees\nGROUP BY DEPARTMENT_ID, MANAGER_ID\nHAVING COUNT(EMPLOYEE_ID) >= 4;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists unique department identifiers from the 'employees' table, grouped by department and manager. It filters the results to include only those departments that have a specified minimum number of employees, represented by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.3457", "db_id": "hr_1", "question": "display job ID for those jobs that were done by two or more for more than 300 days.", "rationale": ["We need to find job IDs for jobs that were done by two or more employees for more than 300 days.", "We will use the 'job_history' table, which contains records of employees' job durations.", "We will group the results by 'JOB_ID' to aggregate the data for each job.", "We will use the COUNT function to ensure that we only consider jobs that have been held by two or more employees.", "To find the duration of each job, we will calculate the difference between the maximum end date and the minimum start date for each job using MAX(END_DATE) - MIN(START_DATE).", "Finally, we will use the HAVING clause to filter the results to only include jobs that meet both conditions: held by two or more employees and lasted more than 300 days."], "gold_sql": "SELECT job_id FROM job_history WHERE end_date - start_date  > 300 GROUP BY job_id HAVING COUNT(*) >= 2", "source_tables": ["job_history"], "pred_sql": "SELECT JOB_ID\nFROM job_history\nGROUP BY JOB_ID\nHAVING COUNT(EMPLOYEE_ID) >= 2 AND (MAX(END_DATE) - MIN(START_DATE)) > 300;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the most recent job end dates for each employee from the 'job_history' table. The placeholder in the SELECT clause represents the employee's unique identifier, while the MAX function is used to retrieve the latest end date for each employee's job history.\"\n}\n"}
{"sample_id": "train.3458", "db_id": "hr_1", "question": "What are the job ids for jobs done more than once for a period of more than 300 days?", "rationale": ["We need to find job IDs for jobs that have been done more than once by employees.", "To achieve this, we will use the 'job_history' table, which records the job history of employees.", "We will group the results by 'EMPLOYEE_ID' and 'JOB_ID' to count how many times each job has been held by each employee.", "We will use the HAVING clause to filter groups where the count of jobs is greater than 1, indicating the job was held more than once.", "Additionally, we need to check that the duration of the job (from the minimum start date to the maximum end date) is greater than 300 days.", "We will calculate the duration using the MAX(END_DATE) and MIN(START_DATE) functions and ensure it exceeds 300 days."], "gold_sql": "SELECT job_id FROM job_history WHERE end_date - start_date  > 300 GROUP BY job_id HAVING COUNT(*) >= 2", "source_tables": ["job_history"], "pred_sql": "SELECT JOB_ID\nFROM job_history\nGROUP BY EMPLOYEE_ID, JOB_ID\nHAVING COUNT(*) > 1 AND (MAX(END_DATE) - MIN(START_DATE)) > 300;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the most recent job end dates for each employee from the 'job_history' table. The placeholder in the SELECT clause represents the employee's unique identifier, while the MAX function is used to retrieve the latest end date for each employee's job history.\"\n}\n"}
{"sample_id": "train.3463", "db_id": "hr_1", "question": "display the department name and number of employees in each of the department.", "rationale": ["We need to display the department name and the number of employees in each department.", "To achieve this, we will select the 'DEPARTMENT_NAME' from the 'departments' table.", "We will also count the number of employees associated with each department, which can be done using the COUNT function on 'EMPLOYEE_ID' from the 'employees' table.", "To link the departments with their employees, we will perform a LEFT JOIN between the 'departments' table and the 'employees' table on the 'DEPARTMENT_ID'.", "Finally, we will group the results by 'DEPARTMENT_NAME' to get the count of employees for each department."], "gold_sql": "SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name", "source_tables": ["employees", "departments"], "pred_sql": "SELECT d.DEPARTMENT_NAME, COUNT(e.EMPLOYEE_ID) AS NUMBER_OF_EMPLOYEES\nFROM departments d\nLEFT JOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID\nGROUP BY d.DEPARTMENT_NAME;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists unique department identifiers from the 'employees' table, grouped by department and manager. It filters the results to include only those departments that have a specified minimum number of employees, represented by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.3470", "db_id": "hr_1", "question": "Provide the full names of employees earning more than the employee with id 163.", "rationale": ["Identify the main table to query: employees, as we need employee names.", "We need to select the first and last names of employees, so we will use the columns FIRST_NAME and LAST_NAME.", "We need to filter employees based on their salary compared to the salary of the employee with ID 163.", "To do this, we will use a subquery to get the salary of the employee with ID 163.", "The subquery will select the SALARY from the employees table where EMPLOYEE_ID is 163.", "The main query will select from employees where their SALARY is greater than the result of the subquery."], "gold_sql": "SELECT first_name ,  last_name FROM employees WHERE salary  >  (SELECT salary FROM employees WHERE employee_id = 163 )", "source_tables": ["employees"], "pred_sql": "SELECT FIRST_NAME, LAST_NAME \nFROM employees \nWHERE SALARY > (SELECT SALARY FROM employees WHERE EMPLOYEE_ID = 163);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of employees, including their unique identifiers, first names, last names, and job identifiers, who earn a salary greater than the maximum salary for a specified job. The placeholder in the subquery represents the job identifier for which the maximum salary is being compared.\"\n}\n"}
{"sample_id": "train.3471", "db_id": "hr_1", "question": "return the smallest salary for every departments.", "rationale": ["We need to return the smallest salary for every department.", "To achieve this, we will select the department name and the minimum salary from the employees.", "We will join the 'departments' table with the 'employees' table on the 'DEPARTMENT_ID' to link employees to their respective departments.", "We will use the MIN() function to find the smallest salary for each department.", "Finally, we will group the results by the department name to ensure we get the minimum salary for each department."], "gold_sql": "SELECT MIN(salary) ,  department_id FROM employees GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT d.DEPARTMENT_NAME, MIN(e.SALARY) AS MIN_SALARY\nFROM departments d\nJOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID\nGROUP BY d.DEPARTMENT_NAME;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the average salary of employees grouped by their department. It filters out employees who have a specific commission percentage, represented by a placeholder for string values.\"\n}\n"}
{"sample_id": "train.3472", "db_id": "hr_1", "question": "What is the minimum salary in each department?", "rationale": ["We need to find the minimum salary in each department.", "To do this, we will select the department name and the minimum salary from the employees table.", "We will join the departments table with the employees table on the DEPARTMENT_ID column to associate employees with their respective departments.", "We will use the MIN() function to calculate the minimum salary for each department.", "Finally, we will group the results by department name to get the minimum salary for each department."], "gold_sql": "SELECT MIN(salary) ,  department_id FROM employees GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT d.DEPARTMENT_NAME, MIN(e.SALARY) AS MIN_SALARY\nFROM departments d\nJOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID\nGROUP BY d.DEPARTMENT_NAME;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the average salary of employees grouped by their department. It filters out employees who have a specific commission percentage, represented by a placeholder for string values.\"\n}\n"}
{"sample_id": "train.3482", "db_id": "hr_1", "question": "What is all the information regarding employees who are managers?", "rationale": ["Identify the requirement: We need to find all information regarding employees who are managers.", "To determine who the managers are, we can look for employees whose EMPLOYEE_ID appears in the MANAGER_ID field of the employees table.", "We will use a subquery to select all unique MANAGER_IDs from the employees table where MANAGER_ID is not null.", "The main query will then select all columns from the employees table where the EMPLOYEE_ID is in the list of MANAGER_IDs obtained from the subquery."], "gold_sql": "SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T1.employee_id  =  T2.manager_id", "source_tables": ["employees", "departments"], "pred_sql": "SELECT * FROM employees WHERE EMPLOYEE_ID IN (SELECT MANAGER_ID FROM employees WHERE MANAGER_ID IS NOT NULL)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists unique department identifiers from the 'employees' table, grouped by department and manager. It filters the results to include only those departments that have a specified minimum number of employees, represented by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.3488", "db_id": "hr_1", "question": "Give the distinct department ids of departments in which a manager is in charge of 4 or more employees?", "rationale": ["We need to find distinct department IDs where a manager oversees 4 or more employees.", "To achieve this, we will use the 'employees' table, which contains information about employees and their respective departments and managers.", "We will group the results by 'DEPARTMENT_ID' and 'MANAGER_ID' to count the number of employees in each department managed by each manager.", "Using the HAVING clause, we will filter the groups to include only those where the count of employees is 4 or more."], "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"], "pred_sql": "SELECT DEPARTMENT_ID\nFROM employees\nGROUP BY DEPARTMENT_ID, MANAGER_ID\nHAVING COUNT(EMPLOYEE_ID) >= 4;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists unique department identifiers from the 'employees' table, grouped by department and manager. It filters the results to include only those departments that have a specified minimum number of employees, represented by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.3497", "db_id": "hr_1", "question": "Find the ids of the employees who does not work in those departments where some employees works whose manager id within the range 100 and 200.", "rationale": ["Identify the employees we want to find, which are those not working in certain departments.", "We need to find departments where employees have a manager ID within the range of 100 and 200.", "To do this, we can create a subquery that selects distinct department IDs from the employees table where the manager ID is between 100 and 200.", "Finally, we select employee IDs from the employees table where their department ID is not in the list of department IDs returned by the subquery."], "gold_sql": "SELECT * FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN 100 AND 200)", "source_tables": ["employees", "departments"], "pred_sql": "SELECT EMPLOYEE_ID FROM employees WHERE DEPARTMENT_ID NOT IN (SELECT DISTINCT DEPARTMENT_ID FROM employees WHERE MANAGER_ID BETWEEN '100' AND '200');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists unique department identifiers from the 'employees' table, grouped by department and manager. It filters the results to include only those departments that have a specified minimum number of employees, represented by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.3502", "db_id": "hr_1", "question": "What are the full names and hire dates for employees in the same department as someone with the first name Clara, not including Clara?", "rationale": ["We need to find the full names and hire dates of employees who work in the same department as an employee named Clara.", "To get the full names, we will concatenate the first and last names of the employees using '||'.", "We will select the hire date from the employees table as well.", "To filter employees in the same department as Clara, we will use a subquery to find Clara's department ID.", "The subquery will select the DEPARTMENT_ID from the employees table where the FIRST_NAME is 'Clara'.", "We will also ensure that we do not include Clara herself in the results by adding a condition to exclude her first name."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  ( SELECT department_id FROM employees WHERE first_name  =  'Clara') AND first_name != 'Clara'", "source_tables": ["employees"], "pred_sql": "SELECT e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.HIRE_DATE \nFROM employees e \nWHERE e.DEPARTMENT_ID = (SELECT e2.DEPARTMENT_ID \n                         FROM employees e2 \n                         WHERE e2.FIRST_NAME = 'Clara') \nAND e.FIRST_NAME != 'Clara';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of employees' first names, last names, hire dates, salaries, and their department identifiers from the 'employees' table, excluding those whose first names match a specific pattern. The placeholder in the WHERE clause allows for filtering based on the first name criteria.\"\n}\n"}
{"sample_id": "train.3506", "db_id": "hr_1", "question": "What are the ids, full names, and salaries for employees making more than average and who work in a department with employees who have the letter J in their first name?", "rationale": ["Identify the required fields: employee IDs, full names (first and last), and salaries.", "To get the full name, concatenate the first and last names using '||'.", "Filter employees whose salary is greater than the average salary of all employees. This requires a subquery to calculate the average salary.", "Additionally, filter employees who work in departments where at least one employee has a first name containing the letter 'J'. This requires another subquery that selects department IDs based on the first name condition."], "gold_sql": "SELECT employee_id ,  first_name ,  last_name ,  salary FROM employees WHERE salary  >  ( SELECT AVG (salary) FROM employees ) AND department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE '%J%')", "source_tables": ["employees"], "pred_sql": "SELECT e.EMPLOYEE_ID, e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.SALARY \nFROM employees e \nWHERE e.SALARY > (SELECT AVG(SALARY) FROM employees) \nAND e.DEPARTMENT_ID IN (\n    SELECT d.DEPARTMENT_ID \n    FROM employees d \n    WHERE d.FIRST_NAME LIKE '%J%'\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their department identifiers from the 'employees' table, specifically targeting those employees who earn the minimum salary within their respective departments. The subquery identifies the minimum salary for each department, and the placeholder in the WHERE clause allows for dynamic filtering based on salary criteria.\"\n}\n"}
{"sample_id": "train.3507", "db_id": "hr_1", "question": "display the employee number and job id for all employees whose salary is smaller than any salary of those employees whose job title is MK_MAN.", "rationale": ["Identify the main table to query: 'employees' for employee details.", "Select the columns needed: 'EMPLOYEE_ID' and 'JOB_ID'.", "Establish the condition for filtering: salary must be less than a certain value.", "Determine the value to compare against: the minimum salary of employees with the job title 'MK_MAN'.", "Use a subquery to find the minimum salary from the 'employees' table joined with the 'jobs' table, filtering by the job title 'MK_MAN'.", "Combine the main query and the subquery to form the complete SQL statement."], "gold_sql": "SELECT employee_id ,  job_id FROM employees WHERE salary  <  ( SELECT min(salary) FROM employees WHERE job_id  =  'MK_MAN' )", "source_tables": ["employees"], "pred_sql": "SELECT EMPLOYEE_ID, JOB_ID FROM employees WHERE SALARY < (SELECT MIN(SALARY) FROM employees JOIN jobs ON employees.JOB_ID = jobs.JOB_ID WHERE JOB_TITLE = 'MK_MAN')", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of employee IDs and their corresponding job IDs from the 'employees' table, specifically for those employees whose salary is less than the minimum salary for a specified job. The placeholder in the subquery represents the job identifier for which the minimum salary is being compared.\"\n}\n"}
{"sample_id": "train.3510", "db_id": "hr_1", "question": "What are the employee ids, full names, and job ids for employees who make more than the highest earning employee with title PU_MAN?", "rationale": ["Identify the columns needed: employee ids, full names, and job ids.", "To get the full names, concatenate the FIRST_NAME and LAST_NAME columns with a space in between.", "We need to filter employees based on their salary being greater than the highest salary for the job title 'PU_MAN'.", "Use a subquery to find the maximum salary for the job title 'PU_MAN' from the jobs table.", "Construct the main query to select the required columns from the employees table where the salary condition is met."], "gold_sql": "SELECT employee_id ,  first_name ,  last_name ,  job_id FROM employees WHERE salary  >  ( SELECT max(salary) FROM employees WHERE job_id  =  'PU_MAN' )", "source_tables": ["employees"], "pred_sql": "SELECT EMPLOYEE_ID, FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, JOB_ID \nFROM employees \nWHERE SALARY > (SELECT MAX(MAX_SALARY) \n                  FROM jobs \n                  WHERE JOB_TITLE = 'PU_MAN');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of employees, including their unique identifiers, first names, last names, and job identifiers, who earn a salary greater than the maximum salary for a specified job. The placeholder in the subquery represents the job identifier for which the maximum salary is being compared.\"\n}\n"}
{"sample_id": "train.3512", "db_id": "hr_1", "question": "What are total salaries and department id for each department that has more than 2 employees?", "rationale": ["We need to find the total salaries and department IDs for departments with more than 2 employees.", "To do this, we will join the 'employees' table with the 'departments' table on the 'DEPARTMENT_ID'.", "We will use the SUM function to calculate the total salaries for each department.", "We will group the results by 'DEPARTMENT_ID' to aggregate the salaries for each department.", "To filter departments with more than 2 employees, we will use the HAVING clause with COUNT to count the number of employees in each department."], "gold_sql": "SELECT department_id ,  SUM(salary) FROM employees GROUP BY department_id HAVING count(*)  >=  2", "source_tables": ["employees"], "pred_sql": "SELECT d.DEPARTMENT_ID, SUM(e.SALARY) AS total_salaries\nFROM employees e\nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID\nGROUP BY d.DEPARTMENT_ID\nHAVING COUNT(e.EMPLOYEE_ID) > 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the average salary of employees grouped by their department. It filters out employees who have a specific commission percentage, represented by a placeholder for string values.\"\n}\n"}
{"sample_id": "train.3515", "db_id": "hr_1", "question": "display the department ID, full name (first and last name), salary for those employees who is highest salary in every department.", "rationale": ["We need to display the department ID, full name (first and last name), and salary of employees with the highest salary in each department.", "To get the full name, we can concatenate the first name and last name using the '||' operator.", "We will select from the 'employees' table and filter the results to only include those employees whose salary is equal to the maximum salary in their respective department.", "To find the maximum salary for each department, we can use a subquery that selects the maximum salary from the 'employees' table, grouped by department ID."], "gold_sql": "SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT e.DEPARTMENT_ID, e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.SALARY \nFROM employees e \nWHERE e.SALARY = (SELECT MAX(e2.SALARY) \n                  FROM employees e2 \n                  WHERE e2.DEPARTMENT_ID = e.DEPARTMENT_ID)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their department identifiers from the 'employees' table. It specifically filters for employees who earn the minimum salary within their respective departments. The placeholder in the WHERE clause represents the salary criteria based on the minimum salary grouped by department.\"\n}\n"}
{"sample_id": "train.3516", "db_id": "hr_1", "question": "What are the department ids, full names, and salaries for employees who make the most in their departments?", "rationale": ["Identify the required fields: department ids, full names, and salaries of employees.", "To get the full names, concatenate the FIRST_NAME and LAST_NAME fields from the employees table.", "To find the highest salary in each department, use a subquery that selects the maximum salary for each department.", "The main query selects the department ID, full name, and salary from the employees table where the salary matches the maximum salary for that department."], "gold_sql": "SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT e.DEPARTMENT_ID, e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.SALARY \nFROM employees e \nWHERE e.SALARY = (SELECT MAX(SALARY) \n                   FROM employees \n                   WHERE DEPARTMENT_ID = e.DEPARTMENT_ID)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the average salary of employees grouped by their department. It filters out employees who have a specific commission percentage, represented by a placeholder for string values.\"\n}\n"}
{"sample_id": "train.3520", "db_id": "hr_1", "question": "What are the full names and cities of employees who have the letter Z in their first names?", "rationale": ["Identify the relevant tables: 'employees' for employee names and 'locations' for cities.", "We need to select the full names of employees, which requires concatenating their first and last names.", "The query must filter employees whose first names contain the letter 'Z'.", "To get the city of each employee, we need to join the 'employees' table with the 'locations' table based on the department ID.", "The final SQL query will select the concatenated full name and the city from the joined tables, applying the filter for the first name."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T3.city FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id WHERE T1.first_name LIKE '%z%'", "source_tables": ["employees", "departments", "locations"], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, CITY \nFROM employees \nJOIN locations ON employees.DEPARTMENT_ID = departments.DEPARTMENT_ID \nJOIN countries ON locations.COUNTRY_ID = countries.COUNTRY_ID \nJOIN regions ON countries.REGION_ID = regions.REGION_ID \nWHERE FIRST_NAME LIKE '%Z%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names, last names, and salaries of employees from the 'employees' table whose first names match a specific pattern. The placeholder in the WHERE clause represents the pattern for the first name.\"\n}\n"}
{"sample_id": "train.3523", "db_id": "hr_1", "question": "display the full name (first and last name ) of employee with ID and name of the country presently where (s)he is working.", "rationale": ["Identify the tables needed: 'employees', 'departments', 'locations', and 'countries'.", "We need to join these tables to get the employee's full name and the country they are currently working in.", "The 'employees' table contains the employee's first and last name, while the 'countries' table contains the country name.", "Join 'employees' with 'departments' on 'DEPARTMENT_ID' to get department information.", "Join 'departments' with 'locations' on 'LOCATION_ID' to get location information.", "Join 'locations' with 'countries' on 'COUNTRY_ID' to get the country name.", "Use a WHERE clause to filter the results for the specific employee ID provided."], "gold_sql": "SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id", "source_tables": ["countries", "employees", "departments", "locations"], "pred_sql": "SELECT e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, c.COUNTRY_NAME \nFROM employees e \nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nJOIN locations l ON d.LOCATION_ID = l.LOCATION_ID \nJOIN countries c ON l.COUNTRY_ID = c.COUNTRY_ID \nWHERE e.EMPLOYEE_ID = ?;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the employee ID, first name, and last name of employees from the 'employees' table who belong to the same department as a specified employee. The placeholder in the WHERE clause allows for filtering based on the first name of the employee.\"\n}\n"}
{"sample_id": "train.3525", "db_id": "hr_1", "question": "display the department name and number of employees in each of the department.", "rationale": ["We need to display the department name and the number of employees in each department.", "To get the department name, we will select the 'DEPARTMENT_NAME' from the 'departments' table.", "To count the number of employees in each department, we will use the COUNT() function on 'EMPLOYEE_ID' from the 'employees' table.", "We will join the 'departments' table with the 'employees' table on the 'DEPARTMENT_ID' to link employees to their respective departments.", "Since some departments may not have any employees, we will use a LEFT JOIN to ensure all departments are included in the results.", "Finally, we will group the results by 'DEPARTMENT_NAME' to get the count of employees for each department."], "gold_sql": "SELECT department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY department_name", "source_tables": ["employees", "departments"], "pred_sql": "SELECT d.DEPARTMENT_NAME, COUNT(e.EMPLOYEE_ID) AS NUMBER_OF_EMPLOYEES\nFROM departments d\nLEFT JOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID\nGROUP BY d.DEPARTMENT_NAME;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists unique department identifiers from the 'employees' table, grouped by department and manager. It filters the results to include only those departments that have a specified minimum number of employees, represented by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.3526", "db_id": "hr_1", "question": "What are the department names and how many employees work in each of them?", "rationale": ["Identify the tables needed: We need the 'departments' table for department names and the 'employees' table to count the number of employees in each department.", "Use a LEFT JOIN to combine 'departments' and 'employees' on the 'DEPARTMENT_ID' column, ensuring we include all departments even if they have no employees.", "Select the department name from the 'departments' table and count the number of employees from the 'employees' table, using COUNT(e.EMPLOYEE_ID) to get the number of employees per department.", "Group the results by department name to aggregate the employee counts for each department."], "gold_sql": "SELECT department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY department_name", "source_tables": ["employees", "departments"], "pred_sql": "SELECT d.DEPARTMENT_NAME, COUNT(e.EMPLOYEE_ID) AS EMPLOYEE_COUNT\nFROM departments d\nLEFT JOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID\nGROUP BY d.DEPARTMENT_NAME;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists unique department identifiers from the 'employees' table, grouped by department and manager. It filters the results to include only those departments that have a specified minimum number of employees, represented by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.3528", "db_id": "hr_1", "question": "What are full names and salaries of employees working in the city of London?", "rationale": ["We need to retrieve the full names and salaries of employees.", "The full name can be constructed by concatenating the first name and last name from the 'employees' table.", "To find employees in London, we need to join the 'employees' table with the 'departments' table to get the department information, and then with the 'locations' table to filter by city.", "The 'locations' table is linked to the 'countries' table, but we only need to filter by the city, so we will join 'locations' and 'departments' directly.", "The final SQL query will select the concatenated full name and salary from the relevant tables, filtering for the city of London."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  'London'", "source_tables": ["employees", "departments", "locations"], "pred_sql": "SELECT e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.SALARY \nFROM employees e \nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nJOIN locations l ON d.LOCATION_ID = l.LOCATION_ID \nJOIN countries c ON l.COUNTRY_ID = c.COUNTRY_ID \nWHERE l.CITY = 'London';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names, last names, and salaries of employees from the 'employees' table whose first names match a specific pattern. The placeholder in the WHERE clause represents the pattern for the first name.\"\n}\n"}
{"sample_id": "train.3641", "db_id": "baseball_1", "question": "In 2014, what are the id and rank of the team that has the largest average number of attendance?", "rationale": ["Identify the relevant table: The 'team' table contains the necessary information about teams, including their attendance and rank.", "Filter for the year 2014: We need to focus on the records from the year 2014.", "Select the team_id and rank: These are the specific columns we want to retrieve from the table.", "Order by attendance: To find the team with the largest average attendance, we will order the results by the 'attendance' column in descending order.", "Limit the results to 1: Since we only want the team with the largest attendance, we will limit the results to 1."], "gold_sql": "SELECT T2.team_id ,  T2.rank FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id WHERE T1.year  =  2014 GROUP BY T1.team_id ORDER BY avg(T1.attendance) DESC LIMIT 1;", "source_tables": ["team", "home_game"], "pred_sql": "SELECT team_id, rank FROM team WHERE year = 2014 ORDER BY attendance DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.\"\n}\n"}
{"sample_id": "train.3647", "db_id": "baseball_1", "question": "Which 3 players won the most player awards? List their full name and id.", "rationale": ["Identify the relevant tables: We need to gather player information and their awards, so we will use the 'player' and 'player_award' tables.", "Join the 'player' table with the 'player_award' table on 'player_id' to associate players with their awards.", "Group the results by 'player_id' to aggregate the number of awards each player has won.", "Count the number of awards for each player using COUNT(pa.award_id).", "Order the results in descending order based on the total number of awards to find the top players.", "Limit the results to the top 3 players with the most awards."], "gold_sql": "SELECT T1.name_first ,  T1.name_last ,  T1.player_id FROM player AS T1 JOIN player_award AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.player_id ORDER BY count(*) DESC LIMIT 3;", "source_tables": ["player_award", "player"], "pred_sql": "SELECT p.player_id, p.name_first, p.name_last, COUNT(pa.award_id) AS total_awards\nFROM player p\nJOIN player_award pa ON p.player_id = pa.player_id\nGROUP BY p.player_id\nORDER BY total_awards DESC\nLIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.\"\n}\n"}
{"sample_id": "train.3649", "db_id": "baseball_1", "question": "List three countries which are the origins of the least players.", "rationale": ["We need to find the countries with the least number of players.", "The relevant table for player information is the 'player' table, which contains the 'birth_country' and 'player_id' columns.", "To count the number of players from each country, we will use the COUNT function and group the results by 'birth_country'.", "We will order the results in ascending order based on the count of players to get the countries with the least players at the top.", "Finally, we will limit the results to 3 to get only the top three countries."], "gold_sql": "SELECT birth_country FROM player GROUP BY birth_country ORDER BY count(*) ASC LIMIT 3;", "source_tables": ["player"], "pred_sql": "SELECT birth_country, COUNT(player_id) AS player_count\nFROM player\nGROUP BY birth_country\nORDER BY player_count ASC\nLIMIT 3;", "hint": "\n"}
{"sample_id": "train.3650", "db_id": "baseball_1", "question": "What are the three countries that the least players are from?", "rationale": ["We need to find the countries with the least number of players.", "The relevant table for player information is the 'player' table, which contains the 'birth_country' and 'player_id' columns.", "To count the number of players from each country, we will use the COUNT() function and group the results by 'birth_country'.", "We will order the results in ascending order based on the count of players to get the countries with the least players first.", "Finally, we will limit the results to the top 3 countries using the LIMIT clause."], "gold_sql": "SELECT birth_country FROM player GROUP BY birth_country ORDER BY count(*) ASC LIMIT 3;", "source_tables": ["player"], "pred_sql": "SELECT birth_country, COUNT(player_id) AS player_count\nFROM player\nGROUP BY birth_country\nORDER BY player_count ASC\nLIMIT 3;", "hint": "\n"}
{"sample_id": "train.3651", "db_id": "baseball_1", "question": "Find all the players' first name and last name who have empty death record.", "rationale": ["Identify the relevant table: The 'player' table contains the first and last names of players as well as their death records.", "Determine the condition: We need to find players who have an empty death record, which means their 'death_year' should be NULL.", "Construct the SQL query: We will select 'name_first' and 'name_last' from the 'player' table where 'death_year' is NULL."], "gold_sql": "SELECT name_first ,  name_last FROM player WHERE death_year = '';", "source_tables": ["player"], "pred_sql": "SELECT name_first, name_last FROM player WHERE death_year IS NULL", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of players from the 'player' table who have a recorded year of death. The placeholder in the WHERE clause represents the specific year of death being queried.\"\n}\n"}
{"sample_id": "train.3657", "db_id": "baseball_1", "question": "What is the highest salary among each team? List the team name, id and maximum salary.", "rationale": ["We need to find the highest salary for each team, which requires us to aggregate the salary data.", "The 'salary' table contains the salary records, and the 'team' table contains the team names and IDs.", "To get the maximum salary for each team, we will use the MAX() function on the salary column.", "We will join the 'salary' table with the 'team' table on the 'team_id' to get the team names along with their IDs.", "Finally, we will group the results by 'team_id' and 'name' to ensure we get the maximum salary for each team."], "gold_sql": "SELECT T1.name ,  T1.team_id ,  max(T2.salary) FROM team AS T1 JOIN salary AS T2 ON T1.team_id  =  T2.team_id GROUP BY T1.team_id;", "source_tables": ["team", "salary"], "pred_sql": "SELECT t.name, t.team_id, MAX(s.salary) AS max_salary\nFROM salary s\nJOIN team t ON s.team_id = t.team_id\nGROUP BY t.team_id, t.name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the salary records from the 'salary' table for a specific year, sorted in descending order. The placeholders represent the year for which the salary data is requested and the limit on the number of records to return.\"\n}\n"}
{"sample_id": "train.3662", "db_id": "baseball_1", "question": "Which players won awards in both 1960 and 1961? Return their first names and last names.", "rationale": ["Identify the relevant tables: 'player' for player names and 'player_award' for award information.", "Join the 'player' table with the 'player_award' table twice to check for awards in both years 1960 and 1961.", "Use the WHERE clause to filter for players who won awards in both specified years.", "Select the first and last names of the players who meet the criteria."], "gold_sql": "SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1960 INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1961", "source_tables": ["player_award", "player"], "pred_sql": "SELECT p.name_first, p.name_last\nFROM player p\nJOIN player_award pa1 ON p.player_id = pa1.player_id\nJOIN player_award pa2 ON p.player_id = pa2.player_id\nWHERE pa1.year = 1960 AND pa2.year = 1961;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of players from the 'player' table who have a recorded year of death. The placeholder in the WHERE clause represents the specific year of death being queried.\"\n}\n"}
{"sample_id": "train.3665", "db_id": "baseball_1", "question": "List the maximum scores of the team Boston Red Stockings when the team won in postseason?", "rationale": ["Identify the relevant tables: postseason and team.", "We need to find the maximum scores (wins) of the Boston Red Stockings when they won in the postseason.", "Join the postseason table with the team table on the winning team ID.", "Filter the results to only include rows where the team name is 'Boston Red Stockings'.", "Use the MAX function to get the maximum wins from the filtered results."], "gold_sql": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings';", "source_tables": ["postseason", "team"], "pred_sql": "SELECT MAX(p.wins) AS max_wins\nFROM postseason p\nJOIN team t ON p.team_id_winner = t.team_id\nWHERE t.name = 'Boston Red Stockings';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.\"\n}\n"}
{"sample_id": "train.3666", "db_id": "baseball_1", "question": "What are the maximum scores the team Boston Red Stockings got when the team won in postseason?", "rationale": ["Identify the relevant tables: postseason and team.", "We need to find the maximum scores (wins) for the team Boston Red Stockings when they won in postseason.", "Join the postseason table with the team table on the winning team ID.", "Filter the results to only include rows where the team name is 'Boston Red Stockings'.", "Use the MAX function to get the maximum wins from the filtered results."], "gold_sql": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings';", "source_tables": ["postseason", "team"], "pred_sql": "SELECT MAX(p.wins) AS max_wins\nFROM postseason p\nJOIN team t ON p.team_id_winner = t.team_id\nWHERE t.name = 'Boston Red Stockings';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.\"\n}\n"}
{"sample_id": "train.3669", "db_id": "baseball_1", "question": "What are the name and id of the team with the most victories in 2008 postseason?", "rationale": ["Identify the relevant tables: We need the 'team' table for team names and IDs, and the 'postseason' table for postseason victories.", "Join the 'team' table with the 'postseason' table on the winning team ID (team_id_winner).", "Filter the results to only include the year 2008 from the 'postseason' table.", "Order the results by the number of wins in descending order to get the team with the most victories.", "Limit the results to 1 to get only the top team."], "gold_sql": "SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  2008 GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["postseason", "team"], "pred_sql": "SELECT team.name, team.team_id \nFROM team \nJOIN postseason ON team.team_id = postseason.team_id_winner \nWHERE postseason.year = 2008 \nORDER BY postseason.wins DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.\"\n}\n"}
{"sample_id": "train.3673", "db_id": "baseball_1", "question": "What is the total number of postseason games that team Boston Red Stockings participated in?", "rationale": ["Identify the relevant table: The 'batting_postseason' table contains information about postseason games played by teams.", "Determine the relevant columns: We need to sum the 'g' column, which represents the total games played in postseason.", "Filter the results: We need to filter the results to only include games played by the 'Boston Red Stockings'.", "Use a subquery to find the team_id for 'Boston Red Stockings' from the 'team' table.", "Construct the SQL query to sum the total postseason games for the specified team."], "gold_sql": "SELECT count(*) FROM ( SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' UNION SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' );", "source_tables": ["postseason", "team"], "pred_sql": "SELECT SUM(g) AS total_postseason_games\nFROM batting_postseason\nWHERE team_id = (SELECT team_id FROM team WHERE name = 'Boston Red Stockings')", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.\"\n}\n"}
{"sample_id": "train.3678", "db_id": "baseball_1", "question": "What is the total salary expenses of team Boston Red Stockings in 2010?", "rationale": ["Identify the relevant table: The 'salary' table contains salary records for players.", "Determine the specific team: We need to find the team_id for 'Boston Red Stockings' in the year 2010.", "Use a subquery to get the team_id: This will allow us to filter the salary records for the correct team.", "Calculate the total salary expenses: Use the SUM function to aggregate the salaries for the specified team and year."], "gold_sql": "SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings' AND T1.year  =  2010", "source_tables": ["team", "salary"], "pred_sql": "SELECT SUM(salary) AS total_salary_expenses \nFROM salary \nWHERE team_id = (SELECT team_id FROM team WHERE name = 'Boston Red Stockings' AND year = 2010) \nAND year = 2010;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the salary records for players in two specific years from the 'salary' table. The placeholders in the WHERE clause represent the years for which the salary data is being queried.\"\n}\n"}
{"sample_id": "train.3679", "db_id": "baseball_1", "question": "How many players were in the team Boston Red Stockings in 2000?", "rationale": ["Identify the relevant tables: 'appearances' for player participation and 'team' for team identification.", "Join the 'appearances' table with the 'team' table on 'team_id' to link players to their respective teams.", "Filter the results to include only players from the 'Boston Red Stockings' team in the year 2000.", "Use COUNT(DISTINCT a.player_id) to count the unique players in that team for the specified year."], "gold_sql": "SELECT count(*) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings' AND T1.year  =  2000", "source_tables": ["team", "salary"], "pred_sql": "SELECT COUNT(DISTINCT a.player_id) AS player_count\nFROM appearances a\nJOIN team t ON a.team_id = t.team_id\nWHERE t.name = 'Boston Red Stockings' AND a.year = '2000';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.\"\n}\n"}
{"sample_id": "train.3681", "db_id": "baseball_1", "question": "List the 3 highest salaries of the players in 2001?", "rationale": ["Identify the relevant table: The 'salary' table contains the salary records for players.", "Specify the year: We need to filter the records for the year 2001.", "Select the required columns: We want to retrieve the 'player_id' and 'salary' columns.", "Order the results: To find the highest salaries, we will order the results by 'salary' in descending order.", "Limit the results: We only need the top 3 highest salaries, so we will use 'LIMIT 3' to restrict the output."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2001 ORDER BY salary DESC LIMIT 3;", "source_tables": ["salary"], "pred_sql": "SELECT player_id, salary FROM salary WHERE year = 2001 ORDER BY salary DESC LIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the salary records for players in two specific years from the 'salary' table. The placeholders in the WHERE clause represent the years for which the salary data is being queried.\"\n}\n"}
{"sample_id": "train.3684", "db_id": "baseball_1", "question": "List all the salary values players received in 2010 and 2001.", "rationale": ["Identify the relevant table: The 'salary' table contains the salary records for players.", "Determine the years of interest: The user wants salary values for the years 2010 and 2001.", "Construct the SQL query: Use a SELECT statement to retrieve 'player_id' and 'salary' from the 'salary' table where the 'year' is either 2010 or 2001."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2010 UNION SELECT salary FROM salary WHERE YEAR  =  2001", "source_tables": ["salary"], "pred_sql": "SELECT player_id, salary FROM salary WHERE year IN (2010, 2001);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the salary records for players in two specific years from the 'salary' table. The placeholders in the WHERE clause represent the years for which the salary data is being queried.\"\n}\n"}
{"sample_id": "train.3685", "db_id": "baseball_1", "question": "In which year did the least people enter hall of fame?", "rationale": ["We need to find the year with the least number of players inducted into the Hall of Fame.", "The hint suggests creating a virtual table that summarizes the number of players inducted for each year, which can be done using a COUNT function on the player_id column.", "We will group the results by the year of induction (yearid) to get the count of inductees for each year.", "To find the year with the least inductees, we will order the results in ascending order based on the count of inductees and limit the results to 1 to get the year with the least inductees."], "gold_sql": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT 1;", "source_tables": ["hall_of_fame"], "pred_sql": "SELECT yearid, COUNT(player_id) AS inductee_count \nFROM hall_of_fame \nGROUP BY yearid \nORDER BY inductee_count ASC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.\"\n}\n"}
{"sample_id": "train.3686", "db_id": "baseball_1", "question": "Find the year in which the least people enter hall of fame.", "rationale": ["We need to find the year with the least number of players inducted into the Hall of Fame.", "The hint suggests creating a virtual table that summarizes the number of players inducted for each year.", "We will use the COUNT function to count the number of player_ids for each year in the hall_of_fame table.", "We will group the results by yearid to get the count of inductees for each year.", "To find the year with the least inductees, we will order the results in ascending order based on the count of inductees.", "Finally, we will limit the results to 1 to get only the year with the least inductees."], "gold_sql": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT 1;", "source_tables": ["hall_of_fame"], "pred_sql": "SELECT yearid, COUNT(player_id) AS inductee_count \nFROM hall_of_fame \nGROUP BY yearid \nORDER BY inductee_count ASC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.\"\n}\n"}
{"sample_id": "train.3689", "db_id": "baseball_1", "question": "How many games were played in park \"Columbia Park\" in 1907?", "rationale": ["Identify the relevant tables: home_game and park.", "We need to find the total number of games played in a specific park (Columbia Park) for a specific year (1907).", "Join the home_game table with the park table on the park_id to access park names.", "Filter the results to only include games played in 'Columbia Park' in the year 1907.", "Use the SUM function to calculate the total number of games played in that park for that year."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 1907 AND T2.park_name = 'Columbia Park';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(home_game.games) AS total_games\nFROM home_game\nJOIN park ON home_game.park_id = park.park_id\nWHERE park.park_name = 'Columbia Park' AND home_game.year = 1907;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the cities where parks are located, specifically those that have a number of parks within a specified range. The placeholders in the HAVING clause represent the minimum and maximum number of parks that should be present in those cities.\"\n}\n"}
{"sample_id": "train.3690", "db_id": "baseball_1", "question": "Count the number of games taken place in park \"Columbia Park\" in 1907.", "rationale": ["Identify the relevant tables: We need to find the number of games played in a specific park in a specific year, which involves the 'home_game' and 'park' tables.", "Join the tables: We will join the 'home_game' table with the 'park' table on the 'park_id' to access the park's name.", "Filter the results: We will filter the results to only include games played in 'Columbia Park' in the year 1907.", "Aggregate the results: We will use the SUM function to count the total number of games played in that park for that year."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 1907 AND T2.park_name = 'Columbia Park';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(home_game.games) AS total_games\nFROM home_game\nJOIN park ON home_game.park_id = park.park_id\nWHERE park.park_name = 'Columbia Park' AND home_game.year = 1907;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.\"\n}\n"}
{"sample_id": "train.3691", "db_id": "baseball_1", "question": "How many games were played in city Atlanta in 2000?", "rationale": ["Identify the relevant tables: home_game and park.", "We need to find the total number of games played in Atlanta in the year 2000.", "Join the home_game table with the park table on the park_id to access the city information.", "Filter the results to only include games played in Atlanta and in the year 2000.", "Use the SUM function to aggregate the total number of games played."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year  =  2000 AND T2.city  =  'Atlanta';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(home_game.games) AS total_games\nFROM home_game\nJOIN park ON home_game.park_id = park.park_id\nWHERE park.city = 'Atlanta' AND home_game.year = 2000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.\"\n}\n"}
{"sample_id": "train.3692", "db_id": "baseball_1", "question": "Find the number of games taken place in city Atlanta in 2000.", "rationale": ["Identify the relevant tables: 'home_game' for game statistics and 'park' for location details.", "Join the 'home_game' table with the 'park' table on the park_id to access city information.", "Filter the results to include only games that took place in Atlanta in the year 2000.", "Use the SUM function to calculate the total number of games played in that city and year."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year  =  2000 AND T2.city  =  'Atlanta';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(games) AS total_games\nFROM home_game\nJOIN park ON home_game.park_id = park.park_id\nWHERE park.city = 'Atlanta' AND home_game.year = 2000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.\"\n}\n"}
{"sample_id": "train.3697", "db_id": "baseball_1", "question": "List players' first name and last name who received salary from team Washington Nationals in both 2005 and 2007.", "rationale": ["Identify the relevant tables: We need to retrieve player names and their salary records, so we will use the 'salary' and 'player' tables.", "Join the salary table on itself: To find players who received salaries in both 2005 and 2007, we will join the 'salary' table on itself using the player_id.", "Filter by team: We need to filter the results to only include players who received salaries from the Washington Nationals. This can be done by using a subquery to get the team_id for the Washington Nationals.", "Specify the years: We will add conditions to ensure that we are only looking at records from the years 2005 and 2007."], "gold_sql": "SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2005 AND T3.name = 'Washington Nationals' INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2007 AND T3.name = 'Washington Nationals'", "source_tables": ["team", "player", "salary"], "pred_sql": "SELECT p.name_first, p.name_last\nFROM salary s1\nJOIN salary s2 ON s1.player_id = s2.player_id\nJOIN player p ON s1.player_id = p.player_id\nWHERE s1.team_id = (SELECT team_id FROM team WHERE name = 'Washington Nationals')\n  AND s1.year = '2005'\n  AND s2.year = '2007';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the salary records for players in two specific years from the 'salary' table. The placeholders in the WHERE clause represent the years for which the salary data is being queried.\"\n}\n"}
{"sample_id": "train.3699", "db_id": "baseball_1", "question": "How many home games did the team Boston Red Stockings play from 1990 to 2000 in total?", "rationale": ["Identify the relevant table: The 'home_game' table contains information about home games played by teams.", "Determine the criteria: We need to filter for the team 'Boston Red Stockings' and the years from 1990 to 2000.", "Use a subquery to find the team_id for 'Boston Red Stockings' from the 'team' table.", "Sum the 'games' column in the 'home_game' table for the specified team_id and year range."], "gold_sql": "SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = 'Boston Red Stockings' AND T1.year BETWEEN 1990 AND 2000;", "source_tables": ["team", "home_game"], "pred_sql": "SELECT SUM(games) AS total_home_games\nFROM home_game\nWHERE team_id = (SELECT team_id FROM team WHERE name = 'Boston Red Stockings')\nAND year BETWEEN 1990 AND 2000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.\"\n}\n"}
{"sample_id": "train.3702", "db_id": "baseball_1", "question": "Find the team that attended the least number of home games in 1980.", "rationale": ["Identify the relevant table: The 'home_game' table contains information about home games played by teams, including the year and the number of games.", "Filter the data: We need to focus on the year 1980, so we will add a WHERE clause to filter for that year.", "Sort the results: To find the team with the least number of home games, we will sort the results in ascending order based on the 'games' column.", "Limit the results: Since we only want the team with the least number of home games, we will use LIMIT 1 to get only the top result."], "gold_sql": "SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = 1980 ORDER BY T1.attendance ASC LIMIT 1;", "source_tables": ["team", "home_game"], "pred_sql": "SELECT team_id, games FROM home_game WHERE year = 1980 ORDER BY games ASC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.\"\n}\n"}
{"sample_id": "train.3710", "db_id": "baseball_1", "question": "Which park did the most people attend in 2008?", "rationale": ["Identify the relevant tables: home_game for attendance data and park for park names.", "Join the home_game table with the park table on the park_id to get park names along with attendance.", "Filter the results to only include data from the year 2008.", "Order the results by attendance in descending order to find the park with the highest attendance.", "Limit the results to 1 to get only the park with the most attendance."], "gold_sql": "SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 2008 ORDER BY T1.attendance DESC LIMIT 1;", "source_tables": ["park", "home_game"], "pred_sql": "SELECT park.park_name, home_game.attendance \nFROM home_game \nJOIN park ON home_game.park_id = park.park_id \nWHERE home_game.year = 2008 \nORDER BY home_game.attendance DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the cities where parks are located, specifically those that have a number of parks within a specified range. The placeholders in the HAVING clause represent the minimum and maximum number of parks that should be present in those cities.\"\n}\n"}
{"sample_id": "train.3898", "db_id": "hospital_1", "question": "Which department has the largest number of employees?", "rationale": ["Identify the relevant tables: Department and Physician.", "We need to count the number of employees (physicians) in each department.", "Join the Department table with the Physician table on the Head of the department.", "Group the results by department to get the count of physicians in each department.", "Order the results by the count of physicians in descending order to find the department with the most employees.", "Limit the results to 1 to get only the department with the largest number of employees."], "gold_sql": "SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT 1;", "source_tables": ["department"], "pred_sql": "SELECT d.Name, COUNT(p.EmployeeID) AS EmployeeCount\nFROM Department d\nLEFT JOIN Physician p ON d.Head = p.EmployeeID\nGROUP BY d.DepartmentID\nORDER BY EmployeeCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of department heads from the 'Department' table, grouped by department ID. The result is ordered by the count of departments, and a placeholder is used to limit the number of results returned.\"\n}\n"}
{"sample_id": "train.3899", "db_id": "hospital_1", "question": "Find the department with the most employees.", "rationale": ["We need to find the department with the most employees, which involves counting the number of physicians in each department.", "To do this, we will join the 'Department' table with the 'Physician' table on the condition that the department head is a physician.", "We will use a LEFT JOIN to ensure that we include departments even if they have no physicians.", "Next, we will group the results by department ID to count the number of physicians in each department.", "We will order the results by the count of physicians in descending order to get the department with the most employees at the top.", "Finally, we will limit the results to just one department to get the one with the most employees."], "gold_sql": "SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT 1;", "source_tables": ["department"], "pred_sql": "SELECT Department.Name, COUNT(Physician.EmployeeID) AS EmployeeCount\nFROM Department\nLEFT JOIN Physician ON Department.Head = Physician.EmployeeID\nGROUP BY Department.DepartmentID\nORDER BY EmployeeCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of department heads from the 'Department' table, grouped by department ID. The result is ordered by the count of departments, and a placeholder is used to limit the number of results returned.\"\n}\n"}
{"sample_id": "train.3902", "db_id": "hospital_1", "question": "what is the name and position of the head whose department has least number of employees?", "rationale": ["Identify the head of each department from the 'Department' table, which includes the 'Head' column that references 'Physician.EmployeeID'.", "Join the 'Department' table with the 'Physician' table to get the names and positions of the department heads.", "Group the results by 'Department.DepartmentID' to count the number of employees in each department.", "Order the results by the count of employees in ascending order to find the department with the least number of employees.", "Limit the results to 1 to get only the head of the department with the least number of employees."], "gold_sql": "SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["physician", "department"], "pred_sql": "SELECT Physician.Name, Physician.Position \nFROM Department \nJOIN Physician ON Department.Head = Physician.EmployeeID \nGROUP BY Department.DepartmentID \nORDER BY COUNT(Physician.EmployeeID) ASC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of department heads from the 'Department' table, grouped by their department identifiers. The result is ordered by the count of departments, and a placeholder is used to limit the number of results returned.\"\n}\n"}
{"sample_id": "train.3904", "db_id": "hospital_1", "question": "What are names of patients who made an appointment?", "rationale": ["We need to find the names of patients who made an appointment.", "The relevant tables are 'Patient' and 'Appointment'.", "The 'Patient' table contains the names of the patients, and the 'Appointment' table contains the appointments made by patients.", "To find the patients who made appointments, we will join the 'Patient' table with the 'Appointment' table on the 'Patient.SSN' and 'Appointment.Patient' columns.", "We will select the distinct names from the 'Patient' table to avoid duplicates."], "gold_sql": "SELECT name FROM appointment AS T1 JOIN patient AS T2 ON T1.patient  =  T2.ssn", "source_tables": ["patient", "appointment"], "pred_sql": "SELECT DISTINCT Patient.Name\nFROM Patient\nJOIN Appointment ON Patient.SSN = Appointment.Patient;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the patients who have undergone procedures, ordered by the date of the procedures. The placeholder in the LIMIT clause represents the maximum number of patients to be displayed.\"\n}\n"}
{"sample_id": "train.3905", "db_id": "hospital_1", "question": "List the names of patients who have made appointments.", "rationale": ["We need to list the names of patients who have made appointments.", "The relevant tables are 'Patient' and 'Appointment'.", "The 'Patient' table contains the names of the patients, and the 'Appointment' table contains the records of appointments made by patients.", "To find patients who have made appointments, we can join the 'Patient' table with the 'Appointment' table on the 'Patient.SSN' and 'Appointment.Patient' columns.", "Using DISTINCT ensures that we only get unique patient names, even if a patient has multiple appointments."], "gold_sql": "SELECT name FROM appointment AS T1 JOIN patient AS T2 ON T1.patient  =  T2.ssn", "source_tables": ["patient", "appointment"], "pred_sql": "SELECT DISTINCT Patient.Name\nFROM Patient\nJOIN Appointment ON Patient.SSN = Appointment.Patient;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the patients who have undergone procedures, ordered by the date of the procedures. The placeholder in the LIMIT clause represents the maximum number of patients to be displayed.\"\n}\n"}
{"sample_id": "train.3914", "db_id": "hospital_1", "question": "Find the names of all physicians and their primary affiliated departments' names.", "rationale": ["Identify the tables needed: Physician, Affiliated_With, and Department.", "We need to select the names of physicians and their affiliated departments.", "Join the Physician table with the Affiliated_With table on the EmployeeID and Physician columns.", "Join the Affiliated_With table with the Department table on the Department columns.", "Filter the results to only include primary affiliations by checking the PrimaryAffiliation column."], "gold_sql": "SELECT T1.name ,  T3.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T2.PrimaryAffiliation  =  1", "source_tables": ["physician", "department", "affiliated_with"], "pred_sql": "SELECT Physician.Name AS PhysicianName, Department.Name AS DepartmentName\nFROM Physician\nJOIN Affiliated_With ON Physician.EmployeeID = Affiliated_With.Physician\nJOIN Department ON Affiliated_With.Department = Department.DepartmentID\nWHERE Affiliated_With.PrimaryAffiliation = 'Yes';", "hint": "\n"}
{"sample_id": "train.3915", "db_id": "hospital_1", "question": "What are the name and primarily affiliated department name of each physician?", "rationale": ["Identify the relevant tables: Physician, Affiliated_With, and Department.", "We need to retrieve the physician's name and the name of their primarily affiliated department.", "Join the Physician table with the Affiliated_With table on the EmployeeID and Physician columns respectively.", "Join the resulting table with the Department table on the Department column from Affiliated_With and DepartmentID from Department.", "Filter the results to include only those records where the PrimaryAffiliation is marked as 'Yes'.", "Select the Physician's name and the Department's name in the final output."], "gold_sql": "SELECT T1.name ,  T3.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T2.PrimaryAffiliation  =  1", "source_tables": ["physician", "department", "affiliated_with"], "pred_sql": "SELECT Physician.Name AS PhysicianName, Department.Name AS DepartmentName\nFROM Physician\nJOIN Affiliated_With ON Physician.EmployeeID = Affiliated_With.Physician\nJOIN Department ON Affiliated_With.Department = Department.DepartmentID\nWHERE Affiliated_With.PrimaryAffiliation = 'Yes';", "hint": "\n"}
{"sample_id": "train.3929", "db_id": "hospital_1", "question": "Return the name of each physician and the number of patients he or she treats.", "rationale": ["We need to return the names of physicians and the number of patients they treat.", "The relevant tables are Physician and Prescribes, as Prescribes links physicians to patients through prescriptions.", "We will join the Physician table with the Prescribes table on the Physician's EmployeeID.", "To count the number of patients treated by each physician, we will use COUNT(DISTINCT Prescribes.Patient) to ensure we count each patient only once.", "Finally, we will group the results by Physician.Name to get the count for each physician."], "gold_sql": "SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid", "source_tables": ["physician", "patient"], "pred_sql": "SELECT Physician.Name, COUNT(DISTINCT Prescribes.Patient) AS NumberOfPatients\nFROM Physician\nJOIN Prescribes ON Physician.EmployeeID = Prescribes.Physician\nGROUP BY Physician.Name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the patients who have undergone procedures, ordered by the date of the procedures. The placeholder in the LIMIT clause represents the maximum number of patients to be displayed.\"\n}\n"}
{"sample_id": "train.3930", "db_id": "hospital_1", "question": "Find the name of physicians who are in charge of more than one patient.", "rationale": ["We need to find physicians who are in charge of more than one patient.", "To do this, we will join the Physician table with the Prescribes table, as the Prescribes table contains information about which physician prescribed medication to which patient.", "We will group the results by the physician's EmployeeID to aggregate the data for each physician.", "Using the COUNT function, we will count the distinct patients for each physician.", "Finally, we will use the HAVING clause to filter the results to only include physicians who have prescribed to more than one distinct patient."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  1", "source_tables": ["physician", "patient"], "pred_sql": "SELECT Physician.Name\nFROM Physician\nJOIN Prescribes ON Physician.EmployeeID = Prescribes.Physician\nGROUP BY Physician.EmployeeID\nHAVING COUNT(DISTINCT Prescribes.Patient) > 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the patients who have undergone procedures, ordered by the date of the procedures. The placeholder in the LIMIT clause represents the maximum number of patients to be displayed.\"\n}\n"}
{"sample_id": "train.3931", "db_id": "hospital_1", "question": "Which physicians are in charge of more than one patient? Give me their names.", "rationale": ["Identify the relevant tables: Physician and Prescribes.", "We need to find physicians who have prescribed medication to patients.", "Join the Physician table with the Prescribes table on the Physician's EmployeeID.", "Group the results by Physician's EmployeeID to aggregate the data.", "Use the COUNT function to count distinct patients for each physician.", "Filter the results using HAVING to only include physicians with more than one patient."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  1", "source_tables": ["physician", "patient"], "pred_sql": "SELECT Physician.Name\nFROM Physician\nJOIN Prescribes ON Physician.EmployeeID = Prescribes.Physician\nGROUP BY Physician.EmployeeID\nHAVING COUNT(DISTINCT Prescribes.Patient) > 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the patients who have undergone procedures, ordered by the date of the procedures. The placeholder in the LIMIT clause represents the maximum number of patients to be displayed.\"\n}\n"}
{"sample_id": "train.3934", "db_id": "hospital_1", "question": "Find the number of rooms for different block code?", "rationale": ["We need to find the number of rooms for different block codes.", "The relevant table for this information is the 'Room' table, which contains the 'BlockCode' and 'RoomNumber' columns.", "To get the count of rooms for each block code, we will use the COUNT() function.", "We will group the results by 'BlockCode' to get the count for each unique block code."], "gold_sql": "SELECT count(*) ,  T1.blockcode FROM BLOCK AS T1 JOIN room AS T2 ON T1.blockfloor  =  T2.blockfloor AND T1.blockcode  =  T2.blockcode GROUP BY T1.blockcode", "source_tables": ["block", "room"], "pred_sql": "SELECT Room.BlockCode, COUNT(Room.RoomNumber) AS NumberOfRooms\nFROM Room\nGROUP BY Room.BlockCode;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of nurses who are on call, filtered by specific conditions related to blocked floors and blocked codes. The placeholders in the WHERE clause represent the identifiers for the blocked floor and blocked code statuses.\"\n}\n"}
{"sample_id": "train.3944", "db_id": "hospital_1", "question": "Find the number of medications prescribed for each brand.", "rationale": ["We need to find the number of medications prescribed for each brand.", "The relevant tables are 'Medication' and 'Prescribes'.", "We will join these two tables on the 'Medication.Code' and 'Prescribes.Medication' columns.", "We will use the COUNT function to count the number of prescriptions for each brand.", "Finally, we will group the results by 'Medication.Brand' to get the count for each brand."], "gold_sql": "SELECT count(*) ,  T1.name FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand", "source_tables": ["prescribes", "medication"], "pred_sql": "SELECT Medication.Brand, COUNT(Prescribes.Medication) AS NumberOfPrescriptions\nFROM Medication\nJOIN Prescribes ON Medication.Code = Prescribes.Medication\nGROUP BY Medication.Brand;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the patients who have undergone procedures, ordered by the date of the procedures. The placeholder in the LIMIT clause represents the maximum number of patients to be displayed.\"\n}\n"}
{"sample_id": "train.3959", "db_id": "hospital_1", "question": "Find the physician who prescribed the highest dose. What is his or her name?", "rationale": ["Identify the relevant tables: Prescribes for prescriptions and Physician for physician details.", "We need to find the physician who prescribed the highest dose, so we will order the results by the Dose column in descending order.", "To get the physician's name, we will join the Prescribes table with the Physician table on the Physician identifier.", "Finally, we will limit the results to 1 to get only the physician with the highest dose."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT 1", "source_tables": ["physician", "prescribes"], "pred_sql": "SELECT Physician.Name\nFROM Prescribes\nJOIN Physician ON Prescribes.Physician = Physician.EmployeeID\nORDER BY Prescribes.Dose DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the patients who have undergone procedures, ordered by the date of the procedures. The placeholder in the LIMIT clause represents the maximum number of patients to be displayed.\"\n}\n"}
{"sample_id": "train.3960", "db_id": "hospital_1", "question": "List the physicians' employee ids together with their primary affiliation departments' ids.", "rationale": ["Identify the relevant tables: Physician and Affiliated_With.", "We need to select the EmployeeID from the Physician table and the Department from the Affiliated_With table.", "To link these two tables, we will use the common field: Physician.EmployeeID and Affiliated_With.Physician.", "We are interested in the primary affiliation, so we will filter the results where Affiliated_With.PrimaryAffiliation is 'Yes'.", "Construct the SQL query using SELECT, JOIN, and WHERE clauses."], "gold_sql": "SELECT physician ,  department FROM affiliated_with WHERE primaryaffiliation  =  1", "source_tables": ["affiliated_with"], "pred_sql": "SELECT Physician.EmployeeID, Affiliated_With.Department \nFROM Physician \nJOIN Affiliated_With ON Physician.EmployeeID = Affiliated_With.Physician \nWHERE Affiliated_With.PrimaryAffiliation = 'Yes';", "hint": "\n"}
{"sample_id": "train.3961", "db_id": "hospital_1", "question": "What are each physician's employee id and department id primarily affiliated.", "rationale": ["Identify the required columns: EmployeeID from Physician and Department from Affiliated_With.", "Determine the relationship between the tables: Physician is linked to Affiliated_With through the Physician identifier.", "Use a JOIN clause to combine the Physician and Affiliated_With tables based on the matching Physician identifier.", "Filter the results to include only those records where the PrimaryAffiliation is marked as 'Yes' to get the primary affiliations."], "gold_sql": "SELECT physician ,  department FROM affiliated_with WHERE primaryaffiliation  =  1", "source_tables": ["affiliated_with"], "pred_sql": "SELECT Physician.EmployeeID, Affiliated_With.Department \nFROM Physician \nJOIN Affiliated_With ON Physician.EmployeeID = Affiliated_With.Physician \nWHERE Affiliated_With.PrimaryAffiliation = 'Yes';", "hint": "\n"}
{"sample_id": "train.3970", "db_id": "hospital_1", "question": "Find the three most expensive procedures.", "rationale": ["Identify the table that contains the procedure information, which is the Procedures table.", "Select the columns needed: the name of the procedure (Name) and its cost (Cost).", "Order the results by the Cost column in descending order to get the most expensive procedures first.", "Limit the results to 3 to get only the top three most expensive procedures."], "gold_sql": "SELECT name FROM procedures ORDER BY cost LIMIT 3", "source_tables": ["procedures"], "pred_sql": "SELECT Name, Cost FROM Procedures ORDER BY Cost DESC LIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the patients who have undergone procedures, ordered by the date of the procedures. The placeholder in the LIMIT clause represents the maximum number of patients to be displayed.\"\n}\n"}
{"sample_id": "train.3971", "db_id": "hospital_1", "question": "What are the three most costly procedures?", "rationale": ["Identify the table that contains the procedures and their costs, which is the Procedures table.", "Select the columns 'Name' and 'Cost' from the Procedures table.", "Order the results by the 'Cost' column in descending order to get the most costly procedures first.", "Limit the results to 3 to get only the top three most costly procedures."], "gold_sql": "SELECT name FROM procedures ORDER BY cost LIMIT 3", "source_tables": ["procedures"], "pred_sql": "SELECT Name, Cost FROM Procedures ORDER BY Cost DESC LIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the patients who have undergone procedures, ordered by the date of the procedures. The placeholder in the LIMIT clause represents the maximum number of patients to be displayed.\"\n}\n"}
{"sample_id": "train.3973", "db_id": "hospital_1", "question": "Which physicians are trained in procedures that are more expensive than 5000?", "rationale": ["We need to find physicians trained in procedures that cost more than 5000.", "Start by selecting the physician's name from the Physician table.", "Join the Trained_In table to link physicians with the procedures they are trained in using the Physician.EmployeeID and Trained_In.Physician.", "Next, join the Procedures table to get the cost of the procedures using Trained_In.Treatment and Procedures.Code.", "Finally, filter the results where the cost of the procedures is greater than 5000."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  5000", "source_tables": ["physician", "procedures", "trained_in"], "pred_sql": "SELECT DISTINCT Physician.Name\nFROM Physician\nJOIN Trained_In ON Physician.EmployeeID = Trained_In.Physician\nJOIN Procedures ON Trained_In.Treatment = Procedures.Code\nWHERE Procedures.Cost > '5000';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the patients who have undergone procedures, ordered by the date of the procedures. The placeholder in the LIMIT clause represents the maximum number of patients to be displayed.\"\n}\n"}
{"sample_id": "train.3974", "db_id": "hospital_1", "question": "Find the physician who was trained in the most expensive procedure?", "rationale": ["Identify the relevant tables: Physician, Trained_In, and Procedures.", "Join the Physician table with the Trained_In table on the EmployeeID and Physician fields.", "Join the resulting table with the Procedures table on the Treatment and Code fields to access procedure costs.", "Order the results by the Cost of the procedures in descending order to find the most expensive one.", "Limit the results to 1 to get only the physician trained in the most expensive procedure."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment ORDER BY T3.cost DESC LIMIT 1", "source_tables": ["physician", "procedures", "trained_in"], "pred_sql": "SELECT Physician.Name\nFROM Physician\nJOIN Trained_In ON Physician.EmployeeID = Trained_In.Physician\nJOIN Procedures ON Trained_In.Treatment = Procedures.Code\nORDER BY Procedures.Cost DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the patients who have undergone procedures, ordered by the date of the procedures. The placeholder in the LIMIT clause represents the maximum number of patients to be displayed.\"\n}\n"}
{"sample_id": "train.3985", "db_id": "hospital_1", "question": "What procedures cost less than 5000 and have John Wen as a trained physician?", "rationale": ["Identify the relevant tables: Procedures and Trained_In, as well as Physician to filter by the physician's name.", "We need to find procedures that cost less than 5000, so we will filter the Procedures table based on the Cost column.", "We also need to ensure that the physician is John Wen, which requires joining the Trained_In table with the Physician table to access the physician's name.", "The join condition will be based on the Treatment code in Trained_In matching the Code in Procedures, and the Physician's EmployeeID matching the one in Trained_In.", "Finally, we will select the procedure names and costs that meet both conditions."], "gold_sql": "SELECT name FROM procedures WHERE cost  <  5000 INTERSECT SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  'John Wen'", "source_tables": ["procedures", "physician", "trained_in"], "pred_sql": "SELECT Procedures.Name, Procedures.Cost \nFROM Procedures \nJOIN Trained_In ON Procedures.Code = Trained_In.Treatment \nJOIN Physician ON Trained_In.Physician = Physician.EmployeeID \nWHERE Procedures.Cost < 5000 AND Physician.Name = 'John Wen';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the patients who have undergone procedures, ordered by the date of the procedures. The placeholder in the LIMIT clause represents the maximum number of patients to be displayed.\"\n}\n"}
{"sample_id": "train.4321", "db_id": "tracking_grants_for_research", "question": "What are the different grant amounts for documents sent before '1986-08-26 20:49:27' and after the grant ended on '1989-03-16 18:27:16'?", "rationale": ["Identify the relevant tables: Grants and Documents are needed to get grant amounts and filter by document sent dates.", "Join the Grants table with the Documents table on the grant_id to link documents to their respective grants.", "Use the WHERE clause to filter documents sent before '1986-08-26 20:49:27'.", "Also, filter grants that ended before '1989-03-16 18:27:16'.", "Select distinct grant amounts to avoid duplicates in the results."], "gold_sql": "SELECT T1.grant_amount FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id WHERE T2.sent_date  <  '1986-08-26 20:49:27' INTERSECT SELECT grant_amount FROM grants WHERE grant_end_date  >  '1989-03-16 18:27:16'", "source_tables": ["grants", "documents"], "pred_sql": "SELECT DISTINCT Grants.grant_amount \nFROM Grants \nJOIN Documents ON Grants.grant_id = Documents.grant_id \nWHERE Documents.sent_date < '1986-08-26 20:49:27' \nAND Grants.grant_end_date < '1989-03-16 18:27:16';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\"\n}\n"}
{"sample_id": "train.4322", "db_id": "tracking_grants_for_research", "question": "List the project details of the project both producing patent and paper as outcomes.", "rationale": ["Identify the relevant tables: Projects, Project_Outcomes, and Research_Outcomes are needed to get project details and their outcomes.", "Join the Projects table with Project_Outcomes on project_id to link projects with their outcomes.", "Join the Project_Outcomes table with Research_Outcomes on outcome_code to get the descriptions of the outcomes.", "Filter the results to include only those projects that have both 'patent' and 'paper' as outcomes.", "Use GROUP BY to group the results by project_id to ensure we are looking at unique projects.", "Use HAVING to ensure that only projects with both outcomes are included in the final result."], "gold_sql": "SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  'Paper' INTERSECT SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  'Patent'", "source_tables": ["project_outcomes", "projects"], "pred_sql": "SELECT p.project_details \nFROM Projects p \nJOIN Project_Outcomes po ON p.project_id = po.project_id \nJOIN Research_Outcomes ro ON po.outcome_code = ro.outcome_code \nWHERE ro.outcome_description IN ('patent', 'paper') \nGROUP BY p.project_id \nHAVING COUNT(DISTINCT ro.outcome_description) = 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\"\n}\n"}
{"sample_id": "train.4324", "db_id": "tracking_grants_for_research", "question": "What is the total grant amount of the organisations described as research?", "rationale": ["Identify the relevant tables: Grants and Organisations.", "Determine the relationship between Grants and Organisations using the foreign key 'organisation_id'.", "Filter the organisations based on their type, specifically those described as 'research'.", "Use the SUM function to calculate the total grant amount for the filtered organisations."], "gold_sql": "SELECT sum(grant_amount) FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id JOIN organisation_Types AS T3 ON T2.organisation_type  =  T3.organisation_type WHERE T3.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations"], "pred_sql": "SELECT SUM(Grants.grant_amount) AS total_grant_amount\nFROM Grants\nJOIN Organisations ON Grants.organisation_id = Organisations.organisation_id\nWHERE Organisations.organisation_type = (SELECT organisation_type FROM Organisation_Types WHERE organisation_type_description = 'research');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.\"\n}\n"}
{"sample_id": "train.4327", "db_id": "tracking_grants_for_research", "question": "From what date and to what date do the staff work on a project that has the most staff and has staff in a leader role?", "rationale": ["Identify the role code for the leader role from the Staff_Roles table.", "Use the Project_Staff table to find projects that have staff members with the leader role.", "Group the results by project_id and count the number of staff members for each project.", "Order the projects by the count of staff members in descending order to find the project with the most staff.", "Limit the results to 1 to get the project with the most staff members.", "Use the project_id from the previous step to select the date_from and date_to from the Project_Staff table."], "gold_sql": "SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT 1 ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  'leader'", "source_tables": ["project_staff"], "pred_sql": "SELECT date_from, date_to \nFROM Project_Staff \nWHERE project_id = (SELECT project_id \n                    FROM Project_Staff \n                    WHERE role_code = (SELECT role_code \n                                      FROM Staff_Roles \n                                      WHERE role_description = 'leader') \n                    GROUP BY project_id \n                    ORDER BY COUNT(staff_id) DESC \n                    LIMIT 1)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\"\n}\n"}
{"sample_id": "train.4330", "db_id": "tracking_grants_for_research", "question": "What is the organisation type and id of the organisation which has the most number of research staff?", "rationale": ["We need to find the organisation type and id of the organisation with the most research staff.", "To do this, we will join the 'Organisations' table with the 'Research_Staff' table on the organisation id.", "We also need to join the 'Organisation_Types' table to get the organisation type description based on the organisation type code.", "We will group the results by organisation id and organisation type to count the number of research staff for each organisation.", "Finally, we will order the results by the count of research staff in descending order and limit the results to 1 to get the organisation with the most research staff."], "gold_sql": "SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT Organisations.organisation_id, Organisation_Types.organisation_type \nFROM Organisations \nJOIN Research_Staff ON Organisations.organisation_id = Research_Staff.employer_organisation_id \nJOIN Organisation_Types ON Organisations.organisation_type = Organisation_Types.organisation_type \nGROUP BY Organisations.organisation_id, Organisation_Types.organisation_type \nORDER BY COUNT(Research_Staff.staff_id) DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of details about research staff members from the 'Research_Staff' table, sorted in ascending order. The placeholder in the ORDER BY clause indicates that the user can specify how they want to sort the staff details.\"\n}\n"}
{"sample_id": "train.4334", "db_id": "tracking_grants_for_research", "question": "Find out the send dates of the documents with the grant amount of more than 5000 were granted by organisation type described", "rationale": ["Identify the relevant tables: Documents, Grants, Organisations, and Organisation_Types.", "Determine the relationships between these tables: Documents are linked to Grants via grant_id, Grants are linked to Organisations via organisation_id, and Organisations are linked to Organisation_Types via organisation_type.", "Select the 'sent_date' from the Documents table as the main output.", "Filter the results to include only those grants where the grant_amount is greater than 5000.", "Construct the SQL query using JOINs to connect the tables based on their relationships."], "gold_sql": "SELECT T1.sent_date FROM documents AS T1 JOIN Grants AS T2 ON T1.grant_id  =  T2.grant_id JOIN Organisations AS T3 ON T2.organisation_id  =  T3.organisation_id JOIN organisation_Types AS T4 ON T3.organisation_type  =  T4.organisation_type WHERE T2.grant_amount  >  5000 AND T4.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations", "documents"], "pred_sql": "SELECT Documents.sent_date \nFROM Documents \nJOIN Grants ON Documents.grant_id = Grants.grant_id \nJOIN Organisations ON Grants.organisation_id = Organisations.organisation_id \nJOIN Organisation_Types ON Organisations.organisation_type = Organisation_Types.organisation_type \nWHERE Grants.grant_amount > 5000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\"\n}\n"}
{"sample_id": "train.4338", "db_id": "tracking_grants_for_research", "question": "List the project details of the projects which did not hire any staff for a researcher role.", "rationale": ["We need to list project details of projects that did not hire any staff for a researcher role.", "To achieve this, we will select the project details from the Projects table.", "We will perform a LEFT JOIN with the Project_Staff table on the project_id to find any associated staff members.", "We will filter the Project_Staff table to only include those with a role_code corresponding to 'Researcher'.", "In the WHERE clause, we will check for NULL values in the staff_id from the Project_Staff table, which indicates that no staff were hired for the researcher role."], "gold_sql": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_Staff WHERE role_code  =  'researcher' )", "source_tables": ["project_staff", "projects"], "pred_sql": "SELECT p.project_details \nFROM Projects p \nLEFT JOIN Project_Staff ps ON p.project_id = ps.project_id AND ps.role_code = (SELECT role_code FROM Staff_Roles WHERE role_description = 'Researcher') \nWHERE ps.staff_id IS NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\"\n}\n"}
{"sample_id": "train.4339", "db_id": "tracking_grants_for_research", "question": "What are the details for all projects that did not hire any staff in a research role?", "rationale": ["Identify the relevant tables: Projects and Project_Staff.", "We need to find projects that did not hire any staff in a research role, so we will use a LEFT JOIN between Projects and Project_Staff.", "The join condition will include a filter for staff roles that are related to research, which can be identified by checking the Staff_Roles table for role descriptions that include 'research'.", "To find projects without any research staff, we will check for NULL values in the staff_id column of the Project_Staff table after the join.", "Select the project_id and project_details from the Projects table where the condition is met."], "gold_sql": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_Staff WHERE role_code  =  'researcher' )", "source_tables": ["project_staff", "projects"], "pred_sql": "SELECT p.project_id, p.project_details \nFROM Projects p \nLEFT JOIN Project_Staff ps ON p.project_id = ps.project_id AND ps.role_code IN (SELECT role_code FROM Staff_Roles WHERE role_description LIKE '%research%') \nWHERE ps.staff_id IS NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\"\n}\n"}
{"sample_id": "train.4342", "db_id": "tracking_grants_for_research", "question": "When do all the researcher role staff start to work, and when do they stop working?", "rationale": ["Identify the relevant table: Project_Staff contains the information about staff members and their involvement dates.", "Determine the columns needed: We need the start date (date_from) and end date (date_to) for the researcher role staff.", "Filter the staff members by their role: Use a subquery to select role codes from Staff_Roles where the role description includes 'researcher'.", "Use aggregate functions: To find the earliest start date and the latest end date, we will use MIN() and MAX() functions respectively.", "Construct the SQL query: Combine all the elements into a single SQL query that selects the minimum start date and maximum end date for the filtered staff members."], "gold_sql": "SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  'researcher'", "source_tables": ["project_staff"], "pred_sql": "SELECT MIN(date_from) AS start_date, MAX(date_to) AS end_date \nFROM Project_Staff \nWHERE role_code IN (SELECT role_code FROM Staff_Roles WHERE role_description LIKE '%researcher%');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\"\n}\n"}
{"sample_id": "train.4350", "db_id": "tracking_grants_for_research", "question": "How many staff does each project has? List the project id and the number in an ascending order.", "rationale": ["Identify the relevant tables: We need to count the number of staff members associated with each project, so we will use the Project_Staff table.", "Determine the columns needed: We need the project_id and the count of staff members (staff_id).", "Use the COUNT() function: To count the number of staff members for each project, we will use the COUNT() function on staff_id.", "Group the results: We will group the results by project_id to get the count of staff for each project.", "Order the results: Finally, we will order the results in ascending order based on project_id."], "gold_sql": "SELECT T1.project_id ,  count(*) FROM Project_Staff AS T1 JOIN Projects AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) ASC", "source_tables": ["project_staff", "projects"], "pred_sql": "SELECT project_id, COUNT(staff_id) AS staff_count\nFROM Project_Staff\nGROUP BY project_id\nORDER BY project_id ASC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of staff members associated with projects, filtered by a specific role code or by their involvement start date. The placeholders in the WHERE clause represent the role code and the date from which to consider staff involvement.\"\n}\n"}
{"sample_id": "train.4351", "db_id": "tracking_grants_for_research", "question": "For each project id, how many staff does it have? List them in increasing order.", "rationale": ["Identify the relevant tables: We need to count staff members associated with each project, so we will use the Project_Staff table.", "Determine the required fields: We need the project_id and the count of staff members (staff_id).", "Use the COUNT() function to count the number of staff members for each project_id.", "Group the results by project_id to get the count for each project.", "Order the results in increasing order of project_id."], "gold_sql": "SELECT T1.project_id ,  count(*) FROM Project_Staff AS T1 JOIN Projects AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) ASC", "source_tables": ["project_staff", "projects"], "pred_sql": "SELECT project_id, COUNT(staff_id) AS staff_count \nFROM Project_Staff \nGROUP BY project_id \nORDER BY project_id ASC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of staff members associated with projects, filtered by a specific role code or by their involvement start date. The placeholders in the WHERE clause represent the role code and the date from which to consider staff involvement.\"\n}\n"}
{"sample_id": "train.4356", "db_id": "tracking_grants_for_research", "question": "Which project made the most number of outcomes? List the project details and the project id.", "rationale": ["Identify the relevant tables: Projects and Project_Outcomes are needed to get project details and their outcomes.", "Join the Projects table with the Project_Outcomes table on the project_id to associate projects with their outcomes.", "Group the results by project_id and project_details to aggregate the outcomes for each project.", "Count the number of outcomes for each project using COUNT(po.outcome_code).", "Order the results in descending order to get the project with the most outcomes at the top.", "Limit the results to 1 to get only the project with the highest number of outcomes."], "gold_sql": "SELECT T1.project_details ,  T1.project_id FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "projects"], "pred_sql": "SELECT p.project_id, p.project_details\nFROM Projects p\nJOIN Project_Outcomes po ON p.project_id = po.project_id\nGROUP BY p.project_id, p.project_details\nORDER BY COUNT(po.outcome_code) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.\"\n}\n"}
{"sample_id": "train.4359", "db_id": "tracking_grants_for_research", "question": "What are the details of the project with no outcomes?", "rationale": ["Identify the main table of interest, which is 'Projects', as we need details of projects.", "Determine the condition for projects with no outcomes, which means we need to check for projects that do not have any associated entries in the 'Project_Outcomes' table.", "Use a subquery to select all project_ids from 'Project_Outcomes' and then filter the 'Projects' table to exclude these project_ids.", "Construct the SQL query to select all columns from 'Projects' where the project_id is not in the list of project_ids from the subquery."], "gold_sql": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_outcomes )", "source_tables": ["project_outcomes", "projects"], "pred_sql": "SELECT * FROM Projects WHERE project_id NOT IN (SELECT project_id FROM Project_Outcomes);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.\"\n}\n"}
{"sample_id": "train.4360", "db_id": "tracking_grants_for_research", "question": "Which organisation hired the most number of research staff? List the organisation id, type and detail.", "rationale": ["Identify the relevant tables: Research_Staff and Organisations.", "We need to join these tables on the employer_organisation_id from Research_Staff and organisation_id from Organisations.", "We want to count the number of research staff for each organisation, so we will use GROUP BY on organisation_id.", "To find the organisation with the most research staff, we will use COUNT() to count the staff_id and order the results in descending order.", "Finally, we will limit the results to 1 to get the organisation with the highest count."], "gold_sql": "SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT Organisations.organisation_id, Organisations.organisation_type, Organisations.organisation_details\nFROM Research_Staff\nJOIN Organisations ON Research_Staff.employer_organisation_id = Organisations.organisation_id\nGROUP BY Organisations.organisation_id\nORDER BY COUNT(Research_Staff.staff_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of details about research staff members from the 'Research_Staff' table, sorted in ascending order. The placeholder in the ORDER BY clause indicates that the user can specify how they want to sort the staff details.\"\n}\n"}
{"sample_id": "train.4363", "db_id": "tracking_grants_for_research", "question": "For each staff id, what is the description of the role that is involved with the most number of projects?", "rationale": ["Identify the relevant tables: Project_Staff for staff involvement in projects and Staff_Roles for role descriptions.", "Join Project_Staff with Staff_Roles on role_code to get role descriptions for each staff member.", "Filter the results to include only those staff members who are currently involved in projects (date_from <= now and date_to is either NULL or >= now).", "Group the results by staff_id and role_description to count the number of projects each staff member is involved in for each role.", "Order the results by the count of projects in descending order to find the role with the most involvement.", "Limit the results to 1 to get the staff id and role description of the role involved with the most number of projects."], "gold_sql": "SELECT T1.role_description ,  T2.staff_id FROM Staff_Roles AS T1 JOIN Project_Staff AS T2 ON T1.role_code  =  T2.role_code JOIN Project_outcomes AS T3 ON T2.project_id  =  T3.project_id GROUP BY T2.staff_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "project_staff", "staff_roles"], "pred_sql": "SELECT ps.staff_id, sr.role_description\nFROM Project_Staff ps\nJOIN Staff_Roles sr ON ps.role_code = sr.role_code\nWHERE ps.date_from <= DATE('now') AND (ps.date_to IS NULL OR ps.date_to >= DATE('now'))\nGROUP BY ps.staff_id, sr.role_description\nORDER BY COUNT(ps.project_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\"\n}\n"}
{"sample_id": "train.4364", "db_id": "tracking_grants_for_research", "question": "Which document type is described with the prefix 'Initial'?", "rationale": ["Identify the table that contains document types, which is 'Document_Types'.", "Determine the relevant columns needed: 'document_type_code' and 'document_description'.", "The question asks for document types with descriptions that start with the prefix 'Initial'.", "Use the SQL 'LIKE' operator to filter results where 'document_description' starts with 'Initial'.", "Construct the SQL query to select the required columns from the 'Document_Types' table with the appropriate condition."], "gold_sql": "SELECT document_type_code FROM Document_Types WHERE document_description LIKE 'Initial%'", "source_tables": ["document_types"], "pred_sql": "SELECT document_type_code, document_description FROM Document_Types WHERE document_description LIKE 'Initial%';", "hint": "\n"}
{"sample_id": "train.4369", "db_id": "tracking_grants_for_research", "question": "For each grant id, how many documents does it have, and which one has the most?", "rationale": ["We need to count the number of documents associated with each grant id.", "We will use the Grants table to get the grant ids and the Documents table to count the documents.", "We will perform a LEFT JOIN between Grants and Documents on the grant_id to ensure we get all grants even if they have no documents.", "We will use COUNT(d.document_id) to count the number of documents for each grant.", "We will group the results by grant_id to get the count for each grant.", "To find the grant with the most documents, we will order the results by document_count in descending order.", "Finally, we will limit the results to 1 to get only the grant with the most documents."], "gold_sql": "SELECT grant_id ,  count(*) FROM Documents GROUP BY grant_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["documents"], "pred_sql": "SELECT g.grant_id, COUNT(d.document_id) AS document_count, d.document_id\nFROM Grants g\nLEFT JOIN Documents d ON g.grant_id = d.grant_id\nGROUP BY g.grant_id\nHAVING COUNT(d.document_id) > 0\nORDER BY document_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.4374", "db_id": "tracking_grants_for_research", "question": "How many Patent outcomes are generated from all the projects?", "rationale": ["Identify the relevant tables: Project_Outcomes and Research_Outcomes are needed to find patent outcomes.", "Determine the relationship: Project_Outcomes has a foreign key relationship with Research_Outcomes through outcome_code.", "Filter for patent outcomes: Use a WHERE clause to filter Research_Outcomes for descriptions that include 'Patent'.", "Count distinct outcomes: Use COUNT(DISTINCT ...) to count unique patent outcomes from the filtered results."], "gold_sql": "SELECT count(*) FROM Project_outcomes WHERE outcome_code  =  'Patent'", "source_tables": ["project_outcomes"], "pred_sql": "SELECT COUNT(DISTINCT po.outcome_code) AS patent_outcome_count\nFROM Project_Outcomes po\nJOIN Research_Outcomes ro ON po.outcome_code = ro.outcome_code\nWHERE ro.outcome_description LIKE '%Patent%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.\"\n}\n"}
{"sample_id": "train.4376", "db_id": "tracking_grants_for_research", "question": "How many project staff worked as leaders or started working before '1989-04-24 23:51:54'?", "rationale": ["Identify the relevant table: Project_Staff contains information about staff members involved in projects, including their roles and dates of involvement.", "Determine the criteria for filtering: We need to count staff members who worked as leaders and started before a specific date.", "Use a subquery to find the role_code for 'Leader' from the Staff_Roles table.", "Filter the Project_Staff table using the role_code for leaders and the date_from column to ensure the date is before '1989-04-24 23:51:54'.", "Count the number of records that meet these criteria."], "gold_sql": "SELECT count(*) FROM Project_Staff WHERE role_code  =  'leader' OR date_from  <  '1989-04-24 23:51:54'", "source_tables": ["project_staff"], "pred_sql": "SELECT COUNT(*) \nFROM Project_Staff \nWHERE role_code = (SELECT role_code FROM Staff_Roles WHERE role_description = 'Leader') \nAND date_from < '1989-04-24 23:51:54';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\"\n}\n"}
{"sample_id": "train.4380", "db_id": "tracking_grants_for_research", "question": "What are the result description of the project whose detail is 'sint'?", "rationale": ["Identify the relevant table: The question asks about project details, which are stored in the 'Projects' table.", "Determine the specific column needed: We need the 'project_details' column to find the project with the detail 'sint'.", "Formulate the SQL query: We will select the 'project_id' and 'project_details' from the 'Projects' table where 'project_details' matches 'sint'."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code JOIN Projects AS T3 ON T2.project_id  =  T3.project_id WHERE T3.project_details  =  'sint'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "pred_sql": "SELECT project_id, project_details FROM Projects WHERE project_details = 'sint';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.\"\n}\n"}
{"sample_id": "train.4381", "db_id": "tracking_grants_for_research", "question": "What is the description for the results whose project detail is 'sint'?", "rationale": ["Identify the relevant tables: Projects and Project_Outcomes.", "Determine the relationship between the tables: Projects has a project_id that links to Project_Outcomes.", "Select the necessary columns: project_details from Projects and outcome_details from Project_Outcomes.", "Filter the results based on the project detail being 'sint'.", "Construct the SQL query using JOIN to combine the two tables based on the project_id."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code JOIN Projects AS T3 ON T2.project_id  =  T3.project_id WHERE T3.project_details  =  'sint'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "pred_sql": "SELECT p.project_details, po.outcome_details \nFROM Projects p \nJOIN Project_Outcomes po ON p.project_id = po.project_id \nWHERE p.project_details = 'sint';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.\"\n}\n"}
{"sample_id": "train.4385", "db_id": "tracking_grants_for_research", "question": "What are the details for the projects which were launched by the organization with the most projects?", "rationale": ["Identify the table that contains project details, which is the 'Projects' table.", "Determine the organization with the most projects by grouping the 'Projects' table by 'organisation_id' and counting the number of projects for each organization.", "Order the results by the count of projects in descending order to get the organization with the highest count at the top.", "Use a subquery to find the 'organisation_id' of the organization with the most projects.", "Select all details from the 'Projects' table where the 'organisation_id' matches the one found in the subquery."], "gold_sql": "SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT 1 )", "source_tables": ["projects"], "pred_sql": "SELECT * FROM Projects WHERE organisation_id = (SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY COUNT(project_id) DESC LIMIT 1);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.\"\n}\n"}
{"sample_id": "train.4391", "db_id": "tracking_grants_for_research", "question": "For each project id, how many tasks are there?", "rationale": ["Identify the relevant tables: We need to count tasks associated with each project, so we will use the 'Tasks' table.", "Determine the grouping: We want to group the results by 'project_id' to get the count of tasks for each project.", "Use the COUNT function: We will use COUNT(task_id) to count the number of tasks for each project.", "Construct the SQL query: Combine the SELECT statement with the GROUP BY clause to form the complete SQL query."], "gold_sql": "SELECT count(*) ,  T1.project_details FROM Projects AS T1 JOIN Tasks AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id", "source_tables": ["tasks", "projects"], "pred_sql": "SELECT project_id, COUNT(task_id) AS task_count \nFROM Tasks \nGROUP BY project_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.\"\n}\n"}
{"sample_id": "train.4392", "db_id": "tracking_grants_for_research", "question": "What are the staff roles of the staff who", "rationale": ["Identify the relevant tables: Project_Staff and Staff_Roles are needed to get the staff roles.", "Join the Project_Staff table with the Staff_Roles table on the role_code to get the role descriptions.", "Filter the results based on the involvement dates of the staff members: include those whose date_from is less than or equal to the current date and whose date_to is either NULL or greater than or equal to the current date."], "gold_sql": "SELECT role_code FROM Project_Staff WHERE date_from  >  '2003-04-19 15:06:20' AND date_to  <  '2016-03-15 00:33:18'", "source_tables": ["project_staff"], "pred_sql": "SELECT sr.role_description \nFROM Project_Staff ps \nJOIN Staff_Roles sr ON ps.role_code = sr.role_code \nWHERE ps.date_from <= DATE('now') AND (ps.date_to IS NULL OR ps.date_to >= DATE('now'));", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\"\n}\n"}
{"sample_id": "train.4397", "db_id": "tracking_grants_for_research", "question": "What is the most common role for the staff?", "rationale": ["Identify the relevant table: The question pertains to staff roles, so we will focus on the Project_Staff table.", "Count occurrences: We need to count how many times each role_code appears in the Project_Staff table to determine the most common role.", "Group by role_code: To count the occurrences of each role, we will group the results by role_code.", "Order by count: We will order the results in descending order based on the count of each role to find the most common one.", "Limit the results: Since we only want the most common role, we will limit the results to 1."], "gold_sql": "SELECT role_code FROM Project_Staff GROUP BY role_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_staff"], "pred_sql": "SELECT role_code, COUNT(*) as role_count \nFROM Project_Staff \nGROUP BY role_code \nORDER BY role_count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\"\n}\n"}
{"sample_id": "train.5534", "db_id": "products_gen_characteristics", "question": "Find the number of products with category \"Spices\" and typically sold above 1000.", "rationale": ["Identify the relevant tables: Products and Ref_Product_Categories.", "We need to count the number of products, so we will use the COUNT() function.", "Join the Products table with the Ref_Product_Categories table on the product_category_code to filter by category.", "Add a WHERE clause to filter for products in the 'Spices' category.", "Add another condition in the WHERE clause to filter for products with a typical selling price greater than 1000."], "gold_sql": "SELECT count(*) FROM products WHERE product_category_code  =  'Spices' AND typical_buying_price  >  1000", "source_tables": ["products"], "pred_sql": "SELECT COUNT(*) AS product_count\nFROM Products\nJOIN Ref_Product_Categories ON Products.product_category_code = Ref_Product_Categories.product_category_code\nWHERE Ref_Product_Categories.product_category_description = 'Spices'\nAND Products.typical_selling_price > 1000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of products from the 'Products' table that belong to a specific product category and have a typical buying price above a certain threshold. The placeholders in the WHERE clause represent the product category code and the minimum buying price.\"\n}\n"}
{"sample_id": "train.5543", "db_id": "products_gen_characteristics", "question": "What are the descriptions of the categories that products with product descriptions that contain the letter t are in?", "rationale": ["Identify the relevant tables: We need to get product category descriptions from the Ref_Product_Categories table and filter products based on their descriptions from the Products table.", "Determine the relationship: The Products table has a foreign key relationship with the Ref_Product_Categories table through the product_category_code.", "Formulate the SQL query: We will select the distinct product_category_description from Ref_Product_Categories where we join it with Products on product_category_code.", "Add the filtering condition: We need to filter products whose product_description contains the letter 't', which can be done using the LIKE operator with a wildcard."], "gold_sql": "SELECT T1.product_category_description FROM ref_product_categories AS T1 JOIN products AS T2 ON T1.product_category_code  =  T2.product_category_code WHERE T2.product_description LIKE '%t%'", "source_tables": ["products", "ref_product_categories"], "pred_sql": "SELECT DISTINCT rpc.product_category_description \nFROM Ref_Product_Categories rpc \nJOIN Products p ON rpc.product_category_code = p.product_category_code \nWHERE p.product_description LIKE '%t%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of products from the 'Products' table that belong to a specific product category and have a typical buying price above a certain threshold. The placeholders in the WHERE clause represent the product category code and the minimum buying price.\"\n}\n"}
{"sample_id": "train.5576", "db_id": "products_gen_characteristics", "question": "Count the products that have the color description \"white\" or have the characteristic name \"hot\".", "rationale": ["We need to count the products based on two conditions: color description and characteristic name.", "First, we will select from the 'Products' table.", "To check the color description, we will join the 'Ref_Colors' table on the 'color_code'.", "To check the characteristic name, we will join the 'Product_Characteristics' table on 'product_id' and then join the 'Characteristics' table on 'characteristic_id'.", "In the WHERE clause, we will specify the conditions: color description should be 'white' or characteristic name should be 'hot'.", "Finally, we will use COUNT(*) to get the total number of products that meet either of the conditions."], "gold_sql": "SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  'white' OR t3.characteristic_name  =  'hot'", "source_tables": ["products", "ref_colors", "characteristics", "product_characteristics"], "pred_sql": "SELECT COUNT(*) FROM Products p\nLEFT JOIN Ref_Colors c ON p.color_code = c.color_code\nLEFT JOIN Product_Characteristics pc ON p.product_id = pc.product_id\nLEFT JOIN Characteristics ch ON pc.characteristic_id = ch.characteristic_id\nWHERE c.color_description = 'white' OR ch.characteristic_name = 'hot';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of products from the 'Products' table that belong to a specific product category and have a typical buying price above a certain threshold. The placeholders in the WHERE clause represent the product category code and the minimum buying price.\"\n}\n"}
{"sample_id": "train.5579", "db_id": "products_gen_characteristics", "question": "Return the unit of measure for 'Herb' products.", "rationale": ["Identify the relevant tables: Products and Ref_Product_Categories.", "Determine the relationship between the tables: Products has a foreign key to Ref_Product_Categories via product_category_code.", "Select the unit_of_measure from Ref_Product_Categories.", "Filter the products to only include those that are related to 'Herb' by using a LIKE clause on the product_name."], "gold_sql": "SELECT unit_of_measure FROM ref_product_categories WHERE product_category_code  =  'Herbs'", "source_tables": ["ref_product_categories"], "pred_sql": "SELECT Ref_Product_Categories.unit_of_measure \nFROM Products \nJOIN Ref_Product_Categories ON Products.product_category_code = Ref_Product_Categories.product_category_code \nWHERE Products.product_name LIKE '%Herb%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of products from the 'Products' table that belong to a specific product category and have a typical buying price above a certain threshold. The placeholders in the WHERE clause represent the product category code and the minimum buying price.\"\n}\n"}
{"sample_id": "train.5586", "db_id": "products_gen_characteristics", "question": "Find the unit of measurement and product category code of product named \"chervil\".", "rationale": ["Identify the relevant tables: Products and Ref_Product_Categories.", "Determine the columns needed: unit_of_measure from Ref_Product_Categories and product_category_code from Products.", "Establish the relationship between the tables using the foreign key: Products.product_category_code = Ref_Product_Categories.product_category_code.", "Filter the results to find the product named 'chervil'.", "Construct the SQL SELECT statement to retrieve the desired columns."], "gold_sql": "SELECT t2.unit_of_measure ,  t2.product_category_code FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code WHERE t1.product_name  =  'chervil'", "source_tables": ["products", "ref_product_categories"], "pred_sql": "SELECT pc.product_category_code, p.product_name, rpc.unit_of_measure \nFROM Products p \nJOIN Ref_Product_Categories rpc ON p.product_category_code = rpc.product_category_code \nWHERE p.product_name = 'chervil';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of products from the 'Products' table that belong to a specific product category and have a typical buying price above a certain threshold. The placeholders in the WHERE clause represent the product category code and the minimum buying price.\"\n}\n"}
{"sample_id": "train.5589", "db_id": "products_gen_characteristics", "question": "What are the names of products that are not 'white' in color and are not measured by the unit 'Handful'?", "rationale": ["Identify the relevant tables: Products, Ref_Colors, and Ref_Product_Categories.", "We need to select the product names from the Products table.", "Filter out products that are 'white' in color. This requires a subquery to get the color_code for 'white' from the Ref_Colors table.", "Also, filter out products that are measured by the unit 'Handful'. This requires another subquery to get the product_category_code for 'Handful' from the Ref_Product_Categories table.", "Combine these conditions in the WHERE clause using the NOT EQUAL operator (!=) for both filters."], "gold_sql": "SELECT t1.product_name FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code JOIN ref_colors AS t3 ON t1.color_code  =  t3.color_code WHERE t3.color_description  =  'white' AND t2.unit_of_measure != 'Handful'", "source_tables": ["products", "ref_colors", "ref_product_categories"], "pred_sql": "SELECT product_name \nFROM Products \nWHERE color_code != (SELECT color_code FROM Ref_Colors WHERE color_description = 'white') \nAND product_category_code != (SELECT product_category_code FROM Ref_Product_Categories WHERE unit_of_measure = 'Handful');", "hint": "\n"}
{"sample_id": "train.5592", "db_id": "products_gen_characteristics", "question": "What is the description of the color used by least products?", "rationale": ["Identify the relevant tables: We need to find the color descriptions from the Ref_Colors table and the products that use those colors from the Products table.", "Join the tables: We will join the Ref_Colors table with the Products table on the color_code to link colors with their respective products.", "Group by color: We will group the results by color_code to count how many products are associated with each color.", "Count products: Use COUNT(p.product_id) to count the number of products for each color.", "Order by count: We will order the results in ascending order to find the color used by the least number of products.", "Limit the results: Finally, we will limit the results to 1 to get only the color with the least products."], "gold_sql": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) ASC LIMIT 1", "source_tables": ["products", "ref_colors"], "pred_sql": "SELECT c.color_description\nFROM Ref_Colors c\nJOIN Products p ON c.color_code = p.color_code\nGROUP BY c.color_code\nORDER BY COUNT(p.product_id) ASC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of products from the 'Products' table that belong to a specific product category and have a typical buying price above a certain threshold. The placeholders in the WHERE clause represent the product category code and the minimum buying price.\"\n}\n"}
{"sample_id": "train.5599", "db_id": "products_gen_characteristics", "question": "Give the names of characteristics that are in two or more products?", "rationale": ["We need to find the names of characteristics that are associated with two or more products.", "To do this, we will join the 'Characteristics' table with the 'Product_Characteristics' table using the 'characteristic_id'.", "Next, we will group the results by 'characteristic_name' to aggregate the data for each characteristic.", "We will use the HAVING clause to filter the groups, ensuring that we only include those characteristics that are linked to two or more distinct products, which we count using COUNT(DISTINCT Product_Characteristics.product_id)."], "gold_sql": "SELECT t3.characteristic_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id GROUP BY t3.characteristic_name HAVING count(*)  >= 2", "source_tables": ["products", "characteristics", "product_characteristics"], "pred_sql": "SELECT characteristic_name\nFROM Characteristics\nJOIN Product_Characteristics ON Characteristics.characteristic_id = Product_Characteristics.characteristic_id\nGROUP BY characteristic_name\nHAVING COUNT(DISTINCT Product_Characteristics.product_id) >= 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique characteristic names from the 'Characteristics' table. The use of DISTINCT ensures that each characteristic name appears only once in the result set.\"\n}\n"}
{"sample_id": "train.5669", "db_id": "dorm_1", "question": "What are the names of the all-female dorms?", "rationale": ["Identify the table that contains information about dormitories, which is the 'Dorm' table.", "Determine the relevant column that specifies the gender designation for the dormitory, which is the 'gender' column.", "Formulate a SQL query to select the 'dorm_name' from the 'Dorm' table where the 'gender' is 'F' for female dorms."], "gold_sql": "SELECT dorm_name FROM dorm WHERE gender  =  'F'", "source_tables": ["dorm"], "pred_sql": "SELECT dorm_name FROM Dorm WHERE gender = 'F';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the number of students and their average age, grouped by the city code, for a specific gender. The placeholder in the WHERE clause represents the gender of the students being queried.\"\n}\n"}
{"sample_id": "train.5688", "db_id": "dorm_1", "question": "Find the average and total capacity of dorms for the students with gender X.", "rationale": ["Identify the tables involved: Dorm, Lives_in, and Student.", "We need to calculate the average and total capacity of dorms, so we will use the AVG() and SUM() functions on the 'student_capacity' column from the Dorm table.", "To find the relevant dorms, we need to join the Lives_in table with the Dorm table on 'dormid', and then join the Student table on 'stuid'.", "We will filter the results based on the gender of the students, which is specified in the WHERE clause as 'Student.Sex = 'X'.", "Finally, we will select the average and total capacity from the resulting joined tables."], "gold_sql": "SELECT avg(student_capacity) ,  sum(student_capacity) FROM dorm WHERE gender  =  'X'", "source_tables": ["dorm"], "pred_sql": "SELECT AVG(Dorm.student_capacity) AS average_capacity, SUM(Dorm.student_capacity) AS total_capacity\nFROM Dorm\nJOIN Lives_in ON Dorm.dormid = Lives_in.dormid\nJOIN Student ON Lives_in.stuid = Student.StuID\nWHERE Student.Sex = 'X';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the number of students and their average age, grouped by the city code, for a specific gender. The placeholder in the WHERE clause represents the gender of the students being queried.\"\n}\n"}
{"sample_id": "train.5699", "db_id": "dorm_1", "question": "What are the names and types of the dorms that have a capacity greater than 300 or less than 100?", "rationale": ["Identify the relevant table: The question pertains to dormitories, so we will use the 'Dorm' table.", "Determine the columns needed: We need the names of the dorms and their capacities, which correspond to 'dorm_name' and 'student_capacity'.", "Formulate the condition: We need to filter dorms based on their capacity, specifically those with a capacity greater than 300 or less than 100.", "Construct the SQL query: Using the SELECT statement to retrieve the required columns from the 'Dorm' table with the specified conditions in the WHERE clause."], "gold_sql": "SELECT dorm_name ,  gender FROM dorm WHERE student_capacity  >  300 OR student_capacity  <  100", "source_tables": ["dorm"], "pred_sql": "SELECT dorm_name, student_capacity \nFROM Dorm \nWHERE student_capacity > 300 OR student_capacity < 100;", "hint": "\n"}
{"sample_id": "train.5747", "db_id": "dorm_1", "question": "What are the total number of students who are living in a male dorm?", "rationale": ["Identify the relevant tables: Lives_in and Dorm are needed to find students living in male dorms.", "Use the COUNT function to get the total number of students.", "Join the Lives_in table with the Dorm table on the dormid to access dorm information.", "Filter the results using a WHERE clause to include only male dorms by checking the gender column in the Dorm table."], "gold_sql": "SELECT count(*) FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T3.gender  =  'M'", "source_tables": ["student", "lives_in", "dorm"], "pred_sql": "SELECT COUNT(Lives_in.stuid) AS total_students\nFROM Lives_in\nJOIN Dorm ON Lives_in.dormid = Dorm.dormid\nWHERE Dorm.gender = 'male';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the number of students and their average age, grouped by the city code, for a specific gender. The placeholder in the WHERE clause represents the gender of the students being queried.\"\n}\n"}
{"sample_id": "train.5755", "db_id": "dorm_1", "question": "What is the most common amenity in the dorms?", "rationale": ["To find the most common amenity in the dorms, we need to count the occurrences of each amenity.", "The 'Has_amenity' table links dormitories to their amenities, and the 'Dorm_amenity' table provides the names of these amenities.", "We will perform a JOIN between 'Has_amenity' and 'Dorm_amenity' to get the amenity names along with their counts.", "We will group the results by amenity ID and name to count how many times each amenity appears.", "Finally, we will order the results in descending order based on the count and limit the output to the top result to get the most common amenity."], "gold_sql": "SELECT T1.amenity_name FROM dorm_amenity AS T1 JOIN has_amenity AS T2 ON T1.amenid  =  T2.amenid GROUP BY T2.amenid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["has_amenity", "dorm_amenity"], "pred_sql": "SELECT ha.amenid, da.amenity_name, COUNT(*) as amenity_count\nFROM Has_amenity ha\nJOIN Dorm_amenity da ON ha.amenid = da.amenid\nGROUP BY ha.amenid, da.amenity_name\nORDER BY amenity_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the number of students and their average age, grouped by the city code, for a specific gender. The placeholder in the WHERE clause represents the gender of the students being queried.\"\n}\n"}
{"sample_id": "train.5757", "db_id": "dorm_1", "question": "What are the first names of all students who live in the dorm with the most amenities?", "rationale": ["Identify the relevant tables: Student, Lives_in, and Has_amenity.", "We need to find students who live in dorms, so we will join the Student table with the Lives_in table on the StuID.", "Next, we need to count the number of amenities for each dorm, so we will join the Lives_in table with the Has_amenity table on dormid.", "We will group the results by dormid to count the amenities for each dorm.", "To find the dorm with the most amenities, we will order the results by the count of amenities in descending order.", "Finally, we will limit the results to 1 to get the dorm with the most amenities and select the first names of the students living in that dorm."], "gold_sql": "SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["has_amenity", "lives_in", "student", "dorm_amenity", "dorm"], "pred_sql": "SELECT S.Fname \nFROM Student S \nJOIN Lives_in L ON S.StuID = L.stuid \nJOIN Has_amenity H ON L.dormid = H.dormid \nGROUP BY L.dormid \nORDER BY COUNT(H.amenid) DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of last names of students from the 'Student' table based on specific criteria. It includes students of a certain gender residing in a specific city, as well as students of the same gender who are younger than a specified age. The placeholders in the WHERE clauses represent the gender, city code, and age criteria.\"\n}\n"}
{"sample_id": "train.5776", "db_id": "customer_complaints", "question": "Find the emails of customers who has filed a complaints of the product with the most complaints.", "rationale": ["Identify the main goal: Find the emails of customers who have filed complaints about the product with the most complaints.", "To achieve this, we need to join the Customers table with the Complaints table on the customer_id.", "Next, we need to determine which product has the most complaints. This can be done by grouping the Complaints table by product_id and counting the number of complaints for each product.", "We will order the results of this grouping in descending order based on the count of complaints and limit the results to the top product (the one with the most complaints).", "Finally, we will use this product_id in the WHERE clause of our main query to filter the customers who complained about that product."], "gold_sql": "SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "customers"], "pred_sql": "SELECT c.email_address\nFROM Customers c\nJOIN Complaints co ON c.customer_id = co.customer_id\nWHERE co.product_id = (\n    SELECT product_id\n    FROM Complaints\n    GROUP BY product_id\n    ORDER BY COUNT(*) DESC\n    LIMIT 1\n)", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table summarizes the different complaint status codes from the 'Complaints' table, specifically focusing on those status codes that have a count exceeding a specified number. The placeholder in the HAVING clause represents the minimum count of complaints required for a status code to be included in the results.\"\n}\n"}
{"sample_id": "train.5777", "db_id": "customer_complaints", "question": "What are the emails of customers who have filed complaints on the product which has had the greatest number of complaints?", "rationale": ["Identify the main goal: Retrieve the email addresses of customers who have filed complaints about the product with the greatest number of complaints.", "To find the product with the greatest number of complaints, a subquery is needed that counts complaints grouped by product_id and orders them in descending order, limiting the result to the top product.", "Join the Customers table with the Complaints table on customer_id to access customer email addresses related to the complaints.", "Use the result of the subquery to filter the complaints to only those related to the product with the highest complaint count."], "gold_sql": "SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "customers"], "pred_sql": "SELECT c.email_address\nFROM Customers c\nJOIN Complaints co ON c.customer_id = co.customer_id\nWHERE co.product_id = (\n    SELECT product_id\n    FROM Complaints\n    GROUP BY product_id\n    ORDER BY COUNT(*) DESC\n    LIMIT 1\n)", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table summarizes the different complaint status codes from the 'Complaints' table, specifically focusing on those status codes that have a count exceeding a specified number. The placeholder in the HAVING clause represents the minimum count of complaints required for a status code to be included in the results.\"\n}\n"}
{"sample_id": "train.5779", "db_id": "customer_complaints", "question": "Return the names of products that have had complaints filed by the customer who has filed the fewest complaints.", "rationale": ["Identify the main goal: We need to find the names of products that have had complaints filed by a specific customer.", "Determine the customer who has filed the fewest complaints: This can be done by grouping the complaints by customer_id and counting them, then ordering by the count in ascending order and limiting the result to 1.", "Join the Products table with the Complaints table on product_id to get the product names associated with the complaints.", "Filter the results to only include products that have complaints from the identified customer (the one with the fewest complaints).", "Construct the SQL query using the SELECT statement to retrieve the product names, along with the necessary JOIN and WHERE clauses."], "gold_sql": "SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "products", "customers"], "pred_sql": "SELECT p.product_name \nFROM Products p \nJOIN Complaints c ON p.product_id = c.product_id \nWHERE c.customer_id = (\n    SELECT customer_id \n    FROM Complaints \n    GROUP BY customer_id \n    ORDER BY COUNT(*) ASC \n    LIMIT 1\n)", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table summarizes the different complaint status codes from the 'Complaints' table, specifically focusing on those status codes that have a count exceeding a specified number. The placeholder in the HAVING clause represents the minimum count of complaints required for a status code to be included in the results.\"\n}\n"}
{"sample_id": "train.5795", "db_id": "customer_complaints", "question": "What is the last name of the staff member in charge of the complaint on the product with the lowest price?", "rationale": ["Identify the relevant tables: Staff, Complaints, and Products.", "We need to find the last name of the staff member handling a complaint related to the product with the lowest price.", "To do this, we will join the Staff table with the Complaints table on staff_id, and then join the Complaints table with the Products table on product_id.", "Next, we need to find the product with the lowest price. This can be done using a subquery that selects the minimum product_price from the Products table.", "Finally, we will filter the results to only include the staff member associated with the complaint for the product that has the lowest price."], "gold_sql": "SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT 1", "source_tables": ["complaints", "products", "staff"], "pred_sql": "SELECT Staff.last_name \nFROM Staff \nJOIN Complaints ON Staff.staff_id = Complaints.staff_id \nJOIN Products ON Complaints.product_id = Products.product_id \nWHERE Products.product_price = (\n    SELECT MIN(product_price) \n    FROM Products\n);", "hint": "\n"}
{"sample_id": "train.5800", "db_id": "customer_complaints", "question": "How many customers are there in the customer type with the most customers?", "rationale": ["Identify the need to count customers based on their type.", "Use the Customers table to access customer data.", "Group the results by the customer_type_code to get the count of customers for each type.", "Order the results in descending order to find the type with the most customers.", "Limit the results to 1 to get only the top customer type."], "gold_sql": "SELECT count(*) FROM customers GROUP BY customer_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers"], "pred_sql": "SELECT customer_type_code, COUNT(customer_id) AS customer_count \nFROM Customers \nGROUP BY customer_type_code \nORDER BY customer_count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of customers grouped by their type, allowing for an analysis of the distribution of different customer types. The placeholder in the LIMIT clause represents the maximum number of customer types to display, enabling users to specify how many top customer types they wish to see.\"\n}\n"}
{"sample_id": "train.5810", "db_id": "customer_complaints", "question": "What is first names of the top 5 staff who have handled the greatest number of complaints?", "rationale": ["Identify the relevant tables: Staff and Complaints.", "We need to find the first names of staff members, so we will select the 'first_name' column from the Staff table.", "To determine how many complaints each staff member has handled, we will join the Staff table with the Complaints table on the 'staff_id' column.", "We will group the results by 'staff_id' to aggregate the number of complaints handled by each staff member.", "We will use the COUNT function to count the number of complaints for each staff member.", "To get the top 5 staff members who handled the greatest number of complaints, we will order the results in descending order based on the count of complaints and limit the results to 5."], "gold_sql": "SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT 5", "source_tables": ["complaints", "staff"], "pred_sql": "SELECT first_name \nFROM Staff \nJOIN Complaints ON Staff.staff_id = Complaints.staff_id \nGROUP BY Staff.staff_id \nORDER BY COUNT(Complaints.complaint_id) DESC \nLIMIT 5;", "hint": "\n"}
{"sample_id": "train.5812", "db_id": "customer_complaints", "question": "Which state has the most customers?", "rationale": ["Identify the relevant table: The question pertains to customers, so we will use the Customers table.", "Determine the required information: We need to find out which state has the most customers, which means we need to count the number of customers in each state.", "Group the results: To count the customers by state, we will use the GROUP BY clause on the 'state' column.", "Count the customers: We will use the COUNT function to count the number of customer_id entries for each state.", "Order the results: To find the state with the most customers, we will order the results in descending order based on the customer count.", "Limit the results: Since we only want the state with the most customers, we will use the LIMIT clause to restrict the output to 1."], "gold_sql": "SELECT state FROM customers GROUP BY state ORDER BY count(*) LIMIT 1", "source_tables": ["customers"], "pred_sql": "SELECT state, COUNT(customer_id) AS customer_count\nFROM Customers\nGROUP BY state\nORDER BY customer_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of customers grouped by their type, allowing for an analysis of the distribution of different customer types. The placeholder in the LIMIT clause represents the maximum number of customer types to display, enabling users to specify how many top customer types they wish to see.\"\n}\n"}
{"sample_id": "train.5813", "db_id": "customer_complaints", "question": "Give the state that has the most customers.", "rationale": ["Identify the table that contains customer information, which is the 'Customers' table.", "We need to count the number of customers in each state, so we will use the COUNT() function.", "To group the results by state, we will use the GROUP BY clause on the 'state' column.", "To find the state with the most customers, we will order the results in descending order based on the count of customers.", "Finally, we will limit the results to only the top state using the LIMIT clause."], "gold_sql": "SELECT state FROM customers GROUP BY state ORDER BY count(*) LIMIT 1", "source_tables": ["customers"], "pred_sql": "SELECT state, COUNT(customer_id) AS customer_count\nFROM Customers\nGROUP BY state\nORDER BY customer_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of customers grouped by their type, allowing for an analysis of the distribution of different customer types. The placeholder in the LIMIT clause represents the maximum number of customer types to display, enabling users to specify how many top customer types they wish to see.\"\n}\n"}
{"sample_id": "train.5865", "db_id": "tracking_share_transactions", "question": "What are the lot details of lots associated with transactions whose share count is bigger than 100 and whose type code is \"PUR\"?", "rationale": ["Identify the relevant tables: Lots, Transactions, and Transactions_Lots.", "We need to retrieve lot details, so we will select 'Lots.lot_details'.", "We need to filter transactions based on share count and transaction type code, so we will join the Transactions table with Transactions_Lots and Lots.", "The condition for share count is that it must be greater than 100, and the transaction type code must be 'PUR'.", "Construct the SQL query using the SELECT statement with the necessary JOINs and WHERE conditions."], "gold_sql": "SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON  T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  >  100 AND T3.transaction_type_code  =  'PUR'", "source_tables": ["lots", "transactions_lots", "transactions"], "pred_sql": "SELECT Lots.lot_details \nFROM Lots \nJOIN Transactions_Lots ON Lots.lot_id = Transactions_Lots.lot_id \nJOIN Transactions ON Transactions_Lots.transaction_id = Transactions.transaction_id \nWHERE Transactions.share_count > 100 \nAND Transactions.transaction_type_code = 'PUR';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the maximum and minimum share counts for each type of transaction recorded in the 'Transactions' table. The placeholder in the SELECT clause represents the transaction type code, while the aggregation functions calculate the maximum and minimum share counts for each group of transaction types.\"\n}\n"}
{"sample_id": "train.5866", "db_id": "tracking_share_transactions", "question": "Show the average transaction amount for different transaction types.", "rationale": ["Identify the relevant tables: Transactions and Ref_Transaction_Types are needed to get transaction amounts and their types.", "Join the Transactions table with the Ref_Transaction_Types table on the transaction_type_code to associate each transaction with its type.", "Use the AVG() function to calculate the average transaction amount for each transaction type.", "Group the results by transaction_type_code to get the average for each type."], "gold_sql": "SELECT transaction_type_code ,  avg(amount_of_transaction) FROM TRANSACTIONS GROUP BY transaction_type_code", "source_tables": ["transactions"], "pred_sql": "SELECT rt.transaction_type_code, AVG(t.amount_of_transaction) AS average_transaction_amount\nFROM Transactions t\nJOIN Ref_Transaction_Types rt ON t.transaction_type_code = rt.transaction_type_code\nGROUP BY rt.transaction_type_code;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the maximum and minimum share counts for each type of transaction recorded in the 'Transactions' table. The placeholder in the SELECT clause represents the transaction type code, while the aggregation functions calculate the maximum and minimum share counts for each group of transaction types.\"\n}\n"}
{"sample_id": "train.5873", "db_id": "tracking_share_transactions", "question": "Show the number of transactions with transaction type code \"SALE\" for different investors if it is larger than 0.", "rationale": ["Identify the relevant tables: Transactions and Ref_Transaction_Types are needed to filter by transaction type code 'SALE'.", "Use a JOIN to connect Transactions with Ref_Transaction_Types based on the transaction_type_code.", "Count the number of transactions for each investor by grouping the results by investor_id.", "Filter the results to only include those with a transaction type code of 'SALE'.", "Use the HAVING clause to ensure that only investors with more than 0 transactions are included in the final result."], "gold_sql": "SELECT investor_id ,  COUNT(*) FROM TRANSACTIONS WHERE transaction_type_code  =  'SALE' GROUP BY investor_id", "source_tables": ["transactions"], "pred_sql": "SELECT Transactions.investor_id, COUNT(Transactions.transaction_id) AS transaction_count\nFROM Transactions\nJOIN Ref_Transaction_Types ON Transactions.transaction_type_code = Ref_Transaction_Types.transaction_type_code\nWHERE Ref_Transaction_Types.transaction_type_code = 'SALE'\nGROUP BY Transactions.investor_id\nHAVING transaction_count > 0;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the maximum and minimum share counts for each type of transaction recorded in the 'Transactions' table. The placeholder in the SELECT clause represents the transaction type code, while the aggregation functions calculate the maximum and minimum share counts for each group of transaction types.\"\n}\n"}
{"sample_id": "train.5876", "db_id": "tracking_share_transactions", "question": "Show the transaction type code that occurs the most frequently.", "rationale": ["We need to find the transaction type code that occurs the most frequently in the Transactions table.", "To do this, we will use the COUNT function to count the occurrences of each transaction_type_code.", "We will group the results by transaction_type_code to aggregate the counts for each type.", "Next, we will order the results in descending order based on the count of occurrences.", "Finally, we will limit the results to only the top entry to get the most frequent transaction type code."], "gold_sql": "SELECT transaction_type_code FROM TRANSACTIONS GROUP BY transaction_type_code ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["transactions"], "pred_sql": "SELECT transaction_type_code\nFROM Transactions\nGROUP BY transaction_type_code\nORDER BY COUNT(*) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the dates of transactions from the 'Transactions' table that correspond to a specific type of transaction. The placeholder in the WHERE clause represents the transaction type code.\"\n}\n"}
{"sample_id": "train.5884", "db_id": "tracking_share_transactions", "question": "What are the details of the lots which are not used in any transactions?", "rationale": ["Identify the Lots table to retrieve details of lots.", "Determine the condition to find lots not used in any transactions.", "Use a subquery to select lot_ids from the Transactions_Lots table, which links transactions to lots.", "Use the NOT IN clause to filter out lots that are present in the Transactions_Lots subquery."], "gold_sql": "SELECT lot_details FROM Lots EXCEPT SELECT T1.lot_details FROM Lots AS T1 JOIN transactions_lots AS T2 ON T1.lot_id  =  T2.lot_id", "source_tables": ["lots", "transactions_lots"], "pred_sql": "SELECT * FROM Lots WHERE lot_id NOT IN (SELECT lot_id FROM Transactions_Lots);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the maximum and minimum share counts for each type of transaction recorded in the 'Transactions' table. The placeholder in the SELECT clause represents the transaction type code, while the aggregation functions calculate the maximum and minimum share counts for each group of transaction types.\"\n}\n"}
{"sample_id": "train.5893", "db_id": "cre_Theme_park", "question": "Show details of all visitors.", "rationale": ["The user wants to see details of all visitors, which corresponds to the 'Visitors' table in the database.", "To retrieve all details, we will use the SELECT statement with a wildcard (*) to select all columns from the 'Visitors' table."], "gold_sql": "SELECT Tourist_Details FROM VISITORS", "source_tables": ["visitors"], "pred_sql": "SELECT * FROM Visitors;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides details about tourists from the 'Visitors' table. The placeholder in the SELECT clause represents the specific details related to each tourist.\"\n}\n"}
{"sample_id": "train.5901", "db_id": "cre_Theme_park", "question": "What is the detail of the location UK Gallery?", "rationale": ["Identify the table that contains location details, which is the 'Locations' table.", "Determine the specific column to filter by, which is 'Location_Name'.", "Use a WHERE clause to specify the location name we are interested in, which is 'UK Gallery'.", "Construct the SQL query to select all columns from the 'Locations' table where the location name matches 'UK Gallery'."], "gold_sql": "SELECT Other_Details FROM LOCATIONS WHERE Location_Name  =  'UK Gallery'", "source_tables": ["locations"], "pred_sql": "SELECT * FROM Locations WHERE Location_Name = 'UK Gallery';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides details about tourists from the 'Visitors' table. The placeholder in the SELECT clause represents the specific details related to each tourist.\"\n}\n"}
{"sample_id": "train.5902", "db_id": "cre_Theme_park", "question": "Return the detail of the location named \"UK Gallery\".", "rationale": ["Identify the table that contains location details, which is the 'Locations' table.", "Determine the specific column that holds the name of the location, which is 'Location_Name'.", "Formulate a SQL query to select all columns from the 'Locations' table where the 'Location_Name' matches 'UK Gallery'."], "gold_sql": "SELECT Other_Details FROM LOCATIONS WHERE Location_Name  =  'UK Gallery'", "source_tables": ["locations"], "pred_sql": "SELECT * FROM Locations WHERE Location_Name = 'UK Gallery';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides details about tourists from the 'Visitors' table. The placeholder in the SELECT clause represents the specific details related to each tourist.\"\n}\n"}
{"sample_id": "train.5914", "db_id": "cre_Theme_park", "question": "Give me the star rating descriptions of the hotels that cost more than 10000.", "rationale": ["Identify the relevant tables: Hotels and Ref_Hotel_Star_Ratings.", "Determine the columns needed: star_rating_description from Ref_Hotel_Star_Ratings and price_range from Hotels.", "Establish the relationship between the tables using the foreign key: Hotels.star_rating_code = Ref_Hotel_Star_Ratings.star_rating_code.", "Filter the results to include only hotels with a price_range greater than 10000.", "Construct the SQL query to select the star rating descriptions based on the specified conditions."], "gold_sql": "SELECT T2.star_rating_description FROM HOTELS AS T1 JOIN Ref_Hotel_Star_Ratings AS T2 ON T1.star_rating_code  =  T2.star_rating_code WHERE T1.price_range  >  10000", "source_tables": ["ref_hotel_star_ratings", "hotels"], "pred_sql": "SELECT Ref_Hotel_Star_Ratings.star_rating_description \nFROM Hotels \nJOIN Ref_Hotel_Star_Ratings ON Hotels.star_rating_code = Ref_Hotel_Star_Ratings.star_rating_code \nWHERE Hotels.price_range > '10000';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides details about hotels, specifically their additional information and star rating codes. The results are ordered by the price range of the hotels in ascending order, and the number of results returned is limited by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.5915", "db_id": "cre_Theme_park", "question": "What are the details and opening hours of the museums?", "rationale": ["Identify the relevant table: Museums, which contains details about museums and their opening hours.", "Select the columns needed: Museum_ID, Museum_Details, and Opening_Hours.", "Construct the SQL query to retrieve these columns from the Museums table."], "gold_sql": "SELECT T1.Museum_Details ,  T2.Opening_Hours FROM MUSEUMS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Museum_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["tourist_attractions", "museums"], "pred_sql": "SELECT Museum_ID, Museum_Details, Opening_Hours FROM Museums;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides details about tourists from the 'Visitors' table. The placeholder in the SELECT clause represents the specific details related to each tourist.\"\n}\n"}
{"sample_id": "train.5922", "db_id": "cre_Theme_park", "question": "Which tourist attractions are related to royal family? Tell me their details and how we can get there.", "rationale": ["Identify the relevant tables: Tourist_Attractions and Royal_Family.", "Determine the columns needed: all columns from Tourist_Attractions, Royal_Family_Details from Royal_Family, and How_to_Get_There from Tourist_Attractions.", "Establish the relationship between the tables using the foreign key: Tourist_Attractions.Tourist_Attraction_ID = Royal_Family.Royal_Family_ID.", "Construct the SQL query using a SELECT statement to retrieve the desired columns and a JOIN to connect the tables."], "gold_sql": "SELECT T1.Royal_Family_Details ,  T2.How_to_Get_There FROM ROYAL_FAMILY AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Royal_Family_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["royal_family", "tourist_attractions"], "pred_sql": "SELECT Tourist_Attractions.*, Royal_Family.Royal_Family_Details, Tourist_Attractions.How_to_Get_There \nFROM Tourist_Attractions \nJOIN Royal_Family ON Tourist_Attractions.Tourist_Attraction_ID = Royal_Family.Royal_Family_ID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides details about tourists from the 'Visitors' table. The placeholder in the SELECT clause represents the specific details related to each tourist.\"\n}\n"}
{"sample_id": "train.5924", "db_id": "cre_Theme_park", "question": "Find the details of the shops that can be reached by walk.", "rationale": ["Identify the relevant table: Shops contains the details of the shops.", "Determine the relationship: Shops are linked to Tourist_Attractions through the Shop_ID.", "Filter the results: We need to find shops that can be reached by walking, which implies checking the How_to_Get_There field in the Tourist_Attractions table for the keyword 'walk'.", "Construct the SQL query using a JOIN to connect Shops and Tourist_Attractions, and apply the WHERE clause to filter based on the walking condition."], "gold_sql": "SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  'walk'", "source_tables": ["shops", "tourist_attractions"], "pred_sql": "SELECT Shops.Shop_ID, Shops.Shop_Details \nFROM Shops \nJOIN Tourist_Attractions ON Shops.Shop_ID = Tourist_Attractions.Tourist_Attraction_ID \nWHERE Tourist_Attractions.How_to_Get_There LIKE '%walk%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides details about hotels, specifically their additional information and star rating codes. The results are ordered by the price range of the hotels in ascending order, and the number of results returned is limited by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.5927", "db_id": "cre_Theme_park", "question": "What are the details of the markets that can be accessed by walk or bus?", "rationale": ["Identify the relevant table for street markets, which is 'Street_Markets'.", "Determine the columns needed: 'Market_ID' and 'Market_Details'.", "Identify the relationship between street markets and tourist attractions, as we need to filter based on access methods.", "Use the 'Tourist_Attractions' table to find attractions that can be accessed by walking or bus, focusing on the 'How_to_Get_There' column.", "Construct a subquery to select 'Tourist_Attraction_ID' from 'Tourist_Attractions' where 'How_to_Get_There' contains 'walk' or 'bus'.", "Use the results of the subquery to filter the 'Street_Markets' table, ensuring we only get markets related to accessible attractions."], "gold_sql": "SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  'walk' OR  T2.How_to_Get_There  =  'bus'", "source_tables": ["street_markets", "tourist_attractions"], "pred_sql": "SELECT Market_ID, Market_Details FROM Street_Markets WHERE Market_ID IN (SELECT Tourist_Attraction_ID FROM Tourist_Attractions WHERE How_to_Get_There LIKE '%walk%' OR How_to_Get_There LIKE '%bus%');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides details about hotels, specifically their additional information and star rating codes. The results are ordered by the price range of the hotels in ascending order, and the number of results returned is limited by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.5928", "db_id": "cre_Theme_park", "question": "Find the details of all the markets that are accessible by walk or bus.", "rationale": ["Identify the relevant table: Street_Markets contains the details of the markets.", "Determine the criteria for accessibility: The markets should be accessible by walk or bus.", "Formulate the SQL query to select all columns from the Street_Markets table where the Market_Details contain either 'walk' or 'bus'."], "gold_sql": "SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  'walk' OR  T2.How_to_Get_There  =  'bus'", "source_tables": ["street_markets", "tourist_attractions"], "pred_sql": "SELECT * FROM Street_Markets WHERE Market_Details LIKE '%walk%' OR Market_Details LIKE '%bus%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides details about hotels, specifically their additional information and star rating codes. The results are ordered by the price range of the hotels in ascending order, and the number of results returned is limited by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.5942", "db_id": "cre_Theme_park", "question": "What are the details of the three most expensive hotels?", "rationale": ["Identify the table that contains hotel details, which is the 'Hotels' table.", "Determine the relevant column for sorting the hotels by price, which is 'price_range'.", "Since we want the most expensive hotels, we will order the results in descending order.", "Limit the results to the top three entries to get the three most expensive hotels."], "gold_sql": "SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT 3", "source_tables": ["hotels"], "pred_sql": "SELECT * FROM Hotels ORDER BY price_range DESC LIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides details about hotels, specifically their additional information and star rating codes. The results are ordered by the price range of the hotels in ascending order, and the number of results returned is limited by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.5943", "db_id": "cre_Theme_park", "question": "Show the details and star ratings of the 3 least expensive hotels.", "rationale": ["Identify the relevant tables: Hotels and Ref_Hotel_Star_Ratings.", "Determine the columns needed: hotel_id and other_hotel_details from Hotels, and star_rating_description from Ref_Hotel_Star_Ratings.", "Join the Hotels table with Ref_Hotel_Star_Ratings on the star_rating_code to get star ratings for each hotel.", "Order the results by price_range in ascending order to find the least expensive hotels.", "Limit the results to 3 to get only the three least expensive hotels."], "gold_sql": "SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT 3", "source_tables": ["hotels"], "pred_sql": "SELECT h.hotel_id, h.other_hotel_details, r.star_rating_description \nFROM Hotels h \nJOIN Ref_Hotel_Star_Ratings r ON h.star_rating_code = r.star_rating_code \nORDER BY h.price_range ASC \nLIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides details about hotels, specifically their additional information and star rating codes. The results are ordered by the price range of the hotels in ascending order, and the number of results returned is limited by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.5945", "db_id": "cre_Theme_park", "question": "Show the transportation method most people choose to get to tourist attractions.", "rationale": ["Identify the relevant tables: 'Visits' for tracking tourist visits and 'Tourist_Attractions' for details about the attractions.", "Join the 'Visits' table with the 'Tourist_Attractions' table on the 'Tourist_Attraction_ID' to access the transportation method.", "Select the 'How_to_Get_There' column from the 'Tourist_Attractions' table to find out the transportation methods.", "Count the number of visitors for each transportation method using COUNT(*) and group the results by 'How_to_Get_There'.", "Order the results in descending order to find the most popular transportation method.", "Limit the results to 1 to get only the top choice."], "gold_sql": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["tourist_attractions"], "pred_sql": "SELECT How_to_Get_There, COUNT(*) as Number_of_Visitors\nFROM Visits\nJOIN Tourist_Attractions ON Visits.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID\nGROUP BY How_to_Get_There\nORDER BY Number_of_Visitors DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides details about tourists from the 'Visitors' table. The placeholder in the SELECT clause represents the specific details related to each tourist.\"\n}\n"}
{"sample_id": "train.5946", "db_id": "cre_Theme_park", "question": "Which transportation method is used the most often to get to tourist attractions?", "rationale": ["Identify the relevant table: The question pertains to transportation methods used to get to tourist attractions, which is related to the 'Tourist_Attractions' table.", "Determine the relevant column: The 'How_to_Get_There' column in the 'Tourist_Attractions' table contains the transportation methods.", "Count occurrences: We need to count how many times each transportation method is mentioned, which can be done using the COUNT() function.", "Group by transportation method: To get the count for each method, we will use GROUP BY on the 'How_to_Get_There' column.", "Order by usage: To find the most used method, we will order the results in descending order based on the count.", "Limit the results: Since we only want the most used method, we will limit the results to 1."], "gold_sql": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["tourist_attractions"], "pred_sql": "SELECT How_to_Get_There, COUNT(*) as usage_count \nFROM Tourist_Attractions \nGROUP BY How_to_Get_There \nORDER BY usage_count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides details about tourists from the 'Visitors' table. The placeholder in the SELECT clause represents the specific details related to each tourist.\"\n}\n"}
{"sample_id": "train.5951", "db_id": "cre_Theme_park", "question": "Show different tourist attractions' names, ids, and the corresponding number of visits.", "rationale": ["Identify the required information: tourist attractions' names, ids, and the number of visits.", "The relevant tables are 'Tourist_Attractions' for names and ids, and 'Visits' for counting the number of visits.", "Use a LEFT JOIN to connect 'Tourist_Attractions' with 'Visits' on the 'Tourist_Attraction_ID'.", "Count the number of visits for each attraction using COUNT(v.Visit_ID).", "Group the results by 'Tourist_Attraction_ID' and 'Name' to get the count for each attraction."], "gold_sql": "SELECT T1.Name ,  T2.Tourist_Attraction_ID ,   COUNT(*) FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID", "source_tables": ["visits", "tourist_attractions"], "pred_sql": "SELECT ta.Name AS Tourist_Attraction_Name, ta.Tourist_Attraction_ID, COUNT(v.Visit_ID) AS Number_of_Visits\nFROM Tourist_Attractions ta\nLEFT JOIN Visits v ON ta.Tourist_Attraction_ID = v.Tourist_Attraction_ID\nGROUP BY ta.Tourist_Attraction_ID, ta.Name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides details about tourists from the 'Visitors' table. The placeholder in the SELECT clause represents the specific details related to each tourist.\"\n}\n"}
{"sample_id": "train.5959", "db_id": "cre_Theme_park", "question": "What are the names of the tourist attractions that have parking or shopping as their feature details?", "rationale": ["Identify the main table to query from, which is 'Tourist_Attractions' for the names of tourist attractions.", "Determine the features associated with each tourist attraction by joining the 'Tourist_Attraction_Features' table.", "Join the 'Features' table to get the details of the features associated with each attraction.", "Filter the results to include only those attractions that have 'parking' or 'shopping' as their feature details."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'park' UNION SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'shopping'", "source_tables": ["features", "tourist_attractions", "tourist_attraction_features"], "pred_sql": "SELECT ta.Name\nFROM Tourist_Attractions ta\nJOIN Tourist_Attraction_Features taf ON ta.Tourist_Attraction_ID = taf.Tourist_Attraction_ID\nJOIN Features f ON taf.Feature_ID = f.Feature_ID\nWHERE f.Feature_Details IN ('parking', 'shopping');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides details about tourists from the 'Visitors' table. The placeholder in the SELECT clause represents the specific details related to each tourist.\"\n}\n"}
{"sample_id": "train.5960", "db_id": "cre_Theme_park", "question": "Find the tourist attractions that have parking or shopping as their feature details. What are the names of the attractions?", "rationale": ["Identify the main table to query from, which is 'Tourist_Attractions' for the names of attractions.", "Determine the features related to the attractions by joining the 'Tourist_Attraction_Features' table.", "Join the 'Features' table to filter based on specific feature details, which are 'parking' and 'shopping'.", "Use a WHERE clause to specify the conditions for the features we are interested in."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'park' UNION SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'shopping'", "source_tables": ["features", "tourist_attractions", "tourist_attraction_features"], "pred_sql": "SELECT ta.Name \nFROM Tourist_Attractions ta \nJOIN Tourist_Attraction_Features taf ON ta.Tourist_Attraction_ID = taf.Tourist_Attraction_ID \nJOIN Features f ON taf.Feature_ID = f.Feature_ID \nWHERE f.Feature_Details IN ('parking', 'shopping');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides details about tourists from the 'Visitors' table. The placeholder in the SELECT clause represents the specific details related to each tourist.\"\n}\n"}
{"sample_id": "train.5964", "db_id": "cre_Theme_park", "question": "Which tourist attractions do the tourists Vincent and Marcelle visit? Tell me the names of the attractions.", "rationale": ["Identify the relevant tables: 'Visits' for visit records, 'Visitors' for tourist details, and 'Tourist_Attractions' for attraction names.", "Join the 'Visits' table with the 'Visitors' table on 'Tourist_ID' to get the details of the tourists who visited.", "Join the resulting table with the 'Tourist_Attractions' table on 'Tourist_Attraction_ID' to get the names of the attractions.", "Filter the results to include only the tourists named 'Vincent' and 'Marcelle' using a WHERE clause."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  'Vincent' INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  'Marcelle'", "source_tables": ["visits", "visitors", "tourist_attractions"], "pred_sql": "SELECT ta.Name\nFROM Visits v\nJOIN Visitors vi ON v.Tourist_ID = vi.Tourist_ID\nJOIN Tourist_Attractions ta ON v.Tourist_Attraction_ID = ta.Tourist_Attraction_ID\nWHERE vi.Tourist_Details IN ('Vincent', 'Marcelle');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides details about tourists from the 'Visitors' table. The placeholder in the SELECT clause represents the specific details related to each tourist.\"\n}\n"}
{"sample_id": "train.6059", "db_id": "customers_and_addresses", "question": "What is the average amount of items ordered in each order?", "rationale": ["Identify the relevant table: The 'Order_Items' table contains the 'order_quantity' which is needed to calculate the average amount of items ordered.", "Use the AVG() function: This function will calculate the average of the 'order_quantity' column.", "Construct the SQL query: The query selects the average of 'order_quantity' from the 'Order_Items' table."], "gold_sql": "SELECT avg(order_quantity) FROM order_items", "source_tables": ["order_items"], "pred_sql": "SELECT AVG(order_quantity) AS average_items_ordered FROM Order_Items;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average quantity of products ordered from the 'Order_Items' table. The result provides insights into the typical order size for products.\"\n}\n"}
{"sample_id": "train.6066", "db_id": "customers_and_addresses", "question": "Find the payment method that is used most frequently.", "rationale": ["Identify the relevant table: The 'Customers' table contains the 'payment_method' column.", "Count the occurrences of each payment method: Use COUNT() to tally how many times each payment method appears.", "Group the results by payment method: Use GROUP BY to aggregate the counts for each unique payment method.", "Order the results by frequency: Use ORDER BY to sort the counts in descending order, so the most frequent payment method appears first.", "Limit the results to the top entry: Use LIMIT 1 to return only the most frequently used payment method."], "gold_sql": "SELECT payment_method FROM customers GROUP BY payment_method ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers"], "pred_sql": "SELECT payment_method, COUNT(payment_method) AS frequency\nFROM Customers\nGROUP BY payment_method\nORDER BY frequency DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the preferred payment methods used by customers from the 'Customers' table. It groups the results by payment method and orders them by the frequency of each method, allowing the user to specify a limit on the number of payment methods returned.\"\n}\n"}
{"sample_id": "train.6085", "db_id": "customers_and_addresses", "question": "Which city has the most customers living in?", "rationale": ["Identify the relevant tables: We need to find the city with the most customers, so we will use the Customer_Addresses and Addresses tables.", "Join the tables: We will join Customer_Addresses with Addresses on the address_id to get the city information for each customer.", "Count distinct customers: We will count the distinct customer_id for each city to avoid counting the same customer multiple times if they have multiple addresses.", "Group by city: We will group the results by city to aggregate the customer counts for each city.", "Order the results: We will order the results in descending order based on the customer count to find the city with the most customers.", "Limit the results: We will limit the results to 1 to get only the city with the highest count."], "gold_sql": "SELECT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id GROUP BY t3.city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "customers", "customer_addresses"], "pred_sql": "SELECT city, COUNT(DISTINCT customer_id) AS customer_count\nFROM Customer_Addresses\nJOIN Addresses ON Customer_Addresses.address_id = Addresses.address_id\nGROUP BY city\nORDER BY customer_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6098", "db_id": "customers_and_addresses", "question": "Find the contact channel code that was used by the customer named \"Tillman Ernser\".", "rationale": ["Identify the customer ID for 'Tillman Ernser' from the Customers table.", "Use the identified customer ID to find the corresponding contact channel code in the Customer_Contact_Channels table.", "Filter the results to only include currently active contact channels (where active_to_date is NULL).", "Limit the results to the most recently active contact channel by using LIMIT 1."], "gold_sql": "SELECT DISTINCT channel_code FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  'Tillman Ernser'", "source_tables": ["customer_contact_channels", "customers"], "pred_sql": "SELECT channel_code FROM Customer_Contact_Channels WHERE customer_id = (SELECT customer_id FROM Customers WHERE customer_name = 'Tillman Ernser') AND active_to_date IS NULL LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the channel codes and associated contact numbers from the 'Customer_Contact_Channels' table for the most recently active contact channel based on the duration of activity. The placeholder in the LIMIT clause allows for specifying the number of records to retrieve based on the longest active duration.\"\n}\n"}
{"sample_id": "train.6099", "db_id": "customers_and_addresses", "question": "What is the \"active to date\" of the latest contact channel used by \"Tillman Ernser\"?", "rationale": ["Identify the customer ID for 'Tillman Ernser' from the Customers table.", "Query the Customer_Contact_Channels table to find the active_to_date for the contact channels associated with that customer ID.", "Order the results by active_from_date in descending order to get the latest contact channel.", "Limit the results to 1 to retrieve only the most recent contact channel's active_to_date."], "gold_sql": "SELECT max(t2.active_to_date) FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  'Tillman Ernser'", "source_tables": ["customer_contact_channels", "customers"], "pred_sql": "SELECT active_to_date \nFROM Customer_Contact_Channels \nWHERE customer_id = (SELECT customer_id FROM Customers WHERE customer_name = 'Tillman Ernser') \nORDER BY active_from_date DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the channel codes and associated contact numbers from the 'Customer_Contact_Channels' table for the most recently active contact channel based on the duration of activity. The placeholder in the LIMIT clause allows for specifying the number of records to retrieve based on the longest active duration.\"\n}\n"}
{"sample_id": "train.6100", "db_id": "customers_and_addresses", "question": "Return the the \"active to date\" of the latest contact channel used by the customer named \"Tillman Ernser\".", "rationale": ["Identify the customer ID for 'Tillman Ernser' from the Customers table.", "Use the identified customer ID to query the Customer_Contact_Channels table for the active contact channels.", "Order the results by the active_from_date in descending order to get the most recently active channel.", "Limit the results to 1 to get only the latest contact channel's details.", "Select the active_to_date from the result to get the required information."], "gold_sql": "SELECT max(t2.active_to_date) FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  'Tillman Ernser'", "source_tables": ["customer_contact_channels", "customers"], "pred_sql": "SELECT active_to_date \nFROM Customer_Contact_Channels \nWHERE customer_id = (SELECT customer_id FROM Customers WHERE customer_name = 'Tillman Ernser') \nORDER BY active_from_date DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the channel codes and associated contact numbers from the 'Customer_Contact_Channels' table for the most recently active contact channel based on the duration of activity. The placeholder in the LIMIT clause allows for specifying the number of records to retrieve based on the longest active duration.\"\n}\n"}
{"sample_id": "train.6101", "db_id": "customers_and_addresses", "question": "What is the average time span of contact channels in the database?", "rationale": ["Identify the relevant table: The 'Customer_Contact_Channels' table contains the information about contact channels and their active durations.", "Determine the columns needed: We need 'active_from_date' and 'active_to_date' to calculate the duration of each contact channel.", "Calculate the duration: Use the JULIANDAY function to convert the dates into a format that allows for subtraction, which gives the duration in days.", "Calculate the average: Use the AVG function to find the average of these durations.", "Filter out inactive channels: Ensure that we only consider channels that have an 'active_to_date' that is not null, indicating they were active at some point."], "gold_sql": "SELECT avg(active_to_date - active_from_date) FROM customer_contact_channels", "source_tables": ["customer_contact_channels"], "pred_sql": "SELECT AVG(julianday(active_to_date) - julianday(active_from_date)) AS average_time_span\nFROM Customer_Contact_Channels\nWHERE active_to_date IS NOT NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the channel codes and associated contact numbers from the 'Customer_Contact_Channels' table for the most recently active contact channel based on the duration of activity. The placeholder in the LIMIT clause allows for specifying the number of records to retrieve based on the longest active duration.\"\n}\n"}
{"sample_id": "train.6102", "db_id": "customers_and_addresses", "question": "Compute the average active time span of contact channels.", "rationale": ["Identify the relevant table: Customer_Contact_Channels contains the contact channel information.", "Determine the columns needed: active_from_date and active_to_date are necessary to calculate the active time span.", "Calculate the duration: Use the julianday function to convert the dates to Julian day numbers and subtract to find the duration in days.", "Use AVG function: To compute the average of the active time spans across all contact channels.", "Filter out inactive channels: Ensure that only channels with a defined active_to_date are considered for the average calculation."], "gold_sql": "SELECT avg(active_to_date - active_from_date) FROM customer_contact_channels", "source_tables": ["customer_contact_channels"], "pred_sql": "SELECT AVG(julianday(active_to_date) - julianday(active_from_date)) AS average_active_time_span\nFROM Customer_Contact_Channels\nWHERE active_to_date IS NOT NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the channel codes and associated contact numbers from the 'Customer_Contact_Channels' table for the most recently active contact channel based on the duration of activity. The placeholder in the LIMIT clause allows for specifying the number of records to retrieve based on the longest active duration.\"\n}\n"}
{"sample_id": "train.6104", "db_id": "customers_and_addresses", "question": "Return the channel code and contact number of the customer contact channel whose active duration was the longest.", "rationale": ["Identify the relevant table: Customer_Contact_Channels, which contains channel codes and contact numbers.", "Determine the columns needed: channel_code and contact_number.", "Calculate the duration of activity for each contact channel using the difference between active_to_date and active_from_date.", "Sort the results by the calculated duration in descending order to get the longest active duration first.", "Limit the results to 1 to get only the contact channel with the longest active duration."], "gold_sql": "SELECT channel_code ,  contact_number FROM customer_contact_channels WHERE active_to_date - active_from_date  =  (SELECT active_to_date - active_from_date FROM customer_contact_channels ORDER BY (active_to_date - active_from_date) DESC LIMIT 1)", "source_tables": ["customer_contact_channels"], "pred_sql": "SELECT channel_code, contact_number FROM Customer_Contact_Channels ORDER BY (julianday(active_to_date) - julianday(active_from_date)) DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the channel codes and associated contact numbers from the 'Customer_Contact_Channels' table for the most recently active contact channel based on the duration of activity. The placeholder in the LIMIT clause allows for specifying the number of records to retrieve based on the longest active duration.\"\n}\n"}
{"sample_id": "train.6105", "db_id": "customers_and_addresses", "question": "Find the name and active date of the customer that use email as the contact channel.", "rationale": ["Identify the relevant tables: Customers and Customer_Contact_Channels.", "We need to retrieve the customer name and the active date of the customer.", "The active date corresponds to the 'active_from_date' in the Customer_Contact_Channels table.", "We will join the Customers table with the Customer_Contact_Channels table on the customer_id.", "We filter the results to include only those records where the channel_code is 'email'.", "To ensure we only get currently active email contacts, we check that 'active_to_date' is NULL."], "gold_sql": "SELECT t1.customer_name ,  t2.active_from_date FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t2.channel_code  =  'Email'", "source_tables": ["customer_contact_channels", "customers"], "pred_sql": "SELECT c.customer_name, cc.active_from_date \nFROM Customers c \nJOIN Customer_Contact_Channels cc ON c.customer_id = cc.customer_id \nWHERE cc.channel_code = 'email' \nAND cc.active_to_date IS NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the channel codes and associated contact numbers from the 'Customer_Contact_Channels' table for the most recently active contact channel based on the duration of activity. The placeholder in the LIMIT clause allows for specifying the number of records to retrieve based on the longest active duration.\"\n}\n"}
{"sample_id": "train.6127", "db_id": "customers_and_addresses", "question": "Who made the latest order?", "rationale": ["Identify the table that contains order information, which is 'Customer_Orders'.", "To find out who made the latest order, we need to sort the orders by 'order_date' in descending order.", "We will select the 'customer_id' from the 'Customer_Orders' table.", "To get only the latest order, we will limit the results to 1 using 'LIMIT 1'."], "gold_sql": "SELECT t1.customer_name FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id ORDER BY t2.order_date DESC LIMIT 1", "source_tables": ["customer_orders", "customers"], "pred_sql": "SELECT customer_id FROM Customer_Orders ORDER BY order_date DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average quantity of products ordered from the 'Order_Items' table. The result provides insights into the typical order size for products.\"\n}\n"}
{"sample_id": "train.6131", "db_id": "customers_and_addresses", "question": "Find the name and ID of the product whose total order quantity is the largest.", "rationale": ["We need to find the product with the largest total order quantity.", "To do this, we will use the 'Order_Items' table, which contains the 'product_id' and 'order_quantity'.", "We will sum the 'order_quantity' for each 'product_id' to get the total quantity ordered for each product.", "Next, we will group the results by 'product_id' to aggregate the quantities for each product.", "To find the product with the largest total order quantity, we will order the results in descending order based on the summed quantity.", "Finally, we will limit the results to 1 to get only the product with the highest total order quantity."], "gold_sql": "SELECT t2.product_details ,  t2.product_id FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY sum(t1.order_quantity) LIMIT 1", "source_tables": ["products", "order_items"], "pred_sql": "SELECT oi.product_id, SUM(oi.order_quantity) AS total_quantity\nFROM Order_Items oi\nGROUP BY oi.product_id\nORDER BY total_quantity DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average quantity of products ordered from the 'Order_Items' table. The result provides insights into the typical order size for products.\"\n}\n"}
{"sample_id": "train.6133", "db_id": "customers_and_addresses", "question": "Find all the addresses in East Julianaside, Texas or in Gleasonmouth, Arizona.", "rationale": ["Identify the relevant table: The question asks for addresses, so we will use the 'Addresses' table.", "Determine the filtering criteria: We need to find addresses in two specific cities (East Julianaside and Gleasonmouth) and their corresponding states (Texas and Arizona).", "Construct the WHERE clause: We will use an OR condition to combine the two sets of criteria for the cities and states.", "Formulate the SQL query: We will select all columns from the 'Addresses' table where the conditions are met."], "gold_sql": "SELECT address_content FROM addresses WHERE city  =  'East Julianaside' AND state_province_county  =  'Texas' UNION SELECT address_content FROM addresses WHERE city  =  'Gleasonmouth' AND state_province_county  =  'Arizona'", "source_tables": ["addresses"], "pred_sql": "SELECT * FROM Addresses WHERE (city = 'East Julianaside' AND state_province_county = 'Texas') OR (city = 'Gleasonmouth' AND state_province_county = 'Arizona');", "hint": "\n"}
{"sample_id": "train.6134", "db_id": "customers_and_addresses", "question": "What are all the addresses in East Julianaside, Texas or in Gleasonmouth, Arizona.", "rationale": ["Identify the relevant table: The question asks for addresses, so we will use the 'Addresses' table.", "Determine the filtering criteria: We need to filter addresses based on the city and state. The cities are 'East Julianaside' and 'Gleasonmouth', and the states are 'Texas' and 'Arizona'.", "Construct the WHERE clause: We will use an OR condition to include addresses from either of the specified cities and states.", "Formulate the SQL query: We will select all columns from the 'Addresses' table where the conditions in the WHERE clause are met."], "gold_sql": "SELECT address_content FROM addresses WHERE city  =  'East Julianaside' AND state_province_county  =  'Texas' UNION SELECT address_content FROM addresses WHERE city  =  'Gleasonmouth' AND state_province_county  =  'Arizona'", "source_tables": ["addresses"], "pred_sql": "SELECT * FROM Addresses WHERE (city = 'East Julianaside' AND state_province_county = 'Texas') OR (city = 'Gleasonmouth' AND state_province_county = 'Arizona');", "hint": "\n"}
{"sample_id": "train.6271", "db_id": "city_record", "question": "What is the match id of the competition called \"1994 FIFA World Cup qualification\"?", "rationale": ["Identify the table that contains the competition information, which is the 'match' table.", "Determine the column that holds the competition name, which is 'Competition'.", "Formulate a subquery to find the Competition ID for '1994 FIFA World Cup qualification'.", "Use the result of the subquery to select the Match_ID from the 'match' table."], "gold_sql": "SELECT match_id FROM MATCH WHERE competition = '1994 FIFA World Cup qualification'", "source_tables": ["match"], "pred_sql": "SELECT Match_ID FROM match WHERE Competition = (SELECT Competition FROM match WHERE Competition = '1994 FIFA World Cup qualification');", "hint": "\n"}
{"sample_id": "train.6275", "db_id": "city_record", "question": "Find the city that hosted the most events.", "rationale": ["To find the city that hosted the most events, we need to look at the 'hosting_city' table, which contains the 'Host_City' and 'Match_ID'.", "We will count the number of matches hosted by each city using COUNT(Match_ID).", "We will group the results by 'Host_City' to aggregate the counts for each city.", "To determine which city hosted the most events, we will order the results in descending order based on the count of matches.", "Finally, we will limit the results to 1 to get the city with the highest count."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["hosting_city", "city"], "pred_sql": "SELECT Host_City, COUNT(Match_ID) AS Event_Count\nFROM hosting_city\nGROUP BY Host_City\nORDER BY Event_Count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of cities from the 'city' table that have a regional population greater than a specified number and also those that have a regional population less than another specified number. The placeholders in the WHERE clauses represent the population thresholds.\"\n}\n"}
{"sample_id": "train.6282", "db_id": "city_record", "question": "Which three cities have the largest regional population?", "rationale": ["Identify the table that contains the relevant data: the 'city' table has the 'City' and 'Regional_Population' columns.", "To find the three cities with the largest regional population, we need to select the 'City' and 'Regional_Population' columns from the 'city' table.", "We will order the results by 'Regional_Population' in descending order to get the largest populations first.", "Finally, we will limit the results to the top three entries using 'LIMIT 3'."], "gold_sql": "SELECT city FROM city ORDER BY regional_population DESC LIMIT 3", "source_tables": ["city"], "pred_sql": "SELECT City, Regional_Population FROM city ORDER BY Regional_Population DESC LIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of cities from the 'city' table that have a regional population greater than a specified number and also those that have a regional population less than another specified number. The placeholders in the WHERE clauses represent the population thresholds.\"\n}\n"}
{"sample_id": "train.6283", "db_id": "city_record", "question": "What are the three largest cities in terms of regional population?", "rationale": ["Identify the relevant table: The 'city' table contains the information about cities and their regional populations.", "Determine the required information: We need the names of the cities and their regional populations.", "Sort the results: To find the largest cities, we will sort the results by 'Regional_Population' in descending order.", "Limit the results: We only need the top three cities, so we will use 'LIMIT 3' to restrict the output to three rows."], "gold_sql": "SELECT city FROM city ORDER BY regional_population DESC LIMIT 3", "source_tables": ["city"], "pred_sql": "SELECT City, Regional_Population FROM city ORDER BY Regional_Population DESC LIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of cities from the 'city' table that have a regional population greater than a specified number and also those that have a regional population less than another specified number. The placeholders in the WHERE clauses represent the population thresholds.\"\n}\n"}
{"sample_id": "train.6286", "db_id": "city_record", "question": "Which city has the highest temperature in February?", "rationale": ["Identify the relevant tables: 'city' for city names and 'temperature' for temperature data.", "We need to find the city with the highest temperature in February, so we will focus on the 'Feb' column in the 'temperature' table.", "Join the 'city' table with the 'temperature' table on the 'City_ID' to get city names along with their February temperatures.", "Use an ORDER BY clause to sort the results by the February temperature in descending order to get the highest temperature at the top.", "Limit the results to 1 to get only the city with the highest temperature."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id ORDER BY T2.Feb DESC LIMIT 1", "source_tables": ["city", "temperature"], "pred_sql": "SELECT c.City, t.Feb \nFROM city c \nJOIN temperature t ON c.City_ID = t.City_ID \nORDER BY t.Feb DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of cities from the 'city' table that have a regional population greater than a specified number and also those that have a regional population less than another specified number. The placeholders in the WHERE clauses represent the population thresholds.\"\n}\n"}
{"sample_id": "train.6288", "db_id": "city_record", "question": "Give me a list of cities whose temperature in March is lower than that in July or higher than that in Oct?", "rationale": ["Identify the relevant tables: 'city' and 'temperature'.", "We need to join these tables on the 'City_ID' to access city names and their temperature data.", "The condition requires us to filter cities based on their temperature in March compared to July and October.", "The SQL query will select the city names from the 'city' table where the temperature in March is either lower than in July or higher than in October."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul OR T2.Mar  >  T2.Oct", "source_tables": ["city", "temperature"], "pred_sql": "SELECT c.City FROM city c JOIN temperature t ON c.City_ID = t.City_ID WHERE t.Mar < t.Jul OR t.Mar > t.Oct;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of cities from the 'city' table that have a regional population greater than a specified number and also those that have a regional population less than another specified number. The placeholders in the WHERE clauses represent the population thresholds.\"\n}\n"}
{"sample_id": "train.6290", "db_id": "city_record", "question": "Give me a list of cities whose temperature in Mar is lower than that in July and which have also served as host cities?", "rationale": ["We need to find cities with specific temperature conditions and that have hosted matches.", "First, we will select the city names from the 'city' table.", "We will join the 'temperature' table to access the temperature data for each city.", "We will also join the 'hosting_city' table to filter cities that have hosted matches.", "The condition we need to check is that the temperature in March (t.Mar) is lower than the temperature in July (t.Jul).", "Finally, we will ensure that the cities returned are those that have hosted matches by checking the 'hosting_city' table."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul INTERSECT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "pred_sql": "SELECT c.City \nFROM city c \nJOIN temperature t ON c.City_ID = t.City_ID \nJOIN hosting_city h ON c.City_ID = h.Host_City \nWHERE t.Mar < t.Jul;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of cities from the 'city' table that have a regional population greater than a specified number and also those that have a regional population less than another specified number. The placeholders in the WHERE clauses represent the population thresholds.\"\n}\n"}
{"sample_id": "train.6293", "db_id": "city_record", "question": "Which cities have lower temperature in March than in Dec and have never served as host cities?", "rationale": ["Identify the relevant tables: 'city', 'temperature', and 'hosting_city'.", "We need to compare the average temperatures in March and December, so we will join the 'city' table with the 'temperature' table on 'City_ID'.", "The condition for lower temperature in March than in December is specified as 't.Mar < t.Dec'.", "To find cities that have never served as host cities, we will use a subquery to exclude any 'Host_City' from the 'hosting_city' table.", "The final query selects the city names from the 'city' table that meet both conditions."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "pred_sql": "SELECT c.City \nFROM city c \nJOIN temperature t ON c.City_ID = t.City_ID \nWHERE t.Mar < t.Dec \nAND c.City_ID NOT IN (SELECT Host_City FROM hosting_city)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of cities from the 'city' table that have a regional population greater than a specified number and also those that have a regional population less than another specified number. The placeholders in the WHERE clauses represent the population thresholds.\"\n}\n"}
{"sample_id": "train.6295", "db_id": "city_record", "question": "Which cities have higher temperature in Feb than in Jun or have once served as host cities?", "rationale": ["Identify the relevant tables: 'city', 'temperature', and 'hosting_city'.", "We need to find cities that have a higher temperature in February than in June. This requires joining the 'city' table with the 'temperature' table on 'City_ID'.", "Additionally, we need to check if the city has ever hosted a match, which involves joining the 'city' table with the 'hosting_city' table on 'Host_City'.", "Use a LEFT JOIN for the hosting_city table to ensure we still get cities that may not have hosted any matches.", "The WHERE clause will filter for cities where the temperature in February is greater than in June or where the city has hosted a match.", "Select distinct city names to avoid duplicates in the result."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Feb  >  T2.Jun UNION SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "pred_sql": "SELECT DISTINCT c.City \nFROM city c \nJOIN temperature t ON c.City_ID = t.City_ID \nLEFT JOIN hosting_city h ON c.City_ID = h.Host_City \nWHERE (t.Feb > t.Jun) OR (h.Host_City IS NOT NULL);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of cities from the 'city' table that have a regional population greater than a specified number and also those that have a regional population less than another specified number. The placeholders in the WHERE clauses represent the population thresholds.\"\n}\n"}
{"sample_id": "train.6324", "db_id": "e_government", "question": "Find the last name of the first ever contact person of the organization with the highest UK Vat number.", "rationale": ["Identify the organization with the highest UK VAT number by using a subquery to select the maximum value from the Organizations table.", "Join the Organization_Contact_Individuals table with the Individuals table to get the contact person's last name.", "Join the Organization_Contact_Individuals table with the Organizations table to filter by the organization with the highest UK VAT number.", "Order the results by the date of contact to find the first contact person.", "Limit the results to 1 to get only the first contact person's last name."], "gold_sql": "SELECT t3.individual_last_name FROM organizations AS t1 JOIN organization_contact_individuals AS t2 ON t1.organization_id  =  t2.organization_id JOIN individuals AS t3 ON t2.individual_id  =  t3.individual_id WHERE t1.uk_vat_number  =  (SELECT max(uk_vat_number) FROM organizations) ORDER BY t2.date_contact_to ASC LIMIT 1", "source_tables": ["organizations", "organization_contact_individuals", "individuals"], "pred_sql": "SELECT i.individual_last_name\nFROM Organization_Contact_Individuals oci\nJOIN Individuals i ON oci.individual_id = i.individual_id\nJOIN Organizations org ON oci.organization_id = org.organization_id\nWHERE org.uk_vat_number = (SELECT MAX(uk_vat_number) FROM Organizations)\nORDER BY oci.date_contact_from ASC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6328", "db_id": "e_government", "question": "Find name of the services that has never been used.", "rationale": ["Identify the table that contains the service names, which is the Services table.", "We need to find services that have never been used, which means we need to check against the Party_Services table where service bookings are recorded.", "To find services that have never been used, we can select service names from the Services table where the service_id is not present in the Party_Services table.", "Construct the SQL query using a subquery to filter out the used services from the Services table."], "gold_sql": "SELECT service_name FROM services EXCEPT SELECT t1.service_name FROM services AS t1 JOIN party_services AS t2 ON t1.service_id  =  t2.service_id", "source_tables": ["services", "party_services"], "pred_sql": "SELECT service_name \nFROM Services \nWHERE service_id NOT IN (SELECT service_id FROM Party_Services);", "hint": "\n"}
{"sample_id": "train.6330", "db_id": "e_government", "question": "Find the name of all the cities and states.", "rationale": ["Identify the relevant table: The question asks for cities and states, which are found in the Addresses table.", "Select the appropriate columns: We need to select 'town_city' for cities and 'state_province_county' for states.", "Use DISTINCT to avoid duplicate entries: Since we want the names of all cities and states, we should use DISTINCT to ensure each combination is unique.", "Construct the SQL query: Combine the selected columns and the table name into a SQL SELECT statement."], "gold_sql": "SELECT town_city FROM addresses UNION SELECT state_province_county FROM addresses", "source_tables": ["addresses"], "pred_sql": "SELECT DISTINCT town_city, state_province_county FROM Addresses;", "hint": "\n"}
{"sample_id": "train.6331", "db_id": "e_government", "question": "What are the names of all cities and states?", "rationale": ["Identify the relevant table: The question asks for city and state names, which are found in the Addresses table.", "Select the appropriate columns: We need to select 'town_city' and 'state_province_county' from the Addresses table.", "Use DISTINCT to avoid duplicate entries: Since cities and states can repeat, we use DISTINCT to get unique combinations of city and state.", "Construct the SQL query: Combine the selected columns and table into a SQL SELECT statement."], "gold_sql": "SELECT town_city FROM addresses UNION SELECT state_province_county FROM addresses", "source_tables": ["addresses"], "pred_sql": "SELECT DISTINCT town_city, state_province_county FROM Addresses;", "hint": "\n"}
{"sample_id": "train.6346", "db_id": "e_government", "question": "Find the last name of the individuals that have been contact individuals of an organization.", "rationale": ["Identify the relevant tables: We need to find individuals who are contact individuals for organizations, so we will use the Organization_Contact_Individuals and Individuals tables.", "Determine the relationship: The Organization_Contact_Individuals table has a foreign key 'individual_id' that links to the 'individual_id' in the Individuals table.", "Select the required field: We need the last names of these individuals, which is found in the Individuals table under 'individual_last_name'.", "Construct the SQL query: We will use a JOIN to combine the Organization_Contact_Individuals and Individuals tables on the 'individual_id' field and select the 'individual_last_name' from the Individuals table."], "gold_sql": "SELECT DISTINCT t1.individual_last_name FROM individuals AS t1 JOIN organization_contact_individuals AS t2 ON t1.individual_id  =  t2.individual_id", "source_tables": ["organization_contact_individuals", "individuals"], "pred_sql": "SELECT Individuals.individual_last_name \nFROM Organization_Contact_Individuals \nJOIN Individuals ON Organization_Contact_Individuals.individual_id = Individuals.individual_id;", "hint": "\n"}
{"sample_id": "train.6723", "db_id": "activity_1", "question": "Show the first name, last name, and phone number for all female faculty members.", "rationale": ["Identify the relevant table: Faculty.", "Determine the columns needed: first name (Fname), last name (Lname), and phone number (Phone).", "Filter the results to include only female faculty members by using a WHERE clause that checks the Sex column for 'Female'.", "Construct the SQL SELECT statement to retrieve the specified columns from the Faculty table with the appropriate filter."], "gold_sql": "SELECT Fname ,  Lname ,  phone FROM Faculty WHERE Sex  =  'F'", "source_tables": ["faculty"], "pred_sql": "SELECT Fname, Lname, Phone FROM Faculty WHERE Sex = 'Female';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names, last names, and contact phone numbers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.\"\n}\n"}
{"sample_id": "train.6725", "db_id": "activity_1", "question": "Show ids for all the male faculty.", "rationale": ["Identify the table that contains the faculty information, which is the 'Faculty' table.", "Determine the column that stores the gender of the faculty members, which is 'Sex'.", "Filter the results to only include male faculty members by using a WHERE clause that checks if 'Sex' is equal to 'Male'.", "Select the unique identifier for each faculty member, which is 'FacID', to show the ids for all male faculty."], "gold_sql": "SELECT FacID FROM Faculty WHERE Sex  =  'M'", "source_tables": ["faculty"], "pred_sql": "SELECT FacID FROM Faculty WHERE Sex = 'Male';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the count of faculty members by gender from the 'Faculty' table, filtered by a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty members.\"\n}\n"}
{"sample_id": "train.6738", "db_id": "activity_1", "question": "Find the building that has the largest number of faculty members.", "rationale": ["Identify the table that contains information about faculty members, which is the Faculty table.", "We need to count the number of faculty members in each building, so we will use the COUNT() function.", "To get the number of faculty members per building, we will group the results by the Building column.", "To find the building with the largest number of faculty members, we will order the results in descending order based on the count of faculty members.", "Finally, we will limit the results to only the top entry to get the building with the largest number of faculty members."], "gold_sql": "SELECT building FROM Faculty GROUP BY building ORDER BY count(*) DESC LIMIT 1", "source_tables": ["faculty"], "pred_sql": "SELECT Building, COUNT(FacID) AS FacultyCount\nFROM Faculty\nGROUP BY Building\nORDER BY FacultyCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of buildings where faculty members of a specific academic rank are located. The query groups the results by building and filters to include only those buildings that have a certain number of faculty members, as indicated by the placeholders.\"\n}\n"}
{"sample_id": "train.6740", "db_id": "activity_1", "question": "In which buildings are there at least ten professors?", "rationale": ["We need to find buildings with at least ten professors.", "We will use the Faculty table, which contains information about faculty members including their building.", "We will group the results by the 'Building' column to count the number of faculty members in each building.", "We will use the HAVING clause to filter the groups to only include those with a count of faculty members greater than or equal to 10."], "gold_sql": "SELECT building FROM Faculty WHERE rank  =  'Professor' GROUP BY building HAVING count(*)  >=  10", "source_tables": ["faculty"], "pred_sql": "SELECT Building\nFROM Faculty\nGROUP BY Building\nHAVING COUNT(FacID) >= 10;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of buildings where faculty members of a specific academic rank are located. The query groups the results by building and filters to include only those buildings that have a certain number of faculty members, as indicated by the placeholders.\"\n}\n"}
{"sample_id": "train.6747", "db_id": "activity_1", "question": "Show the number of male and female assistant professors.", "rationale": ["Identify the relevant table: The 'Faculty' table contains information about faculty members, including their gender and rank.", "Determine the specific rank to filter by: The query is focused on assistant professors, so we will filter the results to include only those with the rank of 'Assistant Professor'.", "Group the results by gender: We need to count the number of faculty members for each gender, so we will use the GROUP BY clause on the 'Sex' column.", "Count the number of faculty members: We will use the COUNT() function to get the total number of faculty members for each gender after filtering by rank."], "gold_sql": "SELECT sex ,  count(*) FROM Faculty WHERE rank  =  'AsstProf' GROUP BY sex", "source_tables": ["faculty"], "pred_sql": "SELECT Sex, COUNT(*) as Count\nFROM Faculty\nWHERE Rank = 'Assistant Professor'\nGROUP BY Sex;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the count of faculty members by gender from the 'Faculty' table, filtered by a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty members.\"\n}\n"}
{"sample_id": "train.6750", "db_id": "activity_1", "question": "Who is the advisor of Linda Smith? Give me the first name and last name.", "rationale": ["Identify the tables involved: We need to find the advisor of a student named Linda Smith, which involves the Student and Faculty tables.", "Determine the relationship: The Student table has a column 'Advisor' that references the 'FacID' in the Faculty table, indicating which faculty member is the advisor for each student.", "Construct the SELECT statement: We want to retrieve the first name (Fname) and last name (Lname) of the advisor, which is in the Faculty table.", "Add the JOIN clause: We need to join the Student table with the Faculty table on the condition that the Faculty's FacID matches the Student's Advisor.", "Add the WHERE clause: We need to filter the results to only include the student named Linda Smith by checking both the first name and last name."], "gold_sql": "SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T2.fname  =  'Linda' AND T2.lname  =  'Smith'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT Fname, Lname \nFROM Faculty \nJOIN Student ON Faculty.FacID = Student.Advisor \nWHERE Student.Fname = 'Linda' AND Student.Lname = 'Smith';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of faculty members from the 'Faculty' table who hold a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.\"\n}\n"}
{"sample_id": "train.6751", "db_id": "activity_1", "question": "Show the ids of students whose advisors are professors.", "rationale": ["Identify the relevant tables: We need to find students and their advisors, so we will use the Student and Faculty tables.", "Determine the relationship: The Student table has a column 'Advisor' that references 'FacID' in the Faculty table, indicating which faculty member is the advisor for each student.", "Construct the SQL query: We will select the distinct student IDs (StuID) from the Student table where there is a matching faculty member in the Faculty table based on the advisor relationship."], "gold_sql": "SELECT T2.StuID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.rank  =  'Professor'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT DISTINCT Student.StuID \nFROM Student \nJOIN Faculty ON Student.Advisor = Faculty.FacID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of buildings where faculty members of a specific academic rank are located. The query groups the results by building and filters to include only those buildings that have a certain number of faculty members, as indicated by the placeholders.\"\n}\n"}
{"sample_id": "train.6753", "db_id": "activity_1", "question": "Show first name and last name for all the students advised by Michael Goodrich.", "rationale": ["Identify the tables needed: We need to retrieve student information, so we will use the 'Student' table. We also need to join with the 'Faculty' table to filter by advisor.", "Determine the join condition: Students are advised by faculty members, so we will join 'Student' and 'Faculty' on the 'Advisor' field in 'Student' and 'FacID' in 'Faculty'.", "Select the required fields: We need the first name and last name of the students, which are 'Fname' and 'LName' from the 'Student' table.", "Add the filtering condition: We need to filter the faculty members to only those whose first name is 'Michael' and last name is 'Goodrich'.", "Construct the SQL query: Combine all the elements into a complete SQL query."], "gold_sql": "SELECT T2.fname ,  T2.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.fname  =  'Michael' AND T1.lname  =  'Goodrich'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT S.Fname, S.LName \nFROM Student S \nJOIN Faculty F ON S.Advisor = F.FacID \nWHERE F.Fname = 'Michael' AND F.Lname = 'Goodrich';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names, last names, and contact phone numbers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.\"\n}\n"}
{"sample_id": "train.6759", "db_id": "activity_1", "question": "What are the first and last name of the faculty who has the most students?", "rationale": ["Identify the relevant tables: Faculty, Faculty_Participates_in, and Participates_in are needed to find faculty and their associated students.", "Join the Faculty table with Faculty_Participates_in on FacID to link faculty members to the activities they participate in.", "Join the result with Participates_in on actid to link those activities to the students participating in them.", "Group the results by faculty ID to count the number of students associated with each faculty member.", "Order the results by the count of students in descending order to find the faculty member with the most students.", "Limit the results to 1 to get only the faculty member with the highest count."], "gold_sql": "SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID ORDER BY count(*) DESC LIMIT 1", "source_tables": ["faculty", "student"], "pred_sql": "SELECT F.Fname, F.Lname\nFROM Faculty F\nJOIN Faculty_Participates_in FPI ON F.FacID = FPI.FacID\nJOIN Participates_in PI ON FPI.actid = PI.actid\nGROUP BY F.FacID\nORDER BY COUNT(PI.stuid) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of faculty members from the 'Faculty' table who hold a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.\"\n}\n"}
{"sample_id": "train.6765", "db_id": "activity_1", "question": "What activities do we have?", "rationale": ["Identify the table that contains the information about activities, which is the 'Activity' table.", "Determine the column that holds the name of the activities, which is 'activity_name'.", "Construct a SQL query to select the 'activity_name' from the 'Activity' table."], "gold_sql": "SELECT activity_name FROM Activity", "source_tables": ["activity"], "pred_sql": "SELECT activity_name FROM Activity;", "hint": "\n"}
{"sample_id": "train.6766", "db_id": "activity_1", "question": "List all the activities we have.", "rationale": ["Identify the table that contains the activities, which is the 'Activity' table.", "To list all activities, we need to select all columns from the 'Activity' table.", "The SQL query to achieve this is 'SELECT * FROM Activity;'"], "gold_sql": "SELECT activity_name FROM Activity", "source_tables": ["activity"], "pred_sql": "SELECT * FROM Activity;", "hint": "\n"}
{"sample_id": "train.6780", "db_id": "activity_1", "question": "What is the first and last name of the faculty members who participated in at least one activity? For each of them, also show the number of activities they participated in.", "rationale": ["Identify the relevant tables: Faculty and Faculty_Participates_in.", "We need to select the first name (Fname) and last name (Lname) of faculty members from the Faculty table.", "We also need to count the number of activities each faculty member participated in, which is represented by the actid in the Faculty_Participates_in table.", "Join the Faculty table with the Faculty_Participates_in table on the FacID to link faculty members with their activities.", "Group the results by the faculty member's ID (FacID) to aggregate the count of activities.", "Use the COUNT function to count the number of activities for each faculty member.", "Filter the results using HAVING to include only those faculty members who have participated in at least one activity."], "gold_sql": "SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID", "source_tables": ["faculty", "faculty_participates_in"], "pred_sql": "SELECT F.Fname, F.Lname, COUNT(FPI.actid) AS activity_count\nFROM Faculty F\nJOIN Faculty_Participates_in FPI ON F.FacID = FPI.FacID\nGROUP BY F.FacID\nHAVING COUNT(FPI.actid) > 0;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of faculty members from the 'Faculty' table who hold a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.\"\n}\n"}
{"sample_id": "train.6781", "db_id": "activity_1", "question": "Show all the activity names and the number of faculty involved in each activity.", "rationale": ["We need to show all activity names and the number of faculty involved in each activity.", "To achieve this, we will select the 'activity_name' from the 'Activity' table.", "We also need to count the number of faculty members involved in each activity, which can be done using the COUNT function on 'FacID' from the 'Faculty_Participates_in' table.", "To link the activities with the faculty members, we will perform a LEFT JOIN between the 'Activity' table and the 'Faculty_Participates_in' table on the 'actid' column.", "Finally, we will group the results by 'activity_name' to get the count of faculty members for each activity."], "gold_sql": "SELECT T1.activity_name ,  count(*) FROM Activity AS T1 JOIN Faculty_participates_in AS T2 ON T1.actID  =  T2.actID GROUP BY T1.actID", "source_tables": ["activity", "faculty_participates_in"], "pred_sql": "SELECT Activity.activity_name, COUNT(Faculty_Participates_in.FacID) AS faculty_count\nFROM Activity\nLEFT JOIN Faculty_Participates_in ON Activity.actid = Faculty_Participates_in.actid\nGROUP BY Activity.activity_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the count of faculty members by gender from the 'Faculty' table, filtered by a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty members.\"\n}\n"}
{"sample_id": "train.6782", "db_id": "activity_1", "question": "How many faculty members participate in each activity? Return the activity names and the number of faculty members.", "rationale": ["Identify the tables needed: Activity and Faculty_Participates_in.", "We need to count the number of faculty members participating in each activity, so we will use COUNT() function on the FacID from Faculty_Participates_in.", "Join the Activity table with Faculty_Participates_in on the actid column to link activities with their participating faculty members.", "Use GROUP BY clause to group the results by activity name to get the count of faculty members for each activity.", "Select the activity name and the count of faculty members as the final output."], "gold_sql": "SELECT T1.activity_name ,  count(*) FROM Activity AS T1 JOIN Faculty_participates_in AS T2 ON T1.actID  =  T2.actID GROUP BY T1.actID", "source_tables": ["activity", "faculty_participates_in"], "pred_sql": "SELECT Activity.activity_name, COUNT(Faculty_Participates_in.FacID) AS faculty_count\nFROM Activity\nLEFT JOIN Faculty_Participates_in ON Activity.actid = Faculty_Participates_in.actid\nGROUP BY Activity.activity_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the count of faculty members by gender from the 'Faculty' table, filtered by a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty members.\"\n}\n"}
{"sample_id": "train.6789", "db_id": "activity_1", "question": "Show the ids for all the students who participate in an activity and are under 20.", "rationale": ["Identify the relevant tables: We need to look at the 'Participates_in' table to find students participating in activities and the 'Student' table to filter by age.", "Determine the condition: We want students who are under 20 years old.", "Construct a subquery: Create a subquery to select 'StuID' from the 'Student' table where 'Age' is less than 20.", "Use the subquery in the main query: In the main query, select 'stuid' from 'Participates_in' where 'stuid' is in the results of the subquery."], "gold_sql": "SELECT StuID FROM Participates_in INTERSECT SELECT StuID FROM Student WHERE age  <  20", "source_tables": ["student", "participates_in"], "pred_sql": "SELECT stuid FROM Participates_in WHERE stuid IN (SELECT StuID FROM Student WHERE Age < 20);", "hint": "\n"}
{"sample_id": "train.6795", "db_id": "activity_1", "question": "Find the first names of the faculty members who are playing Canoeing or Kayaking.", "rationale": ["Identify the tables involved: Faculty, Faculty_Participates_in, and Activity.", "We need to retrieve the first names of faculty members, so we will select the 'Fname' column from the Faculty table.", "To find faculty members participating in Canoeing or Kayaking, we need to join the Faculty table with the Faculty_Participates_in table on the FacID column.", "Next, we join the Faculty_Participates_in table with the Activity table on the actid column to access the activity names.", "Finally, we filter the results to include only those activities that are either 'Canoeing' or 'Kayaking' using the WHERE clause with the IN operator."], "gold_sql": "SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT Faculty.Fname \nFROM Faculty \nJOIN Faculty_Participates_in ON Faculty.FacID = Faculty_Participates_in.FacID \nJOIN Activity ON Faculty_Participates_in.actid = Activity.actid \nWHERE Activity.activity_name IN ('Canoeing', 'Kayaking');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of faculty members from the 'Faculty' table who hold a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.\"\n}\n"}
{"sample_id": "train.6796", "db_id": "activity_1", "question": "Which faculty members are playing either Canoeing or Kayaking? Tell me their first names.", "rationale": ["Identify the relevant tables: Faculty, Faculty_Participates_in, and Activity.", "We need to find faculty members who participate in specific activities, namely Canoeing or Kayaking.", "Join the Faculty table with the Faculty_Participates_in table on the FacID to get the activities they participate in.", "Join the resulting table with the Activity table on actid to filter by activity names.", "Use a WHERE clause to specify that we are only interested in activities named 'Canoeing' or 'Kayaking'.", "Select the first names of the faculty members from the Faculty table."], "gold_sql": "SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT Faculty.Fname \nFROM Faculty \nJOIN Faculty_Participates_in ON Faculty.FacID = Faculty_Participates_in.FacID \nJOIN Activity ON Faculty_Participates_in.actid = Activity.actid \nWHERE Activity.activity_name IN ('Canoeing', 'Kayaking');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of faculty members from the 'Faculty' table who hold a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.\"\n}\n"}
{"sample_id": "train.6798", "db_id": "activity_1", "question": "What are the first names of the professors who do not play Canoeing or Kayaking as activities?", "rationale": ["Identify the relevant tables: Faculty and Faculty_Participates_in.", "We need to find faculty members who do not participate in specific activities (Canoeing and Kayaking).", "Use a subquery to find the FacIDs of faculty members who participate in Canoeing or Kayaking.", "The subquery will join Faculty_Participates_in with Activity to filter by activity names.", "The main query will select the first names of faculty members whose FacID is not in the result of the subquery."], "gold_sql": "SELECT lname FROM faculty WHERE rank  =  'Professor' EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT F.Fname \nFROM Faculty F \nWHERE F.FacID NOT IN (\n    SELECT FP.FacID \n    FROM Faculty_Participates_in FP \n    JOIN Activity A ON FP.actid = A.actid \n    WHERE A.activity_name IN ('Canoeing', 'Kayaking')\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of faculty members from the 'Faculty' table who hold a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.\"\n}\n"}
{"sample_id": "train.6801", "db_id": "activity_1", "question": "Find the ids of the students who participate in Canoeing and Kayaking.", "rationale": ["Identify the tables involved: We need to find student IDs from the Participates_in table and the activity names from the Activity table.", "Determine the relationship: The Participates_in table has a foreign key actid that links to the Activity table's actid.", "Filter the activities: We are specifically looking for students who participate in 'Canoeing' and 'Kayaking'.", "Construct the SQL query: Use a SELECT statement to get the student IDs, join the Participates_in table with the Activity table on actid, and filter the results based on the activity names."], "gold_sql": "SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  'Canoeing' INTERSECT SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  'Kayaking'", "source_tables": ["activity", "participates_in"], "pred_sql": "SELECT p.stuid \nFROM Participates_in p \nJOIN Activity a ON p.actid = a.actid \nWHERE a.activity_name IN ('Canoeing', 'Kayaking');", "hint": "\n"}
{"sample_id": "dev.95", "db_id": "car_1", "question": "Which model of the car has the minimum horsepower?", "rationale": ["Identify the relevant table: The question asks for car models and their horsepower, so we will focus on the 'cars_data' table.", "Select the columns needed: We need to select the 'Model' and 'Horsepower' columns from the 'cars_data' table.", "Order the results: To find the model with the minimum horsepower, we will order the results by 'Horsepower' in ascending order.", "Limit the results: Since we only want the model with the minimum horsepower, we will limit the results to 1."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT Model, Horsepower FROM cars_data ORDER BY Horsepower ASC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of cars from the 'cars_data' table that have an acceleration time greater than the acceleration time of the top specified number of cars sorted by horsepower. The placeholder in the subquery represents the number of top cars to consider for the comparison.\"\n}\n"}
{"sample_id": "dev.97", "db_id": "car_1", "question": "Find the model of the car whose weight is below the average weight.", "rationale": ["Identify the requirement: We need to find the model of the car whose weight is below the average weight.", "To find the average weight, we can use the AVG() function on the Weight column from the cars_data table.", "We need to select the Model from the car_names table, which is linked to the cars_data table through the MakeId.", "We will use a subquery to filter the car models based on the condition that their weight is less than the average weight calculated in the previous step."], "gold_sql": "SELECT T1.model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Weight  <  (SELECT avg(Weight) FROM CARS_DATA)", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT Model FROM car_names WHERE MakeId IN (SELECT Id FROM cars_data WHERE Weight < (SELECT AVG(Weight) FROM cars_data));", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of cars from the 'cars_data' table that have an acceleration time greater than the acceleration time of the top specified number of cars sorted by horsepower. The placeholder in the subquery represents the number of top cars to consider for the comparison.\"\n}\n"}
{"sample_id": "dev.111", "db_id": "car_1", "question": "What is the accelerate of the car make amc hornet sportabout (sw)?", "rationale": ["Identify the relevant tables: We need to find the 'accelerate' value for a specific car make, which involves the 'cars_data', 'car_names', 'model_list', 'car_makers', and 'countries' tables.", "Determine the relationships: 'cars_data' is linked to 'car_names' through 'MakeId', 'car_names' is linked to 'model_list' through 'Model', 'model_list' is linked to 'car_makers' through 'Maker', and 'car_makers' is linked to 'countries' through 'Country'.", "Filter the results: We need to filter the results to only include the car make 'amc hornet sportabout (sw)'.", "Construct the SQL query: Using the identified tables and relationships, construct the SQL query to select the 'Accelerate' column from 'cars_data' where the make matches the specified car make."], "gold_sql": "SELECT T1.Accelerate FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Make  =  'amc hornet sportabout (sw)';", "source_tables": ["cars_data", "car_names"], "pred_sql": "SELECT cars_data.Accelerate \nFROM cars_data \nJOIN car_names ON cars_data.Id = car_names.MakeId \nJOIN model_list ON car_names.Model = model_list.Model \nJOIN car_makers ON model_list.Maker = car_makers.Id \nJOIN countries ON car_makers.Country = countries.CountryId \nWHERE car_names.Make = 'amc hornet sportabout (sw)';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of cars from the 'cars_data' table that have an acceleration time greater than the acceleration time of the top specified number of cars sorted by horsepower. The placeholder in the subquery represents the number of top cars to consider for the comparison.\"\n}\n"}
{"sample_id": "dev.112", "db_id": "car_1", "question": "How much does the car accelerate that makes amc hornet sportabout (sw)?", "rationale": ["Identify the car model and maker from the car_names table using the provided model name 'hornet sportabout' and maker 'amc'.", "Use the MakeId from the car_names table to find the corresponding entry in the cars_data table.", "Select the 'Accelerate' column from the cars_data table for the identified car."], "gold_sql": "SELECT T1.Accelerate FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Make  =  'amc hornet sportabout (sw)';", "source_tables": ["cars_data", "car_names"], "pred_sql": "SELECT Accelerate FROM cars_data WHERE Id = (SELECT MakeId FROM car_names WHERE Model = 'hornet sportabout' AND Make = 'amc')", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of cars from the 'cars_data' table that have an acceleration time greater than the acceleration time of the top specified number of cars sorted by horsepower. The placeholder in the subquery represents the number of top cars to consider for the comparison.\"\n}\n"}
{"sample_id": "dev.113", "db_id": "car_1", "question": "How many car makers are there in france?", "rationale": ["Identify the relevant tables: car_makers and countries.", "We need to count the number of car makers based in France.", "Join the car_makers table with the countries table on the Country identifier.", "Filter the results to include only those car makers where the country name is 'France'.", "Use the COUNT function to get the total number of car makers in France."], "gold_sql": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  'france';", "source_tables": ["car_makers", "countries"], "pred_sql": "SELECT COUNT(*) AS NumberOfCarMakers\nFROM car_makers\nJOIN countries ON car_makers.Country = countries.CountryId\nWHERE countries.CountryName = 'France';", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the relationship between car makers and their respective car models from the 'model_list' table. The placeholders represent the identifiers for the car makers and models.\"\n}\n"}
{"sample_id": "dev.121", "db_id": "car_1", "question": "What are all the makers and models?", "rationale": ["Identify the tables needed: car_makers and model_list.", "We need to retrieve the Maker from car_makers and the Model from model_list.", "Establish the relationship between the two tables using the foreign key: car_makers.Id corresponds to model_list.Maker.", "Construct the SQL SELECT statement to get the desired columns from the joined tables."], "gold_sql": "SELECT Maker ,  Model FROM MODEL_LIST;", "source_tables": ["model_list"], "pred_sql": "SELECT car_makers.Maker, model_list.Model \nFROM car_makers \nJOIN model_list ON car_makers.Id = model_list.Maker;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the relationship between car makers and their respective car models from the 'model_list' table. The placeholders represent the identifiers for the car makers and models.\"\n}\n"}
{"sample_id": "dev.129", "db_id": "car_1", "question": "Which countries in europe have at least 3 car manufacturers?", "rationale": ["Identify the relevant tables: countries, car_makers, and continents.", "We need to filter countries that are in Europe, so we will join the countries table with the continents table to get the ContId for Europe.", "Next, we will join the car_makers table to the countries table to find out how many car manufacturers are in each country.", "We will group the results by country name to count the number of car manufacturers per country.", "Finally, we will use the HAVING clause to filter countries that have at least 3 car manufacturers."], "gold_sql": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  'europe' GROUP BY T1.CountryName HAVING count(*)  >=  3;", "source_tables": ["continents", "car_makers", "countries"], "pred_sql": "SELECT c.CountryName\nFROM countries c\nJOIN car_makers cm ON c.CountryId = cm.Country\nWHERE c.Continent = (SELECT ContId FROM continents WHERE Continent = 'Europe')\nGROUP BY c.CountryName\nHAVING COUNT(cm.Id) >= 3;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the relationship between car makers and their respective car models from the 'model_list' table. The placeholders represent the identifiers for the car makers and models.\"\n}\n"}
{"sample_id": "dev.130", "db_id": "car_1", "question": "What are the names of all European countries with at least 3 manufacturers?", "rationale": ["Identify the relevant tables: countries and car_makers.", "We need to find countries in Europe, so we will filter the countries table based on the continent.", "Join the countries table with the car_makers table on the country identifier.", "Group the results by country name to count the number of manufacturers per country.", "Use the HAVING clause to filter countries that have at least 3 manufacturers."], "gold_sql": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  'europe' GROUP BY T1.CountryName HAVING count(*)  >=  3;", "source_tables": ["continents", "car_makers", "countries"], "pred_sql": "SELECT c.CountryName \nFROM countries c \nJOIN car_makers cm ON c.CountryId = cm.Country \nWHERE c.Continent = (SELECT ContId FROM continents WHERE Continent = 'Europe') \nGROUP BY c.CountryName \nHAVING COUNT(cm.Id) >= 3;", "hint": "\n"}
{"sample_id": "dev.131", "db_id": "car_1", "question": "What is the maximum horsepower and the make of the car models with 3 cylinders?", "rationale": ["Identify the relevant tables: 'cars_data' for horsepower and cylinders, and 'car_names' for the make of the car.", "We need to find the maximum horsepower, so we will use the MAX() function on the 'Horsepower' column from the 'cars_data' table.", "We need to filter the results to only include cars with 3 cylinders, which will be done using a WHERE clause.", "To get the make of the car, we will join the 'cars_data' table with the 'car_names' table on the appropriate foreign key relationship.", "Finally, we will select the maximum horsepower and the make of the car models that meet the criteria."], "gold_sql": "SELECT T2.horsepower ,  T1.Make FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.cylinders  =  3 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT MAX(cars_data.Horsepower) AS MaxHorsepower, car_names.Make \nFROM cars_data \nJOIN car_names ON cars_data.Id = car_names.MakeId \nWHERE cars_data.Cylinders = 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of cars from the 'cars_data' table that have an acceleration time greater than the acceleration time of the top specified number of cars sorted by horsepower. The placeholder in the subquery represents the number of top cars to consider for the comparison.\"\n}\n"}
{"sample_id": "dev.141", "db_id": "car_1", "question": "Which model has the most version(make) of cars?", "rationale": ["Identify the relevant tables: We need to find the model with the most versions (makes) of cars, which involves the 'model_list' and 'car_names' tables.", "Join the tables: We will join 'model_list' (aliased as ml) with 'car_names' (aliased as cn) on the model name to link car models with their respective makes.", "Count the makes: We will count the number of distinct makes for each model using COUNT(cn.Make).", "Group by model: We will group the results by model to aggregate the counts for each model.", "Order the results: We will order the results in descending order based on the count of makes to find the model with the most versions.", "Limit the results: Finally, we will limit the results to 1 to get the model with the highest count."], "gold_sql": "SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["car_names"], "pred_sql": "SELECT ml.Model, COUNT(cn.Make) AS VersionCount\nFROM model_list ml\nJOIN car_names cn ON ml.Model = cn.Model\nGROUP BY ml.Model\nORDER BY VersionCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the relationship between car makers and their respective car models from the 'model_list' table. The placeholders represent the identifiers for the car makers and models.\"\n}\n"}
{"sample_id": "dev.142", "db_id": "car_1", "question": "What model has the most different versions?", "rationale": ["Identify the table that contains car models, which is 'model_list'.", "We need to count the number of different versions for each model, so we will use the COUNT() function.", "Group the results by the 'Model' column to aggregate the counts for each model.", "Order the results in descending order based on the count of versions to find the model with the most versions.", "Limit the results to 1 to get only the model with the highest count."], "gold_sql": "SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["car_names"], "pred_sql": "SELECT Model, COUNT(*) as VersionCount\nFROM model_list\nGROUP BY Model\nORDER BY VersionCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the relationship between car makers and their respective car models from the 'model_list' table. The placeholders represent the identifiers for the car makers and models.\"\n}\n"}
{"sample_id": "dev.150", "db_id": "car_1", "question": "What are the names and ids of all makers with more than 3 models?", "rationale": ["Identify the relevant tables: car_makers and model_list.", "We need to find car makers with more than 3 models, so we will join car_makers with model_list on the Maker ID.", "We will group the results by the car maker's ID and name to aggregate the models associated with each maker.", "Using the HAVING clause, we will filter the groups to include only those with a count of models greater than 3."], "gold_sql": "SELECT T1.FullName ,  T1.Id FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >  3;", "source_tables": ["car_makers", "model_list"], "pred_sql": "SELECT cm.Id, cm.Maker \nFROM car_makers cm \nJOIN model_list ml ON cm.Id = ml.Maker \nGROUP BY cm.Id, cm.Maker \nHAVING COUNT(ml.ModelId) > 3;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the relationship between car makers and their respective car models from the 'model_list' table. The placeholders represent the identifiers for the car makers and models.\"\n}\n"}
{"sample_id": "dev.161", "db_id": "car_1", "question": "How many countries has more than 2 car makers ?", "rationale": ["Identify the countries that have car makers by joining the 'countries' table with the 'car_makers' table on the country identifier.", "Group the results by country to count the number of car makers in each country.", "Use the HAVING clause to filter the groups to only include those with more than 2 car makers.", "Count the distinct countries that meet the criteria."], "gold_sql": "select count(*) from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  2", "source_tables": ["car_makers", "countries"], "pred_sql": "SELECT COUNT(DISTINCT c.CountryId) AS CountryCount\nFROM countries c\nJOIN car_makers cm ON c.CountryId = cm.Country\nGROUP BY c.CountryId\nHAVING COUNT(cm.Id) > 2;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the relationship between car makers and their respective car models from the 'model_list' table. The placeholders represent the identifiers for the car makers and models.\"\n}\n"}
{"sample_id": "dev.165", "db_id": "car_1", "question": "For the cars with 4 cylinders, which model has the largest horsepower?", "rationale": ["Identify the relevant table: 'cars_data' contains the information about cars including horsepower and number of cylinders.", "Filter the records to include only those cars that have 4 cylinders by using a WHERE clause: 'Cylinders = 4'.", "To find the model with the largest horsepower, sort the results in descending order based on the 'Horsepower' column.", "Limit the results to only the top record using 'LIMIT 1' to get the model with the highest horsepower."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  4 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT Model, Horsepower FROM cars_data WHERE Cylinders = 4 ORDER BY Horsepower DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of cars from the 'cars_data' table that have an acceleration time greater than the acceleration time of the top specified number of cars sorted by horsepower. The placeholder in the subquery represents the number of top cars to consider for the comparison.\"\n}\n"}
{"sample_id": "dev.171", "db_id": "car_1", "question": "Which models are lighter than 3500 but not built by the 'Ford Motor Company'?", "rationale": ["Identify the relevant tables: car_names, model_list, car_makers, and cars_data.", "We need to select the car models that meet the weight condition and exclude those made by 'Ford Motor Company'.", "Join the car_names table with model_list to get the car maker's ID for each model.", "Join the model_list with car_makers to filter out the models made by 'Ford Motor Company'.", "Join the cars_data table to access the weight of each car model.", "Use a WHERE clause to filter for models lighter than 3500 and not made by 'Ford Motor Company'.", "Select the Model from the car_names table that meets these criteria."], "gold_sql": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.Model  =  T2.Model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.Id JOIN CAR_MAKERS AS T4 ON T1.Maker  =  T4.Id WHERE T3.weight  <  3500 AND T4.FullName != 'Ford Motor Company';", "source_tables": ["car_makers", "model_list", "car_names", "cars_data"], "pred_sql": "SELECT car_names.Model \nFROM car_names \nJOIN model_list ON car_names.Model = model_list.Model \nJOIN car_makers ON model_list.Maker = car_makers.Id \nJOIN cars_data ON car_names.MakeId = cars_data.Id \nWHERE cars_data.Weight < 3500 \nAND car_makers.FullName != 'Ford Motor Company';", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the relationship between car makers and their respective car models from the 'model_list' table. The placeholders represent the identifiers for the car makers and models.\"\n}\n"}
{"sample_id": "dev.175", "db_id": "car_1", "question": "Which are the car makers which produce at least 2 models and more than 3 car makers ? List the id and the maker .", "rationale": ["Identify the relevant tables: car_makers and model_list.", "We need to find car makers that produce at least 2 models, so we will join car_makers with model_list on the Maker ID.", "Group the results by car maker ID and name to aggregate the models produced by each maker.", "Use the HAVING clause to filter groups that have 2 or more models.", "Additionally, we need to ensure that there are more than 3 distinct car makers in total, which can be checked using a subquery."], "gold_sql": "select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker group by t1.id having count(*)  >=  2 intersect select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker join car_names as t3 on t2.model  =  t3.model group by t1.id having count(*)  >  3;", "source_tables": ["car_makers", "car_names", "model_list"], "pred_sql": "SELECT cm.Id, cm.Maker\nFROM car_makers cm\nJOIN model_list ml ON cm.Id = ml.Maker\nGROUP BY cm.Id, cm.Maker\nHAVING COUNT(ml.ModelId) >= 2\nAND (SELECT COUNT(DISTINCT Id) FROM car_makers) > 3;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the relationship between car makers and their respective car models from the 'model_list' table. The placeholders represent the identifiers for the car makers and models.\"\n}\n"}
{"sample_id": "dev.176", "db_id": "car_1", "question": "What are the ids and makers of all car makers that produce at least 2 models and make more than 3 cars?", "rationale": ["Identify the relevant tables: car_makers, model_list, car_names, and cars_data.", "We need to find car makers that produce at least 2 models, so we will join car_makers with model_list on the Maker ID.", "Next, we will join model_list with car_names to link models to their respective makes.", "Then, we will join car_names with cars_data to count the number of cars produced by each maker.", "We will group the results by car maker ID and name to aggregate the counts.", "Use the HAVING clause to filter for makers that have at least 2 distinct models and more than 3 cars."], "gold_sql": "SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >=  2 INTERSECT SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker JOIN CAR_NAMES AS T3 ON T2.model  =  T3.model GROUP BY T1.Id HAVING count(*)  >  3;", "source_tables": ["car_makers", "car_names", "model_list"], "pred_sql": "SELECT cm.Id, cm.Maker\nFROM car_makers cm\nJOIN model_list ml ON cm.Id = ml.Maker\nJOIN car_names cn ON ml.Model = cn.Model\nJOIN cars_data cd ON cn.MakeId = cd.Id\nGROUP BY cm.Id, cm.Maker\nHAVING COUNT(DISTINCT ml.Model) >= 2 AND COUNT(cd.Id) > 3;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the relationship between car makers and their respective car models from the 'model_list' table. The placeholders represent the identifiers for the car makers and models.\"\n}\n"}
{"sample_id": "dev.526", "db_id": "student_transcripts_tracking", "question": "What are the names and ids of every course with less than 2 sections?", "rationale": ["Identify the relevant tables: Courses and Sections.", "We need to find courses with less than 2 sections, so we will join the Courses table with the Sections table on the course_id.", "Use a LEFT JOIN to ensure we include courses that may not have any sections.", "Group the results by course_id and course_name to aggregate the section counts for each course.", "Use the HAVING clause to filter the grouped results to only include courses with a count of sections less than 2."], "gold_sql": "SELECT T1.course_name ,  T1.course_id FROM Courses AS T1 JOIN Sections AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_id HAVING count(*)  <=  2", "source_tables": ["courses", "sections"], "pred_sql": "SELECT c.course_id, c.course_name \nFROM Courses c \nLEFT JOIN Sections s ON c.course_id = s.course_id \nGROUP BY c.course_id, c.course_name \nHAVING COUNT(s.section_id) < 2;", "hint": "\n"}
{"sample_id": "dev.534", "db_id": "student_transcripts_tracking", "question": "What are the first, middle, and last names, along with the ids, of all students who enrolled in 2 degree programs in one semester?", "rationale": ["Identify the relevant tables: Students and Student_Enrolment.", "We need to find students who are enrolled in two different degree programs in the same semester.", "Join the Students table with the Student_Enrolment table to link students with their enrolments.", "To find students enrolled in two degree programs in the same semester, we can join the Student_Enrolment table with itself (self-join) on the student_id and semester_id.", "Use a WHERE clause to ensure that the degree_program_id from both enrolments are different.", "Group the results by student_id to aggregate the enrolments for each student.", "Use HAVING to filter the groups to only those with exactly 2 distinct degree_program_ids."], "gold_sql": "SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  2", "source_tables": ["student_enrolment", "students"], "pred_sql": "SELECT s.student_id, s.first_name, s.middle_name, s.last_name\nFROM Students s\nJOIN Student_Enrolment se ON s.student_id = se.student_id\nJOIN Student_Enrolment se2 ON s.student_id = se2.student_id AND se.semester_id = se2.semester_id\nWHERE se.degree_program_id != se2.degree_program_id\nGROUP BY s.student_id\nHAVING COUNT(DISTINCT se.degree_program_id) = 2;", "hint": "\n"}
{"sample_id": "dev.535", "db_id": "student_transcripts_tracking", "question": "Who is enrolled in a Bachelor degree program? List the first name, middle name, last name.", "rationale": ["Identify the relevant tables: Students, Student_Enrolment, and Degree_Programs.", "We need to join these tables to connect students with their enrolment records and the degree programs they are enrolled in.", "The Students table contains the first name, middle name, and last name of the students.", "The Degree_Programs table contains the degree program information, specifically the name of the program.", "We are looking for students enrolled in a Bachelor degree program, so we will filter the results based on the degree_summary_name containing 'Bachelor'.", "Construct the SQL query using SELECT to retrieve the required fields and JOIN to connect the tables appropriately."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  'Bachelor'", "source_tables": ["student_enrolment", "degree_programs", "students"], "pred_sql": "SELECT s.first_name, s.middle_name, s.last_name\nFROM Students s\nJOIN Student_Enrolment se ON s.student_id = se.student_id\nJOIN Degree_Programs dp ON se.degree_program_id = dp.degree_program_id\nWHERE dp.degree_summary_name LIKE '%Bachelor%';", "hint": "\n"}
{"sample_id": "dev.539", "db_id": "student_transcripts_tracking", "question": "Find the program which most number of students are enrolled in. List both the id and the summary.", "rationale": ["Identify the relevant tables: Degree_Programs and Student_Enrolment are needed to find the degree programs and their enrollments.", "Join the Degree_Programs table with the Student_Enrolment table on the degree_program_id to associate each program with its enrolled students.", "Group the results by degree_program_id to count the number of students enrolled in each program.", "Order the results by the count of students in descending order to find the program with the most enrollments.", "Limit the results to 1 to get only the program with the highest number of students."], "gold_sql": "SELECT T1.degree_program_id ,  T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_program_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "degree_programs"], "pred_sql": "SELECT dp.degree_program_id, dp.degree_summary_name\nFROM Degree_Programs dp\nJOIN Student_Enrolment se ON dp.degree_program_id = se.degree_program_id\nGROUP BY dp.degree_program_id\nORDER BY COUNT(se.student_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of how many times each student course appears in the 'Transcript_Contents' table, grouped by the course identifier. The results are ordered by the count in descending order, allowing users to see the most frequently recorded courses. The placeholder in the LIMIT clause represents the maximum number of results to return.\"\n}\n"}
{"sample_id": "dev.541", "db_id": "student_transcripts_tracking", "question": "Which student has enrolled for the most times in any program? List the id, first name, middle name, last name, the number of enrollments and student id.", "rationale": ["Identify the relevant tables: Students and Student_Enrolment.", "We need to count the number of enrollments for each student, so we will join the Students table with the Student_Enrolment table on the student_id.", "Use COUNT() function to count the number of enrollments for each student.", "Group the results by student_id to aggregate the counts for each student.", "Order the results by the count of enrollments in descending order to find the student with the most enrollments.", "Limit the results to 1 to get only the student with the highest number of enrollments."], "gold_sql": "SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "students"], "pred_sql": "SELECT s.student_id, s.first_name, s.middle_name, s.last_name, COUNT(se.student_enrolment_id) AS number_of_enrollments\nFROM Students s\nJOIN Student_Enrolment se ON s.student_id = se.student_id\nGROUP BY s.student_id\nORDER BY number_of_enrollments DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "dev.547", "db_id": "student_transcripts_tracking", "question": "What's the name of the course with most number of enrollments?", "rationale": ["To find the course with the most enrollments, we need to count how many times each course appears in the 'Transcript_Contents' table.", "We will join the 'Courses' table with the 'Student_Enrolment_Courses' table to link courses to student enrollments.", "Next, we will join the 'Transcript_Contents' table to count the occurrences of each course in the transcripts.", "We will group the results by course identifier to get the count of enrollments for each course.", "Finally, we will order the results by the count in descending order and limit the output to 1 to get the course with the most enrollments."], "gold_sql": "SELECT  T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["courses", "student_enrolment_courses"], "pred_sql": "SELECT Courses.course_name\nFROM Courses\nJOIN Student_Enrolment_Courses ON Courses.course_id = Student_Enrolment_Courses.course_id\nJOIN Transcript_Contents ON Student_Enrolment_Courses.student_course_id = Transcript_Contents.student_course_id\nGROUP BY Courses.course_id\nORDER BY COUNT(Transcript_Contents.student_course_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of how many times each student course appears in the 'Transcript_Contents' table, grouped by the course identifier. The results are ordered by the count in descending order, allowing users to see the most frequently recorded courses. The placeholder in the LIMIT clause represents the maximum number of results to return.\"\n}\n"}
{"sample_id": "dev.548", "db_id": "student_transcripts_tracking", "question": "What is the name of the course with the most students enrolled?", "rationale": ["Identify the relevant tables: Courses, Student_Enrolment_Courses, and Transcript_Contents are needed to find the course with the most students enrolled.", "Join the Courses table with the Student_Enrolment_Courses table on course_id to link courses with their enrolments.", "Join the resulting table with the Transcript_Contents table on student_course_id to count how many times each course appears in the transcripts.", "Group the results by course_id to aggregate the counts of students enrolled in each course.", "Order the results by the count of students in descending order to get the course with the most students at the top.", "Limit the results to 1 to get only the course with the highest enrollment."], "gold_sql": "SELECT  T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["courses", "student_enrolment_courses"], "pred_sql": "SELECT Courses.course_name\nFROM Courses\nJOIN Student_Enrolment_Courses ON Courses.course_id = Student_Enrolment_Courses.course_id\nJOIN Transcript_Contents ON Student_Enrolment_Courses.student_course_id = Transcript_Contents.student_course_id\nGROUP BY Courses.course_id\nORDER BY COUNT(Transcript_Contents.student_course_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of how many times each student course appears in the 'Transcript_Contents' table, grouped by the course identifier. The results are ordered by the count in descending order, allowing users to see the most frequently recorded courses. The placeholder in the LIMIT clause represents the maximum number of results to return.\"\n}\n"}
{"sample_id": "dev.550", "db_id": "student_transcripts_tracking", "question": "What are the last name of the students who live in North Carolina but have not registered in any degree programs?", "rationale": ["Identify the relevant table: Students, which contains the last names of students and their address IDs.", "Identify the Addresses table to filter students based on their state of residence (North Carolina).", "Use a subquery to find all address IDs in North Carolina from the Addresses table.", "Use another subquery to find all student IDs that are enrolled in any degree programs from the Student_Enrolment table.", "Combine these conditions to select last names of students who live in North Carolina and are not in the list of enrolled students."], "gold_sql": "SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  'NorthCarolina' EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id", "source_tables": ["addresses", "student_enrolment", "students"], "pred_sql": "SELECT last_name \nFROM Students \nWHERE current_address_id IN (\n    SELECT address_id \n    FROM Addresses \n    WHERE state_province_county = 'North Carolina'\n) \nAND student_id NOT IN (\n    SELECT student_id \n    FROM Student_Enrolment\n);", "hint": "\n"}
{"sample_id": "dev.554", "db_id": "student_transcripts_tracking", "question": "What is the mobile phone number of the student named Timmothy Ward ?", "rationale": ["Identify the relevant table: The question asks for the mobile phone number of a student, which is found in the Students table.", "Determine the columns needed: We need the 'cell_mobile_number' column from the Students table.", "Filter the results: We need to filter the results to find the student with the first name 'Timmothy' and the last name 'Ward'.", "Construct the SQL query: Combine the SELECT statement with the WHERE clause to filter by the student's name."], "gold_sql": "select cell_mobile_number from students where first_name  =  'timmothy' and last_name  =  'ward'", "source_tables": ["students"], "pred_sql": "SELECT cell_mobile_number FROM Students WHERE first_name = 'Timmothy' AND last_name = 'Ward';", "hint": "\n"}
{"sample_id": "dev.561", "db_id": "student_transcripts_tracking", "question": "Which address holds the most number of students currently? List the address id and all lines.", "rationale": ["We need to find the address that holds the most number of students currently.", "The relevant tables are 'Addresses' and 'Students'.", "We will join the 'Addresses' table with the 'Students' table on the current address ID.", "We will group the results by address ID and the address lines to count the number of students at each address.", "We will order the results by the count of students in descending order to find the address with the most students.", "Finally, we will limit the results to 1 to get only the address with the highest count."], "gold_sql": "SELECT T1.address_id ,  T1.line_1 ,  T1.line_2 FROM Addresses AS T1 JOIN Students AS T2 ON T1.address_id  =  T2.current_address_id GROUP BY T1.address_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "students"], "pred_sql": "SELECT a.address_id, a.line_1, a.line_2, a.line_3 \nFROM Addresses a \nJOIN Students s ON a.address_id = s.current_address_id \nGROUP BY a.address_id, a.line_1, a.line_2, a.line_3 \nORDER BY COUNT(s.student_id) DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "dev.578", "db_id": "student_transcripts_tracking", "question": "What are the different addresses that have students living there?", "rationale": ["Identify the relevant tables: We need to look at the Addresses table to get the address details and the Students table to find out which students live at those addresses.", "Determine the relationship: Students have a current address which is linked to the Addresses table through the current_address_id.", "Construct the SQL query: We will select distinct addresses from the Addresses table that have corresponding entries in the Students table based on the current_address_id."], "gold_sql": "SELECT count(DISTINCT current_address_id) FROM Students", "source_tables": ["students"], "pred_sql": "SELECT DISTINCT a.* FROM Addresses a JOIN Students s ON a.address_id = s.current_address_id;", "hint": "\n"}
{"sample_id": "dev.581", "db_id": "student_transcripts_tracking", "question": "Describe the section h.", "rationale": ["The user wants to describe a specific section identified by the name 'h'.", "To retrieve information about a section, we need to select all columns from the Sections table.", "We will use a WHERE clause to filter the results to only include the section with the name 'h'."], "gold_sql": "SELECT section_description FROM Sections WHERE section_name  =  'h'", "source_tables": ["sections"], "pred_sql": "SELECT * FROM Sections WHERE section_name = 'h';", "hint": "\n"}
{"sample_id": "dev.705", "db_id": "world_1", "question": "How many countries have governments that are republics?", "rationale": ["Identify the relevant table: The 'country' table contains information about countries and their government forms.", "Determine the specific information needed: We need to count the number of countries with a government form of 'Republic'.", "Construct the SQL query: Use the COUNT() function to count the rows in the 'country' table where the GovernmentForm is 'Republic'."], "gold_sql": "SELECT count(*) FROM country WHERE GovernmentForm  =  'Republic'", "source_tables": ["country"], "pred_sql": "SELECT COUNT(*) FROM country WHERE GovernmentForm = 'Republic';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.\"\n}\n"}
{"sample_id": "dev.723", "db_id": "world_1", "question": "How many people live in Asia, and what is the largest GNP among them?", "rationale": ["Identify the relevant tables: We need to gather data from the 'country' table to find the total population and GNP.", "Determine the conditions: We are interested in countries located in Asia, so we will filter by the 'Continent' column.", "Calculate the total population: We will use the SUM function to get the total population of all countries in Asia.", "Find the largest GNP: We will use the MAX function to find the highest GNP among the countries in Asia.", "Construct the SQL query: Combine the SUM and MAX functions in a SELECT statement, applying the WHERE clause to filter for Asia."], "gold_sql": "SELECT sum(Population) ,  max(GNP) FROM country WHERE Continent  =  'Asia'", "source_tables": ["country"], "pred_sql": "SELECT SUM(c.Population) AS TotalPopulation, MAX(c.GNP) AS LargestGNP\nFROM country c\nWHERE c.Continent = 'Asia';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the average Gross National Product (GNP) and the total population of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.\"\n}\n"}
{"sample_id": "dev.724", "db_id": "world_1", "question": "What is the average life expectancy in African countries that are republics?", "rationale": ["Identify the relevant table: The 'country' table contains the necessary information about countries, including their continent, government form, and life expectancy.", "Filter by continent: We need to focus on countries in Africa, so we will add a WHERE clause to filter for 'Continent = 'Africa'.", "Filter by government form: We are interested in countries that are republics, so we will add another condition to the WHERE clause to check if 'GovernmentForm' contains the word 'Republic'.", "Calculate the average life expectancy: We will use the AVG() function to calculate the average life expectancy of the filtered countries.", "Select the average life expectancy: We will select the average life expectancy and give it an alias for clarity."], "gold_sql": "SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  'Africa' AND GovernmentForm  =  'Republic'", "source_tables": ["country"], "pred_sql": "SELECT AVG(LifeExpectancy) AS AverageLifeExpectancy\nFROM country\nWHERE Continent = 'Africa' AND GovernmentForm LIKE '%Republic%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total population and average life expectancy of countries grouped by continent. It filters the results to only include continents where the average life expectancy is below a specified threshold. The placeholder in the HAVING clause represents the life expectancy limit.\"\n}\n"}
{"sample_id": "dev.725", "db_id": "world_1", "question": "Give the average life expectancy for countries in Africa which are republics?", "rationale": ["Identify the relevant table: The 'country' table contains the necessary information about countries, including their life expectancy and government form.", "Determine the conditions: We need to filter for countries in Africa, which is specified by the 'Continent' column, and those that are republics, which can be identified using the 'GovernmentForm' column.", "Use the AVG function: To find the average life expectancy, we will use the AVG() function on the 'LifeExpectancy' column.", "Construct the SQL query: Combine the SELECT statement with the WHERE clause to filter the results accordingly."], "gold_sql": "SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  'Africa' AND GovernmentForm  =  'Republic'", "source_tables": ["country"], "pred_sql": "SELECT AVG(LifeExpectancy) AS AverageLifeExpectancy \nFROM country \nWHERE Continent = 'Africa' \nAND GovernmentForm LIKE '%Republic%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total population and average life expectancy of countries grouped by continent. It filters the results to only include continents where the average life expectancy is below a specified threshold. The placeholder in the HAVING clause represents the life expectancy limit.\"\n}\n"}
{"sample_id": "dev.731", "db_id": "world_1", "question": "Give the mean GNP and total population of nations which are considered US territory.", "rationale": ["Identify the required data: mean GNP and total population of countries considered US territory.", "Determine the relevant table: the 'country' table contains the necessary columns for GNP and population.", "Use the AVG() function to calculate the mean GNP and SUM() function to calculate the total population.", "Filter the results using a WHERE clause to include only those countries with a GovernmentForm of 'US Territory'.", "Construct the SQL query to select the average GNP and total population from the country table with the specified condition."], "gold_sql": "SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  'US Territory'", "source_tables": ["country"], "pred_sql": "SELECT AVG(GNP) AS Mean_GNP, SUM(Population) AS Total_Population FROM country WHERE GovernmentForm = 'US Territory';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the average Gross National Product (GNP) and the total population of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.\"\n}\n"}
{"sample_id": "dev.735", "db_id": "world_1", "question": "How many different forms of governments are there in Africa?", "rationale": ["Identify the table that contains information about countries and their government forms, which is the 'country' table.", "Determine the relevant column for government forms, which is 'GovernmentForm'.", "To find the number of different forms of government, we need to count distinct values in the 'GovernmentForm' column.", "Since we are interested in countries located in Africa, we will filter the results using the 'Continent' column with the value 'Africa'.", "Construct the SQL query using the SELECT statement to count distinct government forms from the 'country' table with the specified condition."], "gold_sql": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  'Africa'", "source_tables": ["country"], "pred_sql": "SELECT COUNT(DISTINCT GovernmentForm) AS DifferentGovernmentForms FROM country WHERE Continent = 'Africa';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of distinct government forms present in countries located within a specific continent. The placeholder in the WHERE clause represents the continent's name.\"\n}\n"}
{"sample_id": "dev.754", "db_id": "world_1", "question": "What are the countries where either English or Dutch is the official language ?", "rationale": ["Identify the relevant tables: We need to look at the 'country' and 'countrylanguage' tables to find the countries with specific official languages.", "Determine the conditions: We are interested in countries where either English or Dutch is an official language. This means we need to filter the 'countrylanguage' table for rows where 'IsOfficial' is 'T' and the 'Language' is either 'English' or 'Dutch'.", "Use JOIN to combine the tables: We will join the 'country' table with the 'countrylanguage' table on the 'Code' and 'CountryCode' fields to get the country names along with their languages.", "Select distinct country names: Since we want unique country names, we will use SELECT DISTINCT to avoid duplicates in our results."], "gold_sql": "select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  'english' and isofficial  =  't' union select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  'dutch' and isofficial  =  't'", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT DISTINCT country.Name \nFROM country \nJOIN countrylanguage ON country.Code = countrylanguage.CountryCode \nWHERE countrylanguage.IsOfficial = 'T' AND (countrylanguage.Language = 'English' OR countrylanguage.Language = 'Dutch');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.\"\n}\n"}
{"sample_id": "dev.755", "db_id": "world_1", "question": "Which countries have either English or Dutch as an official language?", "rationale": ["Identify the relevant tables: We need to look at the 'country' and 'countrylanguage' tables to find the countries with specific languages.", "We need to join the 'country' table with the 'countrylanguage' table on the 'Code' and 'CountryCode' columns respectively to get the country names along with their languages.", "We need to filter the results to include only those countries where the language is either 'English' or 'Dutch'.", "Additionally, we need to ensure that the language is marked as an official language by checking the 'IsOfficial' column for 'T' (true).", "Finally, we select distinct country names to avoid duplicates in the result set."], "gold_sql": "SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English' AND IsOfficial  =  'T' UNION SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'Dutch' AND IsOfficial  =  'T'", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT DISTINCT country.Name \nFROM country \nJOIN countrylanguage ON country.Code = countrylanguage.CountryCode \nWHERE countrylanguage.Language IN ('English', 'Dutch') AND countrylanguage.IsOfficial = 'T';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.\"\n}\n"}
{"sample_id": "dev.758", "db_id": "world_1", "question": "Which languages are spoken by only one country in republic governments?", "rationale": ["Identify the relevant tables: countrylanguage for languages and country for government forms.", "Join the countrylanguage table with the country table on the CountryCode to access government forms.", "Filter the results to include only non-official languages (IsOfficial = 'No') and those countries with a republican form of government (GovernmentForm LIKE '%Republic%').", "Group the results by language to count how many countries speak each language.", "Use HAVING to filter the grouped results to include only those languages spoken by exactly one country (COUNT(DISTINCT c.Code) = 1)."], "gold_sql": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.GovernmentForm  =  'Republic' GROUP BY T2.Language HAVING COUNT(*)  =  1", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT cl.Language\nFROM countrylanguage cl\nJOIN country c ON cl.CountryCode = c.Code\nWHERE cl.IsOfficial = 'No' AND c.GovernmentForm LIKE '%Republic%'\nGROUP BY cl.Language\nHAVING COUNT(DISTINCT c.Code) = 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.\"\n}\n"}
{"sample_id": "dev.759", "db_id": "world_1", "question": "What languages are only used by a single country with a republic government?", "rationale": ["Identify the relevant tables: We need to look at the 'countrylanguage' table for languages and the 'country' table for government forms.", "Join the 'countrylanguage' table with the 'country' table on the 'CountryCode' to access the government form of each country that speaks a language.", "Filter the results to include only those languages that are not official (IsOfficial = 'No') and are spoken in countries with a republic government (GovernmentForm LIKE '%Republic%').", "Group the results by language to count how many distinct countries speak each language.", "Use the HAVING clause to filter the grouped results to only include languages that are spoken by a single country (COUNT(DISTINCT c.Code) = 1)."], "gold_sql": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.GovernmentForm  =  'Republic' GROUP BY T2.Language HAVING COUNT(*)  =  1", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT cl.Language\nFROM countrylanguage cl\nJOIN country c ON cl.CountryCode = c.Code\nWHERE cl.IsOfficial = 'No'\nAND c.GovernmentForm LIKE '%Republic%'\nGROUP BY cl.Language\nHAVING COUNT(DISTINCT c.Code) = 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.\"\n}\n"}
{"sample_id": "dev.760", "db_id": "world_1", "question": "Find the city with the largest population that uses English.", "rationale": ["Identify the relevant tables: city, country, and countrylanguage.", "We need to find cities that use English, so we will join the city table with the country table and then with the countrylanguage table.", "The join condition will be city.CountryCode = country.Code and country.Code = countrylanguage.CountryCode.", "We will filter the results to only include rows where the language is 'English'.", "To find the city with the largest population, we will order the results by city.Population in descending order.", "Finally, we will limit the results to 1 to get the city with the largest population."], "gold_sql": "SELECT T1.Name ,  T1.Population FROM city AS T1 JOIN countrylanguage AS T2 ON T1.CountryCode  =  T2.CountryCode WHERE T2.Language  =  'English' ORDER BY T1.Population DESC LIMIT 1", "source_tables": ["city", "countrylanguage"], "pred_sql": "SELECT city.Name, city.Population \nFROM city \nJOIN country ON city.CountryCode = country.Code \nJOIN countrylanguage ON country.Code = countrylanguage.CountryCode \nWHERE countrylanguage.Language = 'English' \nORDER BY city.Population DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of the number of countries and the maximum percentage of speakers for a specific language from the 'countrylanguage' table. The placeholder in the WHERE clause represents the language name being queried.\"\n}\n"}
{"sample_id": "dev.766", "db_id": "world_1", "question": "What is the total number of people living in the nations that do not use English?", "rationale": ["We need to find the total population of countries that do not use English as an official language.", "To do this, we will first identify the country codes of countries where English is an official language using a subquery.", "The subquery will select the CountryCode from the countrylanguage table where the Language is 'English' and IsOfficial is 'T'.", "Next, we will sum the populations of countries whose codes are not in the list returned by the subquery.", "Finally, we will write the main query to select the sum of the population from the country table, filtering out the countries identified in the subquery."], "gold_sql": "SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English')", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT SUM(c.Population) AS TotalPopulation\nFROM country c\nWHERE c.Code NOT IN (\n    SELECT cl.CountryCode\n    FROM countrylanguage cl\n    WHERE cl.Language = 'English' AND cl.IsOfficial = 'T'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.\"\n}\n"}
{"sample_id": "dev.774", "db_id": "world_1", "question": "What are the African countries that have a  population less than any country in Asia?", "rationale": ["Identify the countries in Africa by filtering the 'country' table for the continent 'Africa'.", "Use a subquery to find the minimum population of any country in Asia by filtering the 'country' table for the continent 'Asia' and selecting the minimum population.", "Combine the two conditions to find African countries with a population less than the minimum population found in Asia."], "gold_sql": "SELECT Name FROM country WHERE Continent  =  'Africa'  AND population  <  (SELECT max(population) FROM country WHERE Continent  =  'Asia')", "source_tables": ["country"], "pred_sql": "SELECT c.Name \nFROM country c \nWHERE c.Continent = 'Africa' \nAND c.Population < (SELECT MIN(Population) FROM country WHERE Continent = 'Asia');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total population and average life expectancy of countries grouped by continent. It filters the results to only include continents where the average life expectancy is below a specified threshold. The placeholder in the HAVING clause represents the life expectancy limit.\"\n}\n"}
{"sample_id": "dev.777", "db_id": "world_1", "question": "What are the Asian countries which have a population larger than that of any country in Africa?", "rationale": ["Identify the countries in Asia by filtering the 'country' table where the 'Continent' column is 'Asia'.", "To find countries in Asia with a population larger than any country in Africa, we need to compare the population of Asian countries with the maximum population of African countries.", "Use a subquery to select the maximum population from the 'country' table where the 'Continent' is 'Africa'.", "Combine these conditions in the WHERE clause of the main query to filter the results accordingly."], "gold_sql": "SELECT Name FROM country WHERE Continent  =  'Asia'  AND population  >  (SELECT min(population) FROM country WHERE Continent  =  'Africa')", "source_tables": ["country"], "pred_sql": "SELECT c.Name \nFROM country c \nWHERE c.Continent = 'Asia' \nAND c.Population > (SELECT MAX(Population) FROM country WHERE Continent = 'Africa');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the total population and average surface area of countries located in a specific continent that have a surface area greater than a specified value. The placeholders in the WHERE clause represent the continent's name and the minimum surface area.\"\n}\n"}
{"sample_id": "dev.778", "db_id": "world_1", "question": "What are the country codes for countries that do not speak English?", "rationale": ["Identify the requirement: We need to find country codes for countries that do not speak English.", "Understand the schema: The 'country' table contains country codes, and the 'countrylanguage' table contains languages spoken in those countries.", "Use a subquery to find country codes where English is an official language: SELECT CountryCode FROM countrylanguage WHERE Language = 'English' AND IsOfficial = 'Yes'.", "Use the NOT IN clause to filter out these country codes from the main query: SELECT DISTINCT country.Code FROM country WHERE country.Code NOT IN (subquery).", "Combine these elements to form the final SQL query."], "gold_sql": "SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  'English'", "source_tables": ["countrylanguage"], "pred_sql": "SELECT DISTINCT country.Code FROM country WHERE country.Code NOT IN (SELECT CountryCode FROM countrylanguage WHERE Language = 'English' AND IsOfficial = 'Yes');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.\"\n}\n"}
{"sample_id": "dev.786", "db_id": "world_1", "question": "Which unique cities are in Asian countries where Chinese is the official language ?", "rationale": ["Identify the tables needed: city, country, and countrylanguage.", "We need to find unique cities, so we will use SELECT DISTINCT on city.Name.", "We need to join the city table with the country table on the CountryCode to get the continent information.", "Next, we join the country table with the countrylanguage table to filter by language and its official status.", "We filter the results to include only cities in Asian countries by checking the continent.", "We also filter to include only those countries where Chinese is an official language."], "gold_sql": "select distinct t3.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode join city as t3 on t1.code  =  t3.countrycode where t2.isofficial  =  't' and t2.language  =  'chinese' and t1.continent  =  'asia'", "source_tables": ["country", "city", "countrylanguage"], "pred_sql": "SELECT DISTINCT city.Name \nFROM city \nJOIN country ON city.CountryCode = country.Code \nJOIN countrylanguage ON country.Code = countrylanguage.CountryCode \nWHERE country.Continent = 'Asia' \nAND countrylanguage.Language = 'Chinese' \nAND countrylanguage.IsOfficial = 'T';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.\"\n}\n"}
{"sample_id": "dev.789", "db_id": "world_1", "question": "Give the name, year of independence, and surface area of the country that has the lowest population.", "rationale": ["Identify the required fields: Name, Year of Independence (IndepYear), and Surface Area (SurfaceArea) from the country table.", "Determine the condition to find the country with the lowest population, which involves ordering the results by the Population column in ascending order.", "Use the ORDER BY clause to sort the countries by their population.", "Limit the results to only one entry using the LIMIT clause to get the country with the lowest population."], "gold_sql": "SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT 1", "source_tables": ["country"], "pred_sql": "SELECT Name, IndepYear, SurfaceArea FROM country ORDER BY Population ASC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of countries, displaying their names, surface areas, and the year they gained independence. The results are ordered by the population of the countries, and the number of entries returned is limited by a specified placeholder for numeric values.\"\n}\n"}
{"sample_id": "dev.793", "db_id": "world_1", "question": "What are the names of countries that speak more than 2 languages, as well as how many languages they speak?", "rationale": ["We need to find countries that speak more than 2 languages.", "We will use the 'country' table to get the names of the countries.", "We will join the 'countrylanguage' table to count the number of languages spoken in each country.", "We will group the results by country code to aggregate the language counts.", "Finally, we will filter the results using HAVING to only include countries with more than 2 languages."], "gold_sql": "SELECT COUNT(T2.Language) ,  T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Name HAVING COUNT(*)  >  2", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT c.Name, COUNT(cl.Language) AS LanguageCount\nFROM country c\nJOIN countrylanguage cl ON c.Code = cl.CountryCode\nGROUP BY c.Code\nHAVING COUNT(cl.Language) > 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.\"\n}\n"}
{"sample_id": "dev.797", "db_id": "world_1", "question": "What are the different government forms and what is the total population of each for government forms that have an average life expectancy greater than 72?", "rationale": ["Identify the relevant table: The 'country' table contains the 'GovernmentForm' and 'Population' columns, as well as 'LifeExpectancy'.", "Filter the results: We need to filter for government forms where the average life expectancy is greater than 72. This is done using a WHERE clause.", "Group the results: To get the total population for each government form, we will use the GROUP BY clause on 'GovernmentForm'.", "Calculate the total population: We will use the SUM function to calculate the total population for each government form.", "Select the required columns: We will select 'GovernmentForm' and the calculated total population as 'TotalPopulation'."], "gold_sql": "SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  72", "source_tables": ["country"], "pred_sql": "SELECT GovernmentForm, SUM(Population) AS TotalPopulation\nFROM country\nWHERE LifeExpectancy > 72\nGROUP BY GovernmentForm;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total population of countries grouped by their government form, filtering for those government forms where the average life expectancy exceeds a specified threshold. The placeholder in the HAVING clause represents the minimum average life expectancy value.\"\n}\n"}
{"sample_id": "dev.812", "db_id": "world_1", "question": "What are the cities whose population is between 160000 and 900000?", "rationale": ["Identify the table to query: The 'city' table contains the population data.", "Determine the condition: We need to find cities with a population between 160000 and 900000.", "Construct the SQL query: Use the SELECT statement to retrieve all columns from the 'city' table where the population falls within the specified range using the BETWEEN clause."], "gold_sql": "SELECT name FROM city WHERE Population BETWEEN 160000 AND 900000", "source_tables": ["city"], "pred_sql": "SELECT * FROM city WHERE Population BETWEEN '160000' AND '900000';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the total population and average surface area of countries located in a specific continent that have a surface area greater than a specified value. The placeholders in the WHERE clause represent the continent's name and the minimum surface area.\"\n}\n"}
{"sample_id": "dev.820", "db_id": "world_1", "question": "What are the codes of countries where Spanish is spoken by the largest percentage of people?", "rationale": ["Identify the relevant table: countrylanguage, which contains information about languages spoken in countries.", "Filter the records to only include those where the Language is 'Spanish'.", "Order the results by the Percentage column in descending order to get the countries where Spanish is spoken by the largest percentage of people.", "Select the CountryCode from the filtered and ordered results."], "gold_sql": "SELECT CountryCode ,  max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  'Spanish' GROUP BY CountryCode", "source_tables": ["countrylanguage"], "pred_sql": "SELECT CountryCode FROM countrylanguage WHERE Language = 'Spanish' ORDER BY Percentage DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.\"\n}\n"}
{"sample_id": "dev.821", "db_id": "world_1", "question": "Return the codes of countries for which Spanish is the predominantly spoken language.", "rationale": ["Identify the table that contains language information: countrylanguage.", "Determine the relevant columns: CountryCode, Language, and IsOfficial.", "Filter the results to include only those rows where Language is 'Spanish'.", "Additionally, filter to ensure that the language is not an official language by checking IsOfficial = 'no'.", "Construct the SQL query using the SELECT statement to retrieve the CountryCode based on the specified conditions."], "gold_sql": "SELECT CountryCode ,  max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  'Spanish' GROUP BY CountryCode", "source_tables": ["countrylanguage"], "pred_sql": "SELECT CountryCode FROM countrylanguage WHERE Language = 'Spanish' AND IsOfficial = 'no';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.\"\n}\n"}
{"sample_id": "dev.920", "db_id": "dog_kennels", "question": "What is the average age of the dogs who have gone through any treatments?", "rationale": ["Identify the relevant tables: Dogs and Treatments.", "We need to find the average age of dogs that have undergone treatments, so we will join the Dogs table with the Treatments table on the dog_id.", "Use the AVG() function to calculate the average age of the dogs from the Dogs table after the join."], "gold_sql": "SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )", "source_tables": ["dogs", "treatments"], "pred_sql": "SELECT AVG(D.age) AS average_age\nFROM Dogs D\nJOIN Treatments T ON D.dog_id = T.dog_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a unique list of breed codes and size codes for dogs from the 'Dogs' table. The placeholders represent the breed and size categories associated with the dogs.\"\n}\n"}
{"sample_id": "dev.936", "db_id": "dog_kennels", "question": "Which owner has paid for the most treatments on his or her dogs? List the owner id and last name.", "rationale": ["Identify the relevant tables: Owners, Dogs, and Treatments.", "Join the Owners table with the Dogs table on owner_id to link owners to their dogs.", "Join the resulting table with the Treatments table on dog_id to link treatments to the respective dogs.", "Group the results by owner_id and last_name to aggregate treatment costs for each owner.", "Use SUM to calculate the total cost of treatments for each owner.", "Order the results in descending order based on the total treatment cost to find the owner who has paid the most.", "Limit the results to 1 to get only the top owner."], "gold_sql": "SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["owners", "dogs", "treatments"], "pred_sql": "SELECT Owners.owner_id, Owners.last_name\nFROM Owners\nJOIN Dogs ON Owners.owner_id = Dogs.owner_id\nJOIN Treatments ON Dogs.dog_id = Treatments.dog_id\nGROUP BY Owners.owner_id, Owners.last_name\nORDER BY SUM(Treatments.cost_of_treatment) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a unique list of breed codes and size codes for dogs from the 'Dogs' table. The placeholders represent the breed and size categories associated with the dogs.\"\n}\n"}
{"sample_id": "dev.942", "db_id": "dog_kennels", "question": "Which professionals have done at least two types of treatments? List the professional id and cell phone.", "rationale": ["Identify the relevant table: The question pertains to professionals and treatments, so we will focus on the Treatments table.", "Determine the required fields: We need to select the professional_id and cell_number of professionals who have performed at least two types of treatments.", "Group the results: We will group the results by professional_id to aggregate the treatment types associated with each professional.", "Count distinct treatment types: We will use COUNT(DISTINCT treatment_type_code) to count the number of different treatment types each professional has administered.", "Filter the results: We will use HAVING to filter the groups to only include those with a count of two or more distinct treatment types."], "gold_sql": "SELECT T1.professional_id ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  2", "source_tables": ["professionals", "treatments"], "pred_sql": "SELECT professional_id, cell_number\nFROM Treatments\nGROUP BY professional_id\nHAVING COUNT(DISTINCT treatment_type_code) >= 2;", "hint": "\n"}
{"sample_id": "dev.944", "db_id": "dog_kennels", "question": "What are the first name and last name of the professionals who have done treatment with cost below average?", "rationale": ["Identify the relevant tables: Professionals and Treatments.", "We need to select the first name and last name of professionals, so we will select 'first_name' and 'last_name' from the Professionals table.", "To find professionals who have done treatments, we need to join the Professionals table with the Treatments table on the professional_id.", "We need to filter the treatments based on their cost being below average. Therefore, we will use a subquery to calculate the average cost of treatments.", "The subquery will select the average of 'cost_of_treatment' from the Treatments table.", "Finally, we will apply the condition in the WHERE clause to filter out the professionals based on the average treatment cost."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T1.last_name FROM Professionals AS T1 JOIN Treatments AS T2 WHERE cost_of_treatment  <  ( SELECT avg(cost_of_treatment) FROM Treatments )", "source_tables": ["professionals", "treatments"], "pred_sql": "SELECT Professionals.first_name, Professionals.last_name\nFROM Professionals\nJOIN Treatments ON Professionals.professional_id = Treatments.professional_id\nWHERE Treatments.cost_of_treatment < (SELECT AVG(cost_of_treatment) FROM Treatments);", "hint": "\n"}
{"sample_id": "dev.950", "db_id": "dog_kennels", "question": "List each owner's first name, last name, and the size of his for her dog.", "rationale": ["Identify the required information: owner's first name, last name, and dog's size.", "Determine the relevant tables: Owners, Dogs, and Sizes.", "Establish relationships between the tables: Owners are linked to Dogs via owner_id, and Dogs are linked to Sizes via size_code.", "Use JOIN clauses to combine the tables based on these relationships.", "Select the appropriate columns from the combined tables."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id", "source_tables": ["owners", "dogs"], "pred_sql": "SELECT Owners.first_name, Owners.last_name, Sizes.size_description \nFROM Owners \nJOIN Dogs ON Owners.owner_id = Dogs.owner_id \nJOIN Sizes ON Dogs.size_code = Sizes.size_code;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a unique list of breed codes and size codes for dogs from the 'Dogs' table. The placeholders represent the breed and size categories associated with the dogs.\"\n}\n"}
{"sample_id": "dev.951", "db_id": "dog_kennels", "question": "What are each owner's first name, last name, and the size of their dog?", "rationale": ["Identify the required information: owner's first name, last name, and dog's size.", "Determine the relevant tables: Owners, Dogs, and Sizes.", "Establish relationships between the tables: Owners are linked to Dogs via owner_id, and Dogs are linked to Sizes via size_code.", "Use JOIN clauses to combine the tables based on these relationships.", "Select the appropriate columns from the combined tables."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id", "source_tables": ["owners", "dogs"], "pred_sql": "SELECT Owners.first_name, Owners.last_name, Sizes.size_description \nFROM Owners \nJOIN Dogs ON Owners.owner_id = Dogs.owner_id \nJOIN Sizes ON Dogs.size_code = Sizes.size_code;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a unique list of breed codes and size codes for dogs from the 'Dogs' table. The placeholders represent the breed and size categories associated with the dogs.\"\n}\n"}
{"sample_id": "dev.958", "db_id": "dog_kennels", "question": "What are the arriving date and the departing date of the dogs who have gone through a treatment?", "rationale": ["Identify the relevant tables: Dogs and Treatments.", "We need the arriving and departing dates of dogs, which are in the Dogs table.", "We also need to filter for dogs that have undergone treatment, which is indicated in the Treatments table.", "To link the Dogs and Treatments tables, we can use the dog_id column, which is common to both tables.", "Construct the SQL query to select the date_arrived and date_departed from the Dogs table, joining it with the Treatments table on dog_id."], "gold_sql": "SELECT DISTINCT T1.date_arrived ,  T1.date_departed FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id", "source_tables": ["dogs", "treatments"], "pred_sql": "SELECT d.date_arrived, d.date_departed \nFROM Dogs d \nJOIN Treatments t ON d.dog_id = t.dog_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a unique list of breed codes and size codes for dogs from the 'Dogs' table. The placeholders represent the breed and size categories associated with the dogs.\"\n}\n"}
{"sample_id": "dev.961", "db_id": "dog_kennels", "question": "Who owns the youngest dog? Give me his or her last name.", "rationale": ["Identify the relevant tables: We need information from the Dogs and Owners tables.", "Determine the necessary columns: We need the last name of the owner and the date of birth of the dog to find the youngest dog.", "Join the Dogs table with the Owners table on the owner_id to link dogs with their respective owners.", "Sort the results by the date_of_birth of the dogs in descending order to get the youngest dog first.", "Limit the results to 1 to get only the youngest dog owner."], "gold_sql": "SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )", "source_tables": ["owners", "dogs"], "pred_sql": "SELECT Owners.last_name \nFROM Dogs \nJOIN Owners ON Dogs.owner_id = Owners.owner_id \nORDER BY Dogs.date_of_birth DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a unique list of breed codes and size codes for dogs from the 'Dogs' table. The placeholders represent the breed and size categories associated with the dogs.\"\n}\n"}
{"sample_id": "dev.997", "db_id": "dog_kennels", "question": "Find the distinct breed type and size type combinations for dogs.", "rationale": ["We need to find distinct combinations of breed types and size types for dogs.", "The relevant tables for this query are 'Dogs', 'Breeds', and 'Sizes'.", "We will join the 'Dogs' table with the 'Breeds' table on the 'breed_code' to get the breed names.", "We will also join the 'Dogs' table with the 'Sizes' table on the 'size_code' to get the size descriptions.", "Using SELECT DISTINCT will ensure that we only get unique combinations of breed names and size descriptions."], "gold_sql": "SELECT DISTINCT breed_code ,  size_code FROM dogs", "source_tables": ["dogs"], "pred_sql": "SELECT DISTINCT Breeds.breed_name, Sizes.size_description \nFROM Dogs \nJOIN Breeds ON Dogs.breed_code = Breeds.breed_code \nJOIN Sizes ON Dogs.size_code = Sizes.size_code;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a unique list of breed codes and size codes for dogs from the 'Dogs' table. The placeholders represent the breed and size categories associated with the dogs.\"\n}\n"}
{"sample_id": "dev.999", "db_id": "dog_kennels", "question": "What are each professional's first name and description of the treatment they have performed?", "rationale": ["Identify the required information: professional's first name and treatment description.", "Determine the relevant tables: Professionals and Treatment_Types.", "Recognize that Treatments table links Professionals and Treatment_Types through foreign keys.", "Use JOIN statements to connect the tables based on their relationships: Treatments to Professionals and Treatments to Treatment_Types.", "Select the desired columns from the joined tables."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code", "source_tables": ["professionals", "treatments", "treatment_types"], "pred_sql": "SELECT Professionals.first_name, Treatment_Types.treatment_type_description\nFROM Treatments\nJOIN Professionals ON Treatments.professional_id = Professionals.professional_id\nJOIN Treatment_Types ON Treatments.treatment_type_code = Treatment_Types.treatment_type_code;", "hint": "\n"}
