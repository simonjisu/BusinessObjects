{"sample_id": "train.2612", "db_id": "inn_1", "question": "Find the name of the room with the maximum occupancy.", "rationale": ["Identify the relevant table: The 'Rooms' table contains the information about room names and their maximum occupancy.", "Determine the requirement: We need to find the room name with the maximum occupancy.", "Use a subquery to find the maximum occupancy: The subquery (SELECT MAX(maxOccupancy) FROM Rooms) will return the highest value of maxOccupancy from the Rooms table.", "Filter the main query: The main query will select the roomName from the Rooms table where the maxOccupancy matches the maximum value found in the subquery."], "gold_sql": "SELECT roomName FROM Rooms ORDER BY maxOccupancy DESC LIMIT 1;", "source_tables": ["rooms"], "pred_sql": "SELECT roomName FROM Rooms WHERE maxOccupancy = (SELECT MAX(maxOccupancy) FROM Rooms);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of rooms from the 'Rooms' table that have specific types of beds available. The placeholders in the WHERE clause represent the types of beds that the user is interested in.\",\n        \"virtual_table\": \"SELECT roomName FROM Rooms WHERE bedType  =  [PLACEHOLDER-TYPE:STRING] OR bedType  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.2621", "db_id": "inn_1", "question": "What is the average minimum and price of the rooms for each different decor.", "rationale": ["Identify the tables involved: Rooms and Reservations.", "Determine the required fields: decor, average price, and minimum price.", "Use JOIN to connect Rooms and Reservations based on the RoomId.", "Use AVG() to calculate the average price and MIN() to find the minimum price of rooms.", "Group the results by the decor type to get the average and minimum prices for each decor."], "gold_sql": "SELECT decor , avg(basePrice) ,  min(basePrice) FROM Rooms GROUP BY decor;", "source_tables": ["rooms"], "pred_sql": "SELECT Rooms.decor, AVG(CAST(Rooms.basePrice AS REAL)) AS average_price, MIN(CAST(Rooms.basePrice AS REAL)) AS minimum_price \nFROM Rooms \nJOIN Reservations ON Rooms.RoomId = Reservations.Room \nGROUP BY Rooms.decor;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of room decorations from the 'Rooms' table that have been reserved, grouped by their decor type. The results are ordered by the count of reservations for each decor type in ascending order, with a limit on the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T2.decor FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T2.decor ORDER BY count(T2.decor) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.2628", "db_id": "inn_1", "question": "List the name of rooms with king or queen bed.", "rationale": ["Identify the relevant table: The 'Rooms' table contains the information about room names and bed types.", "Determine the required columns: We need the 'roomName' column from the 'Rooms' table.", "Specify the condition for bed types: We are interested in rooms with either 'king' or 'queen' beds.", "Construct the SQL query: Using the identified table and columns, we create a SELECT statement with a WHERE clause to filter by the specified bed types."], "gold_sql": "SELECT roomName FROM Rooms WHERE bedType  =  'King' OR bedType  =  'Queen';", "source_tables": ["rooms"], "pred_sql": "SELECT roomName FROM Rooms WHERE bedType = 'king' OR bedType = 'queen';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of rooms from the 'Rooms' table that have specific types of beds available. The placeholders in the WHERE clause represent the types of beds that the user is interested in.\",\n        \"virtual_table\": \"SELECT roomName FROM Rooms WHERE bedType  =  [PLACEHOLDER-TYPE:STRING] OR bedType  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.2639", "db_id": "inn_1", "question": "For each room, find its name and the number of times reservations were made for it.", "rationale": ["Identify the columns needed: room name and the count of reservations.", "Use the Rooms table to get the room names.", "Join the Rooms table with the Reservations table on the RoomId to link rooms with their reservations.", "Count the number of reservations for each room using COUNT() function.", "Group the results by RoomId to get the count for each room."], "gold_sql": "SELECT T2.roomName ,  count(*) ,  T1.Room FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT Rooms.roomName, COUNT(Reservations.Code) AS reservation_count \nFROM Rooms \nLEFT JOIN Reservations ON Rooms.RoomId = Reservations.Room \nGROUP BY Rooms.RoomId;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of kids associated with reservations made by a specific guest. The placeholders in the WHERE clause represent the first and last names of the guest.\",\n        \"virtual_table\": \"SELECT kids FROM Reservations WHERE FirstName = [PLACEHOLDER-TYPE:STRING] AND LastName  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.2846", "db_id": "customer_deliveries", "question": "Show the details of all trucks in the order of their license number.", "rationale": ["Identify the table needed: The question asks for details of trucks, so we will use the 'Trucks' table.", "Select all columns: We need all details, so we will use SELECT *.", "Order by license number: The question specifies to order the results by the truck's license number, so we will add ORDER BY truck_licence_number."], "gold_sql": "SELECT truck_details FROM trucks ORDER BY truck_licence_number", "source_tables": ["trucks"], "pred_sql": "SELECT * FROM Trucks ORDER BY truck_licence_number;", "hint": "\n"}
{"sample_id": "train.2848", "db_id": "customer_deliveries", "question": "Find the names of customers who are not living in the state of California.", "rationale": ["Identify the relevant tables: Customers, Customer_Addresses, and Addresses.", "We need to find customer names, so we will select 'customer_name' from the Customers table.", "To filter customers based on their address, we need to join the Customers table with the Customer_Addresses table using 'customer_id'.", "Next, we join the Customer_Addresses table with the Addresses table using 'address_id' to access the state information.", "Finally, we apply a WHERE clause to filter out customers whose state is 'California'."], "gold_sql": "SELECT customer_name FROM customers EXCEPT SELECT t1.customer_name FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id WHERE t3.state_province_county  =  'California'", "source_tables": ["addresses", "customers", "customer_addresses"], "pred_sql": "SELECT customer_name \nFROM Customers C \nJOIN Customer_Addresses CA ON C.customer_id = CA.customer_id \nJOIN Addresses A ON CA.address_id = A.address_id \nWHERE A.state_province_county != 'California';", "hint": "\n"}
{"sample_id": "train.2856", "db_id": "customer_deliveries", "question": "Find the name of route that has the highest number of deliveries.", "rationale": ["We need to find the name of the route with the highest number of deliveries.", "To do this, we will first count the number of deliveries for each route in the Order_Deliveries table.", "We will group the results by route_id and order them in descending order based on the count of deliveries.", "We will limit the results to 1 to get the route with the highest number of deliveries.", "Finally, we will select the route_name from the Delivery_Routes table where the route_id matches the one we found in the previous step."], "gold_sql": "SELECT t1.route_name FROM Delivery_Routes AS t1 JOIN Delivery_Route_Locations AS t2 ON t1.route_id  =  t2.route_id GROUP BY t1.route_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["delivery_route_locations", "delivery_routes"], "pred_sql": "SELECT route_name\nFROM Delivery_Routes\nWHERE route_id = (\n    SELECT route_id\n    FROM Order_Deliveries\n    GROUP BY route_id\n    ORDER BY COUNT(*) DESC\n    LIMIT 1\n);", "hint": "\n"}
{"sample_id": "train.3175", "db_id": "college_1", "question": "How many professors are teaching class with code ACCT-211?", "rationale": ["Identify the relevant tables: CLASS and PROFESSOR.", "Determine the relationship between the tables: CLASS has a foreign key PROF_NUM that links to EMP_NUM in PROFESSOR.", "We need to count the number of distinct professors teaching the class with code 'ACCT-211'.", "Use a JOIN to connect CLASS and PROFESSOR on the PROF_NUM and EMP_NUM fields respectively.", "Filter the results to only include the class with CLASS_CODE 'ACCT-211'.", "Use COUNT(DISTINCT p.EMP_NUM) to get the number of unique professors teaching that class."], "gold_sql": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["class"], "pred_sql": "SELECT COUNT(DISTINCT p.EMP_NUM) AS professor_count \nFROM CLASS c \nJOIN PROFESSOR p ON c.PROF_NUM = p.EMP_NUM \nWHERE c.CLASS_CODE = 'ACCT-211';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of professors grouped by the school code from the 'Department' table. The placeholder in the SELECT clause represents the count of professors, while the school code is derived from the department associated with each professor.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code\"\n    }\n}\n"}
{"sample_id": "train.3176", "db_id": "college_1", "question": "How many professors teach a class with the code ACCT-211?", "rationale": ["Identify the relevant tables: PROFESSOR and CLASS are needed to find professors teaching a specific class.", "Join the PROFESSOR table with the CLASS table on the common column PROF_NUM to link professors to their classes.", "Filter the results to only include classes with the CLASS_CODE 'ACCT-211'.", "Use COUNT(DISTINCT p.EMP_NUM) to count the unique professors teaching that class."], "gold_sql": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["class"], "pred_sql": "SELECT COUNT(DISTINCT p.EMP_NUM) \nFROM PROFESSOR p \nJOIN CLASS c ON p.EMP_NUM = c.PROF_NUM \nWHERE c.CLASS_CODE = 'ACCT-211';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of professors grouped by the school code from the 'Department' table. The placeholder in the SELECT clause represents the count of professors, while the school code is derived from the department associated with each professor.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code\"\n    }\n}\n"}
{"sample_id": "train.3179", "db_id": "college_1", "question": "What are the first names and date of birth of professors teaching course ACCT-211?", "rationale": ["Identify the tables needed: We need information from the PROFESSOR (to get first names), CLASS (to link professors to courses), and COURSE (to filter by course code).", "Join the CLASS table with the EMPLOYEE table to get the first names of professors teaching the classes.", "Join the CLASS table with the COURSE table to filter for the specific course 'ACCT-211'.", "Select the first names and date of birth of the professors from the EMPLOYEE table."], "gold_sql": "SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["employee", "class"], "pred_sql": "SELECT T2.emp_fname, T2.emp_dob FROM CLASS AS T1 JOIN EMPLOYEE AS T2 ON T1.PROF_NUM = T2.EMP_NUM JOIN COURSE AS T3 ON T1.CRS_CODE = T3.CRS_CODE WHERE T3.CRS_CODE = 'ACCT-211'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description ,  T5.dept_name FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num JOIN department AS T5 ON T4.dept_code  =  T5.dept_code\"\n    }\n}\n"}
{"sample_id": "train.3188", "db_id": "college_1", "question": "Where is the history department?", "rationale": ["The user is asking for the location of the history department, which implies we need to query the DEPARTMENT table.", "To find the history department, we will filter the DEPARTMENT table by the department name, specifically looking for 'History'.", "We will select the department name and address from the DEPARTMENT table to provide the location information."], "gold_sql": "SELECT dept_address FROM department WHERE dept_name  =  'History'", "source_tables": ["department"], "pred_sql": "SELECT T5.dept_name, T5.dept_address FROM DEPARTMENT AS T5 WHERE T5.dept_name = 'History'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description ,  T5.dept_name FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num JOIN department AS T5 ON T4.dept_code  =  T5.dept_code\"\n    }\n}\n"}
{"sample_id": "train.3190", "db_id": "college_1", "question": "What are the different locations of the school with the code BUS?", "rationale": ["Identify the relevant table: The question asks about locations associated with a specific school code, which relates to the DEPARTMENT table where school codes and addresses are stored.", "Determine the specific column needed: We need the DEPT_ADDRESS column to get the locations of the departments.", "Filter by the school code: We will add a WHERE clause to filter the results to only include departments that belong to the school with the code 'BUS'.", "Use DISTINCT to ensure unique addresses are returned, as multiple departments may share the same address."], "gold_sql": "SELECT count(DISTINCT dept_address) FROM department WHERE school_code  =  'BUS'", "source_tables": ["department"], "pred_sql": "SELECT DISTINCT DEPT_ADDRESS FROM DEPARTMENT WHERE SCHOOL_CODE = 'BUS';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of school codes from the 'department' table, grouped by the school code and ordered by the count of professors associated with each school. The placeholder in the LIMIT clause allows the user to specify the maximum number of school codes to retrieve.\",\n        \"virtual_table\": \"SELECT T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3201", "db_id": "college_1", "question": "What is the total credit does each department offer?", "rationale": ["Identify the tables involved: We need to gather information from the COURSE and CLASS tables to determine the total credit hours offered by each department.", "Determine the relationship: The COURSE table has a DEPT_CODE that links to the department, and the CLASS table has a CRS_CODE that links to the COURSE table.", "Use aggregation: We need to sum the credit hours (CRS_CREDIT) for each department, which requires a GROUP BY clause on the DEPT_CODE.", "Construct the SQL query: Using the JOIN clause to connect the COURSE and CLASS tables on the CRS_CODE, and then summing the CRS_CREDIT while grouping by DEPT_CODE."], "gold_sql": "SELECT sum(crs_credit) ,  dept_code FROM course GROUP BY dept_code", "source_tables": ["course"], "pred_sql": "SELECT sum(T1.CRS_CREDIT) AS total_credit, T1.DEPT_CODE FROM COURSE AS T1 JOIN CLASS AS T2 ON T1.CRS_CODE = T2.CRS_CODE GROUP BY T1.DEPT_CODE", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables, allowing for the aggregation of credit hours per department.\",\n        \"virtual_table\": \"SELECT sum(T1.crs_credit) ,  T1.dept_code FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY T1.dept_code\"\n    }\n}\n"}
{"sample_id": "train.3202", "db_id": "college_1", "question": "How many credits does the department offer?", "rationale": ["The question asks for the total credits offered by the department.", "To find this, we need to sum the credit hours from the COURSE table.", "The COURSE table contains the CRS_CREDIT column which represents the number of credit hours for each course.", "We need to join the COURSE table with the CLASS table to ensure we are considering only the courses that have classes scheduled.", "The join is done on the CRS_CODE column which is common in both tables.", "After joining, we can group the results by DEPT_CODE to get the total credits for each department.", "Finally, we select the sum of CRS_CREDIT and the DEPT_CODE to get the desired result."], "gold_sql": "SELECT sum(crs_credit) ,  dept_code FROM course GROUP BY dept_code", "source_tables": ["course"], "pred_sql": "SELECT sum(T1.CRS_CREDIT) AS total_credits, T1.DEPT_CODE FROM COURSE AS T1 JOIN CLASS AS T2 ON T1.CRS_CODE = T2.CRS_CODE GROUP BY T1.DEPT_CODE", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables, allowing for the aggregation of credit hours per department.\",\n        \"virtual_table\": \"SELECT sum(T1.crs_credit) ,  T1.dept_code FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY T1.dept_code\"\n    }\n}\n"}
{"sample_id": "train.3213", "db_id": "college_1", "question": "Which school has the smallest amount of professors?", "rationale": ["We need to find the school with the smallest number of professors.", "The hint provides a virtual table that counts professors grouped by school code.", "We will use the provided virtual table to create a subquery that counts the number of professors for each school.", "Next, we will order the results of this subquery by the count of professors in ascending order.", "Finally, we will limit the results to 1 to get the school with the smallest number of professors."], "gold_sql": "SELECT T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code ORDER BY count(*) LIMIT 1", "source_tables": ["department", "professor"], "pred_sql": "SELECT T1.school_code FROM (SELECT count(*) AS professor_count, T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code = T2.dept_code GROUP BY T1.school_code) AS counts ORDER BY professor_count ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of professors grouped by the school code from the 'Department' table. The placeholder in the SELECT clause represents the count of professors, while the school code is derived from the department associated with each professor.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code\"\n    }\n}\n"}
{"sample_id": "train.3215", "db_id": "college_1", "question": "Find the number of professors with a Ph.D. degree in each department.", "rationale": ["Identify the tables needed: DEPARTMENT and PROFESSOR.", "We need to count the number of professors, so we will use COUNT(*) in the SELECT clause.", "We need to filter professors with a Ph.D. degree, so we will add a WHERE clause to check for 'Ph.D.' in the PROF_HIGH_DEGREE column.", "We want to group the results by department, so we will use GROUP BY on the DEPT_NAME from the DEPARTMENT table.", "Join the DEPARTMENT and PROFESSOR tables on the DEPT_CODE to get the necessary information for the count and department name."], "gold_sql": "SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  'Ph.D.' GROUP BY dept_code", "source_tables": ["professor"], "pred_sql": "SELECT COUNT(*) AS professor_count, D.DEPT_NAME \nFROM DEPARTMENT D \nJOIN PROFESSOR P ON D.DEPT_CODE = P.DEPT_CODE \nWHERE P.PROF_HIGH_DEGREE = 'Ph.D.' \nGROUP BY D.DEPT_NAME;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of professors grouped by the school code from the 'Department' table. The placeholder in the SELECT clause represents the count of professors, while the school code is derived from the department associated with each professor.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code\"\n    }\n}\n"}
{"sample_id": "train.3217", "db_id": "college_1", "question": "Find the number of students for each department.", "rationale": ["We need to find the number of students for each department.", "The relevant table for student information is the STUDENT table.", "To count the number of students, we can use the COUNT() function.", "We will group the results by the department code to get the count for each department.", "The provided hint suggests a virtual table that counts students grouped by department code, which we can use as a basis for our query."], "gold_sql": "SELECT count(*) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT count(*) AS student_count, dept_code FROM STUDENT GROUP BY dept_code", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of students grouped by their department codes from the 'student' table. The placeholder in the SELECT statement represents the department code for which the count of students is being aggregated.\",\n        \"virtual_table\": \"SELECT count(*) ,  dept_code FROM student GROUP BY dept_code\"\n    }\n}\n"}
{"sample_id": "train.3219", "db_id": "college_1", "question": "Find the total number of hours have done for all students in each department.", "rationale": ["Identify the relevant table: The STUDENT table contains the total credit hours completed by students and their department codes.", "Determine the aggregation needed: We need to sum the total credit hours for each department.", "Group the results: Use GROUP BY to organize the results by department code.", "Construct the SQL query: Combine the SELECT statement with the SUM function and GROUP BY clause to create the final query."], "gold_sql": "SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT sum(STU_HRS) AS total_hours, DEPT_CODE FROM STUDENT GROUP BY DEPT_CODE", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total credit hours completed by students, grouped by their respective departments. The placeholder in the SELECT clause represents the total credit hours, while the GROUP BY clause organizes the results by department code.\",\n        \"virtual_table\": \"SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code\"\n    }\n}\n"}
{"sample_id": "train.3240", "db_id": "college_1", "question": "Which department offers the most credits all together?", "rationale": ["Identify the relevant tables: COURSE and CLASS, as we need to aggregate credit hours by department.", "Join the COURSE and CLASS tables on the CRS_CODE to link courses to their respective classes.", "Use the SUM function to calculate the total credit hours for each department.", "Group the results by DEPT_CODE to get the total credits per department.", "Order the results in descending order to find the department with the most credits.", "Limit the results to 1 to get only the department with the highest total credits."], "gold_sql": "SELECT T3.dept_name FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code JOIN department AS T3 ON T1.dept_code  =  T3.dept_code GROUP BY T1.dept_code ORDER BY sum(T1.crs_credit) DESC LIMIT 1", "source_tables": ["course", "department", "class"], "pred_sql": "SELECT DEPT_CODE, SUM(CRS_CREDIT) AS TOTAL_CREDITS \nFROM COURSE \nJOIN CLASS ON COURSE.CRS_CODE = CLASS.CRS_CODE \nGROUP BY DEPT_CODE \nORDER BY TOTAL_CREDITS DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables, allowing for the aggregation of credit hours per department.\",\n        \"virtual_table\": \"SELECT sum(T1.crs_credit) ,  T1.dept_code FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY T1.dept_code\"\n    }\n}\n"}
{"sample_id": "train.3243", "db_id": "college_1", "question": "What is the first name of each student enrolled in class ACCT-211?", "rationale": ["Identify the relevant tables: ENROLL, CLASS, and STUDENT.", "We need to find the first names of students enrolled in a specific class, which is identified by the CRS_CODE 'ACCT-211'.", "Join the ENROLL table with the CLASS table on CLASS_CODE to link students to their classes.", "Join the resulting table with the STUDENT table on STU_NUM to access student details.", "Select the STU_FNAME column from the STUDENT table where the class code matches 'ACCT-211'."], "gold_sql": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  'ACCT-211'", "source_tables": ["student", "class", "enroll"], "pred_sql": "SELECT STUDENT.STU_FNAME FROM ENROLL JOIN CLASS ON ENROLL.CLASS_CODE = CLASS.CLASS_CODE JOIN STUDENT ON ENROLL.STU_NUM = STUDENT.STU_NUM WHERE CLASS.CRS_CODE = 'ACCT-211';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description ,  T5.dept_name FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num JOIN department AS T5 ON T4.dept_code  =  T5.dept_code\"\n    }\n}\n"}
{"sample_id": "train.3245", "db_id": "college_1", "question": "What is the first name of students enrolled in class ACCT-211 and got grade C?", "rationale": ["Identify the tables needed: STUDENT, ENROLL, and CLASS are required to get the first names of students enrolled in a specific class and their grades.", "The STUDENT table contains the first names of students, while the ENROLL table links students to their enrolled classes and their grades.", "The CLASS table provides the class code to filter the results to only those enrolled in 'ACCT-211'.", "Join the STUDENT table with the ENROLL table on the student number (STU_NUM) to get the grades for each student.", "Join the resulting table with the CLASS table on the class code (CLASS_CODE) to filter for the specific class 'ACCT-211'.", "Add a WHERE clause to filter for students who received a grade of 'C'.", "Select the first names of the students that meet these criteria."], "gold_sql": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  'ACCT-211' AND T2.enroll_grade  =  'C'", "source_tables": ["student", "class", "enroll"], "pred_sql": "SELECT STUDENT.STU_FNAME \nFROM STUDENT \nJOIN ENROLL ON STUDENT.STU_NUM = ENROLL.STU_NUM \nJOIN CLASS ON ENROLL.CLASS_CODE = CLASS.CLASS_CODE \nWHERE CLASS.CLASS_CODE = 'ACCT-211' AND ENROLL.ENROLL_GRADE = 'C';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total credit hours completed by students, grouped by their respective departments. The placeholder in the SELECT clause represents the total credit hours, while the GROUP BY clause organizes the results by department code.\",\n        \"virtual_table\": \"SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code\"\n    }\n}\n"}
{"sample_id": "train.3254", "db_id": "college_1", "question": "What is the name of the department with the most students enrolled?", "rationale": ["To find the department with the most students enrolled, we first need to count the number of students in each department.", "We can use the provided virtual table to count students grouped by their department codes: `SELECT count(*), dept_code FROM student GROUP BY dept_code`.", "Next, we need to join this result with the DEPARTMENT table to get the department names corresponding to the department codes.", "We will join the DEPARTMENT table on the DEPT_CODE column with the result of our student count query.", "To find the department with the most students, we will order the results by the student count in descending order and limit the results to 1."], "gold_sql": "SELECT T4.dept_name FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code GROUP BY T3.dept_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["course", "department", "class", "enroll"], "pred_sql": "SELECT d.DEPT_NAME\nFROM DEPARTMENT d\nJOIN (\n    SELECT count(*) as student_count, dept_code \n    FROM STUDENT \n    GROUP BY dept_code\n) as dept_student_count ON d.DEPT_CODE = dept_student_count.dept_code\nORDER BY student_count DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of students grouped by their department codes from the 'student' table. The placeholder in the SELECT statement represents the department code for which the count of students is being aggregated.\",\n        \"virtual_table\": \"SELECT count(*) ,  dept_code FROM student GROUP BY dept_code\"\n    }\n}\n"}
{"sample_id": "train.3257", "db_id": "college_1", "question": "List the codes of all courses that take place in room KLR209.", "rationale": ["Identify the relevant table: The CLASS table contains information about class schedules, including the room where each class is held.", "Determine the specific column needed: We need the CLASS_ROOM column to filter for classes held in room KLR209.", "Select the course codes: The CRS_CODE column in the CLASS table will provide the course codes for the classes held in the specified room.", "Use DISTINCT to ensure unique course codes are returned, as multiple sections of the same course may be held in the same room."], "gold_sql": "SELECT class_code FROM CLASS WHERE class_room  =  'KLR209'", "source_tables": ["class"], "pred_sql": "SELECT DISTINCT CLASS.CRS_CODE\nFROM CLASS\nWHERE CLASS.CLASS_ROOM = 'KLR209';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables, allowing for the aggregation of credit hours per department.\",\n        \"virtual_table\": \"SELECT sum(T1.crs_credit) ,  T1.dept_code FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY T1.dept_code\"\n    }\n}\n"}
{"sample_id": "train.3258", "db_id": "college_1", "question": "What are the codes of all the courses that are located in room KLR209?", "rationale": ["Identify the relevant table: The CLASS table contains information about class locations, including the CLASS_ROOM column.", "Determine the specific condition: We need to filter the results to only include classes held in room 'KLR209'.", "Select the desired output: We want the unique course codes (CRS_CODE) associated with the classes in that room.", "Construct the SQL query: Use SELECT DISTINCT to get unique course codes from the CLASS table where the CLASS_ROOM matches 'KLR209'."], "gold_sql": "SELECT class_code FROM CLASS WHERE class_room  =  'KLR209'", "source_tables": ["class"], "pred_sql": "SELECT DISTINCT CLASS.CRS_CODE \nFROM CLASS \nWHERE CLASS.CLASS_ROOM = 'KLR209';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables, allowing for the aggregation of credit hours per department.\",\n        \"virtual_table\": \"SELECT sum(T1.crs_credit) ,  T1.dept_code FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY T1.dept_code\"\n    }\n}\n"}
{"sample_id": "train.3267", "db_id": "college_1", "question": "What is the first name of students who got grade C in any class?", "rationale": ["Identify the relevant tables: STUDENT and ENROLL are needed since we want student names and their grades.", "We need to join the STUDENT table with the ENROLL table on the student number (STU_NUM) to access the grades associated with each student.", "We are specifically looking for students who received a grade of 'C', so we will filter the results using a WHERE clause on the ENROLL_GRADE column.", "To avoid duplicate names, we will use DISTINCT to ensure each student's first name appears only once in the result."], "gold_sql": "SELECT DISTINCT stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE enroll_grade  =  'C'", "source_tables": ["enroll", "student"], "pred_sql": "SELECT DISTINCT STUDENT.STU_FNAME \nFROM STUDENT \nJOIN ENROLL ON STUDENT.STU_NUM = ENROLL.STU_NUM \nWHERE ENROLL.ENROLL_GRADE = 'C';", "hint": "\n"}
{"sample_id": "train.3273", "db_id": "college_1", "question": "What are the first names of the professors who do not teach a class.", "rationale": ["Identify the relevant tables: We need to find professors and their teaching status, so we will use the EMPLOYEE and CLASS tables.", "We need the first names of professors, which are in the EMPLOYEE table under the column 'emp_fname'.", "To find professors who do not teach a class, we need to check which professors are not present in the CLASS table. This can be done using a subquery that selects 'prof_num' from the CLASS table.", "The main query will select 'emp_fname' from the EMPLOYEE table where 'emp_num' is not in the list of 'prof_num' from the CLASS table."], "gold_sql": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  'PROF' EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num", "source_tables": ["employee", "class"], "pred_sql": "SELECT emp_fname FROM EMPLOYEE WHERE emp_num NOT IN (SELECT prof_num FROM CLASS)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description ,  T5.dept_name FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num JOIN department AS T5 ON T4.dept_code  =  T5.dept_code\"\n    }\n}\n"}
{"sample_id": "train.3274", "db_id": "college_1", "question": "What are the first names of all professors not teaching any classes?", "rationale": ["Identify the table that contains professor information, which is the PROFESSOR table.", "We need to find professors who are not teaching any classes, so we will check the CLASS table for any entries associated with each professor.", "We can use a subquery to select all professor numbers (prof_num) from the CLASS table.", "The main query will select the first names (emp_fname) of professors whose employee numbers (emp_num) are not in the list obtained from the subquery."], "gold_sql": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  'PROF' EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num", "source_tables": ["employee", "class"], "pred_sql": "SELECT emp_fname FROM PROFESSOR WHERE emp_num NOT IN (SELECT prof_num FROM CLASS)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description ,  T5.dept_name FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num JOIN department AS T5 ON T4.dept_code  =  T5.dept_code\"\n    }\n}\n"}
{"sample_id": "train.3288", "db_id": "college_1", "question": "How many professors attained either Ph.D. or Masters degrees?", "rationale": ["Identify the relevant table: The PROFESSOR table contains information about professors, including their highest degree obtained.", "Determine the condition: We need to count professors who have either a Ph.D. or a Masters degree.", "Construct the SQL query: Use the COUNT function to count the number of professors meeting the condition, filtering with a WHERE clause that checks if PROF_HIGH_DEGREE is either 'Ph.D.' or 'Masters'."], "gold_sql": "SELECT count(*) FROM professor WHERE prof_high_degree  =  'Ph.D.' OR prof_high_degree  =  'MA'", "source_tables": ["professor"], "pred_sql": "SELECT COUNT(*) FROM PROFESSOR WHERE PROF_HIGH_DEGREE IN ('Ph.D.', 'Masters');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description ,  T5.dept_name FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num JOIN department AS T5 ON T4.dept_code  =  T5.dept_code\"\n    }\n}\n"}
{"sample_id": "train.3292", "db_id": "college_1", "question": "What is the first name of the professor who is teaching CIS-220 and QM-261?", "rationale": ["Identify the relevant tables: CLASS, EMPLOYEE, COURSE, PROFESSOR, and DEPARTMENT.", "Join the CLASS table with EMPLOYEE to get the professor's first name.", "Join the CLASS table with COURSE to filter by the course codes 'CIS-220' and 'QM-261'.", "Join with PROFESSOR to ensure we are getting the correct professors for the classes.", "Join with DEPARTMENT to gather any additional department information if needed, although it's not required for the final output.", "Use a WHERE clause to filter the results to only include the specified course codes."], "gold_sql": "SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  'CIS-220' INTERSECT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  'QM-261'", "source_tables": ["employee", "class"], "pred_sql": "SELECT T2.emp_fname FROM CLASS AS T1 JOIN EMPLOYEE AS T2 ON T1.PROF_NUM = T2.EMP_NUM JOIN COURSE AS T3 ON T1.CRS_CODE = T3.CRS_CODE JOIN PROFESSOR AS T4 ON T2.EMP_NUM = T4.EMP_NUM JOIN DEPARTMENT AS T5 ON T4.DEPT_CODE = T5.DEPT_CODE WHERE T3.CRS_CODE IN ('CIS-220', 'QM-261')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description ,  T5.dept_name FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num JOIN department AS T5 ON T4.dept_code  =  T5.dept_code\"\n    }\n}\n"}
{"sample_id": "train.3293", "db_id": "college_1", "question": "Find the first name of student who is taking classes from accounting and Computer Info. Systems departments", "rationale": ["Identify the tables needed: STUDENT, ENROLL, CLASS, COURSE, and DEPARTMENT.", "Join the ENROLL table with STUDENT to get student details.", "Join the CLASS table to link classes with enrollments.", "Join the COURSE table to get course details associated with each class.", "Join the DEPARTMENT table to filter courses by department names.", "Use a WHERE clause to filter departments to 'Accounting' and 'Computer Info. Systems'.", "Select the distinct first names of students who meet the criteria."], "gold_sql": "SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Accounting' INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Computer Info. Systems'", "source_tables": ["course", "enroll", "department", "class", "student"], "pred_sql": "SELECT DISTINCT S.STU_FNAME \nFROM STUDENT AS S \nJOIN ENROLL AS E ON S.STU_NUM = E.STU_NUM \nJOIN CLASS AS C ON E.CLASS_CODE = C.CLASS_CODE \nJOIN COURSE AS CRS ON C.CRS_CODE = CRS.CRS_CODE \nJOIN DEPARTMENT AS D ON CRS.DEPT_CODE = D.DEPT_CODE \nWHERE D.DEPT_NAME IN ('Accounting', 'Computer Info. Systems');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description ,  T5.dept_name FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num JOIN department AS T5 ON T4.dept_code  =  T5.dept_code\"\n    }\n}\n"}
{"sample_id": "train.3308", "db_id": "college_1", "question": "What are the first names and office of the professors who are in the history department and have a Ph.D?", "rationale": ["Identify the relevant tables: CLASS, EMPLOYEE, PROFESSOR, and DEPARTMENT.", "Join the CLASS table with the EMPLOYEE table to get the first names of professors.", "Join the EMPLOYEE table with the PROFESSOR table to get office details.", "Join the PROFESSOR table with the DEPARTMENT table to filter by department name (History) and highest degree (Ph.D).", "Select the first names and office locations of the professors who meet the criteria."], "gold_sql": "SELECT T1.emp_fname ,  T2.prof_office FROM employee AS T1 JOIN professor AS T2 ON T1.emp_num  =  T2.emp_num JOIN department AS T3 ON T3.dept_code  =  T2.dept_code WHERE T3.dept_name  =  'History' AND T2.prof_high_degree  =  'Ph.D.'", "source_tables": ["employee", "professor", "department"], "pred_sql": "SELECT T2.emp_fname, T4.prof_office FROM CLASS AS T1 JOIN EMPLOYEE AS T2 ON T1.PROF_NUM = T2.EMP_NUM JOIN PROFESSOR AS T4 ON T2.EMP_NUM = T4.EMP_NUM JOIN DEPARTMENT AS T5 ON T4.DEPT_CODE = T5.DEPT_CODE WHERE T5.DEPT_NAME = 'History' AND T4.PROF_HIGH_DEGREE = 'Ph.D';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description ,  T5.dept_name FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num JOIN department AS T5 ON T4.dept_code  =  T5.dept_code\"\n    }\n}\n"}
{"sample_id": "train.3319", "db_id": "college_1", "question": "Find names of all students who took some course and got A or C.", "rationale": ["Identify the tables needed: STUDENT for student names and ENROLL for enrollment details including grades.", "We need to find students who received either an 'A' or 'C' grade, so we will filter the ENROLL table based on the ENROLL_GRADE column.", "To get the names of the students, we will select the first and last names from the STUDENT table.", "We will join the STUDENT table with the ENROLL table on the student number (STU_NUM) to link students with their grades.", "Finally, we will use DISTINCT to ensure that each student's name appears only once in the result, even if they took multiple courses with qualifying grades."], "gold_sql": "SELECT T1.stu_fname ,  T1.stu_lname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE T2.enroll_grade  =  'C' OR T2.enroll_grade  =  'A'", "source_tables": ["enroll", "student"], "pred_sql": "SELECT DISTINCT S.STU_FNAME, S.STU_LNAME \nFROM STUDENT S \nJOIN ENROLL E ON S.STU_NUM = E.STU_NUM \nWHERE E.ENROLL_GRADE IN ('A', 'C');", "hint": "\n"}
{"sample_id": "train.3324", "db_id": "college_1", "question": "What are the different first names and highest degree attained for professors teaching in the Computer Information Systems department?", "rationale": ["Identify the relevant tables: CLASS, EMPLOYEE, PROFESSOR, and DEPARTMENT.", "We need to get the first names of professors and their highest degree, so we will select T2.emp_fname and T4.prof_high_degree.", "Join the CLASS table with EMPLOYEE to get the professor's first name using the professor number.", "Join the PROFESSOR table to access the highest degree of the professors.", "Join the DEPARTMENT table to filter for the Computer Information Systems department.", "Use a WHERE clause to specify that we only want professors from the Computer Information Systems department."], "gold_sql": "SELECT DISTINCT T2.emp_fname ,  T3.prof_high_degree FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN professor AS T3 ON T2.emp_num  =  T3.emp_num JOIN department AS T4 ON T4.dept_code  =  T3.dept_code WHERE T4.dept_name  =  'Computer Info. Systems'", "source_tables": ["employee", "professor", "class", "department"], "pred_sql": "SELECT T2.emp_fname, T4.prof_high_degree \nFROM CLASS AS T1 \nJOIN EMPLOYEE AS T2 ON T1.prof_num = T2.emp_num \nJOIN PROFESSOR AS T4 ON T2.emp_num = T4.emp_num \nJOIN DEPARTMENT AS T5 ON T4.dept_code = T5.dept_code \nWHERE T5.dept_name = 'Computer Information Systems'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description ,  T5.dept_name FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num JOIN department AS T5 ON T4.dept_code  =  T5.dept_code\"\n    }\n}\n"}
{"sample_id": "train.3333", "db_id": "college_1", "question": "Find the name of department that offers the class whose description has the word \"Statistics\".", "rationale": ["Identify the relevant tables: We need to find the department name, which is in the DEPARTMENT table, and we need to filter classes based on their descriptions, which are in the COURSE table.", "Join the DEPARTMENT and COURSE tables: We will join these tables on the DEPT_CODE to link courses to their respective departments.", "Filter the courses: We need to filter the courses to only those whose description contains the word 'Statistics'.", "Select the department name: Finally, we will select the distinct department names that meet the criteria."], "gold_sql": "SELECT T2.dept_name FROM course AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.crs_description LIKE '%Statistics%'", "source_tables": ["course", "department"], "pred_sql": "SELECT DISTINCT D.DEPT_NAME \nFROM DEPARTMENT D \nJOIN COURSE C ON D.DEPT_CODE = C.DEPT_CODE \nWHERE C.CRS_DESCRIPTION LIKE '%Statistics%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of classes grouped by department code from the 'CLASS' and 'COURSE' tables. The placeholder in the SELECT statement represents the count of classes for each department.\",\n        \"virtual_table\": \"SELECT count(*) ,  dept_code FROM CLASS AS T1 JOIN course AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY dept_code\"\n    }\n}\n"}
{"sample_id": "train.3343", "db_id": "sports_competition", "question": "What are the types and countries of competitions?", "rationale": ["The question asks for the types and countries of competitions.", "We need to select the 'Competition_type' and 'Country' columns from the 'competition' table.", "To ensure we get unique combinations of competition types and their respective countries, we will use the GROUP BY clause on both 'Competition_type' and 'Country'."], "gold_sql": "SELECT Competition_type ,  Country FROM competition", "source_tables": ["competition"], "pred_sql": "SELECT Competition_type, Country FROM competition GROUP BY Competition_type, Country", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the types of competitions held, grouped by their type, and orders them by the number of occurrences in descending order. The placeholder in the LIMIT clause represents the maximum number of competition types to display.\",\n        \"virtual_table\": \"SELECT Competition_type FROM competition GROUP BY Competition_type ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3355", "db_id": "sports_competition", "question": "Please show the names and the players of clubs.", "rationale": ["Identify the tables needed: 'club' for club names and 'player' for player names.", "Determine the relationship between the tables: 'player' has a foreign key 'Club_ID' that references 'club'.", "Use a JOIN operation to combine data from both tables based on the 'Club_ID'.", "Select the desired columns: the name of the club and the name of the player."], "gold_sql": "SELECT T1.name ,  T2.Player_id FROM club AS T1 JOIN player AS T2 ON T1.Club_ID  =  T2.Club_ID", "source_tables": ["club", "player"], "pred_sql": "SELECT c.name AS club_name, p.name AS player_name \nFROM club c \nJOIN player p ON c.Club_ID = p.Club_ID;", "hint": "\n"}
{"sample_id": "train.3364", "db_id": "sports_competition", "question": "What are the positions of players whose average number of points scored by that position is larger than 20?", "rationale": ["Identify the relevant table: The 'player' table contains the information about players and their positions.", "Determine the required calculation: We need to calculate the average number of points scored by players in each position.", "Group the results: Use GROUP BY to group the players by their Position.", "Filter the results: Use HAVING to filter out positions where the average points scored is greater than 20."], "gold_sql": "SELECT POSITION FROM player GROUP BY name HAVING avg(Points)  >=  20", "source_tables": ["player"], "pred_sql": "SELECT Position FROM player GROUP BY Position HAVING AVG(Points) > 20;", "hint": "\n"}
{"sample_id": "train.3374", "db_id": "sports_competition", "question": "What are the positions of both players that have more than 20 20 points and less than 10 points?", "rationale": ["Identify the table that contains player information, which is the 'player' table.", "Determine the relevant column for player positions, which is 'Position'.", "Identify the column that contains the points scored by players, which is 'Points'.", "Formulate the condition to filter players based on their points: greater than 20 or less than 10.", "Construct the SQL SELECT statement to retrieve the 'Position' of players that meet the specified conditions."], "gold_sql": "SELECT POSITION FROM player WHERE Points  >  20 INTERSECT SELECT POSITION FROM player WHERE Points  <  10", "source_tables": ["player"], "pred_sql": "SELECT Position FROM player WHERE Points > 20 OR Points < 10;", "hint": "\n"}
{"sample_id": "train.3383", "db_id": "sports_competition", "question": "which country did participated in the most number of Tournament competitions?", "rationale": ["Identify the relevant table: The 'competition' table contains information about the competitions, including their type and country.", "Filter for tournament competitions: We need to focus on competitions where the Competition_type is 'tournament'.", "Group by country: To find out how many tournaments each country participated in, we will group the results by the 'Country' column.", "Count the number of tournaments: We will count the number of occurrences for each country using COUNT(*).", "Order the results: We will order the results in descending order based on the count of tournaments to find the country with the most tournaments.", "Limit the results: Finally, we will limit the results to 1 to get the country with the highest count."], "gold_sql": "SELECT country FROM competition WHERE competition_type  =  'Tournament' GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["competition"], "pred_sql": "SELECT Country, COUNT(*) as Tournament_Count \nFROM competition \nWHERE Competition_type = 'tournament' \nGROUP BY Country \nORDER BY Tournament_Count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the types of competitions held, grouped by their type, and orders them by the number of occurrences in descending order. The placeholder in the LIMIT clause represents the maximum number of competition types to display.\",\n        \"virtual_table\": \"SELECT Competition_type FROM competition GROUP BY Competition_type ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3384", "db_id": "sports_competition", "question": "what is the name of the country that participated in the most tournament competitions?", "rationale": ["Identify the relevant table: The 'competition' table contains information about the competitions, including their type and country.", "Filter for tournament competitions: We need to focus on competitions that are of type 'tournament'.", "Group by country: To find out which country participated in the most tournaments, we will group the results by the 'Country' column.", "Count the occurrences: We will count the number of tournaments for each country to determine participation levels.", "Order by count: We will order the results in descending order to get the country with the highest participation at the top.", "Limit the results: Finally, we will limit the results to just one entry to get the country with the most tournament participations."], "gold_sql": "SELECT country FROM competition WHERE competition_type  =  'Tournament' GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["competition"], "pred_sql": "SELECT Country FROM competition WHERE Competition_type = 'tournament' GROUP BY Country ORDER BY COUNT(*) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the types of competitions held, grouped by their type, and orders them by the number of occurrences in descending order. The placeholder in the LIMIT clause represents the maximum number of competition types to display.\",\n        \"virtual_table\": \"SELECT Competition_type FROM competition GROUP BY Competition_type ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3388", "db_id": "sports_competition", "question": "What are the countries that have never participated in any friendly-type competitions?", "rationale": ["We need to find countries that have never participated in friendly-type competitions.", "First, we will select distinct countries from the competition table.", "We will use a LEFT JOIN with the competition_result table to find any associated results for friendly competitions.", "We will filter the results to only include competitions of type 'friendly'.", "To find countries that have never participated, we will check for NULL values in both Club_ID_1 and Club_ID_2 from the competition_result table, indicating no participation."], "gold_sql": "SELECT country FROM competition EXCEPT SELECT country FROM competition WHERE competition_type  =  'Friendly'", "source_tables": ["competition"], "pred_sql": "SELECT DISTINCT c.Country \nFROM competition c \nLEFT JOIN competition_result cr ON c.Competition_ID = cr.Competition_ID \nWHERE c.Competition_type = 'friendly' \nAND cr.Club_ID_1 IS NULL \nAND cr.Club_ID_2 IS NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the types of competitions held, grouped by their type, and orders them by the number of occurrences in descending order. The placeholder in the LIMIT clause represents the maximum number of competition types to display.\",\n        \"virtual_table\": \"SELECT Competition_type FROM competition GROUP BY Competition_type ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3407", "db_id": "hr_1", "question": "List the full name (first and last name), and salary for those employees who earn below 6000.", "rationale": ["Identify the relevant table: The 'employees' table contains the necessary information about employees' names and salaries.", "Determine the required fields: We need the first name, last name, and salary of employees.", "Set the condition: We want to filter employees who earn below 6000.", "Construct the SQL query: Using the SELECT statement to retrieve the specified fields from the 'employees' table with the appropriate WHERE clause."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees WHERE salary  <  6000", "source_tables": ["employees"], "pred_sql": "SELECT FIRST_NAME, LAST_NAME, SALARY FROM employees WHERE SALARY < 6000", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names, last names, and salaries of employees from the 'employees' table who earn less than a specified salary. The placeholder in the WHERE clause represents the salary threshold.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  salary FROM employees WHERE salary  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3418", "db_id": "hr_1", "question": "What are the full name, hire date, salary, and department id for employees without the letter M in their first name?", "rationale": ["Identify the required fields: full name (first and last name), hire date, salary, and department id.", "To get the full name, we can concatenate the first name and last name of the employee.", "We need to filter employees whose first name does not contain the letter 'M'.", "The relevant table for employee information is the 'employees' table.", "Construct the SQL query to select the required fields from the 'employees' table with the specified condition."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%'", "source_tables": ["employees"], "pred_sql": "SELECT CONCAT(e.FIRST_NAME, ' ', e.LAST_NAME) AS full_name, e.HIRE_DATE, e.SALARY, e.DEPARTMENT_ID \nFROM employees AS e \nWHERE e.FIRST_NAME NOT LIKE '%M%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name ,  T2.department_name ,  T3.city ,  T3.state_province FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id\"\n    }\n}\n"}
{"sample_id": "train.3419", "db_id": "hr_1", "question": "display the full name (first and last), hire date, salary, and department number for those employees whose first name does not containing the letter M and make the result set in ascending order by department number.", "rationale": ["Identify the required fields: first name, last name, hire date, salary, and department number.", "Filter employees whose first name does not contain the letter 'M'.", "Sort the results in ascending order by department number.", "Construct the SQL query using the SELECT statement with the appropriate WHERE clause and ORDER BY clause."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT first_name, last_name, hire_date, department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id ASC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name ,  T2.department_name ,  T3.city ,  T3.state_province FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id\"\n    }\n}\n"}
{"sample_id": "train.3420", "db_id": "hr_1", "question": "What are the full name, hire data, salary and department id for employees without the letter M in their first name, ordered by ascending department id?", "rationale": ["Identify the required fields: full name (first and last), hire date, salary, and department id.", "To create the full name, concatenate the first name and last name using '||'.", "Filter employees whose first name does not contain the letter 'M' using the NOT LIKE operator.", "Order the results by department id in ascending order.", "Construct the SQL SELECT statement with the identified fields and conditions."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, HIRE_DATE, SALARY, DEPARTMENT_ID \nFROM employees \nWHERE FIRST_NAME NOT LIKE '%M%' \nORDER BY DEPARTMENT_ID ASC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name ,  T2.department_name ,  T3.city ,  T3.state_province FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id\"\n    }\n}\n"}
{"sample_id": "train.3442", "db_id": "hr_1", "question": "Which job titles correspond to jobs with salaries over 9000?", "rationale": ["Identify the relevant table: The 'jobs' table contains information about job titles and their corresponding salary ranges.", "Determine the condition: We need to find jobs with salaries over 9000, which means we should check both the 'MIN_SALARY' and 'MAX_SALARY' columns.", "Construct the SQL query: We will select the 'JOB_TITLE' from the 'jobs' table where either 'MIN_SALARY' or 'MAX_SALARY' is greater than 9000."], "gold_sql": "SELECT job_title FROM jobs WHERE min_salary  >  9000", "source_tables": ["jobs"], "pred_sql": "SELECT JOB_TITLE FROM jobs WHERE MIN_SALARY > 9000 OR MAX_SALARY > 9000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of employees from the 'employees' table who earn more than a specific employee's salary. The placeholder in the subquery represents the unique identifier of the employee whose salary is being compared.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name FROM employees WHERE salary  >  (SELECT salary FROM employees WHERE employee_id = [PLACEHOLDER-TYPE:NUMBER] )\"\n    }\n}\n"}
{"sample_id": "train.3444", "db_id": "hr_1", "question": "What are the job titles, and range of salaries for jobs with maximum salary between 12000 and 18000?", "rationale": ["Identify the relevant table: The question asks for job titles and salary ranges, which are found in the 'jobs' table.", "Determine the columns needed: We need 'JOB_TITLE', 'MIN_SALARY', and 'MAX_SALARY' from the 'jobs' table.", "Apply the condition: The question specifies that we want jobs with a maximum salary between 12000 and 18000, so we will use a WHERE clause to filter the results based on 'MAX_SALARY'.", "Construct the SQL query: Combine the selected columns and the condition into a complete SQL statement."], "gold_sql": "SELECT job_title ,  max_salary - min_salary FROM jobs WHERE max_salary BETWEEN 12000 AND 18000", "source_tables": ["jobs"], "pred_sql": "SELECT JOB_TITLE, MIN_SALARY, MAX_SALARY FROM jobs WHERE MAX_SALARY BETWEEN 12000 AND 18000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of employees from the 'employees' table who earn more than a specific employee's salary. The placeholder in the subquery represents the unique identifier of the employee whose salary is being compared.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name FROM employees WHERE salary  >  (SELECT salary FROM employees WHERE employee_id = [PLACEHOLDER-TYPE:NUMBER] )\"\n    }\n}\n"}
{"sample_id": "train.3448", "db_id": "hr_1", "question": "What are the employee ids for each employee and final dates of employment at their last job?", "rationale": ["Identify the relevant table: The 'job_history' table contains the employment history of employees, including their end dates.", "Determine the required information: We need the employee IDs and the final dates of employment at their last job.", "Use the MAX function: To find the last job end date for each employee, we can use the MAX function on the 'end_date' column.", "Group by employee: To ensure we get the last end date for each employee, we will group the results by 'employee_id'.", "Construct the SQL query: Combine the selected columns and functions into a complete SQL query."], "gold_sql": "SELECT employee_id ,  MAX(end_date) FROM job_history GROUP BY employee_id", "source_tables": ["job_history"], "pred_sql": "SELECT employee_id, MAX(end_date) FROM job_history GROUP BY employee_id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the most recent job end dates for each employee from the 'job_history' table. The placeholder in the SELECT clause represents the employee's unique identifier, while the MAX function is used to retrieve the latest end date for each employee's job history.\",\n        \"virtual_table\": \"SELECT employee_id ,  MAX(end_date) FROM job_history GROUP BY employee_id\"\n    }\n}\n"}
{"sample_id": "train.3453", "db_id": "hr_1", "question": "display the average salary of employees for each department who gets a commission percentage.", "rationale": ["Identify the relevant tables: employees and departments are needed to get the average salary per department.", "We need to calculate the average salary, so we will use the AVG() function on the SALARY column from the employees table.", "To filter employees who receive a commission percentage, we will add a WHERE clause to check if COMMISSION_PCT is not NULL.", "We will join the employees table with the departments table on the DEPARTMENT_ID to get the department information for each employee.", "Finally, we will group the results by DEPARTMENT_ID to get the average salary for each department."], "gold_sql": "SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != 'null' GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT d.DEPARTMENT_ID, AVG(e.SALARY) AS average_salary\nFROM employees e\nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID\nWHERE e.COMMISSION_PCT IS NOT NULL\nGROUP BY d.DEPARTMENT_ID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the minimum salary for each department from the 'employees' table. The placeholder in the SELECT clause represents the salary values, while the GROUP BY clause organizes the results by department identifier.\",\n        \"virtual_table\": \"SELECT MIN(salary) ,  department_id FROM employees GROUP BY department_id\"\n    }\n}\n"}
{"sample_id": "train.3454", "db_id": "hr_1", "question": "What is the average salary of employees who have a commission percentage that is not null?", "rationale": ["Identify the table needed: The 'employees' table contains the salary and commission percentage information.", "Determine the condition: We need to filter employees whose commission percentage is not null, which can be done using the WHERE clause.", "Calculate the average salary: Use the AVG() function to compute the average salary of the filtered employees.", "Construct the SQL query: Combine the SELECT statement with the AVG function and the WHERE clause to form the complete SQL query."], "gold_sql": "SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != 'null' GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT AVG(SALARY) AS average_salary FROM employees WHERE COMMISSION_PCT IS NOT NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names, last names, and salaries of employees from the 'employees' table who earn less than a specified salary. The placeholder in the WHERE clause represents the salary threshold.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  salary FROM employees WHERE salary  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3455", "db_id": "hr_1", "question": "display the country ID and number of cities for each country.", "rationale": ["Identify the required columns: COUNTRY_ID from countries and the count of cities from locations.", "To get the number of cities for each country, we need to join the countries table with the locations table on the COUNTRY_ID.", "Use the COUNT function to count the number of cities for each country.", "Group the results by COUNTRY_ID to ensure we get a count for each country."], "gold_sql": "SELECT country_id ,  COUNT(*) FROM locations GROUP BY country_id", "source_tables": ["locations"], "pred_sql": "SELECT countries.COUNTRY_ID, COUNT(locations.CITY) AS number_of_cities\nFROM countries\nJOIN locations ON countries.COUNTRY_ID = locations.COUNTRY_ID\nGROUP BY countries.COUNTRY_ID;", "hint": "\n"}
{"sample_id": "train.3456", "db_id": "hr_1", "question": "Give the country id and corresponding count of cities in each country.", "rationale": ["Identify the tables needed: 'countries' for country information and 'locations' for city information.", "Determine the relationship between the tables: 'locations' has a foreign key 'COUNTRY_ID' that links to 'countries'.", "Use a JOIN to combine 'countries' and 'locations' on 'COUNTRY_ID'.", "Count the number of cities (from 'locations') for each country (from 'countries').", "Group the results by 'COUNTRY_ID' to get the count for each country."], "gold_sql": "SELECT country_id ,  COUNT(*) FROM locations GROUP BY country_id", "source_tables": ["locations"], "pred_sql": "SELECT c.COUNTRY_ID, COUNT(l.CITY) AS CITY_COUNT\nFROM countries c\nJOIN locations l ON c.COUNTRY_ID = l.COUNTRY_ID\nGROUP BY c.COUNTRY_ID;", "hint": "\n"}
{"sample_id": "train.3465", "db_id": "hr_1", "question": "Can you return all detailed info of jobs which was done by any of the employees who is presently earning a salary on and above 12000?", "rationale": ["The query needs to return detailed information about jobs.", "We need to find jobs that have been done by employees who currently earn a salary of 12000 or more.", "To do this, we will first select the employee IDs from the 'employees' table where the salary is greater than or equal to 12000.", "Next, we will use these employee IDs to find the job IDs from the 'job_history' table, which records the jobs held by employees.", "Finally, we will select all columns from the 'jobs' table where the JOB_ID matches those found in the job history for the selected employees."], "gold_sql": "SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  12000", "source_tables": ["job_history", "employees"], "pred_sql": "SELECT jobs.* FROM jobs WHERE jobs.JOB_ID IN (SELECT job_history.JOB_ID FROM job_history WHERE job_history.EMPLOYEE_ID IN (SELECT employees.EMPLOYEE_ID FROM employees WHERE employees.SALARY >= 12000))", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of employees from the 'employees' table who earn more than a specific employee's salary. The placeholder in the subquery represents the unique identifier of the employee whose salary is being compared.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name FROM employees WHERE salary  >  (SELECT salary FROM employees WHERE employee_id = [PLACEHOLDER-TYPE:NUMBER] )\"\n    }\n}\n"}
{"sample_id": "train.3482", "db_id": "hr_1", "question": "What is all the information regarding employees who are managers?", "rationale": ["Identify the requirement: We need information about employees who are managers.", "To find employees who are managers, we can look for employees whose IDs appear in the manager_id field of the employees table.", "We will use a subquery to select distinct manager_ids from the employees table.", "We will join the employees table with the departments and locations tables to get the department names and location details.", "The final query will select the first name, last name, department name, city, and state/province of those employees who are managers."], "gold_sql": "SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T1.employee_id  =  T2.manager_id", "source_tables": ["employees", "departments"], "pred_sql": "SELECT T1.first_name, T1.last_name, T2.department_name, T3.city, T3.state_province \nFROM employees AS T1 \nJOIN departments AS T2 ON T1.department_id = T2.department_id \nJOIN locations AS T3 ON T2.location_id = T3.location_id \nWHERE T1.employee_id IN (SELECT DISTINCT manager_id FROM employees WHERE manager_id IS NOT NULL);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name ,  T2.department_name ,  T3.city ,  T3.state_province FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id\"\n    }\n}\n"}
{"sample_id": "train.3487", "db_id": "hr_1", "question": "What are the unique ids of those departments where any manager is managing 4 or more employees.", "rationale": ["We need to find departments where any manager is managing 4 or more employees.", "To do this, we will join the 'departments' table with the 'employees' table on the 'DEPARTMENT_ID'.", "We will group the results by 'DEPARTMENT_ID' to count the number of employees in each department.", "Using the HAVING clause, we will filter the groups to only include those with 4 or more employees.", "Finally, we will select the unique 'DEPARTMENT_ID' from the filtered results."], "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"], "pred_sql": "SELECT d.DEPARTMENT_ID \nFROM departments d \nJOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID \nGROUP BY d.DEPARTMENT_ID \nHAVING COUNT(e.EMPLOYEE_ID) >= 4;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of employees from the 'employees' table who belong to specific departments identified by their department IDs. The placeholders in the WHERE clause represent the department IDs to filter the employees accordingly.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name FROM employees WHERE department_id  =  [PLACEHOLDER-TYPE:NUMBER] OR department_id  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3488", "db_id": "hr_1", "question": "Give the distinct department ids of departments in which a manager is in charge of 4 or more employees?", "rationale": ["We need to find departments where a manager is in charge of 4 or more employees.", "To do this, we will first join the 'employees' table with the 'departments' table to get the department information for each employee.", "We will use the COUNT function to count the number of employees in each department.", "We will group the results by department_id to get the count of employees per department.", "Finally, we will filter the results to only include departments with 4 or more employees and select the distinct department ids."], "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"], "pred_sql": "SELECT department_id FROM (SELECT T2.department_id, COUNT(*) AS employee_count FROM employees AS T1 JOIN departments AS T2 ON T1.department_id = T2.department_id GROUP BY T2.department_id) AS dept_counts WHERE employee_count >= 4;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT statement represents the department's name, while the COUNT function calculates the total number of employees per department.\",\n        \"virtual_table\": \"SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name\"\n    }\n}\n"}
{"sample_id": "train.3496", "db_id": "hr_1", "question": "What is all the information regarding employees with salaries above the minimum and under 2500?", "rationale": ["Identify the relevant table: The 'employees' table contains the information about employees, including their salaries.", "Determine the salary conditions: We need to find employees with salaries above the minimum salary defined in the 'jobs' table and below 2500.", "Use a subquery to find the minimum salary: The minimum salary can be obtained from the 'jobs' table using a subquery.", "Construct the SQL query: Combine the conditions to select all columns from the 'employees' table where the salary is greater than the minimum salary and less than 2500."], "gold_sql": "SELECT * FROM employees WHERE salary BETWEEN (SELECT MIN(salary) FROM employees) AND 2500", "source_tables": ["employees"], "pred_sql": "SELECT * FROM employees WHERE salary > (SELECT MIN_SALARY FROM jobs) AND salary < 2500;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names, last names, and salaries of employees from the 'employees' table who earn less than a specified salary. The placeholder in the WHERE clause represents the salary threshold.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  salary FROM employees WHERE salary  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3500", "db_id": "hr_1", "question": "What are the full names and hire dates for employees in the same department as someone with the first name Clara?", "rationale": ["Identify the requirement: We need the full names (first and last) and hire dates of employees who work in the same department as an employee named Clara.", "To find Clara's department, we will first query the employees table to get the department ID for Clara.", "We will then use this department ID to filter employees in the same department.", "The main query will select the first name, last name, and hire date from the employees table, joining with the departments table to ensure we are looking at the correct department.", "The subquery will find the department ID for Clara, which will be used in the main query's WHERE clause."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  (SELECT department_id FROM employees WHERE first_name  =  'Clara')", "source_tables": ["employees"], "pred_sql": "SELECT T1.FIRST_NAME, T1.LAST_NAME, T1.HIRE_DATE \nFROM employees AS T1 \nJOIN departments AS T2 ON T1.DEPARTMENT_ID = T2.DEPARTMENT_ID \nWHERE T2.DEPARTMENT_ID IN (\n    SELECT T3.DEPARTMENT_ID \n    FROM employees AS T3 \n    WHERE T3.FIRST_NAME = 'Clara'\n);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name ,  T2.department_name ,  T3.city ,  T3.state_province FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id\"\n    }\n}\n"}
{"sample_id": "train.3502", "db_id": "hr_1", "question": "What are the full names and hire dates for employees in the same department as someone with the first name Clara, not including Clara?", "rationale": ["Identify the requirement: We need the full names (first and last) and hire dates of employees who are in the same department as an employee named Clara, excluding Clara herself.", "To achieve this, we will need to join the employees table with the departments table to access department information.", "We will use a subquery to find the department_id of Clara, which will allow us to filter employees in the same department.", "The final query will select the first name, last name, and hire date of employees from the employees table, ensuring that we exclude Clara by adding a condition in the WHERE clause."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  ( SELECT department_id FROM employees WHERE first_name  =  'Clara') AND first_name != 'Clara'", "source_tables": ["employees"], "pred_sql": "SELECT T1.first_name, T1.last_name, T1.hire_date \nFROM employees AS T1 \nJOIN departments AS T2 ON T1.department_id = T2.department_id \nWHERE T2.department_id = (SELECT department_id FROM employees WHERE first_name = 'Clara') \nAND T1.first_name != 'Clara';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name ,  T2.department_name ,  T3.city ,  T3.state_province FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id\"\n    }\n}\n"}
{"sample_id": "train.3503", "db_id": "hr_1", "question": "display the employee number and name( first name and last name ) for all employees who work in a department with any employee whose name contains a \u2019T\u2019.", "rationale": ["Identify the main requirement: We need to display the employee number and name (first name and last name) for all employees who work in a department with any employee whose name contains a 'T'.", "To achieve this, we need to find the department IDs of employees whose first or last name contains 'T'.", "We can use a subquery to select distinct department IDs from the employees table where either the first name or last name contains 'T'.", "Next, we will use this subquery in the main query to select the employee ID, first name, and last name of employees who belong to those departments.", "The final SQL query will join these two parts together, ensuring we get the correct employee details based on the department IDs identified in the subquery."], "gold_sql": "SELECT employee_id ,  first_name ,  last_name FROM employees WHERE department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE '%T%' )", "source_tables": ["employees"], "pred_sql": "SELECT e.EMPLOYEE_ID, e.FIRST_NAME, e.LAST_NAME \nFROM employees e \nWHERE e.DEPARTMENT_ID IN (\n    SELECT DISTINCT e2.DEPARTMENT_ID \n    FROM employees e2 \n    WHERE e2.FIRST_NAME LIKE '%T%' OR e2.LAST_NAME LIKE '%T%'\n);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of employees from the 'employees' table who belong to specific departments identified by their department IDs. The placeholders in the WHERE clause represent the department IDs to filter the employees accordingly.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name FROM employees WHERE department_id  =  [PLACEHOLDER-TYPE:NUMBER] OR department_id  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3507", "db_id": "hr_1", "question": "display the employee number and job id for all employees whose salary is smaller than any salary of those employees whose job title is MK_MAN.", "rationale": ["Identify the requirement: We need to display employee number and job id for employees whose salary is less than any salary of those with job title 'MK_MAN'.", "Determine the relevant tables: The 'employees' table contains employee details including salary and job id, while the 'jobs' table contains job titles and their corresponding job ids.", "Create a subquery to find the job id for 'MK_MAN': This involves selecting the job_id from the jobs table where job_title is 'MK_MAN'.", "Create another subquery to find the minimum salary for the job id obtained in the previous step: This will help us compare the salaries of other employees against this minimum salary.", "Combine the subqueries: Use the main query to select employee_id and job_id from the employees table where their salary is less than the minimum salary obtained from the subquery."], "gold_sql": "SELECT employee_id ,  job_id FROM employees WHERE salary  <  ( SELECT min(salary) FROM employees WHERE job_id  =  'MK_MAN' )", "source_tables": ["employees"], "pred_sql": "SELECT employee_id, job_id FROM employees WHERE salary < (SELECT MIN(salary) FROM employees WHERE job_id = (SELECT job_id FROM jobs WHERE job_title = 'MK_MAN'))", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of employee IDs and their corresponding job IDs from the 'employees' table, specifically for those employees whose salary is less than the minimum salary for a specified job. The placeholder in the subquery represents the job identifier for which the minimum salary is being compared.\",\n        \"virtual_table\": \"SELECT employee_id ,  job_id FROM employees WHERE salary  <  ( SELECT min(salary) FROM employees WHERE job_id  =  [PLACEHOLDER-TYPE:STRING] )\"\n    }\n}\n"}
{"sample_id": "train.3512", "db_id": "hr_1", "question": "What are total salaries and department id for each department that has more than 2 employees?", "rationale": ["We need to find the total salaries and department IDs for departments with more than 2 employees.", "To do this, we will join the 'employees' table with the 'departments' table on the DEPARTMENT_ID.", "We will use the SUM function to calculate the total salaries for each department.", "We will group the results by DEPARTMENT_ID to get the total salaries per department.", "To filter the departments that have more than 2 employees, we will use the HAVING clause with COUNT to count the number of employees in each department."], "gold_sql": "SELECT department_id ,  SUM(salary) FROM employees GROUP BY department_id HAVING count(*)  >=  2", "source_tables": ["employees"], "pred_sql": "SELECT T2.DEPARTMENT_ID, SUM(T1.SALARY) AS total_salaries \nFROM employees AS T1 \nJOIN departments AS T2 ON T1.DEPARTMENT_ID = T2.DEPARTMENT_ID \nGROUP BY T2.DEPARTMENT_ID \nHAVING COUNT(T1.EMPLOYEE_ID) > 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT statement represents the department's name, while the COUNT function calculates the total number of employees per department.\",\n        \"virtual_table\": \"SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name\"\n    }\n}\n"}
{"sample_id": "train.3515", "db_id": "hr_1", "question": "display the department ID, full name (first and last name), salary for those employees who is highest salary in every department.", "rationale": ["We need to display the department ID, full name (first and last name), and salary of employees with the highest salary in each department.", "To get the full name, we can concatenate the first name and last name using the '||' operator.", "We will select the department ID and the concatenated full name as 'FULL_NAME'.", "To find the highest salary in each department, we can use a subquery that selects the maximum salary from the employees table, filtered by the department ID.", "The main query will select from the employees table where the salary matches the maximum salary from the subquery for the corresponding department."], "gold_sql": "SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT e.DEPARTMENT_ID, e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.SALARY \nFROM employees e \nWHERE e.SALARY = (SELECT MAX(SALARY) \n                   FROM employees \n                   WHERE DEPARTMENT_ID = e.DEPARTMENT_ID)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of employees from the 'employees' table who belong to specific departments identified by their department IDs. The placeholders in the WHERE clause represent the department IDs to filter the employees accordingly.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name FROM employees WHERE department_id  =  [PLACEHOLDER-TYPE:NUMBER] OR department_id  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3520", "db_id": "hr_1", "question": "What are the full names and cities of employees who have the letter Z in their first names?", "rationale": ["Identify the tables needed: employees, departments, and locations.", "We need to retrieve the first name and last name of employees, which are in the employees table.", "We also need the city of the employees' departments, which requires joining the departments and locations tables.", "The join conditions are: employees to departments on DEPARTMENT_ID, and departments to locations on LOCATION_ID.", "We need to filter the results to only include employees whose first names contain the letter 'Z'.", "Construct the SQL query using the identified tables, joins, and conditions."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T3.city FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id WHERE T1.first_name LIKE '%z%'", "source_tables": ["employees", "departments", "locations"], "pred_sql": "SELECT T1.FIRST_NAME, T1.LAST_NAME, T3.CITY \nFROM employees AS T1 \nJOIN departments AS T2 ON T1.DEPARTMENT_ID = T2.DEPARTMENT_ID \nJOIN locations AS T3 ON T2.LOCATION_ID = T3.LOCATION_ID \nWHERE T1.FIRST_NAME LIKE '%Z%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name ,  T2.department_name ,  T3.city ,  T3.state_province FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id\"\n    }\n}\n"}
{"sample_id": "train.3523", "db_id": "hr_1", "question": "display the full name (first and last name ) of employee with ID and name of the country presently where (s)he is working.", "rationale": ["Identify the tables needed to retrieve the employee's full name and the country they are working in.", "The 'employees' table contains the first and last names of employees.", "The 'departments' table is needed to link employees to their respective departments.", "The 'locations' table provides the location details of the departments, including the country.", "The 'countries' table contains the names of the countries associated with the locations.", "Join the 'employees' table with 'departments', 'locations', and 'countries' to get the required information.", "Use a WHERE clause to filter the results for a specific employee ID."], "gold_sql": "SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id", "source_tables": ["countries", "employees", "departments", "locations"], "pred_sql": "SELECT T1.first_name, T1.last_name, T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id = T2.department_id JOIN locations AS T3 ON T2.location_id = T3.location_id JOIN countries AS T4 ON T3.country_id = T4.country_id WHERE T1.employee_id = ?", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name ,  T2.department_name ,  T3.city ,  T3.state_province FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id\"\n    }\n}\n"}
{"sample_id": "train.3525", "db_id": "hr_1", "question": "display the department name and number of employees in each of the department.", "rationale": ["Identify the tables needed: 'employees' for employee data and 'departments' for department names.", "Join the 'employees' table with the 'departments' table on the common column 'DEPARTMENT_ID'.", "Select the department name from the 'departments' table and count the number of employees from the 'employees' table.", "Group the results by department name to get the count of employees in each department."], "gold_sql": "SELECT department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY department_name", "source_tables": ["employees", "departments"], "pred_sql": "SELECT T2.DEPARTMENT_NAME, COUNT(*) AS NUMBER_OF_EMPLOYEES \nFROM employees AS T1 \nJOIN departments AS T2 ON T1.DEPARTMENT_ID = T2.DEPARTMENT_ID \nGROUP BY T2.DEPARTMENT_NAME;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT statement represents the department's name, while the COUNT function calculates the total number of employees per department.\",\n        \"virtual_table\": \"SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name\"\n    }\n}\n"}
{"sample_id": "train.3526", "db_id": "hr_1", "question": "What are the department names and how many employees work in each of them?", "rationale": ["Identify the tables needed: 'employees' for employee data and 'departments' for department names.", "Determine the relationship between the tables: 'employees' has a foreign key 'DEPARTMENT_ID' that links to 'departments'.", "Use a JOIN operation to combine data from both tables based on the 'DEPARTMENT_ID'.", "Select the department name from the 'departments' table and count the number of employees from the 'employees' table.", "Group the results by department name to get the count of employees in each department."], "gold_sql": "SELECT department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY department_name", "source_tables": ["employees", "departments"], "pred_sql": "SELECT T2.DEPARTMENT_NAME, COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.DEPARTMENT_ID = T2.DEPARTMENT_ID GROUP BY T2.DEPARTMENT_NAME", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT statement represents the department's name, while the COUNT function calculates the total number of employees per department.\",\n        \"virtual_table\": \"SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name\"\n    }\n}\n"}
{"sample_id": "train.3527", "db_id": "hr_1", "question": "display the full name (first and last name), and salary of those employees who working in any department located in London.", "rationale": ["Identify the required information: full name (first and last name) and salary of employees in departments located in London.", "To get the full name, we need to select the FIRST_NAME and LAST_NAME from the employees table.", "The salary can be directly selected from the employees table as well.", "We need to join the employees table with the departments table to link employees to their respective departments using DEPARTMENT_ID.", "Next, we join the departments table with the locations table to find the location of each department using LOCATION_ID.", "Finally, we filter the results to include only those departments that are located in London by using a WHERE clause on the CITY column of the locations table."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  'London'", "source_tables": ["employees", "departments", "locations"], "pred_sql": "SELECT T1.FIRST_NAME, T1.LAST_NAME, T1.SALARY \nFROM employees AS T1 \nJOIN departments AS T2 ON T1.DEPARTMENT_ID = T2.DEPARTMENT_ID \nJOIN locations AS T3 ON T2.LOCATION_ID = T3.LOCATION_ID \nWHERE T3.CITY = 'London';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name ,  T2.department_name ,  T3.city ,  T3.state_province FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id\"\n    }\n}\n"}
{"sample_id": "train.3528", "db_id": "hr_1", "question": "What are full names and salaries of employees working in the city of London?", "rationale": ["Identify the tables needed: employees, departments, and locations.", "We need to retrieve the first name, last name, and salary of employees.", "To get the city information, we need to join the employees table with the departments table and then with the locations table.", "The join condition is based on the department_id and location_id.", "Finally, we filter the results to only include employees who work in the city of London."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  'London'", "source_tables": ["employees", "departments", "locations"], "pred_sql": "SELECT T1.FIRST_NAME, T1.LAST_NAME, T1.SALARY \nFROM employees AS T1 \nJOIN departments AS T2 ON T1.DEPARTMENT_ID = T2.DEPARTMENT_ID \nJOIN locations AS T3 ON T2.LOCATION_ID = T3.LOCATION_ID \nWHERE T3.CITY = 'London'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name ,  T2.department_name ,  T3.city ,  T3.state_province FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id\"\n    }\n}\n"}
{"sample_id": "train.3532", "db_id": "music_1", "question": "Find the id of the song that lasts the longest.", "rationale": ["Identify the table that contains the song information, which is the 'song' table.", "Determine the relevant column for the song duration, which is 'duration'.", "To find the song that lasts the longest, we need to sort the songs by duration in descending order.", "Use the ORDER BY clause to sort the results by 'duration' in descending order.", "To get only the longest song, we will limit the results to 1 using the LIMIT clause.", "Select the 'f_id' column to get the id of the longest song."], "gold_sql": "SELECT f_id FROM files ORDER BY duration DESC LIMIT 1", "source_tables": ["files"], "pred_sql": "SELECT f_id FROM song ORDER BY duration DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.3542", "db_id": "music_1", "question": "What are the names of the artists who sang the shortest song?", "rationale": ["Identify the relevant table: The 'song' table contains information about songs, including their duration and the artist who performed them.", "Determine the goal: We need to find the names of the artists who sang the shortest song.", "Use the ORDER BY clause: To find the shortest song, we can order the songs by their duration in ascending order.", "Limit the results: Since we only want the shortest song, we will limit the results to 1 using LIMIT 1.", "Select the artist's name: We will select the 'artist_name' from the 'song' table for the shortest song."], "gold_sql": "SELECT T1.artist_name FROM song AS T1 JOIN files AS T2 ON T1.f_id  =  T2.f_id ORDER BY T2.duration LIMIT 1", "source_tables": ["files", "song"], "pred_sql": "SELECT artist_name FROM song ORDER BY duration ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names and genders of artists from the 'artist' table who have released songs on a specific date. The placeholder in the WHERE clause represents the release date of the songs.\",\n        \"virtual_table\": \"SELECT T1.artist_name ,  T1.gender FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.releasedate LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3545", "db_id": "music_1", "question": "How many songs have 4 minute duration?", "rationale": ["Identify the relevant table: The 'song' table contains the duration of songs.", "Determine the condition: We need to find songs with a duration of 4 minutes, which is represented as '4:00'.", "Construct the SQL query: Use the COUNT function to count the number of records in the 'song' table that meet the duration condition."], "gold_sql": "SELECT count(*) FROM files WHERE duration LIKE '4:%'", "source_tables": ["files"], "pred_sql": "SELECT COUNT(*) FROM song WHERE duration = '4:00';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.3549", "db_id": "music_1", "question": "What is the average rating of songs produced by female artists?", "rationale": ["Identify the relevant tables: We need to use the 'artist' table to filter by gender and the 'song' table to get the ratings of the songs.", "We need to join the 'artist' table with the 'song' table on the 'artist_name' column to access the ratings of songs produced by female artists.", "Filter the results to include only female artists by adding a WHERE clause that checks if the gender is 'female'.", "Finally, calculate the average rating of the songs using the AVG() function on the 'rating' column from the 'song' table."], "gold_sql": "SELECT avg(T2.rating) FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  'Female'", "source_tables": ["artist", "song"], "pred_sql": "SELECT AVG(T3.rating) AS average_rating FROM artist AS T1 JOIN song AS T3 ON T1.artist_name = T3.artist_name WHERE T1.gender = 'female';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names and genders of artists from the 'artist' table who have released songs on a specific date. The placeholder in the WHERE clause represents the release date of the songs.\",\n        \"virtual_table\": \"SELECT T1.artist_name ,  T1.gender FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.releasedate LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3552", "db_id": "music_1", "question": "Find the file format that is used by the most files.", "rationale": ["We need to find the file format that is used by the most files.", "To do this, we will select the 'formats' column from the 'files' table.", "We will count the number of occurrences of each format using COUNT(*) and alias it as 'file_count'.", "To get the count for each format, we will group the results by the 'formats' column using GROUP BY.", "To find the most used format, we will order the results in descending order based on 'file_count' using ORDER BY file_count DESC.", "Finally, we will limit the results to only the top entry using LIMIT 1."], "gold_sql": "SELECT formats FROM files GROUP BY formats ORDER BY COUNT (*) DESC LIMIT 1", "source_tables": ["files"], "pred_sql": "SELECT formats, COUNT(*) as file_count \nFROM files \nGROUP BY formats \nORDER BY file_count DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3556", "db_id": "music_1", "question": "What is the id of the files that are available in the format of mp4 and a resolution smaller than 1000?", "rationale": ["Identify the table that contains the file information, which is the 'files' table.", "We need to select the 'f_id' column from the 'files' table.", "The condition requires filtering files that are in the 'mp4' format, which can be checked using the 'formats' column with a LIKE clause.", "Additionally, we need to ensure that the 'resolution' is smaller than 1000. Since 'resolution' is stored as text, we will cast it to an integer for comparison.", "Combine these conditions in the WHERE clause to filter the results accordingly."], "gold_sql": "SELECT f_id FROM files WHERE formats  =  'mp4' INTERSECT SELECT f_id FROM song WHERE resolution  <  1000", "source_tables": ["files", "song"], "pred_sql": "SELECT f_id FROM files WHERE formats LIKE '%mp4%' AND CAST(resolution AS INTEGER) < 1000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.3557", "db_id": "music_1", "question": "What is the country of origin of the artist who is female and produced a song in Bangla?", "rationale": ["Identify the relevant tables: We need information from the 'artist' table for the country of origin and the 'song' table to check the language of the song.", "We need to filter artists based on gender (female) and the language of the song (Bangla).", "Join the 'artist' table with the 'song' table on the artist's name to correlate the artist with their songs.", "Construct the SQL query to select the country from the 'artist' table where the artist is female and the song is in Bangla."], "gold_sql": "SELECT T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  'Female' AND T2.languages  =  'bangla'", "source_tables": ["artist", "song"], "pred_sql": "SELECT artist.country FROM artist JOIN song ON artist.artist_name = song.artist_name WHERE artist.gender = 'female' AND song.languages LIKE '%Bangla%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names and genders of artists from the 'artist' table who have released songs on a specific date. The placeholder in the WHERE clause represents the release date of the songs.\",\n        \"virtual_table\": \"SELECT T1.artist_name ,  T1.gender FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.releasedate LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3558", "db_id": "music_1", "question": "What countries are the female artists who sung in the language Bangla from?", "rationale": ["Identify the relevant table: We need information about artists, specifically their country and gender, so we will use the 'artist' table.", "Filter for female artists: We will add a condition to select only those artists whose gender is 'female'.", "Identify the language condition: We need to find artists who have sung songs in the Bangla language, which is found in the 'song' table.", "Use a subquery: We will create a subquery to select the artist names from the 'song' table where the languages include 'Bangla'.", "Combine the conditions: We will combine the conditions to filter female artists from the 'artist' table whose names are in the list of artists from the subquery."], "gold_sql": "SELECT T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  'Female' AND T2.languages  =  'bangla'", "source_tables": ["artist", "song"], "pred_sql": "SELECT artist.country FROM artist WHERE artist.gender = 'female' AND artist.artist_name IN (SELECT song.artist_name FROM song WHERE song.languages LIKE '%Bangla%')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names and genders of artists from the 'artist' table who have released songs on a specific date. The placeholder in the WHERE clause represents the release date of the songs.\",\n        \"virtual_table\": \"SELECT T1.artist_name ,  T1.gender FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.releasedate LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3566", "db_id": "music_1", "question": "What is the gender and name of the artist who sang the song with the smallest resolution?", "rationale": ["Identify the relevant tables: We need information from the 'artist' and 'song' tables.", "Determine the required fields: We need the 'gender' and 'artist_name' from the 'artist' table.", "Establish the relationship: The 'artist' table is linked to the 'song' table through the 'artist_name' field.", "Find the song with the smallest resolution: We can use a subquery to find the minimum resolution from the 'song' table.", "Join the results: We will join the 'artist' and 'song' tables to get the artist's gender and name for the song with the smallest resolution."], "gold_sql": "SELECT T1.gender ,  T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.resolution LIMIT 1", "source_tables": ["artist", "song"], "pred_sql": "SELECT artist.gender, artist.artist_name \nFROM artist \nJOIN song ON artist.artist_name = song.artist_name \nWHERE song.resolution = (SELECT MIN(resolution) FROM song)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the subquery represents the language for which the minimum resolution is being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.3567", "db_id": "music_1", "question": "For each file format, return the number of artists who released songs in that format.", "rationale": ["We need to count the number of distinct artists for each file format.", "To do this, we will join the 'files' table with the 'song' table on the 'f_id' column, since 'f_id' in the 'song' table corresponds to the file associated with the song.", "Next, we will join the 'artist' table with the 'song' table on the 'artist_name' column to get the artist details for each song.", "We will select the 'formats' from the 'files' table and count the distinct 'artist_name' from the 'artist' table.", "Finally, we will group the results by 'formats' to get the count of artists for each file format."], "gold_sql": "SELECT count(*) ,  formats FROM files GROUP BY formats", "source_tables": ["files"], "pred_sql": "SELECT f.formats, COUNT(DISTINCT a.artist_name) AS artist_count \nFROM files AS f \nJOIN song AS s ON f.f_id = s.f_id \nJOIN artist AS a ON s.artist_name = a.artist_name \nGROUP BY f.formats;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names and genders of artists from the 'artist' table who have released songs on a specific date. The placeholder in the WHERE clause represents the release date of the songs.\",\n        \"virtual_table\": \"SELECT T1.artist_name ,  T1.gender FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.releasedate LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3576", "db_id": "music_1", "question": "What are the names and genders of all artists who released songs in the month of March?", "rationale": ["Identify the tables involved: 'artist' and 'song'.", "We need to retrieve the names and genders of artists, which are in the 'artist' table.", "We need to filter songs based on their release date, specifically for the month of March.", "The release date format is assumed to be 'YYYY-MM-DD', so we can use a LIKE clause to match any date in March by using '%-03-%'.", "Join the 'artist' table with the 'song' table on the artist's name to correlate artists with their songs.", "Construct the SQL query using the selected columns and the appropriate WHERE clause."], "gold_sql": "SELECT T1.artist_name ,  T1.gender FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.releasedate LIKE '%Mar%'", "source_tables": ["artist", "song"], "pred_sql": "SELECT T1.artist_name, T1.gender FROM artist AS T1 JOIN song AS T2 ON T1.artist_name = T2.artist_name WHERE T2.releasedate LIKE '%-03-%'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names and genders of artists from the 'artist' table who have released songs on a specific date. The placeholder in the WHERE clause represents the release date of the songs.\",\n        \"virtual_table\": \"SELECT T1.artist_name ,  T1.gender FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.releasedate LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3586", "db_id": "music_1", "question": "What are the languages that are used most often in songs?", "rationale": ["To find the languages used most often in songs, we need to count the occurrences of each language in the 'song' table.", "We will use the COUNT() function to count how many times each language appears.", "We will group the results by the 'languages' column to get the count for each distinct language.", "Finally, we will order the results in descending order to show the most frequently used languages at the top."], "gold_sql": "SELECT languages FROM song GROUP BY languages ORDER BY count(*) DESC LIMIT 1", "source_tables": ["song"], "pred_sql": "SELECT languages, COUNT(*) as language_count FROM song GROUP BY languages ORDER BY language_count DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.3590", "db_id": "music_1", "question": "What are the names of all male British artists?", "rationale": ["Identify the relevant table: The 'artist' table contains information about artists, including their names, countries, and genders.", "Determine the criteria: We need to filter for artists who are from Britain and are male.", "Construct the SQL query: Use a SELECT statement to retrieve the 'artist_name' from the 'artist' table where the 'country' is 'Britain' and the 'gender' is 'male'."], "gold_sql": "SELECT artist_name FROM artist WHERE country  =  'UK' AND gender  =  'Male'", "source_tables": ["artist"], "pred_sql": "SELECT artist_name FROM artist WHERE country = 'Britain' AND gender = 'male';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names and genders of artists from the 'artist' table who have released songs on a specific date. The placeholder in the WHERE clause represents the release date of the songs.\",\n        \"virtual_table\": \"SELECT T1.artist_name ,  T1.gender FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.releasedate LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3598", "db_id": "music_1", "question": "What is the average rating and resolution of all bangla songs?", "rationale": ["Identify the relevant table: The 'song' table contains the information about songs, including their genre and rating.", "Determine the genre of interest: The user is asking for 'Bangla' songs, so we will filter the results based on the genre_is column.", "Calculate the average rating: We will use the AVG() function to calculate the average rating of the Bangla songs.", "Select the resolution: We will also select the resolution of the songs, as requested by the user.", "Construct the SQL query: Combine the above elements into a single SQL query that selects the average rating and resolution for Bangla songs."], "gold_sql": "SELECT avg(rating) ,  avg(resolution) FROM song WHERE languages  =  'bangla'", "source_tables": ["song"], "pred_sql": "SELECT AVG(rating) AS average_rating, resolution FROM song WHERE genre_is = 'Bangla'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the subquery represents the language for which the minimum resolution is being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.3599", "db_id": "music_1", "question": "What are the maximum and minimum resolution of songs whose duration is 3 minutes?", "rationale": ["Identify the relevant table: The 'song' table contains the resolution and duration of songs.", "Determine the conditions: We need to filter songs based on a specific duration of '3 minutes'.", "Select the required fields: We need to find the maximum and minimum resolution of the filtered songs.", "Construct the SQL query: Use the SELECT statement to get the MAX and MIN of the resolution column, applying the WHERE clause for the duration."], "gold_sql": "SELECT max(T2.resolution) ,  min(T2.resolution) FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.duration LIKE '3:%'", "source_tables": ["files", "song"], "pred_sql": "SELECT MAX(resolution) AS max_resolution, MIN(resolution) AS min_resolution FROM song WHERE duration = '3 minutes'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the subquery represents the language for which the minimum resolution is being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.3601", "db_id": "music_1", "question": "What are the maximum duration and resolution of songs grouped and ordered by languages?", "rationale": ["Identify the columns needed: maximum duration and resolution of songs, grouped by languages.", "Use the MAX() function to get the maximum values for duration and resolution.", "Group the results by the 'languages' column to aggregate the data accordingly.", "Order the results by the 'languages' column for better readability."], "gold_sql": "SELECT max(T1.duration) ,  max(T2.resolution) ,  T2.languages FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.languages ORDER BY T2.languages", "source_tables": ["files", "song"], "pred_sql": "SELECT languages, MAX(duration) AS max_duration, MAX(resolution) AS max_resolution \nFROM song \nGROUP BY languages \nORDER BY languages;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.3603", "db_id": "music_1", "question": "What are the shortest duration and lowest rating of songs grouped by genre and ordered by genre?", "rationale": ["Identify the relevant tables: 'song' and 'genre' are needed to get the song details and their corresponding genres.", "We need to find the shortest duration and lowest rating of songs, which requires using aggregate functions MIN() on the 'duration' and 'rating' columns from the 'song' table.", "To group the results by genre, we will use the GROUP BY clause on the 'g_name' column from the 'genre' table.", "To ensure we get the correct genre for each song, we will join the 'song' table with the 'genre' table on the genre name.", "Finally, we will order the results by genre name using the ORDER BY clause."], "gold_sql": "SELECT min(T1.duration) ,  min(T2.rating) ,  T2.genre_is FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.genre_is ORDER BY T2.genre_is", "source_tables": ["files", "song"], "pred_sql": "SELECT genre.g_name, MIN(song.duration) AS shortest_duration, MIN(song.rating) AS lowest_rating\nFROM song\nJOIN genre ON song.genre_is = genre.g_name\nGROUP BY genre.g_name\nORDER BY genre.g_name;", "hint": "\n"}
{"sample_id": "train.3607", "db_id": "music_1", "question": "Find the name and country of origin for all artists who have release at least one song of resolution above 900.", "rationale": ["Identify the tables involved: We need information from the 'artist' table and the 'song' table.", "Determine the columns needed: We need the 'artist_name' and 'country' from the 'artist' table.", "Establish the relationship: The 'artist' table is related to the 'song' table through the 'artist_name' column.", "Filter the results: We need to filter songs based on the resolution being greater than 900.", "Use DISTINCT to avoid duplicate artist entries if they have multiple songs meeting the criteria."], "gold_sql": "SELECT T1.artist_name ,  T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.resolution  >  900 GROUP BY T2.artist_name HAVING count(*)  >=  1", "source_tables": ["artist", "song"], "pred_sql": "SELECT DISTINCT artist.artist_name, artist.country FROM artist JOIN song ON artist.artist_name = song.artist_name WHERE song.resolution > 900;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.3619", "db_id": "music_1", "question": "Find the top 3 artists who have the largest number of songs works whose language is Bangla.", "rationale": ["Identify the relevant table: The 'song' table contains information about songs, including their languages and associated artists.", "Filter songs by language: We need to filter the songs to only include those where the language is 'Bangla'.", "Count the number of songs per artist: We will group the results by 'artist_name' and count the number of songs for each artist using COUNT(song_name).", "Order the results: To find the top artists, we will order the results in descending order based on the count of songs.", "Limit the results: Finally, we will limit the results to the top 3 artists."], "gold_sql": "SELECT T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.languages  =  'bangla' GROUP BY T2.artist_name ORDER BY count(*) DESC LIMIT 3", "source_tables": ["artist", "song"], "pred_sql": "SELECT artist_name, COUNT(song_name) AS song_count \nFROM song \nWHERE languages = 'Bangla' \nGROUP BY artist_name \nORDER BY song_count DESC \nLIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.3623", "db_id": "music_1", "question": "List the duration, file size and format of songs whose genre is pop, ordered by title?", "rationale": ["Identify the relevant tables: 'song' for song details and 'files' for file details.", "Determine the columns needed: 'duration' from 'song', 'file_size' and 'formats' from 'files'.", "Establish the relationship between the tables: 'song' and 'files' are linked by 'f_id'.", "Filter the results to include only songs where the genre is 'pop'.", "Order the results by the song title, which is represented by 'song_name' in the 'song' table."], "gold_sql": "SELECT T1.duration ,  T1.file_size ,  T1.formats FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T2.genre_is  =  'pop' ORDER BY T2.song_name", "source_tables": ["files", "song"], "pred_sql": "SELECT song.duration, files.file_size, files.formats \nFROM song \nJOIN files ON song.f_id = files.f_id \nWHERE song.genre_is = 'pop' \nORDER BY song.song_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.3624", "db_id": "music_1", "question": "What is the duration, file size, and song format for every pop song, ordered by title alphabetically?", "rationale": ["Identify the required columns: duration, file size, and song format.", "Determine the relevant tables: 'song' for song details and 'files' for file details.", "Establish the relationship between the tables: 'song' and 'files' are linked by the 'f_id' column.", "Filter the results to include only pop songs by using a WHERE clause on the 'genre_is' column in the 'song' table.", "Order the results alphabetically by song title using the ORDER BY clause on the 'song_name' column."], "gold_sql": "SELECT T1.duration ,  T1.file_size ,  T1.formats FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T2.genre_is  =  'pop' ORDER BY T2.song_name", "source_tables": ["files", "song"], "pred_sql": "SELECT song.duration, files.file_size, files.formats \nFROM song \nJOIN files ON song.f_id = files.f_id \nWHERE song.genre_is = 'pop' \nORDER BY song.song_name ASC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.3631", "db_id": "baseball_1", "question": "What is average salary of the players in the team named 'Boston Red Stockings' ?", "rationale": ["Identify the relevant tables: We need the 'salary' table to get the salary information and the 'team' table to filter by team name.", "Join the 'salary' table with the 'team' table on 'team_id' to associate salaries with the respective teams.", "Filter the results to only include the team named 'Boston Red Stockings'.", "Use the AVG() function to calculate the average salary of the players in that team."], "gold_sql": "SELECT avg(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings'", "source_tables": ["team", "salary"], "pred_sql": "SELECT AVG(s.salary) FROM salary AS s JOIN team AS t ON s.team_id = t.team_id WHERE t.name = 'Boston Red Stockings';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total attendance for home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the attendance data.\",\n        \"virtual_table\": \"SELECT sum(T1.attendance) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3650", "db_id": "baseball_1", "question": "What are the three countries that the least players are from?", "rationale": ["Identify the relevant table: The 'player' table contains information about players, including their birth countries.", "Group the data: We need to group the players by their birth country to count how many players are from each country.", "Count the players: Use the COUNT function to count the number of players for each country.", "Order the results: We want to order the countries by the count of players in ascending order to find the countries with the least players.", "Limit the results: We only need the top three countries with the least players, so we will use the LIMIT clause."], "gold_sql": "SELECT birth_country FROM player GROUP BY birth_country ORDER BY count(*) ASC LIMIT 3;", "source_tables": ["player"], "pred_sql": "SELECT birth_country FROM player GROUP BY birth_country ORDER BY count(*) ASC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of countries where players were born, grouped by country and ordered by the number of players from each country in ascending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of countries to return.\",\n        \"virtual_table\": \"SELECT birth_country FROM player GROUP BY birth_country ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3657", "db_id": "baseball_1", "question": "What is the highest salary among each team? List the team name, id and maximum salary.", "rationale": ["Identify the tables needed: 'team' for team names and IDs, and 'salary' for salary information.", "Join the 'team' table with the 'salary' table on 'team_id' to associate each team with its salaries.", "Use the MAX() function to find the highest salary for each team.", "Group the results by 'team_id' and 'team name' to ensure we get the maximum salary for each team."], "gold_sql": "SELECT T1.name ,  T1.team_id ,  max(T2.salary) FROM team AS T1 JOIN salary AS T2 ON T1.team_id  =  T2.team_id GROUP BY T1.team_id;", "source_tables": ["team", "salary"], "pred_sql": "SELECT T1.name, T1.team_id, MAX(T2.salary) AS max_salary \nFROM team AS T1 \nJOIN salary AS T2 ON T1.team_id = T2.team_id \nGROUP BY T1.team_id, T1.name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\",\n        \"virtual_table\": \"SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3658", "db_id": "baseball_1", "question": "For each team, return the team name, id and the maximum salary among the team.", "rationale": ["We need to retrieve the team name, team id, and the maximum salary for each team.", "The relevant tables for this query are 'team' and 'salary'.", "We will join the 'team' table with the 'salary' table on the 'team_id' column, which is common to both tables.", "To find the maximum salary for each team, we will use the MAX() function on the 'salary' column from the 'salary' table.", "We will group the results by 'team.team_id' and 'team.name' to ensure we get one result per team."], "gold_sql": "SELECT T1.name ,  T1.team_id ,  max(T2.salary) FROM team AS T1 JOIN salary AS T2 ON T1.team_id  =  T2.team_id GROUP BY T1.team_id;", "source_tables": ["team", "salary"], "pred_sql": "SELECT team.name, team.team_id, MAX(salary.salary) AS max_salary\nFROM team\nJOIN salary ON team.team_id = salary.team_id\nGROUP BY team.team_id, team.name;", "hint": "\n"}
{"sample_id": "train.3659", "db_id": "baseball_1", "question": "What are the name and id of the team offering the lowest average salary?", "rationale": ["Identify the relevant tables: 'team' for team names and IDs, and 'salary' for salary information.", "Join the 'team' and 'salary' tables on 'team_id' to associate teams with their salaries.", "Group the results by 'team_id' to calculate the average salary for each team.", "Use the AVG() function to compute the average salary for each team.", "Order the results in ascending order based on the average salary to find the lowest.", "Limit the results to 1 to get only the team with the lowest average salary."], "gold_sql": "SELECT T1.name ,  T1.team_id FROM team AS T1 JOIN salary AS T2 ON T1.team_id = T2.team_id GROUP BY T1.team_id ORDER BY avg(T2.salary) ASC LIMIT 1;", "source_tables": ["team", "salary"], "pred_sql": "SELECT team.name, team.team_id\nFROM team\nJOIN salary ON team.team_id = salary.team_id\nGROUP BY team.team_id\nORDER BY AVG(salary.salary) ASC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3661", "db_id": "baseball_1", "question": "Find the players' first name and last name who won award both in 1960 and in 1961.", "rationale": ["We need to find players who won awards in both 1960 and 1961.", "The relevant table for player awards is 'player_award', which contains the player_id and the year they won an award.", "We will join the 'player' table to get the first and last names of the players.", "To find players who won awards in both years, we will perform a self-join on the 'player_award' table, filtering for the years 1960 and 1961."], "gold_sql": "SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1960 INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1961", "source_tables": ["player_award", "player"], "pred_sql": "SELECT p.name_first, p.name_last \nFROM player p \nJOIN player_award pa1 ON p.player_id = pa1.player_id \nJOIN player_award pa2 ON p.player_id = pa2.player_id \nWHERE pa1.year = '1960' AND pa2.year = '1961';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of players from the 'player' table who have a recorded year of death. The placeholder in the WHERE clause represents the specific year of death being queried.\",\n        \"virtual_table\": \"SELECT name_first ,  name_last FROM player WHERE death_year = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.3663", "db_id": "baseball_1", "question": "List players' first name and last name who have weight greater than 220 or height shorter than 75.", "rationale": ["Identify the relevant table: The 'player' table contains the necessary columns for player names, weight, and height.", "Determine the columns to select: We need to select 'name_first' and 'name_last' for the players.", "Establish the conditions: We want players with a weight greater than 220 or a height shorter than 75.", "Construct the SQL query: Combine the selected columns and conditions into a valid SQL SELECT statement."], "gold_sql": "SELECT name_first ,  name_last FROM player WHERE weight  >  220 OR height  <  75", "source_tables": ["player"], "pred_sql": "SELECT name_first, name_last FROM player WHERE weight > 220 OR height < 75;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of players from the 'player' table who have a specified year of death. The placeholder in the WHERE clause represents the year of death.\",\n        \"virtual_table\": \"SELECT name_first ,  name_last FROM player WHERE death_year = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.3664", "db_id": "baseball_1", "question": "What are the first name and last name of the players who have weight above 220 or height below 75?", "rationale": ["Identify the relevant table: The 'player' table contains the first name, last name, weight, and height of players.", "Determine the conditions: We need players with a weight greater than 220 or a height less than 75.", "Construct the SQL query: Use a SELECT statement to retrieve 'name_first' and 'name_last' from the 'player' table, applying the specified conditions in the WHERE clause."], "gold_sql": "SELECT name_first ,  name_last FROM player WHERE weight  >  220 OR height  <  75", "source_tables": ["player"], "pred_sql": "SELECT name_first, name_last FROM player WHERE weight > 220 OR height < 75;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of players from the 'player' table who have a recorded year of death. The placeholder in the WHERE clause represents the specific year of death being queried.\",\n        \"virtual_table\": \"SELECT name_first ,  name_last FROM player WHERE death_year = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.3665", "db_id": "baseball_1", "question": "List the maximum scores of the team Boston Red Stockings when the team won in postseason?", "rationale": ["Identify the relevant tables: 'postseason' for postseason results and 'team' for team names.", "Join the 'postseason' table with the 'team' table on the winning team ID to get the team names associated with the postseason results.", "Filter the results to only include the Boston Red Stockings by using a WHERE clause.", "Select the maximum wins from the postseason results for the Boston Red Stockings using the MAX() function."], "gold_sql": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings';", "source_tables": ["postseason", "team"], "pred_sql": "SELECT MAX(p.wins) AS max_wins\nFROM postseason AS p\nJOIN team AS t ON p.team_id_winner = t.team_id\nWHERE t.name = 'Boston Red Stockings';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\",\n        \"virtual_table\": \"SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3666", "db_id": "baseball_1", "question": "What are the maximum scores the team Boston Red Stockings got when the team won in postseason?", "rationale": ["Identify the relevant tables: 'postseason' for postseason results and 'team' for team names.", "Join the 'postseason' table with the 'team' table on the winning team identifier.", "Filter the results to only include rows where the team name is 'Boston Red Stockings'.", "Select the maximum wins from the filtered results to find the highest score the team achieved when they won in the postseason."], "gold_sql": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings';", "source_tables": ["postseason", "team"], "pred_sql": "SELECT MAX(p.wins) AS max_wins\nFROM postseason AS p\nJOIN team AS t ON p.team_id_winner = t.team_id\nWHERE t.name = 'Boston Red Stockings';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\",\n        \"virtual_table\": \"SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
