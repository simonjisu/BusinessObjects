{"sample_id": "train.6723", "db_id": "activity_1", "question": "Show the first name, last name, and phone number for all female faculty members.", "rationale": ["The query is identifying the relevant table, which is 'Faculty'.", "Select the columns to display, 'Fname', 'Lname', and 'phone'.", "Add a condition to filter the 'Sex' column for the specified gender using a placeholder for string values."], "gold_sql": "SELECT Fname ,  Lname ,  phone FROM Faculty WHERE Sex  =  'F'", "source_tables": ["faculty"], "description": "This virtual table describes the first names, last names, and contact phone numbers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.", "virtual_table": "SELECT Fname ,  Lname ,  phone FROM Faculty WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6739", "db_id": "activity_1", "question": "Show all the buildings that have at least 10 professors.", "rationale": ["The query identifies the relevant table, which is 'Faculty'.", "Select the 'building' column to display the locations of faculty offices.", "Add a condition to filter the 'rank' column for the specified academic rank using a placeholder for string values.", "Group the results by 'building' to aggregate the data based on the location.", "Use the HAVING clause to filter the grouped results to include only those buildings with a count of faculty members greater than or equal to a specified number, using a placeholder for numeric values."], "gold_sql": "SELECT building FROM Faculty WHERE rank  =  'Professor' GROUP BY building HAVING count(*)  >=  10", "source_tables": ["faculty"], "description": "This virtual table provides a list of buildings where faculty members of a specific academic rank are located. The query groups the results by building and filters to include only those buildings that have a certain number of faculty members, as indicated by the placeholders.", "virtual_table": "SELECT building FROM Faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] GROUP BY building HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6724", "db_id": "activity_1", "question": "What are the first name, last name, and phone number of all the female faculty members?", "rationale": ["The query is identifying the relevant table, which is 'Faculty'.", "Select the columns to display, 'Fname', 'Lname', and 'phone'.", "Add a condition to filter the 'Sex' column for the specified gender using a placeholder for string values."], "gold_sql": "SELECT Fname ,  Lname ,  phone FROM Faculty WHERE Sex  =  'F'", "source_tables": ["faculty"], "description": "This virtual table describes the first names, last names, and contact phone numbers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.", "virtual_table": "SELECT Fname ,  Lname ,  phone FROM Faculty WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6802", "db_id": "activity_1", "question": "Which students participate in both Canoeing and Kayaking as their activities? Tell me their student ids.", "rationale": ["The query is identifying the relevant tables, which are 'Participates_in' and 'Activity'.", "It selects the 'stuid' column from the 'Participates_in' table.", "The query uses JOIN to connect 'Participates_in' with 'Activity' based on the activity identifier 'actid'.", "It filters the results based on the names of two activities using placeholders for string values.", "The INTERSECT operator is used to find students who participate in both activities."], "gold_sql": "SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  'Canoeing' INTERSECT SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  'Kayaking'", "source_tables": ["activity", "participates_in"], "description": "This virtual table identifies students who participate in two specific activities from the 'Activity' table. The placeholders in the WHERE clauses represent the names of the activities being queried.", "virtual_table": "SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6740", "db_id": "activity_1", "question": "In which buildings are there at least ten professors?", "rationale": ["The query identifies the relevant table, which is 'Faculty'.", "Select the 'building' column to display the locations of faculty offices.", "Add a condition to filter the 'rank' column for the specified academic rank using a placeholder for string values.", "Group the results by 'building' to aggregate the data based on the location.", "Use the HAVING clause to filter the grouped results to include only those buildings with a count of faculty members greater than or equal to a specified number, using a placeholder for numeric values."], "gold_sql": "SELECT building FROM Faculty WHERE rank  =  'Professor' GROUP BY building HAVING count(*)  >=  10", "source_tables": ["faculty"], "description": "This virtual table provides a list of buildings where faculty members of a specific academic rank are located. The query groups the results by building and filters to include only those buildings that have a certain number of faculty members, as indicated by the placeholders.", "virtual_table": "SELECT building FROM Faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] GROUP BY building HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6780", "db_id": "activity_1", "question": "What is the first and last name of the faculty members who participated in at least one activity? For each of them, also show the number of activities they participated in.", "rationale": ["The query identifies the relevant tables, which are 'Faculty' and 'Faculty_Participates_in'.", "It selects the columns to display: the first name and last name of faculty members, along with a count of their participation in activities.", "The JOIN operation links the 'Faculty' table with the 'Faculty_Participates_in' table based on the faculty identifier.", "The GROUP BY clause is used to aggregate the results by each faculty member's unique identifier, allowing for the count of activities to be calculated."], "gold_sql": "SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID", "source_tables": ["faculty", "faculty_participates_in"], "description": "This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is grouped by each faculty member's unique identifier. The placeholders represent the faculty member's first name, last name, and the count of their participation in activities.", "virtual_table": "SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID"}
{"sample_id": "train.6759", "db_id": "activity_1", "question": "What are the first and last name of the faculty who has the most students?", "rationale": ["The query identifies the relevant tables, which are 'Faculty' and 'Student'.", "It selects the first name and last name of faculty members (aliased as T1) who are advisors to students (aliased as T2).", "A JOIN operation is performed on the Faculty and Student tables using the advisor relationship.", "The results are grouped by the faculty ID to aggregate the number of students each faculty member advises.", "The results are ordered in descending order based on the count of students advised, and a limit is applied to restrict the number of faculty members returned using a placeholder for numeric values."], "gold_sql": "SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID ORDER BY count(*) DESC LIMIT 1", "source_tables": ["faculty", "student"], "description": "This virtual table provides the first and last names of faculty members who serve as advisors to students. The results are grouped by faculty ID and ordered by the number of students they advise, with a limit on the number of faculty members returned based on a specified number.", "virtual_table": "SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6800", "db_id": "activity_1", "question": "What are the first names of the faculty members playing both Canoeing and Kayaking?", "rationale": ["The query identifies the relevant tables, which are 'Faculty', 'Faculty_Participates_in', and 'Activity'.", "It selects the 'lname' column from the 'Faculty' table.", "The JOIN operations link faculty members to the activities they participate in through the 'Faculty_Participates_in' table.", "The WHERE clause filters the results based on the specified activity name using a placeholder for string values.", "The INTERSECT operation ensures that only faculty members participating in the same activity are included in the final result."], "gold_sql": "SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' INTERSECT SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "description": "This virtual table describes the last names of faculty members who participate in a specific activity. The query uses an INTERSECT operation to ensure that only faculty members who are involved in the same activity are selected. The placeholders in the WHERE clause represent the name of the activity.", "virtual_table": "SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6755", "db_id": "activity_1", "question": "Show the faculty id of each faculty member, along with the number of students he or she advises.", "rationale": ["The query identifies the relevant tables, which are 'Faculty' and 'Student'.", "It selects the 'FacID' from the 'Faculty' table and counts the number of students associated with each faculty member.", "The JOIN operation is used to link the 'Faculty' table with the 'Student' table based on the advisor relationship.", "The GROUP BY clause is applied to aggregate the results by each faculty member's ID."], "gold_sql": "SELECT T1.FacID ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID", "source_tables": ["faculty", "student"], "description": "This virtual table provides a count of students assigned to each faculty member as their advisor from the 'Faculty' and 'Student' tables. The placeholder in the SELECT statement represents the faculty member's unique identifier.", "virtual_table": "SELECT T1.FacID ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID"}
{"sample_id": "train.6796", "db_id": "activity_1", "question": "Which faculty members are playing either Canoeing or Kayaking? Tell me their first names.", "rationale": ["The query identifies the relevant tables: 'Faculty', 'Faculty_Participates_in', and 'Activity'.", "It selects the distinct last names of faculty members from the 'Faculty' table.", "The JOIN operations link the faculty members to their respective activities through the 'Faculty_Participates_in' table and the 'Activity' table.", "The WHERE clause filters the results based on the specified activity names using placeholders for string values."], "gold_sql": "SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "description": "This virtual table lists the distinct last names of faculty members who participate in specific activities from the 'Activity' table. The placeholders in the WHERE clause represent the names of the activities of interest.", "virtual_table": "SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6738", "db_id": "activity_1", "question": "Find the building that has the largest number of faculty members.", "rationale": ["The query identifies the relevant table, which is 'Faculty'.", "It selects the 'building' column to display the names of the buildings.", "The results are grouped by 'building' to aggregate the data based on the building names.", "The query orders the results by the count of faculty members in each building in descending order to show the most populated buildings first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT building FROM Faculty GROUP BY building ORDER BY count(*) DESC LIMIT 1", "source_tables": ["faculty"], "description": "This virtual table provides a list of buildings where faculty members have their offices, grouped by building name. The results are ordered by the number of faculty members in each building in descending order, and the placeholder allows the user to specify the maximum number of buildings to return.", "virtual_table": "SELECT building FROM Faculty GROUP BY building ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6795", "db_id": "activity_1", "question": "Find the first names of the faculty members who are playing Canoeing or Kayaking.", "rationale": ["The query identifies the relevant tables: 'Faculty', 'Faculty_Participates_in', and 'Activity'.", "It selects distinct last names from the 'Faculty' table.", "The JOIN operations link faculty members to their participation in activities through the 'Faculty_Participates_in' table and the 'Activity' table.", "The WHERE clause filters the results based on the names of the activities, using placeholders for the activity names."], "gold_sql": "SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "description": "This virtual table provides a list of distinct last names of faculty members who participate in specific activities. The activities are filtered based on their names, which are represented by placeholders in the WHERE clause.", "virtual_table": "SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6757", "db_id": "activity_1", "question": "Show all the faculty ranks and the number of students advised by each rank.", "rationale": ["The query identifies the relevant tables, which are 'Faculty' and 'Student'.", "It selects the 'rank' column from the 'Faculty' table and counts the number of students associated with each faculty member.", "The join condition links faculty members to their students through the advisor relationship, where 'FacID' in 'Faculty' matches 'advisor' in 'Student'.", "The results are grouped by the faculty rank to provide a count of students for each rank."], "gold_sql": "SELECT T1.rank ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.rank", "source_tables": ["faculty", "student"], "description": "This virtual table summarizes the number of students assigned to each academic rank of faculty members. It joins the 'Faculty' table with the 'Student' table based on the advisor relationship, grouping the results by the faculty rank to count the number of students per rank.", "virtual_table": "SELECT T1.rank ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.rank"}
{"sample_id": "train.6733", "db_id": "activity_1", "question": "Show the first name and last name for all the instructors.", "rationale": ["The query is identifying the relevant table, which is 'Faculty'.", "Select the columns to display, 'fname' and 'lname'.", "Add a condition to filter the 'Rank' column for the specified rank using a placeholder for string values."], "gold_sql": "SELECT fname ,  lname FROM Faculty WHERE Rank  =  'Instructor'", "source_tables": ["faculty"], "description": "This virtual table describes the first and last names of faculty members from the 'Faculty' table who hold a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.", "virtual_table": "SELECT fname ,  lname FROM Faculty WHERE Rank  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6782", "db_id": "activity_1", "question": "How many faculty members participate in each activity? Return the activity names and the number of faculty members.", "rationale": ["The query identifies the relevant tables, which are 'Activity' and 'Faculty_Participates_in'.", "It selects the 'activity_name' from the 'Activity' table and counts the number of faculty members participating in each activity.", "The JOIN operation links the two tables based on the activity identifier, ensuring that only matching records are considered.", "The GROUP BY clause is used to aggregate the results by activity, allowing for a count of faculty members for each distinct activity."], "gold_sql": "SELECT T1.activity_name ,  count(*) FROM Activity AS T1 JOIN Faculty_participates_in AS T2 ON T1.actID  =  T2.actID GROUP BY T1.actID", "source_tables": ["activity", "faculty_participates_in"], "description": "This virtual table summarizes the number of faculty members participating in each activity from the 'Activity' table. The placeholder in the GROUP BY clause represents the activity's identifier.", "virtual_table": "SELECT T1.activity_name ,  count(*) FROM Activity AS T1 JOIN Faculty_participates_in AS T2 ON T1.actID  =  T2.actID GROUP BY T1.actID"}
{"sample_id": "train.6781", "db_id": "activity_1", "question": "Show all the activity names and the number of faculty involved in each activity.", "rationale": ["The query identifies the relevant tables, which are 'Activity' and 'Faculty_Participates_in'.", "It selects the 'activity_name' from the 'Activity' table and counts the number of faculty members participating in each activity.", "The JOIN operation links the two tables based on the activity identifier, ensuring that only matching records are considered.", "The GROUP BY clause is used to aggregate the results by activity, allowing for a count of faculty members for each specific activity."], "gold_sql": "SELECT T1.activity_name ,  count(*) FROM Activity AS T1 JOIN Faculty_participates_in AS T2 ON T1.actID  =  T2.actID GROUP BY T1.actID", "source_tables": ["activity", "faculty_participates_in"], "description": "This virtual table summarizes the number of faculty members participating in each activity from the 'Activity' table. The placeholder in the GROUP BY clause represents the activity's identifier.", "virtual_table": "SELECT T1.activity_name ,  count(*) FROM Activity AS T1 JOIN Faculty_participates_in AS T2 ON T1.actID  =  T2.actID GROUP BY T1.actID"}
{"sample_id": "train.6766", "db_id": "activity_1", "question": "List all the activities we have.", "rationale": ["The query identifies the relevant table, which is 'Activity'.", "Select the column to display, 'activity_name'.", "This virtual table can be expanded with additional conditions or joins using placeholders."], "gold_sql": "SELECT activity_name FROM Activity", "source_tables": ["activity"], "description": "This virtual table describes the names of activities from the 'Activity' table. The placeholder can be used to filter or join with other tables if needed.", "virtual_table": "SELECT activity_name FROM Activity"}
{"sample_id": "train.6726", "db_id": "activity_1", "question": "What are the faculty ids of all the male faculty members?", "rationale": ["The query is identifying the relevant table, which is 'Faculty'.", "Select the column to display, 'FacID'.", "Add a condition to filter the 'Sex' column for the specified gender using a placeholder for string values."], "gold_sql": "SELECT FacID FROM Faculty WHERE Sex  =  'M'", "source_tables": ["faculty"], "description": "This virtual table describes the unique identifiers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.", "virtual_table": "SELECT FacID FROM Faculty WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6776", "db_id": "activity_1", "question": "Find the number of activities Mark Giuliano is involved in.", "rationale": ["The query identifies the relevant tables, which are 'Faculty' and 'Faculty_Participates_in'.", "It uses a JOIN operation to connect the two tables based on the faculty member's ID.", "The SELECT statement counts the number of records that match the specified first and last names of the faculty member using placeholders for string values."], "gold_sql": "SELECT count(*) FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID WHERE T1.fname  =  'Mark' AND T1.lname  =  'Giuliano'", "source_tables": ["faculty", "faculty_participates_in"], "description": "This virtual table provides the count of faculty members who participate in activities, filtered by the first and last names of the faculty member. The placeholders in the WHERE clause represent the first and last names of the faculty member being queried.", "virtual_table": "SELECT count(*) FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6765", "db_id": "activity_1", "question": "What activities do we have?", "rationale": ["The query identifies the relevant table, which is 'Activity'.", "Select the column to display, 'activity_name', which represents the name of each activity."], "gold_sql": "SELECT activity_name FROM Activity", "source_tables": ["activity"], "description": "This virtual table describes the names of activities from the 'Activity' table. The placeholder can be used to filter or join with other tables if needed.", "virtual_table": "SELECT activity_name FROM Activity"}
{"sample_id": "train.534", "db_id": "allergy_1", "question": "How many students are over 18 and do not have allergy to food type or animal type?", "rationale": ["The query identifies the relevant table, which is 'Student'.", "It counts the total number of students that meet the specified criteria.", "The condition filters students based on their age, using a placeholder for numeric values.", "A subquery is used to exclude students who have allergies of specified types, joining 'Has_Allergy' and 'Allergy_Type' tables to check for the allergy types, with placeholders for the allergy types."], "gold_sql": "SELECT count(*) FROM Student WHERE age  >  18 AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food' OR T2.allergytype  =  'animal')", "source_tables": ["has_allergy", "allergy_type", "student"], "description": "This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the allergy types to be excluded.", "virtual_table": "SELECT count(*) FROM Student WHERE age  >  [PLACEHOLDER-TYPE:NUMBER] AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] OR T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.522", "db_id": "allergy_1", "question": "What are the allergies the girl named Lisa has? And what are the types of them? Order the result by allergy names.", "rationale": ["The query identifies the relevant tables: 'Allergy_Type', 'Has_Allergy', and 'Student'.", "It selects the columns 'Allergy' and 'AllergyType' from the 'Allergy_Type' table.", "The JOIN operations link the 'Has_Allergy' table to the 'Allergy_Type' table and the 'Student' table based on the foreign key relationships.", "A condition is added to filter results based on the student's first name using a placeholder for string values.", "The results are ordered by the 'Allergy' column."], "gold_sql": "SELECT T1.Allergy ,  T1.AllergyType FROM Allergy_type AS T1 JOIN Has_allergy AS T2 ON T1.Allergy  =  T2.Allergy JOIN Student AS T3 ON T3.StuID  =  T2.StuID WHERE T3.Fname  =  'Lisa' ORDER BY T1.Allergy", "source_tables": ["has_allergy", "allergy_type", "student"], "description": "This virtual table provides a list of allergies and their types for students based on their first name. The placeholders in the WHERE clause allow for filtering by a specific student's first name.", "virtual_table": "SELECT T1.Allergy ,  T1.AllergyType FROM Allergy_type AS T1 JOIN Has_allergy AS T2 ON T1.Allergy  =  T2.Allergy JOIN Student AS T3 ON T3.StuID  =  T2.StuID WHERE T3.Fname  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.Allergy"}
{"sample_id": "train.529", "db_id": "allergy_1", "question": "Find the number of male (sex is 'M') students who have some food type allery.", "rationale": ["The query identifies the relevant table, which is 'Student'.", "It counts the total number of students that meet certain criteria.", "A condition is added to filter students based on their gender using a placeholder for string values.", "A subquery is used to find students who have allergies by joining 'Has_Allergy' and 'Allergy_Type' tables, filtering by the specified allergy type using another placeholder for string values."], "gold_sql": "SELECT count(*) FROM Student WHERE sex  =  'M' AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "description": "This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the query represent the gender of the students and the type of allergy they have.", "virtual_table": "SELECT count(*) FROM Student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.527", "db_id": "allergy_1", "question": "List the first and last name of the students who do not have any food type allergy.", "rationale": ["The query identifies the relevant table, which is 'Student'.", "Select the columns to display, 'fname' and 'lname'.", "Add a condition to filter out students whose IDs are in a subquery.", "The subquery selects student IDs from 'Has_Allergy' joined with 'Allergy_Type' where the allergy type matches the specified placeholder."], "gold_sql": "SELECT fname ,  lname FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "description": "This virtual table provides the first and last names of students from the 'Student' table who do not have a specific type of allergy. The placeholder in the subquery represents the allergy type that is being filtered out.", "virtual_table": "SELECT fname ,  lname FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.533", "db_id": "allergy_1", "question": "Find the number of students who are older than 18 and do not have allergy to either food or animal.", "rationale": ["The query identifies the relevant table, which is 'Student'.", "It counts the total number of students that meet the specified criteria.", "A condition is added to filter students based on their age using a placeholder for numeric values.", "A subquery is used to exclude students who have allergies of specified types by joining 'Has_Allergy' and 'Allergy_Type' tables, with placeholders for the allergy types."], "gold_sql": "SELECT count(*) FROM Student WHERE age  >  18 AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food' OR T2.allergytype  =  'animal')", "source_tables": ["has_allergy", "allergy_type", "student"], "description": "This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the types of allergies to exclude.", "virtual_table": "SELECT count(*) FROM Student WHERE age  >  [PLACEHOLDER-TYPE:NUMBER] AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] OR T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.526", "db_id": "allergy_1", "question": "How old are the students with allergies to food and animal types on average?", "rationale": ["The query identifies the relevant table, which is 'Student', to calculate the average age.", "It uses a subquery to find students who have allergies of a specific type by joining 'Has_Allergy' and 'Allergy_Type'.", "The INTERSECT operator is used to ensure that only students with both specified allergy types are considered.", "The placeholders in the WHERE clause represent the allergy types, allowing users to specify different categories for the query."], "gold_sql": "SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food' INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'animal')", "source_tables": ["has_allergy", "allergy_type", "student"], "description": "This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.", "virtual_table": "SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.535", "db_id": "allergy_1", "question": "Find the first name and major of the students who are not allegry to soy.", "rationale": ["The query identifies the relevant table, which is 'Student'.", "Select the columns to display, 'fname' and 'major'.", "Add a condition to filter out students who have a specific allergy by using a subquery that checks the 'StuID' in the 'Has_Allergy' table for the specified allergy, using a placeholder for string values."], "gold_sql": "SELECT fname ,  major FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Soy')", "source_tables": ["has_allergy", "student"], "description": "This virtual table provides the first names and majors of students from the 'Student' table who do not have a specific allergy. The placeholder in the subquery represents the name of the allergy being checked against the 'Has_Allergy' table.", "virtual_table": "SELECT fname ,  major FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.470", "db_id": "allergy_1", "question": "What are the full names and ages for all female students whose sex is F?", "rationale": ["The query identifies the relevant table, which is 'Student'.", "Select the columns to display: 'Fname', 'Lname', and 'Age'.", "Add a condition to filter the 'Sex' column for the specified gender using a placeholder for string values."], "gold_sql": "SELECT Fname ,  Lname ,  Age FROM Student WHERE Sex  =  'F'", "source_tables": ["student"], "description": "This virtual table provides the first name, last name, and age of students from the 'Student' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the students.", "virtual_table": "SELECT Fname ,  Lname ,  Age FROM Student WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.536", "db_id": "allergy_1", "question": "What are the first name and major of the students who are able to consume soy?", "rationale": ["The query identifies the relevant table, which is 'Student'.", "Select the columns to display, 'fname' and 'major'.", "Add a condition to filter out students whose 'StuID' is present in the 'Has_Allergy' table for a specific allergy using a placeholder for string values."], "gold_sql": "SELECT fname ,  major FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Soy')", "source_tables": ["has_allergy", "student"], "description": "This virtual table provides the first names and majors of students from the 'Student' table who do not have a specific allergy. The placeholder in the subquery represents the name of the allergy that is being checked against the students' allergies.", "virtual_table": "SELECT fname ,  major FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.513", "db_id": "allergy_1", "question": "Which allergy has most number of students affected?", "rationale": ["The query identifies the relevant table, which is 'Has_Allergy'.", "It selects the 'Allergy' column to display the names of allergies.", "The GROUP BY clause is used to group the results by the 'Allergy' name.", "The ORDER BY clause sorts the results based on the count of occurrences in descending order.", "The LIMIT clause uses a placeholder to allow the user to specify how many results they want to see."], "gold_sql": "SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT 1", "source_tables": ["has_allergy"], "description": "This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.", "virtual_table": "SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.501", "db_id": "allergy_1", "question": "Which advisor has most number of students?", "rationale": ["The query identifies the relevant table, which is 'Student'.", "Select the column to display, 'advisor'.", "Group the results by the 'advisor' column to aggregate the data.", "Order the results by the count of students associated with each advisor in descending order.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT advisor FROM Student GROUP BY advisor ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "description": "This virtual table provides a list of academic advisors from the 'Student' table, grouped by the advisor's name. The results are ordered by the number of students assigned to each advisor in descending order, with a limit on the number of advisors returned, specified by a placeholder for numeric values.", "virtual_table": "SELECT advisor FROM Student GROUP BY advisor ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.491", "db_id": "allergy_1", "question": "Which major has most number of students?", "rationale": ["The query identifies the relevant table, which is 'Student'.", "Select the column to display, 'major'.", "Group the results by the 'major' column to aggregate the data.", "Order the results by the count of students in each major in descending order to show the most popular majors first.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT major FROM Student GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "description": "This virtual table provides a list of academic majors from the 'Student' table, grouped by the major and ordered by the number of students in each major in descending order. The placeholder in the LIMIT clause represents the maximum number of majors to return.", "virtual_table": "SELECT major FROM Student GROUP BY major ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.509", "db_id": "allergy_1", "question": "How many female students have milk or egg allergies?", "rationale": ["The query identifies the relevant tables, which are 'Has_Allergy' and 'Student'.", "It uses a JOIN operation to combine data from both tables based on the student ID.", "The SELECT statement counts the number of records that meet the specified conditions.", "The WHERE clause filters the results based on the gender of the students and checks for specific allergies using placeholders for string values."], "gold_sql": "SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  'F' AND T1.allergy  =  'Milk' OR T1.allergy  =  'Eggs'", "source_tables": ["has_allergy", "student"], "description": "This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.", "virtual_table": "SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  [PLACEHOLDER-TYPE:STRING] AND T1.allergy  =  [PLACEHOLDER-TYPE:STRING] OR T1.allergy  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.456", "db_id": "allergy_1", "question": "Which allergy type is most common?", "rationale": ["The query identifies the relevant table, which is 'Allergy_Type'.", "It selects the 'allergytype' column to display the types of allergies.", "The query groups the results by 'allergytype' to aggregate the data.", "It orders the results by the count of occurrences in descending order to show the most common types first.", "The LIMIT clause uses a placeholder to specify how many types to return."], "gold_sql": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT 1", "source_tables": ["allergy_type"], "description": "This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.", "virtual_table": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.518", "db_id": "allergy_1", "question": "How many students are affected by each allergy type?", "rationale": ["The query identifies the relevant tables, which are 'Has_Allergy' and 'Allergy_Type'.", "It performs a JOIN operation on the 'Allergy' column to combine data from both tables.", "The SELECT statement retrieves the 'allergytype' from the 'Allergy_Type' table and counts the number of occurrences from the 'Has_Allergy' table.", "The GROUP BY clause is used to aggregate the results by 'allergytype', allowing us to see the count of students for each type of allergy."], "gold_sql": "SELECT T2.allergytype ,  count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy GROUP BY T2.allergytype", "source_tables": ["has_allergy", "allergy_type"], "description": "This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.", "virtual_table": "SELECT T2.allergytype ,  count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy GROUP BY T2.allergytype"}
{"sample_id": "train.442", "db_id": "allergy_1", "question": "How many distinct allergies are there?", "rationale": ["The query identifies the relevant table, which is 'Allergy_Type'.", "It selects the distinct values of the 'AllergyType' column to count the unique allergy categories.", "The use of the COUNT function allows for the aggregation of these distinct values, providing a total count."], "gold_sql": "SELECT count(DISTINCT allergytype) FROM Allergy_type", "source_tables": ["allergy_type"], "description": "This virtual table provides the count of distinct allergy types from the 'Allergy_Type' table. The result will indicate how many unique categories of allergies are present in the database.", "virtual_table": "SELECT count(DISTINCT allergytype) FROM Allergy_type"}
{"sample_id": "train.512", "db_id": "allergy_1", "question": "How many students are affected by food related allergies?", "rationale": ["The query identifies the relevant tables, 'Has_Allergy' and 'Allergy_Type'.", "It uses a JOIN operation to connect these tables based on the allergy name.", "The SELECT statement counts the number of records that match the specified allergy type, using a placeholder for the allergy type in the WHERE clause."], "gold_sql": "SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  'food'", "source_tables": ["has_allergy", "allergy_type"], "description": "This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.", "virtual_table": "SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.511", "db_id": "allergy_1", "question": "How many students have a food allergy?", "rationale": ["The query identifies the relevant tables, 'Has_Allergy' and 'Allergy_Type'.", "It uses a JOIN operation to connect these tables based on the allergy name.", "The SELECT statement counts the number of records that match the specified allergy type, using a placeholder for the allergy type in the WHERE clause."], "gold_sql": "SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  'food'", "source_tables": ["has_allergy", "allergy_type"], "description": "This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.", "virtual_table": "SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.508", "db_id": "allergy_1", "question": "Which students are unaffected by allergies?", "rationale": ["The query starts by selecting the 'StuID' from the 'Student' table, which contains all students.", "Then, it uses the EXCEPT clause to remove any 'StuID' that appears in the 'Has_Allergy' table, which lists students with allergies."], "gold_sql": "SELECT StuID FROM Student EXCEPT SELECT StuID FROM Has_allergy", "source_tables": ["has_allergy", "student"], "description": "This virtual table identifies students from the 'Student' table who do not have any allergies recorded in the 'Has_Allergy' table. The query uses the EXCEPT clause to exclude students with allergies from the list of all students.", "virtual_table": "SELECT StuID FROM Student EXCEPT SELECT StuID FROM Has_allergy"}
{"sample_id": "train.450", "db_id": "allergy_1", "question": "What is allergy type of a cat allergy?", "rationale": ["The query is identifying the relevant table, which is 'Allergy_Type'.", "Select the column to display, 'AllergyType'.", "Add a condition to filter the 'Allergy' column for the specified allergy using a placeholder for string values."], "gold_sql": "SELECT allergytype FROM Allergy_type WHERE allergy  =  'Cat'", "source_tables": ["allergy_type"], "description": "This virtual table describes the type or category of a specific allergy from the 'Allergy_Type' table. The placeholder in the WHERE clause represents the name of the allergy being queried.", "virtual_table": "SELECT allergytype FROM Allergy_type WHERE allergy  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.471", "db_id": "allergy_1", "question": "Show student ids for all male students.", "rationale": ["The query is identifying the relevant table, which is 'Student'.", "Select the column to display, 'StuID'.", "Add a condition to filter the 'Sex' column for the specified gender using a placeholder for string values."], "gold_sql": "SELECT StuID FROM Student WHERE Sex  =  'M'", "source_tables": ["student"], "description": "This virtual table lists the unique identifiers of students from the 'Student' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the students.", "virtual_table": "SELECT StuID FROM Student WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1263", "db_id": "apartment_rentals", "question": "Which apartment type code is the most common among apartments with more than one bathroom?", "rationale": ["The query identifies the relevant table, which is 'Apartments'.", "It selects the 'apt_type_code' to show the different types of apartments.", "A condition is added to filter apartments based on the number of bathrooms using a placeholder for numeric values.", "The results are grouped by 'apt_type_code' to aggregate the counts of each type.", "The results are ordered by the count of apartments in descending order to show the most common types first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT apt_type_code FROM Apartments WHERE bathroom_count  >  1 GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["apartments"], "description": "This virtual table provides a summary of the types of apartments available in the 'Apartments' table that have a specified number of bathrooms. The results are grouped by the apartment type code and ordered by the count of apartments in each type, allowing users to see which types are most common based on the bathroom count. The placeholders in the WHERE clause and LIMIT clause represent the minimum number of bathrooms and the maximum number of results to return, respectively.", "virtual_table": "SELECT apt_type_code FROM Apartments WHERE bathroom_count  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1259", "db_id": "apartment_rentals", "question": "Which apartment type has the largest number of total rooms? Return the apartment type code, its number of bathrooms and number of bedrooms.", "rationale": ["The query identifies the relevant table, which is 'Apartments'.", "Selects the columns 'apt_type_code', 'bathroom_count', and 'bedroom_count' to display information about the apartments.", "Groups the results by 'apt_type_code' to aggregate data for each type of apartment.", "Orders the results by the sum of 'room_count' in descending order to prioritize apartment types with more rooms.", "Limits the number of results returned based on a placeholder for numeric values."], "gold_sql": "SELECT apt_type_code ,  bathroom_count ,  bedroom_count FROM Apartments GROUP BY apt_type_code ORDER BY sum(room_count) DESC LIMIT 1", "source_tables": ["apartments"], "description": "This virtual table summarizes the types of apartments available in the 'Apartments' table, displaying the apartment type code along with the count of bathrooms and bedrooms. The results are grouped by apartment type and ordered by the total number of rooms in descending order, with a limit on the number of results returned based on a specified numeric value.", "virtual_table": "SELECT apt_type_code ,  bathroom_count ,  bedroom_count FROM Apartments GROUP BY apt_type_code ORDER BY sum(room_count) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1260", "db_id": "apartment_rentals", "question": "Show the most common apartment type code.", "rationale": ["The query identifies the relevant table, which is 'Apartments'.", "It selects the 'apt_type_code' to show the different types of apartments.", "The GROUP BY clause is used to group the results by 'apt_type_code'.", "The ORDER BY clause sorts the grouped results by the count of apartments in each type in descending order.", "The LIMIT clause uses a placeholder to allow the user to specify how many types of apartments they want to see."], "gold_sql": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["apartments"], "description": "This virtual table provides a summary of the different types of apartments available in the 'Apartments' table. It groups the apartments by their type code and orders them by the number of apartments of each type in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of apartment types to retrieve.", "virtual_table": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1257", "db_id": "apartment_rentals", "question": "What are the top three apartment types in terms of the average room count? Give me the", "rationale": ["The query identifies the relevant table, which is 'Apartments'.", "It selects the 'apt_type_code' to display the different types of apartments.", "The results are grouped by 'apt_type_code' to aggregate the data based on apartment types.", "The average number of rooms is calculated using 'avg(room_count)' to order the types by their average room count.", "The LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY avg(room_count) DESC LIMIT 3", "source_tables": ["apartments"], "description": "This virtual table provides a summary of the different types of apartments available in the 'Apartments' table, grouped by their type code. The results are ordered by the average number of rooms in each apartment type, allowing users to see which types of apartments have more rooms on average. The placeholder in the LIMIT clause represents the maximum number of apartment types to return.", "virtual_table": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY avg(room_count) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1220", "db_id": "apartment_rentals", "question": "Show the apartment numbers, start dates, and end dates of all the apartment bookings.", "rationale": ["The query identifies the relevant tables, which are 'Apartment_Bookings' and 'Apartments'.", "It selects the 'apt_number' from the 'Apartments' table and 'booking_start_date' from the 'Apartment_Bookings' table.", "A JOIN operation is performed on the 'apt_id' to link the bookings to their respective apartments."], "gold_sql": "SELECT T2.apt_number ,  T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id", "source_tables": ["apartment_bookings", "apartments"], "description": "This virtual table provides a list of apartment numbers along with their corresponding booking start dates from the 'Apartment_Bookings' and 'Apartments' tables. The placeholders in the query represent the identifiers linking the bookings to the apartments.", "virtual_table": "SELECT T2.apt_number ,  T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id"}
{"sample_id": "train.1239", "db_id": "apartment_rentals", "question": "What are the facility codes of the apartments with more than four bedrooms?", "rationale": ["The query identifies the relevant tables, which are 'Apartment_Facilities' and 'Apartments'.", "It selects the 'facility_code' from the 'Apartment_Facilities' table.", "A JOIN operation is performed to link 'Apartment_Facilities' with 'Apartments' based on the apartment ID.", "A condition is added to filter the results based on the 'bedroom_count' in the 'Apartments' table using a placeholder for numeric values."], "gold_sql": "SELECT T1.facility_code FROM Apartment_Facilities AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  4", "source_tables": ["apartments", "apartment_facilities"], "description": "This virtual table lists the facility codes of apartments that have a specified number of bedrooms. The placeholder in the WHERE clause represents the minimum number of bedrooms required for the apartments.", "virtual_table": "SELECT T1.facility_code FROM Apartment_Facilities AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1233", "db_id": "apartment_rentals", "question": "What are the guest first name, start date, and end date of each apartment booking?", "rationale": ["The query identifies the relevant tables, 'Apartment_Bookings' and 'Guests'.", "It selects the 'guest_first_name' from the 'Guests' table and 'booking_start_date' from the 'Apartment_Bookings' table.", "A JOIN operation is performed on the 'guest_id' to link the bookings with the respective guests, ensuring that the data retrieved corresponds to the correct guest for each booking."], "gold_sql": "SELECT T2.guest_first_name ,  T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id", "source_tables": ["apartment_bookings", "guests"], "description": "This virtual table provides the first names of guests along with the start dates of their apartment bookings. The placeholders in the query allow for filtering or additional conditions to be applied as needed.", "virtual_table": "SELECT T2.guest_first_name ,  T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id"}
{"sample_id": "train.1221", "db_id": "apartment_rentals", "question": "What are the apartment number, start date, and end date of each apartment booking?", "rationale": ["The query identifies the relevant tables, 'Apartment_Bookings' and 'Apartments'.", "It selects the 'apt_number' from the 'Apartments' table and the 'booking_start_date' from the 'Apartment_Bookings' table.", "A JOIN operation is performed to link the two tables based on the 'apt_id' to ensure that the correct apartment number corresponds to each booking."], "gold_sql": "SELECT T2.apt_number ,  T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id", "source_tables": ["apartment_bookings", "apartments"], "description": "This virtual table provides information about apartment bookings, specifically the apartment number and the start date of the booking. The placeholders in the query allow for filtering or additional conditions to be applied as needed.", "virtual_table": "SELECT T2.apt_number ,  T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id"}
{"sample_id": "train.1223", "db_id": "apartment_rentals", "question": "Return the booking start date and end date for the apartments that have type code \"Duplex\".", "rationale": ["The query identifies the relevant tables, 'Apartment_Bookings' and 'Apartments'.", "It selects the 'booking_start_date' from the 'Apartment_Bookings' table.", "A JOIN is performed on the 'apt_id' to link bookings to their respective apartments.", "A condition is added to filter the results based on the 'apt_type_code' using a placeholder for string values."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.apt_type_code  =  'Duplex'", "source_tables": ["apartment_bookings", "apartments"], "description": "This virtual table provides the start dates of apartment bookings from the 'Apartment_Bookings' table for apartments of a specific type. The placeholder in the WHERE clause represents the apartment type code.", "virtual_table": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.apt_type_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1235", "db_id": "apartment_rentals", "question": "What are the start date and end date of the apartment bookings made by female guests (gender code \"Female\")?", "rationale": ["The query identifies the relevant tables, which are 'Apartment_Bookings' and 'Guests'.", "It selects the 'booking_start_date' and 'booking_end_date' from the 'Apartment_Bookings' table.", "A JOIN operation is performed between 'Apartment_Bookings' and 'Guests' on the 'guest_id' to link bookings to guests.", "A condition is added to filter the results based on the 'gender_code' of the guests using a placeholder for string values."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id WHERE T2.gender_code  =  'Female'", "source_tables": ["apartment_bookings", "guests"], "description": "This virtual table provides the start dates of apartment bookings along with the corresponding booking end dates for guests filtered by a specific gender. The placeholders in the WHERE clause represent the gender code of the guests.", "virtual_table": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id WHERE T2.gender_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3669", "db_id": "baseball_1", "question": "What are the name and id of the team with the most victories in 2008 postseason?", "rationale": ["The query identifies the relevant tables, 'postseason' and 'team'.", "It selects the team names from the 'team' table and the winning team identifiers from the 'postseason' table.", "A join is performed on the winning team identifier to match it with the team identifier in the 'team' table.", "A condition is added to filter the results for a specific year using a placeholder for numeric values.", "The results are grouped by the winning team identifier to aggregate the wins and ordered by the count of wins in descending order.", "A limit is applied to restrict the number of results returned."], "gold_sql": "SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  2008 GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["postseason", "team"], "description": "This virtual table provides the names of the winning teams and their corresponding identifiers from the postseason table for a specific year. The results are grouped by the winning team identifier and ordered by the count of wins in descending order, with a limit on the number of results returned.", "virtual_table": "SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3671", "db_id": "baseball_1", "question": "What is the number of wins the team Boston Red Stockings got in the postseasons each year in history?", "rationale": ["The query identifies the relevant tables, 'postseason' and 'team'.", "It selects the count of wins and the year from the 'postseason' table.", "A JOIN is performed between 'postseason' and 'team' on the winning team identifier to filter results based on the team name.", "The WHERE clause uses a placeholder to specify the team name, allowing for dynamic querying.", "The results are grouped by year to provide a count of wins for each year."], "gold_sql": "SELECT count(*) ,  T1.year FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' GROUP BY T1.year", "source_tables": ["postseason", "team"], "description": "This virtual table provides the count of postseason wins for a specific team across different years. The placeholder in the WHERE clause represents the name of the team for which the postseason wins are being queried.", "virtual_table": "SELECT count(*) ,  T1.year FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.year"}
{"sample_id": "train.3684", "db_id": "baseball_1", "question": "List all the salary values players received in 2010 and 2001.", "rationale": ["The query identifies the relevant table, which is 'salary'.", "It selects the 'salary' column to display the salary amounts.", "The UNION operator is used to combine results from two different years, with placeholders for the specific years in the WHERE clause."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2010 UNION SELECT salary FROM salary WHERE YEAR  =  2001", "source_tables": ["salary"], "description": "This virtual table provides the salary records for players in two specific years from the 'salary' table. The placeholders in the WHERE clause represent the years for which the salary data is being queried.", "virtual_table": "SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3641", "db_id": "baseball_1", "question": "In 2014, what are the id and rank of the team that has the largest average number of attendance?", "rationale": ["The query identifies the relevant tables, 'home_game' and 'team'.", "It selects the 'team_id' and 'rank' columns from the 'team' table.", "A JOIN operation is performed between 'home_game' and 'team' on the 'team_id' column to combine relevant data.", "A WHERE clause filters the results for a specific year using a placeholder for numeric values.", "The results are grouped by 'team_id' to aggregate attendance data.", "The ORDER BY clause sorts the results based on the average attendance in descending order.", "A LIMIT clause restricts the number of results returned based on a specified maximum."], "gold_sql": "SELECT T2.team_id ,  T2.rank FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id WHERE T1.year  =  2014 GROUP BY T1.team_id ORDER BY avg(T1.attendance) DESC LIMIT 1;", "source_tables": ["team", "home_game"], "description": "This virtual table provides the team IDs and their ranks for teams that hosted home games in a specific year. The results are grouped by team ID and ordered by the average attendance of the home games in descending order, with a limit on the number of results returned. The placeholders represent the year of the home games and the maximum number of teams to display.", "virtual_table": "SELECT T2.team_id ,  T2.rank FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id ORDER BY avg(T1.attendance) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3670", "db_id": "baseball_1", "question": "Find the name and id of the team that won the most times in 2008 postseason.", "rationale": ["The query identifies the relevant tables, 'postseason' and 'team'.", "It selects the team name from the 'team' table and the winning team ID from the 'postseason' table.", "A JOIN operation is performed to link the winning team ID with the corresponding team name using the team ID.", "A condition is added to filter the results for a specific year using a placeholder for numeric values.", "The results are grouped by the winning team ID to aggregate the data and ordered by the count of wins in descending order.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  2008 GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["postseason", "team"], "description": "This virtual table provides the names of the winning teams and their corresponding team IDs from the postseason table for a specific year. The results are grouped by the winning team ID and ordered by the number of wins in descending order, with a limit on the number of results returned.", "virtual_table": "SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3647", "db_id": "baseball_1", "question": "Which 3 players won the most player awards? List their full name and id.", "rationale": ["The query identifies the relevant tables, 'player' and 'player_award'.", "It selects the first name, last name, and player ID from the 'player' table.", "A JOIN operation is performed on 'player_award' to link players with their awards using the player ID.", "The results are grouped by player ID to avoid duplicates and to count the number of awards per player.", "The results are ordered by the count of awards in descending order to show the most awarded players first.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for the user to specify the desired number."], "gold_sql": "SELECT T1.name_first ,  T1.name_last ,  T1.player_id FROM player AS T1 JOIN player_award AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.player_id ORDER BY count(*) DESC LIMIT 3;", "source_tables": ["player_award", "player"], "description": "This virtual table provides a list of players along with their first and last names from the 'player' table, who have received awards. The results are grouped by player ID to ensure uniqueness and are ordered by the number of awards received in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of players to return.", "virtual_table": "SELECT T1.name_first ,  T1.name_last ,  T1.player_id FROM player AS T1 JOIN player_award AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.player_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3662", "db_id": "baseball_1", "question": "Which players won awards in both 1960 and 1961? Return their first names and last names.", "rationale": ["The query identifies the relevant table, which is 'player' and 'player_award'.", "It selects the columns to display, 'name_first' and 'name_last'.", "The JOIN operation connects the 'player' table with the 'player_award' table based on the player ID.", "The INTERSECT operation is used to find players who received awards in both specified years, using placeholders for the years in the WHERE clause."], "gold_sql": "SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1960 INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1961", "source_tables": ["player_award", "player"], "description": "This virtual table describes the first and last names of players who received awards in two specific years. The placeholders in the WHERE clause represent the years for which the awards were given.", "virtual_table": "SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3697", "db_id": "baseball_1", "question": "List players' first name and last name who received salary from team Washington Nationals in both 2005 and 2007.", "rationale": ["The query identifies the relevant tables: 'salary', 'player', and 'team'.", "It selects the 'name_first' and 'name_last' columns from the 'player' table.", "The 'salary' table is joined with the 'player' table using the 'player_id' to link salary records to players.", "The 'team' table is joined to associate players with their respective teams using the 'team_id_br'.", "Conditions are added to filter results based on the specified year and team name using placeholders for user input.", "The INTERSECT operator is used to ensure that the results are distinct and meet both conditions."], "gold_sql": "SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2005 AND T3.name = 'Washington Nationals' INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2007 AND T3.name = 'Washington Nationals'", "source_tables": ["team", "player", "salary"], "description": "This virtual table retrieves the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.", "virtual_table": "SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3700", "db_id": "baseball_1", "question": "Count the total number of games the team Boston Red Stockings attended from 1990 to 2000.", "rationale": ["The query identifies the relevant tables, 'home_game' and 'team'.", "It selects the sum of the 'games' column from the 'home_game' table.", "A join is performed between 'home_game' and 'team' on the 'team_id' to link the games to the specific team.", "A condition is added to filter by the team's name using a placeholder for string values.", "Another condition is added to filter the years using placeholders for numeric values."], "gold_sql": "SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = 'Boston Red Stockings' AND T1.year BETWEEN 1990 AND 2000;", "source_tables": ["team", "home_game"], "description": "This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.", "virtual_table": "SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3707", "db_id": "baseball_1", "question": "Which cities have 2 to 4 parks?", "rationale": ["The query identifies the relevant table, which is 'park'.", "It selects the 'city' column to display the cities where parks are located.", "The GROUP BY clause is used to group the results by city.", "The HAVING clause filters the grouped results to include only those cities that have a count of parks within a specified range, using placeholders for the minimum and maximum counts."], "gold_sql": "SELECT city FROM park GROUP BY city HAVING count(*) BETWEEN 2 AND 4;", "source_tables": ["park"], "description": "This virtual table lists the cities where parks are located, specifically those that have a number of parks within a specified range. The placeholders in the HAVING clause represent the minimum and maximum number of parks that should be present in those cities.", "virtual_table": "SELECT city FROM park GROUP BY city HAVING count(*) BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3638", "db_id": "baseball_1", "question": "Count the number of players who enter hall of fame for each year.", "rationale": ["The query identifies the relevant table, which is 'hall_of_fame'.", "It selects the 'yearid' to group the results by year.", "The count function is used to aggregate the number of players inducted for each year, and the results are grouped by 'yearid' to provide a count for each distinct year."], "gold_sql": "SELECT yearid ,  count(*) FROM hall_of_fame GROUP BY yearid;", "source_tables": ["hall_of_fame"], "description": "This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.", "virtual_table": "SELECT yearid ,  count(*) FROM hall_of_fame GROUP BY yearid;"}
{"sample_id": "train.3694", "db_id": "baseball_1", "question": "How many games in total did team Boston Red Stockings attend from 2000 to 2010?", "rationale": ["The query identifies the relevant tables, 'home_game' and 'team'.", "It selects the sum of the 'attendance' column from the 'home_game' table.", "A join is performed between 'home_game' and 'team' on the 'team_id' to link attendance data with team information.", "A condition is added to filter by the team's name using a placeholder for string values.", "Another condition is included to filter the years of the home games using placeholders for numeric values."], "gold_sql": "SELECT sum(T1.attendance) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' AND T1.year BETWEEN 2000 AND 2010;", "source_tables": ["team", "home_game"], "description": "This virtual table calculates the total attendance for home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the attendance data.", "virtual_table": "SELECT sum(T1.attendance) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3701", "db_id": "baseball_1", "question": "Which team had the least number of attendances in home games in 1980?", "rationale": ["The query identifies the relevant tables, 'home_game' and 'team'.", "It selects the 'name' column from the 'team' table, which contains the names of the teams.", "A JOIN operation is performed between 'home_game' and 'team' on the 'team_id' to link home games with their respective teams.", "A condition is added to filter the results based on the specified year using a placeholder for numeric values.", "The results are ordered by the 'attendance' column in ascending order and limited to a specified number of results using placeholders."], "gold_sql": "SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = 1980 ORDER BY T1.attendance ASC LIMIT 1;", "source_tables": ["team", "home_game"], "description": "This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.", "virtual_table": "SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3710", "db_id": "baseball_1", "question": "Which park did the most people attend in 2008?", "rationale": ["The query identifies the relevant tables, 'home_game' and 'park'.", "It selects the 'park_name' from the 'park' table.", "A join is performed between 'home_game' and 'park' on the 'park_id' to link home games to their respective parks.", "A condition is added to filter the results for a specific year using a placeholder for numeric values.", "The results are ordered by attendance in descending order and limited to a specified number using placeholders."], "gold_sql": "SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 2008 ORDER BY T1.attendance DESC LIMIT 1;", "source_tables": ["park", "home_game"], "description": "This virtual table provides a list of park names where home games were played in a specific year, ordered by attendance in descending order. The placeholders represent the year of the home games and the limit on the number of park names to return.", "virtual_table": "SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3699", "db_id": "baseball_1", "question": "How many home games did the team Boston Red Stockings play from 1990 to 2000 in total?", "rationale": ["The query identifies the relevant tables, 'home_game' and 'team'.", "It selects the sum of the 'games' column from the 'home_game' table.", "A join is performed between 'home_game' and 'team' on the 'team_id' to link the games to the specific team.", "A condition is added to filter by the team's name using a placeholder for string values.", "Another condition is added to filter the years using placeholders for numeric values."], "gold_sql": "SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = 'Boston Red Stockings' AND T1.year BETWEEN 1990 AND 2000;", "source_tables": ["team", "home_game"], "description": "This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.", "virtual_table": "SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3649", "db_id": "baseball_1", "question": "List three countries which are the origins of the least players.", "rationale": ["The query identifies the relevant table, which is 'player'.", "It selects the 'birth_country' column to display the countries of birth.", "The results are grouped by 'birth_country' to aggregate the data.", "The results are ordered by the count of players from each country in ascending order.", "The LIMIT clause uses a placeholder to allow the user to specify how many countries to return."], "gold_sql": "SELECT birth_country FROM player GROUP BY birth_country ORDER BY count(*) ASC LIMIT 3;", "source_tables": ["player"], "description": "This virtual table provides a list of countries where players were born, grouped by country and ordered by the number of players from each country in ascending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of countries to return.", "virtual_table": "SELECT birth_country FROM player GROUP BY birth_country ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3652", "db_id": "baseball_1", "question": "What are the first name and last name of the players whose death record is empty?", "rationale": ["The query identifies the relevant table, which is 'player'.", "Select the columns to display, 'name_first' and 'name_last'.", "Add a condition to filter the 'death_year' column for the specified year using a placeholder for string values."], "gold_sql": "SELECT name_first ,  name_last FROM player WHERE death_year = '';", "source_tables": ["player"], "description": "This virtual table describes the first and last names of players from the 'player' table who have a specified year of death. The placeholder in the WHERE clause represents the year of death.", "virtual_table": "SELECT name_first ,  name_last FROM player WHERE death_year = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.3651", "db_id": "baseball_1", "question": "Find all the players' first name and last name who have empty death record.", "rationale": ["The query identifies the relevant table, which is 'player'.", "Select the columns to display, 'name_first' and 'name_last'.", "Add a condition to filter the 'death_year' column for the specified year using a placeholder for string values."], "gold_sql": "SELECT name_first ,  name_last FROM player WHERE death_year = '';", "source_tables": ["player"], "description": "This virtual table describes the first and last names of players from the 'player' table who have a recorded year of death. The placeholder in the WHERE clause represents the specific year of death being queried.", "virtual_table": "SELECT name_first ,  name_last FROM player WHERE death_year = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.3678", "db_id": "baseball_1", "question": "What is the total salary expenses of team Boston Red Stockings in 2010?", "rationale": ["The query identifies the relevant tables, 'salary' and 'team'.", "It selects the sum of salaries from the 'salary' table.", "A join is performed between 'salary' and 'team' on the team identifier to link salary records to the corresponding team.", "Conditions are added to filter results based on the specified team name and year using placeholders for string and numeric values."], "gold_sql": "SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings' AND T1.year  =  2010", "source_tables": ["team", "salary"], "description": "This virtual table calculates the total salary of players from a specific team for a given year. The placeholders represent the team's name and the year for which the salary data is being queried.", "virtual_table": "SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3632", "db_id": "baseball_1", "question": "Compute the average salary of the players in the team called 'Boston Red Stockings'.", "rationale": ["The query identifies the relevant tables, which are 'salary' and 'team'.", "It selects the average salary from the 'salary' table.", "A JOIN is performed between the 'salary' table and the 'team' table based on the team identifier.", "A condition is added to filter the results based on the specified team name using a placeholder for string values."], "gold_sql": "SELECT avg(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings'", "source_tables": ["team", "salary"], "description": "This virtual table calculates the average salary of players from a specific team in the 'salary' table. The placeholder in the WHERE clause represents the name of the team for which the average salary is being calculated.", "virtual_table": "SELECT avg(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3667", "db_id": "baseball_1", "question": "How many times did Boston Red Stockings lose in 2009 postseason?", "rationale": ["The query identifies the relevant tables, 'postseason' and 'team'.", "It uses a JOIN to connect the 'postseason' table with the 'team' table based on the losing team's identifier.", "The SELECT statement counts the number of records that match the specified team name and year, using placeholders for these values."], "gold_sql": "SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' AND T1.year = 2009;", "source_tables": ["postseason", "team"], "description": "This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.", "virtual_table": "SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3668", "db_id": "baseball_1", "question": "Count the number of times the team \"Boston Red Stockings\" lost in 2009 postseason.", "rationale": ["The query identifies the relevant tables, 'postseason' and 'team'.", "It joins these tables on the condition that the losing team's identifier matches the team's identifier in the 'team' table.", "The SELECT statement counts the number of losses for the specified team in the specified year, using placeholders for the team name and year."], "gold_sql": "SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' AND T1.year = 2009;", "source_tables": ["postseason", "team"], "description": "This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.", "virtual_table": "SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3679", "db_id": "baseball_1", "question": "How many players were in the team Boston Red Stockings in 2000?", "rationale": ["The query identifies the relevant tables, 'salary' and 'team'.", "It joins the 'salary' table with the 'team' table on the 'team_id_br' to ensure the correct team is referenced.", "The SELECT statement counts the number of salary records for the specified team name and year, using placeholders for these values."], "gold_sql": "SELECT count(*) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings' AND T1.year  =  2000", "source_tables": ["team", "salary"], "description": "This virtual table provides the total count of salary records for a specific team in a given year. The placeholders represent the team's name and the year for which the salary records are being queried.", "virtual_table": "SELECT count(*) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3674", "db_id": "baseball_1", "question": "How many times in total did the team Boston Red Stockings participate in postseason games?", "rationale": ["The query identifies the relevant tables, 'postseason' and 'team'.", "It uses a UNION to combine results from two SELECT statements: one for wins and one for losses.", "Each SELECT statement joins the 'postseason' table with the 'team' table based on the winning and losing team identifiers.", "The WHERE clause filters the results based on the specified team name using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM ( SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' UNION SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' );", "source_tables": ["postseason", "team"], "description": "This virtual table counts the total number of postseason appearances for a specific team, including both wins and losses. It combines data from the 'postseason' table and the 'team' table, filtering by the team's name provided as a placeholder.", "virtual_table": "SELECT count(*) FROM ( SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] );"}
{"sample_id": "train.3673", "db_id": "baseball_1", "question": "What is the total number of postseason games that team Boston Red Stockings participated in?", "rationale": ["The query identifies the relevant tables, which are 'postseason' and 'team'.", "It uses a UNION to combine results from two SELECT statements: one for wins and one for losses.", "Each SELECT statement joins the 'postseason' table with the 'team' table based on the winning and losing team IDs, respectively.", "The WHERE clause filters the results based on the specified team name using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM ( SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' UNION SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' );", "source_tables": ["postseason", "team"], "description": "This virtual table counts the total number of postseason appearances for a specific team, including both wins and losses. It combines data from the 'postseason' table and the 'team' table, filtering by the team's name provided as a placeholder.", "virtual_table": "SELECT count(*) FROM ( SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] );"}
{"sample_id": "train.3680", "db_id": "baseball_1", "question": "How many players did Boston Red Stockings have in 2000?", "rationale": ["The query identifies the relevant tables, 'salary' and 'team'.", "It joins the 'salary' table with the 'team' table on the 'team_id_br' to ensure the correct team is referenced.", "The SELECT statement counts the number of salary records for the specified team name and year, using placeholders for these values."], "gold_sql": "SELECT count(*) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings' AND T1.year  =  2000", "source_tables": ["team", "salary"], "description": "This virtual table provides the total count of salary records for a specific team in a given year. The placeholders represent the team's name and the year for which the salary records are being queried.", "virtual_table": "SELECT count(*) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.142", "db_id": "bike_1", "question": "What are the ids of the stations in San Francisco that normally have more than 10 bikes available?", "rationale": ["The query starts by selecting the 'id' from the 'station' table where the 'city' matches a specified value.", "It uses the INTERSECT operator to combine results with another query that selects 'station_id' from the 'status' table.", "The second part groups the results by 'station_id' and filters them using the HAVING clause to ensure that only those with an average of 'bikes_available' greater than a specified number are included."], "gold_sql": "SELECT id FROM station WHERE city  =  'San Francisco' INTERSECT SELECT station_id FROM status GROUP BY station_id HAVING avg(bikes_available)  >  10", "source_tables": ["status", "station"], "description": "This virtual table identifies the unique station IDs from the 'station' table located in a specific city. It intersects with the 'status' table to find stations that have an average number of available bikes greater than a specified threshold. The placeholders in the WHERE clause and HAVING clause represent the city name and the minimum average bikes available, respectively.", "virtual_table": "SELECT id FROM station WHERE city  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT station_id FROM status GROUP BY station_id HAVING avg(bikes_available)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.195", "db_id": "bike_1", "question": "Find all the zip codes in which the max dew point have never reached 70.", "rationale": ["The query starts by selecting distinct zip codes from the 'weather' table.", "It uses the EXCEPT clause to exclude zip codes that have a maximum dew point greater than or equal to a specified value.", "The placeholder in the WHERE clause is used to represent the maximum dew point threshold for filtering the results."], "gold_sql": "SELECT DISTINCT zip_code FROM weather EXCEPT SELECT DISTINCT zip_code FROM weather WHERE max_dew_point_f  >=  70", "source_tables": ["weather"], "description": "This virtual table provides a list of unique zip codes from the 'weather' table that do not have any weather reports with a maximum dew point above a specified threshold. The placeholder in the query represents the maximum dew point value that is being used to filter the results.", "virtual_table": "SELECT DISTINCT zip_code FROM weather EXCEPT SELECT DISTINCT zip_code FROM weather WHERE max_dew_point_f  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.208", "db_id": "bike_1", "question": "What are the names of the stations that are located in Palo Alto but have never been the ending point of the trips", "rationale": ["The query identifies the relevant table, which is 'station', to retrieve the names of bike stations.", "It filters the results based on the specified city using a placeholder for string values.", "The EXCEPT clause is used to exclude the names of stations that appear as end stations in the 'trip' table, which is determined by counting the occurrences of each end station name.", "A placeholder is included to specify the minimum count of trips for exclusion."], "gold_sql": "SELECT name FROM station WHERE city  =  'Palo Alto' EXCEPT SELECT end_station_name FROM trip GROUP BY end_station_name HAVING count(*)  >  100", "source_tables": ["trip", "station"], "description": "This virtual table lists the names of bike stations located in a specific city, excluding those stations that have been used as end stations for trips more than a specified number of times. The placeholders in the WHERE clause represent the city name and the count of trips.", "virtual_table": "SELECT name FROM station WHERE city  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT end_station_name FROM trip GROUP BY end_station_name HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.134", "db_id": "bike_1", "question": "What are the start station's name and id for the one that had the most start trips in August?", "rationale": ["The query identifies the relevant table, which is 'trip'.", "Select the columns to display, 'start_station_name' and 'start_station_id'.", "Add a condition to filter the 'start_date' column for the specified date using a placeholder for string values.", "Group the results by 'start_station_name' to aggregate the trips per station.", "Order the results by the count of trips in descending order to show the most popular starting stations first.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE '8/%' GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["trip"], "description": "This virtual table provides the names and identifiers of bike stations from which trips started, filtered by a specific start date. The results are grouped by station name and ordered by the number of trips, allowing users to see the most popular starting stations for that date. The placeholders in the WHERE clause represent the start date and the limit for the number of results returned.", "virtual_table": "SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE [PLACEHOLDER-TYPE:STRING] GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.155", "db_id": "bike_1", "question": "Give me ids for all the trip that took place in a zip code area with average mean temperature above 60.", "rationale": ["The query is identifying the relevant tables, which are 'trip' and 'weather'.", "It selects the unique trip IDs from the 'trip' table (aliased as T1).", "A JOIN operation is performed between 'trip' and 'weather' on the zip code to correlate trips with weather data.", "The results are grouped by zip code to aggregate the weather data for each area.", "The HAVING clause filters the groups to include only those with an average mean temperature above a specified numeric value, represented by a placeholder."], "gold_sql": "SELECT T1.id FROM trip AS T1 JOIN weather AS T2 ON T1.zip_code  =  T2.zip_code GROUP BY T2.zip_code HAVING avg(T2.mean_temperature_f)  >  60", "source_tables": ["weather", "trip"], "description": "This virtual table identifies unique trip IDs from the 'trip' table for users whose starting zip code corresponds to weather reports with an average mean temperature above a specified threshold. The placeholder in the HAVING clause represents the temperature limit for filtering the results.", "virtual_table": "SELECT T1.id FROM trip AS T1 JOIN weather AS T2 ON T1.zip_code  =  T2.zip_code GROUP BY T2.zip_code HAVING avg(T2.mean_temperature_f)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.133", "db_id": "bike_1", "question": "Which start station had the most trips starting from August? Give me the name and id of the station.", "rationale": ["The query identifies the relevant table, which is 'trip'.", "Selects the columns to display, 'start_station_name' and 'start_station_id'.", "Adds a condition to filter the 'start_date' column using a placeholder for string values.", "Groups the results by 'start_station_name' to aggregate the trips per station.", "Orders the results by the count of trips in descending order to show the most popular starting stations first.", "Limits the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE '8/%' GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["trip"], "description": "This virtual table provides a list of bike stations from which trips started, along with their unique identifiers. The results are filtered by a specific start date pattern, grouped by the station name, and ordered by the number of trips in descending order, limited to a specified number of results. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the date pattern and the number of results to return.", "virtual_table": "SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE [PLACEHOLDER-TYPE:STRING] GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.172", "db_id": "bike_1", "question": "What are the names of all stations that have more than 10 bikes available and are not located in San Jose?", "rationale": ["The query identifies the relevant tables, which are 'station' and 'status'.", "It selects the 'name' column from the 'station' table.", "The JOIN operation links the 'station' and 'status' tables based on the station ID.", "The GROUP BY clause is used to group the results by station ID to calculate the average number of bikes available.", "The HAVING clause filters the results to include only those stations with an average number of bikes available greater than a specified number using a placeholder.", "The EXCEPT clause excludes any stations that are located in a specified city, using a placeholder for the city name."], "gold_sql": "SELECT T1.name FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(bikes_available)  >  10 EXCEPT SELECT name FROM station WHERE city  =  'San Jose'", "source_tables": ["status", "station"], "description": "This virtual table lists the names of bike stations that have an average number of bikes available greater than a specified number, excluding those located in a specific city. The query combines data from the 'station' and 'status' tables, grouping by station ID to calculate the average bikes available, and uses placeholders for the average bike count and city name.", "virtual_table": "SELECT T1.name FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(bikes_available)  >  [PLACEHOLDER-TYPE:NUMBER] EXCEPT SELECT name FROM station WHERE city  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.156", "db_id": "bike_1", "question": "For each zip code, find the ids of all trips that have a higher average mean temperature above 60?", "rationale": ["The query is identifying the relevant tables, which are 'trip' and 'weather'.", "It selects the unique trip IDs from the 'trip' table (aliased as T1).", "A JOIN operation is performed between 'trip' and 'weather' on the zip code to correlate trips with weather data.", "The results are grouped by zip code to calculate the average mean temperature for each group.", "The HAVING clause filters the groups to include only those with an average mean temperature greater than a specified number, using a placeholder for numeric values."], "gold_sql": "SELECT T1.id FROM trip AS T1 JOIN weather AS T2 ON T1.zip_code  =  T2.zip_code GROUP BY T2.zip_code HAVING avg(T2.mean_temperature_f)  >  60", "source_tables": ["weather", "trip"], "description": "This virtual table identifies unique trip IDs from the 'trip' table for users whose starting zip code corresponds to weather reports with an average mean temperature above a specified threshold. The placeholder in the HAVING clause represents the temperature limit for filtering the results.", "virtual_table": "SELECT T1.id FROM trip AS T1 JOIN weather AS T2 ON T1.zip_code  =  T2.zip_code GROUP BY T2.zip_code HAVING avg(T2.mean_temperature_f)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.146", "db_id": "bike_1", "question": "What are the 3 most common cloud covers in the zip code of 94107?", "rationale": ["The query identifies the relevant table, which is 'weather'.", "It selects the 'cloud_cover' column to display the cloud cover data.", "A condition is added to filter the results based on the specified zip code using a placeholder for numeric values.", "The results are grouped by 'cloud_cover' to aggregate the data.", "The results are ordered by the count of occurrences of each cloud cover value in descending order.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT cloud_cover FROM weather WHERE zip_code  =  94107 GROUP BY cloud_cover ORDER BY COUNT (*) DESC LIMIT 3", "source_tables": ["weather"], "description": "This virtual table provides the cloud cover data from the 'weather' table for a specific zip code. The results are grouped by cloud cover values and ordered by the frequency of each cloud cover value, allowing users to see the most common cloud cover conditions for the specified area, limited to a certain number of results.", "virtual_table": "SELECT cloud_cover FROM weather WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY cloud_cover ORDER BY COUNT (*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.198", "db_id": "bike_1", "question": "What are the ids of all trips that had a duration as long as the average trip duration in the zip code 94103?", "rationale": ["The query is identifying the relevant table, which is 'trip'.", "Select the 'id' column to display the unique identifiers of the trips.", "Add a condition to filter the trips based on their duration, ensuring it is greater than or equal to the average duration.", "The average duration is calculated using a subquery that filters trips by a specific zip code, represented by a placeholder for numeric values."], "gold_sql": "SELECT id FROM trip WHERE duration  >=  (SELECT avg(duration) FROM trip WHERE zip_code  =  94103)", "source_tables": ["trip"], "description": "This virtual table identifies the unique trip identifiers from the 'trip' table where the duration of the trip is greater than or equal to the average duration of trips associated with a specific zip code. The placeholder in the subquery represents the user's zip code.", "virtual_table": "SELECT id FROM trip WHERE duration  >=  (SELECT avg(duration) FROM trip WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.204", "db_id": "bike_1", "question": "What are the different ids and names of the stations that have had more than 12 bikes available?", "rationale": ["The query identifies the relevant tables, which are 'station' and 'status'.", "It selects distinct columns 'id' and 'name' from the 'station' table.", "A JOIN operation is performed between 'station' and 'status' on the station's identifier to combine relevant data.", "A condition is added to filter the results based on the number of bikes available using a placeholder for numeric values."], "gold_sql": "SELECT DISTINCT T1.id ,  T1.name FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id WHERE T2.bikes_available  >  12", "source_tables": ["status", "station"], "description": "This virtual table provides a list of unique bike stations that currently have a certain number of bikes available. The data is retrieved from the 'station' table, which includes the station's unique identifier and name, and is filtered based on the availability of bikes from the 'status' table. The placeholder in the WHERE clause represents the minimum number of bikes that must be available at the station.", "virtual_table": "SELECT DISTINCT T1.id ,  T1.name FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id WHERE T2.bikes_available  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.191", "db_id": "bike_1", "question": "For each station, find its latitude and the minimum duration of trips that ended at the station.", "rationale": ["The query identifies the relevant tables, which are 'station' and 'trip'.", "It selects the 'name' and 'lat' columns from the 'station' table (aliased as T1).", "It calculates the minimum trip duration from the 'trip' table (aliased as T2) for trips that ended at each station.", "The JOIN operation links the two tables on the condition that the 'id' of the station matches the 'end_station_id' of the trip.", "The results are grouped by 'end_station_id' to ensure that the minimum duration is calculated for each station."], "gold_sql": "SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id", "source_tables": ["trip", "station"], "description": "This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.", "virtual_table": "SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id"}
{"sample_id": "train.160", "db_id": "bike_1", "question": "Which days had a minimum dew point smaller than any day in zip code 94107, and in which zip codes were those measurements taken?", "rationale": ["The query identifies the relevant table, which is 'weather'.", "Select the columns to display, 'date' and 'zip_code'.", "Add a condition to filter the 'min_dew_point_f' column to be less than a subquery that retrieves the minimum dew point for a specified zip code using a placeholder for numeric values."], "gold_sql": "SELECT date ,  zip_code FROM weather WHERE min_dew_point_f  <  (SELECT min(min_dew_point_f) FROM weather WHERE zip_code  =  94107)", "source_tables": ["weather"], "description": "This virtual table provides the dates and zip codes of weather reports where the minimum dew point is less than the minimum dew point recorded for a specific zip code. The placeholder in the subquery represents the zip code for which the minimum dew point is being compared.", "virtual_table": "SELECT date ,  zip_code FROM weather WHERE min_dew_point_f  <  (SELECT min(min_dew_point_f) FROM weather WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.137", "db_id": "bike_1", "question": "How many days had both mean humidity above 50 and mean visibility above 8?", "rationale": ["The query identifies the relevant table, which is 'weather'.", "It uses the COUNT function to count the number of records that meet the specified conditions.", "The WHERE clause filters the records based on mean humidity and mean visibility, using placeholders for numeric values."], "gold_sql": "SELECT COUNT(*) FROM weather WHERE mean_humidity  >  50 AND mean_visibility_miles  >  8", "source_tables": ["weather"], "description": "This virtual table provides the count of weather reports from the 'weather' table where the mean humidity exceeds a specified threshold and the mean visibility in miles also exceeds another specified threshold. The placeholders in the WHERE clause represent the numeric values for mean humidity and mean visibility that the user can define.", "virtual_table": "SELECT COUNT(*) FROM weather WHERE mean_humidity  >  [PLACEHOLDER-TYPE:NUMBER] AND mean_visibility_miles  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.211", "db_id": "bike_1", "question": "What is the average latitude and longitude of the starting points of all trips?", "rationale": ["The query identifies the relevant tables, which are 'station' and 'trip'.", "It selects the average latitude and longitude from the 'station' table.", "A JOIN operation is performed between 'station' and 'trip' on the condition that the station ID matches the start station ID in the trip table, allowing us to focus on stations where trips have started."], "gold_sql": "SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id", "source_tables": ["trip", "station"], "description": "This virtual table calculates the average latitude and longitude of bike stations from the 'station' table where trips have started. The placeholders in the query allow for further filtering or modifications based on specific criteria.", "virtual_table": "SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id"}
{"sample_id": "train.188", "db_id": "bike_1", "question": "What are the ids of the trips that lasted the longest and how long did they last?", "rationale": ["The query identifies the relevant table, which is 'trip'.", "Select the columns to display, 'id' and 'duration'.", "Order the results by 'duration' in descending order to show the longest trips first.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT id ,  duration FROM trip ORDER BY duration DESC LIMIT 3", "source_tables": ["trip"], "description": "This virtual table provides a list of trip identifiers and their corresponding durations from the 'trip' table, sorted in descending order by duration. The placeholder in the LIMIT clause allows the user to specify the maximum number of records to return.", "virtual_table": "SELECT id ,  duration FROM trip ORDER BY duration DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.164", "db_id": "bike_1", "question": "What is the id of the trip that started from the station with the highest dock count?", "rationale": ["The query identifies the relevant tables, which are 'trip' and 'station'.", "It selects the 'id' column from the 'trip' table, which represents unique trip identifiers.", "A JOIN operation is performed between the 'trip' table and the 'station' table based on the start station ID to associate trips with their starting stations.", "The results are ordered by the 'dock_count' column from the 'station' table in descending order to prioritize stations with more docks.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT 1", "source_tables": ["trip", "station"], "description": "This virtual table lists the unique identifiers of trips from the 'trip' table, specifically focusing on those that started at various bike stations. The results are ordered by the number of docks available at each station in descending order, allowing users to see which stations with the most docks are associated with the trips. The placeholder in the LIMIT clause represents the maximum number of trip IDs to return.", "virtual_table": "SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.153", "db_id": "bike_1", "question": "When and in what zip code did max temperature reach 80?", "rationale": ["The query identifies the relevant table, which is 'weather'.", "Select the columns to display, 'date' and 'zip_code'.", "Add a condition to filter the 'max_temperature_f' column for values greater than or equal to the specified threshold using a placeholder for numeric values."], "gold_sql": "SELECT date ,  zip_code FROM weather WHERE max_temperature_f  >=  80", "source_tables": ["weather"], "description": "This virtual table provides the dates and zip codes of weather reports where the maximum temperature reached a specified threshold. The placeholder in the WHERE clause represents the minimum temperature value to filter the results.", "virtual_table": "SELECT date ,  zip_code FROM weather WHERE max_temperature_f  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.212", "db_id": "bike_1", "question": "What is the average latitude and longitude of all starting stations for the trips?", "rationale": ["The query identifies the relevant tables, which are 'station' and 'trip'.", "It selects the average latitude and longitude from the 'station' table.", "A JOIN operation is performed between 'station' and 'trip' on the condition that the station ID matches the start station ID in the trip table, ensuring that only stations with recorded trips are considered."], "gold_sql": "SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id", "source_tables": ["trip", "station"], "description": "This virtual table calculates the average latitude and longitude of bike stations from the 'station' table where trips have started. The placeholders in the query allow for further filtering or modifications based on specific criteria.", "virtual_table": "SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id"}
{"sample_id": "train.154", "db_id": "bike_1", "question": "What zip codes have a station with a max temperature greater than or equal to 80 and when did it reach that temperature?", "rationale": ["The query identifies the relevant table, which is 'weather'.", "Select the columns to display, 'date' and 'zip_code'.", "Add a condition to filter the 'max_temperature_f' column for values greater than or equal to the specified threshold using a placeholder for numeric values."], "gold_sql": "SELECT date ,  zip_code FROM weather WHERE max_temperature_f  >=  80", "source_tables": ["weather"], "description": "This virtual table provides the dates and zip codes of weather reports where the maximum temperature reached a specified threshold. The placeholder in the WHERE clause represents the minimum temperature value to filter the results.", "virtual_table": "SELECT date ,  zip_code FROM weather WHERE max_temperature_f  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2402", "db_id": "candidate_poll", "question": "Please list support, consider, and oppose rates for each candidate in ascending order by unsure rate.", "rationale": ["The query identifies the relevant table, which is 'candidate'.", "Select the columns to display: 'Support_rate', 'Consider_rate', and 'Oppose_rate'.", "Order the results by the 'Unsure_rate' column to prioritize candidates based on the uncertainty of respondents."], "gold_sql": "SELECT Support_rate ,  Consider_rate ,  Oppose_rate FROM candidate ORDER BY unsure_rate", "source_tables": ["candidate"], "description": "This virtual table provides the support, consideration, and opposition rates of candidates from the 'candidate' table, ordered by the rate of respondents who are unsure about the candidates. The placeholders in the SELECT clause represent the respective rates of support, consideration, and opposition.", "virtual_table": "SELECT Support_rate ,  Consider_rate ,  Oppose_rate FROM candidate ORDER BY unsure_rate"}
{"sample_id": "train.2403", "db_id": "candidate_poll", "question": "What are the support, consider, and oppose rates of each candidate, ordered ascending by their unsure rate?", "rationale": ["The query identifies the relevant table, which is 'candidate'.", "Select the columns to display: 'Support_rate', 'Consider_rate', and 'Oppose_rate'.", "Add an ORDER BY clause to sort the results based on the 'Unsure_rate' column."], "gold_sql": "SELECT Support_rate ,  Consider_rate ,  Oppose_rate FROM candidate ORDER BY unsure_rate", "source_tables": ["candidate"], "description": "This virtual table provides the support, consideration, and opposition rates of candidates from the 'candidate' table, ordered by the rate of respondents who are unsure about the candidates. The placeholders in the SELECT clause represent the respective rates of support, consideration, and opposition.", "virtual_table": "SELECT Support_rate ,  Consider_rate ,  Oppose_rate FROM candidate ORDER BY unsure_rate"}
{"sample_id": "train.2396", "db_id": "candidate_poll", "question": "Which poll resource provided the most number of candidate information?", "rationale": ["The query identifies the relevant table, which is 'candidate'.", "It selects the 'poll_source' column to display the different sources of poll data.", "The GROUP BY clause is used to group the results by 'poll_source'.", "The ORDER BY clause sorts the grouped results by their count in descending order.", "The LIMIT clause uses a placeholder to allow the user to specify how many poll sources to return."], "gold_sql": "SELECT poll_source FROM candidate GROUP BY poll_source ORDER BY count(*) DESC LIMIT 1", "source_tables": ["candidate"], "description": "This virtual table provides a list of poll sources from the 'candidate' table, grouped by the source and ordered by the number of occurrences. The placeholder in the LIMIT clause allows the user to specify the maximum number of poll sources to retrieve.", "virtual_table": "SELECT poll_source FROM candidate GROUP BY poll_source ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
