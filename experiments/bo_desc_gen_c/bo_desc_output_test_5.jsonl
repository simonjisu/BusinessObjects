{"sample_id": "train.5898", "db_id": "cre_Theme_park", "question": "What is the average price range of five star hotels that allow pets?", "rationale": ["The query identifies the relevant table, which is 'Hotels'.", "It selects the average of the 'price_range' column to determine the average price of hotels.", "Conditions are added to filter the results based on the specified 'star_rating_code' and whether pets are allowed, using placeholders for string and numeric values."], "gold_sql": "SELECT avg(price_range) FROM HOTELS WHERE star_rating_code  =  '5' AND pets_allowed_yn  =  1", "source_tables": ["hotels"], "description": "This virtual table calculates the average price range of hotels from the 'Hotels' table that have a specific star rating and indicate whether pets are allowed. The placeholders in the WHERE clause represent the star rating code and the pets allowed status.", "virtual_table": "SELECT avg(price_range) FROM HOTELS WHERE star_rating_code  =  [PLACEHOLDER-TYPE:STRING] AND pets_allowed_yn  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5904", "db_id": "cre_Theme_park", "question": "Find all the locations whose names contain the word \"film\".", "rationale": ["The query identifies the relevant table, which is 'Locations'.", "Select the column to display, 'Location_Name'.", "Add a condition to filter the 'Location_Name' column using a LIKE operator with a placeholder for string values."], "gold_sql": "SELECT Location_Name FROM LOCATIONS WHERE Location_Name LIKE '%film%'", "source_tables": ["locations"], "description": "This virtual table provides a list of location names from the 'Locations' table that match a specific pattern. The placeholder in the WHERE clause allows for flexible searching of location names based on user input.", "virtual_table": "SELECT Location_Name FROM LOCATIONS WHERE Location_Name LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5915", "db_id": "cre_Theme_park", "question": "What are the details and opening hours of the museums?", "rationale": ["The query identifies the relevant tables, which are 'Museums' and 'Tourist_Attractions'.", "It selects the 'Museum_Details' from the 'Museums' table and 'Opening_Hours' from the 'Tourist_Attractions' table.", "A JOIN operation is performed on the 'Museum_ID' from the 'Museums' table and 'Tourist_Attraction_ID' from the 'Tourist_Attractions' table to link the two tables based on their relationship."], "gold_sql": "SELECT T1.Museum_Details ,  T2.Opening_Hours FROM MUSEUMS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Museum_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["tourist_attractions", "museums"], "description": "This virtual table provides details about museums and their opening hours by joining the 'Museums' table with the 'Tourist_Attractions' table. The placeholder in the SELECT statement allows for the retrieval of specific museum details and their corresponding opening hours.", "virtual_table": "SELECT T1.Museum_Details ,  T2.Opening_Hours FROM MUSEUMS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Museum_ID  =  T2.Tourist_Attraction_ID"}
{"sample_id": "train.5916", "db_id": "cre_Theme_park", "question": "Give me the detail and opening hour for each museum.", "rationale": ["The query identifies the relevant tables, which are 'Museums' and 'Tourist_Attractions'.", "It selects the 'Museum_Details' from the 'Museums' table and 'Opening_Hours' from the 'Tourist_Attractions' table.", "A JOIN operation is performed on the 'Museum_ID' from the 'Museums' table and 'Tourist_Attraction_ID' from the 'Tourist_Attractions' table to link the two tables based on their relationship."], "gold_sql": "SELECT T1.Museum_Details ,  T2.Opening_Hours FROM MUSEUMS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Museum_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["tourist_attractions", "museums"], "description": "This virtual table provides details about museums and their opening hours by joining the 'Museums' table with the 'Tourist_Attractions' table. The placeholder in the SELECT statement allows for the retrieval of specific museum details and their corresponding opening hours.", "virtual_table": "SELECT T1.Museum_Details ,  T2.Opening_Hours FROM MUSEUMS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Museum_ID  =  T2.Tourist_Attraction_ID"}
{"sample_id": "train.5922", "db_id": "cre_Theme_park", "question": "Which tourist attractions are related to royal family? Tell me their details and how we can get there.", "rationale": ["The query identifies the relevant tables, which are 'Royal_Family' and 'Tourist_Attractions'.", "It selects the 'Royal_Family_Details' from the 'Royal_Family' table and 'How_to_Get_There' from the 'Tourist_Attractions' table.", "A join operation is performed on the 'Royal_Family_ID' from the 'Royal_Family' table and 'Tourist_Attraction_ID' from the 'Tourist_Attractions' table to link the two tables based on their relationship."], "gold_sql": "SELECT T1.Royal_Family_Details ,  T2.How_to_Get_There FROM ROYAL_FAMILY AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Royal_Family_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["royal_family", "tourist_attractions"], "description": "This virtual table provides details about royal families and the instructions on how to reach the associated tourist attractions. The join operation links the 'Royal_Family' table with the 'Tourist_Attractions' table based on the unique identifier for royal family entries and the tourist attraction ID.", "virtual_table": "SELECT T1.Royal_Family_Details ,  T2.How_to_Get_There FROM ROYAL_FAMILY AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Royal_Family_ID  =  T2.Tourist_Attraction_ID"}
{"sample_id": "train.5923", "db_id": "cre_Theme_park", "question": "What are the details of the shops that can be accessed by walk?", "rationale": ["The query identifies the relevant tables, which are 'SHOPS' and 'TOURIST_ATTRACTIONS'.", "It selects the 'Shop_Details' column from the 'SHOPS' table.", "A JOIN operation is performed to link 'SHOPS' with 'TOURIST_ATTRACTIONS' based on the matching 'Shop_ID' and 'Tourist_Attraction_ID'.", "A condition is added to filter the results based on the 'How_to_Get_There' column from the 'TOURIST_ATTRACTIONS' table, using a placeholder for string values."], "gold_sql": "SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  'walk'", "source_tables": ["shops", "tourist_attractions"], "description": "This virtual table provides the details of shops that are associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.", "virtual_table": "SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5931", "db_id": "cre_Theme_park", "question": "Which tourist attractions does the visitor with detail 'Vincent' visit?", "rationale": ["The query identifies the relevant tables: 'Tourist_Attractions', 'Visits', and 'Visitors'.", "It selects the 'Name' column from the 'Tourist_Attractions' table.", "The query joins 'Tourist_Attractions' with 'Visits' on the 'Tourist_Attraction_ID' to connect attractions with their visits.", "It further joins 'Visits' with 'Visitors' on 'Tourist_ID' to link visits to specific tourists.", "A condition is added to filter the results based on the 'Tourist_Details' of the specified tourist using a placeholder for string values."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID JOIN VISITORS AS T3 ON T2.Tourist_ID  =  T3.Tourist_ID WHERE T3.Tourist_Details  =  'Vincent'", "source_tables": ["visits", "visitors", "tourist_attractions"], "description": "This virtual table lists the names of tourist attractions that have been visited by a specific tourist. The query joins the 'Tourist_Attractions' table with the 'Visits' table to link attractions to visits, and then further joins with the 'Visitors' table to filter by the details of a specific tourist. The placeholder in the WHERE clause represents the details of the tourist being queried.", "virtual_table": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID JOIN VISITORS AS T3 ON T2.Tourist_ID  =  T3.Tourist_ID WHERE T3.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5932", "db_id": "cre_Theme_park", "question": "Show the tourist attractions visited by the tourist whose detail is 'Vincent'.", "rationale": ["The query identifies the relevant tables: 'Tourist_Attractions', 'Visits', and 'Visitors'.", "It selects the 'Name' column from the 'Tourist_Attractions' table.", "It joins 'Tourist_Attractions' with 'Visits' on the 'Tourist_Attraction_ID' to link attractions to visits.", "It further joins 'Visits' with 'Visitors' on 'Tourist_ID' to associate visits with specific tourists.", "A condition is added to filter the results based on the specified tourist's details using a placeholder for string values."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID JOIN VISITORS AS T3 ON T2.Tourist_ID  =  T3.Tourist_ID WHERE T3.Tourist_Details  =  'Vincent'", "source_tables": ["visits", "visitors", "tourist_attractions"], "description": "This virtual table lists the names of tourist attractions that have been visited by a specific tourist. The query joins the 'Tourist_Attractions' table with the 'Visits' table to link attractions to visits, and then further joins with the 'Visitors' table to filter by the specific tourist's details. The placeholder in the WHERE clause represents the details of the tourist.", "virtual_table": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID JOIN VISITORS AS T3 ON T2.Tourist_ID  =  T3.Tourist_ID WHERE T3.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5941", "db_id": "cre_Theme_park", "question": "Show the details of the top 3 most expensive hotels.", "rationale": ["The query identifies the relevant table, which is 'Hotels'.", "Select the column to display, 'other_hotel_details'.", "Order the results by 'price_range' in descending order to show the most expensive hotels first.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT 3", "source_tables": ["hotels"], "description": "This virtual table provides a list of additional details about hotels from the 'Hotels' table, ordered by their price range in descending order. The placeholder in the LIMIT clause represents the maximum number of hotel details to retrieve.", "virtual_table": "SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5942", "db_id": "cre_Theme_park", "question": "What are the details of the three most expensive hotels?", "rationale": ["The query identifies the relevant table, which is 'Hotels'.", "Select the column to display, 'other_hotel_details'.", "Order the results by 'price_range' in descending order to show the most expensive hotels first.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT 3", "source_tables": ["hotels"], "description": "This virtual table provides a list of additional details about hotels from the 'Hotels' table, ordered by their price range in descending order. The placeholder in the LIMIT clause represents the maximum number of hotel details to retrieve.", "virtual_table": "SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5944", "db_id": "cre_Theme_park", "question": "What are the details and star ratings of the three hotels with the lowest price ranges?", "rationale": ["The query identifies the relevant table, which is 'Hotels'.", "Selects the columns to display, 'other_hotel_details' and 'star_rating_code'.", "Orders the results by 'price_range' in ascending order to show the cheapest hotels first.", "Limits the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT 3", "source_tables": ["hotels"], "description": "This virtual table provides a list of additional details about hotels along with their star rating codes, sorted by the price range in ascending order. The placeholder in the LIMIT clause represents the maximum number of hotel records to return.", "virtual_table": "SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5945", "db_id": "cre_Theme_park", "question": "Show the transportation method most people choose to get to tourist attractions.", "rationale": ["The query identifies the relevant table, which is 'Tourist_Attractions'.", "It selects the 'How_to_Get_There' column to display the instructions for reaching attractions.", "The results are grouped by 'How_to_Get_There' to consolidate similar instructions.", "The results are ordered by the count of occurrences of each instruction in descending order to highlight the most common ones.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["tourist_attractions"], "description": "This virtual table provides a list of instructions on how to reach various tourist attractions, grouped by the unique directions provided. The results are ordered by the frequency of each instruction, allowing users to see the most common ways to get to attractions. The placeholder in the LIMIT clause represents the maximum number of instructions to retrieve.", "virtual_table": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5946", "db_id": "cre_Theme_park", "question": "Which transportation method is used the most often to get to tourist attractions?", "rationale": ["The query identifies the relevant table, which is 'Tourist_Attractions'.", "Select the column 'How_to_Get_There' to display the instructions for reaching attractions.", "Group the results by 'How_to_Get_There' to consolidate similar instructions.", "Order the results by the count of occurrences of each instruction in descending order to prioritize the most common ones.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["tourist_attractions"], "description": "This virtual table provides a list of instructions on how to reach various tourist attractions, grouped by the unique directions provided. The results are ordered by the frequency of each instruction, allowing users to see the most common ways to get to attractions. The placeholder in the LIMIT clause represents the maximum number of instructions to retrieve.", "virtual_table": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5955", "db_id": "cre_Theme_park", "question": "Show the names and ids of tourist attractions that are visited at most once.", "rationale": ["The query identifies the relevant tables, 'Tourist_Attractions' and 'Visits'.", "It selects the 'Name' and 'Tourist_Attraction_ID' from the 'Tourist_Attractions' table.", "A JOIN operation is performed between 'Tourist_Attractions' and 'Visits' on the 'Tourist_Attraction_ID' to link attractions with their visit records.", "The results are grouped by 'Tourist_Attraction_ID' to aggregate visit counts.", "The HAVING clause filters the results to include only those attractions with visit counts less than or equal to the specified numeric placeholder."], "gold_sql": "SELECT T1.Name ,  T1.Tourist_Attraction_ID FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID HAVING count(*)  <=  1", "source_tables": ["visits", "tourist_attractions"], "description": "This virtual table provides the names and unique identifiers of tourist attractions that have been visited a limited number of times, as specified by a placeholder for numeric values. The data is sourced from the 'Tourist_Attractions' table, and it is filtered based on the number of visits recorded in the 'Visits' table, ensuring that only attractions with visit counts below or equal to the specified threshold are included.", "virtual_table": "SELECT T1.Name ,  T1.Tourist_Attraction_ID FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID HAVING count(*)  <=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5956", "db_id": "cre_Theme_park", "question": "What are the names and ids of the tourist attractions that are visited at most once?", "rationale": ["The query identifies the relevant tables, 'Tourist_Attractions' and 'Visits'.", "It selects the 'Name' and 'Tourist_Attraction_ID' from the 'Tourist_Attractions' table.", "A JOIN operation is performed between 'Tourist_Attractions' and 'Visits' on the 'Tourist_Attraction_ID' to link attractions with their visit records.", "The results are grouped by 'Tourist_Attraction_ID' to aggregate visit counts.", "A HAVING clause is used to filter the results based on the count of visits, using a placeholder for numeric values."], "gold_sql": "SELECT T1.Name ,  T1.Tourist_Attraction_ID FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID HAVING count(*)  <=  1", "source_tables": ["visits", "tourist_attractions"], "description": "This virtual table provides the names and unique identifiers of tourist attractions that have been visited a limited number of times, as specified by a placeholder for numeric values. The data is sourced from the 'Tourist_Attractions' table, and it is filtered based on the count of visits recorded in the 'Visits' table, ensuring that only attractions with visit counts less than or equal to the specified number are included.", "virtual_table": "SELECT T1.Name ,  T1.Tourist_Attraction_ID FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID HAVING count(*)  <=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5959", "db_id": "cre_Theme_park", "question": "What are the names of the tourist attractions that have parking or shopping as their feature details?", "rationale": ["The query identifies the relevant tables: 'Tourist_Attractions', 'Tourist_Attraction_Features', and 'Features'.", "It selects the 'Name' column from the 'Tourist_Attractions' table.", "The JOIN operations link the tables based on their foreign key relationships, ensuring that only attractions with the specified features are included.", "The WHERE clause filters the results based on the feature details, using placeholders for the specific feature descriptions. The UNION operator allows for combining results from two similar queries, each filtering by a different feature detail."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'park' UNION SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'shopping'", "source_tables": ["features", "tourist_attractions", "tourist_attraction_features"], "description": "This virtual table lists the names of tourist attractions that feature specific characteristics. The query combines results from the 'Tourist_Attractions', 'Tourist_Attraction_Features', and 'Features' tables, filtering based on the details of the features. The placeholders in the WHERE clause represent the specific feature details being queried.", "virtual_table": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5960", "db_id": "cre_Theme_park", "question": "Find the tourist attractions that have parking or shopping as their feature details. What are the names of the attractions?", "rationale": ["The query identifies the relevant tables: 'Tourist_Attractions', 'Tourist_Attraction_Features', and 'Features'.", "It selects the 'Name' column from the 'Tourist_Attractions' table.", "The query uses JOIN operations to connect the tables based on their foreign key relationships.", "It applies a condition to filter attractions based on specific feature details using placeholders for string values.", "The UNION operator is used to combine results from two similar queries, allowing for multiple feature criteria."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'park' UNION SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'shopping'", "source_tables": ["features", "tourist_attractions", "tourist_attraction_features"], "description": "This virtual table lists the names of tourist attractions that feature specific characteristics. The query retrieves attraction names from the 'Tourist_Attractions' table by joining it with the 'Tourist_Attraction_Features' and 'Features' tables. The placeholders in the WHERE clause represent the details of the features that the attractions must have, allowing users to specify different feature criteria.", "virtual_table": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5963", "db_id": "cre_Theme_park", "question": "What are the names of the tourist attractions Vincent and Marcelle visit?", "rationale": ["The query identifies the relevant tables: 'Tourist_Attractions', 'Visitors', and 'Visits'.", "It selects the 'Name' of the tourist attractions from the 'Tourist_Attractions' table.", "The JOIN operations link the 'Tourist_Attraction_ID' and 'Tourist_ID' across the 'Tourist_Attractions', 'Visitors', and 'Visits' tables to find the attractions visited by the tourists.", "The WHERE clause filters the results based on the details of the tourists using placeholders for string values.", "The INTERSECT operator is used to find common attractions visited by both tourists based on their details."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  'Vincent' INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  'Marcelle'", "source_tables": ["visits", "visitors", "tourist_attractions"], "description": "This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.", "virtual_table": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5985", "db_id": "game_1", "question": "Which game type has most number of games?", "rationale": ["The query identifies the relevant table, which is 'Video_Games'.", "It selects the 'GType' column to display the types of video games.", "The results are grouped by 'GType' to aggregate the data based on the genre.", "The results are ordered by the count of games in each genre in descending order.", "A limit is applied to restrict the number of genres displayed, using a placeholder for numeric values."], "gold_sql": "SELECT gtype FROM Video_games GROUP BY gtype ORDER BY count(*) DESC LIMIT 1", "source_tables": ["video_games"], "description": "This virtual table summarizes the types of video games from the 'Video_Games' table, grouping them by genre and ordering the results by the number of games in each genre. The placeholder in the LIMIT clause represents the maximum number of genres to display.", "virtual_table": "SELECT gtype FROM Video_games GROUP BY gtype ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5988", "db_id": "game_1", "question": "What is the type with the fewest games?", "rationale": ["The query identifies the relevant table, which is 'Video_Games'.", "It selects the 'GType' column to display the genre of the video games.", "The query groups the results by 'GType' to aggregate the data based on the genre.", "It orders the results by the count of each genre to prioritize the most common ones.", "The LIMIT clause uses a placeholder to specify the maximum number of genres to return."], "gold_sql": "SELECT gtype FROM Video_games GROUP BY gtype ORDER BY count(*) LIMIT 1", "source_tables": ["video_games"], "description": "This virtual table summarizes the types of video games from the 'Video_Games' table, grouping them by their genre. The placeholder in the LIMIT clause represents the maximum number of genres to be displayed.", "virtual_table": "SELECT gtype FROM Video_games GROUP BY gtype ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6001", "db_id": "game_1", "question": "How many students play sports?", "rationale": ["The query identifies the relevant table, which is 'SportsInfo'.", "It uses the COUNT function to count the number of distinct 'StuID' entries.", "The DISTINCT keyword ensures that only unique student identifiers are counted, providing the total number of unique students involved in sports."], "gold_sql": "SELECT count(DISTINCT StuID) FROM Sportsinfo", "source_tables": ["sportsinfo"], "description": "This virtual table provides the count of distinct students from the 'SportsInfo' table, indicating how many unique students are participating in sports activities. The query uses the COUNT function to aggregate the unique student identifiers.", "virtual_table": "SELECT count(DISTINCT StuID) FROM Sportsinfo"}
{"sample_id": "train.6003", "db_id": "game_1", "question": "List ids for all student who are on scholarship.", "rationale": ["The query identifies the relevant table, which is 'SportsInfo'.", "Select the column to display, 'StuID', which is the unique identifier for each student.", "Add a condition to filter the 'OnScholarship' column for the specified scholarship status using a placeholder for string values."], "gold_sql": "SELECT StuID FROM Sportsinfo WHERE onscholarship  =  'Y'", "source_tables": ["sportsinfo"], "description": "This virtual table lists the unique identifiers of students from the 'SportsInfo' table who are on a sports scholarship. The placeholder in the WHERE clause represents the scholarship status, which can be either 'Yes' or 'No'.", "virtual_table": "SELECT StuID FROM Sportsinfo WHERE onscholarship  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6004", "db_id": "game_1", "question": "What are the ids for all sporty students who are on scholarship?", "rationale": ["The query identifies the relevant table, which is 'SportsInfo'.", "Select the column to display, 'StuID', which is the unique identifier for each student.", "Add a condition to filter the 'OnScholarship' column for the specified scholarship status using a placeholder for string values."], "gold_sql": "SELECT StuID FROM Sportsinfo WHERE onscholarship  =  'Y'", "source_tables": ["sportsinfo"], "description": "This virtual table lists the unique identifiers of students from the 'SportsInfo' table who are on a sports scholarship. The placeholder in the WHERE clause represents the scholarship status, which can be either 'Yes' or 'No'.", "virtual_table": "SELECT StuID FROM Sportsinfo WHERE onscholarship  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6006", "db_id": "game_1", "question": "What are the last names for all scholarship students?", "rationale": ["The query identifies the relevant tables, which are 'SportsInfo' and 'Student'.", "It uses a JOIN operation to combine records from both tables based on the common 'StuID' field.", "The SELECT statement specifies that only the 'LName' column from the 'Student' table should be displayed.", "A condition is added to filter the results based on the 'OnScholarship' column from the 'SportsInfo' table using a placeholder for string values."], "gold_sql": "SELECT T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T1.onscholarship  =  'Y'", "source_tables": ["sportsinfo", "student"], "description": "This virtual table describes the last names of students from the 'Student' table who are participating in sports and are on a sports scholarship. The placeholder in the WHERE clause represents the scholarship status.", "virtual_table": "SELECT T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T1.onscholarship  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6010", "db_id": "game_1", "question": "What is the total number of all football games played by scholarship students?", "rationale": ["The query identifies the relevant table, which is 'SportsInfo'.", "It selects the sum of the 'GamesPlayed' column to get the total number of games played.", "Conditions are added to filter the results based on the specified 'SportName' and whether the student is 'OnScholarship', using placeholders for string values."], "gold_sql": "SELECT sum(gamesplayed) FROM Sportsinfo WHERE sportname  =  'Football' AND onscholarship  =  'Y'", "source_tables": ["sportsinfo"], "description": "This virtual table summarizes the total number of games played by students involved in a specific sport who are also on a sports scholarship. The placeholders in the WHERE clause represent the sport's name and the scholarship status.", "virtual_table": "SELECT sum(gamesplayed) FROM Sportsinfo WHERE sportname  =  [PLACEHOLDER-TYPE:STRING] AND onscholarship  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6014", "db_id": "game_1", "question": "What are the ids of all students along with how many sports and games did they play?", "rationale": ["The query identifies the relevant table, which is 'SportsInfo'.", "It selects the 'StuID' to group the results by each student.", "The count function is used to count the number of entries for each student, and the sum function calculates the total number of games played by each student.", "The GROUP BY clause is applied to aggregate the results based on 'StuID' to ensure each student's data is summarized correctly."], "gold_sql": "SELECT StuID ,  count(*) ,  sum(gamesplayed) FROM Sportsinfo GROUP BY StuID", "source_tables": ["sportsinfo"], "description": "This virtual table summarizes the total number of games played by each student from the 'SportsInfo' table. The placeholder in the SELECT clause represents the unique student identifier, while the count and sum functions aggregate the data accordingly.", "virtual_table": "SELECT StuID ,  count(*) ,  sum(gamesplayed) FROM Sportsinfo GROUP BY StuID"}
{"sample_id": "train.6019", "db_id": "game_1", "question": "Which sport has most number of students on scholarship?", "rationale": ["The query identifies the relevant table, which is 'SportsInfo'.", "Select the column to display, 'SportName'.", "Add a condition to filter the 'OnScholarship' column for the specified scholarship status using a placeholder for string values.", "Group the results by 'SportName' to aggregate the data.", "Order the results by the count of students participating in each sport in descending order.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT sportname FROM Sportsinfo WHERE onscholarship  =  'Y' GROUP BY sportname ORDER BY count(*) DESC LIMIT 1", "source_tables": ["sportsinfo"], "description": "This virtual table describes the names of sports in which students are involved, filtered by their scholarship status. The results are grouped by sport name and ordered by the number of students participating in each sport, with a limit on the number of results returned. The placeholders represent the scholarship status and the maximum number of results to display.", "virtual_table": "SELECT sportname FROM Sportsinfo WHERE onscholarship  =  [PLACEHOLDER-TYPE:STRING] GROUP BY sportname ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6020", "db_id": "game_1", "question": "What is the sport with the most scholarship students?", "rationale": ["The query identifies the relevant table, which is 'SportsInfo'.", "Select the column to display, 'SportName'.", "Add a condition to filter the 'OnScholarship' column for the specified scholarship status using a placeholder for string values.", "Group the results by 'SportName' to aggregate the data.", "Order the results by the count of students in each sport in descending order.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT sportname FROM Sportsinfo WHERE onscholarship  =  'Y' GROUP BY sportname ORDER BY count(*) DESC LIMIT 1", "source_tables": ["sportsinfo"], "description": "This virtual table provides a list of sports names from the 'SportsInfo' table for students who are either on or not on a sports scholarship, depending on the specified condition. The results are grouped by sport name and ordered by the number of students participating in each sport, with a limit on the number of results returned.", "virtual_table": "SELECT sportname FROM Sportsinfo WHERE onscholarship  =  [PLACEHOLDER-TYPE:STRING] GROUP BY sportname ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6024", "db_id": "game_1", "question": "What are the student ids for those on scholarship in major number 600?", "rationale": ["The query is identifying the relevant table, which is 'Student' and 'SportsInfo'.", "Select the column 'StuID' to display the unique identifier for students.", "Add a condition to filter the 'major' column for the specified major using a placeholder for numeric values.", "Use the INTERSECT operator to find students who are also in the 'SportsInfo' table with a condition on the 'OnScholarship' column using a placeholder for string values."], "gold_sql": "SELECT StuID FROM Student WHERE major  =  600 INTERSECT SELECT StuID FROM Sportsinfo WHERE onscholarship  =  'Y'", "source_tables": ["sportsinfo", "student"], "description": "This virtual table identifies students who are majoring in a specific field of study and are also participating in sports on a scholarship. The placeholders in the query represent the major and the scholarship status.", "virtual_table": "SELECT StuID FROM Student WHERE major  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT StuID FROM Sportsinfo WHERE onscholarship  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6025", "db_id": "game_1", "question": "Show student ids who are female and play football.", "rationale": ["The query is identifying the relevant table, which is 'Student' and 'SportsInfo'.", "Select the column 'StuID' to display the unique identifier of the students.", "Add a condition to filter the 'sex' column for the specified gender using a placeholder for string values.", "Use the INTERSECT operator to find students who are both of the specified gender and participate in the specified sport, filtering the 'SportName' column in the 'SportsInfo' table with another placeholder for string values."], "gold_sql": "SELECT StuID FROM Student WHERE sex  =  'F' INTERSECT SELECT StuID FROM Sportsinfo WHERE sportname  =  'Football'", "source_tables": ["sportsinfo", "student"], "description": "This virtual table identifies students who are of a specific gender and also participate in a particular sport. The placeholders in the WHERE clauses represent the gender and the sport's name.", "virtual_table": "SELECT StuID FROM Student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT StuID FROM Sportsinfo WHERE sportname  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6026", "db_id": "game_1", "question": "What are the ids of all female students who play football?", "rationale": ["The query is identifying the relevant table, which is 'Student' and 'SportsInfo'.", "Select the column 'StuID' to display the unique identifier of the students.", "Add a condition to filter the 'sex' column for the specified gender using a placeholder for string values.", "Use the INTERSECT operator to find students who are also listed in the 'SportsInfo' table for a specific sport, using a placeholder for the sport's name."], "gold_sql": "SELECT StuID FROM Student WHERE sex  =  'F' INTERSECT SELECT StuID FROM Sportsinfo WHERE sportname  =  'Football'", "source_tables": ["sportsinfo", "student"], "description": "This virtual table identifies students who are of a specific gender and also participate in a particular sport. The placeholders in the WHERE clauses represent the gender and the sport's name.", "virtual_table": "SELECT StuID FROM Student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT StuID FROM Sportsinfo WHERE sportname  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6028", "db_id": "game_1", "question": "What are the ids of all male students who do not play football?", "rationale": ["The query starts by selecting the 'StuID' from the 'Student' table.", "It applies a filter to include only those students whose 'Sex' matches the specified placeholder for gender.", "The EXCEPT clause is used to exclude students who are involved in a specific sport, identified by the 'SportName' placeholder from the 'SportsInfo' table."], "gold_sql": "SELECT StuID FROM Student WHERE sex  =  'M' EXCEPT SELECT StuID FROM Sportsinfo WHERE sportname  =  'Football'", "source_tables": ["sportsinfo", "student"], "description": "This virtual table identifies students from the 'Student' table who are of a specific gender and are not participating in a specified sport. The placeholders in the WHERE clause represent the gender and the sport's name.", "virtual_table": "SELECT StuID FROM Student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT StuID FROM Sportsinfo WHERE sportname  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6060", "db_id": "customers_and_addresses", "question": "Find the average order quantity per order.", "rationale": ["The query identifies the relevant table, which is 'Order_Items'.", "It selects the average of the 'order_quantity' column to determine the typical quantity of products ordered."], "gold_sql": "SELECT avg(order_quantity) FROM order_items", "source_tables": ["order_items"], "description": "This virtual table calculates the average quantity of products ordered from the 'Order_Items' table. The result provides insights into the typical order size for products.", "virtual_table": "SELECT avg(order_quantity) FROM order_items"}
{"sample_id": "train.6071", "db_id": "customers_and_addresses", "question": "What are the details of all products?", "rationale": ["The query is identifying the relevant table, which is 'Products'.", "Select the column to display, 'product_details'.", "Use DISTINCT to ensure that only unique product specifications are returned."], "gold_sql": "SELECT DISTINCT product_details FROM products", "source_tables": ["products"], "description": "The virtual table provides a unique list of product specifications from the 'Products' table. The placeholder in the SELECT statement allows for potential filtering or additional conditions to be added later.", "virtual_table": "SELECT DISTINCT product_details FROM products"}
{"sample_id": "train.6075", "db_id": "customers_and_addresses", "question": "Find the detail of products whose detail contains the word \"Latte\" or the word \"Americano\"", "rationale": ["The query identifies the relevant table, which is 'Products'.", "Select the column to display, 'product_details'.", "Add a condition to filter the 'product_details' column for specified patterns using placeholders for string values."], "gold_sql": "SELECT product_details FROM products WHERE product_details LIKE '%Latte%' OR product_details LIKE '%Americano%'", "source_tables": ["products"], "description": "This virtual table retrieves the product details from the 'Products' table that match specific criteria. The placeholders in the WHERE clause represent the patterns to search for in the product details.", "virtual_table": "SELECT product_details FROM products WHERE product_details LIKE [PLACEHOLDER-TYPE:STRING] OR product_details LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6085", "db_id": "customers_and_addresses", "question": "Which city has the most customers living in?", "rationale": ["The query identifies the relevant tables: 'Customers', 'Customer_Addresses', and 'Addresses'.", "It selects the 'city' column from the 'Addresses' table.", "The query joins the 'Customers' table with 'Customer_Addresses' on 'customer_id' and then joins 'Customer_Addresses' with 'Addresses' on 'address_id'.", "The results are grouped by 'city' to aggregate the number of customers in each city.", "The results are ordered by the count of customers in descending order, and a limit is applied to restrict the number of cities returned using a placeholder for numeric values."], "gold_sql": "SELECT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id GROUP BY t3.city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "customers", "customer_addresses"], "description": "This virtual table provides a list of cities where customers are located, derived from the 'Customers', 'Customer_Addresses', and 'Addresses' tables. The results are grouped by city and ordered by the number of customers in each city, with a limit on the number of cities returned based on a specified numeric value.", "virtual_table": "SELECT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id GROUP BY t3.city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6086", "db_id": "customers_and_addresses", "question": "Find the city where the most customers live.", "rationale": ["The query identifies the relevant tables: 'Customers', 'Customer_Addresses', and 'Addresses'.", "It selects the 'city' column from the 'Addresses' table.", "The JOIN operations link customers to their addresses through the 'Customer_Addresses' table.", "The results are grouped by 'city' to aggregate customer counts.", "The results are ordered by the count of customers in each city in descending order.", "A limit is applied to restrict the number of cities returned based on a placeholder for numeric values."], "gold_sql": "SELECT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id GROUP BY t3.city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "customers", "customer_addresses"], "description": "This virtual table provides a list of cities where customers are located, derived from the 'Customers', 'Customer_Addresses', and 'Addresses' tables. The results are grouped by city and ordered by the number of customers in each city, with a limit on the number of cities returned based on a specified numeric value.", "virtual_table": "SELECT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id GROUP BY t3.city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6097", "db_id": "customers_and_addresses", "question": "Which contact channel has been used by the customer with name \"Tillman Ernser\"?", "rationale": ["The query identifies the relevant tables, which are 'Customers' and 'Customer_Contact_Channels'.", "It selects distinct values from the 'channel_code' column to avoid duplicates.", "The JOIN operation links the two tables using the 'customer_id' to ensure that the contact channels correspond to the correct customer.", "A condition is added to filter the results based on the specified customer's name using a placeholder for string values."], "gold_sql": "SELECT DISTINCT channel_code FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  'Tillman Ernser'", "source_tables": ["customer_contact_channels", "customers"], "description": "This virtual table provides a distinct list of contact channels used by customers from the 'Customers' table based on their name. The placeholder in the WHERE clause represents the specific customer's name.", "virtual_table": "SELECT DISTINCT channel_code FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6100", "db_id": "customers_and_addresses", "question": "Return the the \"active to date\" of the latest contact channel used by the customer named \"Tillman Ernser\".", "rationale": ["The query identifies the relevant tables, which are 'Customers' and 'Customer_Contact_Channels'.", "It selects the maximum value of 'active_to_date' from 'Customer_Contact_Channels' to find the most recent deactivation date.", "A JOIN operation is performed on 'customer_id' to link the two tables based on the customer.", "A condition is added to filter the results based on the specified customer's name using a placeholder for string values."], "gold_sql": "SELECT max(t2.active_to_date) FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  'Tillman Ernser'", "source_tables": ["customer_contact_channels", "customers"], "description": "This virtual table retrieves the most recent deactivation date of a contact channel for a specific customer from the 'Customers' and 'Customer_Contact_Channels' tables. The placeholder in the WHERE clause represents the customer's name.", "virtual_table": "SELECT max(t2.active_to_date) FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6101", "db_id": "customers_and_addresses", "question": "What is the average time span of contact channels in the database?", "rationale": ["The query identifies the relevant table, which is 'Customer_Contact_Channels'.", "It calculates the average duration by subtracting 'active_from_date' from 'active_to_date'.", "The result is aggregated using the AVG function to provide the average duration of active contact channels."], "gold_sql": "SELECT avg(active_to_date - active_from_date) FROM customer_contact_channels", "source_tables": ["customer_contact_channels"], "description": "This virtual table calculates the average duration that contact channels remain active for customers in the 'Customer_Contact_Channels' table. The placeholder in the SELECT clause represents the calculation of the difference between the active dates.", "virtual_table": "SELECT avg(active_to_date - active_from_date) FROM customer_contact_channels"}
{"sample_id": "train.6103", "db_id": "customers_and_addresses", "question": "What is the channel code and contact number of the customer contact channel that was active for the longest time?", "rationale": ["The query identifies the relevant table, which is 'Customer_Contact_Channels'.", "It selects the columns 'channel_code' and 'contact_number' to display.", "The condition filters the records based on the difference between 'active_to_date' and 'active_from_date', ensuring we only get the most recently active contact channel.", "The subquery retrieves the maximum duration of activity, and the placeholder allows the user to specify how many records to limit the results to."], "gold_sql": "SELECT channel_code ,  contact_number FROM customer_contact_channels WHERE active_to_date - active_from_date  =  (SELECT active_to_date - active_from_date FROM customer_contact_channels ORDER BY (active_to_date - active_from_date) DESC LIMIT 1)", "source_tables": ["customer_contact_channels"], "description": "This virtual table provides the channel codes and associated contact numbers from the 'Customer_Contact_Channels' table for the most recently active contact channel based on the duration of activity. The placeholder in the LIMIT clause allows for specifying the number of records to retrieve based on the longest active duration.", "virtual_table": "SELECT channel_code ,  contact_number FROM customer_contact_channels WHERE active_to_date - active_from_date  =  (SELECT active_to_date - active_from_date FROM customer_contact_channels ORDER BY (active_to_date - active_from_date) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.6108", "db_id": "customers_and_addresses", "question": "Find the name of the customer who made the order of the largest amount of goods.", "rationale": ["The query identifies the relevant tables: 'Customers', 'Customer_Orders', and 'Order_Items'.", "It selects the 'customer_name' from the 'Customers' table.", "The JOIN operations link customers to their orders and the items in those orders.", "The WHERE clause filters the results to only include customers whose order quantity matches the maximum order quantity found in the 'Order_Items' table."], "gold_sql": "SELECT t1.customer_name FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id JOIN order_items AS t3 ON t2.order_id  =  t3.order_id WHERE t3.order_quantity  =  ( SELECT max(order_quantity) FROM order_items)", "source_tables": ["customer_orders", "customers", "order_items"], "description": "This virtual table provides the names of customers who have placed orders containing the maximum quantity of any product. It joins the 'Customers' table with the 'Customer_Orders' table to link customers to their orders, and then further joins with the 'Order_Items' table to access the order quantities. The placeholder in the WHERE clause is used to filter for the maximum order quantity across all orders.", "virtual_table": "SELECT t1.customer_name FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id JOIN order_items AS t3 ON t2.order_id  =  t3.order_id WHERE t3.order_quantity  =  ( SELECT max(order_quantity) FROM order_items)"}
{"sample_id": "train.6123", "db_id": "customers_and_addresses", "question": "What is the total number of products that are in orders with status \"Cancelled\"?", "rationale": ["The query identifies the relevant tables, which are 'Customer_Orders' and 'Order_Items'.", "It uses a JOIN operation to link 'Customer_Orders' with 'Order_Items' based on the 'order_id'.", "The SUM function is applied to the 'order_quantity' column from 'Order_Items' to calculate the total quantity ordered.", "A condition is added to filter the results based on the 'order_status' column from 'Customer_Orders', using a placeholder for string values."], "gold_sql": "SELECT sum(t2.order_quantity) FROM customer_orders AS t1 JOIN order_items AS t2 ON t1.order_id  =  t2.order_id WHERE t1.order_status  =  'Cancelled'", "source_tables": ["customer_orders", "order_items"], "description": "This virtual table calculates the total quantity of products ordered from the 'Customer_Orders' table, filtered by a specific order status. The placeholder in the WHERE clause represents the order status to be specified by the user.", "virtual_table": "SELECT sum(t2.order_quantity) FROM customer_orders AS t1 JOIN order_items AS t2 ON t1.order_id  =  t2.order_id WHERE t1.order_status  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6130", "db_id": "customers_and_addresses", "question": "What is the most frequently ordered product? Tell me the detail of the product", "rationale": ["The query identifies the relevant tables, 'Order_Items' and 'Products'.", "It selects the 'product_details' from the 'Products' table.", "The JOIN operation links 'Order_Items' to 'Products' using the 'product_id'.", "The results are grouped by 'product_id' to aggregate the data.", "The ORDER BY clause sorts the results based on the count of orders in descending order.", "The LIMIT clause uses a placeholder to specify how many product details to return."], "gold_sql": "SELECT t2.product_details FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["products", "order_items"], "description": "This virtual table provides a list of product details from the 'Products' table based on the quantity of each product ordered. The query joins the 'Order_Items' table with the 'Products' table to aggregate the product details, grouping by product ID and ordering the results by the count of orders in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of product details to return.", "virtual_table": "SELECT t2.product_details FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6131", "db_id": "customers_and_addresses", "question": "Find the name and ID of the product whose total order quantity is the largest.", "rationale": ["The query identifies the relevant tables, 'Order_Items' and 'Products'.", "It selects the 'product_details' and 'product_id' from the 'Products' table.", "A JOIN operation is performed between 'Order_Items' and 'Products' on the 'product_id' to link the ordered items with their details.", "The results are grouped by 'product_id' to aggregate the order quantities for each product.", "The results are ordered by the sum of 'order_quantity' to show the most ordered products first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT t2.product_details ,  t2.product_id FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY sum(t1.order_quantity) LIMIT 1", "source_tables": ["products", "order_items"], "description": "This virtual table provides a summary of product details and their identifiers from the 'Products' table, based on the quantities ordered from the 'Order_Items' table. The results are grouped by product ID and ordered by the total quantity ordered, with a limit specified by a placeholder for numeric values.", "virtual_table": "SELECT t2.product_details ,  t2.product_id FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY sum(t1.order_quantity) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6132", "db_id": "customers_and_addresses", "question": "What are the name and ID of the product bought the most.", "rationale": ["The query identifies the relevant tables, 'Order_Items' and 'Products'.", "It selects the 'product_details' and 'product_id' from the 'Products' table.", "A JOIN operation is performed between 'Order_Items' and 'Products' on the 'product_id' to link the ordered items with their details.", "The results are grouped by 'product_id' to aggregate the order quantities for each product.", "The results are ordered by the sum of 'order_quantity' to show the most ordered products first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT t2.product_details ,  t2.product_id FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY sum(t1.order_quantity) LIMIT 1", "source_tables": ["products", "order_items"], "description": "This virtual table provides a summary of product details and their identifiers from the 'Products' table, based on the quantities ordered from the 'Order_Items' table. The results are grouped by product ID and ordered by the total quantity ordered, with a limit specified by a placeholder for numeric values.", "virtual_table": "SELECT t2.product_details ,  t2.product_id FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY sum(t1.order_quantity) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6133", "db_id": "customers_and_addresses", "question": "Find all the addresses in East Julianaside, Texas or in Gleasonmouth, Arizona.", "rationale": ["The query identifies the relevant table, which is 'Addresses'.", "It selects the 'address_content' column to display the detailed description of the addresses.", "The query includes two conditions to filter the results based on the specified city and state, using placeholders for string values.", "The UNION operator is used to combine results from two identical queries, allowing for flexibility in retrieving addresses from different entries that match the criteria."], "gold_sql": "SELECT address_content FROM addresses WHERE city  =  'East Julianaside' AND state_province_county  =  'Texas' UNION SELECT address_content FROM addresses WHERE city  =  'Gleasonmouth' AND state_province_county  =  'Arizona'", "source_tables": ["addresses"], "description": "This virtual table retrieves the detailed address content from the 'Addresses' table for specific cities and states, allowing for the combination of results from two different queries based on the same criteria. The placeholders in the WHERE clauses represent the city and state names.", "virtual_table": "SELECT address_content FROM addresses WHERE city  =  [PLACEHOLDER-TYPE:STRING] AND state_province_county  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT address_content FROM addresses WHERE city  =  [PLACEHOLDER-TYPE:STRING] AND state_province_county  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6155", "db_id": "music_4", "question": "What are the category of music festivals with result \"Awarded\"?", "rationale": ["The query identifies the relevant table, which is 'music_festival'.", "Select the column to display, 'Category'.", "Add a condition to filter the 'RESULT' column for the specified result using a placeholder for string values."], "gold_sql": "SELECT Category FROM music_festival WHERE RESULT  =  'Awarded'", "source_tables": ["music_festival"], "description": "This virtual table provides the categories of awards or recognitions from the 'music_festival' table based on a specific result. The placeholder in the WHERE clause represents the outcome of the festival participation.", "virtual_table": "SELECT Category FROM music_festival WHERE RESULT  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6167", "db_id": "music_4", "question": "Please show the songs that have result \"nominated\" at music festivals.", "rationale": ["The query identifies the relevant tables, which are 'music_festival' and 'volume'.", "It selects the 'Song' column from the 'volume' table, which is linked to the music festival results.", "A JOIN operation is performed between 'music_festival' and 'volume' on the 'Volume' and 'Volume_ID' columns to connect the data.", "A condition is added to filter the results based on the 'Result' column from the 'music_festival' table using a placeholder for string values."], "gold_sql": "SELECT T2.Song FROM music_festival AS T1 JOIN volume AS T2 ON T1.Volume  =  T2.Volume_ID WHERE T1.Result  =  'Nominated'", "source_tables": ["music_festival", "volume"], "description": "This virtual table describes the songs associated with music festivals where the outcome was a specific result. The query joins the 'music_festival' and 'volume' tables based on the volume identifier, and filters the results based on the specified outcome using a placeholder for string values.", "virtual_table": "SELECT T2.Song FROM music_festival AS T1 JOIN volume AS T2 ON T1.Volume  =  T2.Volume_ID WHERE T1.Result  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6180", "db_id": "music_4", "question": "Return the famous release date for the oldest artist.", "rationale": ["The query identifies the relevant table, which is 'artist'.", "Select the column to display, 'Famous_Release_date'.", "Order the results by the 'Age' column in descending order to show the oldest artists first.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT Famous_Release_date FROM artist ORDER BY Age DESC LIMIT 1", "source_tables": ["artist"], "description": "This virtual table provides the release dates of the most recognized songs by artists from the 'artist' table, ordered by the age of the artists in descending order. The placeholder in the LIMIT clause represents the maximum number of results to return.", "virtual_table": "SELECT Famous_Release_date FROM artist ORDER BY Age DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6185", "db_id": "music_4", "question": "Please show the categories of the music festivals with count more than 1.", "rationale": ["The query identifies the relevant table, which is 'music_festival'.", "It selects the 'Category' column to display the different categories of awards.", "The GROUP BY clause is used to group the results by 'Category'.", "The HAVING clause filters the grouped results to include only those categories that have a count greater than a specified number, using a placeholder for numeric values."], "gold_sql": "SELECT Category FROM music_festival GROUP BY Category HAVING COUNT(*)  >  1", "source_tables": ["music_festival"], "description": "This virtual table summarizes the categories of awards or recognitions from the 'music_festival' table that have received more than a specified number of entries. The placeholder in the HAVING clause represents the minimum count of entries required to filter the categories.", "virtual_table": "SELECT Category FROM music_festival GROUP BY Category HAVING COUNT(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6187", "db_id": "music_4", "question": "What is the song in the volume with the maximum weeks on top?", "rationale": ["The query identifies the relevant table, which is 'volume'.", "Select the 'Song' column to display the song identifiers.", "Order the results by 'Weeks_on_Top' in descending order to show the most successful songs first.", "Add a limit to the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT Song FROM volume ORDER BY Weeks_on_Top DESC LIMIT 1", "source_tables": ["volume"], "description": "This virtual table lists the songs from the 'volume' table, ordered by the number of weeks they stayed at the top, allowing users to specify a limit on the number of results returned. The placeholder in the LIMIT clause represents the maximum number of songs to display.", "virtual_table": "SELECT Song FROM volume ORDER BY Weeks_on_Top DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6195", "db_id": "music_4", "question": "What is the issue date of the volume with the minimum weeks on top?", "rationale": ["The query identifies the relevant table, which is 'volume'.", "Select the column to display, 'Issue_Date'.", "Order the results by 'Weeks_on_Top' in ascending order to show the earliest weeks at the top.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT Issue_Date FROM volume ORDER BY Weeks_on_Top ASC LIMIT 1", "source_tables": ["volume"], "description": "This virtual table provides a list of issue release dates from the 'volume' table, ordered by the number of weeks the associated song stayed at the top, allowing users to retrieve a specified number of results. The placeholder in the LIMIT clause represents the maximum number of issue dates to return.", "virtual_table": "SELECT Issue_Date FROM volume ORDER BY Weeks_on_Top ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6271", "db_id": "city_record", "question": "What is the match id of the competition called \"1994 FIFA World Cup qualification\"?", "rationale": ["The query is identifying the relevant table, which is 'match'.", "Select the column to display, 'match_id'.", "Add a condition to filter the 'competition' column for the specified competition using a placeholder for string values."], "gold_sql": "SELECT match_id FROM MATCH WHERE competition = '1994 FIFA World Cup qualification'", "source_tables": ["match"], "description": "This virtual table describes the unique identifiers of matches from the 'match' table that are part of a specific competition. The placeholder in the WHERE clause represents the competition's identifier.", "virtual_table": "SELECT match_id FROM MATCH WHERE competition = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6274", "db_id": "city_record", "question": "Which city has hosted the most events?", "rationale": ["The query identifies the relevant tables, 'city' and 'hosting_city'.", "It selects the 'city' from the 'city' table, using an alias for clarity.", "A JOIN operation is performed between 'city' and 'hosting_city' on the matching city identifiers to link hosted matches with their respective cities.", "The results are grouped by the host city to count the number of matches hosted in each city.", "The results are ordered in descending order based on the count of matches, allowing the most frequently hosting cities to appear first.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for the user to specify the desired number."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["hosting_city", "city"], "description": "This virtual table lists the cities that have hosted the most matches, ordered by the number of matches hosted. The placeholder in the LIMIT clause allows the user to specify how many top cities they want to retrieve.", "virtual_table": "SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6286", "db_id": "city_record", "question": "Which city has the highest temperature in February?", "rationale": ["The query identifies the relevant tables, which are 'city' and 'temperature'.", "It selects the 'city' column from the 'city' table, aliased as T1.", "A JOIN operation is performed between 'city' and 'temperature' on the 'city_id' to combine data from both tables.", "The results are ordered by the average temperature in February from the 'temperature' table in descending order.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id ORDER BY T2.Feb DESC LIMIT 1", "source_tables": ["city", "temperature"], "description": "This virtual table lists the names of cities from the 'city' table, ordered by their average temperature in February from the 'temperature' table in descending order. The placeholder in the LIMIT clause represents the maximum number of cities to be displayed.", "virtual_table": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id ORDER BY T2.Feb DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6287", "db_id": "city_record", "question": "In February, which city marks the highest temperature?", "rationale": ["The query identifies the relevant tables, which are 'city' and 'temperature'.", "It selects the 'city' column from the 'city' table, aliased as T1.", "A JOIN operation is performed between 'city' and 'temperature' on the 'city_id' to combine data from both tables.", "The results are ordered by the average temperature in February from the 'temperature' table in descending order.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id ORDER BY T2.Feb DESC LIMIT 1", "source_tables": ["city", "temperature"], "description": "This virtual table lists the names of cities from the 'city' table, ordered by their average temperature in February from the 'temperature' table in descending order. The placeholder in the LIMIT clause represents the maximum number of cities to be displayed.", "virtual_table": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id ORDER BY T2.Feb DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6288", "db_id": "city_record", "question": "Give me a list of cities whose temperature in March is lower than that in July or higher than that in Oct?", "rationale": ["The query identifies the relevant tables, which are 'city' and 'temperature'.", "It selects the 'city' column from the 'city' table, aliased as T1.", "A JOIN operation is performed between 'city' (T1) and 'temperature' (T2) on the 'city_id' to combine data from both tables.", "The WHERE clause applies conditions to filter cities based on their average temperatures in March, July, and October using placeholders for the temperature values."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul OR T2.Mar  >  T2.Oct", "source_tables": ["city", "temperature"], "description": "This virtual table lists the names of cities from the 'city' table that have an average temperature in March that is either lower than the average temperature in July or higher than the average temperature in October. The placeholders in the WHERE clause represent the temperature values for the respective months.", "virtual_table": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul OR T2.Mar  >  T2.Oct"}
{"sample_id": "train.6289", "db_id": "city_record", "question": "Which cities' temperature in March is lower than that in July or higher than that in Oct?", "rationale": ["The query identifies the relevant tables, which are 'city' and 'temperature'.", "It selects the 'city' column from the 'city' table, aliased as T1.", "A JOIN operation is performed between 'city' (T1) and 'temperature' (T2) on the 'city_id' to combine data from both tables.", "A WHERE clause is added to filter cities based on the temperature conditions for March, July, and October using placeholders for the temperature values."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul OR T2.Mar  >  T2.Oct", "source_tables": ["city", "temperature"], "description": "This virtual table identifies cities from the 'city' table that have a specific temperature condition. It selects cities where the average temperature in March is either less than the average temperature in July or greater than the average temperature in October. The placeholders in the query represent the temperature values for the respective months.", "virtual_table": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul OR T2.Mar  >  T2.Oct"}
{"sample_id": "train.6292", "db_id": "city_record", "question": "Give me a list of cities whose temperature in Mar is lower than that in Dec and which have never been host cities.", "rationale": ["The query starts by selecting the 'city' from the 'city' table, aliased as T1.", "It joins the 'temperature' table, aliased as T2, on the 'city_id' to access temperature data.", "A condition is applied to filter cities where the average temperature in March is less than that in December.", "The EXCEPT clause is used to exclude cities that are found in the 'hosting_city' table, which indicates they have hosted a match. This is done by joining the 'city' table again, aliased as T3, with the 'hosting_city' table, aliased as T4, on the 'city_id' and 'host_city'."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "description": "This virtual table identifies cities that have a lower average temperature in March compared to December, excluding those cities that have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.", "virtual_table": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city"}
{"sample_id": "train.6293", "db_id": "city_record", "question": "Which cities have lower temperature in March than in Dec and have never served as host cities?", "rationale": ["The query starts by selecting the 'city' from the 'city' table, aliased as T1.", "It joins the 'temperature' table, aliased as T2, on the 'city_id' to access temperature data.", "A condition is applied to filter cities where the average temperature in March is less than that in December.", "The EXCEPT clause is used to exclude cities that are found in the 'hosting_city' table, which indicates they have hosted a match. This is done by joining the 'city' table again, aliased as T3, with the 'hosting_city' table, aliased as T4, on the 'city_id' and 'host_city'."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "description": "This virtual table identifies cities that have a lower average temperature in March compared to December, excluding those cities that have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.", "virtual_table": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city"}
{"sample_id": "train.6298", "db_id": "city_record", "question": "Please give me a list of cities whose regional population is over 8000000 or under 5000000.", "rationale": ["The query identifies the relevant table, which is 'city'.", "It selects the 'city' column to display the names of the cities.", "The first part of the query filters cities with a regional population greater than a specified number using a placeholder for numeric values.", "The second part of the query filters cities with a regional population less than another specified number using another placeholder for numeric values.", "The UNION operator combines the results of both queries to provide a comprehensive list of cities that meet either condition."], "gold_sql": "SELECT city FROM city WHERE regional_population  >  10000000 UNION SELECT city FROM city WHERE regional_population  <  5000000", "source_tables": ["city"], "description": "This virtual table provides a list of cities from the 'city' table based on their regional population. It retrieves cities with a population greater than a specified number and also those with a population less than another specified number. The placeholders in the WHERE clauses represent the population thresholds for filtering the cities.", "virtual_table": "SELECT city FROM city WHERE regional_population  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT city FROM city WHERE regional_population  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6313", "db_id": "e_government", "question": "What is the name of the party form that is most common?", "rationale": ["The query identifies the relevant tables, 'Forms' and 'Party_Forms'.", "It selects the 'form_name' from the 'Forms' table.", "A JOIN operation is performed between 'Forms' and 'Party_Forms' on the 'form_id' to link forms to parties.", "The results are grouped by 'form_id' to aggregate the counts of each form's usage.", "The results are ordered by the count of associations in descending order to prioritize the most frequently used forms.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT t1.form_name FROM forms AS t1 JOIN party_forms AS t2 ON t1.form_id  =  t2.form_id GROUP BY t2.form_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["forms", "party_forms"], "description": "This virtual table provides a list of form names from the 'Forms' table that are associated with parties through the 'Party_Forms' table. The results are grouped by form ID and ordered by the count of associations in descending order, allowing users to see the most frequently used forms. The placeholder in the LIMIT clause represents the maximum number of results to return.", "virtual_table": "SELECT t1.form_name FROM forms AS t1 JOIN party_forms AS t2 ON t1.form_id  =  t2.form_id GROUP BY t2.form_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6329", "db_id": "e_government", "question": "What are the names of the services that have never been used?", "rationale": ["The query identifies the relevant table, which is 'Services'.", "It selects the 'service_name' column to display the names of the services.", "The EXCEPT clause is used to filter out service names that are linked to any bookings in the 'Party_Services' table by joining on 'service_id' to ensure only unbooked services are listed."], "gold_sql": "SELECT service_name FROM services EXCEPT SELECT t1.service_name FROM services AS t1 JOIN party_services AS t2 ON t1.service_id  =  t2.service_id", "source_tables": ["services", "party_services"], "description": "This virtual table lists the names of services from the 'Services' table that have not been booked by any party. The query uses an EXCEPT clause to exclude service names that are present in the 'Party_Services' table, indicating that those services have been booked.", "virtual_table": "SELECT service_name FROM services EXCEPT SELECT t1.service_name FROM services AS t1 JOIN party_services AS t2 ON t1.service_id  =  t2.service_id"}
{"sample_id": "train.6330", "db_id": "e_government", "question": "Find the name of all the cities and states.", "rationale": ["The query identifies the relevant table, which is 'Addresses'.", "It selects the 'town_city' column to retrieve the names of towns or cities.", "It also selects the 'state_province_county' column to retrieve the names of states, provinces, or counties.", "The UNION operator is used to combine the results from both columns, ensuring that the final output contains unique values."], "gold_sql": "SELECT town_city FROM addresses UNION SELECT state_province_county FROM addresses", "source_tables": ["addresses"], "description": "This virtual table provides a combined list of town/city names and state/province/county names from the 'Addresses' table. The use of UNION allows for the retrieval of unique entries from both columns, ensuring that any duplicates are removed.", "virtual_table": "SELECT town_city FROM addresses UNION SELECT state_province_county FROM addresses"}
{"sample_id": "train.6342", "db_id": "e_government", "question": "Which state can address \"6862 Kaitlyn Knolls\" possibly be in?", "rationale": ["The query identifies the relevant table, which is 'Addresses'.", "Select the column to display, 'state_province_county'.", "Add a condition to filter the 'line_1_number_building' column using the LIKE operator with a placeholder for string values."], "gold_sql": "SELECT state_province_county FROM addresses WHERE line_1_number_building LIKE '%6862 Kaitlyn Knolls%'", "source_tables": ["addresses"], "description": "This virtual table retrieves the state, province, or county information from the 'Addresses' table based on a specific address line that matches a given pattern. The placeholder in the LIKE clause allows for flexible searching of address lines.", "virtual_table": "SELECT state_province_county FROM addresses WHERE line_1_number_building LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6346", "db_id": "e_government", "question": "Find the last name of the individuals that have been contact individuals of an organization.", "rationale": ["The query identifies the relevant tables, which are 'Individuals' and 'Organization_Contact_Individuals'.", "It selects the 'individual_last_name' column from the 'Individuals' table.", "A JOIN operation is performed on the 'individual_id' to link individuals with their corresponding organization contacts.", "The DISTINCT keyword is used to ensure that only unique last names are included in the result."], "gold_sql": "SELECT DISTINCT t1.individual_last_name FROM individuals AS t1 JOIN organization_contact_individuals AS t2 ON t1.individual_id  =  t2.individual_id", "source_tables": ["organization_contact_individuals", "individuals"], "description": "This virtual table provides a list of unique last names of individuals who have contacted organizations. It combines data from the 'Individuals' table and the 'Organization_Contact_Individuals' table, ensuring that only distinct last names are returned.", "virtual_table": "SELECT DISTINCT t1.individual_last_name FROM individuals AS t1 JOIN organization_contact_individuals AS t2 ON t1.individual_id  =  t2.individual_id"}
{"sample_id": "train.6371", "db_id": "flight_company", "question": "What are the names and types of the companies that have ever operated a flight?", "rationale": ["The query identifies the relevant tables, which are 'operate_company' and 'flight'.", "It selects the columns 'name' and 'Type' from the 'operate_company' table, which represent the company's name and type.", "A JOIN operation is performed between 'operate_company' and 'flight' on the condition that the 'id' from 'operate_company' matches the 'company_id' in 'flight', linking the operating companies to their respective flights."], "gold_sql": "SELECT T1.name ,  T1.type FROM operate_company AS T1 JOIN flight AS t2 ON T1.id  =  T2.company_id", "source_tables": ["flight", "operate_company"], "description": "This virtual table provides the names and types of operating companies that are associated with flights. The data is retrieved by joining the 'operate_company' table with the 'flight' table based on the company identifier, allowing users to see which companies operate specific flights.", "virtual_table": "SELECT T1.name ,  T1.type FROM operate_company AS T1 JOIN flight AS t2 ON T1.id  =  T2.company_id"}
{"sample_id": "train.6375", "db_id": "flight_company", "question": "What is the id, name and IATA code of the airport that had most number of flights?", "rationale": ["The query identifies the relevant tables, 'airport' and 'flight', and establishes a join between them based on the airport identifier.", "It selects the columns 'id', 'name', and 'IATA' from the 'airport' table, which are relevant for identifying airports.", "The results are grouped by the flight identifier to aggregate the data based on the number of flights associated with each airport.", "The results are ordered in descending order based on the count of flights, allowing the most active airports to be listed first.", "A limit is applied to restrict the number of results returned, using a placeholder for the user to specify the desired number."], "gold_sql": "SELECT T1.id ,  T1.name ,  T1.IATA FROM airport AS T1 JOIN flight AS T2 ON T1.id  =  T2.airport_id GROUP BY T2.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airport", "flight"], "description": "This virtual table provides a list of airport identifiers, names, and IATA codes from the 'airport' table, specifically for those airports that have been associated with flights. The results are grouped by flight identifiers to aggregate the data, ordered by the number of flights in descending order, and limited to a specified number of entries. The placeholder in the LIMIT clause represents the maximum number of results to return.", "virtual_table": "SELECT T1.id ,  T1.name ,  T1.IATA FROM airport AS T1 JOIN flight AS T2 ON T1.id  =  T2.airport_id GROUP BY T2.id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6381", "db_id": "flight_company", "question": "How many companies operates airlines in each airport?", "rationale": ["The query identifies the relevant tables: 'operate_company', 'flight', and 'airport'.", "It performs a JOIN operation to link the 'operate_company' table with the 'flight' table using the 'company_id'.", "Then, it joins the 'flight' table with the 'airport' table using the 'airport_id'.", "The SELECT statement retrieves the airport ID and counts the number of flights for each airport.", "Finally, it groups the results by the airport ID to provide a count of flights per airport."], "gold_sql": "SELECT T3.id ,  count(*) FROM operate_company AS T1 JOIN flight AS t2 ON T1.id  =  T2.company_id JOIN airport AS T3 ON T2.airport_id  =  T3.id GROUP BY T3.id", "source_tables": ["airport", "flight", "operate_company"], "description": "This virtual table summarizes the number of flights operated by each company at different airports. It joins the 'operate_company', 'flight', and 'airport' tables to count the flights associated with each airport, identified by their unique IDs.", "virtual_table": "SELECT T3.id ,  count(*) FROM operate_company AS T1 JOIN flight AS t2 ON T1.id  =  T2.company_id JOIN airport AS T3 ON T2.airport_id  =  T3.id GROUP BY T3.id"}
{"sample_id": "train.6517", "db_id": "wine_1", "question": "What is the name of the highest rated wine?", "rationale": ["The query identifies the relevant table, which is 'wine'.", "Select the column to display, 'Name', which represents the names of the wines.", "Order the results by the 'Score' column to prioritize higher-rated wines.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT Name FROM WINE ORDER BY Score LIMIT 1", "source_tables": ["wine"], "description": "This virtual table lists the names of wines from the 'wine' table, ordered by their rating scores. The placeholder in the LIMIT clause indicates the maximum number of wine names to be returned.", "virtual_table": "SELECT Name FROM WINE ORDER BY Score LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6518", "db_id": "wine_1", "question": "Give the name of the wine with the highest score.", "rationale": ["The query identifies the relevant table, which is 'wine'.", "Select the column to display, 'Name'.", "Order the results by the 'Score' column to prioritize higher-rated wines.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT Name FROM WINE ORDER BY Score LIMIT 1", "source_tables": ["wine"], "description": "This virtual table lists the names of wines from the 'wine' table, ordered by their rating scores. The placeholder in the LIMIT clause represents the maximum number of wine names to be displayed.", "virtual_table": "SELECT Name FROM WINE ORDER BY Score LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6520", "db_id": "wine_1", "question": "What is the winery at which the wine with the highest score was made?", "rationale": ["The query identifies the relevant table, which is 'wine'.", "Select the column to display, 'Winery'.", "Order the results by the 'Score' column to prioritize higher-rated wineries.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT Winery FROM WINE ORDER BY SCORE LIMIT 1", "source_tables": ["wine"], "description": "This virtual table lists the names of wineries from the 'wine' table, ordered by their rating scores. The placeholder in the LIMIT clause represents the maximum number of wineries to be displayed.", "virtual_table": "SELECT Winery FROM WINE ORDER BY SCORE LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6533", "db_id": "wine_1", "question": "List the names of all distinct wines that are made of red color grape.", "rationale": ["The query identifies the relevant tables, which are 'grapes' and 'wine'.", "It uses a JOIN operation to connect the two tables based on the grape variety.", "The SELECT DISTINCT clause is used to ensure that only unique wine names are returned.", "A condition is added to filter the grape color using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T2.Name FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'Red'", "source_tables": ["wine", "grapes"], "description": "This virtual table lists the distinct names of wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filtering the results to include only those grapes that match the specified color.", "virtual_table": "SELECT DISTINCT T2.Name FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6544", "db_id": "wine_1", "question": "Give the names and scores of wines made from white grapes.", "rationale": ["The query identifies the relevant tables, which are 'grapes' and 'wine'.", "It selects the columns to display, 'Name' and 'Score' from the 'wine' table.", "A join is performed between the 'grapes' and 'wine' tables on the 'Grape' column to link the grape varieties to their respective wines.", "A condition is added to filter the 'Color' column in the 'grapes' table for the specified color using a placeholder for string values."], "gold_sql": "SELECT T2.Name ,   T2.Score FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'White'", "source_tables": ["wine", "grapes"], "description": "This virtual table provides the names and scores of wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filtering the results to include only those grapes that match the specified color.", "virtual_table": "SELECT T2.Name ,   T2.Score FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6547", "db_id": "wine_1", "question": "Find the the grape whose white color grapes are used to produce wines with scores higher than 90.", "rationale": ["The query identifies the relevant tables, which are 'grapes' and 'wine'.", "It selects distinct grape varieties from the 'grapes' table.", "A JOIN operation is performed between 'grapes' and 'wine' on the grape variety to filter the results based on the specified conditions.", "The WHERE clause includes conditions to filter by grape color and wine score, using placeholders for the specific values."], "gold_sql": "SELECT DISTINCT T1.Grape FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'White' AND T2.score  >  90", "source_tables": ["wine", "grapes"], "description": "This virtual table lists distinct grape varieties from the 'grapes' table that have a specific color and are associated with wines that have a score above a certain threshold. The placeholders in the WHERE clause represent the color of the grape and the minimum score for the wine.", "virtual_table": "SELECT DISTINCT T1.Grape FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING] AND T2.score  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6550", "db_id": "wine_1", "question": "What are the names of wines made from red grapes and with prices above 50?", "rationale": ["The query identifies the relevant tables, which are 'Grapes' and 'Wine'.", "It selects the 'Name' column from the 'Wine' table.", "A JOIN operation is performed between 'Grapes' and 'Wine' on the 'Grape' column to link the two tables.", "Conditions are added to filter the results based on the specified grape color and price using placeholders for string and numeric values."], "gold_sql": "SELECT T2.Name FROM Grapes AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'Red' AND T2.price  >  50", "source_tables": ["wine", "grapes"], "description": "This virtual table describes the names of wines made from grape varieties of a specific color and priced above a certain amount. The placeholders in the WHERE clause represent the grape color and the price threshold.", "virtual_table": "SELECT T2.Name FROM Grapes AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING] AND T2.price  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6558", "db_id": "wine_1", "question": "What are the distinct names of wines with prices higher than any wine from John Anthony winery.", "rationale": ["The query identifies the relevant table, which is 'wine'.", "It selects distinct wine names from the 'wine' table.", "A subquery is used to find the minimum price of wines produced by a specified winery, using a placeholder for the winery's name."], "gold_sql": "SELECT DISTINCT Name FROM WINE WHERE Price  >  (SELECT min(Price) FROM wine WHERE Winery  =  'John Anthony')", "source_tables": ["wine"], "description": "This virtual table lists the distinct names of wines from the 'wine' table that are priced higher than the minimum price of wines produced by a specific winery. The placeholder in the subquery represents the name of the winery.", "virtual_table": "SELECT DISTINCT Name FROM WINE WHERE Price  >  (SELECT min(Price) FROM wine WHERE Winery  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.6566", "db_id": "wine_1", "question": "Give the color of the grape whose wine products have the highest average price?", "rationale": ["The query identifies the relevant tables, 'grapes' and 'wine'.", "It selects the 'Color' column from the 'grapes' table, aliased as T1.", "A JOIN operation is performed between 'grapes' and 'wine' on the 'Grape' column to link grape varieties with their corresponding wines.", "The results are grouped by the 'Grape' column from the 'wine' table to aggregate the data.", "The average price of the wines is calculated and used to order the results in descending order.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.Color FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape GROUP BY T2.Grape ORDER BY AVG(Price) DESC LIMIT 1", "source_tables": ["wine", "grapes"], "description": "This virtual table provides the colors of grape varieties from the 'grapes' table, which are associated with wines in the 'wine' table. The results are grouped by grape variety and ordered by the average price of the wines produced from each grape, with a limit on the number of results returned based on a specified number.", "virtual_table": "SELECT T1.Color FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape GROUP BY T2.Grape ORDER BY AVG(Price) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6588", "db_id": "wine_1", "question": "Which 3 wineries produce the most wines made from white grapes?", "rationale": ["The query identifies the relevant tables, which are 'grapes' and 'wine'.", "It selects the 'Winery' column from the 'wine' table.", "The join condition is established between 'grapes' and 'wine' on the grape variety.", "A filter is applied to the 'Color' column in the 'grapes' table using a placeholder for string values.", "The results are grouped by the 'Winery' to aggregate the data.", "The results are ordered by the count of wines produced, in descending order.", "A limit is applied to restrict the number of wineries returned, using a placeholder for numeric values."], "gold_sql": "SELECT T2.Winery FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.GRAPE  =  T2.GRAPE WHERE T1.Color  =  'White' GROUP BY T2.Winery ORDER BY count(*) DESC LIMIT 3", "source_tables": ["wine", "grapes"], "description": "This virtual table lists the names of wineries that produce wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filters the results by the specified grape color, groups the results by winery name, and orders them by the number of wines produced, limiting the output to a specified number of wineries.", "virtual_table": "SELECT T2.Winery FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.GRAPE  =  T2.GRAPE WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T2.Winery ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6597", "db_id": "wine_1", "question": "Find the county where produces the most number of wines with score higher than 90.", "rationale": ["The query identifies the relevant tables, 'appellations' and 'wine', and establishes a join condition based on the 'Appelation' column.", "It selects the 'County' from the 'appellations' table.", "A condition is added to filter wines based on their 'Score', using a placeholder for numeric values.", "The results are grouped by 'County' to aggregate the data, and ordered by the count of wines in descending order.", "Finally, a limit is applied to restrict the number of counties returned, using another placeholder for numeric values."], "gold_sql": "SELECT T1.County FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T2.Score  >  90 GROUP BY T1.County ORDER BY count(*) DESC LIMIT 1", "source_tables": ["wine", "appellations"], "description": "This virtual table provides a list of counties where wines with a score above a specified threshold are produced. The placeholder in the WHERE clause represents the minimum score for filtering the wines, and the second placeholder limits the number of counties returned based on the count of wines produced in each county.", "virtual_table": "SELECT T1.County FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T2.Score  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.County ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6626", "db_id": "driving_school", "question": "Show the detail of vehicle with id 1.", "rationale": ["The query identifies the relevant table, which is 'Vehicles'.", "Select the column to display, 'vehicle_details'.", "Add a condition to filter the 'vehicle_id' column for the specified vehicle using a placeholder for numeric values."], "gold_sql": "SELECT vehicle_details FROM Vehicles WHERE vehicle_id = 1;", "source_tables": ["vehicles"], "description": "This virtual table provides details about vehicles from the 'Vehicles' table based on a specific vehicle identifier. The placeholder in the WHERE clause represents the unique identifier for the vehicle.", "virtual_table": "SELECT vehicle_details FROM Vehicles WHERE vehicle_id = [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.6650", "db_id": "driving_school", "question": "How many staff live in state Georgia?", "rationale": ["The query identifies the relevant table, which is 'Addresses'.", "It selects a count of all entries in the table to determine how many addresses exist in the specified location.", "A condition is added to filter the results based on the 'state_province_county' column using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM Addresses WHERE state_province_county = 'Georgia';", "source_tables": ["addresses"], "description": "This virtual table provides the count of addresses from the 'Addresses' table that are located in a specific state, province, or county. The placeholder in the WHERE clause represents the name of the state, province, or county being queried.", "virtual_table": "SELECT count(*) FROM Addresses WHERE state_province_county = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.6665", "db_id": "driving_school", "question": "What is the status code, phone number, and email address of the customer whose last name is Kohler or whose first name is Marina?", "rationale": ["The query identifies the relevant table, which is 'Customers'.", "Select the columns to display: 'customer_status_code', 'cell_mobile_phone_number', and 'email_address'.", "Add a condition to filter the 'first_name' and 'last_name' columns for the specified names using placeholders for string values."], "gold_sql": "SELECT customer_status_code ,  cell_mobile_phone_number ,  email_address FROM Customers WHERE first_name = 'Marina' OR last_name  =  'Kohler'", "source_tables": ["customers"], "description": "This virtual table provides the status code, mobile phone number, and email address of customers from the 'Customers' table who have a specific first name or last name. The placeholders in the WHERE clause represent the customer's first and last names.", "virtual_table": "SELECT customer_status_code ,  cell_mobile_phone_number ,  email_address FROM Customers WHERE first_name = [PLACEHOLDER-TYPE:STRING] OR last_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6676", "db_id": "driving_school", "question": "How many lessons taken by customer with first name as Rylan and last name as Goodwin were completed?", "rationale": ["The query identifies the relevant tables, 'Lessons' and 'Customers', that are needed to retrieve the count of lessons.", "It uses a JOIN operation to link the 'Lessons' table with the 'Customers' table based on the customer ID.", "The SELECT statement counts the total number of lessons for the specified customer.", "The WHERE clause filters the results based on the customer's first name, last name, and the lesson status code using placeholders for string values."], "gold_sql": "SELECT count(*) FROM Lessons AS T1 JOIN Customers AS T2 ON T1.customer_id  = T2.customer_id WHERE T2.first_name = 'Rylan' AND T2.last_name = 'Goodwin' AND T1.lesson_status_code = 'Completed';", "source_tables": ["lessons", "customers"], "description": "This virtual table provides the count of lessons associated with a specific customer identified by their first and last name. It filters the lessons based on the customer's name and the status of the lesson. The placeholders in the WHERE clause represent the customer's first name, last name, and the lesson status code.", "virtual_table": "SELECT count(*) FROM Lessons AS T1 JOIN Customers AS T2 ON T1.customer_id  = T2.customer_id WHERE T2.first_name = [PLACEHOLDER-TYPE:STRING] AND T2.last_name = [PLACEHOLDER-TYPE:STRING] AND T1.lesson_status_code = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.6688", "db_id": "driving_school", "question": "Which city does has most number of customers?", "rationale": ["The query identifies the relevant tables, 'Customers' and 'Addresses', and establishes a join between them using the customer_address_id and address_id.", "It selects the 'city' column from the 'Addresses' table.", "The results are grouped by 'city' to aggregate the customer counts per city.", "The results are ordered in descending order based on the count of customers in each city.", "A limit is applied to restrict the number of cities returned, using a placeholder for numeric values."], "gold_sql": "SELECT T2.city FROM Customers AS T1 JOIN Addresses AS T2 ON T1.customer_address_id = T2.address_id GROUP BY T2.city ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["addresses", "customers"], "description": "This virtual table provides a list of cities where customers are located, derived from the 'Customers' and 'Addresses' tables. The results are grouped by city and ordered by the number of customers in each city, with a limit on the number of cities returned based on a specified number.", "virtual_table": "SELECT T2.city FROM Customers AS T1 JOIN Addresses AS T2 ON T1.customer_address_id = T2.address_id GROUP BY T2.city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.6711", "db_id": "driving_school", "question": "What are the last names that are used by customers and staff?", "rationale": ["The query is identifying the relevant tables, which are 'Customers' and 'Staff'.", "Select the column to display, 'last_name', from both tables.", "Use the INTERSECT operator to find common last names between the two tables."], "gold_sql": "SELECT last_name FROM Customers INTERSECT SELECT last_name FROM Staff", "source_tables": ["staff", "customers"], "description": "This virtual table identifies the last names that are common between customers and staff members. The query uses the INTERSECT operator to find last names that appear in both the 'Customers' and 'Staff' tables.", "virtual_table": "SELECT last_name FROM Customers INTERSECT SELECT last_name FROM Staff"}
{"sample_id": "train.6714", "db_id": "driving_school", "question": "What is the id and detail of the vehicle used in lessons for most of the times?", "rationale": ["The query identifies the relevant tables, which are 'Vehicles' and 'Lessons'.", "It selects the columns 'vehicle_id' and 'vehicle_details' from the 'Vehicles' table.", "A JOIN operation is performed between 'Vehicles' and 'Lessons' on the vehicle ID to link vehicles to the lessons they are used in.", "The results are grouped by 'vehicle_id' to aggregate the data based on each vehicle.", "The results are ordered by the count of lessons associated with each vehicle in descending order to show the most frequently used vehicles first.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.vehicle_id ,  T1.vehicle_details FROM Vehicles AS T1 JOIN Lessons AS T2 ON T1.vehicle_id  =  T2.vehicle_id GROUP BY T1.vehicle_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["lessons", "vehicles"], "description": "This virtual table provides a list of vehicle IDs and their corresponding details from the 'Vehicles' table, specifically for vehicles that have been used in lessons. The results are grouped by vehicle ID and ordered by the number of lessons associated with each vehicle in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.", "virtual_table": "SELECT T1.vehicle_id ,  T1.vehicle_details FROM Vehicles AS T1 JOIN Lessons AS T2 ON T1.vehicle_id  =  T2.vehicle_id GROUP BY T1.vehicle_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6725", "db_id": "activity_1", "question": "Show ids for all the male faculty.", "rationale": ["The query is identifying the relevant table, which is 'Faculty'.", "Select the column to display, 'FacID'.", "Add a condition to filter the 'Sex' column for the specified gender using a placeholder for string values."], "gold_sql": "SELECT FacID FROM Faculty WHERE Sex  =  'M'", "source_tables": ["faculty"], "description": "This virtual table describes the unique identifiers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.", "virtual_table": "SELECT FacID FROM Faculty WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6734", "db_id": "activity_1", "question": "What are the first name and last name of all the instructors?", "rationale": ["The query is identifying the relevant table, which is 'Faculty'.", "Select the columns to display, 'fname' and 'lname'.", "Add a condition to filter the 'Rank' column for the specified rank using a placeholder for string values."], "gold_sql": "SELECT fname ,  lname FROM Faculty WHERE Rank  =  'Instructor'", "source_tables": ["faculty"], "description": "This virtual table describes the first and last names of faculty members from the 'Faculty' table who hold a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.", "virtual_table": "SELECT fname ,  lname FROM Faculty WHERE Rank  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6737", "db_id": "activity_1", "question": "Which building has most faculty members?", "rationale": ["The query identifies the relevant table, which is 'Faculty'.", "It selects the 'building' column to display the names of the buildings.", "The results are grouped by 'building' to aggregate the data based on the building names.", "The query orders the results by the count of faculty members in each building in descending order to show the most populated buildings first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT building FROM Faculty GROUP BY building ORDER BY count(*) DESC LIMIT 1", "source_tables": ["faculty"], "description": "This virtual table provides a list of buildings where faculty members have their offices, grouped by building name. The results are ordered by the number of faculty members in each building in descending order, and the placeholder allows the user to specify the maximum number of buildings to return.", "virtual_table": "SELECT building FROM Faculty GROUP BY building ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6747", "db_id": "activity_1", "question": "Show the number of male and female assistant professors.", "rationale": ["The query identifies the relevant table, which is 'Faculty'.", "It selects the 'sex' column and counts the number of occurrences for each gender.", "A condition is added to filter the results based on the specified 'rank' using a placeholder for string values.", "The results are grouped by 'sex' to provide a count for each gender category."], "gold_sql": "SELECT sex ,  count(*) FROM Faculty WHERE rank  =  'AsstProf' GROUP BY sex", "source_tables": ["faculty"], "description": "This virtual table summarizes the gender distribution of faculty members based on their academic rank. The placeholder in the WHERE clause represents the specific rank of faculty members being queried.", "virtual_table": "SELECT sex ,  count(*) FROM Faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] GROUP BY sex"}
{"sample_id": "train.6748", "db_id": "activity_1", "question": "How many male and female assistant professors do we have?", "rationale": ["The query identifies the relevant table, which is 'Faculty'.", "It selects the 'sex' column and counts the number of occurrences for each gender.", "A condition is added to filter the results based on the specified 'rank' using a placeholder for string values.", "The results are grouped by 'sex' to provide a count of faculty members for each gender within the specified rank."], "gold_sql": "SELECT sex ,  count(*) FROM Faculty WHERE rank  =  'AsstProf' GROUP BY sex", "source_tables": ["faculty"], "description": "This virtual table summarizes the gender distribution of faculty members based on their academic rank. The placeholder in the WHERE clause represents the specific rank of faculty members being queried.", "virtual_table": "SELECT sex ,  count(*) FROM Faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] GROUP BY sex"}
{"sample_id": "train.6750", "db_id": "activity_1", "question": "Who is the advisor of Linda Smith? Give me the first name and last name.", "rationale": ["The query identifies the relevant tables, which are 'Faculty' and 'Student'.", "It selects the columns to display, 'fname' and 'lname' from the 'Faculty' table.", "A JOIN operation is performed between 'Faculty' and 'Student' on the advisor relationship.", "Conditions are added to filter the 'Student' table for the specified student's first and last names using placeholders for string values."], "gold_sql": "SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T2.fname  =  'Linda' AND T2.lname  =  'Smith'", "source_tables": ["faculty", "student"], "description": "This virtual table describes the first names and last names of faculty members who are academic advisors to a specific student. The placeholders in the WHERE clause represent the first and last names of the student.", "virtual_table": "SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T2.fname  =  [PLACEHOLDER-TYPE:STRING] AND T2.lname  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6751", "db_id": "activity_1", "question": "Show the ids of students whose advisors are professors.", "rationale": ["The query is identifying the relevant tables, which are 'Faculty' and 'Student'.", "A JOIN operation is performed to connect the 'Faculty' table with the 'Student' table based on the advisor relationship.", "The SELECT statement specifies that we want to retrieve the 'StuID' from the 'Student' table.", "A condition is added to filter faculty members based on their rank using a placeholder for string values."], "gold_sql": "SELECT T2.StuID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.rank  =  'Professor'", "source_tables": ["faculty", "student"], "description": "This virtual table identifies the unique identifiers of students who are advised by faculty members of a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.", "virtual_table": "SELECT T2.StuID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.rank  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6752", "db_id": "activity_1", "question": "Which students have professors as their advisors? Find their student ids.", "rationale": ["The query is identifying the relevant tables, which are 'Faculty' and 'Student'.", "A JOIN operation is performed to connect the 'Faculty' table with the 'Student' table based on the advisor relationship.", "The SELECT statement specifies that we want to retrieve the 'StuID' from the 'Student' table.", "A condition is added to filter faculty members based on their rank using a placeholder for string values."], "gold_sql": "SELECT T2.StuID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.rank  =  'Professor'", "source_tables": ["faculty", "student"], "description": "This virtual table identifies the unique identifiers of students who are advised by faculty members of a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.", "virtual_table": "SELECT T2.StuID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.rank  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6753", "db_id": "activity_1", "question": "Show first name and last name for all the students advised by Michael Goodrich.", "rationale": ["The query identifies the relevant tables, which are 'Faculty' and 'Student'.", "It selects the columns to display, 'fname' and 'lname' from the 'Student' table.", "A JOIN operation is performed between 'Faculty' and 'Student' on the advisor relationship.", "Conditions are added to filter the faculty member by their first and last names using placeholders for string values."], "gold_sql": "SELECT T2.fname ,  T2.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.fname  =  'Michael' AND T1.lname  =  'Goodrich'", "source_tables": ["faculty", "student"], "description": "This virtual table describes the first and last names of students who are advised by a specific faculty member. The placeholders in the WHERE clause represent the first and last names of the faculty member.", "virtual_table": "SELECT T2.fname ,  T2.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6756", "db_id": "activity_1", "question": "What are the faculty id and the number of students each faculty has?", "rationale": ["The query identifies the relevant tables, which are 'Faculty' and 'Student'.", "It selects the 'FacID' from the 'Faculty' table and counts the number of students associated with each faculty member.", "The JOIN operation links the 'Faculty' table with the 'Student' table based on the advisor relationship, where 'FacID' matches the 'advisor' field in the 'Student' table.", "The GROUP BY clause groups the results by 'FacID' to aggregate the count of students for each faculty member."], "gold_sql": "SELECT T1.FacID ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID", "source_tables": ["faculty", "student"], "description": "This virtual table provides a count of students assigned to each faculty member as their advisor from the 'Faculty' and 'Student' tables. The placeholder in the SELECT statement represents the faculty member's unique identifier.", "virtual_table": "SELECT T1.FacID ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID"}
{"sample_id": "train.6758", "db_id": "activity_1", "question": "How many students are advised by each rank of faculty? List the rank and the number of students.", "rationale": ["The query identifies the relevant tables, which are 'Faculty' and 'Student'.", "It selects the 'rank' column from the 'Faculty' table and counts the number of students associated with each faculty member.", "The join condition links faculty members to their students through the advisor relationship.", "The results are grouped by the faculty rank to provide a count of students for each rank."], "gold_sql": "SELECT T1.rank ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.rank", "source_tables": ["faculty", "student"], "description": "This virtual table summarizes the number of students assigned to each academic rank of faculty members. It joins the 'Faculty' table with the 'Student' table based on the advisor relationship, grouping the results by the faculty rank to count the number of students per rank.", "virtual_table": "SELECT T1.rank ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.rank"}
{"sample_id": "train.6761", "db_id": "activity_1", "question": "Show the ids for all the faculty members who have at least 2 students.", "rationale": ["The query identifies the relevant tables, which are 'Faculty' and 'Student'.", "It selects the 'FacID' from the 'Faculty' table, using an alias for clarity.", "A JOIN operation is performed between 'Faculty' and 'Student' on the advisor relationship, where 'FacID' matches the 'advisor' field in the 'Student' table.", "The results are grouped by 'FacID' to aggregate the number of students each faculty member advises.", "The HAVING clause filters the results to include only those faculty members who have advised a specified minimum number of students, using a placeholder for numeric values."], "gold_sql": "SELECT T1.FacID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID HAVING count(*)  >=  2", "source_tables": ["faculty", "student"], "description": "This virtual table identifies faculty members who serve as advisors to students. It retrieves the unique identifiers of faculty members from the 'Faculty' table, joining it with the 'Student' table based on the advisor relationship. The results are grouped by faculty ID, and only those faculty members who have advised a specified minimum number of students are included, as indicated by the placeholder in the HAVING clause.", "virtual_table": "SELECT T1.FacID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]"}
