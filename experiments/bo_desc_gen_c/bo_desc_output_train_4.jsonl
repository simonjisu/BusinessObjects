{"sample_id": "train.3449", "db_id": "hr_1", "question": "display those departments where more than ten employees work who got a commission percentage.", "rationale": ["The query identifies the relevant table, which is 'employees'.", "It selects the 'department_id' to group the results by department.", "The HAVING clause is used to filter groups based on the count of employees with a commission percentage, using a placeholder for the numeric value."], "gold_sql": "SELECT department_id FROM employees GROUP BY department_id HAVING COUNT(commission_pct) > 10", "source_tables": ["employees"], "description": "This virtual table lists the identifiers of departments from the 'employees' table that have more than a specified number of employees receiving a commission. The placeholder in the HAVING clause represents the minimum count of employees with a commission percentage.", "virtual_table": "SELECT department_id FROM employees GROUP BY department_id HAVING COUNT(commission_pct) > [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3474", "db_id": "hr_1", "question": "What are the full names and department ids for the lowest paid employees across all departments.", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Select the columns to display: 'first_name', 'last_name', and 'department_id'.", "Add a condition to filter employees whose salary matches the minimum salary in their department using a subquery that groups by 'department_id' and selects the minimum salary."], "gold_sql": "SELECT first_name ,  last_name ,  department_id FROM employees WHERE salary IN (SELECT MIN(salary) FROM employees GROUP BY department_id)", "source_tables": ["employees"], "description": "This virtual table provides the first and last names of employees along with their department identifiers from the 'employees' table, specifically targeting those employees who earn the minimum salary within their respective departments. The subquery identifies the minimum salary for each department, and the placeholder in the WHERE clause allows for dynamic filtering based on salary criteria.", "virtual_table": "SELECT first_name ,  last_name ,  department_id FROM employees WHERE salary IN (SELECT MIN(salary) FROM employees GROUP BY department_id)"}
{"sample_id": "train.3457", "db_id": "hr_1", "question": "display job ID for those jobs that were done by two or more for more than 300 days.", "rationale": ["The query identifies the relevant table, which is 'job_history'.", "It selects the 'job_id' column to display the job identifiers.", "A condition is added to filter the records where the difference between 'end_date' and 'start_date' exceeds a specified number of days using a placeholder for numeric values.", "The results are grouped by 'job_id' to aggregate the data.", "A HAVING clause is included to filter the groups to only those with a count of occurrences greater than or equal to a specified number, using another placeholder for numeric values."], "gold_sql": "SELECT job_id FROM job_history WHERE end_date - start_date  > 300 GROUP BY job_id HAVING COUNT(*) >= 2", "source_tables": ["job_history"], "description": "This virtual table provides a list of job identifiers from the 'job_history' table where the duration of the job (calculated as the difference between the end date and start date) exceeds a specified number of days. Additionally, it groups the results by job identifier and filters to include only those jobs that have been held for a minimum number of times, as indicated by the placeholder in the HAVING clause.", "virtual_table": "SELECT job_id FROM job_history WHERE end_date - start_date  > [PLACEHOLDER-TYPE:NUMBER] GROUP BY job_id HAVING COUNT(*) >= [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3506", "db_id": "hr_1", "question": "What are the ids, full names, and salaries for employees making more than average and who work in a department with employees who have the letter J in their first name?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "It selects the columns to display: 'employee_id', 'first_name', 'last_name', and 'salary'.", "A condition is added to filter employees whose salary is greater than the average salary, calculated using a subquery.", "Another condition is included to filter employees based on their department, specifically those departments that have at least one employee with a first name matching a specified pattern, using a placeholder for string values."], "gold_sql": "SELECT employee_id ,  first_name ,  last_name ,  salary FROM employees WHERE salary  >  ( SELECT AVG (salary) FROM employees ) AND department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE '%J%')", "source_tables": ["employees"], "description": "This virtual table provides a list of employees, including their unique identifier, first name, last name, and salary, from the 'employees' table. It filters the results to show only those employees whose salary is greater than the average salary of all employees and belong to departments where the first name of at least one employee matches a specified pattern.", "virtual_table": "SELECT employee_id ,  first_name ,  last_name ,  salary FROM employees WHERE salary  >  ( SELECT AVG (salary) FROM employees ) AND department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.3451", "db_id": "hr_1", "question": "Find the ids of the departments where any manager is managing 4 or more employees.", "rationale": ["The query identifies the relevant table, which is 'employees'.", "It selects distinct 'department_id' to ensure unique entries.", "The results are grouped by 'department_id' and 'manager_id' to aggregate the data accordingly.", "A HAVING clause is used to filter groups based on the count of 'employee_id', ensuring only departments with a specified minimum number of employees are included, using a placeholder for numeric values."], "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"], "description": "This virtual table lists unique department identifiers from the 'employees' table, grouped by department and manager. It filters the results to include only those departments that have a specified minimum number of employees, represented by a placeholder for numeric values.", "virtual_table": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3428", "db_id": "hr_1", "question": "Return the full names and salaries for employees with first names that end with the letter m.", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Select the columns to display: 'first_name', 'last_name', and 'salary'.", "Add a condition to filter the 'first_name' column using a LIKE operator with a placeholder for string values."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees WHERE first_name LIKE '%m'", "source_tables": ["employees"], "description": "This virtual table describes the first names, last names, and salaries of employees from the 'employees' table whose first names match a specific pattern. The placeholder in the WHERE clause represents the pattern for the first name.", "virtual_table": "SELECT first_name ,  last_name ,  salary FROM employees WHERE first_name LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3463", "db_id": "hr_1", "question": "display the department name and number of employees in each of the department.", "rationale": ["The query identifies the relevant tables, which are 'employees' and 'departments'.", "It uses a JOIN operation to link the 'employees' table with the 'departments' table based on the 'department_id'.", "The SELECT statement specifies the 'department_name' from the 'departments' table and counts the number of employees in each department.", "The GROUP BY clause is used to group the results by 'department_name', allowing for the aggregation of employee counts per department."], "gold_sql": "SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name", "source_tables": ["employees", "departments"], "description": "This virtual table provides a count of employees grouped by their respective department names from the 'departments' table. The placeholder in the SELECT statement allows for the retrieval of department names, while the COUNT function aggregates the number of employees in each department.", "virtual_table": "SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name"}
{"sample_id": "train.3470", "db_id": "hr_1", "question": "Provide the full names of employees earning more than the employee with id 163.", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Select the columns to display, 'first_name' and 'last_name'.", "Add a condition to filter employees based on their salary being greater than the salary of a specific employee.", "The subquery retrieves the salary of the employee identified by the placeholder for numeric values."], "gold_sql": "SELECT first_name ,  last_name FROM employees WHERE salary  >  (SELECT salary FROM employees WHERE employee_id = 163 )", "source_tables": ["employees"], "description": "This virtual table describes the first and last names of employees from the 'employees' table who earn more than a specific employee's salary. The placeholder in the subquery represents the unique identifier of the employee whose salary is being compared.", "virtual_table": "SELECT first_name ,  last_name FROM employees WHERE salary  >  (SELECT salary FROM employees WHERE employee_id = [PLACEHOLDER-TYPE:NUMBER] )"}
{"sample_id": "train.3508", "db_id": "hr_1", "question": "What are the employee ids and job ids for employees who make less than the lowest earning employee with title MK_MAN?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Select the columns to display, 'employee_id' and 'job_id'.", "Add a condition to filter employees whose salary is less than a certain value.", "The subquery retrieves the minimum salary for a specific job using a placeholder for the job identifier."], "gold_sql": "SELECT employee_id ,  job_id FROM employees WHERE salary  <  ( SELECT min(salary) FROM employees WHERE job_id  =  'MK_MAN' )", "source_tables": ["employees"], "description": "This virtual table provides a list of employee IDs and their corresponding job IDs from the 'employees' table, specifically for those employees whose salary is less than the minimum salary for a specified job. The placeholder in the subquery represents the job identifier for which the minimum salary is being compared.", "virtual_table": "SELECT employee_id ,  job_id FROM employees WHERE salary  <  ( SELECT min(salary) FROM employees WHERE job_id  =  [PLACEHOLDER-TYPE:STRING] )"}
{"sample_id": "train.3472", "db_id": "hr_1", "question": "What is the minimum salary in each department?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "It selects the minimum salary and groups the results by department identifier.", "The use of MIN(salary) allows for the calculation of the lowest salary within each department."], "gold_sql": "SELECT MIN(salary) ,  department_id FROM employees GROUP BY department_id", "source_tables": ["employees"], "description": "This virtual table provides the minimum salary for each department from the 'employees' table. The placeholder in the SELECT clause represents the salary values, while the GROUP BY clause organizes the results by department identifier.", "virtual_table": "SELECT MIN(salary) ,  department_id FROM employees GROUP BY department_id"}
{"sample_id": "train.3408", "db_id": "hr_1", "question": "What are the full names and salaries for any employees earning less than 6000?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Select the columns to display: 'first_name', 'last_name', and 'salary'.", "Add a condition to filter the 'salary' column for employees earning less than the specified amount using a placeholder for numeric values."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees WHERE salary  <  6000", "source_tables": ["employees"], "description": "This virtual table describes the first names, last names, and salaries of employees from the 'employees' table who earn less than a specified salary. The placeholder in the WHERE clause represents the salary threshold.", "virtual_table": "SELECT first_name ,  last_name ,  salary FROM employees WHERE salary  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3447", "db_id": "hr_1", "question": "display the employee ID for each employee and the date on which he ended his previous job.", "rationale": ["The query identifies the relevant table, which is 'job_history'.", "Select the column 'employee_id' to display the unique identifier for each employee.", "Use the MAX function to find the latest 'end_date' for each employee's job history.", "Group the results by 'employee_id' to ensure that we get the most recent end date for each employee."], "gold_sql": "SELECT employee_id ,  MAX(end_date) FROM job_history GROUP BY employee_id", "source_tables": ["job_history"], "description": "This virtual table provides a summary of the most recent job end dates for each employee from the 'job_history' table. The placeholder in the SELECT clause represents the employee's unique identifier, while the MAX function is used to retrieve the latest end date for each employee's job history.", "virtual_table": "SELECT employee_id ,  MAX(end_date) FROM job_history GROUP BY employee_id"}
{"sample_id": "train.3432", "db_id": "hr_1", "question": "What are the full names of employees who with in department 70 or 90?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Select the columns to display, 'first_name' and 'last_name'.", "Add a condition to filter the 'department_id' column for the specified department IDs using placeholders for numeric values."], "gold_sql": "SELECT first_name ,  last_name FROM employees WHERE department_id  =  70 OR department_id  =  90", "source_tables": ["employees"], "description": "This virtual table describes the first and last names of employees from the 'employees' table who belong to specific departments identified by their department IDs. The placeholders in the WHERE clause represent the department IDs to filter the employees accordingly.", "virtual_table": "SELECT first_name ,  last_name FROM employees WHERE department_id  =  [PLACEHOLDER-TYPE:NUMBER] OR department_id  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3464", "db_id": "hr_1", "question": "Give the name of each department and the number of employees in each.", "rationale": ["The query identifies the relevant tables, which are 'employees' and 'departments'.", "It uses a JOIN operation to link the two tables based on the 'department_id'.", "The SELECT statement retrieves the 'department_name' from the 'departments' table and counts the number of employees in each department.", "The GROUP BY clause is used to aggregate the results by 'department_name', allowing for a count of employees per department."], "gold_sql": "SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name", "source_tables": ["employees", "departments"], "description": "This virtual table summarizes the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT statement represents the department's name, while the COUNT function calculates the total number of employees per department.", "virtual_table": "SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name"}
{"sample_id": "train.3518", "db_id": "hr_1", "question": "What are the full names, departments, cities, and state provinces for each employee?", "rationale": ["The query identifies the relevant tables: 'employees', 'departments', and 'locations'.", "It selects the columns to display: 'first_name' and 'last_name' from 'employees', 'department_name' from 'departments', and 'city' and 'state_province' from 'locations'.", "The JOIN operations link the 'employees' table to the 'departments' table using 'department_id', and then link the 'departments' table to the 'locations' table using 'location_id' to gather all necessary information."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T2.department_name ,  T3.city ,  T3.state_province FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id", "source_tables": ["employees", "departments", "locations"], "description": "This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.", "virtual_table": "SELECT T1.first_name ,  T1.last_name ,  T2.department_name ,  T3.city ,  T3.state_province FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id"}
{"sample_id": "train.3471", "db_id": "hr_1", "question": "return the smallest salary for every departments.", "rationale": ["The query identifies the relevant table, which is 'employees'.", "It selects the minimum salary and groups the results by department identifier.", "The use of MIN(salary) allows for the aggregation of salary data to find the lowest salary in each department."], "gold_sql": "SELECT MIN(salary) ,  department_id FROM employees GROUP BY department_id", "source_tables": ["employees"], "description": "This virtual table provides the minimum salary for each department from the 'employees' table. The placeholder in the SELECT clause represents the salary values, while the GROUP BY clause organizes the results by department identifier.", "virtual_table": "SELECT MIN(salary) ,  department_id FROM employees GROUP BY department_id"}
{"sample_id": "train.3524", "db_id": "hr_1", "question": "What the full names, ids of each employee and the name of the country they are in?", "rationale": ["The query identifies the relevant tables: 'employees', 'departments', 'locations', and 'countries'.", "It selects the 'first_name', 'last_name', and 'employee_id' from the 'employees' table (aliased as T1).", "It joins the 'departments' table (T2) on the 'department_id' to associate employees with their departments.", "It further joins the 'locations' table (T3) on 'location_id' to link departments to their locations.", "Finally, it joins the 'countries' table (T4) on 'country_id' to retrieve the country names associated with the locations."], "gold_sql": "SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id", "source_tables": ["countries", "employees", "departments", "locations"], "description": "This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.", "virtual_table": "SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id"}
{"sample_id": "train.3481", "db_id": "hr_1", "question": "get the details of employees who manage a department.", "rationale": ["The query identifies the relevant tables, which are 'employees' and 'departments'.", "It uses a JOIN operation to combine these tables based on the condition that the 'department_id' in the employees table matches the 'department_id' in the departments table.", "The WHERE clause filters the results to include only those employees whose 'employee_id' is equal to the 'manager_id' in the departments table.", "The SELECT DISTINCT statement ensures that the results do not contain duplicate entries."], "gold_sql": "SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T1.employee_id  =  T2.manager_id", "source_tables": ["employees", "departments"], "description": "This virtual table provides a list of employees who are also managers in their respective departments. It combines data from the 'employees' and 'departments' tables, ensuring that only those employees whose 'employee_id' matches the 'manager_id' of their department are included. The use of DISTINCT ensures that duplicate records are eliminated, providing a unique list of such employees.", "virtual_table": "SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T1.employee_id  =  T2.manager_id"}
{"sample_id": "train.3498", "db_id": "hr_1", "question": "What are the ids for employees who do not work in departments with managers that have ids between 100 and 200?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "It selects all columns from the 'employees' table.", "A condition is added to filter out department IDs that are linked to manager IDs within a specified numeric range using placeholders."], "gold_sql": "SELECT * FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN 100 AND 200)", "source_tables": ["employees", "departments"], "description": "This virtual table retrieves all employee records from the 'employees' table where the department ID does not fall within a specified range of manager IDs. The placeholders in the query represent numeric values for the range of manager IDs to filter out departments managed by those IDs.", "virtual_table": "SELECT * FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.3497", "db_id": "hr_1", "question": "Find the ids of the employees who does not work in those departments where some employees works whose manager id within the range 100 and 200.", "rationale": ["The query identifies the relevant table, which is 'employees'.", "It selects all columns from the 'employees' table.", "A condition is added to filter out department IDs that are managed by managers whose IDs fall within a specified numeric range, using a subquery to select those department IDs from the 'departments' table."], "gold_sql": "SELECT * FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN 100 AND 200)", "source_tables": ["employees", "departments"], "description": "This virtual table retrieves all employee records from the 'employees' table where the department ID does not fall within a specified range of manager IDs. The placeholders in the query represent numeric values for the range of manager IDs to filter out departments managed by those IDs.", "virtual_table": "SELECT * FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.3466", "db_id": "hr_1", "question": "What is all the job history info done by employees earning a salary greater than or equal to 12000?", "rationale": ["The query identifies the relevant tables, which are 'job_history' and 'employees'.", "It selects all columns from the joined tables using the wildcard '*'.", "The JOIN condition links the 'employee_id' from 'job_history' to 'employees', ensuring we get the correct employee data for each job history record.", "A condition is added to filter employees based on their salary, using a placeholder for numeric values."], "gold_sql": "SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  12000", "source_tables": ["job_history", "employees"], "description": "This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary to filter the results.", "virtual_table": "SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2619", "db_id": "inn_1", "question": "How many rooms have king beds? Report the number for each decor type.", "rationale": ["The query identifies the relevant table, which is 'Rooms'.", "Select the 'decor' column and count the number of rooms for each decor style.", "Add a condition to filter the 'bedType' column for the specified bed type using a placeholder for string values.", "Group the results by the 'decor' column to get the count of rooms for each decor style."], "gold_sql": "SELECT decor ,  count(*) FROM Rooms WHERE bedType = 'King' GROUP BY decor;", "source_tables": ["rooms"], "description": "This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the bed type being queried.", "virtual_table": "SELECT decor ,  count(*) FROM Rooms WHERE bedType = [PLACEHOLDER-TYPE:STRING] GROUP BY decor;"}
{"sample_id": "train.2591", "db_id": "inn_1", "question": "What are the names and decor of rooms with a king bed? Sort them by their price", "rationale": ["The query identifies the relevant table, which is 'Rooms'.", "Select the columns to display, 'roomName' and 'decor'.", "Add a condition to filter the 'bedType' column for the specified bed type using a placeholder for string values.", "Order the results by 'basePrice' to sort the rooms based on their pricing."], "gold_sql": "SELECT roomName ,  decor FROM Rooms WHERE bedtype  =  'King' ORDER BY basePrice;", "source_tables": ["rooms"], "description": "This virtual table provides the names and decor descriptions of rooms from the 'Rooms' table that have a specific type of bed. The results are ordered by the base price of the rooms. The placeholder in the WHERE clause represents the type of bed being queried.", "virtual_table": "SELECT roomName ,  decor FROM Rooms WHERE bedtype  =  [PLACEHOLDER-TYPE:STRING] ORDER BY basePrice;"}
{"sample_id": "train.2638", "db_id": "inn_1", "question": "Return the name and number of reservations made for each of the rooms.", "rationale": ["The query identifies the relevant tables, 'Reservations' and 'Rooms', and uses a JOIN to combine them based on the room identifier.", "It selects the 'roomName' from the 'Rooms' table and counts the number of reservations for each room from the 'Reservations' table.", "The GROUP BY clause is used to aggregate the results by room, allowing for a count of reservations per room."], "gold_sql": "SELECT T2.roomName ,  count(*) ,  T1.Room FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room", "source_tables": ["rooms", "reservations"], "description": "This virtual table provides a summary of room reservations, showing the room names along with the count of reservations for each room. The placeholders in the query allow for dynamic filtering based on room identifiers.", "virtual_table": "SELECT T2.roomName ,  count(*) ,  T1.Room FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room"}
{"sample_id": "train.2618", "db_id": "inn_1", "question": "Find the number of rooms with king bed for each decor type.", "rationale": ["The query identifies the relevant table, which is 'Rooms'.", "Select the 'decor' column and count the number of rooms using count(*).", "Add a condition to filter the 'bedType' column for the specified bed type using a placeholder for string values.", "Group the results by the 'decor' column to aggregate the count of rooms with the same decor."], "gold_sql": "SELECT decor ,  count(*) FROM Rooms WHERE bedType = 'King' GROUP BY decor;", "source_tables": ["rooms"], "description": "This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the type of bed being queried.", "virtual_table": "SELECT decor ,  count(*) FROM Rooms WHERE bedType = [PLACEHOLDER-TYPE:STRING] GROUP BY decor;"}
{"sample_id": "train.2579", "db_id": "inn_1", "question": "Find the number of kids staying in the rooms reserved by a person called ROY SWEAZ.", "rationale": ["The query identifies the relevant table, which is 'Reservations'.", "Select the column to display, 'Kids'.", "Add conditions to filter the 'FirstName' and 'LastName' columns for the specified guest using placeholders for string values."], "gold_sql": "SELECT kids FROM Reservations WHERE FirstName = 'ROY' AND LastName  =  'SWEAZY';", "source_tables": ["reservations"], "description": "This virtual table provides the number of kids associated with reservations made by a specific guest. The placeholders in the WHERE clause represent the first and last names of the guest.", "virtual_table": "SELECT kids FROM Reservations WHERE FirstName = [PLACEHOLDER-TYPE:STRING] AND LastName  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.2629", "db_id": "inn_1", "question": "What are the names of rooms that have either king or queen bed?", "rationale": ["The query is identifying the relevant table, which is 'Rooms'.", "Select the column to display, 'roomName'.", "Add a condition to filter the 'bedType' column for the specified types of beds using placeholders for string values. The condition allows for multiple bed types using the OR operator."], "gold_sql": "SELECT roomName FROM Rooms WHERE bedType  =  'King' OR bedType  =  'Queen';", "source_tables": ["rooms"], "description": "This virtual table describes the names of rooms from the 'Rooms' table that have specific types of beds available. The placeholders in the WHERE clause represent the types of beds that the user is interested in.", "virtual_table": "SELECT roomName FROM Rooms WHERE bedType  =  [PLACEHOLDER-TYPE:STRING] OR bedType  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.2605", "db_id": "inn_1", "question": "What are the first and last names of people who payed more than the rooms' base prices?", "rationale": ["The query identifies the relevant tables, which are 'Reservations' and 'Rooms'.", "It selects the columns to display, 'firstname' and 'lastname' from the 'Reservations' table.", "A JOIN operation is performed on the 'Room' column from 'Reservations' and 'RoomId' from 'Rooms' to link the two tables.", "A condition is added to filter the results where the difference between the 'Rate' from 'Reservations' and 'basePrice' from 'Rooms' is greater than a specified numeric value using a placeholder."], "gold_sql": "SELECT T1.firstname ,  T1.lastname FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T1.Rate - T2.basePrice  >  0", "source_tables": ["rooms", "reservations"], "description": "This virtual table provides the first and last names of guests from the 'Reservations' table who have a reservation rate that exceeds the base price of the room they booked. The placeholder in the WHERE clause represents the difference in price that is being queried.", "virtual_table": "SELECT T1.firstname ,  T1.lastname FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T1.Rate - T2.basePrice  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2601", "db_id": "inn_1", "question": "What is the least popular kind of decor?", "rationale": ["The query identifies the relevant tables, 'Reservations' and 'Rooms', and establishes a join between them based on the room identifier.", "It selects the 'decor' column from the 'Rooms' table, which describes the room's decor.", "The results are grouped by the 'decor' column to aggregate similar decorations.", "The results are ordered in ascending order based on the count of each decoration type, allowing for the least common decorations to appear first.", "A limit is applied to restrict the number of results returned, with a placeholder for the user to specify the desired number."], "gold_sql": "SELECT T2.decor FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T2.decor ORDER BY count(T2.decor) ASC LIMIT 1;", "source_tables": ["rooms", "reservations"], "description": "This virtual table provides a list of room decorations from the 'Rooms' table that have been reserved, grouped by the decoration type. The placeholder in the LIMIT clause allows for specifying the maximum number of decoration types to return.", "virtual_table": "SELECT T2.decor FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T2.decor ORDER BY count(T2.decor) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.2600", "db_id": "inn_1", "question": "What kind of decor has the least number of reservations?", "rationale": ["The query identifies the relevant tables, 'Reservations' and 'Rooms', and establishes a join between them using the foreign key relationship where 'Reservations.Room' matches 'Rooms.RoomId'.", "It selects the 'decor' column from the 'Rooms' table, which describes the room's decor.", "The results are grouped by the 'decor' to aggregate the data based on the type of decor.", "The results are ordered by the count of each decor type in ascending order to show the least reserved decor types first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T2.decor FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T2.decor ORDER BY count(T2.decor) ASC LIMIT 1;", "source_tables": ["rooms", "reservations"], "description": "This virtual table provides a list of room decorations from the 'Rooms' table that have been reserved, grouped by their decor type. The results are ordered by the count of reservations for each decor type in ascending order, with a limit on the number of results returned based on a specified number.", "virtual_table": "SELECT T2.decor FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T2.decor ORDER BY count(T2.decor) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.2588", "db_id": "inn_1", "question": "How many king beds are there?", "rationale": ["The query identifies the relevant table, which is 'Rooms'.", "It selects the sum of the 'beds' column to calculate the total number of beds.", "A condition is added to filter the results based on the 'bedType' column using a placeholder for string values."], "gold_sql": "SELECT sum(beds) FROM Rooms WHERE bedtype  =  'King';", "source_tables": ["rooms"], "description": "This virtual table calculates the total number of beds available in rooms of a specific bed type from the 'Rooms' table. The placeholder in the WHERE clause represents the type of bed being queried.", "virtual_table": "SELECT sum(beds) FROM Rooms WHERE bedtype  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.2615", "db_id": "inn_1", "question": "Which room has the highest base price?", "rationale": ["The query identifies the relevant table, which is 'Rooms'.", "Select the columns to display, 'RoomId' and 'roomName'.", "Sort the results by 'basePrice' in descending order to show the most expensive rooms first.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT RoomId ,  roomName FROM Rooms ORDER BY basePrice DESC LIMIT 1;", "source_tables": ["rooms"], "description": "This virtual table provides a list of room identifiers and their names from the 'Rooms' table, sorted by the base price in descending order. The placeholder in the LIMIT clause represents the maximum number of rooms to be displayed.", "virtual_table": "SELECT RoomId ,  roomName FROM Rooms ORDER BY basePrice DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.2608", "db_id": "inn_1", "question": "Find the number of rooms with a king bed.", "rationale": ["The query identifies the relevant table, which is 'Rooms'.", "It selects the count of all rooms that match a specific condition.", "A condition is added to filter the 'bedType' column for the specified type of bed using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM Rooms WHERE bedType  =  'King';", "source_tables": ["rooms"], "description": "This virtual table provides the count of rooms from the 'Rooms' table that have a specific type of bed. The placeholder in the WHERE clause represents the type of bed being queried.", "virtual_table": "SELECT count(*) FROM Rooms WHERE bedType  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.2602", "db_id": "inn_1", "question": "List how many times the number of people in the room reached the maximum occupancy of the room. The number of people include adults and kids.", "rationale": ["The query identifies the relevant tables, which are 'Reservations' and 'Rooms'.", "It performs a join operation on the 'Room' column from 'Reservations' and 'RoomId' from 'Rooms' to link the two tables.", "The condition in the WHERE clause checks if the sum of 'Adults' and 'Kids' in the reservation equals the 'maxOccupancy' of the room, ensuring that only valid reservations are counted."], "gold_sql": "SELECT count(*) FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T2.maxOccupancy  =  T1.Adults + T1.Kids;", "source_tables": ["rooms", "reservations"], "description": "This virtual table provides a count of reservations where the total number of occupants (adults and kids) matches the maximum occupancy allowed for each room. It joins the 'Reservations' table with the 'Rooms' table based on the room identifier, ensuring that only those reservations that meet the occupancy criteria are counted.", "virtual_table": "SELECT count(*) FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T2.maxOccupancy  =  T1.Adults + T1.Kids;"}
{"sample_id": "train.1536", "db_id": "insurance_and_eClaims", "question": "What are the names of the customers and staff members?", "rationale": ["The query is identifying the relevant tables, which are 'Customers' and 'Staff'.", "Using the UNION operator to combine results from both tables.", "Selecting the 'Customer_Details' from the 'Customers' table and 'Staff_Details' from the 'Staff' table to provide a unified view of details from both entities."], "gold_sql": "SELECT customer_details FROM customers UNION SELECT staff_details FROM staff", "source_tables": ["staff", "customers"], "description": "This virtual table combines detailed information about customers and staff members from the 'Customers' and 'Staff' tables. The placeholder in the SELECT statement allows for the retrieval of customer details and staff details, providing a comprehensive view of both entities.", "virtual_table": "SELECT customer_details FROM customers UNION SELECT staff_details FROM staff"}
{"sample_id": "train.1535", "db_id": "insurance_and_eClaims", "question": "Find the names of all the customers and staff members.", "rationale": ["The query is identifying the relevant tables, which are 'Customers' and 'Staff'.", "Using the UNION operator to combine results from both tables.", "Selecting the 'Customer_Details' from the 'Customers' table and 'Staff_Details' from the 'Staff' table to provide a unified view of details from both entities."], "gold_sql": "SELECT customer_details FROM customers UNION SELECT staff_details FROM staff", "source_tables": ["staff", "customers"], "description": "This virtual table combines detailed information about customers and staff members from the 'Customers' and 'Staff' tables. The placeholder in the SELECT clause allows for the retrieval of customer details and staff details, respectively.", "virtual_table": "SELECT customer_details FROM customers UNION SELECT staff_details FROM staff"}
{"sample_id": "train.1517", "db_id": "insurance_and_eClaims", "question": "Find the total amount claimed in the most recently created document.", "rationale": ["The query identifies the relevant tables, 'Claim_Headers' and 'Claims_Documents'.", "It uses a JOIN to link the claims with their corresponding documents based on the claim ID.", "The SUM function is used to calculate the total amount claimed from the 'Claim_Headers' table.", "A subquery is included to filter the documents based on their creation date, with a placeholder for limiting the selection of dates."], "gold_sql": "SELECT sum(t1.amount_claimed) FROM claim_headers AS t1 JOIN claims_documents AS t2 ON t1.claim_header_id  =  t2.claim_id WHERE t2.created_date  =  (SELECT created_date FROM claims_documents ORDER BY created_date LIMIT 1)", "source_tables": ["claims_documents", "claim_headers"], "description": "This virtual table calculates the total amount claimed from the 'Claim_Headers' table for claims that have associated documents created on a specific date. The placeholder in the subquery represents the limit for selecting the created date of the documents.", "virtual_table": "SELECT sum(t1.amount_claimed) FROM claim_headers AS t1 JOIN claims_documents AS t2 ON t1.claim_header_id  =  t2.claim_id WHERE t2.created_date  =  (SELECT created_date FROM claims_documents ORDER BY created_date LIMIT [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.1528", "db_id": "insurance_and_eClaims", "question": "Which claim processing stage has the most claims? Show the claim status name.", "rationale": ["The query identifies the relevant tables, which are 'claims_processing' and 'claims_processing_stages'.", "It selects the 'claim_status_name' from the 'claims_processing_stages' table.", "A JOIN operation is performed on the 'claim_stage_id' to link the two tables together.", "The results are grouped by 'claim_stage_id' to aggregate the data appropriately.", "The results are ordered by the count of occurrences in descending order to prioritize the most common statuses.", "A placeholder is included to allow the user to specify the limit on the number of statuses returned."], "gold_sql": "SELECT t2.claim_status_name FROM claims_processing AS t1 JOIN claims_processing_stages AS t2 ON t1.claim_stage_id  =  t2.claim_stage_id GROUP BY t1.claim_stage_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["claims_processing", "claims_processing_stages"], "description": "This virtual table provides a summary of the claim statuses from the claims processing stages. It retrieves the names of the claim statuses by joining the 'claims_processing' table with the 'claims_processing_stages' table based on the claim stage identifier. The results are grouped by the claim stage identifier and ordered by the count of occurrences in descending order, allowing the user to specify a limit on the number of statuses returned.", "virtual_table": "SELECT t2.claim_status_name FROM claims_processing AS t1 JOIN claims_processing_stages AS t2 ON t1.claim_stage_id  =  t2.claim_stage_id GROUP BY t1.claim_stage_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1527", "db_id": "insurance_and_eClaims", "question": "What is the name of the claim processing stage that most of the claims are on?", "rationale": ["The query identifies the relevant tables, which are 'claims_processing' and 'claims_processing_stages'.", "It selects the 'claim_status_name' from the 'claims_processing_stages' table.", "A JOIN operation is performed on the 'claim_stage_id' to link the two tables together.", "The results are grouped by 'claim_stage_id' to aggregate the data appropriately.", "The results are ordered by the count of occurrences in descending order to prioritize the most common statuses.", "A placeholder is included to allow the user to specify the limit on the number of statuses returned."], "gold_sql": "SELECT t2.claim_status_name FROM claims_processing AS t1 JOIN claims_processing_stages AS t2 ON t1.claim_stage_id  =  t2.claim_stage_id GROUP BY t1.claim_stage_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["claims_processing", "claims_processing_stages"], "description": "This virtual table provides a summary of the claim statuses from the claims processing stages. It retrieves the names of the claim statuses by joining the 'claims_processing' table with the 'claims_processing_stages' table based on the claim stage identifier. The results are grouped by the claim stage identifier and ordered by the count of occurrences in descending order, allowing the user to specify a limit on the number of statuses returned.", "virtual_table": "SELECT t2.claim_status_name FROM claims_processing AS t1 JOIN claims_processing_stages AS t2 ON t1.claim_stage_id  =  t2.claim_stage_id GROUP BY t1.claim_stage_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1545", "db_id": "insurance_and_eClaims", "question": "Which customer is associated with the latest policy?", "rationale": ["The query identifies the relevant tables, which are 'Policies' and 'Customers'.", "It selects the 'Customer_Details' from the 'Customers' table.", "A JOIN operation is performed on 'Policies' and 'Customers' using the 'Customer_ID' to link them.", "A subquery is used to find the maximum 'Start_Date' from the 'Policies' table to filter for the most recent policy."], "gold_sql": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)", "source_tables": ["policies", "customers"], "description": "This virtual table retrieves the detailed information about customers from the 'Customers' table who have the most recently started insurance policy from the 'Policies' table. The query uses a subquery to find the maximum start date of policies, ensuring that only the latest policy is considered.", "virtual_table": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)"}
{"sample_id": "train.1522", "db_id": "insurance_and_eClaims", "question": "Which customer made the smallest amount of claim in one claim? Return the customer details.", "rationale": ["The query identifies the relevant tables: 'Claim_Headers', 'Policies', and 'Customers'.", "It selects the 'Customer_Details' from the 'Customers' table.", "The join conditions link 'Claim_Headers' to 'Policies' via 'Policy_ID', and 'Policies' to 'Customers' via 'Customer_ID'.", "A subquery is used to find the minimum 'Amount_Piad' from 'Claim_Headers' to filter the results."], "gold_sql": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)", "source_tables": ["policies", "customers", "claim_headers"], "description": "This virtual table retrieves the detailed information about customers associated with the claim that has the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to policies, and then joins with the 'Customers' table to get customer details. The query filters for the claim with the lowest amount paid using a subquery.", "virtual_table": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)"}
{"sample_id": "train.1515", "db_id": "insurance_and_eClaims", "question": "Find the total and average amount paid in claim headers.", "rationale": ["The query identifies the relevant table, which is 'Claim_Headers'.", "It selects the sum and average of the 'amount_paid' column to provide a summary of the payments made for claims."], "gold_sql": "SELECT sum(amount_piad) ,  avg(amount_piad) FROM claim_headers", "source_tables": ["claim_headers"], "description": "This virtual table summarizes the total and average amounts paid for claims from the 'Claim_Headers' table. The placeholders in the SELECT clause represent the total and average of the 'amount_paid' column.", "virtual_table": "SELECT sum(amount_piad) ,  avg(amount_piad) FROM claim_headers"}
{"sample_id": "train.900", "db_id": "insurance_fnol", "question": "Find the policy types more than 4 customers use. Show their type code.", "rationale": ["The query identifies the relevant table, which is 'Available_Policies'.", "It selects the 'policy_type_code' column to display unique policy types.", "The GROUP BY clause is used to group the results by 'policy_type_code'.", "The HAVING clause filters the groups to include only those with a count greater than a specified number, using a placeholder for numeric values."], "gold_sql": "SELECT policy_type_code FROM available_policies GROUP BY policy_type_code HAVING count(*)  >  4", "source_tables": ["available_policies"], "description": "This virtual table provides a list of unique policy types from the 'Available_Policies' table that have been issued more than a specified number of times. The placeholder in the HAVING clause represents the minimum count of policies required to be included in the results.", "virtual_table": "SELECT policy_type_code FROM available_policies GROUP BY policy_type_code HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.899", "db_id": "insurance_fnol", "question": "Find the policy type used by more than 4 customers.", "rationale": ["The query identifies the relevant table, which is 'Available_Policies'.", "It selects the 'policy_type_code' to display unique policy types.", "The GROUP BY clause is used to group the results by 'policy_type_code'.", "The HAVING clause filters the groups to include only those with a count greater than a specified number, using a placeholder for numeric values."], "gold_sql": "SELECT policy_type_code FROM available_policies GROUP BY policy_type_code HAVING count(*)  >  4", "source_tables": ["available_policies"], "description": "This virtual table summarizes the unique policy types from the 'Available_Policies' table that have been issued more than a specified number of times. The placeholder in the HAVING clause represents the minimum count of policies required to be included in the results.", "virtual_table": "SELECT policy_type_code FROM available_policies GROUP BY policy_type_code HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.930", "db_id": "insurance_fnol", "question": "What is the ordered list of customer ids?", "rationale": ["The query identifies the relevant table, which is 'Customers'.", "Select the columns to display, 'customer_id' and 'customer_name'.", "Add an ORDER BY clause to sort the results by 'customer_id' in ascending order."], "gold_sql": "SELECT customer_id ,  customer_name FROM customers ORDER BY customer_id ASC", "source_tables": ["customers"], "description": "This virtual table provides a list of customer IDs and their corresponding names from the 'Customers' table, sorted in ascending order by customer ID. The placeholders represent the customer identifiers and names.", "virtual_table": "SELECT customer_id ,  customer_name FROM customers ORDER BY customer_id ASC"}
{"sample_id": "train.896", "db_id": "insurance_fnol", "question": "Which policy type appears most frequently in the available policies?", "rationale": ["The query identifies the relevant table, which is 'Available_Policies'.", "It selects the 'policy_type_code' column to display the types of policies.", "The query groups the results by 'policy_type_code' to aggregate similar types together.", "It orders the grouped results by the count of occurrences in descending order to show the most common types first.", "The LIMIT clause is used to restrict the number of results returned, with a placeholder for the maximum number of types to display."], "gold_sql": "SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["available_policies"], "description": "This virtual table summarizes the different types of insurance policies available in the 'Available_Policies' table. It groups the policies by their type code and orders them by the number of occurrences, allowing users to see the most common policy types. The placeholder in the LIMIT clause represents the maximum number of policy types to return.", "virtual_table": "SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.894", "db_id": "insurance_fnol", "question": "What are the phone numbers of customers using the policy with the code \"Life Insurance\"?", "rationale": ["The query identifies the relevant table, which is 'Available_Policies'.", "Select the column to display, 'Customer_Phone'.", "Add a condition to filter the 'policy_type_code' column for the specified policy type using a placeholder for string values."], "gold_sql": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  'Life Insurance'", "source_tables": ["available_policies"], "description": "This virtual table provides the contact phone numbers of customers from the 'Available_Policies' table who have a specific type of insurance policy. The placeholder in the WHERE clause represents the policy type code.", "virtual_table": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3894", "db_id": "insurance_policies", "question": "List the date the claim was made, the date it was settled and the amount settled for all the claims which had exactly one settlement.", "rationale": ["The query identifies the relevant tables, which are 'Claims' and 'Settlements'.", "It selects the 'claim_id', 'date_claim_made', and 'Date_Claim_Settled' from the 'Claims' table, aliased as T1.", "A JOIN operation is performed between 'Claims' (T1) and 'Settlements' (T2) on the 'Claim_id' to link claims with their settlements.", "The results are grouped by 'claim_id' to aggregate the data for each claim.", "The HAVING clause filters the results to include only those claims that have a specific number of associated settlements, using a placeholder for numeric values."], "gold_sql": "SELECT T1.claim_id ,  T1.date_claim_made ,  T1.Date_Claim_Settled FROM Claims AS T1 JOIN Settlements AS T2 ON T1.Claim_id  =  T2.Claim_id GROUP BY T1.claim_id HAVING count(*)  =  1", "source_tables": ["claims", "settlements"], "description": "This virtual table provides a summary of claims and their settlement dates from the 'Claims' table, specifically focusing on claims that have a certain number of associated settlements. The placeholders in the HAVING clause represent the count of settlements that must match for the claims to be included in the results.", "virtual_table": "SELECT T1.claim_id ,  T1.date_claim_made ,  T1.Date_Claim_Settled FROM Claims AS T1 JOIN Settlements AS T2 ON T1.Claim_id  =  T2.Claim_id GROUP BY T1.claim_id HAVING count(*)  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3861", "db_id": "insurance_policies", "question": "Give me the claim date, settlement date for all the claims whose claimed amount is larger than the average.", "rationale": ["The query identifies the relevant table, which is 'Claims'.", "Select the columns to display, 'Date_Claim_Made' and 'Date_Claim_Settled'.", "Add a condition to filter the claims where 'Amount_Claimed' is greater than the average amount claimed, using a subquery to calculate the average."], "gold_sql": "SELECT Date_Claim_Made ,  Date_Claim_Settled FROM Claims WHERE Amount_Claimed  >  ( SELECT avg(Amount_Claimed) FROM Claims )", "source_tables": ["claims"], "description": "This virtual table provides the dates when claims were made and settled from the 'Claims' table for those claims where the amount claimed exceeds the average amount claimed across all claims. The placeholder in the WHERE clause represents a condition based on the average amount claimed.", "virtual_table": "SELECT Date_Claim_Made ,  Date_Claim_Settled FROM Claims WHERE Amount_Claimed  >  ( SELECT avg(Amount_Claimed) FROM Claims )"}
{"sample_id": "train.3864", "db_id": "insurance_policies", "question": "How many settlements does each claim correspond to? List the claim id and the number of settlements.", "rationale": ["The query identifies the relevant tables, which are 'Claims' and 'Settlements'.", "It selects the 'Claim_ID' from the 'Claims' table and counts the number of associated records in the 'Settlements' table.", "A JOIN operation is performed on the 'Claim_ID' to link claims with their corresponding settlements.", "The results are grouped by 'Claim_ID' to provide a count for each unique claim."], "gold_sql": "SELECT T1.Claim_id ,  count(*) FROM Claims AS T1 JOIN Settlements AS T2 ON T1.claim_id  =  T2.claim_id GROUP BY T1.claim_id", "source_tables": ["claims", "settlements"], "description": "This virtual table provides a count of settlements associated with each insurance claim from the 'Claims' table. The placeholder in the SELECT statement represents the unique identifier for each claim, while the count reflects the number of settlements linked to that claim.", "virtual_table": "SELECT T1.Claim_id ,  count(*) FROM Claims AS T1 JOIN Settlements AS T2 ON T1.claim_id  =  T2.claim_id GROUP BY T1.claim_id"}
{"sample_id": "train.3881", "db_id": "insurance_policies", "question": "What is the payment method that were used the least often?", "rationale": ["The query identifies the relevant table, which is 'Payments'.", "It selects the 'Payment_Method_Code' column to display unique payment methods.", "The GROUP BY clause is used to group the results by 'Payment_Method_Code'.", "The ORDER BY clause sorts the grouped results by their count in ascending order.", "The LIMIT clause uses a placeholder to allow the user to specify how many unique payment methods to return."], "gold_sql": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) ASC LIMIT 1", "source_tables": ["payments"], "description": "This virtual table provides a list of unique payment method codes used in the 'Payments' table, grouped by the method code and ordered by the frequency of each method in ascending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of payment methods to retrieve.", "virtual_table": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3859", "db_id": "insurance_policies", "question": "Find the claimed amount in the claim with the least amount settled. Show both the settlement amount and claim amount.", "rationale": ["The query identifies the relevant table, which is 'Claims'.", "Selects the columns 'Amount_Settled' and 'Amount_Claimed' to display the financial details of the claims.", "Orders the results by 'Amount_Settled' in ascending order to show the smallest settled amounts first.", "Includes a limit on the number of records returned, using a placeholder for numeric values."], "gold_sql": "SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Settled ASC LIMIT 1", "source_tables": ["claims"], "description": "This virtual table provides a summary of the amounts settled and claimed for insurance claims from the 'Claims' table. The results are ordered by the settled amount in ascending order, and the placeholder allows for limiting the number of records returned.", "virtual_table": "SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Settled ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3858", "db_id": "insurance_policies", "question": "Among all the claims, what is the amount claimed in the claim with the least amount settled? List both the settlement amount and claim amount.", "rationale": ["The query identifies the relevant table, which is 'Claims'.", "Selects the columns 'Amount_Settled' and 'Amount_Claimed' to display the financial details of the claims.", "Orders the results by 'Amount_Settled' in ascending order to show the smallest settled amounts first.", "Includes a limit on the number of records returned, using a placeholder for numeric values."], "gold_sql": "SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Settled ASC LIMIT 1", "source_tables": ["claims"], "description": "This virtual table provides a summary of the amounts settled and claimed for insurance claims from the 'Claims' table. The results are ordered by the settled amount in ascending order, and the placeholder allows for limiting the number of records returned.", "virtual_table": "SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Settled ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3887", "db_id": "insurance_policies", "question": "Find the policy type the most customers choose.", "rationale": ["The query identifies the relevant table, which is 'Customer_Policies'.", "It selects the 'Policy_Type_Code' column to display the different types of insurance policies.", "The query groups the results by 'Policy_Type_Code' to aggregate the data based on policy types.", "It orders the results by the count of each policy type in descending order to show the most common types first.", "The LIMIT clause uses a placeholder to allow the user to specify how many policy types to return."], "gold_sql": "SELECT Policy_Type_Code FROM Customer_Policies GROUP BY Policy_Type_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customer_policies"], "description": "This virtual table summarizes the different types of insurance policies from the 'Customer_Policies' table, grouping them by their policy type code. The placeholder in the LIMIT clause allows the user to specify the maximum number of policy types to retrieve, sorted by the frequency of each type in descending order.", "virtual_table": "SELECT Policy_Type_Code FROM Customer_Policies GROUP BY Policy_Type_Code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3856", "db_id": "insurance_policies", "question": "Among all the claims, what is the settlement amount of the claim with the largest claim amount? List both the settlement amount and claim amount.", "rationale": ["The query identifies the relevant table, which is 'Claims'.", "Selects the columns 'Amount_Settled' and 'Amount_Claimed' to display the financial details of the claims.", "Orders the results by 'Amount_Claimed' in descending order to show the highest claims first.", "Includes a limit on the number of records returned, using a placeholder for numeric values."], "gold_sql": "SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Claimed DESC LIMIT 1", "source_tables": ["claims"], "description": "This virtual table provides a summary of the amounts claimed and settled for insurance claims from the 'Claims' table. The results are ordered by the claimed amount in descending order, and the placeholder allows for limiting the number of records returned.", "virtual_table": "SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Claimed DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3892", "db_id": "insurance_policies", "question": "List the details of the customers who do not have any policies.", "rationale": ["The query identifies the relevant table, which is 'Customers'.", "It selects the 'customer_details' column to display.", "The EXCEPT clause is used to exclude customer details that are linked to any policies by joining 'Customers' with 'Customer_Policies' on 'Customer_ID' to filter out those customers."], "gold_sql": "SELECT customer_details FROM Customers EXCEPT SELECT T1.customer_details FROM Customers AS T1 JOIN Customer_Policies AS T2 ON T1.customer_id  =  T2.customer_id", "source_tables": ["customer_policies", "customers"], "description": "This virtual table provides a list of customer details from the 'Customers' table, excluding those customers who have associated insurance policies. The query uses an EXCEPT clause to filter out customers that are linked to any policies in the 'Customer_Policies' table.", "virtual_table": "SELECT customer_details FROM Customers EXCEPT SELECT T1.customer_details FROM Customers AS T1 JOIN Customer_Policies AS T2 ON T1.customer_id  =  T2.customer_id"}
{"sample_id": "train.2257", "db_id": "machine_repair", "question": "Show names of technicians and the number of machines they are assigned to repair.", "rationale": ["The query identifies the relevant tables, which are 'repair_assignment' and 'technician'.", "It selects the 'Name' column from the 'technician' table and counts the number of assignments from the 'repair_assignment' table.", "A JOIN operation is performed on the technician's ID to link the two tables.", "The results are grouped by the technician's name to aggregate the count of assignments for each technician."], "gold_sql": "SELECT T2.Name ,  COUNT(*) FROM repair_assignment AS T1 JOIN technician AS T2 ON T1.technician_ID  =  T2.technician_ID GROUP BY T2.Name", "source_tables": ["repair_assignment", "technician"], "description": "This virtual table provides a summary of the number of repair assignments handled by each technician. It joins the 'repair_assignment' table with the 'technician' table to associate each assignment with the technician's name. The result is grouped by the technician's name, allowing for a count of assignments per technician.", "virtual_table": "SELECT T2.Name ,  COUNT(*) FROM repair_assignment AS T1 JOIN technician AS T2 ON T1.technician_ID  =  T2.technician_ID GROUP BY T2.Name"}
{"sample_id": "train.2262", "db_id": "machine_repair", "question": "What are the starting years shared by the technicians from the team \"CLE\" or \"CWS\"?", "rationale": ["The query identifies the relevant table, which is 'technician'.", "It selects the 'Starting_Year' column to display the years when technicians started working.", "The INTERSECT operator is used to find common starting years between technicians from two different teams, with placeholders for the team identifiers in the WHERE clause."], "gold_sql": "SELECT Starting_Year FROM technician WHERE Team  =  'CLE' INTERSECT SELECT Starting_Year FROM technician WHERE Team  =  'CWS'", "source_tables": ["technician"], "description": "This virtual table retrieves the starting years of technicians from the 'technician' table who belong to two specific teams. The placeholders in the WHERE clause represent the identifiers for the teams being compared.", "virtual_table": "SELECT Starting_Year FROM technician WHERE Team  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT Starting_Year FROM technician WHERE Team  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2247", "db_id": "machine_repair", "question": "Please show the team that has the most number of technicians.", "rationale": ["The query identifies the relevant table, which is 'technician'.", "It selects the 'Team' column to display the teams of technicians.", "The results are grouped by the 'Team' column to aggregate the data.", "The ordering is done based on the count of technicians in each team in descending order.", "A limit is applied to restrict the number of teams returned, using a placeholder for numeric values."], "gold_sql": "SELECT Team FROM technician GROUP BY Team ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["technician"], "description": "This virtual table provides a list of technician teams from the 'technician' table, grouped by their team identifier. The results are ordered by the number of technicians in each team in descending order, and the placeholder allows for limiting the number of teams returned.", "virtual_table": "SELECT Team FROM technician GROUP BY Team ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2256", "db_id": "machine_repair", "question": "What are the names of the technicians that are assigned to repair machines with more point values than 70?", "rationale": ["The query identifies the relevant tables: 'repair_assignment', 'machine', and 'technician'.", "It selects the 'Name' column from the 'technician' table, which represents the technicians' names.", "The JOIN operations link the 'repair_assignment' table with the 'machine' and 'technician' tables based on their respective identifiers.", "A condition is added to filter machines based on their 'value_points', using a placeholder for numeric values."], "gold_sql": "SELECT T3.Name FROM repair_assignment AS T1 JOIN machine AS T2 ON T1.machine_id  =  T2.machine_id JOIN technician AS T3 ON T1.technician_ID  =  T3.technician_ID WHERE T2.value_points  >  70", "source_tables": ["machine", "repair_assignment", "technician"], "description": "This virtual table lists the names of technicians who are assigned to repair tasks for machines that have a value point greater than a specified threshold. The placeholders in the WHERE clause represent the minimum value points for filtering the machines.", "virtual_table": "SELECT T3.Name FROM repair_assignment AS T1 JOIN machine AS T2 ON T1.machine_id  =  T2.machine_id JOIN technician AS T3 ON T1.technician_ID  =  T3.technician_ID WHERE T2.value_points  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2244", "db_id": "machine_repair", "question": "What is the starting year for the oldest technician?", "rationale": ["The query identifies the relevant table, which is 'technician'.", "Select the column to display, 'Starting_Year'.", "Order the results by the 'Age' column in descending order to show the oldest technicians first.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT Starting_Year FROM technician ORDER BY Age DESC LIMIT 1", "source_tables": ["technician"], "description": "This virtual table provides the starting years of technicians from the 'technician' table, ordered by their age in descending order. The placeholder in the LIMIT clause represents the maximum number of records to return.", "virtual_table": "SELECT Starting_Year FROM technician ORDER BY Age DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1108", "db_id": "match_season", "question": "Which college have both players with position midfielder and players with position defender?", "rationale": ["The query identifies the relevant table, which is 'match_season'.", "It selects the 'College' column to display the colleges attended by players.", "The INTERSECT operator is used to find common colleges attended by players in two different positions, with placeholders for the specified positions in the WHERE clause."], "gold_sql": "SELECT College FROM match_season WHERE POSITION  =  'Midfielder' INTERSECT SELECT College FROM match_season WHERE POSITION  =  'Defender'", "source_tables": ["match_season"], "description": "This virtual table retrieves the colleges attended by players who play in two specified positions during the match season. The placeholders in the WHERE clause represent the positions of the players being compared.", "virtual_table": "SELECT College FROM match_season WHERE POSITION  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT College FROM match_season WHERE POSITION  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1106", "db_id": "match_season", "question": "What are the names of countries that have both players with position forward and players with position defender?", "rationale": ["The query is identifying the relevant tables, which are 'country' and 'match_season'.", "It selects the 'Country_name' from the 'country' table.", "The join condition links the 'Country_id' from the 'country' table to the 'Country' in the 'match_season' table.", "The query filters the results based on the 'Position' of the players in the 'match_season' table using a placeholder for string values.", "The use of INTERSECT ensures that only countries with players in the specified position are included in the final result."], "gold_sql": "SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  'Forward' INTERSECT SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  'Defender'", "source_tables": ["country", "match_season"], "description": "This virtual table identifies the names of countries represented by players who occupy a specific position in matches. It uses an intersection to find countries where players in that position are participating in matches, ensuring that only countries with players in that position are returned. The placeholders in the query represent the position of the players being filtered.", "virtual_table": "SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1064", "db_id": "match_season", "question": "Show the draft pick numbers and draft classes of players whose positions are defenders.", "rationale": ["The query identifies the relevant table, which is 'match_season'.", "Select the columns to display, 'Draft_Pick_Number' and 'Draft_Class'.", "Add a condition to filter the 'Position' column for the specified position using a placeholder for string values."], "gold_sql": "SELECT Draft_Pick_Number ,  Draft_Class FROM match_season WHERE POSITION  =  'Defender'", "source_tables": ["match_season"], "description": "This virtual table provides information about the draft pick number and draft class of players from the 'match_season' table who play in a specific position. The placeholder in the WHERE clause represents the position of the player.", "virtual_table": "SELECT Draft_Pick_Number ,  Draft_Class FROM match_season WHERE POSITION  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1093", "db_id": "match_season", "question": "How many players are from each country?", "rationale": ["The query identifies the relevant tables, which are 'country' and 'match_season'.", "It selects the 'Country_name' from the 'country' table and counts the number of matches from the 'match_season' table.", "A JOIN operation is performed on the 'Country_id' from the 'country' table and the 'Country' from the 'match_season' table to link the data.", "The results are grouped by 'Country_name' to provide a count of matches for each country."], "gold_sql": "SELECT Country_name ,  COUNT(*) FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country GROUP BY T1.Country_name", "source_tables": ["country", "match_season"], "description": "This virtual table provides a count of matches played by players from each country, by joining the 'country' table with the 'match_season' table. The placeholder in the SELECT clause represents the country names, and the COUNT function aggregates the number of matches for each country.", "virtual_table": "SELECT Country_name ,  COUNT(*) FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country GROUP BY T1.Country_name"}
{"sample_id": "train.1073", "db_id": "match_season", "question": "For each player, what are their name, season, and country that they belong to?", "rationale": ["The query identifies the relevant tables, which are 'country' and 'match_season'.", "It selects the columns 'Season' and 'Player' from the 'match_season' table and 'Country_name' from the 'country' table.", "A JOIN operation is performed on the 'Country_id' from the 'country' table and the 'Country' from the 'match_season' table to link players with their countries."], "gold_sql": "SELECT T2.Season ,  T2.Player ,  T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country", "source_tables": ["country", "match_season"], "description": "This virtual table provides a list of match seasons along with the players participating in those seasons and their corresponding country names. The data is retrieved by joining the 'country' table with the 'match_season' table based on the country identifier, allowing us to associate each player with their respective country during a specific season.", "virtual_table": "SELECT T2.Season ,  T2.Player ,  T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country"}
{"sample_id": "train.1080", "db_id": "match_season", "question": "How many distinct official languages are there among countries of players whose positions are defenders.", "rationale": ["The query identifies the relevant tables, which are 'country' and 'match_season'.", "It uses a JOIN to connect the 'country' table with the 'match_season' table based on the country identifier.", "The SELECT statement counts the distinct values of the 'Official_native_language' column from the 'country' table.", "A condition is added to filter the results based on the player's position using a placeholder for string values."], "gold_sql": "SELECT count(DISTINCT T1.Official_native_language) FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  'Defender'", "source_tables": ["country", "match_season"], "description": "This virtual table counts the distinct official native languages of countries represented by players in a specific position during matches. The placeholder in the WHERE clause represents the player's position.", "virtual_table": "SELECT count(DISTINCT T1.Official_native_language) FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1083", "db_id": "match_season", "question": "Who are the different players, what season do they play in, and what is the name of the team they are on?", "rationale": ["The query identifies the relevant tables, 'match_season' and 'team'.", "It selects the columns 'Season' and 'Player' from the 'match_season' table (aliased as T1) and 'Name' from the 'team' table (aliased as T2).", "A JOIN operation is performed on the 'Team' column from 'match_season' and 'Team_id' from 'team' to link players with their teams."], "gold_sql": "SELECT T1.Season ,  T1.Player ,  T2.Name FROM match_season AS T1 JOIN team AS T2 ON T1.Team  =  T2.Team_id", "source_tables": ["team", "match_season"], "description": "This virtual table provides a summary of match seasons, including the season name, player name, and the corresponding team name. The data is retrieved from the 'match_season' table, which is joined with the 'team' table to associate each player with their respective team using the team identifier.", "virtual_table": "SELECT T1.Season ,  T1.Player ,  T2.Name FROM match_season AS T1 JOIN team AS T2 ON T1.Team  =  T2.Team_id"}
{"sample_id": "train.1094", "db_id": "match_season", "question": "Return all players sorted by college in ascending alphabetical order.", "rationale": ["The query identifies the relevant table, which is 'match_season'.", "Select the column to display, which is 'player'.", "Add an ORDER BY clause to sort the results based on the 'College' column in ascending order."], "gold_sql": "SELECT player FROM match_season ORDER BY College ASC", "source_tables": ["match_season"], "description": "This virtual table lists the names of players from the 'match_season' table, ordered by their college names in ascending order. The placeholder in the ORDER BY clause represents the college names.", "virtual_table": "SELECT player FROM match_season ORDER BY College ASC"}
{"sample_id": "train.2506", "db_id": "movie_1", "question": "Find the title and score of the movie with the lowest rating among all movies directed by each director.", "rationale": ["The query identifies the relevant tables, 'Rating' and 'Movie', and uses a JOIN to combine them based on the movie identifier (mID).", "It selects the movie title, the stars given in the rating, and the director's name.", "The query also calculates the minimum star rating for each director using the MIN function.", "Finally, it groups the results by the director's name to provide a summary of ratings for each director."], "gold_sql": "SELECT T2.title ,  T1.stars ,  T2.director ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T2.director", "source_tables": ["rating", "movie"], "description": "This virtual table provides a summary of movie ratings, displaying the title of each movie, the number of stars given, the director's name, and the minimum star rating for each director. The data is aggregated by director, allowing for a comparison of the lowest ratings received by movies directed by the same individual.", "virtual_table": "SELECT T2.title ,  T1.stars ,  T2.director ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T2.director"}
{"sample_id": "train.2514", "db_id": "movie_1", "question": "Find the average rating star for each movie that are not reviewed by Brittany Harris.", "rationale": ["The query identifies the relevant table, which is 'Rating', to calculate average ratings.", "It selects the movie identifier 'mID' and the average of 'stars' for the ratings.", "A subquery is used to filter out movies that have been rated by a specific reviewer, linking the 'Rating' and 'Reviewer' tables through the reviewer ID 'rID'.", "The placeholder in the subquery represents the reviewer's name whose ratings are to be excluded."], "gold_sql": "SELECT mID ,  avg(stars) FROM Rating WHERE mID NOT IN (SELECT T1.mID FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T2.name  =  'Brittany Harris') GROUP BY mID", "source_tables": ["rating", "reviewer"], "description": "This virtual table provides the average star ratings of movies from the 'Rating' table, excluding those rated by a specific reviewer. The placeholder in the subquery represents the reviewer's name whose ratings are to be excluded.", "virtual_table": "SELECT mID ,  avg(stars) FROM Rating WHERE mID NOT IN (SELECT T1.mID FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING]) GROUP BY mID"}
{"sample_id": "train.2519", "db_id": "movie_1", "question": "For each movie that received more than 3 reviews, what is the average rating?", "rationale": ["The query identifies the relevant table, which is 'Rating'.", "Select the column 'mID' to display the unique movie identifiers and calculate the average of the 'stars' column.", "Group the results by 'mID' to aggregate the ratings for each movie.", "Add a condition to filter the results using HAVING to ensure that only movies with a specified minimum number of ratings are included, using a placeholder for numeric values."], "gold_sql": "SELECT mID ,  avg(stars) FROM Rating GROUP BY mID HAVING count(*)  >=  2", "source_tables": ["rating"], "description": "This virtual table provides the unique movie identifiers along with the average star ratings from the 'Rating' table. It groups the results by movie ID and filters to include only those movies that have received a minimum number of ratings, as specified by the placeholder.", "virtual_table": "SELECT mID ,  avg(stars) FROM Rating GROUP BY mID HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2504", "db_id": "movie_1", "question": "Find the title and star rating of the movie that got the least rating star for each reviewer.", "rationale": ["The query identifies the relevant tables, 'Rating' and 'Movie'.", "It selects the columns to display: movie title from 'Movie', reviewer ID, stars from 'Rating', and the minimum stars given by each reviewer.", "The JOIN operation links the 'Rating' table with the 'Movie' table based on the movie identifier, ensuring that the ratings correspond to the correct movies.", "The GROUP BY clause is used to aggregate the results by reviewer ID, allowing for the calculation of the minimum stars given by each reviewer."], "gold_sql": "SELECT T2.title ,  T1.rID ,  T1.stars ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.rID", "source_tables": ["rating", "movie"], "description": "This virtual table provides a summary of movie ratings by reviewers. It displays the title of the movie, the unique identifier of the reviewer, the number of stars given in the rating, and the minimum stars given by each reviewer. The placeholders represent the relevant identifiers and ratings.", "virtual_table": "SELECT T2.title ,  T1.rID ,  T1.stars ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.rID"}
{"sample_id": "train.2487", "db_id": "movie_1", "question": "For all directors who have directed more than one movie, what movies have they directed and what are their names?", "rationale": ["The query identifies the relevant table, which is 'Movie'.", "It performs a self-join on the 'Movie' table to compare movies directed by the same director.", "The SELECT statement specifies the columns to display: 'title' and 'director'.", "A condition is added to ensure that the titles of the movies are different using 'WHERE T1.title != T2.title'.", "The results are ordered by 'director' and 'title' to organize the output."], "gold_sql": "SELECT T1.title ,  T1.director FROM Movie AS T1 JOIN Movie AS T2 ON T1.director  =  T2.director WHERE T1.title != T2.title ORDER BY T1.director ,  T1.title", "source_tables": ["movie"], "description": "This virtual table lists the titles and directors of movies from the 'Movie' table that have the same director but different titles. The query uses a self-join on the 'Movie' table to compare movies directed by the same person, ensuring that the titles are not the same. The results are ordered by the director's name and the movie title.", "virtual_table": "SELECT T1.title ,  T1.director FROM Movie AS T1 JOIN Movie AS T2 ON T1.director  =  T2.director WHERE T1.title != T2.title ORDER BY T1.director ,  T1.title"}
{"sample_id": "train.2531", "db_id": "movie_1", "question": "What are the names of all movies that received 3 or 4 stars?", "rationale": ["The query identifies the relevant tables, which are 'Rating' and 'Movie'.", "It selects the 'title' column from the 'Movie' table.", "The query uses a JOIN to link the 'Rating' table with the 'Movie' table based on the movie identifier (mID).", "It filters the results based on the number of stars given in the rating using placeholders for numeric values.", "The INTERSECT operator is used to find titles that match the star ratings from two different conditions."], "gold_sql": "SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  3 INTERSECT SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  4", "source_tables": ["rating", "movie"], "description": "This virtual table describes the titles of movies that have received a specific number of stars from two different reviewers. The placeholders in the WHERE clause represent the star ratings given by the reviewers.", "virtual_table": "SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2515", "db_id": "movie_1", "question": "What is the average rating for each movie that has never been reviewed by Brittany Harris?", "rationale": ["The query identifies the relevant table, which is 'Rating', to calculate average ratings.", "It selects the movie ID (mID) and the average of the stars given in the ratings.", "A subquery is used to filter out movies that have been rated by a specific reviewer, linking the 'Rating' table to the 'Reviewer' table using the reviewer ID (rID).", "The placeholder in the subquery represents the reviewer's name whose ratings are to be excluded from the average calculation."], "gold_sql": "SELECT mID ,  avg(stars) FROM Rating WHERE mID NOT IN (SELECT T1.mID FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T2.name  =  'Brittany Harris') GROUP BY mID", "source_tables": ["rating", "reviewer"], "description": "This virtual table provides the average star ratings of movies from the 'Rating' table, excluding those rated by a specific reviewer. The placeholder in the subquery represents the reviewer's name whose ratings are to be excluded.", "virtual_table": "SELECT mID ,  avg(stars) FROM Rating WHERE mID NOT IN (SELECT T1.mID FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING]) GROUP BY mID"}
{"sample_id": "train.2529", "db_id": "movie_1", "question": "What are the names of all reviewers that have given 3 or 4 stars for reviews?", "rationale": ["The query identifies the relevant tables, which are 'Rating' and 'Reviewer'.", "It selects the 'name' column from the 'Reviewer' table.", "The JOIN operation links the 'Rating' table to the 'Reviewer' table using the reviewer ID.", "The WHERE clause filters the ratings based on the specified number of stars using a placeholder for numeric values.", "The INTERSECT operation is used to find common reviewers who rated two different movies with the same star rating."], "gold_sql": "SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T1.stars  =  3 INTERSECT SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T1.stars  =  4", "source_tables": ["rating", "reviewer"], "description": "This virtual table describes the names of reviewers who have given a specific number of stars to movies. The query uses an INTERSECT operation to find reviewers who rated two different movies with the same star rating. The placeholders in the WHERE clause represent the number of stars given in the ratings.", "virtual_table": "SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2497", "db_id": "movie_1", "question": "What are the movie titles with the highest average rating and what are those ratings?", "rationale": ["The query identifies the relevant tables, 'Rating' and 'Movie'.", "It selects the movie title from the 'Movie' table and calculates the average stars from the 'Rating' table.", "The JOIN operation links the two tables based on the movie identifier (mID).", "The results are grouped by the movie identifier to calculate the average rating for each movie.", "The ORDER BY clause sorts the results by the average rating in descending order.", "The LIMIT clause uses a placeholder to allow the user to specify how many results to return."], "gold_sql": "SELECT T2.title ,  avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY avg(T1.stars) DESC LIMIT 1", "source_tables": ["rating", "movie"], "description": "This virtual table provides a list of movie titles along with their average ratings from the 'Rating' table. The results are grouped by movie identifier and ordered by the average rating in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of results to return.", "virtual_table": "SELECT T2.title ,  avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY avg(T1.stars) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2482", "db_id": "movie_1", "question": "Return all reviewer names and movie names together in a single list.", "rationale": ["The query is identifying the relevant tables, which are 'Reviewer' and 'Movie'.", "Using the UNION operator to combine the results from two SELECT statements.", "The first SELECT statement retrieves the 'name' column from the 'Reviewer' table.", "The second SELECT statement retrieves the 'title' column from the 'Movie' table."], "gold_sql": "SELECT name FROM Reviewer UNION SELECT title FROM Movie", "source_tables": ["movie", "reviewer"], "description": "This virtual table combines the names of reviewers and the titles of movies from the respective tables. The result will include a unified list of names and titles, allowing for a comprehensive view of both reviewers and movies.", "virtual_table": "SELECT name FROM Reviewer UNION SELECT title FROM Movie"}
{"sample_id": "train.2494", "db_id": "movie_1", "question": "How many movie reviews does each director get?", "rationale": ["The query identifies the relevant tables, which are 'Movie' and 'Rating'.", "It selects the count of ratings and the director's name from the 'Movie' table.", "A JOIN operation is performed on the 'mID' to link the 'Movie' and 'Rating' tables.", "The results are grouped by the director's name to aggregate the count of ratings for each director."], "gold_sql": "SELECT count(*) ,  T1.director FROM Movie AS T1 JOIN Rating AS T2 ON T1.mID  =  T2.mID GROUP BY T1.director", "source_tables": ["rating", "movie"], "description": "This virtual table provides a count of ratings for each movie director from the 'Movie' and 'Rating' tables. The placeholder in the SELECT statement represents the total number of ratings grouped by each director's name.", "virtual_table": "SELECT count(*) ,  T1.director FROM Movie AS T1 JOIN Rating AS T2 ON T1.mID  =  T2.mID GROUP BY T1.director"}
{"sample_id": "train.2496", "db_id": "movie_1", "question": "Find the movies with the highest average rating. Return the movie titles and average rating.", "rationale": ["The query identifies the relevant tables, 'Rating' and 'Movie'.", "It selects the 'title' from the 'Movie' table and calculates the average of 'stars' from the 'Rating' table.", "A JOIN operation is performed on the 'mID' to link ratings to their corresponding movies.", "The results are grouped by the movie identifier to calculate the average rating for each movie.", "The results are ordered by the average rating in descending order to show the highest-rated movies first.", "A placeholder is included in the LIMIT clause to allow the user to specify how many results they want to retrieve."], "gold_sql": "SELECT T2.title ,  avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY avg(T1.stars) DESC LIMIT 1", "source_tables": ["rating", "movie"], "description": "This virtual table provides a list of movie titles along with their average ratings from the 'Rating' table. The results are grouped by movie identifier and ordered by the average rating in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of results to return.", "virtual_table": "SELECT T2.title ,  avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY avg(T1.stars) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2516", "db_id": "movie_1", "question": "What are the ids of the movies that are not reviewed by Brittany Harris.", "rationale": ["The query starts by selecting the unique movie identifiers (mID) from the 'Rating' table.", "It uses the EXCEPT clause to exclude movies that have been rated by a specific reviewer.", "To find the movies rated by the reviewer, a JOIN operation is performed between the 'Rating' and 'Reviewer' tables based on the reviewer ID (rID).", "The condition in the WHERE clause filters the results to only include ratings from the specified reviewer using a placeholder for the reviewer's name."], "gold_sql": "SELECT mID FROM Rating EXCEPT SELECT T1.mID FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T2.name  =  'Brittany Harris'", "source_tables": ["rating", "reviewer"], "description": "This virtual table identifies the unique movie identifiers from the 'Rating' table that have not been rated by a specific reviewer. The placeholder in the query represents the reviewer's name, allowing users to filter out movies rated by that particular reviewer.", "virtual_table": "SELECT mID FROM Rating EXCEPT SELECT T1.mID FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2499", "db_id": "movie_1", "question": "What are the titles and average ratings for all movies that have the lowest average rating?", "rationale": ["The query identifies the relevant tables, 'Rating' and 'Movie'.", "It selects the 'title' from the 'Movie' table and calculates the average of 'stars' from the 'Rating' table.", "A JOIN operation is performed on the 'mID' to link ratings to their respective movies.", "The results are grouped by 'mID' to ensure that the average rating is calculated for each movie.", "The results are ordered by the average rating in ascending order and limited to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT T2.title ,  avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY avg(T1.stars) LIMIT 1", "source_tables": ["rating", "movie"], "description": "This virtual table provides the titles of movies along with their average ratings from the 'Rating' table. The results are grouped by movie identifier and ordered by the average rating in ascending order, with a limit on the number of results returned.", "virtual_table": "SELECT T2.title ,  avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY avg(T1.stars) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2460", "db_id": "movie_1", "question": "Find the names of all reviewers who have ratings with a NULL value for the date.", "rationale": ["The query identifies the relevant tables, which are 'Reviewer' and 'Rating'.", "It selects distinct names from the 'Reviewer' table to avoid duplicates.", "The join condition links the 'Reviewer' table to the 'Rating' table using the reviewer's ID.", "A condition is added to filter the results based on the 'ratingDate' using a placeholder for string values."], "gold_sql": "SELECT DISTINCT name FROM Reviewer AS T1 JOIN Rating AS T2 ON T1.rID  =  T2.rID WHERE ratingDate  =  'null'", "source_tables": ["rating", "reviewer"], "description": "This virtual table lists the distinct names of reviewers who submitted ratings on a specific date. The query joins the 'Reviewer' and 'Rating' tables based on the reviewer's ID, filtering the results by the date of the rating submission.", "virtual_table": "SELECT DISTINCT name FROM Reviewer AS T1 JOIN Rating AS T2 ON T1.rID  =  T2.rID WHERE ratingDate  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2511", "db_id": "movie_1", "question": "What are the titles of all movies that have between 3 and 5 stars?", "rationale": ["The query identifies the relevant tables, which are 'Rating' and 'Movie'.", "It selects the 'title' column from the 'Movie' table.", "A JOIN operation is performed between 'Rating' and 'Movie' on the movie identifier 'mID'.", "A condition is added to filter the ratings based on a specified range of stars using placeholders for numeric values."], "gold_sql": "SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars BETWEEN 3 AND 5", "source_tables": ["rating", "movie"], "description": "This virtual table lists the titles of movies from the 'Movie' table that have received ratings within a specified range of stars. The placeholders in the WHERE clause represent the minimum and maximum star ratings.", "virtual_table": "SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2523", "db_id": "movie_1", "question": "What are the ids of all reviewers who have not given 4 stars at least once?", "rationale": ["The query is identifying the relevant table, which is 'Rating'.", "Select the column to display, 'rID', which represents the unique identifier of the reviewer.", "Add a condition to filter the 'stars' column to exclude ratings that match the specified number using a placeholder for numeric values."], "gold_sql": "SELECT rID FROM Rating WHERE stars != 4", "source_tables": ["rating"], "description": "This virtual table describes the unique identifiers of reviewers from the 'Rating' table who have given a rating that is not equal to a specified number of stars. The placeholder in the WHERE clause represents the number of stars to filter out.", "virtual_table": "SELECT rID FROM Rating WHERE stars != [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2522", "db_id": "movie_1", "question": "Find the ids of reviewers who didn't only give 4 star.", "rationale": ["The query is identifying the relevant table, which is 'Rating'.", "Select the column to display, 'rID', which is the unique identifier for each reviewer.", "Add a condition to filter the 'stars' column for ratings that are not equal to the specified number using a placeholder for numeric values."], "gold_sql": "SELECT rID FROM Rating WHERE stars != 4", "source_tables": ["rating"], "description": "This virtual table describes the unique identifiers of reviewers from the 'Rating' table who have given a rating that is not equal to a specified number of stars. The placeholder in the WHERE clause represents the number of stars.", "virtual_table": "SELECT rID FROM Rating WHERE stars != [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3583", "db_id": "music_1", "question": "List the names of all songs that have 4 minute duration or are in English.", "rationale": ["The query identifies the relevant tables, which are 'files' and 'song'.", "It selects the 'song_name' from the 'song' table based on a join condition with the 'files' table using the 'f_id' column.", "The first part of the query filters songs based on the duration of the files using a placeholder for string values.", "The second part of the query retrieves song names from the 'song' table where the languages match a specified value, also using a placeholder for string values."], "gold_sql": "SELECT T2.song_name FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.duration LIKE '4:%' UNION SELECT song_name FROM song WHERE languages  =  'english'", "source_tables": ["files", "song"], "description": "This virtual table provides a list of song titles from the 'files' and 'song' tables based on specific criteria. It retrieves song names associated with files that match a certain duration and also includes song names from the 'song' table that are available in a specified language. The placeholders in the WHERE clause represent the duration format and the language of the songs.", "virtual_table": "SELECT T2.song_name FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.duration LIKE [PLACEHOLDER-TYPE:STRING] UNION SELECT song_name FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3584", "db_id": "music_1", "question": "What are the names of all songs that are approximately 4 minutes long or are in English?", "rationale": ["The query identifies the relevant tables, which are 'files' and 'song'.", "It selects the 'song_name' from the 'song' table where the file's duration matches a specified pattern using a placeholder for string values.", "It uses a UNION to combine results from the 'song' table where the song's languages match a specified language, also using a placeholder for string values."], "gold_sql": "SELECT T2.song_name FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.duration LIKE '4:%' UNION SELECT song_name FROM song WHERE languages  =  'english'", "source_tables": ["files", "song"], "description": "This virtual table provides a list of song titles from the 'files' and 'song' tables based on specific criteria. It retrieves song names associated with files that match a certain duration and also includes song names that are available in a specified language. The placeholders in the WHERE clause represent the duration format and the language of the songs.", "virtual_table": "SELECT T2.song_name FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.duration LIKE [PLACEHOLDER-TYPE:STRING] UNION SELECT song_name FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3587", "db_id": "music_1", "question": "What is the language that was used most often in songs with resolution above 500?", "rationale": ["The query identifies the relevant table, which is 'song'.", "Select the column to display, 'artist_name'.", "Add a condition to filter the 'resolution' column for values greater than a specified number using a placeholder for numeric values.", "Group the results by the 'languages' column to aggregate the data based on the languages available for the songs.", "Order the results in descending order based on the count of songs per language to prioritize the most common languages.", "Limit the number of results returned to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT artist_name FROM song WHERE resolution  >  500 GROUP BY languages ORDER BY count(*) DESC LIMIT 1", "source_tables": ["song"], "description": "This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, sorted in descending order based on the count of songs per language, and limited to a specified number of results.", "virtual_table": "SELECT artist_name FROM song WHERE resolution  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY languages ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3588", "db_id": "music_1", "question": "What is the name of the artist, for each language, that has the most songs with a higher resolution than 500?", "rationale": ["The query identifies the relevant table, which is 'song'.", "It selects the 'artist_name' column to display the names of artists.", "A condition is added to filter songs based on their resolution using a placeholder for numeric values.", "The results are grouped by the 'languages' column to aggregate the data accordingly.", "The results are ordered by the count of songs in descending order to show the most prolific artists first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT artist_name FROM song WHERE resolution  >  500 GROUP BY languages ORDER BY count(*) DESC LIMIT 1", "source_tables": ["song"], "description": "This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, and ordered by the count of songs in descending order, limited to a specified number of results.", "virtual_table": "SELECT artist_name FROM song WHERE resolution  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY languages ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3602", "db_id": "music_1", "question": "What are the maximum duration and resolution of all songs, for each language, ordered alphabetically by language?", "rationale": ["The query identifies the relevant tables, 'files' and 'song', and uses a JOIN to connect them based on the foreign key relationship between 'f_id'.", "It selects the maximum duration from the 'files' table and the maximum resolution from the 'song' table, along with the languages from the 'song' table.", "The results are grouped by the 'languages' column to aggregate the data accordingly, and ordered by the 'languages' for better readability."], "gold_sql": "SELECT max(T1.duration) ,  max(T2.resolution) ,  T2.languages FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.languages ORDER BY T2.languages", "source_tables": ["files", "song"], "description": "This virtual table provides the maximum duration and resolution of audio files, along with the languages in which the songs are available. The data is aggregated by languages, allowing users to see the longest audio files and their highest resolutions for each language category.", "virtual_table": "SELECT max(T1.duration) ,  max(T2.resolution) ,  T2.languages FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.languages ORDER BY T2.languages"}
{"sample_id": "train.3620", "db_id": "music_1", "question": "What are the top 3 artists with the largest number of songs in the language Bangla?", "rationale": ["The query identifies the relevant tables, which are 'artist' and 'song'.", "It selects the 'artist_name' from the 'artist' table.", "A JOIN operation is performed on the 'artist_name' column to link the two tables.", "A condition is added to filter the songs based on the specified language using a placeholder for string values.", "The results are grouped by 'artist_name' to aggregate the data.", "The results are ordered by the count of songs in descending order to show the most prolific artists first.", "A limit is applied to restrict the number of results returned based on a numeric placeholder."], "gold_sql": "SELECT T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.languages  =  'bangla' GROUP BY T2.artist_name ORDER BY count(*) DESC LIMIT 3", "source_tables": ["artist", "song"], "description": "This virtual table lists the names of artists from the 'artist' table who have songs available in a specific language. The query joins the 'artist' and 'song' tables on the artist's name, filters the results based on the specified language, groups the results by artist name, and orders them by the number of songs in descending order, limiting the output to a specified number of artists.", "virtual_table": "SELECT T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.languages  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T2.artist_name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3604", "db_id": "music_1", "question": "What is the shortest and most poorly rated song for each genre, ordered alphabetically by genre?", "rationale": ["The query identifies the relevant tables, which are 'files' and 'song'.", "It selects the minimum duration from the 'files' table and the minimum rating from the 'song' table, along with the genre of the song.", "The JOIN operation links the two tables based on the file identifier, ensuring that the data corresponds correctly between audio files and their associated songs.", "The results are grouped by the genre of the song to aggregate the data accordingly, and ordered by the genre for better readability."], "gold_sql": "SELECT min(T1.duration) ,  min(T2.rating) ,  T2.genre_is FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.genre_is ORDER BY T2.genre_is", "source_tables": ["files", "song"], "description": "This virtual table provides the minimum duration of audio files and the minimum rating of songs grouped by their genre. The placeholders represent the necessary fields from the 'files' and 'song' tables, allowing users to analyze the relationship between audio file durations and song ratings across different genres.", "virtual_table": "SELECT min(T1.duration) ,  min(T2.rating) ,  T2.genre_is FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.genre_is ORDER BY T2.genre_is"}
{"sample_id": "train.3569", "db_id": "music_1", "question": "Find the distinct names of all songs that have a higher resolution than some songs in English.", "rationale": ["The query identifies the relevant table, which is 'song'.", "It selects distinct song names to avoid duplicates.", "The condition filters songs based on their resolution, comparing it to the minimum resolution of songs that are available in a specified language using a subquery and a placeholder for string values."], "gold_sql": "SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  'english')", "source_tables": ["song"], "description": "This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.", "virtual_table": "SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.3575", "db_id": "music_1", "question": "List the name and gender for all artists who released songs in March.", "rationale": ["The query identifies the relevant tables, which are 'artist' and 'song'.", "It selects the columns to display, 'artist_name' and 'gender' from the 'artist' table.", "A JOIN operation is performed on the 'artist' and 'song' tables based on the 'artist_name' column to link artists with their songs.", "A condition is added to filter the results based on the 'releasedate' column from the 'song' table using a placeholder for string values."], "gold_sql": "SELECT T1.artist_name ,  T1.gender FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.releasedate LIKE '%Mar%'", "source_tables": ["artist", "song"], "description": "This virtual table describes the names and genders of artists from the 'artist' table who have released songs on a specific date. The placeholder in the WHERE clause represents the release date of the songs.", "virtual_table": "SELECT T1.artist_name ,  T1.gender FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.releasedate LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3570", "db_id": "music_1", "question": "What are the different names for all songs that have a higher resolution than English songs?", "rationale": ["The query identifies the relevant table, which is 'song'.", "It selects distinct song names to avoid duplicates.", "A subquery is used to find the minimum resolution of songs that are available in a specified language, using a placeholder for the language value.", "The main query filters the songs based on the condition that their resolution is greater than the result of the subquery."], "gold_sql": "SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  'english')", "source_tables": ["song"], "description": "This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the subquery represents the language for which the minimum resolution is being queried.", "virtual_table": "SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.3550", "db_id": "music_1", "question": "How many songs, on average, are sung by a female artist?", "rationale": ["The query identifies the relevant tables, which are 'artist' and 'song'.", "It uses a JOIN operation to connect the two tables based on the 'artist_name' column.", "The SELECT statement is used to calculate the average of the 'rating' column from the 'song' table.", "A condition is added to filter the results based on the 'gender' column from the 'artist' table using a placeholder for string values."], "gold_sql": "SELECT avg(T2.rating) FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  'Female'", "source_tables": ["artist", "song"], "description": "This virtual table calculates the average rating of songs performed by artists of a specific gender. The placeholder in the WHERE clause represents the gender of the artists being queried.", "virtual_table": "SELECT avg(T2.rating) FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3585", "db_id": "music_1", "question": "What is the language used most often in the songs?", "rationale": ["The query identifies the relevant table, which is 'song'.", "It selects the 'languages' column to display.", "The results are grouped by 'languages' to aggregate the data.", "The results are ordered by the count of songs in each language in descending order.", "A limit is applied to restrict the number of languages returned, using a placeholder for numeric values."], "gold_sql": "SELECT languages FROM song GROUP BY languages ORDER BY count(*) DESC LIMIT 1", "source_tables": ["song"], "description": "This virtual table provides a list of languages in which songs are available, grouped by language and ordered by the number of songs in each language. The placeholder in the LIMIT clause allows the user to specify the maximum number of languages to retrieve.", "virtual_table": "SELECT languages FROM song GROUP BY languages ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3591", "db_id": "music_1", "question": "Find the names of songs whose genre is modern or language is English.", "rationale": ["The query identifies the relevant table, which is 'song'.", "Select the column to display, 'song_name'.", "Add conditions to filter the 'genre_is' and 'languages' columns for the specified genre and language using placeholders for string values."], "gold_sql": "SELECT song_name FROM song WHERE genre_is  =  'modern' OR languages  =  'english'", "source_tables": ["song"], "description": "This virtual table describes the titles of songs from the 'song' table that belong to a specific genre or are available in a specific language. The placeholders in the WHERE clause represent the genre and language criteria.", "virtual_table": "SELECT song_name FROM song WHERE genre_is  =  [PLACEHOLDER-TYPE:STRING] OR languages  =  [PLACEHOLDER-TYPE:STRING]"}
