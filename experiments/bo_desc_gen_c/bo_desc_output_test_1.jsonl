{"sample_id": "train.1109", "db_id": "match_season", "question": "Return the colleges that have players who play the Midfielder position, as well as players who play the Defender position.", "rationale": ["The query identifies the relevant table, which is 'match_season'.", "It selects the 'College' column to display the colleges attended by players.", "The INTERSECT operator is used to find common colleges attended by players in two different positions, with placeholders for the positions specified in the WHERE clause."], "gold_sql": "SELECT College FROM match_season WHERE POSITION  =  'Midfielder' INTERSECT SELECT College FROM match_season WHERE POSITION  =  'Defender'", "source_tables": ["match_season"], "description": "This virtual table retrieves the colleges attended by players who have played in two different positions during the match season. The placeholders in the WHERE clause represent the specific positions of the players being compared.", "virtual_table": "SELECT College FROM match_season WHERE POSITION  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT College FROM match_season WHERE POSITION  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1222", "db_id": "apartment_rentals", "question": "What are the booking start and end dates of the apartments with type code \"Duplex\"?", "rationale": ["The query identifies the relevant tables, 'Apartment_Bookings' and 'Apartments'.", "It selects the 'booking_start_date' from the 'Apartment_Bookings' table.", "A JOIN is performed on the 'apt_id' to link bookings to their respective apartments.", "A condition is added to filter the results based on the 'apt_type_code' using a placeholder for string values."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.apt_type_code  =  'Duplex'", "source_tables": ["apartment_bookings", "apartments"], "description": "This virtual table provides the start dates of apartment bookings from the 'Apartment_Bookings' table for apartments of a specific type. The placeholder in the WHERE clause represents the apartment type code.", "virtual_table": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.apt_type_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1224", "db_id": "apartment_rentals", "question": "What are the booking start and end dates of the apartments with more than 2 bedrooms?", "rationale": ["The query identifies the relevant tables, 'Apartment_Bookings' and 'Apartments'.", "It selects the 'booking_start_date' from the 'Apartment_Bookings' table.", "A JOIN operation is performed to link 'Apartment_Bookings' with 'Apartments' based on the apartment ID.", "A condition is added to filter the results based on the number of bedrooms in the 'Apartments' table using a placeholder for numeric values."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  2", "source_tables": ["apartment_bookings", "apartments"], "description": "This virtual table provides the start dates of apartment bookings from the 'Apartment_Bookings' table for apartments that have a specified number of bedrooms. The placeholder in the WHERE clause represents the minimum number of bedrooms required for the apartments being queried.", "virtual_table": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1225", "db_id": "apartment_rentals", "question": "Find the booking start date and end date for the apartments that have more than two bedrooms.", "rationale": ["The query identifies the relevant tables, 'Apartment_Bookings' and 'Apartments'.", "It selects the 'booking_start_date' from the 'Apartment_Bookings' table.", "A JOIN operation is performed to link 'Apartment_Bookings' with 'Apartments' based on the apartment ID.", "A condition is added to filter the results based on the number of bedrooms in the 'Apartments' table using a placeholder for numeric values."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  2", "source_tables": ["apartment_bookings", "apartments"], "description": "This virtual table provides the start dates of apartment bookings from the 'Apartment_Bookings' table for apartments that have a specified number of bedrooms. The placeholder in the WHERE clause represents the minimum number of bedrooms required for the apartments being queried.", "virtual_table": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1229", "db_id": "apartment_rentals", "question": "Which apartments have bookings with status code \"Confirmed\"? Return their apartment numbers.", "rationale": ["The query identifies the relevant tables, 'Apartment_Bookings' and 'Apartments'.", "It uses a JOIN operation to link the two tables based on the apartment ID.", "The SELECT DISTINCT clause is used to ensure that only unique apartment numbers are returned.", "A condition is added to filter the results based on the booking status code using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T2.apt_number FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T1.booking_status_code  =  'Confirmed'", "source_tables": ["apartment_bookings", "apartments"], "description": "This virtual table provides a list of unique apartment numbers from the 'Apartments' table that are associated with bookings having a specific status. The placeholder in the WHERE clause represents the booking status code.", "virtual_table": "SELECT DISTINCT T2.apt_number FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T1.booking_status_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1232", "db_id": "apartment_rentals", "question": "Show the guest first names, start dates, and end dates of all the apartment bookings.", "rationale": ["The query identifies the relevant tables, 'Apartment_Bookings' and 'Guests'.", "It selects the 'guest_first_name' from the 'Guests' table and 'booking_start_date' from the 'Apartment_Bookings' table.", "A JOIN operation is performed on the 'guest_id' to link the bookings with the corresponding guests, allowing us to retrieve guest information related to their bookings."], "gold_sql": "SELECT T2.guest_first_name ,  T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id", "source_tables": ["apartment_bookings", "guests"], "description": "This virtual table provides the first names of guests along with the start dates of their apartment bookings. The placeholders in the query allow for filtering or additional conditions to be applied as needed.", "virtual_table": "SELECT T2.guest_first_name ,  T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id"}
{"sample_id": "train.1234", "db_id": "apartment_rentals", "question": "Show the start dates and end dates of all the apartment bookings made by guests with gender code \"Female\".", "rationale": ["The query identifies the relevant tables, which are 'Apartment_Bookings' and 'Guests'.", "It selects the 'booking_start_date' and 'booking_end_date' columns from the 'Apartment_Bookings' table.", "A JOIN operation is performed between 'Apartment_Bookings' and 'Guests' on the 'guest_id' to link bookings to guests.", "A condition is added to filter the results based on the 'gender_code' of the guests using a placeholder for string values."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id WHERE T2.gender_code  =  'Female'", "source_tables": ["apartment_bookings", "guests"], "description": "This virtual table provides the start dates of apartment bookings along with the corresponding booking end dates for guests filtered by a specific gender. The placeholders in the WHERE clause represent the gender code of the guests.", "virtual_table": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id WHERE T2.gender_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1238", "db_id": "apartment_rentals", "question": "Show the facility codes of apartments with more than 4 bedrooms.", "rationale": ["The query identifies the relevant tables, which are 'Apartment_Facilities' and 'Apartments'.", "It selects the 'facility_code' from the 'Apartment_Facilities' table.", "A JOIN operation is performed between 'Apartment_Facilities' and 'Apartments' on the 'apt_id' to link facilities to their respective apartments.", "A condition is added to filter the results based on the 'bedroom_count' in the 'Apartments' table, using a placeholder for numeric values."], "gold_sql": "SELECT T1.facility_code FROM Apartment_Facilities AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  4", "source_tables": ["apartments", "apartment_facilities"], "description": "This virtual table lists the facility codes of apartments that have a specified number of bedrooms. The placeholder in the WHERE clause represents the minimum number of bedrooms required for the apartments.", "virtual_table": "SELECT T1.facility_code FROM Apartment_Facilities AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1256", "db_id": "apartment_rentals", "question": "Show the top 3 apartment type codes sorted by the average number of rooms in descending order.", "rationale": ["The query identifies the relevant table, which is 'Apartments'.", "It selects the 'apt_type_code' to show the different types of apartments.", "The results are grouped by 'apt_type_code' to aggregate the data based on apartment types.", "The average number of rooms is calculated using 'avg(room_count)' to order the types by their spaciousness.", "The LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY avg(room_count) DESC LIMIT 3", "source_tables": ["apartments"], "description": "This virtual table provides a summary of the different types of apartments available in the 'Apartments' table, grouped by their type code. The results are ordered by the average number of rooms in each apartment type, allowing users to see which types of apartments are more spacious on average. The placeholder in the LIMIT clause represents the maximum number of apartment types to be displayed.", "virtual_table": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY avg(room_count) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1258", "db_id": "apartment_rentals", "question": "Show the apartment type code that has the largest number of total rooms, together with the number of bathrooms and number of bedrooms.", "rationale": ["The query identifies the relevant table, which is 'Apartments'.", "Selects the columns 'apt_type_code', 'bathroom_count', and 'bedroom_count' to display.", "Groups the results by 'apt_type_code' to aggregate data for each type of apartment.", "Orders the results by the sum of 'room_count' in descending order to prioritize types with more rooms.", "Limits the number of results returned based on a placeholder for numeric values."], "gold_sql": "SELECT apt_type_code ,  bathroom_count ,  bedroom_count FROM Apartments GROUP BY apt_type_code ORDER BY sum(room_count) DESC LIMIT 1", "source_tables": ["apartments"], "description": "This virtual table summarizes the types of apartments available in the 'Apartments' table, displaying the apartment type code along with the count of bathrooms and bedrooms. The results are grouped by apartment type and ordered by the total number of rooms in descending order, with a limit on the number of results returned based on a specified number.", "virtual_table": "SELECT apt_type_code ,  bathroom_count ,  bedroom_count FROM Apartments GROUP BY apt_type_code ORDER BY sum(room_count) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1261", "db_id": "apartment_rentals", "question": "Which apartment type code appears the most often?", "rationale": ["The query identifies the relevant table, which is 'Apartments'.", "It selects the 'apt_type_code' to show the different types of apartments.", "The GROUP BY clause is used to group the results by 'apt_type_code'.", "The ORDER BY clause sorts the grouped results by the count of apartments in each type in descending order.", "The LIMIT clause uses a placeholder to allow the user to specify how many types of apartments they want to see."], "gold_sql": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["apartments"], "description": "This virtual table provides a summary of the different types of apartments available in the 'Apartments' table. It groups the apartments by their type code and orders them by the number of apartments of each type in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of apartment types to retrieve.", "virtual_table": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1262", "db_id": "apartment_rentals", "question": "Show the most common apartment type code among apartments with more than 1 bathroom.", "rationale": ["The query identifies the relevant table, which is 'Apartments'.", "It selects the 'apt_type_code' to display the types of apartments.", "A condition is added to filter the results based on the number of bathrooms using a placeholder for numeric values.", "The results are grouped by 'apt_type_code' to aggregate the counts of each type.", "The results are ordered by the count of apartments in descending order to show the most common types first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT apt_type_code FROM Apartments WHERE bathroom_count  >  1 GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["apartments"], "description": "This virtual table provides a summary of the types of apartments available in the 'Apartments' table that have a specified number of bathrooms. The results are grouped by the apartment type code and ordered by the count of apartments in each type, allowing users to see which types are most common based on the bathroom count criteria. The placeholders in the WHERE clause and LIMIT clause represent the minimum number of bathrooms and the maximum number of results to return, respectively.", "virtual_table": "SELECT apt_type_code FROM Apartments WHERE bathroom_count  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1272", "db_id": "apartment_rentals", "question": "Show the apartment numbers of apartments with unit status availability of both 0 and 1.", "rationale": ["The query identifies the relevant tables, which are 'Apartments' and 'View_Unit_Status'.", "It selects the 'apt_number' column from the 'Apartments' table.", "The JOIN operation links the two tables on the 'apt_id' column to combine their data.", "The WHERE clause filters the results based on the availability status using a placeholder for numeric values.", "The INTERSECT operation is used to find common apartment numbers that meet the availability criteria in both parts of the query."], "gold_sql": "SELECT T1.apt_number FROM Apartments AS T1 JOIN View_Unit_Status AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.available_yn  =  0 INTERSECT SELECT T1.apt_number FROM Apartments AS T1 JOIN View_Unit_Status AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.available_yn  =  1", "source_tables": ["view_unit_status", "apartments"], "description": "This virtual table describes the apartment numbers from the 'Apartments' table that are available based on a specific availability status. The query uses an INTERSECT operation to find common apartment numbers that meet the availability criteria specified by the placeholders.", "virtual_table": "SELECT T1.apt_number FROM Apartments AS T1 JOIN View_Unit_Status AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.available_yn  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T1.apt_number FROM Apartments AS T1 JOIN View_Unit_Status AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.available_yn  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1294", "db_id": "soccer_1", "question": "How many leagues are there in England?", "rationale": ["The query identifies the relevant tables, which are 'Country' and 'League'.", "It uses a JOIN operation to connect the 'Country' table with the 'League' table based on the country ID.", "The SELECT statement counts the number of leagues that match the specified country name using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM Country AS T1 JOIN League AS T2 ON T1.id  =  T2.country_id WHERE T1.name  =  'England'", "source_tables": ["country", "league"], "description": "This virtual table provides the count of leagues associated with a specific country from the 'Country' and 'League' tables. The placeholder in the WHERE clause represents the name of the country for which the league count is being queried.", "virtual_table": "SELECT count(*) FROM Country AS T1 JOIN League AS T2 ON T1.id  =  T2.country_id WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1303", "db_id": "soccer_1", "question": "List all of the player ids with a height of at least 180cm and an overall rating higher than 85.", "rationale": ["The query starts by selecting the 'player_api_id' from the 'Player' table.", "It applies a condition to filter players whose height is greater than or equal to a specified number using a placeholder for numeric values.", "Next, it selects 'player_api_id' from the 'Player_Attributes' table, filtering for players with an overall rating greater than a specified number, again using a placeholder for numeric values.", "The INTERSECT operator is used to find players that meet both criteria, ensuring that only those who are both tall and highly rated are included in the result."], "gold_sql": "SELECT player_api_id FROM Player WHERE height  >=  180 INTERSECT SELECT player_api_id FROM Player_Attributes WHERE overall_rating  >  85", "source_tables": ["player_attributes", "player"], "description": "This virtual table identifies players from the 'Player' table who meet specific physical and skill criteria. The first part of the query filters players based on their height, while the second part filters players based on their overall skill rating. The intersection of these two sets of players is returned, represented by the player_api_id.", "virtual_table": "SELECT player_api_id FROM Player WHERE height  >=  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT player_api_id FROM Player_Attributes WHERE overall_rating  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1304", "db_id": "soccer_1", "question": "List all of the ids for left-footed players with a height between 180cm and 190cm.", "rationale": ["The query starts by selecting the 'player_api_id' from the 'Player' table where the height is within a specified range using placeholders for numeric values.", "Next, it selects 'player_api_id' from the 'Player_Attributes' table where the 'preferred_foot' matches a specified value using a placeholder for string values.", "The INTERSECT operator is used to find common 'player_api_id' values from both selections, ensuring that only players who meet both criteria are returned."], "gold_sql": "SELECT player_api_id FROM Player WHERE height  >=  180 AND height  <=  190 INTERSECT SELECT player_api_id FROM Player_Attributes WHERE preferred_foot  =  'left'", "source_tables": ["player_attributes", "player"], "description": "This virtual table identifies players based on their height and preferred foot. It retrieves the API identifiers of players from the 'Player' table whose height falls within a specified range and intersects this with players from the 'Player_Attributes' table who have a specific preferred foot. The placeholders in the query represent the height range and the preferred foot of the players.", "virtual_table": "SELECT player_api_id FROM Player WHERE height  >=  [PLACEHOLDER-TYPE:NUMBER] AND height  <=  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT player_api_id FROM Player_Attributes WHERE preferred_foot  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1306", "db_id": "soccer_1", "question": "List the names and birthdays of the top five players in terms of potential.", "rationale": ["The query identifies the relevant tables, 'Player' and 'Player_Attributes'.", "It selects distinct player names and birthdays from the 'Player' table.", "A join is performed on the 'player_api_id' to combine player data with their attributes.", "The results are ordered by the 'potential' column in descending order to prioritize players with higher potential.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT DISTINCT T1.player_name ,  T1.birthday FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id  =  T2.player_api_id ORDER BY potential DESC LIMIT 5", "source_tables": ["player_attributes", "player"], "description": "This virtual table provides a list of unique player names and their birthdays from the 'Player' table, joined with the 'Player_Attributes' table to include only those players with their corresponding attributes. The results are ordered by the potential skill rating in descending order, and the number of results returned is limited by a specified placeholder for numeric values.", "virtual_table": "SELECT DISTINCT T1.player_name ,  T1.birthday FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id  =  T2.player_api_id ORDER BY potential DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1511", "db_id": "insurance_and_eClaims", "question": "Which type of policy is most frequently used? Give me the policy type code.", "rationale": ["The query identifies the relevant table, which is 'Policies'.", "It selects the 'policy_type_code' column to display the types of insurance policies.", "The GROUP BY clause is used to group the results by 'policy_type_code'.", "The ORDER BY clause sorts the grouped results by their count in descending order.", "The LIMIT clause uses a placeholder to allow the user to specify how many policy types to return."], "gold_sql": "SELECT policy_type_code FROM policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["policies"], "description": "This virtual table summarizes the different types of insurance policies from the 'Policies' table, grouping them by their policy type code. The placeholder in the LIMIT clause allows the user to specify the maximum number of policy types to retrieve, sorted by the frequency of each type in descending order.", "virtual_table": "SELECT policy_type_code FROM policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1513", "db_id": "insurance_and_eClaims", "question": "Find all the policy types that are used by more than 2 customers.", "rationale": ["The query identifies the relevant table, which is 'Policies'.", "It selects the 'policy_type_code' to display unique policy types.", "The GROUP BY clause is used to group the results by 'policy_type_code'.", "The HAVING clause filters the groups to include only those with a count greater than a specified number, using a placeholder for numeric values."], "gold_sql": "SELECT policy_type_code FROM policies GROUP BY policy_type_code HAVING count(*)  >  2", "source_tables": ["policies"], "description": "This virtual table provides a list of unique insurance policy types from the 'Policies' table that have been issued more than a specified number of times. The placeholder in the HAVING clause represents the minimum count of policies required to be included in the results.", "virtual_table": "SELECT policy_type_code FROM policies GROUP BY policy_type_code HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1516", "db_id": "insurance_and_eClaims", "question": "What are the total amount and average amount paid in claim headers?", "rationale": ["The query identifies the relevant table, which is 'Claim_Headers'.", "It selects the sum and average of the 'amount_paid' column to provide a summary of the payments made on claims."], "gold_sql": "SELECT sum(amount_piad) ,  avg(amount_piad) FROM claim_headers", "source_tables": ["claim_headers"], "description": "This virtual table summarizes the total and average amounts paid for claims from the 'Claim_Headers' table. The placeholders in the SELECT clause represent the total and average of the 'amount_paid' column.", "virtual_table": "SELECT sum(amount_piad) ,  avg(amount_piad) FROM claim_headers"}
{"sample_id": "train.1518", "db_id": "insurance_and_eClaims", "question": "How much amount in total were claimed in the most recently created document?", "rationale": ["The query identifies the relevant tables, 'Claim_Headers' and 'Claims_Documents'.", "It uses a JOIN to link the two tables based on the claim identifier.", "The SELECT statement sums the 'amount_claimed' from 'Claim_Headers'.", "A WHERE clause filters the results to include only those claims that have documents created on a specific date, determined by a subquery that selects the created date with a limit placeholder."], "gold_sql": "SELECT sum(t1.amount_claimed) FROM claim_headers AS t1 JOIN claims_documents AS t2 ON t1.claim_header_id  =  t2.claim_id WHERE t2.created_date  =  (SELECT created_date FROM claims_documents ORDER BY created_date LIMIT 1)", "source_tables": ["claims_documents", "claim_headers"], "description": "This virtual table calculates the total amount claimed from the 'Claim_Headers' table for claims that have associated documents created on a specific date. The placeholder in the subquery represents the limit for selecting the created date of the documents.", "virtual_table": "SELECT sum(t1.amount_claimed) FROM claim_headers AS t1 JOIN claims_documents AS t2 ON t1.claim_header_id  =  t2.claim_id WHERE t2.created_date  =  (SELECT created_date FROM claims_documents ORDER BY created_date LIMIT [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.1519", "db_id": "insurance_and_eClaims", "question": "What is the name of the customer who has made the largest amount of claim in a single claim?", "rationale": ["The query identifies the relevant tables: 'Claim_Headers', 'Policies', and 'Customers'.", "It selects the 'customer_details' from the 'Customers' table.", "The query uses JOINs to connect 'Claim_Headers' to 'Policies' via 'policy_id', and 'Policies' to 'Customers' via 'customer_id'.", "A subquery is used to find the maximum 'amount_claimed' from the 'Claim_Headers' table, which serves as a filter in the WHERE clause."], "gold_sql": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_claimed  =  (SELECT max(amount_claimed) FROM claim_headers)", "source_tables": ["policies", "customers", "claim_headers"], "description": "This virtual table retrieves the detailed information about the customer associated with the claim that has the highest amount claimed. The query joins the 'Claim_Headers' table with the 'Policies' table to link claims to their respective policies, and then joins the 'Customers' table to get the customer details. The placeholder in the WHERE clause represents the maximum amount claimed across all claims.", "virtual_table": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_claimed  =  (SELECT max(amount_claimed) FROM claim_headers)"}
{"sample_id": "train.1521", "db_id": "insurance_and_eClaims", "question": "What is the name of the customer who has made the minimum amount of payment in one claim?", "rationale": ["The query identifies the relevant tables: 'Claim_Headers', 'Policies', and 'Customers'.", "It selects the 'customer_details' from the 'Customers' table.", "The query uses JOINs to connect 'Claim_Headers' to 'Policies' via 'policy_id', and 'Policies' to 'Customers' via 'customer_id'.", "A subquery is used to find the minimum 'amount_paid' from 'Claim_Headers', which is used as a condition in the WHERE clause."], "gold_sql": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)", "source_tables": ["policies", "customers", "claim_headers"], "description": "This virtual table retrieves detailed information about customers associated with claims that have the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to their respective policies, and then joins with the 'Customers' table to get customer details. The placeholder in the WHERE clause represents the minimum amount paid for claims.", "virtual_table": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)"}
{"sample_id": "train.1531", "db_id": "insurance_and_eClaims", "question": "Find the names of the customers who have an deputy policy.", "rationale": ["The query identifies the relevant tables, which are 'Policies' and 'Customers'.", "It uses a JOIN operation to link the 'Policies' table with the 'Customers' table based on the 'Customer_ID'.", "The SELECT DISTINCT statement is used to ensure that only unique customer details are retrieved.", "A condition is added to filter the results based on the 'Policy_Type_Code' using a placeholder for string values."], "gold_sql": "SELECT DISTINCT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.policy_type_code  =  'Deputy'", "source_tables": ["policies", "customers"], "description": "This virtual table provides a list of unique customer details from the 'Customers' table for those customers who hold a specific type of insurance policy. The placeholder in the WHERE clause represents the policy type code that is being queried.", "virtual_table": "SELECT DISTINCT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.policy_type_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1533", "db_id": "insurance_and_eClaims", "question": "Find the names of customers who either have an deputy policy or uniformed policy.", "rationale": ["The query identifies the relevant tables, which are 'Policies' and 'Customers'.", "It selects distinct customer details from the 'Customers' table.", "A JOIN operation is performed on the 'customer_id' to link policies to customers.", "The WHERE clause filters the results based on specific policy type codes using placeholders for string values."], "gold_sql": "SELECT DISTINCT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.policy_type_code  =  'Deputy' OR t1.policy_type_code  =  'Uniform'", "source_tables": ["policies", "customers"], "description": "This virtual table provides a list of distinct customer details from the 'Customers' table for customers who hold insurance policies of specific types. The placeholders in the WHERE clause represent the policy type codes that are being queried.", "virtual_table": "SELECT DISTINCT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.policy_type_code  =  [PLACEHOLDER-TYPE:STRING] OR t1.policy_type_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1546", "db_id": "insurance_and_eClaims", "question": "Find the customer who started a policy most recently.", "rationale": ["The query identifies the relevant tables, which are 'Policies' and 'Customers'.", "It selects the 'Customer_Details' from the 'Customers' table.", "A JOIN operation is performed on 'Policies' and 'Customers' using the 'Customer_ID' to link them.", "The WHERE clause filters the results to only include the customer details for the policy that has the maximum start date, using a subquery to find this date."], "gold_sql": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)", "source_tables": ["policies", "customers"], "description": "This virtual table retrieves the detailed information about customers who have the most recently started insurance policy from the 'Policies' table. The placeholder in the WHERE clause represents the condition to find the latest start date of the policy.", "virtual_table": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)"}
{"sample_id": "train.1553", "db_id": "customers_and_invoices", "question": "Show the id, the account name, and other account details for all accounts by the customer with first name 'Meaghan'.", "rationale": ["The query identifies the relevant tables, which are 'Accounts' and 'Customers'.", "It selects the columns to display from the 'Accounts' table: 'account_id', 'date_account_opened', 'account_name', and 'other_account_details'.", "A JOIN operation is performed between 'Accounts' and 'Customers' on the 'customer_id' to link accounts to their respective customers.", "A condition is added to filter the results based on the 'customer_first_name' from the 'Customers' table using a placeholder for string values."], "gold_sql": "SELECT T1.account_id ,  T1.date_account_opened ,  T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  'Meaghan'", "source_tables": ["accounts", "customers"], "description": "This virtual table provides details about customer accounts from the 'Accounts' table, including the account ID, the date the account was opened, the account name, and any additional account details. The results are filtered based on the first name of the customer from the 'Customers' table, represented by a placeholder for string values.", "virtual_table": "SELECT T1.account_id ,  T1.date_account_opened ,  T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1556", "db_id": "customers_and_invoices", "question": "What are the names and other details for accounts corresponding to the customer named Meaghan Keeling?", "rationale": ["The query identifies the relevant tables, which are 'Accounts' and 'Customers'.", "It selects the columns to display, 'account_name' and 'other_account_details' from the 'Accounts' table.", "A JOIN operation is performed to link 'Accounts' with 'Customers' based on the 'customer_id'.", "Conditions are added to filter the results based on the specified first and last names of the customer using placeholders for string values."], "gold_sql": "SELECT T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  'Meaghan' AND T2.customer_last_name  =  'Keeling'", "source_tables": ["accounts", "customers"], "description": "This virtual table describes the account names and additional details of accounts associated with customers from the 'Accounts' table, filtered by the first and last names of the customers. The placeholders in the WHERE clause represent the customer's first and last names.", "virtual_table": "SELECT T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  [PLACEHOLDER-TYPE:STRING] AND T2.customer_last_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1558", "db_id": "customers_and_invoices", "question": "What are the full names of customers with the account name 900?", "rationale": ["The query identifies the relevant tables, which are 'Accounts' and 'Customers'.", "It selects the columns to display, 'customer_first_name' and 'customer_last_name'.", "A JOIN operation is performed on 'customer_id' to link the two tables based on the relationship defined in the schema.", "A condition is added to filter the 'account_name' column for the specified account using a placeholder for string values."], "gold_sql": "SELECT T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T1.account_name  =  '900'", "source_tables": ["accounts", "customers"], "description": "This virtual table describes the first and last names of customers associated with a specific account from the 'Accounts' and 'Customers' tables. The placeholder in the WHERE clause represents the name of the account.", "virtual_table": "SELECT T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T1.account_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1568", "db_id": "customers_and_invoices", "question": "Return the id and full name of the customer with the most accounts.", "rationale": ["The query identifies the relevant tables, 'Accounts' and 'Customers'.", "It selects the 'customer_id', 'customer_first_name', and 'customer_last_name' columns to display.", "A JOIN operation is performed between 'Accounts' and 'Customers' on the 'customer_id' to link accounts to their respective customers.", "The results are grouped by 'customer_id' to aggregate the data for each customer.", "The results are ordered by the count of accounts in descending order to show the customers with the most accounts first.", "A LIMIT clause is included to restrict the number of results returned based on a placeholder for numeric values."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["accounts", "customers"], "description": "This virtual table provides a list of customer IDs along with their first and last names from the 'Customers' table, specifically for those customers who have accounts. The results are grouped by customer ID and ordered by the number of accounts each customer has, with a limit on the number of results returned based on a specified number.", "virtual_table": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1579", "db_id": "customers_and_invoices", "question": "How many transaction does each account have? Show the number and account id.", "rationale": ["The query identifies the relevant table, which is 'Financial_Transactions'.", "It selects a count of all transactions and groups them by 'account_id'.", "The use of count(*) allows for the aggregation of transaction records associated with each account."], "gold_sql": "SELECT count(*) ,  account_id FROM Financial_transactions", "source_tables": ["financial_transactions"], "description": "This virtual table provides a count of financial transactions grouped by account ID from the 'Financial_Transactions' table. The placeholder in the SELECT clause represents the account ID for which the transaction count is being retrieved.", "virtual_table": "SELECT count(*) ,  account_id FROM Financial_transactions"}
{"sample_id": "train.1589", "db_id": "customers_and_invoices", "question": "Show the account name, id and the number of transactions for each account.", "rationale": ["The query identifies the relevant tables, which are 'Financial_Transactions' and 'Accounts'.", "It selects the 'account_name' and 'account_id' from the 'Accounts' table.", "It counts the number of transactions for each account from the 'Financial_Transactions' table.", "The JOIN operation links the two tables based on the 'account_id' to ensure that the data corresponds correctly.", "Finally, the results are grouped by 'account_id' to aggregate the transaction counts for each account."], "gold_sql": "SELECT T2.account_name ,  T1.account_id ,  count(*) FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id GROUP BY T1.account_id", "source_tables": ["accounts", "financial_transactions"], "description": "This virtual table summarizes the total number of financial transactions associated with each account. It displays the account name and account ID from the 'Accounts' table, along with a count of transactions from the 'Financial_Transactions' table, grouped by account ID.", "virtual_table": "SELECT T2.account_name ,  T1.account_id ,  count(*) FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id GROUP BY T1.account_id"}
{"sample_id": "train.1599", "db_id": "customers_and_invoices", "question": "Show the invoice number and the number of transactions for each invoice.", "rationale": ["The query identifies the relevant table, which is 'Financial_Transactions'.", "Select the column 'invoice_number' to display the invoice associated with the transactions.", "Use the count function to aggregate the number of transactions for each invoice.", "Group the results by 'invoice_number' to get the count of transactions for each unique invoice."], "gold_sql": "SELECT invoice_number ,  count(*) FROM Financial_transactions GROUP BY invoice_number", "source_tables": ["financial_transactions"], "description": "This virtual table summarizes the total number of financial transactions associated with each invoice from the 'Financial_Transactions' table. The placeholder in the SELECT clause represents the invoice number, and the count function aggregates the number of transactions per invoice.", "virtual_table": "SELECT invoice_number ,  count(*) FROM Financial_transactions GROUP BY invoice_number"}
{"sample_id": "train.1602", "db_id": "customers_and_invoices", "question": "What is the invoice number and invoice date corresponding to the invoice with the greatest number of transactions?", "rationale": ["The query identifies the relevant tables, 'Financial_Transactions' and 'Invoices'.", "It selects the columns 'invoice_number' and 'invoice_date' from the 'Invoices' table.", "A JOIN operation is performed on the 'invoice_number' to link financial transactions with invoices.", "The results are grouped by 'invoice_number' to aggregate the count of transactions for each invoice.", "The results are ordered by the count of transactions in descending order to prioritize invoices with the most transactions.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T2.invoice_number ,  T2.invoice_date FROM Financial_transactions AS T1 JOIN Invoices AS T2 ON T1.invoice_number  =  T2.invoice_number GROUP BY T1.invoice_number ORDER BY count(*) DESC LIMIT 1", "source_tables": ["invoices", "financial_transactions"], "description": "This virtual table provides a list of invoice numbers and their corresponding invoice dates from the 'Invoices' table, filtered by the number of financial transactions associated with each invoice. The placeholder in the LIMIT clause represents the maximum number of records to return.", "virtual_table": "SELECT T2.invoice_number ,  T2.invoice_date FROM Financial_transactions AS T1 JOIN Invoices AS T2 ON T1.invoice_number  =  T2.invoice_number GROUP BY T1.invoice_number ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1617", "db_id": "customers_and_invoices", "question": "Show the order ids and the number of items in each order.", "rationale": ["The query identifies the relevant table, which is 'Order_Items'.", "Select the 'order_id' to group the results by each order.", "Use the count function to calculate the total number of items for each order, grouping the results by 'order_id' to get a summary of item counts per order."], "gold_sql": "SELECT order_id ,  count(*) FROM Order_items GROUP BY order_id", "source_tables": ["order_items"], "description": "This virtual table summarizes the total number of items in each order from the 'Order_Items' table. The placeholder in the SELECT clause represents the unique identifier for each order, while the count function calculates the total number of items associated with each order.", "virtual_table": "SELECT order_id ,  count(*) FROM Order_items GROUP BY order_id"}
{"sample_id": "train.2049", "db_id": "party_people", "question": "Show all ministers who do not belong to Progress Party.", "rationale": ["The query identifies the relevant table, which is 'party'.", "Select the column to display, 'minister'.", "Add a condition to filter the 'party_name' column to exclude a specific party using a placeholder for string values."], "gold_sql": "SELECT minister FROM party WHERE party_name != 'Progress Party'", "source_tables": ["party"], "description": "This virtual table describes the ministers associated with political parties from the 'party' table, excluding a specific party name. The placeholder in the WHERE clause represents the name of the party to be excluded.", "virtual_table": "SELECT minister FROM party WHERE party_name != [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2058", "db_id": "party_people", "question": "How many members are in each party?", "rationale": ["The query identifies the relevant tables, which are 'Member' and 'Party'.", "It selects the 'party_name' from the 'Party' table and counts the number of members from the 'Member' table.", "A JOIN operation is performed on the 'party_id' to link members to their respective parties.", "The results are grouped by 'party_id' to aggregate the count of members for each party."], "gold_sql": "SELECT T2.party_name ,  count(*) FROM Member AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id", "source_tables": ["party", "member"], "description": "This virtual table summarizes the number of members associated with each political party from the 'Member' and 'Party' tables. The placeholder in the SELECT statement allows for the retrieval of the party name and the count of members belonging to that party.", "virtual_table": "SELECT T2.party_name ,  count(*) FROM Member AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id"}
{"sample_id": "train.2071", "db_id": "party_people", "question": "Show party names and the number of events for each party.", "rationale": ["The query identifies the relevant tables, which are 'party_events' and 'party'.", "It uses a JOIN operation to connect 'party_events' with 'party' based on the 'party_id'.", "The SELECT statement retrieves the 'party_name' from the 'party' table and counts the number of events from the 'party_events' table.", "The GROUP BY clause is used to group the results by 'party_id' to get the count of events for each party."], "gold_sql": "SELECT T2.party_name ,  count(*) FROM party_events AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id", "source_tables": ["party", "party_events"], "description": "This virtual table summarizes the number of events organized by each political party from the 'party_events' table. It joins the 'party' table to retrieve the party names associated with the events. The placeholder in the SELECT statement represents the party name, while the count function aggregates the total number of events for each party.", "virtual_table": "SELECT T2.party_name ,  count(*) FROM party_events AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id"}
{"sample_id": "train.2081", "db_id": "party_people", "question": "How many Annual Meeting events happened in the United Kingdom region?", "rationale": ["The query identifies the relevant tables: 'region', 'party', and 'party_events'.", "It uses JOIN operations to connect these tables based on their foreign key relationships: 'region_id' from 'party' and 'party_id' from 'party_events'.", "The SELECT statement counts the total number of events that match the specified criteria.", "The WHERE clause filters the results based on the 'region_name' and 'Event_Name', using placeholders for these string values."], "gold_sql": "SELECT count(*) FROM region AS t1 JOIN party AS t2 ON t1.region_id  =  t2.region_id JOIN party_events AS t3 ON t2.party_id  =  t3.party_id WHERE t1.region_name  =  'United Kingdom' AND t3.Event_Name  =  'Annaual Meeting'", "source_tables": ["party", "party_events", "region"], "description": "This virtual table provides a count of party events associated with a specific region and event name. It joins the 'region', 'party', and 'party_events' tables to filter the results based on the specified region name and event name. The placeholders in the WHERE clause represent the region's name and the event's name.", "virtual_table": "SELECT count(*) FROM region AS t1 JOIN party AS t2 ON t1.region_id  =  t2.region_id JOIN party_events AS t3 ON t2.party_id  =  t3.party_id WHERE t1.region_name  =  [PLACEHOLDER-TYPE:STRING] AND t3.Event_Name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2176", "db_id": "formula_1", "question": "What are the names and years of all races that had a driver with the last name Lewis?", "rationale": ["The query identifies the relevant tables: 'results', 'races', and 'drivers'.", "It selects the 'name' and 'year' columns from the 'races' table.", "The JOIN operation connects the 'results' table with the 'races' table using the 'raceId' and with the 'drivers' table using the 'driverId'.", "A condition is added to filter the results based on the driver's first name using a placeholder for string values."], "gold_sql": "SELECT T2.name ,  T2.year FROM results AS T1 JOIN races AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T1.driverid = T3.driverid WHERE T3.forename = 'Lewis'", "source_tables": ["results", "drivers", "races"], "description": "This virtual table describes the names and years of races from the 'races' table that a specific driver participated in. The placeholder in the WHERE clause represents the driver's first name.", "virtual_table": "SELECT T2.name ,  T2.year FROM results AS T1 JOIN races AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T1.driverid = T3.driverid WHERE T3.forename = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2182", "db_id": "formula_1", "question": "What are the first and last names of all drivers who participated in the Australian Grand Prix but not the Chinese Grand Prix?", "rationale": ["The query identifies the relevant tables: 'races', 'results', and 'drivers'.", "It selects the 'forename' and 'surname' columns from the 'drivers' table.", "The JOIN operations link the 'races' table to the 'results' table and the 'results' table to the 'drivers' table based on their respective IDs.", "The first part of the query filters drivers based on the name of a specific race using a placeholder for string values.", "The EXCEPT clause is used to exclude drivers who participated in another specified race, which is also filtered by a placeholder for string values."], "gold_sql": "SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Australian Grand Prix' EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Chinese Grand Prix'", "source_tables": ["races", "drivers", "results"], "description": "This virtual table describes the first and last names of drivers who participated in a specific race, excluding those who also participated in another specified race. The placeholders in the WHERE clause represent the names of the races.", "virtual_table": "SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2183", "db_id": "formula_1", "question": "Find all the forenames of distinct drivers who was in position 1 as standing and won?", "rationale": ["The query identifies the relevant tables, which are 'drivers' and 'driverStandings'.", "It selects distinct first names from the 'drivers' table.", "A JOIN operation is performed between 'drivers' and 'driverStandings' on the driver ID to correlate driver information with their standings.", "Conditions are added to filter the results based on the specified position and number of wins using placeholders for numeric values."], "gold_sql": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = 1 AND T2.wins = 1", "source_tables": ["drivers", "driverstandings"], "description": "This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.", "virtual_table": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = [PLACEHOLDER-TYPE:NUMBER] AND T2.wins = [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2185", "db_id": "formula_1", "question": "Find all the forenames of distinct drivers who won in position 1 as driver standing and had more than 20 points?", "rationale": ["The query identifies the relevant tables, which are 'drivers' and 'driverStandings'.", "It selects distinct first names from the 'drivers' table.", "A JOIN operation is performed between 'drivers' and 'driverStandings' on the driver ID to combine relevant data.", "Conditions are added to filter results based on the driver's position, number of wins, and points using placeholders for numeric values."], "gold_sql": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = 1 AND T2.wins = 1 AND T2.points > 20", "source_tables": ["drivers", "driverstandings"], "description": "This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have a specific position in the standings, a certain number of wins, and more points than a specified threshold. The placeholders in the WHERE clause represent the position, number of wins, and points criteria.", "virtual_table": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = [PLACEHOLDER-TYPE:NUMBER] AND T2.wins = [PLACEHOLDER-TYPE:NUMBER] AND T2.points > [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2186", "db_id": "formula_1", "question": "What are the first names of the different drivers who won in position 1 as driver standing and had more than 20 points?", "rationale": ["The query identifies the relevant tables, which are 'drivers' and 'driverStandings'.", "It selects distinct first names from the 'drivers' table.", "A JOIN operation is performed between 'drivers' and 'driverStandings' on the driver ID to combine relevant data.", "Conditions are added to filter results based on the driver's position, number of wins, and points scored, using placeholders for numeric values."], "gold_sql": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = 1 AND T2.wins = 1 AND T2.points > 20", "source_tables": ["drivers", "driverstandings"], "description": "This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have a specific position in the standings, a certain number of wins, and have scored more points than a specified threshold. The placeholders in the WHERE clause represent the position, number of wins, and points criteria.", "virtual_table": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = [PLACEHOLDER-TYPE:NUMBER] AND T2.wins = [PLACEHOLDER-TYPE:NUMBER] AND T2.points > [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2189", "db_id": "formula_1", "question": "What are the numbers of races for each constructor id?", "rationale": ["The query is identifying the relevant table, which is 'constructorStandings'.", "The SELECT statement is counting the number of entries for each constructor using 'count(*)'.", "The GROUP BY clause is used to aggregate the results by 'constructorid', allowing us to see the total standings for each constructor."], "gold_sql": "SELECT count(*) ,  constructorid FROM constructorStandings GROUP BY constructorid", "source_tables": ["constructorstandings"], "description": "This virtual table provides a count of the total number of constructor standings for each constructor from the 'constructorStandings' table. The placeholder in the SELECT statement represents the constructor's identifier, which is grouped to show the total standings for each constructor.", "virtual_table": "SELECT count(*) ,  constructorid FROM constructorStandings GROUP BY constructorid"}
{"sample_id": "train.2218", "db_id": "formula_1", "question": "What are the names of all the Japanese constructors that have earned more than 5 points?", "rationale": ["The query identifies the relevant tables, which are 'constructors' and 'constructorStandings'.", "It selects the 'name' column from the 'constructors' table.", "A JOIN operation is performed between 'constructors' and 'constructorStandings' on the 'constructorId' to link constructors with their standings.", "Conditions are added to filter constructors by their nationality using a placeholder for string values and by their points using a placeholder for numeric values."], "gold_sql": "SELECT T1.name FROM constructors AS T1 JOIN constructorstandings AS T2 ON T1.constructorid = T2.constructorid WHERE T1.nationality = 'Japanese' AND T2.points > 5", "source_tables": ["constructorstandings", "constructors"], "description": "This virtual table lists the names of constructors from the 'constructors' table who have a specific nationality and have scored more than a certain number of points in the constructor standings. The placeholders in the WHERE clause represent the constructor's nationality and the points threshold.", "virtual_table": "SELECT T1.name FROM constructors AS T1 JOIN constructorstandings AS T2 ON T1.constructorid = T2.constructorid WHERE T1.nationality = [PLACEHOLDER-TYPE:STRING] AND T2.points > [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2220", "db_id": "formula_1", "question": "What is the average fastest lap speed for the Monaco Grand Prix in 2008?", "rationale": ["The query identifies the relevant tables, which are 'races' and 'results'.", "It joins the 'races' table with the 'results' table on the race identifier to correlate race data with results.", "The SELECT statement computes the average of the 'fastestLapSpeed' from the 'results' table.", "A condition is added to filter the results based on the specified year and race name using placeholders for numeric and string values."], "gold_sql": "SELECT avg(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "description": "This virtual table calculates the average fastest lap speed from the 'results' table for races that occurred in a specific year and have a particular name. The placeholders in the WHERE clause represent the year of the race and the name of the race.", "virtual_table": "SELECT avg(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T1.name = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2221", "db_id": "formula_1", "question": "What is the maximum fastest lap speed in race named 'Monaco Grand Prix' in 2008 ?", "rationale": ["The query identifies the relevant tables, which are 'races' and 'results'.", "It selects the maximum value of 'fastestLapSpeed' from the 'results' table.", "A JOIN operation is performed between 'races' and 'results' on the 'raceId' to correlate race details with their results.", "Conditions are added to filter the results based on the specified year and race name using placeholders for numeric and string values."], "gold_sql": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "description": "This virtual table provides the maximum fastest lap speed recorded during races held in a specific year and with a specific race name. The placeholders in the WHERE clause represent the year of the race and the official name of the race.", "virtual_table": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T1.name = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2222", "db_id": "formula_1", "question": "What is the maximum fastest lap speed in the Monaco Grand Prix in 2008?", "rationale": ["The query identifies the relevant tables, which are 'races' and 'results'.", "It selects the maximum value of 'fastestLapSpeed' from the 'results' table.", "A JOIN operation is performed between 'races' and 'results' on the 'raceId' to correlate race details with results.", "Conditions are added to filter the results based on the specified year and race name using placeholders for numeric and string values."], "gold_sql": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "description": "This virtual table provides the maximum fastest lap speed recorded during races in a specific year and for a specific race name. The placeholders in the WHERE clause represent the year of the race and the official name of the race.", "virtual_table": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T1.name = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2224", "db_id": "formula_1", "question": "For each race name, What is the maximum fastest lap speed for races after 2004 ordered by year?", "rationale": ["The query identifies the relevant tables, which are 'races' and 'results'.", "It selects the maximum fastest lap speed from the 'results' table and the race name and year from the 'races' table.", "A JOIN operation is performed on the raceId to combine data from both tables.", "A condition is added to filter races that occurred after a specified year using a placeholder for numeric values.", "The results are grouped by race name to ensure unique entries for each race, and ordered by year to present the data chronologically."], "gold_sql": "SELECT max(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "description": "This virtual table provides the maximum fastest lap speed recorded for each race, along with the official name of the race and the year it took place. The placeholder in the WHERE clause represents the year threshold for filtering the races.", "virtual_table": "SELECT max(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.name ORDER BY T1.year"}
{"sample_id": "train.2225", "db_id": "formula_1", "question": "What are the average fastest lap speed in races held after 2004 grouped by race name and ordered by year?", "rationale": ["The query identifies the relevant tables, 'races' and 'results'.", "It selects the average fastest lap speed from the 'results' table and the race name and year from the 'races' table.", "A JOIN operation is performed on the raceId to combine data from both tables.", "A condition is added to filter the results based on the year using a placeholder for numeric values.", "The results are grouped by race name and ordered by year."], "gold_sql": "SELECT avg(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "description": "This virtual table provides the average fastest lap speed of races from the 'races' table, grouped by the race name and year. The placeholder in the WHERE clause represents the year threshold, allowing users to filter races that occurred after a specific year.", "virtual_table": "SELECT avg(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.name ORDER BY T1.year"}
{"sample_id": "train.2226", "db_id": "formula_1", "question": "What is the average fastest lap speed for races held after 2004, for each race, ordered by year?", "rationale": ["The query identifies the relevant tables, which are 'races' and 'results'.", "It selects the average fastest lap speed from the 'results' table and the race name and year from the 'races' table.", "A JOIN operation is performed on the raceId to combine data from both tables.", "A condition is added to filter the results for races that occurred after a specified year using a placeholder for numeric values.", "The results are grouped by race name and ordered by year."], "gold_sql": "SELECT avg(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "description": "This virtual table provides the average fastest lap speed of races from the 'races' table, grouped by the race name and year. The placeholder in the WHERE clause represents a specific year, allowing users to filter for races that occurred after that year.", "virtual_table": "SELECT avg(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.name ORDER BY T1.year"}
{"sample_id": "train.2243", "db_id": "machine_repair", "question": "What is the starting year of the oldest technicians?", "rationale": ["The query identifies the relevant table, which is 'technician'.", "Select the column to display, 'Starting_Year'.", "Order the results by the 'Age' column in descending order to show the oldest technicians first.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT Starting_Year FROM technician ORDER BY Age DESC LIMIT 1", "source_tables": ["technician"], "description": "This virtual table provides the starting years of technicians from the 'technician' table, ordered by their age in descending order. The placeholder in the LIMIT clause represents the maximum number of records to return.", "virtual_table": "SELECT Starting_Year FROM technician ORDER BY Age DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2248", "db_id": "machine_repair", "question": "What are the teams with the most technicians?", "rationale": ["The query identifies the relevant table, which is 'technician'.", "It selects the 'Team' column to display the teams of technicians.", "The GROUP BY clause is used to group the results by the 'Team' column.", "The ORDER BY clause sorts the teams based on the count of technicians in each team in descending order.", "The LIMIT clause uses a placeholder to specify how many teams to return."], "gold_sql": "SELECT Team FROM technician GROUP BY Team ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["technician"], "description": "This virtual table provides a list of technician teams from the 'technician' table, grouped by team and ordered by the number of technicians in each team. The placeholder in the LIMIT clause allows for specifying the maximum number of teams to display.", "virtual_table": "SELECT Team FROM technician GROUP BY Team ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2258", "db_id": "machine_repair", "question": "What are the names of the technicians  and how many machines are they assigned to repair?", "rationale": ["The query identifies the relevant tables, which are 'repair_assignment' and 'technician'.", "It selects the 'Name' column from the 'technician' table and counts the number of repair assignments for each technician.", "The JOIN operation connects the 'repair_assignment' table with the 'technician' table based on the technician's ID.", "The GROUP BY clause is used to aggregate the results by technician's name, allowing for the count of tasks per technician."], "gold_sql": "SELECT T2.Name ,  COUNT(*) FROM repair_assignment AS T1 JOIN technician AS T2 ON T1.technician_ID  =  T2.technician_ID GROUP BY T2.Name", "source_tables": ["repair_assignment", "technician"], "description": "This virtual table provides the names of technicians along with the count of repair tasks they have been assigned to. The data is aggregated from the 'repair_assignment' table, which links technicians to their respective repair tasks, and the 'technician' table, which contains the details of each technician.", "virtual_table": "SELECT T2.Name ,  COUNT(*) FROM repair_assignment AS T1 JOIN technician AS T2 ON T1.technician_ID  =  T2.technician_ID GROUP BY T2.Name"}
{"sample_id": "train.2328", "db_id": "csu_1", "question": "Find all the campuses opened in 1958.", "rationale": ["The query is identifying the relevant table, which is 'Campuses'.", "Select the column to display, 'Campus'.", "Add a condition to filter the 'Year' column for the specified year using a placeholder for numeric values."], "gold_sql": "SELECT campus FROM campuses WHERE YEAR  =  1958", "source_tables": ["campuses"], "description": "This virtual table describes the names of campuses from the 'Campuses' table that have records for a specific year. The placeholder in the WHERE clause represents the year for which the campus data is being queried.", "virtual_table": "SELECT campus FROM campuses WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2334", "db_id": "csu_1", "question": "Find the name of the campuses that is in Northridge, Los Angeles or in San Francisco, San Francisco.", "rationale": ["The query identifies the relevant table, which is 'Campuses'.", "It selects the 'Campus' column to display the names of the campuses.", "The query includes conditions to filter the 'Location' and 'County' columns for specified values using placeholders for string values.", "The UNION operator is used to combine results from two identical selections, allowing for flexibility in filtering."], "gold_sql": "SELECT campus FROM campuses WHERE LOCATION  =  'Northridge' AND county  =  'Los Angeles' UNION SELECT campus FROM campuses WHERE LOCATION  =  'San Francisco' AND county  =  'San Francisco'", "source_tables": ["campuses"], "description": "This virtual table retrieves the names of campuses located in a specific geographical location and county. The query combines results from two identical selections, allowing for the possibility of filtering by different criteria in the future. The placeholders in the WHERE clauses represent the location and county names.", "virtual_table": "SELECT campus FROM campuses WHERE LOCATION  =  [PLACEHOLDER-TYPE:STRING] AND county  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT campus FROM campuses WHERE LOCATION  =  [PLACEHOLDER-TYPE:STRING] AND county  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2350", "db_id": "csu_1", "question": "Which campus has the most faculties in year 2003?", "rationale": ["The query identifies the relevant tables, 'Campuses' and 'faculty'.", "It selects the 'campus' column from the 'Campuses' table.", "A JOIN operation is performed between 'Campuses' and 'faculty' on the campus identifier to combine data from both tables.", "A condition is added to filter the results based on the specified year using a placeholder for numeric values.", "The results are ordered by the number of faculty members in descending order.", "A LIMIT clause is included to restrict the number of returned campuses based on a specified number."], "gold_sql": "SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  2003 ORDER BY T2.faculty DESC LIMIT 1", "source_tables": ["faculty", "campuses"], "description": "This virtual table lists the campuses from the 'Campuses' table that have faculty data for a specific year. The campuses are ordered by the number of faculty members in descending order, and the result is limited to a specified number of campuses. The placeholders in the WHERE clause and LIMIT clause represent the year of the faculty data and the maximum number of campuses to return, respectively.", "virtual_table": "SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY T2.faculty DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2356", "db_id": "csu_1", "question": "report the total number of degrees granted between 1998 and 2002.", "rationale": ["The query identifies the relevant tables, 'Campuses' and 'degrees'.", "It selects the 'campus' from the 'Campuses' table and sums the 'degrees' from the 'degrees' table.", "A JOIN operation is performed on the 'Campus' identifier to link the two tables.", "The WHERE clause filters the results based on a specified range of years using placeholders for numeric values.", "The results are grouped by 'campus' to provide a total count of degrees awarded per campus."], "gold_sql": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  1998 AND T2.year  <=  2002 GROUP BY T1.campus", "source_tables": ["degrees", "campuses"], "description": "This virtual table summarizes the total number of degrees awarded for each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.", "virtual_table": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.year  <=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus"}
{"sample_id": "train.2359", "db_id": "csu_1", "question": "What is the total number of degrees granted after 2000 for each Orange county campus?", "rationale": ["The query identifies the relevant tables, 'Campuses' and 'degrees'.", "It selects the 'campus' from the 'Campuses' table and sums the 'degrees' from the 'degrees' table.", "A JOIN operation is performed on the 'Campus' identifier to link the two tables.", "Conditions are added to filter the results based on the specified county and the year using placeholders for string and numeric values.", "The results are grouped by campus to aggregate the total degrees awarded."], "gold_sql": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  'Orange' AND T2.year  >=  2000 GROUP BY T1.campus", "source_tables": ["degrees", "campuses"], "description": "This virtual table summarizes the total number of degrees awarded by each campus located in a specific county, filtering for degrees awarded from a certain year onwards. The placeholders in the WHERE clause represent the county name and the year threshold.", "virtual_table": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  [PLACEHOLDER-TYPE:STRING] AND T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus"}
{"sample_id": "train.2362", "db_id": "csu_1", "question": "What campus had more than 400 total enrollment but more than 200 full time enrollment in year 1956?", "rationale": ["The query identifies the relevant tables, which are 'Campuses' and 'enrollments'.", "It selects the 'campus' column from the 'Campuses' table.", "A JOIN operation is performed between 'Campuses' and 'enrollments' on the campus identifier.", "Conditions are added to filter the results based on the specified year, total enrollment, and full-time equivalent enrollment using placeholders for numeric values."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN enrollments AS t2 ON t1.id  =  t2.campus WHERE t2.year  =  1956 AND totalenrollment_ay  >  400 AND FTE_AY  >  200", "source_tables": ["enrollments", "campuses"], "description": "This virtual table identifies campuses from the 'Campuses' table that have a specific number of total enrollments and full-time equivalent enrollments for a given academic year. The placeholders in the WHERE clause represent the year, total enrollment threshold, and full-time equivalent enrollment threshold.", "virtual_table": "SELECT T1.campus FROM campuses AS t1 JOIN enrollments AS t2 ON t1.id  =  t2.campus WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] AND totalenrollment_ay  >  [PLACEHOLDER-TYPE:NUMBER] AND FTE_AY  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2363", "db_id": "csu_1", "question": "What campus started in year 1956, has more than 200 full time students, and more than 400 students enrolled?", "rationale": ["The query identifies the relevant tables, 'Campuses' and 'enrollments'.", "It selects the 'campus' column from the 'Campuses' table.", "A JOIN operation is performed between 'Campuses' and 'enrollments' on the campus identifier.", "Conditions are added to filter the results based on the specified year and thresholds for total and full-time equivalent enrollments using placeholders for numeric values."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN enrollments AS t2 ON t1.id  =  t2.campus WHERE t2.year  =  1956 AND totalenrollment_ay  >  400 AND FTE_AY  >  200", "source_tables": ["enrollments", "campuses"], "description": "This virtual table lists the campuses from the 'Campuses' table that have total enrollments exceeding a specified number and full-time equivalent enrollments exceeding another specified number for a given academic year. The placeholders in the WHERE clause represent the year, total enrollment threshold, and full-time equivalent enrollment threshold.", "virtual_table": "SELECT T1.campus FROM campuses AS t1 JOIN enrollments AS t2 ON t1.id  =  t2.campus WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] AND totalenrollment_ay  >  [PLACEHOLDER-TYPE:NUMBER] AND FTE_AY  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2366", "db_id": "csu_1", "question": "List the campuses in Los Angeles county.", "rationale": ["The query is identifying the relevant table, which is 'Campuses'.", "Select the column to display, 'campus'.", "Add a condition to filter the 'county' column for the specified county using a placeholder for string values."], "gold_sql": "SELECT campus FROM campuses WHERE county  =  'Los Angeles'", "source_tables": ["campuses"], "description": "This virtual table describes the campuses located in a specific county from the 'Campuses' table. The placeholder in the WHERE clause represents the name of the county.", "virtual_table": "SELECT campus FROM campuses WHERE county  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2368", "db_id": "csu_1", "question": "How many degrees were conferred in \"San Jose State University\" in 2000?", "rationale": ["The query identifies the relevant tables, 'Campuses' and 'degrees'.", "It selects the 'Degrees' column from the 'degrees' table.", "A JOIN operation is performed to link 'Campuses' and 'degrees' based on the campus identifier.", "Conditions are added to filter results for a specific campus and year using placeholders for string and numeric values."], "gold_sql": "SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  'San Jose State University' AND t2.year  =  2000", "source_tables": ["degrees", "campuses"], "description": "This virtual table describes the types of degrees awarded at a specific campus for a given year. The placeholders in the WHERE clause represent the campus name and the year of the degrees awarded.", "virtual_table": "SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  [PLACEHOLDER-TYPE:STRING] AND t2.year  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2374", "db_id": "csu_1", "question": "What is the number of faculty lines in campus \"Long Beach State University\" in 2002?", "rationale": ["The query identifies the relevant tables, which are 'faculty' and 'campuses'.", "It selects the 'faculty' column to display the number of faculty members.", "A JOIN operation is performed to link the 'faculty' table with the 'campuses' table based on the campus identifier.", "Conditions are added to filter the results by a specific year and campus name using placeholders for numeric and string values."], "gold_sql": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  2002 AND T2.campus  =  'Long Beach State University'", "source_tables": ["faculty", "campuses"], "description": "This virtual table provides the number of faculty members from the 'faculty' table for a specific campus and year. The placeholders in the WHERE clause represent the year of the faculty data record and the name of the campus.", "virtual_table": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] AND T2.campus  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2376", "db_id": "csu_1", "question": "How many faculty lines are there in \"San Francisco State University\" in year 2004?", "rationale": ["The query identifies the relevant tables, which are 'faculty' and 'campuses'.", "It selects the 'faculty' column to display the number of faculty members.", "A JOIN operation is performed to link the 'faculty' table with the 'campuses' table based on the campus identifier.", "Conditions are added to filter the results by a specific year and campus name using placeholders for numeric and string values."], "gold_sql": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  2004 AND T2.campus  =  'San Francisco State University'", "source_tables": ["faculty", "campuses"], "description": "This virtual table provides the number of faculty members from the 'faculty' table for a specific campus and year. The placeholders in the WHERE clause represent the year of the faculty data record and the name of the campus.", "virtual_table": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] AND T2.campus  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2377", "db_id": "csu_1", "question": "How many faculty lines are there at San Francisco State University in 2004?", "rationale": ["The query identifies the relevant tables, which are 'faculty' and 'campuses'.", "It selects the 'faculty' column to display the number of faculty members.", "A JOIN operation is performed to link the 'faculty' table with the 'campuses' table based on the campus identifier.", "Conditions are added to filter the results by a specific year and campus name using placeholders for numeric and string values."], "gold_sql": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  2004 AND T2.campus  =  'San Francisco State University'", "source_tables": ["faculty", "campuses"], "description": "This virtual table provides the number of faculty members from the 'faculty' table for a specific campus and year. The placeholders in the WHERE clause represent the year of the faculty data record and the name of the campus.", "virtual_table": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] AND T2.campus  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2381", "db_id": "csu_1", "question": "How many faculty members did the university that conferred the most degrees in 2002 have?", "rationale": ["The query identifies the relevant tables: 'campuses', 'faculty', and 'degrees'.", "It selects the 'faculty' column from the 'faculty' table.", "The query joins the 'campuses' table with the 'faculty' table on the campus identifier to link faculty data to the respective campus.", "It also joins the 'degrees' table to ensure that the faculty data corresponds to the same year as the degrees awarded.", "A condition is added to filter the results by a specific year using a placeholder for numeric values.", "The results are ordered by the number of degrees awarded in descending order and limited to a specified number of records using placeholders."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2002 ORDER BY t3.degrees DESC LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "description": "This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to associate each faculty record with its corresponding campus and also joins the 'degrees' table to ensure that the faculty data corresponds to the same year as the degrees awarded. The results are ordered by the number of degrees awarded in descending order, and the output is limited to a specified number of records.", "virtual_table": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2382", "db_id": "csu_1", "question": "How many faculty lines are there in the university that conferred the least number of degrees in year 2001?", "rationale": ["The query identifies the relevant tables: 'campuses', 'faculty', and 'degrees'.", "It selects the 'faculty' column from the 'faculty' table.", "The query joins the 'campuses' table with the 'faculty' table on the campus identifier and also joins with the 'degrees' table to ensure that the faculty data corresponds to the year when degrees were awarded.", "A condition is added to filter the results based on a specific year using a placeholder for numeric values.", "The results are ordered by the 'degrees' column and limited to a specified number of results using a placeholder."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2001 ORDER BY t3.degrees LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "description": "This virtual table provides the number of faculty members from the 'faculty' table for campuses that have awarded degrees in a specific year. The query joins the 'campuses' table with the 'faculty' and 'degrees' tables based on the campus identifier and filters the results for a particular year. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the year and the number of results to return.", "virtual_table": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2383", "db_id": "csu_1", "question": "How many faculty members are at the university that gave the least number of degrees in 2001?", "rationale": ["The query identifies the relevant tables: 'campuses', 'faculty', and 'degrees'.", "It selects the 'faculty' column from the 'faculty' table.", "The query joins the 'campuses' table with the 'faculty' table on the campus identifier, and also joins with the 'degrees' table to ensure the year matches.", "A condition is added to filter the results based on a specific year using a placeholder for numeric values.", "The results are ordered by the 'degrees' column and limited to a specified number using a placeholder."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2001 ORDER BY t3.degrees LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "description": "This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to associate campuses with their respective faculty data and the 'degrees' table to ensure that the faculty data corresponds to the same year as the degrees awarded. The placeholders in the WHERE clause represent the year of interest and the limit for the number of results returned.", "virtual_table": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2385", "db_id": "csu_1", "question": "How many undergraduates are there at San Jose State", "rationale": ["The query identifies the relevant tables, 'discipline_enrollments' and 'campuses'.", "It uses a JOIN operation to combine data from both tables based on the campus identifier.", "The SUM function is applied to the 'undergraduate' column to calculate the total number of undergraduate enrollments.", "Conditions are added to filter the results by the specified year and campus name using placeholders for numeric and string values."], "gold_sql": "SELECT sum(t1.undergraduate) FROM discipline_enrollments AS t1 JOIN campuses AS t2 ON t1.campus  =  t2.id WHERE t1.year  =  2004 AND t2.campus  =  'San Jose State University'", "source_tables": ["discipline_enrollments", "campuses"], "description": "This virtual table calculates the total number of undergraduate enrollments from the 'discipline_enrollments' table for a specific campus and year. The placeholders in the WHERE clause represent the year of enrollment and the name of the campus.", "virtual_table": "SELECT sum(t1.undergraduate) FROM discipline_enrollments AS t1 JOIN campuses AS t2 ON t1.campus  =  t2.id WHERE t1.year  =  [PLACEHOLDER-TYPE:NUMBER] AND t2.campus  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2397", "db_id": "candidate_poll", "question": "Return the poll resource associated with the most candidates.", "rationale": ["The query identifies the relevant table, which is 'candidate'.", "It selects the 'poll_source' column to display the different sources of poll data.", "The GROUP BY clause is used to group the results by 'poll_source'.", "The ORDER BY clause sorts the grouped results by their count in descending order to show the most common sources first.", "The LIMIT clause includes a placeholder to allow the user to specify how many poll sources they want to retrieve."], "gold_sql": "SELECT poll_source FROM candidate GROUP BY poll_source ORDER BY count(*) DESC LIMIT 1", "source_tables": ["candidate"], "description": "This virtual table provides a list of poll sources from the 'candidate' table, grouped by the source and ordered by the number of occurrences. The placeholder in the LIMIT clause allows the user to specify the maximum number of poll sources to retrieve.", "virtual_table": "SELECT poll_source FROM candidate GROUP BY poll_source ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2405", "db_id": "candidate_poll", "question": "Return the poll source corresponding to the candidate who has the oppose rate.", "rationale": ["The query identifies the relevant table, which is 'candidate'.", "Select the column to display, 'poll_source'.", "Add an ORDER BY clause to sort the results based on 'oppose_rate' in descending order.", "Include a LIMIT clause with a placeholder to specify the maximum number of results to return."], "gold_sql": "SELECT poll_source FROM candidate ORDER BY oppose_rate DESC LIMIT 1", "source_tables": ["candidate"], "description": "This virtual table provides a list of poll sources from the 'candidate' table, ordered by the opposition rate in descending order. The placeholder in the LIMIT clause indicates the maximum number of poll sources to return.", "virtual_table": "SELECT poll_source FROM candidate ORDER BY oppose_rate DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2417", "db_id": "candidate_poll", "question": "For each sex, what is the name and sex of the candidate with the oppose rate for their sex?", "rationale": ["The query identifies the relevant tables, 'people' and 'candidate', and establishes a join between them based on the 'People_ID'.", "It selects the 'name' and 'sex' from the 'people' table and calculates the minimum 'oppose_rate' from the 'candidate' table.", "The results are grouped by 'sex' to provide the minimum opposition rate for each gender."], "gold_sql": "SELECT t1.name ,  t1.sex ,  min(oppose_rate) FROM people AS t1 JOIN candidate AS t2 ON t1.people_id  =  t2.people_id GROUP BY t1.sex", "source_tables": ["candidate", "people"], "description": "This virtual table provides the names and genders of individuals from the 'people' table, along with the minimum opposition rate from the 'candidate' table for each gender. The data is aggregated by gender, allowing for a comparison of the lowest opposition rates among different genders.", "virtual_table": "SELECT t1.name ,  t1.sex ,  min(oppose_rate) FROM people AS t1 JOIN candidate AS t2 ON t1.people_id  =  t2.people_id GROUP BY t1.sex"}
{"sample_id": "train.2434", "db_id": "movie_1", "question": "Find the titles of all movies directed by steven spielberg.", "rationale": ["The query identifies the relevant table, which is 'Movie'.", "Select the column to display, 'title'.", "Add a condition to filter the 'director' column for the specified director using a placeholder for string values."], "gold_sql": "SELECT title FROM Movie WHERE director = 'Steven Spielberg'", "source_tables": ["movie"], "description": "This virtual table describes the titles of movies from the 'Movie' table that were directed by a specific director. The placeholder in the WHERE clause represents the director's name.", "virtual_table": "SELECT title FROM Movie WHERE director = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2461", "db_id": "movie_1", "question": "What are the different names of all reviewers whose ratings do not have a date field?", "rationale": ["The query identifies the relevant tables, which are 'Reviewer' and 'Rating'.", "It selects distinct names from the 'Reviewer' table to avoid duplicates.", "The join condition links the 'Reviewer' table to the 'Rating' table using the reviewer's ID.", "A condition is added to filter the results based on the 'ratingDate' using a placeholder for string values."], "gold_sql": "SELECT DISTINCT name FROM Reviewer AS T1 JOIN Rating AS T2 ON T1.rID  =  T2.rID WHERE ratingDate  =  'null'", "source_tables": ["rating", "reviewer"], "description": "This virtual table lists the distinct names of reviewers who submitted ratings on a specific date. The query joins the 'Reviewer' and 'Rating' tables based on the reviewer's ID, filtering the results by the date of the rating submission.", "virtual_table": "SELECT DISTINCT name FROM Reviewer AS T1 JOIN Rating AS T2 ON T1.rID  =  T2.rID WHERE ratingDate  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2476", "db_id": "movie_1", "question": "Find the names of all reviewers who rated Gone with the Wind.", "rationale": ["The query identifies the relevant tables: 'Rating', 'Movie', and 'Reviewer'.", "It selects distinct reviewer names from the 'Reviewer' table.", "The JOIN operations link the 'Rating' table to the 'Movie' table using the movie ID, and to the 'Reviewer' table using the reviewer ID.", "A condition is added to filter the results based on the specified movie title using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T3.name FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID JOIN Reviewer AS T3 ON T1.rID  =  T3.rID WHERE T2.title  =  'Gone with the Wind'", "source_tables": ["rating", "movie", "reviewer"], "description": "This virtual table lists the distinct names of reviewers who have rated a specific movie from the 'Movie' table. The placeholder in the WHERE clause represents the title of the movie.", "virtual_table": "SELECT DISTINCT T3.name FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID JOIN Reviewer AS T3 ON T1.rID  =  T3.rID WHERE T2.title  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2483", "db_id": "movie_1", "question": "What are the names of all the reviewers and movie names?", "rationale": ["The query identifies the relevant tables, which are 'Reviewer' and 'Movie'.", "It selects the 'name' column from the 'Reviewer' table and the 'title' column from the 'Movie' table.", "The UNION operator is used to combine the results from both SELECT statements into a single result set."], "gold_sql": "SELECT name FROM Reviewer UNION SELECT title FROM Movie", "source_tables": ["movie", "reviewer"], "description": "This virtual table combines the names of reviewers and the titles of movies from the 'Reviewer' and 'Movie' tables, respectively. The use of UNION allows for a single list that includes both reviewers and movie titles.", "virtual_table": "SELECT name FROM Reviewer UNION SELECT title FROM Movie"}
{"sample_id": "train.2495", "db_id": "movie_1", "question": "For each director, how many reviews have they received?", "rationale": ["The query identifies the relevant tables, which are 'Movie' and 'Rating'.", "It selects the count of ratings and the director's name from the 'Movie' table.", "A JOIN operation is performed on the 'mID' to link the 'Movie' and 'Rating' tables.", "The results are grouped by the director's name to aggregate the count of ratings for each director."], "gold_sql": "SELECT count(*) ,  T1.director FROM Movie AS T1 JOIN Rating AS T2 ON T1.mID  =  T2.mID GROUP BY T1.director", "source_tables": ["rating", "movie"], "description": "This virtual table provides a count of ratings for each movie director from the 'Movie' and 'Rating' tables. The placeholder in the SELECT statement represents the count of ratings, while the grouping is done by the director's name.", "virtual_table": "SELECT count(*) ,  T1.director FROM Movie AS T1 JOIN Rating AS T2 ON T1.mID  =  T2.mID GROUP BY T1.director"}
{"sample_id": "train.2500", "db_id": "movie_1", "question": "What are the names and years of the movies that has the top 3 highest rating star?", "rationale": ["The query identifies the relevant tables, which are 'Rating' and 'Movie'.", "It selects the 'title' and 'year' columns from the 'Movie' table.", "A JOIN operation is performed between 'Rating' and 'Movie' on the movie identifier 'mID' to link ratings to their respective movies.", "The results are ordered by the 'stars' column from the 'Rating' table in descending order to show the highest-rated movies first.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T2.title ,  T2.year FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID ORDER BY T1.stars DESC LIMIT 3", "source_tables": ["rating", "movie"], "description": "This virtual table provides a list of movie titles and their release years from the 'Movie' table, ordered by the number of stars given in ratings from the 'Rating' table. The placeholder in the LIMIT clause allows the user to specify the maximum number of results to return.", "virtual_table": "SELECT T2.title ,  T2.year FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID ORDER BY T1.stars DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2502", "db_id": "movie_1", "question": "For each director, return the director's name together with the title of the movie they directed that received the highest rating among all of their movies, and the value of that rating. Ignore movies whose director is NULL.", "rationale": ["The query identifies the relevant tables, which are 'Rating' and 'Movie'.", "It selects the columns to display: 'title' from the 'Movie' table, 'stars' from the 'Rating' table, and 'director' from the 'Movie' table.", "The JOIN operation links the 'Rating' table to the 'Movie' table using the movie identifier 'mID'.", "A condition is added to filter out movies directed by a specified director using a placeholder for string values.", "The results are grouped by the director to aggregate the maximum stars given for each director's movies."], "gold_sql": "SELECT T2.title ,  T1.stars ,  T2.director ,  max(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE director != 'null' GROUP BY director", "source_tables": ["rating", "movie"], "description": "This virtual table provides a summary of movie ratings, showing the title of the movie, the number of stars given, and the director's name, while excluding movies directed by a specific individual. The placeholder in the WHERE clause represents the name of the director to be excluded from the results.", "virtual_table": "SELECT T2.title ,  T1.stars ,  T2.director ,  max(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE director != [PLACEHOLDER-TYPE:STRING] GROUP BY director"}
{"sample_id": "train.2503", "db_id": "movie_1", "question": "For each director, what are the titles and ratings for all the movies they reviewed?", "rationale": ["The query identifies the relevant tables, which are 'Rating' and 'Movie'.", "It selects the columns to display: 'title' from the 'Movie' table, 'stars' from the 'Rating' table, and 'director' from the 'Movie' table.", "The query uses a JOIN to combine data from the 'Rating' and 'Movie' tables based on the movie identifier (mID).", "A condition is added to filter out movies directed by a specified director using a placeholder for string values.", "The results are grouped by the director to aggregate the maximum stars given for each director's movies."], "gold_sql": "SELECT T2.title ,  T1.stars ,  T2.director ,  max(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE director != 'null' GROUP BY director", "source_tables": ["rating", "movie"], "description": "This virtual table provides a summary of movie ratings, showing the title of the movie, the number of stars given, and the director's name, while excluding movies directed by a specific individual. The placeholder in the WHERE clause represents the director's name that should be excluded from the results.", "virtual_table": "SELECT T2.title ,  T1.stars ,  T2.director ,  max(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE director != [PLACEHOLDER-TYPE:STRING] GROUP BY director"}
{"sample_id": "train.2505", "db_id": "movie_1", "question": "For each reviewer id, what is the title and rating for the movie with the smallest rating?", "rationale": ["The query identifies the relevant tables, 'Rating' and 'Movie', and uses a JOIN to combine them based on the movie identifier (mID).", "It selects the movie title from the 'Movie' table and the reviewer ID, stars given, and calculates the minimum stars from the 'Rating' table.", "The GROUP BY clause is used to aggregate the results by reviewer ID, allowing for the minimum stars to be calculated for each reviewer."], "gold_sql": "SELECT T2.title ,  T1.rID ,  T1.stars ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.rID", "source_tables": ["rating", "movie"], "description": "This virtual table provides a summary of movie ratings by reviewers. It displays the title of the movie, the unique identifier of the reviewer, the number of stars given in the rating, and the minimum stars given by each reviewer for the movies they rated. The placeholders in the query allow for dynamic filtering based on specific reviewer IDs and movie titles.", "virtual_table": "SELECT T2.title ,  T1.rID ,  T1.stars ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.rID"}
{"sample_id": "train.2507", "db_id": "movie_1", "question": "For each director, what is the title and score of their most poorly rated movie?", "rationale": ["The query identifies the relevant tables, 'Rating' and 'Movie', and uses a JOIN to combine them based on the movie identifier (mID).", "It selects the movie title, the stars given in the rating, and the director's name.", "The query also calculates the minimum star rating for each director using the MIN function.", "Finally, it groups the results by the director to provide a summary of ratings for each director's movies."], "gold_sql": "SELECT T2.title ,  T1.stars ,  T2.director ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T2.director", "source_tables": ["rating", "movie"], "description": "This virtual table provides a summary of movie ratings, displaying the title of each movie, the number of stars given in the rating, the director of the movie, and the minimum star rating for each director. The data is aggregated by director, allowing for a comparison of the lowest ratings received by movies directed by the same individual.", "virtual_table": "SELECT T2.title ,  T1.stars ,  T2.director ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T2.director"}
{"sample_id": "train.2508", "db_id": "movie_1", "question": "What is the name of the movie that is rated by most of times?", "rationale": ["The query identifies the relevant tables, 'Rating' and 'Movie'.", "It selects the 'title' from the 'Movie' table and the 'mID' from the 'Rating' table.", "A JOIN operation is performed to link the 'Rating' and 'Movie' tables based on the movie identifier 'mID'.", "The results are grouped by 'mID' to aggregate the ratings for each movie.", "The ORDER BY clause sorts the movies based on the count of ratings in descending order.", "The LIMIT clause restricts the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T2.title ,  T1.mID FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY count(*) DESC LIMIT 1", "source_tables": ["rating", "movie"], "description": "This virtual table provides a list of movie titles along with their unique identifiers from the 'Movie' table. The results are filtered based on the number of ratings received, showing only the top-rated movies. The placeholder in the LIMIT clause represents the maximum number of movies to display.", "virtual_table": "SELECT T2.title ,  T1.mID FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2509", "db_id": "movie_1", "question": "What is the name of the movie that has been reviewed the most?", "rationale": ["The query identifies the relevant tables, 'Rating' and 'Movie'.", "It selects the 'title' from the 'Movie' table and the 'mID' from the 'Rating' table.", "A JOIN operation is performed on the 'mID' to link ratings to their respective movies.", "The results are grouped by 'mID' to aggregate the ratings for each movie.", "The results are ordered by the count of ratings in descending order to show the most rated movies first.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T2.title ,  T1.mID FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY count(*) DESC LIMIT 1", "source_tables": ["rating", "movie"], "description": "This virtual table provides a list of movie titles along with their unique identifiers from the 'Movie' table. The results are filtered based on the number of ratings each movie has received, sorted in descending order, and limited to a specified number of top-rated movies. The placeholder in the LIMIT clause represents the maximum number of movies to return.", "virtual_table": "SELECT T2.title ,  T1.mID FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2517", "db_id": "movie_1", "question": "What are the ids of all moviest hat have not been reviewed by Britanny Harris?", "rationale": ["The query starts by selecting the unique movie identifiers (mID) from the 'Rating' table.", "It uses the EXCEPT clause to exclude movies that have been rated by a specific reviewer.", "To find the movies rated by the specified reviewer, a JOIN operation is performed between the 'Rating' and 'Reviewer' tables based on the reviewer ID (rID).", "The condition in the WHERE clause filters the results to only include ratings from the reviewer with the specified name, which is represented by a placeholder for string values."], "gold_sql": "SELECT mID FROM Rating EXCEPT SELECT T1.mID FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T2.name  =  'Brittany Harris'", "source_tables": ["rating", "reviewer"], "description": "This virtual table identifies the unique movie identifiers from the 'Rating' table that have not been rated by a specific reviewer. The placeholder in the query represents the reviewer's name, allowing users to filter out movies rated by that individual.", "virtual_table": "SELECT mID FROM Rating EXCEPT SELECT T1.mID FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2518", "db_id": "movie_1", "question": "Find the average rating star for each movie that received at least 2 ratings.", "rationale": ["The query identifies the relevant table, which is 'Rating'.", "It selects the 'mID' and calculates the average of the 'stars' column.", "The results are grouped by 'mID' to aggregate ratings for each movie.", "A condition is added to filter the results to include only those movies that have received a specified minimum number of ratings using a placeholder for numeric values."], "gold_sql": "SELECT mID ,  avg(stars) FROM Rating GROUP BY mID HAVING count(*)  >=  2", "source_tables": ["rating"], "description": "This virtual table provides the unique movie identifiers along with the average star ratings from the 'Rating' table. It filters the results to include only those movies that have received a minimum number of ratings, as specified by the placeholder.", "virtual_table": "SELECT mID ,  avg(stars) FROM Rating GROUP BY mID HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2528", "db_id": "movie_1", "question": "What are the names of reviewers who had rated 3 star and 4 star?", "rationale": ["The query identifies the relevant tables, which are 'Rating' and 'Reviewer'.", "It selects the 'name' column from the 'Reviewer' table.", "The JOIN operation links the 'Rating' table to the 'Reviewer' table using the reviewer ID (rID).", "The WHERE clause filters the ratings based on the specified number of stars using a placeholder for numeric values.", "The INTERSECT operation is used to find common reviewers who rated two different movies with the same star rating."], "gold_sql": "SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T1.stars  =  3 INTERSECT SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T1.stars  =  4", "source_tables": ["rating", "reviewer"], "description": "This virtual table describes the names of reviewers who have given a specific number of stars to movies. The query uses an INTERSECT operation to find reviewers who rated two different movies with the same star rating. The placeholders in the WHERE clause represent the number of stars given in the ratings.", "virtual_table": "SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2530", "db_id": "movie_1", "question": "What are the names of movies that get 3 star and 4 star?", "rationale": ["The query identifies the relevant tables, which are 'Rating' and 'Movie'.", "It selects the 'title' column from the 'Movie' table.", "The query uses a JOIN to link the 'Rating' table with the 'Movie' table based on the movie identifier (mID).", "It applies a condition to filter the ratings based on the specified number of stars using placeholders for numeric values.", "The INTERSECT operator is used to find titles that meet the star rating criteria from both instances of the query."], "gold_sql": "SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  3 INTERSECT SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  4", "source_tables": ["rating", "movie"], "description": "This virtual table describes the titles of movies that have received a specific number of stars from two different reviewers. The placeholders in the WHERE clause represent the star ratings given by the reviewers.", "virtual_table": "SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2576", "db_id": "inn_1", "question": "Find the most popular room in the hotel. The most popular room is the room that had seen the largest number of reservations.", "rationale": ["The query identifies the relevant tables, 'Reservations' and 'Rooms'.", "It performs a JOIN operation to link the reservations to their corresponding room names using the foreign key relationship.", "The query groups the results by room to count the number of reservations for each room.", "It orders the results in descending order based on the count of reservations, ensuring the most popular rooms are listed first.", "The LIMIT clause uses a placeholder to specify how many room names to return."], "gold_sql": "SELECT T2.roomName FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["rooms", "reservations"], "description": "This virtual table provides the names of the most frequently reserved rooms from the 'Rooms' table based on the reservations made in the 'Reservations' table. The placeholder in the LIMIT clause represents the maximum number of room names to return.", "virtual_table": "SELECT T2.roomName FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.2577", "db_id": "inn_1", "question": "Which room has the largest number of reservations?", "rationale": ["The query identifies the relevant tables, 'Reservations' and 'Rooms'.", "It performs a JOIN operation to link the reservations to their corresponding room names using the foreign key relationship.", "The GROUP BY clause is used to group the results by room, allowing for counting the number of reservations per room.", "The ORDER BY clause sorts the results in descending order based on the count of reservations, ensuring the most reserved rooms appear first.", "The LIMIT clause uses a placeholder to specify how many room names to return."], "gold_sql": "SELECT T2.roomName FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["rooms", "reservations"], "description": "This virtual table provides the names of the most frequently reserved rooms from the 'Rooms' table based on the reservations made in the 'Reservations' table. The placeholder in the LIMIT clause represents the maximum number of room names to return.", "virtual_table": "SELECT T2.roomName FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.2578", "db_id": "inn_1", "question": "How many kids stay in the rooms reserved by ROY SWEAZY?", "rationale": ["The query identifies the relevant table, which is 'Reservations'.", "Select the column to display, 'Kids'.", "Add conditions to filter the 'FirstName' and 'LastName' columns for the specified guest using placeholders for string values."], "gold_sql": "SELECT kids FROM Reservations WHERE FirstName = 'ROY' AND LastName  =  'SWEAZY';", "source_tables": ["reservations"], "description": "This virtual table provides the number of kids associated with reservations made by a specific guest. The placeholders in the WHERE clause represent the first and last names of the guest.", "virtual_table": "SELECT kids FROM Reservations WHERE FirstName = [PLACEHOLDER-TYPE:STRING] AND LastName  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.2582", "db_id": "inn_1", "question": "Which room has the highest rate? List the room's full name, rate, check in and check out date.", "rationale": ["The query identifies the relevant tables, 'Reservations' and 'Rooms', and uses a JOIN to combine them based on the room identifier.", "It selects the columns 'roomName' from the Rooms table and 'Rate', 'CheckIn', and 'CheckOut' from the Reservations table.", "The results are grouped by the room to avoid duplicates and ordered by the reservation rate in descending order.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T2.roomName ,  T1.Rate ,  T1.CheckIn ,  T1.CheckOut FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY T1.Rate DESC LIMIT 1;", "source_tables": ["rooms", "reservations"], "description": "This virtual table provides a list of room names along with their corresponding reservation rates, check-in, and check-out dates. The data is sourced from the 'Reservations' and 'Rooms' tables, where the room identifier in reservations is linked to the unique room identifier in the rooms table. The results are grouped by room to ensure unique entries and are ordered by the reservation rate in descending order, with a limit on the number of results returned based on a specified number.", "virtual_table": "SELECT T2.roomName ,  T1.Rate ,  T1.CheckIn ,  T1.CheckOut FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY T1.Rate DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.2583", "db_id": "inn_1", "question": "Return the name, rate, check in and check out date for the room with the highest rate.", "rationale": ["The query identifies the relevant tables, 'Reservations' and 'Rooms', and uses a JOIN to combine them based on the room identifier.", "It selects the columns 'roomName' from the Rooms table and 'Rate', 'CheckIn', and 'CheckOut' from the Reservations table.", "The GROUP BY clause is used to group the results by the room to avoid duplicates.", "The ORDER BY clause sorts the results by the 'Rate' in descending order to show the highest rates first.", "The LIMIT clause restricts the number of results returned to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT T2.roomName ,  T1.Rate ,  T1.CheckIn ,  T1.CheckOut FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY T1.Rate DESC LIMIT 1;", "source_tables": ["rooms", "reservations"], "description": "This virtual table provides a list of room names along with their corresponding reservation rates, check-in, and check-out dates. The data is sourced from the 'Reservations' and 'Rooms' tables, where the room identifier in reservations is linked to the unique room identifier in the rooms table. The results are grouped by room to ensure each room appears only once, sorted by the reservation rate in descending order, and limited to a specified number of entries.", "virtual_table": "SELECT T2.roomName ,  T1.Rate ,  T1.CheckIn ,  T1.CheckOut FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY T1.Rate DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.2589", "db_id": "inn_1", "question": "Find the total number of king beds available.", "rationale": ["The query identifies the relevant table, which is 'Rooms'.", "It selects the sum of the 'beds' column to calculate the total number of beds.", "A condition is added to filter the results based on the 'bedType' column using a placeholder for string values."], "gold_sql": "SELECT sum(beds) FROM Rooms WHERE bedtype  =  'King';", "source_tables": ["rooms"], "description": "This virtual table calculates the total number of beds available in rooms of a specific bed type from the 'Rooms' table. The placeholder in the WHERE clause represents the type of beds being queried.", "virtual_table": "SELECT sum(beds) FROM Rooms WHERE bedtype  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.2590", "db_id": "inn_1", "question": "List the names and decor of rooms that have a king bed. Sort the list by their price.", "rationale": ["The query identifies the relevant table, which is 'Rooms'.", "Select the columns to display, 'roomName' and 'decor'.", "Add a condition to filter the 'bedType' column for the specified bed type using a placeholder for string values.", "Order the results by 'basePrice' to sort the rooms based on their pricing."], "gold_sql": "SELECT roomName ,  decor FROM Rooms WHERE bedtype  =  'King' ORDER BY basePrice;", "source_tables": ["rooms"], "description": "This virtual table describes the names and decor of rooms from the 'Rooms' table that have a specific type of bed. The placeholder in the WHERE clause represents the bed type being queried, and the results are ordered by the base price of the rooms.", "virtual_table": "SELECT roomName ,  decor FROM Rooms WHERE bedtype  =  [PLACEHOLDER-TYPE:STRING] ORDER BY basePrice;"}
{"sample_id": "train.2594", "db_id": "inn_1", "question": "What is the decor of room Recluse and defiance?", "rationale": ["The query is identifying the relevant table, which is 'Rooms'.", "Select the column to display, 'decor'.", "Add a condition to filter the 'roomName' column for the specified room using a placeholder for string values."], "gold_sql": "SELECT decor FROM Rooms WHERE roomName  =  'Recluse and defiance';", "source_tables": ["rooms"], "description": "This virtual table describes the decor of a specific room from the 'Rooms' table based on the room's name. The placeholder in the WHERE clause represents the name of the room being queried.", "virtual_table": "SELECT decor FROM Rooms WHERE roomName  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.2604", "db_id": "inn_1", "question": "Find the first and last names of people who payed more than the rooms' base prices.", "rationale": ["The query identifies the relevant tables, 'Reservations' and 'Rooms', and establishes a join condition based on the foreign key relationship between them.", "It selects the 'FirstName' and 'LastName' columns from the 'Reservations' table, aliased as T1.", "The join condition links the 'Room' column in 'Reservations' to the 'RoomId' column in 'Rooms'.", "A condition is added to filter results where the difference between the 'Rate' in 'Reservations' and the 'basePrice' in 'Rooms' exceeds a specified numeric value using a placeholder."], "gold_sql": "SELECT T1.firstname ,  T1.lastname FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T1.Rate - T2.basePrice  >  0", "source_tables": ["rooms", "reservations"], "description": "This virtual table provides the first and last names of guests from the 'Reservations' table who have a reservation rate that exceeds the base price of the room they booked. The placeholder in the WHERE clause represents the difference in price that is being queried.", "virtual_table": "SELECT T1.firstname ,  T1.lastname FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T1.Rate - T2.basePrice  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2609", "db_id": "inn_1", "question": "How many rooms have a king bed?", "rationale": ["The query identifies the relevant table, which is 'Rooms'.", "It selects the count of all rooms that match a specific condition.", "A condition is added to filter the 'bedType' column for the specified type of bed using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM Rooms WHERE bedType  =  'King';", "source_tables": ["rooms"], "description": "This virtual table provides the count of rooms from the 'Rooms' table that have a specific type of bed. The placeholder in the WHERE clause represents the type of bed being queried.", "virtual_table": "SELECT count(*) FROM Rooms WHERE bedType  =  [PLACEHOLDER-TYPE:STRING];"}
