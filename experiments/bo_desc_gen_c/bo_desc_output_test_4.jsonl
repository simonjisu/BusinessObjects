{"sample_id": "train.4750", "db_id": "department_store", "question": "What is the id and name of the staff who has been assigned for the least amount of time?", "rationale": ["The query identifies the relevant tables, which are 'Staff' and 'Staff_Department_Assignments'.", "It selects the 'staff_id' and 'staff_name' columns from the 'Staff' table.", "A JOIN operation is performed to link 'Staff' with 'Staff_Department_Assignments' based on the 'staff_id'.", "The results are ordered by the duration of the assignment, calculated as 'date_assigned_to' minus 'date_assigned_from'.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.staff_id ,  T1.staff_name FROM staff AS T1 JOIN Staff_Department_Assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY date_assigned_to - date_assigned_from LIMIT 1", "source_tables": ["staff_department_assignments", "staff"], "description": "This virtual table provides a list of staff members along with their unique identifiers from the 'Staff' table. It joins the 'Staff' table with the 'Staff_Department_Assignments' table to include only those staff members who have been assigned to a department. The results are ordered by the duration of their assignment, calculated as the difference between the end date and start date of their assignment. The placeholder in the LIMIT clause allows for specifying the maximum number of records to return.", "virtual_table": "SELECT T1.staff_id ,  T1.staff_name FROM staff AS T1 JOIN Staff_Department_Assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY date_assigned_to - date_assigned_from LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4753", "db_id": "department_store", "question": "Find the ids of all distinct customers who made order after some orders that were Cancelled.", "rationale": ["The query identifies the relevant table, which is 'Customer_Orders'.", "It selects distinct customer IDs to ensure each customer is listed only once.", "A condition is added to filter orders based on the order date, specifically those placed after the earliest order date with a given status code, using a subquery and a placeholder for the order status code."], "gold_sql": "SELECT DISTINCT customer_id FROM Customer_Orders WHERE order_date  >  (SELECT min(order_date) FROM Customer_Orders WHERE order_status_code  =  'Cancelled')", "source_tables": ["customer_orders"], "description": "This virtual table lists unique customer identifiers from the 'Customer_Orders' table for orders placed after a specific date. The placeholder in the subquery represents the order status code used to filter the earliest order date.", "virtual_table": "SELECT DISTINCT customer_id FROM Customer_Orders WHERE order_date  >  (SELECT min(order_date) FROM Customer_Orders WHERE order_status_code  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.4755", "db_id": "department_store", "question": "What is id of the staff who had a Staff Department Assignment earlier than any Clerical Staff?", "rationale": ["The query identifies the relevant table, which is 'Staff_Department_Assignments'.", "It selects the 'staff_id' column to display the unique identifiers of staff members.", "A condition is added to filter the results based on the 'date_assigned_to' column, ensuring it is less than the maximum 'date_assigned_to' for a specified job title.", "The subquery retrieves the maximum assignment end date for the specified job title using a placeholder for string values."], "gold_sql": "SELECT staff_id FROM Staff_Department_Assignments WHERE date_assigned_to  <  (SELECT max(date_assigned_to) FROM Staff_Department_Assignments WHERE job_title_code  =  'Clerical Staff')", "source_tables": ["staff_department_assignments"], "description": "This virtual table lists the unique identifiers of staff members who were assigned to a department and whose assignment ended before the most recent assignment date for a specific job title. The placeholder in the subquery represents the job title code to filter the results accordingly.", "virtual_table": "SELECT staff_id FROM Staff_Department_Assignments WHERE date_assigned_to  <  (SELECT max(date_assigned_to) FROM Staff_Department_Assignments WHERE job_title_code  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.4758", "db_id": "department_store", "question": "Return the names and ids of customers who have TN in their address.", "rationale": ["The query identifies the relevant table, which is 'Customers'.", "Select the columns to display, 'customer_name' and 'customer_id'.", "Add a condition to filter the 'customer_address' column using a LIKE clause for the specified address pattern with a placeholder for string values."], "gold_sql": "SELECT customer_name ,  customer_id FROM customers WHERE customer_address LIKE '%TN%'", "source_tables": ["customers"], "description": "This virtual table describes the names and unique identifiers of customers from the 'Customers' table whose addresses match a specific pattern. The placeholder in the WHERE clause represents the address pattern to filter the results.", "virtual_table": "SELECT customer_name ,  customer_id FROM customers WHERE customer_address LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4760", "db_id": "department_store", "question": "What are the names and genders of staff who were assigned in 2016?", "rationale": ["The query identifies the relevant tables, which are 'Staff' and 'Staff_Department_Assignments'.", "It selects the columns to display, 'staff_name' and 'staff_gender'.", "A JOIN operation is performed to link the 'Staff' table with the 'Staff_Department_Assignments' table based on the 'staff_id'.", "A condition is added to filter the results based on the 'date_assigned_from' column using a placeholder for string values."], "gold_sql": "SELECT T1.staff_name ,  T1.staff_gender FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.date_assigned_from LIKE '2016%'", "source_tables": ["staff_department_assignments", "staff"], "description": "This virtual table describes the names and genders of staff members from the 'Staff' table who have been assigned to a department starting from a specific date. The placeholder in the WHERE clause represents the date of assignment.", "virtual_table": "SELECT T1.staff_name ,  T1.staff_gender FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.date_assigned_from LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4762", "db_id": "department_store", "question": "What are the names of staff who have been assigned multiple jobs?", "rationale": ["The query identifies the relevant tables, which are 'Staff' and 'Staff_Department_Assignments'.", "It selects the 'staff_name' from the 'Staff' table.", "A JOIN operation is performed between 'Staff' and 'Staff_Department_Assignments' on the 'staff_id' to link staff members with their department assignments.", "The results are grouped by 'staff_id' to aggregate the assignments for each staff member.", "The HAVING clause filters the results to include only those staff members who have more than a specified number of assignments, using a placeholder for the numeric value."], "gold_sql": "SELECT T1.staff_name FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id GROUP BY T2.staff_id HAVING COUNT (*)  >  1", "source_tables": ["staff_department_assignments", "staff"], "description": "This virtual table describes the names of staff members from the 'Staff' table who are assigned to departments, filtered to include only those with more than a specified number of assignments. The placeholder in the HAVING clause represents the minimum count of assignments required.", "virtual_table": "SELECT T1.staff_name FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id GROUP BY T2.staff_id HAVING COUNT (*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4792", "db_id": "department_store", "question": "What are the ids and names of customers with addressed that contain WY and who do not use a credit card for payment?", "rationale": ["The query identifies the relevant table, which is 'Customers'.", "Select the columns to display, 'customer_id' and 'customer_name'.", "Add conditions to filter the 'customer_address' using a LIKE clause for a specific pattern and exclude customers with a certain 'payment_method_code' using a NOT EQUAL condition with a placeholder for string values."], "gold_sql": "SELECT customer_id ,  customer_name FROM customers WHERE customer_address LIKE '%WY%' AND payment_method_code != 'Credit Card'", "source_tables": ["customers"], "description": "This virtual table describes the unique identifiers and names of customers from the 'Customers' table who have a specific address pattern and do not use a certain payment method. The placeholders in the WHERE clause represent the address pattern and the payment method code.", "virtual_table": "SELECT customer_id ,  customer_name FROM customers WHERE customer_address LIKE [PLACEHOLDER-TYPE:STRING] AND payment_method_code != [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4793", "db_id": "department_store", "question": "Find the average price of all product clothes.", "rationale": ["The query identifies the relevant table, which is 'Products'.", "It selects the average of the 'product_price' column to compute the average price.", "A condition is added to filter the 'product_type_code' column for the specified product type using a placeholder for string values."], "gold_sql": "SELECT avg(product_price) FROM products WHERE product_type_code  =  'Clothes'", "source_tables": ["products"], "description": "This virtual table calculates the average price of products from the 'Products' table that belong to a specific product type. The placeholder in the WHERE clause represents the product type code.", "virtual_table": "SELECT avg(product_price) FROM products WHERE product_type_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4795", "db_id": "department_store", "question": "Find the name of the most expensive hardware product.", "rationale": ["The query identifies the relevant table, which is 'Products'.", "Select the column to display, 'product_name'.", "Add a condition to filter the 'product_type_code' column for the specified product type using a placeholder for string values.", "Order the results by 'product_price' in descending order to show the most expensive products first.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT product_name FROM products WHERE product_type_code  =  'Hardware' ORDER BY product_price DESC LIMIT 1", "source_tables": ["products"], "description": "This virtual table provides a list of product names from the 'Products' table that match a specific product type code. The results are ordered by the product price in descending order, and the number of results returned is limited by a placeholder for numeric values.", "virtual_table": "SELECT product_name FROM products WHERE product_type_code  =  [PLACEHOLDER-TYPE:STRING] ORDER BY product_price DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4902", "db_id": "store_product", "question": "Find the list of page size which have more than 3 product listed", "rationale": ["The query identifies the relevant table, which is 'product'.", "Select the column 'max_page_size' to display the maximum page sizes of products.", "Group the results by 'max_page_size' to aggregate the data based on this attribute.", "Use the HAVING clause to filter groups that have a count greater than a specified number, using a placeholder for numeric values."], "gold_sql": "SELECT max_page_size FROM product GROUP BY max_page_size HAVING count(*)  >  3", "source_tables": ["product"], "description": "This virtual table provides the maximum page sizes of products from the 'product' table, grouped by their maximum page size. The placeholder in the HAVING clause represents the minimum count of products that must share the same maximum page size to be included in the results.", "virtual_table": "SELECT max_page_size FROM product GROUP BY max_page_size HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4903", "db_id": "store_product", "question": "What is the maximum page size for everything that has more than 3 products listed?", "rationale": ["The query identifies the relevant table, which is 'product'.", "It selects the 'max_page_size' column to display the maximum page sizes of products.", "The results are grouped by 'max_page_size' to aggregate the data based on this attribute.", "A condition is added in the HAVING clause to filter groups that have a count greater than a specified number, using a placeholder for numeric values."], "gold_sql": "SELECT max_page_size FROM product GROUP BY max_page_size HAVING count(*)  >  3", "source_tables": ["product"], "description": "This virtual table provides the maximum page sizes of products from the 'product' table, grouped by their maximum page size. The placeholder in the HAVING clause represents the minimum count of products that must share the same maximum page size to be included in the results.", "virtual_table": "SELECT max_page_size FROM product GROUP BY max_page_size HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4913", "db_id": "store_product", "question": "What is the total number of residents for the districts with the 3 largest areas?", "rationale": ["The query identifies the relevant table, which is 'district'.", "It selects the sum of the 'city_population' column to get the total population.", "The results are ordered by 'city_area' in descending order to prioritize larger areas.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT sum(city_population) FROM district ORDER BY city_area DESC LIMIT 3", "source_tables": ["district"], "description": "This virtual table calculates the total population of cities within districts from the 'district' table, ordering the results by the area of the cities in descending order. The placeholder in the LIMIT clause represents the maximum number of results to return.", "virtual_table": "SELECT sum(city_population) FROM district ORDER BY city_area DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4917", "db_id": "store_product", "question": "What are the names of all the stores located in Khanewal District?", "rationale": ["The query identifies the relevant tables: 'store', 'store_district', and 'district'.", "It selects the 'store_name' column from the 'store' table.", "The query uses JOIN operations to connect 'store' with 'store_district' and then 'store_district' with 'district'.", "A condition is added to filter the results based on the 'district_name' column using a placeholder for string values."], "gold_sql": "SELECT t1.store_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t3.district_name  =  'Khanewal District'", "source_tables": ["store_district", "store", "district"], "description": "This virtual table describes the names of stores located in a specific district. The query joins the 'store', 'store_district', and 'district' tables to filter stores based on the district's name provided as a placeholder.", "virtual_table": "SELECT t1.store_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t3.district_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4924", "db_id": "store_product", "question": "Find the city with the most number of stores.", "rationale": ["The query identifies the relevant tables: 'store', 'store_district', and 'district'.", "It joins these tables to connect stores with their respective districts and the cities where those districts are headquartered.", "The selection focuses on the 'headquartered_city' from the 'district' table.", "The results are grouped by 'headquartered_city' to aggregate the data based on the number of stores in each city.", "The results are ordered by the count of stores in descending order to prioritize cities with the most stores.", "A limit is applied to restrict the number of cities returned, using a placeholder for numeric values."], "gold_sql": "SELECT t3.headquartered_city FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id GROUP BY t3.headquartered_city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["store_district", "store", "district"], "description": "This virtual table provides a list of cities where the headquarters of districts are located, based on the stores associated with those districts. The results are grouped by the city name and ordered by the number of stores in descending order, with a limit on the number of cities returned, specified by a placeholder for numeric values.", "virtual_table": "SELECT t3.headquartered_city FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id GROUP BY t3.headquartered_city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4930", "db_id": "store_product", "question": "Find products with max page size as \"A4\" and pages per minute color smaller than 5.", "rationale": ["The query identifies the relevant table, which is 'product'.", "Select the column to display, 'product'.", "Add conditions to filter the 'max_page_size' column for a specified maximum size using a placeholder for string values.", "Add another condition to filter the 'pages_per_minute_color' column for values less than a specified number using a placeholder for numeric values."], "gold_sql": "SELECT product FROM product WHERE max_page_size  =  'A4' AND pages_per_minute_color  <  5", "source_tables": ["product"], "description": "This virtual table describes the products from the 'product' table that have a specific maximum page size and a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the maximum pages per minute for color printing.", "virtual_table": "SELECT product FROM product WHERE max_page_size  =  [PLACEHOLDER-TYPE:STRING] AND pages_per_minute_color  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4932", "db_id": "store_product", "question": "Find products with max page size as \"A4\" or pages per minute color smaller than 5.", "rationale": ["The query identifies the relevant table, which is 'product'.", "Select the column to display, 'product'.", "Add conditions to filter the 'max_page_size' for a specified value using a placeholder for string values and 'pages_per_minute_color' for a specified numeric value using a placeholder for numeric values."], "gold_sql": "SELECT product FROM product WHERE max_page_size  =  'A4' OR pages_per_minute_color  <  5", "source_tables": ["product"], "description": "This virtual table describes the products from the 'product' table that either have a specific maximum page size or have a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the print speed limit.", "virtual_table": "SELECT product FROM product WHERE max_page_size  =  [PLACEHOLDER-TYPE:STRING] OR pages_per_minute_color  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4935", "db_id": "store_product", "question": "What are all of the products whose name includes the substring \"Scanner\"?", "rationale": ["The query identifies the relevant table, which is 'product'.", "Select the column to display, 'product'.", "Add a condition to filter the 'product' column using the LIKE operator for pattern matching with a placeholder for string values."], "gold_sql": "SELECT product FROM product WHERE product LIKE '%Scanner%'", "source_tables": ["product"], "description": "This virtual table describes the names or descriptions of products from the 'product' table that match a specific pattern. The placeholder in the LIKE clause represents the search term for the product name or description.", "virtual_table": "SELECT product FROM product WHERE product LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4937", "db_id": "store_product", "question": "What is the most common maximum page size?", "rationale": ["The query identifies the relevant table, which is 'product'.", "It selects the 'max_page_size' column to display the maximum page sizes of products.", "The results are grouped by 'max_page_size' to aggregate similar sizes together.", "The results are ordered by the count of occurrences of each maximum page size in descending order to show the most common sizes first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT 1", "source_tables": ["product"], "description": "This virtual table provides a list of maximum page sizes from the 'product' table, grouped by the maximum page size and ordered by the frequency of each size in descending order. The placeholder in the LIMIT clause represents the number of results to return.", "virtual_table": "SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4938", "db_id": "store_product", "question": "Find the name of the products that are not using the most frequently-used max page size.", "rationale": ["The query identifies the relevant table, which is 'product'.", "Select the column to display, 'product'.", "Add a condition to filter out products that have the maximum page size, using a subquery to find the most common maximum page size.", "The subquery groups the products by 'max_page_size' and orders them by their count, limiting the result to the top entry, which is represented by a placeholder for numeric values."], "gold_sql": "SELECT product FROM product WHERE product != (SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["product"], "description": "This virtual table lists the names or descriptions of products from the 'product' table that do not have the most common maximum page size. The placeholder in the subquery represents a numeric value to limit the results based on the count of maximum page sizes.", "virtual_table": "SELECT product FROM product WHERE product != (SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.4947", "db_id": "soccer_2", "question": "How many students, on average, does each college have enrolled?", "rationale": ["The query identifies the relevant table, which is 'College'.", "It selects the average of the 'enr' column to compute the average enrollment number.", "The use of the aggregate function 'avg' allows for the calculation of the average across all entries in the 'enr' column."], "gold_sql": "SELECT avg(enr) FROM College", "source_tables": ["college"], "description": "This virtual table calculates the average enrollment number of students across all colleges listed in the 'College' table. The result provides insight into the overall student population in these institutions.", "virtual_table": "SELECT avg(enr) FROM College"}
{"sample_id": "train.4955", "db_id": "soccer_2", "question": "How many hours do the players train on average?", "rationale": ["The query is identifying the relevant table, which is 'Player'.", "Select the column to calculate the average, which is 'HS'.", "The use of the aggregate function 'avg' indicates that we want to compute the average of the high school values."], "gold_sql": "SELECT avg(HS) FROM Player", "source_tables": ["player"], "description": "This virtual table calculates the average high school attended by players from the 'Player' table. The placeholder in the SELECT clause represents the high school data that will be averaged.", "virtual_table": "SELECT avg(HS) FROM Player"}
{"sample_id": "train.4956", "db_id": "soccer_2", "question": "Find the name and training hours of players whose hours are below 1500.", "rationale": ["The query is identifying the relevant table, which is 'Player'.", "Select the columns to display, 'pName' and 'HS'.", "Add a condition to filter the 'HS' column for high schools with an enrollment number less than the specified value using a placeholder for numeric values."], "gold_sql": "SELECT pName ,  HS FROM Player WHERE HS  <  1500", "source_tables": ["player"], "description": "This virtual table describes the names and high schools of players from the 'Player' table who attended high schools with an enrollment number less than a specified value. The placeholder in the WHERE clause represents the enrollment number of students at the high school.", "virtual_table": "SELECT pName ,  HS FROM Player WHERE HS  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4961", "db_id": "soccer_2", "question": "What are the different types of player positions?", "rationale": ["The query identifies the relevant table, which is 'Tryout'.", "It uses the COUNT function to count the number of distinct values in the 'pPos' column, which represents the positions players are trying out for."], "gold_sql": "SELECT count(DISTINCT pPos) FROM tryout", "source_tables": ["tryout"], "description": "This virtual table provides the count of distinct positions that players are trying out for in the 'Tryout' table. The result will give an overview of the variety of positions available for players during tryouts.", "virtual_table": "SELECT count(DISTINCT pPos) FROM tryout"}
{"sample_id": "train.4962", "db_id": "soccer_2", "question": "How many students got accepted after the tryout?", "rationale": ["The query identifies the relevant table, which is 'Tryout'.", "It counts the total number of entries that match a specific decision.", "A condition is added to filter the results based on the 'decision' column using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM tryout WHERE decision  =  'yes'", "source_tables": ["tryout"], "description": "This virtual table provides the total number of players who received a specific decision regarding their tryout from the 'Tryout' table. The placeholder in the WHERE clause represents the decision made about the players' tryouts.", "virtual_table": "SELECT count(*) FROM tryout WHERE decision  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4966", "db_id": "soccer_2", "question": "Find the max, average and min training hours of all players.", "rationale": ["The query identifies the relevant table, which is 'Player'.", "It selects the average, maximum, and minimum values of the 'HS' column.", "The use of aggregate functions (avg, max, min) indicates that we are interested in statistical summaries of the high school data."], "gold_sql": "SELECT avg(HS) ,  max(HS) ,  min(HS) FROM Player", "source_tables": ["player"], "description": "This virtual table provides the average, maximum, and minimum values of the high school attended by players from the 'Player' table. The placeholders in the SELECT clause represent the calculated statistics for the high school data.", "virtual_table": "SELECT avg(HS) ,  max(HS) ,  min(HS) FROM Player"}
{"sample_id": "train.4967", "db_id": "soccer_2", "question": "What is the average, maximum, and minimum for the number of hours spent training?", "rationale": ["The query identifies the relevant table, which is 'Player'.", "It selects the average, maximum, and minimum values of the 'HS' column.", "The use of aggregate functions (avg, max, min) indicates that we are interested in statistical summaries of the high school data."], "gold_sql": "SELECT avg(HS) ,  max(HS) ,  min(HS) FROM Player", "source_tables": ["player"], "description": "This virtual table provides the average, maximum, and minimum values of the high school attended by players from the 'Player' table. The placeholders in the SELECT clause represent the calculated statistics for the high school data.", "virtual_table": "SELECT avg(HS) ,  max(HS) ,  min(HS) FROM Player"}
{"sample_id": "train.4970", "db_id": "soccer_2", "question": "What are the names of players whose training hours is between 500 and 1500?", "rationale": ["The query is identifying the relevant table, which is 'Player'.", "Select the column to display, 'pName'.", "Add a condition to filter the 'HS' column for high school enrollment numbers within a specified range using placeholders for numeric values."], "gold_sql": "SELECT pName FROM Player WHERE HS BETWEEN 500 AND 1500", "source_tables": ["player"], "description": "This virtual table describes the names of players from the 'Player' table who attended high schools within a specific range of enrollment numbers. The placeholders in the WHERE clause represent the lower and upper bounds of the enrollment numbers.", "virtual_table": "SELECT pName FROM Player WHERE HS BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4971", "db_id": "soccer_2", "question": "What are the names of players who train between 500 and 1500 hours?", "rationale": ["The query is identifying the relevant table, which is 'Player'.", "Select the column to display, 'pName'.", "Add a condition to filter the 'HS' column for high school enrollment numbers within a specified range using placeholders for numeric values."], "gold_sql": "SELECT pName FROM Player WHERE HS BETWEEN 500 AND 1500", "source_tables": ["player"], "description": "This virtual table describes the names of players from the 'Player' table who attended high schools within a specific range of enrollment numbers. The placeholders in the WHERE clause represent the lower and upper bounds of the enrollment numbers.", "virtual_table": "SELECT pName FROM Player WHERE HS BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4975", "db_id": "soccer_2", "question": "What are the names and enrollment numbers for colleges that have more than 10000 enrolled and are located in Louisiana?", "rationale": ["The query identifies the relevant table, which is 'College'.", "Select the columns to display, 'cName' and 'enr'.", "Add conditions to filter the 'enr' column for values greater than a specified number and the 'state' column for a specific state using placeholders for numeric and string values."], "gold_sql": "SELECT cName ,  enr FROM College WHERE enr  >  10000 AND state = 'LA'", "source_tables": ["college"], "description": "This virtual table provides the names and enrollment numbers of colleges from the 'College' table that have an enrollment greater than a specified number and are located in a specific state. The placeholders in the WHERE clause represent the minimum enrollment number and the state name.", "virtual_table": "SELECT cName ,  enr FROM College WHERE enr  >  [PLACEHOLDER-TYPE:NUMBER] AND state = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4981", "db_id": "soccer_2", "question": "What are the name of the players who received a card in descending order of the hours of training?", "rationale": ["The query identifies the relevant table, which is 'Player'.", "Select the column to display, 'pName'.", "Add a condition to filter the 'yCard' column for the specified year of eligibility using a placeholder for string values.", "Order the results by the 'HS' column in descending order."], "gold_sql": "SELECT pName FROM Player WHERE yCard  =  'yes' ORDER BY HS DESC", "source_tables": ["player"], "description": "This virtual table describes the names of players from the 'Player' table who have a specific year of eligibility. The results are ordered by the high school attended, in descending order. The placeholder in the WHERE clause represents the year of the player's card.", "virtual_table": "SELECT pName FROM Player WHERE yCard  =  [PLACEHOLDER-TYPE:STRING] ORDER BY HS DESC"}
{"sample_id": "train.4984", "db_id": "soccer_2", "question": "Which position is most popular among players in the tryout?", "rationale": ["The query identifies the relevant table, which is 'Tryout'.", "It selects the 'pPos' column to display the positions players are trying out for.", "The results are grouped by 'pPos' to aggregate the data based on player positions.", "The results are ordered by the count of players in each position in descending order to show the most popular positions first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT pPos FROM tryout GROUP BY pPos ORDER BY count(*) DESC LIMIT 1", "source_tables": ["tryout"], "description": "This virtual table provides a list of player positions from the 'Tryout' table, grouped by position and ordered by the number of players trying out for each position. The placeholder in the LIMIT clause represents the maximum number of positions to return.", "virtual_table": "SELECT pPos FROM tryout GROUP BY pPos ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4985", "db_id": "soccer_2", "question": "What was the most popular position at tryouts?", "rationale": ["The query identifies the relevant table, which is 'Tryout'.", "It selects the 'pPos' column to display the positions players are trying out for.", "The results are grouped by 'pPos' to aggregate the data based on player positions.", "The results are ordered by the count of players in each position in descending order to show the most popular positions first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT pPos FROM tryout GROUP BY pPos ORDER BY count(*) DESC LIMIT 1", "source_tables": ["tryout"], "description": "This virtual table provides a list of player positions from the 'Tryout' table, grouped by position and ordered by the number of players trying out for each position. The placeholder in the LIMIT clause represents the maximum number of positions to return.", "virtual_table": "SELECT pPos FROM tryout GROUP BY pPos ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4988", "db_id": "soccer_2", "question": "What is minimum hours of the students playing in different position?", "rationale": ["The query identifies the relevant tables, which are 'Tryout' and 'Player'.", "It selects the minimum high school attended by players using the 'min' function on the 'HS' column from the 'Player' table.", "The 'pPos' column from the 'Tryout' table is included to show the position for which the players are trying out.", "A JOIN operation is performed on the 'pID' column to link the two tables, allowing access to both player and tryout information.", "The results are grouped by the 'pPos' column to aggregate the minimum high school for each position."], "gold_sql": "SELECT min(T2.HS) ,   T1.pPos FROM tryout AS T1 JOIN player AS T2 ON T1.pID  =  T2.pID GROUP BY T1.pPos", "source_tables": ["player", "tryout"], "description": "This virtual table summarizes the minimum high school attended by players for each position they are trying out for, based on the data from the 'Tryout' and 'Player' tables. The placeholder in the SELECT clause represents the high school name, while the position is grouped accordingly.", "virtual_table": "SELECT min(T2.HS) ,   T1.pPos FROM tryout AS T1 JOIN player AS T2 ON T1.pID  =  T2.pID GROUP BY T1.pPos"}
{"sample_id": "train.4989", "db_id": "soccer_2", "question": "For each position, what is the minimum time students spent practicing?", "rationale": ["The query identifies the relevant tables, which are 'Tryout' and 'Player'.", "It selects the minimum high school name from the 'Player' table and the position from the 'Tryout' table.", "A JOIN operation is performed on the player ID to link the two tables based on the player's participation in the tryout.", "The results are grouped by the position the player is trying out for, allowing for aggregation of high school names per position."], "gold_sql": "SELECT min(T2.HS) ,   T1.pPos FROM tryout AS T1 JOIN player AS T2 ON T1.pID  =  T2.pID GROUP BY T1.pPos", "source_tables": ["player", "tryout"], "description": "This virtual table provides the minimum high school name associated with each position that players are trying out for, by joining the 'Tryout' and 'Player' tables. The placeholder in the SELECT clause represents the high school name, while the grouping is done by the position the player is trying out for.", "virtual_table": "SELECT min(T2.HS) ,   T1.pPos FROM tryout AS T1 JOIN player AS T2 ON T1.pID  =  T2.pID GROUP BY T1.pPos"}
{"sample_id": "train.5003", "db_id": "soccer_2", "question": "What are the names and hours spent practicing of every student who received a yes at tryouts?", "rationale": ["The query identifies the relevant tables, which are 'Player' and 'Tryout'.", "It selects the columns to display, 'pName' and 'HS' from the 'Player' table.", "A JOIN operation is performed between 'Player' and 'Tryout' on the player ID to link the two tables.", "A condition is added to filter the results based on the 'decision' column in the 'Tryout' table using a placeholder for string values."], "gold_sql": "SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes'", "source_tables": ["player", "tryout"], "description": "This virtual table provides the names and high schools of players from the 'Player' table who have a specific decision regarding their tryout. The placeholder in the WHERE clause represents the decision made about the player's tryout.", "virtual_table": "SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5007", "db_id": "soccer_2", "question": "What are the names of all students who successfully tried out for the position of striker?", "rationale": ["The query identifies the relevant tables, which are 'Player' and 'Tryout'.", "It selects the 'pName' column from the 'Player' table.", "A JOIN operation is performed between 'Player' and 'Tryout' on the 'pID' column to link players with their tryout information.", "Conditions are added to filter the results based on the 'decision' and 'pPos' columns in the 'Tryout' table using placeholders for string values."], "gold_sql": "SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes' AND T2.pPos  =  'striker'", "source_tables": ["player", "tryout"], "description": "This virtual table describes the names of players from the 'Player' table who have participated in tryouts and received a specific decision for a particular position. The placeholders in the WHERE clause represent the decision made regarding the player's tryout and the position they are trying out for.", "virtual_table": "SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING] AND T2.pPos  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5013", "db_id": "soccer_2", "question": "What is the average number of hours spent practicing for students who got rejected?", "rationale": ["The query identifies the relevant tables, which are 'Player' and 'Tryout'.", "It selects the average of the 'HS' column from the 'Player' table, which represents the high school attended by the players.", "A JOIN operation is performed between 'Player' and 'Tryout' on the 'pID' column to link players with their tryout information.", "A condition is added to filter the results based on the 'decision' column in the 'Tryout' table using a placeholder for string values."], "gold_sql": "SELECT avg(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'no'", "source_tables": ["player", "tryout"], "description": "This virtual table calculates the average high school attended by players who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.", "virtual_table": "SELECT avg(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5018", "db_id": "soccer_2", "question": "Which college has any student who is a goalie and succeeded in the tryout.", "rationale": ["The query identifies the relevant table, which is 'Tryout'.", "Select the column to display, 'cName', which represents the college name.", "Add conditions to filter the 'decision' and 'pPos' columns for the specified values using placeholders for string values."], "gold_sql": "SELECT cName FROM  tryout WHERE decision  =  'yes' AND pPos  =  'goalie'", "source_tables": ["tryout"], "description": "This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.", "virtual_table": "SELECT cName FROM  tryout WHERE decision  =  [PLACEHOLDER-TYPE:STRING] AND pPos  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5022", "db_id": "soccer_2", "question": "What is the state and enrollment of the colleges where have any students who got accepted in the tryout decision.", "rationale": ["The query identifies the relevant tables, which are 'College' and 'Tryout'.", "It selects distinct values for 'state' and 'enr' from the 'College' table.", "A JOIN operation is performed between 'College' and 'Tryout' on the college name to link the two tables.", "A condition is added to filter the results based on the 'decision' column in the 'Tryout' table using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.state ,  T1.enr FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  'yes'", "source_tables": ["tryout", "college"], "description": "This virtual table provides a distinct list of states and enrollment numbers from the 'College' table for colleges where players have participated in tryouts. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.", "virtual_table": "SELECT DISTINCT T1.state ,  T1.enr FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5023", "db_id": "soccer_2", "question": "How many students are enrolled in colleges that have student accepted during tryouts, and in which states are those colleges?", "rationale": ["The query identifies the relevant tables, 'College' and 'Tryout'.", "It selects distinct values for 'state' and 'enr' from the 'College' table.", "A JOIN operation is performed between 'College' and 'Tryout' on the college name to link the two tables.", "A condition is added to filter the results based on the 'decision' column in the 'Tryout' table using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.state ,  T1.enr FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  'yes'", "source_tables": ["tryout", "college"], "description": "This virtual table provides a distinct list of states and enrollment numbers from the 'College' table for colleges where players have participated in tryouts. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.", "virtual_table": "SELECT DISTINCT T1.state ,  T1.enr FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5026", "db_id": "soccer_2", "question": "Find the names of schools that have some students playing in goalie and mid positions.", "rationale": ["The query is identifying the relevant table, which is 'Tryout'.", "It selects the 'cName' column to display the names of colleges.", "The INTERSECT operator is used to find colleges where players are trying out for two different positions, specified by placeholders for string values."], "gold_sql": "SELECT cName FROM  tryout WHERE pPos  =  'goalie' INTERSECT SELECT cName FROM  tryout WHERE pPos  =  'mid'", "source_tables": ["tryout"], "description": "This virtual table identifies the colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.", "virtual_table": "SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5028", "db_id": "soccer_2", "question": "Find the names of states that have some college students playing in goalie and mid positions.", "rationale": ["The query identifies the relevant tables, which are 'College' and 'Tryout'.", "It selects the 'state' column from the 'College' table.", "The JOIN operation links the 'College' and 'Tryout' tables based on the college name.", "The WHERE clause filters the results based on the player's position using a placeholder for string values.", "The INTERSECT operation ensures that only states with tryouts for the specified position are included in the final result."], "gold_sql": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'goalie' INTERSECT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'mid'", "source_tables": ["tryout", "college"], "description": "This virtual table identifies the states where colleges are located that are hosting tryouts for a specific position. The query uses an intersection to find states that have tryouts for the same position, ensuring that only relevant states are returned. The placeholders in the WHERE clause represent the position for which players are trying out.", "virtual_table": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5029", "db_id": "soccer_2", "question": "What are the names of the states that have some college students playing in the positions of goalie and mid-field?", "rationale": ["The query identifies the relevant tables, which are 'College' and 'Tryout'.", "It selects the 'state' column from the 'College' table.", "The JOIN operation links the 'College' and 'Tryout' tables based on the college name.", "The WHERE clause filters the results based on the player's position using a placeholder for string values.", "The INTERSECT operation ensures that only states with tryouts for the specified position are included in the final result."], "gold_sql": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'goalie' INTERSECT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'mid'", "source_tables": ["tryout", "college"], "description": "This virtual table identifies the states of colleges that are hosting tryouts for a specific position. The query uses an intersection to find states where the tryout position matches the specified placeholder value, ensuring that only relevant states are returned.", "virtual_table": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5030", "db_id": "soccer_2", "question": "How many schools have some students playing in goalie and mid positions.", "rationale": ["The query identifies the relevant table, which is 'Tryout'.", "It uses a subquery to find colleges where players are trying out for the first specified position.", "It uses another subquery to find colleges where players are trying out for the second specified position.", "The INTERSECT operator is used to find colleges that appear in both subqueries, meaning they have players trying out for both positions.", "Finally, the COUNT function is used to count the number of colleges that meet this criteria."], "gold_sql": "SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  'goalie' INTERSECT SELECT cName FROM  tryout WHERE pPos  =  'mid')", "source_tables": ["tryout"], "description": "This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify any two positions they are interested in.", "virtual_table": "SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.5037", "db_id": "soccer_2", "question": "What is the count of states with college students playing in the mid position but not as goalies?", "rationale": ["The query identifies the relevant tables, which are 'College' and 'Tryout'.", "It uses a JOIN operation to combine data from both tables based on the college name.", "The first SELECT statement retrieves states where tryouts for a specific position occurred.", "The EXCEPT clause is used to exclude states where tryouts for the same position also occurred, ensuring only unique states are counted."], "gold_sql": "SELECT COUNT(*) FROM (SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'mid' EXCEPT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'goalie')", "source_tables": ["tryout", "college"], "description": "This virtual table counts the number of unique states where colleges are located that have hosted tryouts for a specific position, excluding those states that have hosted tryouts for the same position. The placeholders in the query represent the position for which the tryouts are being considered.", "virtual_table": "SELECT COUNT(*) FROM (SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.5039", "db_id": "soccer_2", "question": "What are the states with colleges that have enrollments less than the some other college?", "rationale": ["The query identifies the relevant table, which is 'College'.", "It selects distinct values from the 'state' column to avoid duplicates.", "A subquery is used to find the maximum enrollment number from the 'College' table.", "The main query filters the states based on the condition that the enrollment number is less than the maximum found in the subquery."], "gold_sql": "SELECT DISTINCT state FROM college WHERE enr  <  (SELECT max(enr) FROM college)", "source_tables": ["college"], "description": "This virtual table provides a list of distinct states where colleges are located, specifically filtering for those colleges that have an enrollment number less than the maximum enrollment number found in the 'College' table. The placeholder in the WHERE clause represents the enrollment number for comparison.", "virtual_table": "SELECT DISTINCT state FROM college WHERE enr  <  (SELECT max(enr) FROM college)"}
{"sample_id": "train.5102", "db_id": "cre_Drama_Workshop_Groups", "question": "Show the minimum, average, maximum order quantity of all invoices.", "rationale": ["The query identifies the relevant table, which is 'INVOICES'.", "It selects the minimum, average, and maximum values of the 'Order_Quantity' column to provide insights into the order quantities.", "The use of aggregate functions (min, avg, max) allows for a summary of the order quantities across all invoices."], "gold_sql": "SELECT min(Order_Quantity) ,  avg(Order_Quantity) ,  max(Order_Quantity) FROM INVOICES", "source_tables": ["invoices"], "description": "This virtual table provides the minimum, average, and maximum quantities of products ordered as recorded in the 'INVOICES' table. The placeholders in the SELECT statement represent the aggregated values of the 'Order_Quantity' column.", "virtual_table": "SELECT min(Order_Quantity) ,  avg(Order_Quantity) ,  max(Order_Quantity) FROM INVOICES"}
{"sample_id": "train.5118", "db_id": "cre_Drama_Workshop_Groups", "question": "What is the payment method code used by the most orders?", "rationale": ["The query identifies the relevant table, which is 'INVOICES'.", "It selects the 'payment_method_code' to display unique payment methods.", "The GROUP BY clause is used to group the results by 'payment_method_code'.", "The ORDER BY clause sorts the results based on the count of occurrences of each payment method in descending order.", "The LIMIT clause allows the user to specify how many of the most frequently used payment methods to return."], "gold_sql": "SELECT payment_method_code FROM INVOICES GROUP BY payment_method_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["invoices"], "description": "This virtual table provides a list of unique payment method codes used in the invoices, grouped by the payment method code and ordered by the frequency of their usage. The placeholder in the LIMIT clause allows the user to specify the maximum number of payment methods to retrieve.", "virtual_table": "SELECT payment_method_code FROM INVOICES GROUP BY payment_method_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5127", "db_id": "cre_Drama_Workshop_Groups", "question": "Give me the descriptions of the service types that cost more than 100.", "rationale": ["The query identifies the relevant tables, which are 'Ref_Service_Types' and 'Services'.", "It selects the 'Service_Type_Description' from 'Ref_Service_Types'.", "A JOIN is performed between 'Ref_Service_Types' and 'Services' on the 'Service_Type_Code' to link the service types with their descriptions.", "A condition is added to filter the results based on the 'Product_Price' from the 'Services' table using a placeholder for numeric values."], "gold_sql": "SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Price  >  100", "source_tables": ["services", "ref_service_types"], "description": "This virtual table describes the service type descriptions from the 'Ref_Service_Types' table that are associated with services in the 'Services' table, filtered by a specific product price. The placeholder in the WHERE clause represents the minimum product price to filter the results.", "virtual_table": "SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Price  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5134", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the names of workshop groups in which services with product name \"film\" are performed?", "rationale": ["The query identifies the relevant tables, 'Drama_Workshop_Groups' and 'Services'.", "It selects the columns 'Store_Phone' and 'Store_Email_Address' from the 'Drama_Workshop_Groups' table.", "A JOIN operation is performed between 'Drama_Workshop_Groups' and 'Services' on the 'Workshop_Group_ID' to link the two tables.", "A condition is added to filter the results based on the 'Product_Name' from the 'Services' table using a placeholder for string values."], "gold_sql": "SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T2.Product_Name  =  'film'", "source_tables": ["services", "drama_workshop_groups"], "description": "This virtual table provides the phone number and email address of stores associated with specific drama workshop groups that offer a particular product. The placeholder in the WHERE clause represents the name of the product being queried.", "virtual_table": "SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T2.Product_Name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5142", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the order details of the products with price higher than 2000?", "rationale": ["The query identifies the relevant tables, 'Order_Items' and 'Products'.", "It selects the 'Other_Item_Details' column from the 'Order_Items' table.", "A JOIN operation is performed between 'Order_Items' and 'Products' on the 'Product_ID' to link order items with their corresponding products.", "A condition is added to filter products based on their price, using a placeholder for numeric values."], "gold_sql": "SELECT T1.Other_Item_Details FROM ORDER_ITEMS AS T1 JOIN Products AS T2 ON T1.Product_ID  =  T2.Product_ID WHERE T2.Product_price  >  2000", "source_tables": ["products", "order_items"], "description": "This virtual table retrieves additional details about order items from the 'Order_Items' table, specifically for those products whose price exceeds a specified amount. The placeholder in the WHERE clause represents the price threshold for filtering the products.", "virtual_table": "SELECT T1.Other_Item_Details FROM ORDER_ITEMS AS T1 JOIN Products AS T2 ON T1.Product_ID  =  T2.Product_ID WHERE T2.Product_price  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5143", "db_id": "cre_Drama_Workshop_Groups", "question": "Find the order detail for the products with price above 2000.", "rationale": ["The query identifies the relevant tables, 'Order_Items' and 'Products'.", "It selects the 'Other_Item_Details' column from the 'Order_Items' table.", "A JOIN operation is performed between 'Order_Items' and 'Products' on the 'Product_ID' to link order items with their corresponding product details.", "A condition is added to filter products based on their price, using a placeholder for numeric values."], "gold_sql": "SELECT T1.Other_Item_Details FROM ORDER_ITEMS AS T1 JOIN Products AS T2 ON T1.Product_ID  =  T2.Product_ID WHERE T2.Product_price  >  2000", "source_tables": ["products", "order_items"], "description": "This virtual table retrieves additional details about order items from the 'Order_Items' table, specifically for those products whose price exceeds a specified amount. The placeholder in the WHERE clause represents the price threshold for filtering the products.", "virtual_table": "SELECT T1.Other_Item_Details FROM ORDER_ITEMS AS T1 JOIN Products AS T2 ON T1.Product_ID  =  T2.Product_ID WHERE T2.Product_price  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5160", "db_id": "cre_Drama_Workshop_Groups", "question": "What is the most frequent status of bookings?", "rationale": ["The query identifies the relevant table, which is 'Bookings'.", "It selects the 'Status_Code' column to display unique booking statuses.", "The results are grouped by 'Status_Code' to aggregate the counts of each status.", "The results are ordered by the count of bookings for each status in descending order to show the most common statuses first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT Status_Code FROM BOOKINGS GROUP BY Status_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["bookings"], "description": "This virtual table summarizes the unique status codes of bookings from the 'Bookings' table, grouped by their status and ordered by the count of bookings for each status in descending order. The placeholder in the LIMIT clause represents the maximum number of status codes to return.", "virtual_table": "SELECT Status_Code FROM BOOKINGS GROUP BY Status_Code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5161", "db_id": "cre_Drama_Workshop_Groups", "question": "Which status code is the most common of all the bookings?", "rationale": ["The query identifies the relevant table, which is 'Bookings'.", "It selects the 'Status_Code' column to display the unique status codes of bookings.", "The GROUP BY clause is used to group the results by 'Status_Code'.", "The ORDER BY clause sorts the results based on the count of bookings for each status in descending order.", "The LIMIT clause restricts the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT Status_Code FROM BOOKINGS GROUP BY Status_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["bookings"], "description": "This virtual table summarizes the unique status codes of bookings from the 'Bookings' table, grouped by their status and ordered by the count of bookings for each status in descending order. The placeholder in the LIMIT clause represents the maximum number of status codes to return.", "virtual_table": "SELECT Status_Code FROM BOOKINGS GROUP BY Status_Code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5162", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the names of the workshop groups that have bookings with status code \"stop\"?", "rationale": ["The query identifies the relevant tables, 'Bookings' and 'Drama_Workshop_Groups'.", "It selects the 'Store_Name' from the 'Drama_Workshop_Groups' table.", "A JOIN operation is performed on 'Workshop_Group_ID' to link bookings to their respective workshop groups.", "A condition is added to filter the bookings based on a specific 'Status_Code' using a placeholder for string values."], "gold_sql": "SELECT T2.Store_Name FROM Bookings AS T1 JOIN Drama_Workshop_Groups AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T1.Status_Code  =  'stop'", "source_tables": ["drama_workshop_groups", "bookings"], "description": "This virtual table provides the names of stores associated with bookings that have a specific status. The placeholder in the WHERE clause represents the status code of the booking.", "virtual_table": "SELECT T2.Store_Name FROM Bookings AS T1 JOIN Drama_Workshop_Groups AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T1.Status_Code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5171", "db_id": "cre_Drama_Workshop_Groups", "question": "Give me the description of the service type that offers not only the photo product but also the film product.", "rationale": ["The query identifies the relevant tables, which are 'Ref_Service_Types' and 'Services'.", "It selects the 'Service_Type_Description' from 'Ref_Service_Types' by joining it with 'Services' on 'Service_Type_Code'.", "The WHERE clause filters the results based on the 'Product_Name' from the 'Services' table using a placeholder for string values.", "The INTERSECT operator is used to ensure that only service types associated with the same product name are returned in both parts of the query."], "gold_sql": "SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  'photo' INTERSECT SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  'film'", "source_tables": ["services", "ref_service_types"], "description": "This virtual table describes the service type descriptions associated with a specific product from the 'Services' table, ensuring that the same product name is used in both parts of the query. The placeholders in the WHERE clause represent the product's name.", "virtual_table": "SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5459", "db_id": "voter_2", "question": "Find the average age of female students.", "rationale": ["The query identifies the relevant table, which is 'Student'.", "It selects the average of the 'Age' column to compute the average age of students.", "A condition is added to filter the 'Sex' column for the specified gender using a placeholder for string values."], "gold_sql": "SELECT avg(Age) FROM STUDENT WHERE Sex  =  'F'", "source_tables": ["student"], "description": "This virtual table calculates the average age of students from the 'Student' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the students.", "virtual_table": "SELECT avg(Age) FROM STUDENT WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5466", "db_id": "voter_2", "question": "What are the distinct president votes on 08/30/2015?", "rationale": ["The query identifies the relevant table, which is 'Voting_record'.", "Select the distinct values of the 'PRESIDENT_Vote' column to avoid duplicates.", "Add a condition to filter the records based on the 'Registration_Date' using a placeholder for string values."], "gold_sql": "SELECT DISTINCT PRESIDENT_Vote FROM VOTING_RECORD WHERE Registration_Date  =  '08/30/2015'", "source_tables": ["voting_record"], "description": "This virtual table provides a distinct list of presidential votes cast by students from the 'Voting_record' table, filtered by the registration date. The placeholder in the WHERE clause represents the specific registration date being queried.", "virtual_table": "SELECT DISTINCT PRESIDENT_Vote FROM VOTING_RECORD WHERE Registration_Date  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5467", "db_id": "voter_2", "question": "Show all the distinct president votes made on 08/30/2015.", "rationale": ["The query identifies the relevant table, which is 'Voting_record'.", "Select the distinct values of the 'PRESIDENT_Vote' column to avoid duplicates.", "Add a condition to filter the records based on the 'Registration_Date' using a placeholder for string values."], "gold_sql": "SELECT DISTINCT PRESIDENT_Vote FROM VOTING_RECORD WHERE Registration_Date  =  '08/30/2015'", "source_tables": ["voting_record"], "description": "This virtual table provides a distinct list of presidential votes cast by students from the 'Voting_record' table, filtered by the date of registration. The placeholder in the WHERE clause represents the specific registration date being queried.", "virtual_table": "SELECT DISTINCT PRESIDENT_Vote FROM VOTING_RECORD WHERE Registration_Date  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5476", "db_id": "voter_2", "question": "Find the distinct ages of students who have secretary votes in the fall election cycle.", "rationale": ["The query identifies the relevant tables, 'Student' and 'Voting_record'.", "It selects the distinct ages from the 'Student' table.", "A join is performed between 'Student' and 'Voting_record' on the condition that the student's ID matches the vote cast for the secretary candidate.", "A condition is added to filter the results based on the specified election cycle using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.Age FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Secretary_Vote WHERE T2.Election_Cycle  =  'Fall'", "source_tables": ["student", "voting_record"], "description": "This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.", "virtual_table": "SELECT DISTINCT T1.Age FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Secretary_Vote WHERE T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5479", "db_id": "voter_2", "question": "Who served as an advisor for students who have treasurer votes in the spring election cycle?", "rationale": ["The query identifies the relevant tables, 'Student' and 'Voting_record'.", "It selects the distinct 'Advisor' from the 'Student' table.", "A join is performed between 'Student' and 'Voting_record' on the condition that 'StuID' matches 'Treasurer_Vote'.", "A condition is added to filter the results based on the specified 'Election_Cycle' using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.Advisor FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Treasurer_Vote WHERE T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "description": "This virtual table provides a list of unique academic advisors for students who voted for a specific treasurer in a given election cycle. The placeholder in the WHERE clause represents the election cycle identifier.", "virtual_table": "SELECT DISTINCT T1.Advisor FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Treasurer_Vote WHERE T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5486", "db_id": "voter_2", "question": "How many male (sex is M) students have class senator votes in the fall election cycle?", "rationale": ["The query identifies the relevant tables, which are 'Student' and 'Voting_record'.", "It performs a JOIN operation on the 'StuID' to link students with their voting records.", "The SELECT statement counts the total number of students that meet the specified criteria.", "Conditions are added to filter the results based on the student's gender and the election cycle using placeholders for string values."], "gold_sql": "SELECT count(*) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  Class_Senator_Vote WHERE T1.Sex  =  'M' AND T2.Election_Cycle  =  'Fall'", "source_tables": ["student", "voting_record"], "description": "This virtual table counts the number of students from the 'Student' table who are female or male and have participated in the voting process during a specific election cycle. The placeholders in the WHERE clause represent the gender of the students and the election cycle identifier.", "virtual_table": "SELECT count(*) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  Class_Senator_Vote WHERE T1.Sex  =  [PLACEHOLDER-TYPE:STRING] AND T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5491", "db_id": "voter_2", "question": "What is the average age of students who have city code \"NYC\" and have secretary votes for the spring election cycle?", "rationale": ["The query identifies the relevant tables, 'Student' and 'Voting_record'.", "It selects the average age from the 'Student' table.", "A JOIN operation is performed on the 'StuID' to link students with their voting records, specifically filtering for those who voted for the secretary candidate.", "Conditions are added to filter students based on their city code and the election cycle using placeholders for string values."], "gold_sql": "SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.city_code  =  'NYC' AND T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "description": "This virtual table calculates the average age of students from the 'Student' table who voted for a specific candidate in the 'Voting_record' table. The placeholders in the WHERE clause represent the city code where the students reside and the election cycle during which the votes were cast.", "virtual_table": "SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.city_code  =  [PLACEHOLDER-TYPE:STRING] AND T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5492", "db_id": "voter_2", "question": "Find the average age of female (sex is F) students who have secretary votes in the spring election cycle.", "rationale": ["The query identifies the relevant tables, 'Student' and 'Voting_record'.", "It selects the average age from the 'Student' table.", "A JOIN is performed on the 'StuID' to link students with their voting records, specifically filtering for those who voted for the secretary candidate.", "Conditions are added to filter by the student's gender and the election cycle using placeholders for string values."], "gold_sql": "SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.Sex  =  'F' AND T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "description": "This virtual table calculates the average age of students from the 'Student' table who voted for a specific candidate in the 'Voting_record' table. The placeholders in the WHERE clause represent the gender of the students and the election cycle during which the votes were cast.", "virtual_table": "SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.Sex  =  [PLACEHOLDER-TYPE:STRING] AND T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5494", "db_id": "voter_2", "question": "Find the distinct first names of all the students who have vice president votes and whose city code is not PIT.", "rationale": ["The query identifies the relevant tables, 'Student' and 'Voting_record'.", "It selects distinct first names from the 'Student' table (aliased as T1) that are associated with the vice presidential votes in the 'Voting_record' table (aliased as T2).", "The JOIN condition links the 'StuID' from 'Student' with the 'Vice_President_Vote' in 'Voting_record'.", "The EXCEPT clause is used to exclude students from the results who reside in a specified city, indicated by a placeholder for the city code."], "gold_sql": "SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_PRESIDENT_Vote EXCEPT SELECT DISTINCT Fname FROM STUDENT WHERE city_code  =  'PIT'", "source_tables": ["student", "voting_record"], "description": "This virtual table describes the first names of students who voted for a specific vice presidential candidate, excluding those who reside in a particular city. The placeholder in the EXCEPT clause represents the city code.", "virtual_table": "SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_PRESIDENT_Vote EXCEPT SELECT DISTINCT Fname FROM STUDENT WHERE city_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5495", "db_id": "voter_2", "question": "What are the distinct first names of the students who have vice president votes and reside in a city whose city code is not PIT?", "rationale": ["The query identifies the relevant tables, 'Student' and 'Voting_record'.", "It selects distinct first names from the 'Student' table (aliased as T1) that are associated with the vice president votes in the 'Voting_record' table (aliased as T2).", "The JOIN condition links the 'StuID' from 'Student' with the 'Vice_President_Vote' from 'Voting_record'.", "The EXCEPT clause is used to exclude students who reside in a specific city, represented by a placeholder for the city code."], "gold_sql": "SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_PRESIDENT_Vote EXCEPT SELECT DISTINCT Fname FROM STUDENT WHERE city_code  =  'PIT'", "source_tables": ["student", "voting_record"], "description": "This virtual table describes the first names of students who voted for the vice president but are not residents of a specific city. The placeholder in the EXCEPT clause represents the city code that is used to filter out students from that city.", "virtual_table": "SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_PRESIDENT_Vote EXCEPT SELECT DISTINCT Fname FROM STUDENT WHERE city_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5496", "db_id": "voter_2", "question": "Find the distinct last names of all the students who have president votes and whose advisor is not 2192.", "rationale": ["The query identifies the relevant tables, 'Student' and 'Voting_record'.", "It selects distinct last names from the 'Student' table (aliased as T1) that are associated with the presidential votes in the 'Voting_record' table (aliased as T2).", "The JOIN condition links the 'StuID' from the 'Student' table to the 'President_Vote' in the 'Voting_record' table.", "The EXCEPT clause is used to exclude students who have a specific advisor, represented by a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote EXCEPT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  '2192'", "source_tables": ["student", "voting_record"], "description": "This virtual table provides a list of unique last names of students who voted for a presidential candidate, excluding those who have a specific academic advisor. The placeholders in the query represent the advisor's name.", "virtual_table": "SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote EXCEPT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5499", "db_id": "voter_2", "question": "What are the distinct last names of the students who have president votes and have 8741 as the advisor?", "rationale": ["The query identifies the relevant tables, 'Student' and 'Voting_record'.", "It selects distinct last names from the 'Student' table where the student ID matches the presidential vote in the 'Voting_record' table.", "The INTERSECT operation is used to find students who also have a specific advisor, filtering by the 'Advisor' column with a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote INTERSECT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  '8741'", "source_tables": ["student", "voting_record"], "description": "This virtual table describes the last names of students who have voted for a presidential candidate and are assigned to a specific academic advisor. The placeholder in the WHERE clause represents the advisor's name.", "virtual_table": "SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote INTERSECT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5510", "db_id": "voter_2", "question": "What is the most common major among female (sex is F) students?", "rationale": ["The query identifies the relevant table, which is 'Student'.", "Select the column to display, 'Major'.", "Add a condition to filter the 'Sex' column for the specified gender using a placeholder for string values.", "Group the results by 'Major' to aggregate the data.", "Order the results by the count of students in each major in descending order.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT Major FROM STUDENT WHERE Sex  =  'F' GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "description": "This virtual table provides a list of majors from the 'Student' table, filtered by the gender of the students. The results are grouped by major and ordered by the number of students in each major in descending order, with a limit on the number of results returned. The placeholders represent the gender of the students and the maximum number of majors to display.", "virtual_table": "SELECT Major FROM STUDENT WHERE Sex  =  [PLACEHOLDER-TYPE:STRING] GROUP BY major ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5511", "db_id": "voter_2", "question": "Find the major that is studied by the most female students.", "rationale": ["The query identifies the relevant table, which is 'Student'.", "Select the column to display, 'Major'.", "Add a condition to filter the 'Sex' column for the specified gender using a placeholder for string values.", "Group the results by 'Major' to aggregate the data.", "Order the results by the count of students in each major in descending order.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT Major FROM STUDENT WHERE Sex  =  'F' GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "description": "This virtual table provides a list of majors from the 'Student' table, filtered by the gender of the students. The results are grouped by major and ordered by the number of students in each major in descending order, with a limit on the number of results returned. The placeholders represent the gender of the students and the maximum number of majors to display.", "virtual_table": "SELECT Major FROM STUDENT WHERE Sex  =  [PLACEHOLDER-TYPE:STRING] GROUP BY major ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5534", "db_id": "products_gen_characteristics", "question": "Find the number of products with category \"Spices\" and typically sold above 1000.", "rationale": ["The query identifies the relevant table, which is 'Products'.", "It uses the COUNT function to count the number of products that meet specific criteria.", "The WHERE clause filters products based on the 'product_category_code' and 'typical_buying_price', using placeholders for the string and numeric values."], "gold_sql": "SELECT count(*) FROM products WHERE product_category_code  =  'Spices' AND typical_buying_price  >  1000", "source_tables": ["products"], "description": "This virtual table provides a count of products from the 'Products' table that belong to a specific product category and have a typical buying price above a certain threshold. The placeholders in the WHERE clause represent the product category code and the minimum buying price.", "virtual_table": "SELECT count(*) FROM products WHERE product_category_code  =  [PLACEHOLDER-TYPE:STRING] AND typical_buying_price  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5543", "db_id": "products_gen_characteristics", "question": "What are the descriptions of the categories that products with product descriptions that contain the letter t are in?", "rationale": ["The query identifies the relevant tables, which are 'Ref_Product_Categories' and 'Products'.", "It selects the 'product_category_description' from 'Ref_Product_Categories'.", "A JOIN is performed on the 'product_category_code' to link 'Ref_Product_Categories' with 'Products'.", "A condition is added to filter products based on their description using a placeholder for string values."], "gold_sql": "SELECT T1.product_category_description FROM ref_product_categories AS T1 JOIN products AS T2 ON T1.product_category_code  =  T2.product_category_code WHERE T2.product_description LIKE '%t%'", "source_tables": ["products", "ref_product_categories"], "description": "This virtual table provides the descriptions of product categories from the 'Ref_Product_Categories' table for products that have a specific description. The placeholder in the WHERE clause allows for filtering products based on their description.", "virtual_table": "SELECT T1.product_category_description FROM ref_product_categories AS T1 JOIN products AS T2 ON T1.product_category_code  =  T2.product_category_code WHERE T2.product_description LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5556", "db_id": "products_gen_characteristics", "question": "How many distinct characteristic names does the product \"cumin\" have?", "rationale": ["The query identifies the relevant tables: 'Products', 'Product_Characteristics', and 'Characteristics'.", "It uses JOIN operations to link these tables based on their foreign key relationships.", "The SELECT statement counts the distinct characteristic names from the 'Characteristics' table.", "A condition is added to filter the results based on the specified product name using a placeholder for string values."], "gold_sql": "SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  'sesame'", "source_tables": ["products", "characteristics", "product_characteristics"], "description": "This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product for which the distinct characteristics are being counted.", "virtual_table": "SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5577", "db_id": "products_gen_characteristics", "question": "How many products have their color described as 'white' or have a characteristic with the name 'hot'?", "rationale": ["The query identifies the relevant tables: 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors'.", "It uses JOIN operations to link these tables based on their foreign key relationships.", "The SELECT statement counts the total number of products that meet the specified conditions.", "The WHERE clause filters the results based on either the color description or the characteristic name, using placeholders for user-defined values."], "gold_sql": "SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  'white' OR t3.characteristic_name  =  'hot'", "source_tables": ["products", "ref_colors", "characteristics", "product_characteristics"], "description": "This virtual table provides a count of products that either match a specific color description or have a specific characteristic name. It combines data from multiple tables, including 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors', using joins based on their relationships. The placeholders in the WHERE clause represent the color description and characteristic name that the user can specify.", "virtual_table": "SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  [PLACEHOLDER-TYPE:STRING] OR t3.characteristic_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5579", "db_id": "products_gen_characteristics", "question": "Return the unit of measure for 'Herb' products.", "rationale": ["The query is identifying the relevant table, which is 'Ref_Product_Categories'.", "Select the column to display, 'unit_of_measure'.", "Add a condition to filter the 'product_category_code' column for the specified product category using a placeholder for string values."], "gold_sql": "SELECT unit_of_measure FROM ref_product_categories WHERE product_category_code  =  'Herbs'", "source_tables": ["ref_product_categories"], "description": "This virtual table describes the unit of measure for a specific product category from the 'Ref_Product_Categories' table. The placeholder in the WHERE clause represents the unique code for the product category.", "virtual_table": "SELECT unit_of_measure FROM ref_product_categories WHERE product_category_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5586", "db_id": "products_gen_characteristics", "question": "Find the unit of measurement and product category code of product named \"chervil\".", "rationale": ["The query identifies the relevant tables, which are 'Products' and 'Ref_Product_Categories'.", "It selects the columns 'unit_of_measure' and 'product_category_code' from the 'Ref_Product_Categories' table.", "A JOIN operation is performed on the 'product_category_code' to link the 'Products' table with the 'Ref_Product_Categories' table.", "A condition is added to filter the results based on the specified product name using a placeholder for string values."], "gold_sql": "SELECT t2.unit_of_measure ,  t2.product_category_code FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code WHERE t1.product_name  =  'chervil'", "source_tables": ["products", "ref_product_categories"], "description": "This virtual table provides the unit of measure and product category code for a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.", "virtual_table": "SELECT t2.unit_of_measure ,  t2.product_category_code FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5590", "db_id": "products_gen_characteristics", "question": "What is the description of the color for most products?", "rationale": ["The query identifies the relevant tables, 'Products' and 'Ref_Colors'.", "It selects the 'color_description' from the 'Ref_Colors' table.", "A JOIN operation is performed on the 'color_code' to link products with their respective colors.", "The results are grouped by 'color_description' to aggregate the data based on color.", "The ORDER BY clause sorts the colors by their count in descending order, allowing the most common colors to appear first.", "The LIMIT clause uses a placeholder to specify the maximum number of results to return."], "gold_sql": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) DESC LIMIT 1", "source_tables": ["products", "ref_colors"], "description": "The virtual table describes the color descriptions of products from the 'Products' table, grouped by color and ordered by the frequency of each color's occurrence. The placeholder in the LIMIT clause represents the maximum number of color descriptions to return.", "virtual_table": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5592", "db_id": "products_gen_characteristics", "question": "What is the description of the color used by least products?", "rationale": ["The query identifies the relevant tables, which are 'Products' and 'Ref_Colors'.", "It selects the 'color_description' from the 'Ref_Colors' table.", "A JOIN operation is performed on the 'color_code' to link products with their respective colors.", "The results are grouped by 'color_description' to aggregate the data based on color.", "The results are ordered by the count of products associated with each color in ascending order.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) ASC LIMIT 1", "source_tables": ["products", "ref_colors"], "description": "This virtual table provides a list of color descriptions for products from the 'Products' table, grouped by color and ordered by the count of products associated with each color in ascending order. The placeholder in the LIMIT clause represents the maximum number of color descriptions to return.", "virtual_table": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5599", "db_id": "products_gen_characteristics", "question": "Give the names of characteristics that are in two or more products?", "rationale": ["The query identifies the relevant tables: 'Products', 'Product_Characteristics', and 'Characteristics'.", "It selects the 'characteristic_name' from the 'Characteristics' table.", "The tables are joined based on their relationships: 'Products' to 'Product_Characteristics' via 'product_id', and 'Product_Characteristics' to 'Characteristics' via 'characteristic_id'.", "The results are grouped by 'characteristic_name' to aggregate the data.", "A HAVING clause is added to filter the results based on the count of products associated with each characteristic name, using a placeholder for numeric values."], "gold_sql": "SELECT t3.characteristic_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id GROUP BY t3.characteristic_name HAVING count(*)  >= 2", "source_tables": ["products", "characteristics", "product_characteristics"], "description": "This virtual table describes the names of characteristics associated with products from the 'Products' table. It retrieves characteristic names by joining the 'Products', 'Product_Characteristics', and 'Characteristics' tables. The results are grouped by characteristic name, and only those with a count of associated products greater than or equal to a specified number are included. The placeholder in the HAVING clause represents the minimum count of products for the characteristic names to be displayed.", "virtual_table": "SELECT t3.characteristic_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id GROUP BY t3.characteristic_name HAVING count(*)  >= [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5633", "db_id": "railway", "question": "List the builders of railways in ascending alphabetical order.", "rationale": ["The query identifies the relevant table, which is 'railway'.", "Select the column to display, 'Builder'.", "Add an ORDER BY clause to sort the results in ascending order based on the 'Builder' column."], "gold_sql": "SELECT Builder FROM railway ORDER BY Builder ASC", "source_tables": ["railway"], "description": "This virtual table provides a list of builders from the 'railway' table, sorted in ascending order by the builder's name. The query retrieves the 'Builder' column, which indicates the name of the company or individual responsible for constructing the railway.", "virtual_table": "SELECT Builder FROM railway ORDER BY Builder ASC"}
{"sample_id": "train.5643", "db_id": "railway", "question": "Show the id and builder of the railway that are associated with the most trains.", "rationale": ["The query identifies the relevant tables, 'railway' and 'train', and uses a JOIN to combine them based on the common 'Railway_ID'.", "It selects the 'Railway_ID' from the 'train' table and the 'Builder' from the 'railway' table.", "The results are grouped by 'Railway_ID' to aggregate the data, allowing for counting the number of trains associated with each railway.", "The ORDER BY clause sorts the results in descending order based on the count of trains, ensuring that the railways with the most trains appear first.", "The LIMIT clause uses a placeholder to allow the user to specify how many results they want to retrieve."], "gold_sql": "SELECT T2.Railway_ID ,  T1.Builder FROM railway AS T1 JOIN train AS T2 ON T1.Railway_ID  =  T2.Railway_ID GROUP BY T2.Railway_ID ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["train", "railway"], "description": "This virtual table provides a list of railway IDs along with the names of the builders for each railway. The data is aggregated by railway ID, showing the most frequently associated railways based on the number of trains linked to them. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.", "virtual_table": "SELECT T2.Railway_ID ,  T1.Builder FROM railway AS T1 JOIN train AS T2 ON T1.Railway_ID  =  T2.Railway_ID GROUP BY T2.Railway_ID ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5645", "db_id": "railway", "question": "Show the most common builder of railways.", "rationale": ["The query identifies the relevant table, which is 'railway'.", "Select the 'Builder' column to display the names of builders.", "Group the results by 'Builder' to aggregate the data based on builder names.", "Order the results by the count of railways each builder has constructed in descending order to show the most prolific builders first.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT Builder FROM railway GROUP BY Builder ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["railway"], "description": "This virtual table provides a list of builders from the 'railway' table, grouped by their names. It orders the results by the number of railways each builder has constructed, showing the top results based on a specified limit. The placeholder in the LIMIT clause represents the maximum number of builders to display.", "virtual_table": "SELECT Builder FROM railway GROUP BY Builder ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5707", "db_id": "dorm_1", "question": "What is the last name of every student who is either female or living in a city with the code BAL or male and under 20?", "rationale": ["The query identifies the relevant table, which is 'Student'.", "It selects the 'LName' column to display the last names of students.", "The first part of the query filters students by 'sex' and 'city_code' using placeholders for string values.", "The second part of the query filters students by 'sex' and 'age' using a placeholder for numeric values, and combines the results using UNION."], "gold_sql": "SELECT lname FROM student WHERE sex  =  'F' AND city_code  =  'BAL' UNION SELECT lname FROM student WHERE sex  =  'M' AND age  <  20", "source_tables": ["student"], "description": "This virtual table provides a list of last names of students from the 'Student' table based on specific criteria. It includes students of a certain gender residing in a specific city, as well as students of the same gender who are younger than a specified age. The placeholders in the WHERE clauses represent the gender, city code, and age criteria.", "virtual_table": "SELECT lname FROM student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND city_code  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT lname FROM student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND age  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5738", "db_id": "dorm_1", "question": "Find the number of amenities for each of the dorms that can accommodate more than 100 students.", "rationale": ["The query identifies the relevant tables, which are 'dorm' and 'has_amenity'.", "It selects the count of amenities and the dormitory ID from the 'dorm' table.", "A JOIN operation is performed between 'dorm' and 'has_amenity' on the dormitory ID to link dormitories with their amenities.", "A condition is added to filter dormitories based on their student capacity using a placeholder for numeric values.", "The results are grouped by the dormitory ID to provide a count of amenities for each qualifying dormitory."], "gold_sql": "SELECT count(*) ,  T1.dormid FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid WHERE T1.student_capacity  >  100 GROUP BY T1.dormid", "source_tables": ["has_amenity", "dorm"], "description": "This virtual table provides a count of amenities available in dormitories that can accommodate more than a specified number of students. The placeholder in the WHERE clause represents the minimum student capacity for filtering the dormitories.", "virtual_table": "SELECT count(*) ,  T1.dormid FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid WHERE T1.student_capacity  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.dormid"}
{"sample_id": "train.5747", "db_id": "dorm_1", "question": "What are the total number of students who are living in a male dorm?", "rationale": ["The query identifies the relevant tables: 'student', 'lives_in', and 'dorm'.", "It joins the 'student' table with the 'lives_in' table on the student ID to associate students with their dormitory.", "Then, it joins the 'lives_in' table with the 'dorm' table on the dormitory ID to access dormitory details.", "Finally, it adds a condition to filter the results based on the gender designation of the dormitory using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T3.gender  =  'M'", "source_tables": ["student", "lives_in", "dorm"], "description": "This virtual table provides the count of students residing in dormitories based on gender designation. The placeholders in the WHERE clause represent the gender of the dormitory.", "virtual_table": "SELECT count(*) FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T3.gender  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5756", "db_id": "dorm_1", "question": "Find the first name of students who are living in the dorm that has most number of amenities.", "rationale": ["The query identifies the relevant tables, which are 'Student', 'Lives_in', 'Dorm', 'Has_amenity', and 'Dorm_amenity'.", "It selects the 'fname' column from the 'Student' table.", "The query joins 'Student' with 'Lives_in' to find which students live in which dorms.", "A subquery is used to find dormitories with the most amenities by joining 'Dorm', 'Has_amenity', and 'Dorm_amenity', counting the amenities, and ordering them.", "The LIMIT clause uses a placeholder for the maximum number of dormitories to include in the results."], "gold_sql": "SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["has_amenity", "lives_in", "student", "dorm_amenity", "dorm"], "description": "The virtual table describes the first names of students who live in dormitories that have the most amenities. The query joins the 'Student' table with the 'Lives_in' table to find students residing in specific dorms. It then filters the dorms based on a subquery that counts the number of amenities in each dorm, ordering them in descending order and limiting the results to a specified number of dorms. The placeholder in the LIMIT clause represents the maximum number of dormitories to consider.", "virtual_table": "SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.5765", "db_id": "dorm_1", "question": "What is the first name and age of every student who lives in a dorm with a TV Lounge?", "rationale": ["The query identifies the relevant tables, 'student' and 'lives_in', to retrieve student information.", "It selects the columns 'fname' and 'age' from the 'student' table.", "A JOIN operation is performed between 'student' and 'lives_in' to link students with their respective dormitories.", "A subquery is used to filter out dormitories that have a specific amenity by checking against the 'has_amenity' and 'dorm_amenity' tables.", "The placeholder in the subquery represents the amenity's name that is being excluded from the results."], "gold_sql": "SELECT T1.fname ,  T1.age FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid NOT IN (SELECT T3.dormid FROM has_amenity AS T3 JOIN dorm_amenity AS T4 ON T3.amenid  =  T4.amenid WHERE T4.amenity_name  =  'TV Lounge')", "source_tables": ["has_amenity", "student", "lives_in", "dorm_amenity"], "description": "This virtual table describes the first names and ages of students who live in dormitories that do not have a specific amenity. The placeholders in the WHERE clause represent the amenity's name that is being filtered out.", "virtual_table": "SELECT T1.fname ,  T1.age FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid NOT IN (SELECT T3.dormid FROM has_amenity AS T3 JOIN dorm_amenity AS T4 ON T3.amenid  =  T4.amenid WHERE T4.amenity_name  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.5777", "db_id": "customer_complaints", "question": "What are the emails of customers who have filed complaints on the product which has had the greatest number of complaints?", "rationale": ["The query identifies the relevant tables, 'Customers' and 'Complaints'.", "It selects the 'email_address' from the 'Customers' table, aliased as 't1'.", "A JOIN operation is performed between 'Customers' and 'Complaints' on the 'customer_id' to link customers with their complaints.", "The results are grouped by 'customer_id' to ensure that each customer appears only once in the results.", "The results are ordered by the count of complaints for each customer, allowing us to see which customers have the most complaints.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "customers"], "description": "This virtual table provides the email addresses of customers from the 'Customers' table who have made complaints, grouped by customer to ensure unique entries. The results are ordered by the number of complaints each customer has made, and the limit on the number of results returned can be specified using a placeholder for numeric values.", "virtual_table": "SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5778", "db_id": "customer_complaints", "question": "Which products has been complained by the customer who has filed least amount of complaints?", "rationale": ["The query identifies the relevant tables: 'Products', 'Complaints', and 'Customers'.", "It selects distinct product names from the 'Products' table.", "The query joins the 'Products' table with the 'Complaints' table on the product identifier to link complaints to products.", "It further joins with the 'Customers' table to group the results by customer identifiers.", "The results are ordered by the count of complaints associated with each customer, and a limit is applied to control the number of results returned."], "gold_sql": "SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "products", "customers"], "description": "This virtual table provides a list of distinct product names from the 'Products' table that have been associated with complaints. The query joins the 'Products' table with the 'Complaints' table based on the product identifier, and then groups the results by customer identifiers from the 'Customers' table. The results are ordered by the count of complaints per customer, and a limit is applied to restrict the number of product names returned based on a specified number.", "virtual_table": "SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5795", "db_id": "customer_complaints", "question": "What is the last name of the staff member in charge of the complaint on the product with the lowest price?", "rationale": ["The query identifies the relevant tables: 'staff', 'complaints', and 'products'.", "It selects the 'last_name' column from the 'staff' table.", "The query uses JOIN operations to connect the 'staff' table with the 'complaints' table based on the 'staff_id', and then connects the 'complaints' table with the 'products' table based on the 'product_id'.", "The results are ordered by the 'product_price' from the 'products' table.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT 1", "source_tables": ["complaints", "products", "staff"], "description": "This virtual table provides a list of last names of staff members who are associated with complaints related to products. The results are ordered by the price of the products, and the number of results returned is limited by a placeholder for numeric values.", "virtual_table": "SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5796", "db_id": "customer_complaints", "question": "Which complaint status has more than 3 records on file?", "rationale": ["The query identifies the relevant table, which is 'Complaints'.", "It selects the 'complaint_status_code' to display.", "The GROUP BY clause is used to group the results by 'complaint_status_code'.", "The HAVING clause filters the groups to include only those with a count greater than a specified number, using a placeholder for numeric values."], "gold_sql": "SELECT complaint_status_code FROM complaints GROUP BY complaint_status_code HAVING count(*)  >  3", "source_tables": ["complaints"], "description": "The virtual table summarizes the different complaint status codes from the 'Complaints' table, specifically focusing on those status codes that have a count exceeding a specified number. The placeholder in the HAVING clause represents the minimum count of complaints required for a status code to be included in the results.", "virtual_table": "SELECT complaint_status_code FROM complaints GROUP BY complaint_status_code HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5801", "db_id": "customer_complaints", "question": "Count the number of customers that have the customer type that is most common.", "rationale": ["The query identifies the relevant table, which is 'Customers'.", "It uses the COUNT function to count the number of customers for each type, grouping the results by 'customer_type_code'.", "The results are ordered in descending order based on the count of customers, allowing the most common customer types to appear first.", "A LIMIT clause is included to restrict the number of results returned, with a placeholder for the user to specify the desired number."], "gold_sql": "SELECT count(*) FROM customers GROUP BY customer_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers"], "description": "This virtual table provides a count of customers grouped by their type, allowing for an analysis of the distribution of different customer types. The placeholder in the LIMIT clause represents the maximum number of customer types to display, enabling users to specify how many top customer types they wish to see.", "virtual_table": "SELECT count(*) FROM customers GROUP BY customer_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5810", "db_id": "customer_complaints", "question": "What is first names of the top 5 staff who have handled the greatest number of complaints?", "rationale": ["The query identifies the relevant tables, which are 'Staff' and 'Complaints'.", "It selects the 'first_name' column from the 'Staff' table.", "A JOIN operation is performed between 'Staff' and 'Complaints' on the 'staff_id' column to link staff members to the complaints they handle.", "The results are grouped by 'staff_id' to aggregate the data for each staff member.", "The results are ordered by the count of complaints handled by each staff member.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT 5", "source_tables": ["complaints", "staff"], "description": "This virtual table provides the first names of staff members from the 'Staff' table who are associated with complaints in the 'Complaints' table. The results are grouped by staff member and ordered by the number of complaints they have handled, with a limit specified by a placeholder for numeric values.", "virtual_table": "SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5811", "db_id": "customer_complaints", "question": "Return the first names of the 5 staff members who have handled the most complaints.", "rationale": ["The query identifies the relevant tables, which are 'Staff' and 'Complaints'.", "It selects the 'first_name' column from the 'Staff' table, aliased as 't1'.", "A JOIN operation is performed between 'Staff' and 'Complaints' on the 'staff_id' column to link staff members to the complaints they handle.", "The results are grouped by 'staff_id' from the 'Complaints' table to aggregate the data per staff member.", "The results are ordered by the count of complaints handled by each staff member, allowing us to see who has the most complaints.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT 5", "source_tables": ["complaints", "staff"], "description": "This virtual table provides the first names of staff members from the 'Staff' table who are associated with complaints in the 'Complaints' table. The results are grouped by staff member and ordered by the number of complaints they have handled, with a limit on the number of results returned based on a specified number.", "virtual_table": "SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5845", "db_id": "tracking_share_transactions", "question": "Show all investor details.", "rationale": ["The query identifies the relevant table, which is 'Investors'.", "Select the column to display, 'Investor_details'."], "gold_sql": "SELECT Investor_details FROM INVESTORS", "source_tables": ["investors"], "description": "This virtual table provides detailed information about investors from the 'Investors' table. The query selects the 'Investor_details' column, which contains specific information regarding each investor.", "virtual_table": "SELECT Investor_details FROM INVESTORS"}
{"sample_id": "train.5858", "db_id": "tracking_share_transactions", "question": "Show details of all investors if they make any transaction with share count greater than 100.", "rationale": ["The query identifies the relevant tables, which are 'Investors' and 'Transactions'.", "It selects the 'Investor_details' column from the 'Investors' table.", "A JOIN operation is performed between 'Investors' and 'Transactions' on the 'investor_id' to link investors with their transactions.", "A condition is added to filter the results based on the 'share_count' column from the 'Transactions' table, using a placeholder for numeric values."], "gold_sql": "SELECT T1.Investor_details FROM  INVESTORS AS T1 JOIN TRANSACTIONS AS T2 ON T1.investor_id  =  T2.investor_id WHERE T2.share_count  >  100", "source_tables": ["transactions", "investors"], "description": "This virtual table provides detailed information about investors from the 'Investors' table who have made transactions involving a number of shares greater than a specified amount. The placeholder in the WHERE clause represents the minimum share count for filtering the transactions.", "virtual_table": "SELECT T1.Investor_details FROM  INVESTORS AS T1 JOIN TRANSACTIONS AS T2 ON T1.investor_id  =  T2.investor_id WHERE T2.share_count  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5864", "db_id": "tracking_share_transactions", "question": "What are the lot details of lots associated with transactions with share count smaller than 50?", "rationale": ["The query identifies the relevant tables: 'Lots', 'Transactions_Lots', and 'Transactions'.", "It selects the 'lot_details' column from the 'Lots' table.", "The query uses JOINs to connect 'Lots' with 'Transactions_Lots' and 'Transactions' based on their respective identifiers.", "A condition is added to filter the results where the 'share_count' in the 'Transactions' table is less than a specified numeric value using a placeholder."], "gold_sql": "SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  <  50", "source_tables": ["lots", "transactions_lots", "transactions"], "description": "This virtual table describes the details of lots associated with transactions where the number of shares involved in the transaction is less than a specified amount. The placeholders in the WHERE clause represent the numeric value for the share count.", "virtual_table": "SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5866", "db_id": "tracking_share_transactions", "question": "Show the average transaction amount for different transaction types.", "rationale": ["The query identifies the relevant table, which is 'Transactions'.", "It selects the 'transaction_type_code' to categorize the transactions.", "The query calculates the average of 'amount_of_transaction' for each transaction type.", "The GROUP BY clause is used to group the results by 'transaction_type_code' to get the average amount for each type."], "gold_sql": "SELECT transaction_type_code ,  avg(amount_of_transaction) FROM TRANSACTIONS GROUP BY transaction_type_code", "source_tables": ["transactions"], "description": "This virtual table summarizes the average amount of transactions grouped by their respective transaction types from the 'Transactions' table. The placeholder in the SELECT clause represents the transaction type code, while the average amount is calculated for each type.", "virtual_table": "SELECT transaction_type_code ,  avg(amount_of_transaction) FROM TRANSACTIONS GROUP BY transaction_type_code"}
{"sample_id": "train.5867", "db_id": "tracking_share_transactions", "question": "Show the maximum and minimum share count of different transaction types.", "rationale": ["The query identifies the relevant table, which is 'Transactions'.", "It selects the 'transaction_type_code' to categorize the results by transaction type.", "The query uses aggregate functions 'max' and 'min' to calculate the maximum and minimum share counts for each transaction type.", "The 'GROUP BY' clause is used to group the results by 'transaction_type_code' to ensure the aggregation is performed for each type of transaction."], "gold_sql": "SELECT transaction_type_code ,  max(share_count) ,  min(share_count) FROM TRANSACTIONS GROUP BY transaction_type_code", "source_tables": ["transactions"], "description": "This virtual table summarizes the maximum and minimum share counts for each type of transaction recorded in the 'Transactions' table. The placeholder in the SELECT clause represents the transaction type code, while the aggregation functions calculate the maximum and minimum share counts for each group of transaction types.", "virtual_table": "SELECT transaction_type_code ,  max(share_count) ,  min(share_count) FROM TRANSACTIONS GROUP BY transaction_type_code"}
{"sample_id": "train.5883", "db_id": "tracking_share_transactions", "question": "What are the details of all sales and purchases?", "rationale": ["The query is identifying the relevant tables, which are 'Sales' and 'Purchases'.", "It selects the 'sales_details' from the 'Sales' table and 'purchase_details' from the 'Purchases' table.", "The UNION operator is used to combine the results from both tables into a single result set, allowing for a unified view of transaction details."], "gold_sql": "SELECT sales_details FROM sales UNION SELECT purchase_details FROM purchases", "source_tables": ["sales", "purchases"], "description": "This virtual table combines the details of sales and purchase transactions from the 'Sales' and 'Purchases' tables. The placeholder in the SELECT statements allows for the retrieval of specific details related to sales and purchases.", "virtual_table": "SELECT sales_details FROM sales UNION SELECT purchase_details FROM purchases"}
