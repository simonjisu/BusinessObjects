{"sample_id": "train.56", "db_id": "student_assessment", "question": "which course has most number of registered students?", "rationale": ["The query identifies the relevant tables, 'Courses' and 'Student_Course_Registrations'.", "It selects the 'course_name' from the 'Courses' table.", "A JOIN operation is performed to link courses with their registrations based on the course ID.", "The results are grouped by 'course_id' to aggregate the data for each course.", "The results are ordered by the count of registrations in descending order to highlight the most popular courses.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.course_name FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_Id GROUP BY T1.course_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["courses", "student_course_registrations"], "description": "This virtual table provides a list of course names from the 'Courses' table, which are associated with student registrations. The results are grouped by course ID and ordered by the number of registrations in descending order, allowing users to see the most popular courses. The placeholder in the LIMIT clause represents the maximum number of courses to return.", "virtual_table": "SELECT T1.course_name FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_Id GROUP BY T1.course_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.64", "db_id": "student_assessment", "question": "List the id of students who attended some courses?", "rationale": ["The query is identifying the relevant table, which is 'Student_Course_Attendance'.", "Select the column to display, 'student_id'.", "No additional conditions or filters are applied in this query, so it retrieves all student identifiers from the attendance records."], "gold_sql": "SELECT student_id FROM student_course_attendance", "source_tables": ["student_course_attendance"], "description": "This virtual table describes the identifiers of students who have attended courses from the 'Student_Course_Attendance' table. The placeholder in the SELECT clause represents the unique student identifiers.", "virtual_table": "SELECT student_id FROM student_course_attendance"}
{"sample_id": "train.65", "db_id": "student_assessment", "question": "What are the ids of all students who have attended at least one course?", "rationale": ["The query is identifying the relevant table, which is 'Student_Course_Attendance'.", "Select the column to display, 'student_id', which represents the unique identifier for each student."], "gold_sql": "SELECT student_id FROM student_course_attendance", "source_tables": ["student_course_attendance"], "description": "This virtual table describes the identifiers of students who have attended courses from the 'Student_Course_Attendance' table. The placeholder in the SELECT clause represents the unique identifier for each student.", "virtual_table": "SELECT student_id FROM student_course_attendance"}
{"sample_id": "train.76", "db_id": "student_assessment", "question": "What is the id of the candidate who most recently accessed the course?", "rationale": ["The query identifies the relevant table, which is 'Candidate_Assessments'.", "It selects the 'candidate_id' column to display the IDs of candidates.", "The results are ordered by 'assessment_date' in descending order to show the most recent assessments first.", "A placeholder is used in the LIMIT clause to allow the user to specify how many candidate IDs to return."], "gold_sql": "SELECT candidate_id FROM candidate_assessments ORDER BY assessment_date DESC LIMIT 1", "source_tables": ["candidate_assessments"], "description": "This virtual table provides a list of candidate IDs from the 'Candidate_Assessments' table, ordered by the date of assessment in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of candidate IDs to retrieve.", "virtual_table": "SELECT candidate_id FROM candidate_assessments ORDER BY assessment_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.77", "db_id": "student_assessment", "question": "What is detail of the student who registered the most number of courses?", "rationale": ["The query identifies the relevant tables, 'Students' and 'Student_Course_Registrations'.", "It selects the 'student_details' column from the 'Students' table.", "A JOIN operation is performed to link students with their course registrations based on the 'student_id'.", "The results are grouped by 'student_id' to avoid duplicates and to count the number of registrations per student.", "The results are ordered by the count of registrations in descending order to prioritize students with the most registrations.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_course_registrations", "students"], "description": "This virtual table provides a list of student details from the 'Students' table, specifically for those students who have registered for courses. The results are grouped by each student to ensure unique entries and are ordered by the number of course registrations in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of student details to return.", "virtual_table": "SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.82", "db_id": "student_assessment", "question": "For each course id, how many students are registered and what are the course names?", "rationale": ["The query identifies the relevant tables: 'Students', 'Student_Course_Registrations', and 'Courses'.", "It selects the 'course_name' from the 'Courses' table and counts the number of registrations.", "The join operation connects 'Students' to 'Student_Course_Registrations' using 'student_id', and then connects 'Student_Course_Registrations' to 'Courses' using 'course_id'.", "The results are grouped by 'course_id' to aggregate the count of students for each course."], "gold_sql": "SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id", "source_tables": ["courses", "student_course_registrations", "students"], "description": "This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve the course names. The result is grouped by course ID to count the number of students per course.", "virtual_table": "SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id"}
{"sample_id": "train.90", "db_id": "student_assessment", "question": "What are the ids of the students who registered for course 301 most recently?", "rationale": ["The query identifies the relevant table, which is 'Student_Course_Attendance'.", "It selects the 'student_id' column to display the identifiers of students who attended a specific course.", "A condition is added to filter the results based on the 'course_id' using a placeholder for numeric values.", "The results are ordered by 'date_of_attendance' in descending order to show the most recent attendance first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT student_id FROM student_course_attendance WHERE course_id = 301 ORDER BY date_of_attendance DESC LIMIT 1", "source_tables": ["student_course_attendance"], "description": "This virtual table provides a list of student identifiers from the 'Student_Course_Attendance' table for a specific course. The results are ordered by the date of attendance in descending order, and the number of results returned is limited by a placeholder for numeric values.", "virtual_table": "SELECT student_id FROM student_course_attendance WHERE course_id = [PLACEHOLDER-TYPE:NUMBER] ORDER BY date_of_attendance DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.93", "db_id": "student_assessment", "question": "Find distinct cities of address of students?", "rationale": ["The query identifies the relevant tables: 'Addresses', 'People_Addresses', and 'Students'.", "It selects distinct cities from the 'Addresses' table.", "The join conditions link the addresses to the people and then to the students, ensuring that only cities associated with students are included."], "gold_sql": "SELECT DISTINCT T1.city FROM addresses AS T1 JOIN people_addresses AS T2 ON T1.address_id = T2.address_id JOIN students AS T3 ON T2.person_id = T3.student_id", "source_tables": ["addresses", "people_addresses", "students"], "description": "This virtual table provides a distinct list of cities where students are located, by joining the 'Addresses', 'People_Addresses', and 'Students' tables. The placeholders in the query represent the necessary identifiers for the relationships between these tables.", "virtual_table": "SELECT DISTINCT T1.city FROM addresses AS T1 JOIN people_addresses AS T2 ON T1.address_id = T2.address_id JOIN students AS T3 ON T2.person_id = T3.student_id"}
{"sample_id": "train.104", "db_id": "student_assessment", "question": "What are all details of the students who registered but did not attend any course?", "rationale": ["The query identifies the relevant table, which is 'student_course_registrations'.", "It selects all columns from this table.", "A condition is added to filter out students who have attended any courses by using a subquery that checks for student IDs in the 'student_course_attendance' table."], "gold_sql": "SELECT * FROM student_course_registrations WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)", "source_tables": ["student_course_attendance", "student_course_registrations"], "description": "This virtual table provides a list of all course registrations for students who have not attended any courses. The query retrieves all columns from the 'student_course_registrations' table, filtering out students based on their attendance records using a subquery that checks for student IDs in the 'student_course_attendance' table.", "virtual_table": "SELECT * FROM student_course_registrations WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)"}
{"sample_id": "train.105", "db_id": "student_assessment", "question": "List the id of students who registered course statistics in the order of registration date.", "rationale": ["The query identifies the relevant tables, 'Courses' and 'Student_Course_Registrations'.", "It performs a JOIN operation to link the courses with their respective student registrations based on the course ID.", "The WHERE clause filters the results to include only those registrations for a specific course name, using a placeholder for the course name.", "Finally, the results are ordered by the registration date to show the sequence of student registrations."], "gold_sql": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = 'statistics' ORDER BY T2.registration_date", "source_tables": ["courses", "student_course_registrations"], "description": "This virtual table provides a list of student IDs from the 'Students' table who are registered for a specific course. The course is identified by its name, which is represented by a placeholder in the WHERE clause. The results are ordered by the date of registration, allowing for an organized view of when each student registered for the course.", "virtual_table": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = [PLACEHOLDER-TYPE:STRING] ORDER BY T2.registration_date"}
{"sample_id": "train.106", "db_id": "student_assessment", "question": "What are the ids of the students who registered course statistics by order of registration date?", "rationale": ["The query identifies the relevant tables, 'Courses' and 'Student_Course_Registrations'.", "It performs a JOIN operation to link the courses with their respective student registrations based on the course ID.", "The WHERE clause filters the results to include only those registrations for a specific course name, using a placeholder for the course name.", "Finally, the results are ordered by the registration date to show the sequence of student registrations."], "gold_sql": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = 'statistics' ORDER BY T2.registration_date", "source_tables": ["courses", "student_course_registrations"], "description": "This virtual table provides a list of student IDs from the 'Students' table who are registered for a specific course. The course is identified by its name, which is represented by a placeholder in the WHERE clause. The results are ordered by the date of registration, allowing for an organized view of when each student registered for the course.", "virtual_table": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = [PLACEHOLDER-TYPE:STRING] ORDER BY T2.registration_date"}
{"sample_id": "train.123", "db_id": "bike_1", "question": "For each zip code, return the average mean temperature of August there.", "rationale": ["The query identifies the relevant table, which is 'weather'.", "Select the 'zip_code' and the average of 'mean_temperature_f' to display the average temperature for each zip code.", "Add a condition to filter the 'date' column for the specified date using a placeholder for string values.", "Group the results by 'zip_code' to get the average temperature for each unique zip code."], "gold_sql": "SELECT zip_code  ,  avg(mean_temperature_f) FROM weather WHERE date LIKE '8/%' GROUP BY zip_code", "source_tables": ["weather"], "description": "This virtual table provides the average mean temperature in Fahrenheit for each zip code based on weather reports for a specific date. The placeholder in the WHERE clause represents the date for which the weather data is being queried.", "virtual_table": "SELECT zip_code  ,  avg(mean_temperature_f) FROM weather WHERE date LIKE [PLACEHOLDER-TYPE:STRING] GROUP BY zip_code"}
{"sample_id": "train.135", "db_id": "bike_1", "question": "Which bike traveled the most often in zip code 94002?", "rationale": ["The query identifies the relevant table, which is 'trip'.", "Select the column to display, 'bike_id'.", "Add a condition to filter the 'zip_code' column for the specified zip code using a placeholder for numeric values.", "Group the results by 'bike_id' to aggregate the trips for each bike.", "Order the results by the count of trips in descending order to show the most frequently used bikes first.", "Limit the number of results returned based on a specified number using a placeholder."], "gold_sql": "SELECT bike_id FROM trip WHERE zip_code  =  94002 GROUP BY bike_id ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["trip"], "description": "This virtual table provides a list of bike identifiers from the 'trip' table for users who started their trips from a specific zip code. The results are grouped by bike identifier and ordered by the number of trips taken with each bike, allowing users to see which bikes are most frequently used in that area. The placeholders in the WHERE clause represent the zip code of interest and the limit on the number of results to return.", "virtual_table": "SELECT bike_id FROM trip WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY bike_id ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.136", "db_id": "bike_1", "question": "What is the id of the bike that traveled the most in 94002?", "rationale": ["The query identifies the relevant table, which is 'trip'.", "Select the column to display, 'bike_id'.", "Add a condition to filter the 'zip_code' column for the specified zip code using a placeholder for numeric values.", "Group the results by 'bike_id' to aggregate the trips for each bike.", "Order the results by the count of trips in descending order to show the most frequently used bikes first.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT bike_id FROM trip WHERE zip_code  =  94002 GROUP BY bike_id ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["trip"], "description": "This virtual table provides a list of bike identifiers from the 'trip' table for users who started their trips from a specific zip code. The results are grouped by bike identifier and ordered by the number of trips taken, allowing users to see which bikes are most frequently used in that area. The placeholders in the WHERE clause represent the zip code and the limit on the number of results to return.", "virtual_table": "SELECT bike_id FROM trip WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY bike_id ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.143", "db_id": "bike_1", "question": "What are the names and ids of stations that had more than 14 bikes available on average or were installed in December?", "rationale": ["The query identifies the relevant tables, which are 'station' and 'status'.", "It selects the columns 'name' and 'id' from the 'station' table.", "The first part of the query joins the 'station' table with the 'status' table on the station ID, grouping by station ID and filtering for those with an average number of available bikes greater than a specified number using a placeholder.", "The second part of the query selects names and IDs from the 'station' table where the installation date matches a specified pattern using a placeholder."], "gold_sql": "SELECT T1.name ,  T1.id FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(T2.bikes_available)  >  14 UNION SELECT name ,  id FROM station WHERE installation_date LIKE '12/%'", "source_tables": ["status", "station"], "description": "This virtual table provides a list of bike stations along with their unique identifiers. It includes stations that have an average number of available bikes exceeding a specified threshold, as well as stations that were installed on a specific date. The first part of the query retrieves the names and IDs of stations from the 'station' table that are joined with the 'status' table, filtering based on the average number of bikes available. The second part of the query retrieves names and IDs of stations from the 'station' table based on the installation date, using a placeholder for the date format.", "virtual_table": "SELECT T1.name ,  T1.id FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(T2.bikes_available)  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT name ,  id FROM station WHERE installation_date LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.144", "db_id": "bike_1", "question": "What are the names and ids of all stations that have more than 14 bikes available on average or had bikes installed in December?", "rationale": ["The query identifies the relevant tables, which are 'station' and 'status'.", "It selects the 'name' and 'id' columns from the 'station' table.", "The first part of the query joins the 'station' and 'status' tables on the station ID, grouping by station ID and filtering for those with an average number of bikes available greater than a specified number using a placeholder.", "The second part of the query selects the 'name' and 'id' from the 'station' table where the installation date matches a specified string using a placeholder.", "The UNION operator combines the results from both parts of the query."], "gold_sql": "SELECT T1.name ,  T1.id FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(T2.bikes_available)  >  14 UNION SELECT name ,  id FROM station WHERE installation_date LIKE '12/%'", "source_tables": ["status", "station"], "description": "This virtual table provides a list of bike stations along with their unique identifiers. It includes stations that have an average number of available bikes exceeding a specified threshold, as well as stations that were installed on a specific date. The placeholders in the query allow users to specify the minimum average bikes available and the installation date criteria.", "virtual_table": "SELECT T1.name ,  T1.id FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(T2.bikes_available)  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT name ,  id FROM station WHERE installation_date LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.145", "db_id": "bike_1", "question": "What is the 3 most common cloud cover rates in the region of zip code 94107?", "rationale": ["The query identifies the relevant table, which is 'weather'.", "Select the column 'cloud_cover' to display the cloud cover data.", "Add a condition to filter the results based on the specified zip code using a placeholder for numeric values.", "Group the results by 'cloud_cover' to aggregate the data based on different cloud cover values.", "Order the results by the count of occurrences of each cloud cover value in descending order to show the most common conditions first.", "Limit the number of results returned based on a specified number using a placeholder."], "gold_sql": "SELECT cloud_cover FROM weather WHERE zip_code  =  94107 GROUP BY cloud_cover ORDER BY COUNT (*) DESC LIMIT 3", "source_tables": ["weather"], "description": "This virtual table provides the cloud cover data from the 'weather' table for a specific zip code. The results are grouped by cloud cover values and ordered by the frequency of each cloud cover value, allowing users to see the most common cloud cover conditions for the specified area. The placeholders in the WHERE clause represent the zip code, and the LIMIT clause allows for specifying the maximum number of results to return.", "virtual_table": "SELECT cloud_cover FROM weather WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY cloud_cover ORDER BY COUNT (*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.161", "db_id": "bike_1", "question": "For each trip, return its ending station's installation date.", "rationale": ["The query identifies the relevant tables, which are 'trip' and 'station'.", "It selects the 'id' from the 'trip' table and 'installation_date' from the 'station' table.", "A JOIN operation is performed on the 'end_station_id' from the 'trip' table and the 'id' from the 'station' table to link trips to their respective stations."], "gold_sql": "SELECT T1.id ,  T2.installation_date FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id", "source_tables": ["trip", "station"], "description": "This virtual table provides a list of trip identifiers along with the installation dates of the bike stations where the trips ended. The data is sourced from the 'trip' table and the 'station' table, linked by the end station identifier.", "virtual_table": "SELECT T1.id ,  T2.installation_date FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id"}
{"sample_id": "train.162", "db_id": "bike_1", "question": "What is the installation date for each ending station on all the trips?", "rationale": ["The query identifies the relevant tables, which are 'trip' and 'station'.", "It selects the 'id' from the 'trip' table and 'installation_date' from the 'station' table.", "A JOIN operation is performed on the 'end_station_id' from the 'trip' table and the 'id' from the 'station' table to link trips to their respective stations."], "gold_sql": "SELECT T1.id ,  T2.installation_date FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id", "source_tables": ["trip", "station"], "description": "This virtual table provides a list of trip identifiers along with the installation dates of the bike stations where the trips ended. The data is sourced from the 'trip' table and the 'station' table, linked by the end station identifier.", "virtual_table": "SELECT T1.id ,  T2.installation_date FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id"}
{"sample_id": "train.163", "db_id": "bike_1", "question": "Which trip started from the station with the largest dock count? Give me the trip id.", "rationale": ["The query identifies the relevant tables, which are 'trip' and 'station'.", "It selects the unique identifiers from the 'trip' table (T1.id).", "A JOIN operation is performed to link trips to their starting stations based on the station ID.", "The results are ordered by the 'dock_count' from the 'station' table in descending order to prioritize stations with more docks.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT 1", "source_tables": ["trip", "station"], "description": "This virtual table lists the unique identifiers of trips from the 'trip' table, specifically focusing on those that started at various bike stations. The results are ordered by the number of docks available at each station in descending order, allowing users to see which stations with the most docks are associated with the trips. The placeholder in the LIMIT clause represents the maximum number of trip identifiers to return.", "virtual_table": "SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.165", "db_id": "bike_1", "question": "Count the number of trips that did not end in San Francisco city.", "rationale": ["The query identifies the relevant tables, which are 'trip' and 'station'.", "It uses a JOIN operation to connect the 'trip' table with the 'station' table based on the end station ID.", "The COUNT function is used to count the total number of trips that meet the specified condition.", "A condition is added to filter out trips that ended at stations in a specific city using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id WHERE T2.city !=  'San Francisco'", "source_tables": ["trip", "station"], "description": "This virtual table counts the number of trips that ended at stations located in cities other than a specified city. The placeholder in the WHERE clause represents the name of the city to exclude from the count.", "virtual_table": "SELECT count(*) FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id WHERE T2.city !=  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.166", "db_id": "bike_1", "question": "How many trips did not end in San Francisco?", "rationale": ["The query identifies the relevant tables, which are 'trip' and 'station'.", "It uses a JOIN operation to connect the 'trip' table with the 'station' table based on the end station ID.", "The SELECT statement counts the total number of trips that meet the specified condition.", "A condition is added to filter out trips that ended at stations in a specific city using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id WHERE T2.city != 'San Francisco'", "source_tables": ["trip", "station"], "description": "This virtual table provides the count of trips that ended at stations located in cities other than a specified city. The placeholder in the WHERE clause represents the name of the city to exclude from the count.", "virtual_table": "SELECT count(*) FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id WHERE T2.city != [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.167", "db_id": "bike_1", "question": "In zip code 94107, on which day neither Fog nor Rain was not observed?", "rationale": ["The query identifies the relevant table, which is 'weather'.", "Select the 'date' column to display the dates of the weather reports.", "Add conditions to filter the results based on the specified zip code and to exclude certain weather events using placeholders for numeric and string values."], "gold_sql": "SELECT date FROM weather WHERE zip_code  =  94107 AND EVENTS != 'Fog' AND EVENTS != 'Rain'", "source_tables": ["weather"], "description": "This virtual table provides the dates of weather reports from the 'weather' table for a specific zip code, excluding certain weather events. The placeholders in the WHERE clause represent the zip code and the types of weather events to be filtered out.", "virtual_table": "SELECT date FROM weather WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER] AND EVENTS != [PLACEHOLDER-TYPE:STRING] AND EVENTS != [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.168", "db_id": "bike_1", "question": "On which day has it neither been foggy nor rained in the zip code of 94107?", "rationale": ["The query identifies the relevant table, which is 'weather'.", "Select the 'date' column to display the dates of the weather reports.", "Add conditions to filter the results based on the specified zip code and to exclude certain weather events using placeholders for numeric and string values."], "gold_sql": "SELECT date FROM weather WHERE zip_code  =  94107 AND EVENTS != 'Fog' AND EVENTS != 'Rain'", "source_tables": ["weather"], "description": "This virtual table provides the dates of weather reports from the 'weather' table for a specific zip code, excluding certain weather events. The placeholders in the WHERE clause represent the zip code and the types of weather events to be filtered out.", "virtual_table": "SELECT date FROM weather WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER] AND EVENTS != [PLACEHOLDER-TYPE:STRING] AND EVENTS != [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.183", "db_id": "bike_1", "question": "List all the cities in a decreasing order of each city's stations' highest latitude.", "rationale": ["The query identifies the relevant table, which is 'station'.", "It selects the 'city' column to display unique city names.", "The GROUP BY clause is used to ensure that each city is listed only once.", "The ORDER BY clause sorts the cities based on the maximum latitude of the stations, allowing for a geographical ordering from north to south."], "gold_sql": "SELECT city FROM station GROUP BY city ORDER BY max(lat) DESC", "source_tables": ["station"], "description": "This virtual table provides a list of unique cities where bike stations are located, sorted by the maximum latitude of the stations in each city. The placeholder in the ORDER BY clause indicates that the cities will be ordered based on their geographical position from north to south.", "virtual_table": "SELECT city FROM station GROUP BY city ORDER BY max(lat) DESC"}
{"sample_id": "train.184", "db_id": "bike_1", "question": "For each city, list their names in decreasing order by their highest station latitude.", "rationale": ["The query identifies the relevant table, which is 'station'.", "It selects the 'city' column to display unique city names.", "The GROUP BY clause is used to ensure that each city is listed only once.", "The ORDER BY clause sorts the cities based on the maximum latitude of the stations in each city, using the max function on the 'lat' column."], "gold_sql": "SELECT city FROM station GROUP BY city ORDER BY max(lat) DESC", "source_tables": ["station"], "description": "This virtual table provides a list of unique cities where bike stations are located, sorted by the maximum latitude of the stations in each city. The placeholder in the ORDER BY clause indicates that the cities will be ordered based on their geographical position, specifically the highest latitude.", "virtual_table": "SELECT city FROM station GROUP BY city ORDER BY max(lat) DESC"}
{"sample_id": "train.189", "db_id": "bike_1", "question": "For each station, return its longitude and the average duration of trips that started from the station.", "rationale": ["The query identifies the relevant tables, which are 'station' and 'trip'.", "It selects the 'name' and 'long' columns from the 'station' table, and calculates the average trip duration from the 'trip' table.", "A JOIN operation is performed on the 'id' of the 'station' table and the 'start_station_id' of the 'trip' table to link trips to their starting stations.", "The results are grouped by 'start_station_id' to compute the average duration for trips starting at each station."], "gold_sql": "SELECT T1.name ,  T1.long ,  avg(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id GROUP BY T2.start_station_id", "source_tables": ["trip", "station"], "description": "This virtual table provides the names and longitude coordinates of bike stations from the 'station' table, along with the average duration of trips that started at each station. The data is aggregated by the start station identifier, allowing users to see how long trips typically last from each location.", "virtual_table": "SELECT T1.name ,  T1.long ,  avg(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id GROUP BY T2.start_station_id"}
{"sample_id": "train.190", "db_id": "bike_1", "question": "For each start station id, what is its name, longitude and average duration of trips started there?", "rationale": ["The query identifies the relevant tables, which are 'station' and 'trip'.", "It selects the 'name' and 'long' columns from the 'station' table, and calculates the average trip duration from the 'trip' table.", "A JOIN operation is performed on the 'station' and 'trip' tables using the station ID to link trips to their starting stations.", "The results are grouped by the start station ID to compute the average duration for trips starting at each station."], "gold_sql": "SELECT T1.name ,  T1.long ,  avg(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id GROUP BY T2.start_station_id", "source_tables": ["trip", "station"], "description": "This virtual table provides the names and longitude coordinates of bike stations from the 'station' table, along with the average duration of trips that started at each station. The data is aggregated by the start station identifier, allowing users to see how long trips typically last from each location.", "virtual_table": "SELECT T1.name ,  T1.long ,  avg(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id GROUP BY T2.start_station_id"}
{"sample_id": "train.192", "db_id": "bike_1", "question": "For each end station id, what is its name, latitude, and minimum duration for trips ended there?", "rationale": ["The query identifies the relevant tables, which are 'station' and 'trip'.", "It selects the 'name' and 'lat' columns from the 'station' table (aliased as T1).", "It calculates the minimum trip duration from the 'trip' table (aliased as T2) for trips that ended at each station.", "The JOIN operation links the two tables on the condition that the 'id' of the station matches the 'end_station_id' of the trip.", "The results are grouped by the 'end_station_id' to ensure that the minimum duration is calculated for each station."], "gold_sql": "SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id", "source_tables": ["trip", "station"], "description": "This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.", "virtual_table": "SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id"}
{"sample_id": "train.196", "db_id": "bike_1", "question": "What are all the different zip codes that have a maximum dew point that was always below 70?", "rationale": ["The query starts by selecting distinct zip codes from the 'weather' table.", "It uses the EXCEPT clause to exclude zip codes that have a maximum dew point greater than or equal to a specified value.", "The placeholder in the WHERE clause represents the maximum dew point threshold that the user can define."], "gold_sql": "SELECT DISTINCT zip_code FROM weather EXCEPT SELECT DISTINCT zip_code FROM weather WHERE max_dew_point_f  >=  70", "source_tables": ["weather"], "description": "This virtual table provides a list of unique zip codes from the 'weather' table that do not have any recorded maximum dew point above a specified threshold. The placeholder in the query allows users to specify the maximum dew point value for filtering the results.", "virtual_table": "SELECT DISTINCT zip_code FROM weather EXCEPT SELECT DISTINCT zip_code FROM weather WHERE max_dew_point_f  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.205", "db_id": "bike_1", "question": "Give me the zip code where the average mean humidity is below 70 and at least 100 trips took place.", "rationale": ["The query is identifying relevant tables, which are 'weather' and 'trip'.", "It selects the 'zip_code' from the 'weather' table, grouping by 'zip_code' and applying a condition to filter those with an average mean humidity below a specified value using a placeholder for numeric values.", "It intersects this with a selection from the 'trip' table, grouping by 'zip_code' and applying a condition to filter those with a count of trips greater than or equal to a specified value, also using a placeholder for numeric values."], "gold_sql": "SELECT zip_code FROM weather GROUP BY zip_code HAVING avg(mean_humidity)  <  70 INTERSECT SELECT zip_code FROM trip GROUP BY zip_code HAVING count(*)  >=  100", "source_tables": ["weather", "trip"], "description": "This virtual table identifies zip codes where the average mean humidity is below a specified threshold and where the number of trips originating from those zip codes meets or exceeds a certain count. The placeholders in the HAVING clauses represent the humidity threshold and the minimum trip count, respectively.", "virtual_table": "SELECT zip_code FROM weather GROUP BY zip_code HAVING avg(mean_humidity)  <  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT zip_code FROM trip GROUP BY zip_code HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.206", "db_id": "bike_1", "question": "What are the zip codes that have an average mean humidity below 70 and had at least 100 trips come through there?", "rationale": ["The query is identifying relevant tables, which are 'weather' and 'trip'.", "It selects the 'zip_code' from the 'weather' table, grouping by 'zip_code' and applying a condition to filter those with an average mean humidity below a specified number using a placeholder.", "It intersects this with a selection from the 'trip' table, grouping by 'zip_code' and applying a condition to filter those with a count of trips greater than or equal to a specified number using another placeholder."], "gold_sql": "SELECT zip_code FROM weather GROUP BY zip_code HAVING avg(mean_humidity)  <  70 INTERSECT SELECT zip_code FROM trip GROUP BY zip_code HAVING count(*)  >=  100", "source_tables": ["weather", "trip"], "description": "This virtual table identifies zip codes where the average mean humidity is below a specified threshold and where the number of trips originating from those zip codes meets or exceeds a certain count. The placeholders in the HAVING clauses represent the humidity threshold and the minimum trip count, respectively.", "virtual_table": "SELECT zip_code FROM weather GROUP BY zip_code HAVING avg(mean_humidity)  <  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT zip_code FROM trip GROUP BY zip_code HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.304", "db_id": "product_catalog", "question": "What are the attribute data types with more than 3 attribute definitions?", "rationale": ["The query identifies the relevant table, which is 'Attribute_Definitions'.", "It selects the 'attribute_data_type' column to display the various data types.", "The GROUP BY clause is used to group the results by 'attribute_data_type'.", "The HAVING clause filters the groups to include only those with a count greater than a specified number, using a placeholder for numeric values."], "gold_sql": "SELECT attribute_data_type FROM Attribute_Definitions GROUP BY attribute_data_type HAVING count(*)  >  3", "source_tables": ["attribute_definitions"], "description": "This virtual table provides a summary of the different data types defined in the 'Attribute_Definitions' table, specifically those that have more than a specified number of occurrences. The placeholder in the HAVING clause represents the minimum count of attributes required to be included in the results.", "virtual_table": "SELECT attribute_data_type FROM Attribute_Definitions GROUP BY attribute_data_type HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.316", "db_id": "product_catalog", "question": "Find the entry names of the catalog with the attribute that have the most entries.", "rationale": ["The query identifies the relevant tables, 'Catalog_Contents' and 'Catalog_Contents_Additional_Attributes'.", "It selects the 'catalog_entry_name' from 'Catalog_Contents'.", "A JOIN is performed on 'catalog_entry_id' to link the two tables based on the catalog entry.", "A subquery is used to find the most common 'attribute_value' from 'Catalog_Contents_Additional_Attributes', grouping by 'attribute_value' and ordering by count to get the top results.", "The placeholder in the LIMIT clause allows the user to specify how many top attribute values they want to retrieve."], "gold_sql": "SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.attribute_value  =  (SELECT attribute_value FROM Catalog_Contents_Additional_Attributes GROUP BY attribute_value ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["catalog_contents", "catalog_contents_additional_attributes"], "description": "This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that have the most common attribute values associated with them. The placeholder in the LIMIT clause represents the number of top attribute values to consider.", "virtual_table": "SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.attribute_value  =  (SELECT attribute_value FROM Catalog_Contents_Additional_Attributes GROUP BY attribute_value ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.317", "db_id": "product_catalog", "question": "What is the entry name of the most expensive catalog (in USD)?", "rationale": ["The query identifies the relevant table, which is 'Catalog_Contents'.", "Select the column to display, 'catalog_entry_name'.", "Order the results by 'price_in_dollars' in descending order to show the most expensive items first.", "Use a placeholder in the LIMIT clause to allow the user to specify how many entries they want to retrieve."], "gold_sql": "SELECT catalog_entry_name FROM catalog_contents ORDER BY price_in_dollars DESC LIMIT 1", "source_tables": ["catalog_contents"], "description": "This virtual table provides a list of catalog entry names from the 'Catalog_Contents' table, ordered by their price in dollars in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of entries to retrieve.", "virtual_table": "SELECT catalog_entry_name FROM catalog_contents ORDER BY price_in_dollars DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.330", "db_id": "product_catalog", "question": "What are the names of catalog entries with level number 8?", "rationale": ["The query identifies the relevant tables, 'Catalog_Contents' and 'Catalog_Contents_Additional_Attributes'.", "It selects the 'catalog_entry_name' from 'Catalog_Contents'.", "A JOIN operation is performed to link 'Catalog_Contents' with 'Catalog_Contents_Additional_Attributes' based on the 'catalog_entry_id'.", "A condition is added to filter the results based on 'catalog_level_number' using a placeholder for string values."], "gold_sql": "SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.catalog_level_number  =  '8'", "source_tables": ["catalog_contents", "catalog_contents_additional_attributes"], "description": "This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that are associated with specific additional attributes. The placeholder in the WHERE clause represents the level number of the catalog entry, allowing users to filter results based on this attribute.", "virtual_table": "SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.catalog_level_number  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.331", "db_id": "product_catalog", "question": "Find the names of the products with length smaller than 3 or height greater than 5.", "rationale": ["The query identifies the relevant table, which is 'Catalog_Contents'.", "Select the column to display, 'catalog_entry_name'.", "Add conditions to filter the entries based on their length and width using placeholders for numeric values."], "gold_sql": "SELECT catalog_entry_name FROM catalog_contents WHERE LENGTH  <  3 OR width  >  5", "source_tables": ["catalog_contents"], "description": "This virtual table describes the names of catalog entries from the 'Catalog_Contents' table where the length of the entry is less than a specified value or the width is greater than a specified value. The placeholders in the WHERE clause represent the numeric values for length and width.", "virtual_table": "SELECT catalog_entry_name FROM catalog_contents WHERE LENGTH  <  [PLACEHOLDER-TYPE:NUMBER] OR width  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.332", "db_id": "product_catalog", "question": "Which catalog contents have length below 3 or above 5? Find the catalog entry names.", "rationale": ["The query identifies the relevant table, which is 'Catalog_Contents'.", "Select the column to display, 'catalog_entry_name'.", "Add a condition to filter the entries based on their 'length' and 'width' using placeholders for numeric values."], "gold_sql": "SELECT catalog_entry_name FROM catalog_contents WHERE LENGTH  <  3 OR width  >  5", "source_tables": ["catalog_contents"], "description": "This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that meet specific dimensional criteria. The placeholders in the WHERE clause represent the maximum length and minimum width measurements for filtering the catalog entries.", "virtual_table": "SELECT catalog_entry_name FROM catalog_contents WHERE LENGTH  <  [PLACEHOLDER-TYPE:NUMBER] OR width  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.338", "db_id": "product_catalog", "question": "On which days more than one revisions were made on catalogs.", "rationale": ["The query identifies the relevant table, which is 'Catalogs'.", "It selects the 'date_of_latest_revision' column to display the latest revision dates.", "The results are grouped by 'date_of_latest_revision' to aggregate the data based on this column.", "The HAVING clause is used to filter the groups, ensuring only those with a count greater than the specified placeholder are included."], "gold_sql": "SELECT date_of_latest_revision FROM Catalogs GROUP BY date_of_latest_revision HAVING count(*)  >  1", "source_tables": ["catalogs"], "description": "This virtual table provides the latest revision dates of catalogs from the 'Catalogs' table, grouped by the revision date. The placeholder in the HAVING clause represents the minimum count of catalogs that must share the same revision date to be included in the results.", "virtual_table": "SELECT date_of_latest_revision FROM Catalogs GROUP BY date_of_latest_revision HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.388", "db_id": "flight_1", "question": "What are the origins of all flights that are headed to Honolulu?", "rationale": ["The query is identifying the relevant table, which is 'Flight'.", "Select the column to display, 'origin'.", "Add a condition to filter the 'destination' column for the specified destination using a placeholder for string values."], "gold_sql": "SELECT origin FROM Flight WHERE destination  =  'Honolulu'", "source_tables": ["flight"], "description": "This virtual table describes the origins of flights from the 'Flight' table that are headed to a specific destination. The placeholder in the WHERE clause represents the destination's name.", "virtual_table": "SELECT origin FROM Flight WHERE destination  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.390", "db_id": "flight_1", "question": "What are the departure and arrival dates of all flights from LA to Honolulu?", "rationale": ["The query identifies the relevant table, which is 'Flight'.", "Select the columns to display, 'departure_date' and 'arrival_date'.", "Add conditions to filter the 'origin' and 'destination' columns for the specified locations using placeholders for string values."], "gold_sql": "SELECT departure_date ,  arrival_date FROM Flight WHERE origin  =  'Los Angeles' AND destination  =  'Honolulu'", "source_tables": ["flight"], "description": "This virtual table provides the scheduled departure and arrival dates of flights from the 'Flight' table that originate from a specific location and head to a specific destination. The placeholders in the WHERE clause represent the origin and destination locations.", "virtual_table": "SELECT departure_date ,  arrival_date FROM Flight WHERE origin  =  [PLACEHOLDER-TYPE:STRING] AND destination  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.394", "db_id": "flight_1", "question": "What is the average price for flights from LA to Honolulu?", "rationale": ["The query identifies the relevant table, which is 'Flight'.", "It selects the average of the 'price' column to compute the average ticket price.", "Conditions are added to filter the results based on the specified 'origin' and 'destination' using placeholders for string values."], "gold_sql": "SELECT avg(price) FROM Flight WHERE origin  =  'Los Angeles' AND destination  =  'Honolulu'", "source_tables": ["flight"], "description": "This virtual table calculates the average ticket price for flights originating from a specific location and heading to a designated destination. The placeholders in the WHERE clause represent the origin and destination of the flights.", "virtual_table": "SELECT avg(price) FROM Flight WHERE origin  =  [PLACEHOLDER-TYPE:STRING] AND destination  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.415", "db_id": "flight_1", "question": "Show aircraft names and number of flights for each aircraft.", "rationale": ["The query identifies the relevant tables, which are 'Flight' and 'Aircraft'.", "It selects the 'name' column from the 'Aircraft' table and counts the number of flights associated with each aircraft.", "A JOIN operation is performed on the 'aid' column to link flights with their respective aircraft.", "The results are grouped by the 'aid' to aggregate the flight counts for each aircraft."], "gold_sql": "SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid", "source_tables": ["aircraft", "flight"], "description": "This virtual table provides the names of aircraft along with the count of flights associated with each aircraft from the 'Flight' and 'Aircraft' tables. The placeholder in the SELECT statement allows for dynamic retrieval of aircraft names and their corresponding flight counts.", "virtual_table": "SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid"}
{"sample_id": "train.416", "db_id": "flight_1", "question": "What is the name of each aircraft and how many flights does each one complete?", "rationale": ["The query identifies the relevant tables, which are 'Flight' and 'Aircraft'.", "It selects the 'name' column from the 'Aircraft' table and counts the number of flights associated with each aircraft.", "A JOIN operation is performed on the 'aid' column to link flights with their respective aircraft.", "The results are grouped by the 'aid' to aggregate the flight counts for each aircraft."], "gold_sql": "SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid", "source_tables": ["aircraft", "flight"], "description": "This virtual table provides the names of aircraft along with the count of flights associated with each aircraft from the 'Flight' and 'Aircraft' tables. The placeholder in the SELECT statement allows for dynamic retrieval of aircraft names and their corresponding flight counts.", "virtual_table": "SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid"}
{"sample_id": "train.430", "db_id": "flight_1", "question": "What are the names of all employees who are not certified to fly Boeing 737-800s?", "rationale": ["The query identifies the relevant table, which is 'Employee'.", "It selects the 'name' column to display the names of employees.", "The EXCEPT clause is used to exclude employees who hold a certificate for a specific aircraft model.", "A JOIN operation is performed between 'Employee', 'Certificate', and 'Aircraft' to filter out employees based on the aircraft model using a placeholder for string values."], "gold_sql": "SELECT name FROM Employee EXCEPT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  'Boeing 737-800'", "source_tables": ["employee", "certificate", "aircraft"], "description": "This virtual table lists the names of employees from the 'Employee' table who do not hold a certificate for a specific aircraft model. The placeholder in the query represents the name of the aircraft model.", "virtual_table": "SELECT name FROM Employee EXCEPT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.431", "db_id": "flight_1", "question": "Show the name of aircraft which fewest people have its certificate.", "rationale": ["The query identifies the relevant tables, which are 'Certificate' and 'Aircraft'.", "It selects the 'name' column from the 'Aircraft' table.", "The query performs a JOIN operation on the 'aid' column to link certificates to their respective aircraft.", "Results are grouped by 'aid' to aggregate the count of certificates for each aircraft.", "The results are ordered by the count of certificates in descending order to show the most certified aircraft first.", "A placeholder is included in the LIMIT clause to allow the user to specify how many results they want."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["aircraft", "certificate"], "description": "This virtual table provides the names of aircraft that have the most certificates associated with them. The query joins the 'Certificate' and 'Aircraft' tables based on the aircraft ID, groups the results by aircraft ID, and orders them by the count of certificates in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of results to return.", "virtual_table": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.432", "db_id": "flight_1", "question": "What are the names of the aircraft that the least people are certified to fly?", "rationale": ["The query identifies the relevant tables, which are 'Certificate' and 'Aircraft'.", "It selects the 'name' column from the 'Aircraft' table.", "The query performs a JOIN operation between 'Certificate' and 'Aircraft' on the aircraft ID to link certificates to their respective aircraft.", "It groups the results by the aircraft ID to aggregate the count of certificates for each aircraft.", "The results are ordered by the count of certificates in descending order to prioritize aircraft with the most certifications.", "A placeholder is included in the LIMIT clause to allow the user to specify how many aircraft names to return."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["aircraft", "certificate"], "description": "This virtual table provides the names of aircraft that have the most certificates associated with them. The query joins the 'Certificate' and 'Aircraft' tables on the aircraft ID, groups the results by aircraft ID, and orders them by the count of certificates in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of aircraft names to return.", "virtual_table": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.438", "db_id": "flight_1", "question": "What is the salaray and name of the employee with the most certificates to fly planes more than 5000?", "rationale": ["The query identifies the relevant tables: 'Employee', 'Certificate', and 'Aircraft'.", "It selects the 'name' column from the 'Employee' table.", "The query joins the 'Employee' table with the 'Certificate' table on the employee ID, and then joins the 'Certificate' table with the 'Aircraft' table on the aircraft ID.", "A condition is added to filter aircraft based on their maximum travel distance using a placeholder for numeric values.", "The results are grouped by employee ID to count the number of certificates held by each employee.", "The results are ordered in descending order based on the count of certificates, and a limit is applied to restrict the number of results returned."], "gold_sql": "SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  5000 GROUP BY T1.eid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employee", "certificate", "aircraft"], "description": "This virtual table provides the names of employees who hold certificates for aircraft that can travel a distance greater than a specified value. The results are grouped by employee ID and ordered by the number of certificates held, with a limit on the number of results returned.", "virtual_table": "SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.eid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.448", "db_id": "allergy_1", "question": "What are all the different food allergies?", "rationale": ["The query identifies the relevant table, which is 'Allergy_Type'.", "It selects distinct values from the 'allergy' column to avoid duplicates.", "A condition is added to filter the results based on the 'AllergyType' column using a placeholder for string values."], "gold_sql": "SELECT DISTINCT allergy FROM Allergy_type WHERE allergytype  =  'food'", "source_tables": ["allergy_type"], "description": "This virtual table provides a list of distinct allergies from the 'Allergy_Type' table that belong to a specific category of allergies. The placeholder in the WHERE clause represents the type of allergy being queried.", "virtual_table": "SELECT DISTINCT allergy FROM Allergy_type WHERE allergytype  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.452", "db_id": "allergy_1", "question": "How many animal type allergies exist?", "rationale": ["The query identifies the relevant table, which is 'Allergy_Type'.", "It selects the count of records to determine how many allergies fall under a specific type.", "A condition is added to filter the 'AllergyType' column for the specified allergy type using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM Allergy_type WHERE allergytype  =  'animal'", "source_tables": ["allergy_type"], "description": "This virtual table provides the count of different allergies categorized under a specific type from the 'Allergy_Type' table. The placeholder in the WHERE clause represents the allergy type being queried.", "virtual_table": "SELECT count(*) FROM Allergy_type WHERE allergytype  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.455", "db_id": "allergy_1", "question": "Which allergy type has most number of allergies?", "rationale": ["The query identifies the relevant table, which is 'Allergy_Type'.", "It selects the 'allergytype' column to display the types of allergies.", "The query groups the results by 'allergytype' to aggregate the data.", "It orders the results by the count of occurrences in descending order to show the most common types first.", "The LIMIT clause uses a placeholder for numeric values to specify how many types to return."], "gold_sql": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT 1", "source_tables": ["allergy_type"], "description": "This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.", "virtual_table": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.458", "db_id": "allergy_1", "question": "Which allergy type is the least common?", "rationale": ["The query identifies the relevant table, which is 'Allergy_Type'.", "It selects the 'allergytype' column to display the types of allergies.", "The results are grouped by 'allergytype' to aggregate similar types together.", "The results are ordered by the count of occurrences in ascending order to show the least common allergy types first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) ASC LIMIT 1", "source_tables": ["allergy_type"], "description": "This virtual table provides a list of allergy types from the 'Allergy_Type' table, grouped by their category. The results are ordered by the count of occurrences in ascending order, with a limit set by a placeholder for numeric values.", "virtual_table": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.462", "db_id": "allergy_1", "question": "What are the full names of all students", "rationale": ["The query identifies the relevant table, which is 'Student'.", "Select the columns to display, 'Fname' and 'Lname', which represent the first and last names of the students."], "gold_sql": "SELECT Fname ,  Lname FROM Student", "source_tables": ["student"], "description": "The virtual table describes the first and last names of students from the 'Student' table. The query does not include any filtering conditions, allowing for the retrieval of all students' names.", "virtual_table": "SELECT Fname ,  Lname FROM Student"}
{"sample_id": "train.472", "db_id": "allergy_1", "question": "What are the student ids for all male students?", "rationale": ["The query is identifying the relevant table, which is 'Student'.", "Select the column to display, 'StuID', which is the unique identifier for each student.", "Add a condition to filter the 'Sex' column for the specified gender using a placeholder for string values."], "gold_sql": "SELECT StuID FROM Student WHERE Sex  =  'M'", "source_tables": ["student"], "description": "This virtual table lists the unique identifiers of students from the 'Student' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the students.", "virtual_table": "SELECT StuID FROM Student WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.492", "db_id": "allergy_1", "question": "What is the largest major?", "rationale": ["The query identifies the relevant table, which is 'Student'.", "Select the 'major' column to display.", "Group the results by 'major' to aggregate the data.", "Order the results by the count of students in each major in descending order to show the most popular majors first.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT major FROM Student GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "description": "This virtual table provides a list of academic majors from the 'Student' table, grouped by the major name. The results are ordered by the number of students in each major in descending order, with a limit set by a placeholder for numeric values to specify how many top majors to return.", "virtual_table": "SELECT major FROM Student GROUP BY major ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.502", "db_id": "allergy_1", "question": "Give the advisor with the most students.", "rationale": ["The query identifies the relevant table, which is 'Student'.", "Select the column to display, 'advisor'.", "Group the results by the 'advisor' column to aggregate the data.", "Order the results by the count of students associated with each advisor in descending order.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT advisor FROM Student GROUP BY advisor ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "description": "This virtual table provides a list of academic advisors from the 'Student' table, grouped by the advisor's name. The results are ordered by the number of students assigned to each advisor in descending order, with a limit on the number of advisors returned, specified by a placeholder for numeric values.", "virtual_table": "SELECT advisor FROM Student GROUP BY advisor ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.503", "db_id": "allergy_1", "question": "How many students have cat allergies?", "rationale": ["The query identifies the relevant table, which is 'Has_Allergy'.", "It selects the count of records to determine how many students have a specific allergy.", "A condition is added to filter the 'Allergy' column for the specified allergy using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  'Cat'", "source_tables": ["has_allergy"], "description": "This virtual table provides the count of students who have a specific allergy from the 'Has_Allergy' table. The placeholder in the WHERE clause represents the name of the allergy.", "virtual_table": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.504", "db_id": "allergy_1", "question": "How many students are affected by cat allergies?", "rationale": ["The query identifies the relevant table, which is 'Has_Allergy'.", "It selects the count of records to determine how many students have a specific allergy.", "A condition is added to filter the 'Allergy' column for the specified allergy using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  'Cat'", "source_tables": ["has_allergy"], "description": "This virtual table provides the count of students who have a specific allergy from the 'Has_Allergy' table. The placeholder in the WHERE clause represents the name of the allergy.", "virtual_table": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.510", "db_id": "allergy_1", "question": "How many students who are female are allergic to milk or eggs?", "rationale": ["The query identifies the relevant tables, 'Has_Allergy' and 'Student', and uses a JOIN to combine them based on the student ID.", "It selects a count of records to determine how many students meet the criteria.", "The WHERE clause filters the results based on the gender of the students and the specific allergies, using placeholders for these values."], "gold_sql": "SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  'F' AND T1.allergy  =  'Milk' OR T1.allergy  =  'Eggs'", "source_tables": ["has_allergy", "student"], "description": "This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies being queried.", "virtual_table": "SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  [PLACEHOLDER-TYPE:STRING] AND T1.allergy  =  [PLACEHOLDER-TYPE:STRING] OR T1.allergy  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.514", "db_id": "allergy_1", "question": "Which allergy is the most common?", "rationale": ["The query identifies the relevant table, which is 'Has_Allergy'.", "It selects the 'Allergy' column to display the names of allergies.", "The GROUP BY clause is used to group the results by the 'Allergy' name.", "The ORDER BY clause sorts the results based on the count of occurrences in descending order.", "The LIMIT clause uses a placeholder to allow the user to specify how many results they want to see."], "gold_sql": "SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT 1", "source_tables": ["has_allergy"], "description": "This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.", "virtual_table": "SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.519", "db_id": "allergy_1", "question": "Find the last name and age of the student who has allergy to both milk and cat.", "rationale": ["The query identifies the relevant table, which is 'Student'.", "Select the columns to display, 'LName' and 'Age'.", "Add a condition to filter students based on their allergies using a subquery that checks for students with both specified allergies using the INTERSECT operator. The placeholders represent the names of the allergies."], "gold_sql": "SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "description": "This virtual table provides the last names and ages of students from the 'Student' table who have two specific allergies. The placeholders in the query represent the names of the allergies that are being checked for each student.", "virtual_table": "SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.520", "db_id": "allergy_1", "question": "What are the last names and ages of the students who are allergic to milk and cat?", "rationale": ["The query identifies the relevant table, which is 'Student'.", "Select the columns to display, 'lname' and 'age'.", "Add a condition to filter students based on their allergies using a subquery that checks for students with both specified allergies using the INTERSECT operator. The placeholders represent the names of the allergies."], "gold_sql": "SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "description": "This virtual table provides the last names and ages of students from the 'Student' table who have two specific allergies. The placeholders in the query represent the names of the allergies that are being checked for each student.", "virtual_table": "SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.523", "db_id": "allergy_1", "question": "Find the first name and gender of the student who has allergy to milk but not cat.", "rationale": ["The query identifies the relevant table, which is 'Student'.", "Select the columns to display, 'fname' and 'sex'.", "Use a subquery to filter students based on their allergies from the 'Has_Allergy' table.", "The first part of the subquery selects students with a specific allergy using a placeholder for string values.", "The second part of the subquery excludes students with another specified allergy using another placeholder for string values."], "gold_sql": "SELECT fname ,  sex FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' EXCEPT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "description": "This virtual table provides the first names and gender of students from the 'Student' table who have a specific allergy but do not have another specified allergy. The placeholders in the subquery represent the names of the allergies being filtered.", "virtual_table": "SELECT fname ,  sex FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.524", "db_id": "allergy_1", "question": "What are the first name and gender of the students who have allergy to milk but can put up with cats?", "rationale": ["The query identifies the relevant table, which is 'Student'.", "Select the columns to display, 'fname' and 'sex'.", "Use a subquery to filter students based on their allergies from the 'Has_Allergy' table.", "The first part of the subquery selects students with a specific allergy using a placeholder for string values.", "The second part of the subquery excludes students with another specified allergy using another placeholder for string values."], "gold_sql": "SELECT fname ,  sex FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' EXCEPT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "description": "This virtual table provides the first names and gender of students from the 'Student' table who have a specific allergy but do not have another specified allergy. The placeholders in the subquery represent the names of the allergies being filtered.", "virtual_table": "SELECT fname ,  sex FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.525", "db_id": "allergy_1", "question": "Find the average age of the students who have allergies with food and animal types.", "rationale": ["The query identifies the relevant table, which is 'Student', to calculate the average age.", "It uses a subquery to find students who have allergies of a specific type by joining 'Has_Allergy' and 'Allergy_Type'.", "The INTERSECT operator is used to ensure that only students with both specified allergy types are considered.", "Finally, the average age is calculated for the filtered list of students."], "gold_sql": "SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food' INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'animal')", "source_tables": ["has_allergy", "allergy_type", "student"], "description": "This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.", "virtual_table": "SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.528", "db_id": "allergy_1", "question": "What is the full name of each student who is not allergic to any type of food.", "rationale": ["The query identifies the relevant table, which is 'Student'.", "Select the columns to display, 'fname' and 'lname'.", "Add a condition to filter out students whose IDs are in a subquery.", "The subquery selects student IDs from 'Has_Allergy' joined with 'Allergy_Type' where the allergy type matches the specified placeholder."], "gold_sql": "SELECT fname ,  lname FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "description": "This virtual table provides the first and last names of students from the 'Student' table who do not have a specific type of allergy. The placeholder in the subquery represents the allergy type that is being filtered out.", "virtual_table": "SELECT fname ,  lname FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.530", "db_id": "allergy_1", "question": "How many male students (sex is 'M') are allergic to any type of food?", "rationale": ["The query identifies the relevant table, which is 'Student'.", "It counts the total number of students that meet certain criteria.", "The first condition filters students based on their gender using a placeholder for string values.", "The second condition checks if the student's ID is in a subquery that joins 'Has_Allergy' and 'Allergy_Type' to filter allergies by a specific type, using another placeholder for string values."], "gold_sql": "SELECT count(*) FROM Student WHERE sex  =  'M' AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "description": "This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the WHERE clause represent the gender of the students and the type of allergy they have.", "virtual_table": "SELECT count(*) FROM Student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.531", "db_id": "allergy_1", "question": "Find the different first names and cities of the students who have allergy to milk or cat.", "rationale": ["The query identifies the relevant tables, which are 'Student' and 'Has_Allergy'.", "It selects distinct values for the 'fname' and 'city_code' columns from the 'Student' table.", "A JOIN operation is performed between 'Student' and 'Has_Allergy' on the 'StuID' column to link students with their allergies.", "The WHERE clause filters the results based on the specified allergies using placeholders for string values."], "gold_sql": "SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  'Milk' OR T2.Allergy  =  'Cat'", "source_tables": ["has_allergy", "student"], "description": "This virtual table provides a list of distinct first names and city codes of students who have specific allergies. The placeholders in the WHERE clause represent the names of the allergies being queried.", "virtual_table": "SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  [PLACEHOLDER-TYPE:STRING] OR T2.Allergy  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.532", "db_id": "allergy_1", "question": "What are the distinct first names and cities of the students who have allergy either to milk or to cat?", "rationale": ["The query identifies the relevant tables, which are 'Student' and 'Has_Allergy'.", "It selects the distinct first names and city codes from the 'Student' table.", "A JOIN operation is performed between 'Student' and 'Has_Allergy' on the student ID to link students with their allergies.", "The WHERE clause filters the results to include only those students who have one of the specified allergies, using placeholders for the allergy names."], "gold_sql": "SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  'Milk' OR T2.Allergy  =  'Cat'", "source_tables": ["has_allergy", "student"], "description": "This virtual table provides a distinct list of first names and city codes of students who have specific allergies. The placeholders in the WHERE clause represent the names of the allergies that are being queried.", "virtual_table": "SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  [PLACEHOLDER-TYPE:STRING] OR T2.Allergy  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.542", "db_id": "store_1", "question": "What are the names of the countries and average invoice size of the top countries by size?", "rationale": ["The query identifies the relevant table, which is 'invoices'.", "It selects the 'billing_country' and calculates the average of the 'total' column.", "The results are grouped by 'billing_country' to get the average total for each country.", "The results are ordered in descending order based on the average total amount.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT billing_country ,  AVG(total) FROM invoices GROUP BY billing_country ORDER BY AVG(total) DESC LIMIT 10;", "source_tables": ["invoices"], "description": "This virtual table provides the average total amount of invoices grouped by billing country. The results are ordered in descending order based on the average total, and a placeholder is included to limit the number of results returned.", "virtual_table": "SELECT billing_country ,  AVG(total) FROM invoices GROUP BY billing_country ORDER BY AVG(total) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.564", "db_id": "store_1", "question": "How many invoices were billed from each state?", "rationale": ["The query identifies the relevant table, which is 'invoices'.", "It selects the 'billing_state' column and counts the number of invoices for each state.", "A condition is added to filter the results based on the 'billing_country' using a placeholder for string values.", "The results are grouped by 'billing_state' to provide a count of invoices per state."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state;", "source_tables": ["invoices"], "description": "This virtual table summarizes the number of invoices issued in each state for a specific country. The placeholder in the WHERE clause represents the name of the country for which the invoice data is being aggregated.", "virtual_table": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY billing_state;"}
{"sample_id": "train.566", "db_id": "store_1", "question": "What are the states with the most invoices?", "rationale": ["The query identifies the relevant table, which is 'invoices'.", "It selects the 'billing_state' and counts the number of invoices for each state.", "A condition is added to filter the results based on the specified 'billing_country' using a placeholder for string values.", "The results are grouped by 'billing_state' to aggregate the counts.", "The results are ordered by the count of invoices in descending order to show the states with the most invoices first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT 1;", "source_tables": ["invoices"], "description": "This virtual table summarizes the number of invoices issued per state within a specific country. The placeholder in the WHERE clause represents the country for which the invoice counts are being aggregated, while the placeholder in the LIMIT clause specifies the maximum number of states to return, ordered by the count of invoices in descending order.", "virtual_table": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.568", "db_id": "store_1", "question": "What is the number of invoices and total money billed in them from CA?", "rationale": ["The query identifies the relevant table, which is 'invoices'.", "It selects the 'billing_state' column, counts the number of invoices, and sums the total amount for those invoices.", "A condition is added to filter the results based on the specified billing state using a placeholder for string values."], "gold_sql": "SELECT billing_state ,  COUNT(*) ,  SUM(total) FROM invoices WHERE billing_state  =  'CA';", "source_tables": ["invoices"], "description": "This virtual table summarizes the total number of invoices and the total amount billed for a specific billing state from the 'invoices' table. The placeholder in the WHERE clause represents the billing state being queried.", "virtual_table": "SELECT billing_state ,  COUNT(*) ,  SUM(total) FROM invoices WHERE billing_state  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.575", "db_id": "store_1", "question": "What is Astrid Gruber's email and phone number?", "rationale": ["The query is identifying the relevant table, which is 'customers'.", "Select the columns to display, 'email' and 'phone'.", "Add a condition to filter the 'first_name' and 'last_name' columns for the specified customer using placeholders for string values."], "gold_sql": "SELECT email ,  phone FROM customers WHERE first_name = 'Astrid' AND last_name = 'Gruber';", "source_tables": ["customers"], "description": "This virtual table describes the email addresses and phone numbers of customers from the 'customers' table who have a specific first and last name. The placeholders in the WHERE clause represent the customer's first and last names.", "virtual_table": "SELECT email ,  phone FROM customers WHERE first_name = [PLACEHOLDER-TYPE:STRING] AND last_name = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.580", "db_id": "store_1", "question": "How many customers are from California?", "rationale": ["The query identifies the relevant table, which is 'customers'.", "It counts the total number of entries using count(*).", "A condition is added to filter the results based on the 'state' column using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM customers WHERE state = 'CA';", "source_tables": ["customers"], "description": "This virtual table provides the total number of customers from the 'customers' table who reside in a specific state. The placeholder in the WHERE clause represents the state name.", "virtual_table": "SELECT count(*) FROM customers WHERE state = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.593", "db_id": "store_1", "question": "Find the full name of employee who supported the most number of customers.", "rationale": ["The query identifies the relevant tables, which are 'employees' and 'customers'.", "It selects the 'first_name' and 'last_name' columns from the 'employees' table, aliased as T1.", "A JOIN operation is performed between 'employees' and 'customers' on the condition that the employee's ID matches the support representative ID in the customers table.", "The results are grouped by the employee's ID to aggregate the number of customers they support.", "The results are ordered by the count of customers in descending order to show the most supported employees first.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employees", "customers"], "description": "This virtual table provides the first and last names of employees who serve as support representatives for customers. The results are grouped by the employee's unique identifier and ordered by the number of customers they support in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.", "virtual_table": "SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.608", "db_id": "store_1", "question": "How many orders does Luca Mancini have in his invoices?", "rationale": ["The query identifies the relevant tables, which are 'customers' and 'invoices'.", "It uses a JOIN operation to link the 'customers' table with the 'invoices' table based on the customer ID.", "The SELECT statement counts the total number of invoices for the specified customer.", "The WHERE clause filters the results based on the customer's first and last name using placeholders for string values."], "gold_sql": "SELECT count(*) FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id WHERE T1.first_name = 'Lucas' AND T1.last_name = 'Mancini';", "source_tables": ["customers", "invoices"], "description": "This virtual table provides the count of invoices associated with customers from the 'customers' table, filtered by the customer's first and last name. The placeholders in the WHERE clause represent the first and last names of the customer.", "virtual_table": "SELECT count(*) FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id WHERE T1.first_name = [PLACEHOLDER-TYPE:STRING] AND T1.last_name = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.623", "db_id": "store_1", "question": "What is title of album which track Balls to the Wall belongs to?", "rationale": ["The query identifies the relevant tables, which are 'albums' and 'tracks'.", "It selects the 'title' column from the 'albums' table.", "A JOIN is performed between 'albums' and 'tracks' on the condition that the album's ID matches the genre ID of the track, which is likely a mistake since it should match the album ID instead.", "A condition is added to filter the tracks by their name using a placeholder for string values."], "gold_sql": "SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T2.name = 'Balls to the Wall';", "source_tables": ["albums", "tracks"], "description": "This virtual table describes the titles of albums from the 'albums' table that contain tracks of a specific name. The placeholder in the WHERE clause represents the name of the track.", "virtual_table": "SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T2.name = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.626", "db_id": "store_1", "question": "What is the name of all tracks in the album named Balls to the Wall?", "rationale": ["The query identifies the relevant tables, which are 'albums' and 'tracks'.", "It selects the 'name' column from the 'tracks' table.", "A JOIN operation is performed on the 'albums' and 'tracks' tables using the album's ID and the genre ID.", "A condition is added to filter the results based on the specified album title using a placeholder for string values."], "gold_sql": "SELECT T2.name FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T1.title = 'Balls to the Wall';", "source_tables": ["albums", "tracks"], "description": "This virtual table describes the names of tracks from the 'tracks' table that belong to a specific album title in the 'albums' table. The placeholder in the WHERE clause represents the title of the album.", "virtual_table": "SELECT T2.name FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T1.title = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.630", "db_id": "store_1", "question": "What are the names of all Rock tracks that are stored on MPEG audio files?", "rationale": ["The query identifies the relevant tables: 'genres', 'tracks', and 'media_types'.", "It selects the 'name' column from the 'tracks' table.", "The JOIN operations link the 'tracks' table to the 'genres' and 'media_types' tables based on their respective foreign keys.", "Conditions are added to filter the results based on the specified genre and media type using placeholders for string values."], "gold_sql": "SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = 'Rock' AND T3.name = 'MPEG audio file';", "source_tables": ["tracks", "genres", "media_types"], "description": "This virtual table describes the names of tracks from the 'tracks' table that belong to a specific genre and media type. The placeholders in the WHERE clause represent the genre's name and the media type's name.", "virtual_table": "SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = [PLACEHOLDER-TYPE:STRING] AND T3.name = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.632", "db_id": "store_1", "question": "What are the names of all tracks that belong to the Rock genre and whose media type is MPEG?", "rationale": ["The query identifies the relevant tables: 'genres', 'tracks', and 'media_types'.", "It selects the 'name' column from the 'tracks' table (aliased as T2).", "It joins the 'genres' table (aliased as T1) on the genre ID to filter tracks by genre.", "It also joins the 'media_types' table (aliased as T3) on the media type ID to filter tracks by media type.", "The WHERE clause includes conditions to filter by the specified genre name or media type name using placeholders for string values."], "gold_sql": "SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = 'Rock' OR T3.name = 'MPEG audio file';", "source_tables": ["tracks", "genres", "media_types"], "description": "This virtual table describes the names of tracks from the 'tracks' table that belong to a specific genre or media type. The placeholders in the WHERE clause represent the genre's name and the media type's name.", "virtual_table": "SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = [PLACEHOLDER-TYPE:STRING] OR T3.name = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.640", "db_id": "store_1", "question": "What are the tracks that Dean Peeters bought?", "rationale": ["The query identifies the relevant tables: 'tracks', 'invoice_lines', 'invoices', and 'customers'.", "It selects the 'name' column from the 'tracks' table.", "The query uses JOIN operations to connect 'tracks' with 'invoice_lines', 'invoices', and 'customers' based on their respective identifiers.", "A condition is added to filter the results based on the customer's first and last names using placeholders for string values."], "gold_sql": "SELECT T1.name FROM tracks AS T1 JOIN invoice_lines AS T2 ON T1.id = T2.track_id JOIN invoices AS T3 ON T3.id = T2.invoice_id JOIN customers AS T4 ON T4.id = T3.customer_id WHERE T4.first_name = 'Daan' AND T4.last_name = 'Peeters';", "source_tables": ["tracks", "invoice_lines", "customers", "invoices"], "description": "This virtual table describes the names of tracks from the 'tracks' table that have been purchased by a specific customer. The query joins multiple tables to filter the results based on the customer's first and last names, represented by placeholders in the WHERE clause.", "virtual_table": "SELECT T1.name FROM tracks AS T1 JOIN invoice_lines AS T2 ON T1.id = T2.track_id JOIN invoices AS T3 ON T3.id = T2.invoice_id JOIN customers AS T4 ON T4.id = T3.customer_id WHERE T4.first_name = [PLACEHOLDER-TYPE:STRING] AND T4.last_name = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.686", "db_id": "customers_card_transactions", "question": "What are the full names of customers who do not have any accounts?", "rationale": ["The query identifies the relevant table, which is 'Customers', to select customer names.", "It uses the EXCEPT clause to filter out customers who have accounts by joining 'Customers' with 'Accounts' on 'customer_id'.", "The selected columns are 'customer_first_name' and 'customer_last_name' from the 'Customers' table."], "gold_sql": "SELECT customer_first_name ,  customer_last_name FROM Customers EXCEPT SELECT T1.customer_first_name ,  T1.customer_last_name FROM Customers AS T1 JOIN Accounts AS T2 ON T1.customer_id  =  T2.customer_id", "source_tables": ["accounts", "customers"], "description": "This virtual table provides a list of customers who do not have any associated accounts. It selects the first and last names of customers from the 'Customers' table and excludes those who have accounts by performing an EXCEPT operation with a subquery that joins the 'Customers' table with the 'Accounts' table based on the customer ID.", "virtual_table": "SELECT customer_first_name ,  customer_last_name FROM Customers EXCEPT SELECT T1.customer_first_name ,  T1.customer_last_name FROM Customers AS T1 JOIN Accounts AS T2 ON T1.customer_id  =  T2.customer_id"}
{"sample_id": "train.688", "db_id": "customers_card_transactions", "question": "What are the full names of customers who have accounts?", "rationale": ["The query identifies the relevant tables, which are 'Customers' and 'Accounts'.", "It selects distinct values for 'customer_first_name' and 'customer_last_name' to avoid duplicates.", "A JOIN operation is performed on the 'customer_id' to link customers with their accounts, ensuring that only customers with accounts are included."], "gold_sql": "SELECT DISTINCT T1.customer_first_name ,  T1.customer_last_name FROM Customers AS T1 JOIN Accounts AS T2 ON T1.customer_id  =  T2.customer_id", "source_tables": ["accounts", "customers"], "description": "This virtual table provides a distinct list of first and last names of customers from the 'Customers' table who have associated accounts in the 'Accounts' table. The join condition links the customer to their respective account using the customer identifier.", "virtual_table": "SELECT DISTINCT T1.customer_first_name ,  T1.customer_last_name FROM Customers AS T1 JOIN Accounts AS T2 ON T1.customer_id  =  T2.customer_id"}
{"sample_id": "train.704", "db_id": "customers_card_transactions", "question": "Return the full name and phone of the customer who has card number 4560596484842.", "rationale": ["The query identifies the relevant tables, which are 'Customers' and 'Customers_Cards'.", "It selects the columns to display: 'customer_first_name', 'customer_last_name', and 'customer_phone'.", "A JOIN operation is performed to link 'Customers_Cards' with 'Customers' based on the 'customer_id'.", "A condition is added to filter the 'card_number' column for the specified card number using a placeholder for string values."], "gold_sql": "SELECT T2.customer_first_name ,  T2.customer_last_name ,  T2.customer_phone FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T1.card_number  =  '4560596484842'", "source_tables": ["customers", "customers_cards"], "description": "This virtual table describes the first and last names, as well as the phone number of customers associated with a specific card number from the 'Customers' and 'Customers_Cards' tables. The placeholder in the WHERE clause represents the card number being queried.", "virtual_table": "SELECT T2.customer_first_name ,  T2.customer_last_name ,  T2.customer_phone FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T1.card_number  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.717", "db_id": "customers_card_transactions", "question": "What is the customer id, first and last name with least number of accounts.", "rationale": ["The query identifies the relevant tables, 'Customers_cards' and 'Customers'.", "It selects the 'customer_id', 'customer_first_name', and 'customer_last_name' columns to display.", "A JOIN operation is performed to link 'Customers_cards' with 'Customers' based on the 'customer_id'.", "The results are grouped by 'customer_id' to aggregate the data accordingly.", "The results are ordered by the count of associated cards in ascending order.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) ASC LIMIT 1", "source_tables": ["customers", "customers_cards"], "description": "This virtual table provides a list of customer IDs along with their first and last names from the 'Customers' table, specifically for customers who have associated cards in the 'Customers_Cards' table. The results are grouped by customer ID and ordered by the count of associated cards in ascending order, with a limit on the number of results returned as specified by the placeholder.", "virtual_table": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.718", "db_id": "customers_card_transactions", "question": "Return the id and full name of the customer who has the fewest accounts.", "rationale": ["The query identifies the relevant tables, 'Customers_cards' and 'Customers'.", "It selects the 'customer_id', 'customer_first_name', and 'customer_last_name' columns to display.", "A JOIN operation is performed on 'customer_id' to link the two tables together.", "The results are grouped by 'customer_id' to aggregate the data based on the number of cards each customer has.", "The results are ordered by the count of associated cards in ascending order.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) ASC LIMIT 1", "source_tables": ["customers", "customers_cards"], "description": "This virtual table provides a list of customer IDs along with their first and last names from the 'Customers' table, based on the associated cards in the 'Customers_Cards' table. The results are grouped by customer ID and ordered by the count of associated cards in ascending order, with a limit specified by a placeholder for numeric values.", "virtual_table": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.721", "db_id": "customers_card_transactions", "question": "What is the card type code with most number of cards?", "rationale": ["The query identifies the relevant table, which is 'Customers_Cards'.", "It selects the 'card_type_code' to display the types of cards.", "The GROUP BY clause is used to aggregate the results by 'card_type_code'.", "The ORDER BY clause sorts the results based on the count of each card type in descending order.", "The LIMIT clause uses a placeholder to allow the user to specify how many card types to return."], "gold_sql": "SELECT card_type_code FROM Customers_cards GROUP BY card_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers_cards"], "description": "This virtual table summarizes the different types of cards issued to customers by counting the occurrences of each card type. The placeholder in the LIMIT clause allows the user to specify the maximum number of card types to retrieve, sorted by the most common types first.", "virtual_table": "SELECT card_type_code FROM Customers_cards GROUP BY card_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.735", "db_id": "customers_card_transactions", "question": "Show the number of transaction types.", "rationale": ["The query identifies the relevant table, which is 'Financial_Transactions'.", "It selects a count of distinct values from the 'transaction_type' column to determine the number of unique transaction types.", "The use of the DISTINCT keyword ensures that only unique transaction types are counted."], "gold_sql": "SELECT count(DISTINCT transaction_type) FROM Financial_Transactions", "source_tables": ["financial_transactions"], "description": "This virtual table provides a count of distinct transaction types recorded in the 'Financial_Transactions' table. The result will indicate how many unique types of transactions (such as debit or credit) have been made.", "virtual_table": "SELECT count(DISTINCT transaction_type) FROM Financial_Transactions"}
{"sample_id": "train.743", "db_id": "customers_card_transactions", "question": "What is the transaction type that has processed the greatest total amount in transactions?", "rationale": ["The query identifies the relevant table, which is 'Financial_Transactions'.", "It selects the 'transaction_type' column to display the different types of transactions.", "The results are grouped by 'transaction_type' to aggregate the data accordingly.", "The ordering is done based on the sum of 'transaction_amount' in descending order to show the most significant transaction types first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT transaction_type FROM Financial_transactions GROUP BY transaction_type ORDER BY sum(transaction_amount) DESC LIMIT 1", "source_tables": ["financial_transactions"], "description": "This virtual table summarizes the types of transactions recorded in the 'Financial_Transactions' table, grouping them by their type and ordering the results by the total amount of each transaction type in descending order. The placeholder in the LIMIT clause represents the maximum number of transaction types to display.", "virtual_table": "SELECT transaction_type FROM Financial_transactions GROUP BY transaction_type ORDER BY sum(transaction_amount) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.893", "db_id": "insurance_fnol", "question": "What are the customer phone numbers under the policy \"Life Insurance\"?", "rationale": ["The query is identifying the relevant table, which is 'Available_Policies'.", "Select the column to display, 'Customer_Phone'.", "Add a condition to filter the 'policy_type_code' column for the specified policy type using a placeholder for string values."], "gold_sql": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  'Life Insurance'", "source_tables": ["available_policies"], "description": "This virtual table describes the contact phone numbers of customers from the 'Available_Policies' table who have a specific type of insurance policy. The placeholder in the WHERE clause represents the policy type code.", "virtual_table": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.895", "db_id": "insurance_fnol", "question": "Which policy type has the most records in the database?", "rationale": ["The query identifies the relevant table, which is 'Available_Policies'.", "It selects the 'policy_type_code' column to display the types of policies.", "The query groups the results by 'policy_type_code' to aggregate similar types together.", "It orders the grouped results by their count in descending order to show the most common types first.", "The LIMIT clause is used to restrict the number of results returned, with a placeholder for the maximum number of types to display."], "gold_sql": "SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["available_policies"], "description": "This virtual table summarizes the different types of insurance policies available in the 'Available_Policies' table. It groups the policies by their type code and orders them by the number of occurrences, allowing users to see the most common policy types. The placeholder in the LIMIT clause represents the maximum number of policy types to return.", "virtual_table": "SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.897", "db_id": "insurance_fnol", "question": "What are all the customer phone numbers under the most popular policy type?", "rationale": ["The query identifies the relevant table, which is 'Available_Policies'.", "It selects the 'customer_phone' column to display the contact information.", "A subquery is used to find the most common 'policy_type_code' by grouping and counting occurrences, with a limit specified by a placeholder for numeric values."], "gold_sql": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  (SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["available_policies"], "description": "This virtual table retrieves the contact phone numbers of customers from the 'Available_Policies' table who have the most common type of insurance policy. The placeholder in the subquery represents the limit for the number of policy types to consider, allowing users to specify how many of the top policy types they want to retrieve phone numbers for.", "virtual_table": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  (SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.898", "db_id": "insurance_fnol", "question": "Find the phone numbers of customers using the most common policy type among the available policies.", "rationale": ["The query identifies the relevant table, which is 'Available_Policies'.", "It selects the 'customer_phone' column to display the contact numbers of customers.", "A subquery is used to find the most common policy type by grouping the 'policy_type_code' and ordering them by their count in descending order.", "The placeholder in the LIMIT clause allows the user to specify how many of the top policy types to consider."], "gold_sql": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  (SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["available_policies"], "description": "The virtual table describes the contact phone numbers of customers associated with the most common type of insurance policy from the 'Available_Policies' table. The placeholder in the subquery represents the limit for the number of policy types to consider, allowing the user to specify how many of the top policy types they want to retrieve.", "virtual_table": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  (SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.1060", "db_id": "match_season", "question": "Show the players from college UCLA.", "rationale": ["The query is identifying the relevant table, which is 'match_season'.", "Select the column to display, 'Player'.", "Add a condition to filter the 'College' column for the specified college using a placeholder for string values."], "gold_sql": "SELECT Player FROM match_season WHERE College  =  'UCLA'", "source_tables": ["match_season"], "description": "This virtual table describes the players who participated in matches during a specific season and attended a particular college. The placeholder in the WHERE clause represents the name of the college.", "virtual_table": "SELECT Player FROM match_season WHERE College  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1082", "db_id": "match_season", "question": "Show the season, the player, and the name of the team that players belong to.", "rationale": ["The query identifies the relevant tables, 'match_season' and 'team'.", "It selects the columns 'Season' and 'Player' from the 'match_season' table (aliased as T1) and 'Name' from the 'team' table (aliased as T2).", "A JOIN operation is performed on the 'Team' column from 'match_season' and 'Team_id' from 'team' to link players with their respective teams."], "gold_sql": "SELECT T1.Season ,  T1.Player ,  T2.Name FROM match_season AS T1 JOIN team AS T2 ON T1.Team  =  T2.Team_id", "source_tables": ["team", "match_season"], "description": "This virtual table provides a summary of match seasons, including the season name, player names, and their corresponding team names. The data is retrieved from the 'match_season' table, which is joined with the 'team' table to associate players with their teams.", "virtual_table": "SELECT T1.Season ,  T1.Player ,  T2.Name FROM match_season AS T1 JOIN team AS T2 ON T1.Team  =  T2.Team_id"}
{"sample_id": "train.1092", "db_id": "match_season", "question": "Show the country names and the corresponding number of players.", "rationale": ["The query identifies the relevant tables, which are 'country' and 'match_season'.", "It selects the 'Country_name' from the 'country' table and counts the number of matches from the 'match_season' table.", "A JOIN operation is performed on the 'Country_id' from the 'country' table and the 'Country' from the 'match_season' table to link the data.", "The results are grouped by 'Country_name' to provide a count of matches for each country."], "gold_sql": "SELECT Country_name ,  COUNT(*) FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country GROUP BY T1.Country_name", "source_tables": ["country", "match_season"], "description": "This virtual table provides a count of matches played by players from each country, by joining the 'country' table with the 'match_season' table. The placeholder in the SELECT clause represents the country names, and the COUNT function aggregates the number of matches for each country.", "virtual_table": "SELECT Country_name ,  COUNT(*) FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country GROUP BY T1.Country_name"}
{"sample_id": "train.1098", "db_id": "match_season", "question": "Show the top 3 most common colleges of players in match seasons.", "rationale": ["The query identifies the relevant table, which is 'match_season'.", "Select the 'College' column to display the colleges of players.", "Group the results by 'College' to aggregate the data based on the number of players from each college.", "Order the results by the count of players in descending order to show the most represented colleges first.", "Limit the number of results returned based on a specified number using a placeholder for numeric values."], "gold_sql": "SELECT College FROM match_season GROUP BY College ORDER BY count(*) DESC LIMIT 3", "source_tables": ["match_season"], "description": "This virtual table provides a list of colleges from which players have participated in matches during a specific season. The results are grouped by college and ordered by the number of players associated with each college, with a limit on the number of colleges returned as specified by the placeholder.", "virtual_table": "SELECT College FROM match_season GROUP BY College ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1099", "db_id": "match_season", "question": "What are the three colleges from which the most players are from?", "rationale": ["The query identifies the relevant table, which is 'match_season'.", "It selects the 'College' column to display the colleges of players.", "The results are grouped by 'College' to aggregate the data.", "The results are ordered by the count of players associated with each college in descending order.", "A limit is applied to restrict the number of colleges returned based on a placeholder for numeric values."], "gold_sql": "SELECT College FROM match_season GROUP BY College ORDER BY count(*) DESC LIMIT 3", "source_tables": ["match_season"], "description": "This virtual table provides a list of colleges from which players have participated in matches during a specific season. The results are grouped by college and ordered by the number of players associated with each college, with a limit on the number of colleges returned based on the specified number.", "virtual_table": "SELECT College FROM match_season GROUP BY College ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1107", "db_id": "match_season", "question": "Return the names of countries that have players that play the Forward position, as well as players who play the Defender position.", "rationale": ["The query is identifying the relevant tables, which are 'country' and 'match_season'.", "It selects the 'Country_name' from the 'country' table.", "The join condition links the 'Country_id' from the 'country' table to the 'Country' in the 'match_season' table.", "The query filters the results based on the 'Position' column in the 'match_season' table using a placeholder for string values.", "The use of INTERSECT allows for the selection of countries where players have the same specified position in two different instances."], "gold_sql": "SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  'Forward' INTERSECT SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  'Defender'", "source_tables": ["country", "match_season"], "description": "This virtual table identifies the names of countries represented by players who occupy a specific position in matches. It uses an intersection to find countries where players have the same position, allowing for a comparison of two different instances of that position. The placeholders in the query represent the position of the players being filtered.", "virtual_table": "SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  [PLACEHOLDER-TYPE:STRING]"}
