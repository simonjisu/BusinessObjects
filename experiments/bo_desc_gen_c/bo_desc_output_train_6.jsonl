{"sample_id": "train.592", "db_id": "store_1", "question": "What is Nancy Edwards's address?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Select the column to display, 'address'.", "Add conditions to filter the 'first_name' and 'last_name' columns for the specified employee using placeholders for string values."], "gold_sql": "SELECT address FROM employees WHERE first_name = 'Nancy' AND last_name = 'Edwards';", "source_tables": ["employees"], "description": "This virtual table provides the street address of employees from the 'employees' table based on their first and last names. The placeholders in the WHERE clause represent the specific first and last names of the employee being queried.", "virtual_table": "SELECT address FROM employees WHERE first_name = [PLACEHOLDER-TYPE:STRING] AND last_name = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.560", "db_id": "store_1", "question": "What are the total amount of money in the invoices billed from Chicago, Illinois?", "rationale": ["The query identifies the relevant table, which is 'invoices'.", "It selects the sum of the 'total' column to calculate the total amount of invoices.", "A condition is added to filter the results based on the 'billing_city' and 'billing_state' columns using placeholders for string values."], "gold_sql": "SELECT sum(total) FROM invoices WHERE billing_city  =  'Chicago' AND billing_state  =  'IL';", "source_tables": ["invoices"], "description": "This virtual table calculates the total amount of invoices issued for a specific billing city and state. The placeholders in the WHERE clause represent the billing city and state for which the total is being calculated.", "virtual_table": "SELECT sum(total) FROM invoices WHERE billing_city  =  [PLACEHOLDER-TYPE:STRING] AND billing_state  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.555", "db_id": "store_1", "question": "List every album whose title starts with A in alphabetical order.", "rationale": ["The query identifies the relevant table, which is 'albums'.", "Select the column to display, 'title'.", "Add a condition to filter the 'title' column using a LIKE operator for pattern matching with a placeholder for string values.", "Order the results by the 'title' column."], "gold_sql": "SELECT title FROM albums WHERE title LIKE 'A%' ORDER BY title;", "source_tables": ["albums"], "description": "This virtual table describes the titles of albums from the 'albums' table that match a specific pattern. The placeholder in the WHERE clause represents the title pattern to search for.", "virtual_table": "SELECT title FROM albums WHERE title LIKE [PLACEHOLDER-TYPE:STRING] ORDER BY title;"}
{"sample_id": "train.589", "db_id": "store_1", "question": "find the full name of employees who report to Nancy Edwards?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "It uses a self-join to connect employees with their managers by matching the 'id' of the manager (T1) with the 'reports_to' field of the employee (T2).", "The SELECT statement specifies the columns to display, which are 'first_name' and 'last_name' of the employees reporting to the specified manager.", "Conditions are added to filter the results based on the first and last names of the manager using placeholders for string values."], "gold_sql": "SELECT T2.first_name , T2.last_name FROM employees AS T1 JOIN employees AS T2 ON T1.id = T2.reports_to WHERE T1.first_name = 'Nancy' AND T1.last_name = 'Edwards';", "source_tables": ["employees"], "description": "This virtual table describes the first and last names of employees who report to a specific manager from the 'employees' table. The placeholders in the WHERE clause represent the first and last names of the manager.", "virtual_table": "SELECT T2.first_name , T2.last_name FROM employees AS T1 JOIN employees AS T2 ON T1.id = T2.reports_to WHERE T1.first_name = [PLACEHOLDER-TYPE:STRING] AND T1.last_name = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.625", "db_id": "store_1", "question": "List name of all tracks in Balls to the Wall.", "rationale": ["The query identifies the relevant tables, which are 'albums' and 'tracks'.", "It selects the 'name' column from the 'tracks' table.", "A JOIN operation is performed on the 'albums' table and 'tracks' table using the album's ID and genre ID.", "A condition is added to filter the results based on the specified album title using a placeholder for string values."], "gold_sql": "SELECT T2.name FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T1.title = 'Balls to the Wall';", "source_tables": ["albums", "tracks"], "description": "This virtual table describes the names of tracks from the 'tracks' table that belong to a specific album title in the 'albums' table. The placeholder in the WHERE clause represents the title of the album.", "virtual_table": "SELECT T2.name FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T1.title = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.624", "db_id": "store_1", "question": "What is the name of the album that has the track Ball to the Wall?", "rationale": ["The query identifies the relevant tables, which are 'albums' and 'tracks'.", "It selects the 'title' column from the 'albums' table.", "A JOIN is performed between 'albums' and 'tracks' on the condition that the album's ID matches the genre ID of the track, which is likely a mistake since it should match the album ID instead.", "A condition is added to filter the tracks by their name using a placeholder for string values."], "gold_sql": "SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T2.name = 'Balls to the Wall';", "source_tables": ["albums", "tracks"], "description": "This virtual table describes the titles of albums from the 'albums' table that contain tracks of a specific name. The placeholder in the WHERE clause represents the name of the track.", "virtual_table": "SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T2.name = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.553", "db_id": "store_1", "question": "List every album ordered by album title in ascending order.", "rationale": ["The query identifies the relevant table, which is 'albums'.", "Select the column to display, 'title'.", "Add an ORDER BY clause to sort the results by the 'title' column in ascending order."], "gold_sql": "SELECT title FROM albums ORDER BY title;", "source_tables": ["albums"], "description": "This virtual table lists the titles of all albums from the 'albums' table, sorted in alphabetical order. The query retrieves the 'title' column and orders the results by the album title.", "virtual_table": "SELECT title FROM albums ORDER BY title;"}
{"sample_id": "train.611", "db_id": "store_1", "question": "List all media types.", "rationale": ["The query identifies the relevant table, which is 'media_types'.", "Select the column to display, 'name', which represents the name of each media type."], "gold_sql": "SELECT name FROM media_types;", "source_tables": ["media_types"], "description": "This virtual table describes the names of different media types from the 'media_types' table. The query retrieves all media type names without any filtering conditions.", "virtual_table": "SELECT name FROM media_types;"}
{"sample_id": "train.4943", "db_id": "store_product", "question": "What are the names of the districts that have both mall and village store style shops?", "rationale": ["The query identifies the relevant tables: 'store', 'store_district', and 'district'.", "It selects the 'District_name' from the 'district' table.", "The query uses JOINs to connect the 'store' table with 'store_district' and then with 'district' to filter the results based on the store type.", "The INTERSECT operator is used to find common districts between two queries that filter by the same store type, represented by placeholders."], "gold_sql": "SELECT t3.District_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t1.Type  =  'City Mall' INTERSECT SELECT t3.District_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t1.Type  =  'Village Store'", "source_tables": ["store_district", "store", "district"], "description": "This virtual table identifies the names of districts that have stores of a specific type, ensuring that only districts with stores of the same type are returned. The placeholders in the WHERE clause represent the type of store being queried.", "virtual_table": "SELECT t3.District_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t1.Type  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT t3.District_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t1.Type  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4942", "db_id": "store_product", "question": "Find the names of districts where have both city mall and village store type stores.", "rationale": ["The query is identifying the relevant tables, which are 'store', 'store_district', and 'district'.", "It selects the 'District_name' from the 'district' table.", "The query uses JOINs to connect the 'store' table with 'store_district' and then with 'district' to filter the results based on the store type.", "The INTERSECT operator is used to find common districts that have stores of the specified types, using placeholders for the store types."], "gold_sql": "SELECT t3.District_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t1.Type  =  'City Mall' INTERSECT SELECT t3.District_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t1.Type  =  'Village Store'", "source_tables": ["store_district", "store", "district"], "description": "This virtual table identifies the names of districts that have stores of a specific type, intersecting the results for two different types of stores. The placeholders in the WHERE clause represent the types of stores being queried.", "virtual_table": "SELECT t3.District_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t1.Type  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT t3.District_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t1.Type  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4939", "db_id": "store_product", "question": "What are the names of all products that are not the most frequently-used maximum page size?", "rationale": ["The query identifies the relevant table, which is 'product'.", "Select the column to display, 'product'.", "Add a condition to filter out products that have the maximum page size, using a subquery to find the most common maximum page size.", "The subquery groups the products by 'max_page_size', orders them by their count in descending order, and limits the result to one, which is represented by a numeric placeholder."], "gold_sql": "SELECT product FROM product WHERE product != (SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["product"], "description": "This virtual table lists the names or descriptions of products from the 'product' table that do not have the most common maximum page size. The placeholder in the subquery represents a numeric value used to limit the results of the maximum page size.", "virtual_table": "SELECT product FROM product WHERE product != (SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.4931", "db_id": "store_product", "question": "What are the products with the maximum page size A4 that also have a pages per minute color smaller than 5?", "rationale": ["The query identifies the relevant table, which is 'product'.", "Select the column to display, 'product'.", "Add conditions to filter the 'max_page_size' column for a specified maximum size using a placeholder for string values.", "Add a condition to filter the 'pages_per_minute_color' column to be less than a specified number using a placeholder for numeric values."], "gold_sql": "SELECT product FROM product WHERE max_page_size  =  'A4' AND pages_per_minute_color  <  5", "source_tables": ["product"], "description": "This virtual table describes the products from the 'product' table that have a specific maximum page size and a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the maximum pages per minute for color output.", "virtual_table": "SELECT product FROM product WHERE max_page_size  =  [PLACEHOLDER-TYPE:STRING] AND pages_per_minute_color  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4933", "db_id": "store_product", "question": "What are the products with the maximum page size eqal to A4 or a pages per minute color less than 5?", "rationale": ["The query identifies the relevant table, which is 'product'.", "Select the column to display, 'product'.", "Add conditions to filter the 'max_page_size' for a specific value and 'pages_per_minute_color' for a numeric threshold using placeholders for string and numeric values."], "gold_sql": "SELECT product FROM product WHERE max_page_size  =  'A4' OR pages_per_minute_color  <  5", "source_tables": ["product"], "description": "This virtual table describes the products from the 'product' table that either have a specific maximum page size or have a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the print speed limit.", "virtual_table": "SELECT product FROM product WHERE max_page_size  =  [PLACEHOLDER-TYPE:STRING] OR pages_per_minute_color  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4922", "db_id": "store_product", "question": "Find the number of stores in each city.", "rationale": ["The query identifies the relevant tables: 'store', 'store_district', and 'district'.", "It selects the 'headquartered_city' from the 'district' table and counts the number of stores.", "The JOIN operations link the 'store' table to the 'store_district' table and then to the 'district' table based on their respective IDs.", "The GROUP BY clause is used to aggregate the results by 'headquartered_city', providing a count of stores for each city."], "gold_sql": "SELECT t3.headquartered_city ,  count(*) FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id GROUP BY t3.headquartered_city", "source_tables": ["store_district", "store", "district"], "description": "This virtual table provides a count of stores grouped by the city where their respective districts are headquartered. The placeholders in the query represent the relationships between stores and districts, allowing for aggregation of store counts based on the city names.", "virtual_table": "SELECT t3.headquartered_city ,  count(*) FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id GROUP BY t3.headquartered_city"}
{"sample_id": "train.4925", "db_id": "store_product", "question": "What is the city with the most number of flagship stores?", "rationale": ["The query identifies the relevant tables: 'store', 'store_district', and 'district'.", "It joins these tables to connect stores with their respective districts and the cities where those districts are headquartered.", "The results are grouped by the 'headquartered_city' to aggregate the data based on city names.", "The results are ordered by the count of stores in each city in descending order to prioritize cities with more stores.", "A limit is applied to restrict the number of cities returned, using a placeholder for numeric values."], "gold_sql": "SELECT t3.headquartered_city FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id GROUP BY t3.headquartered_city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["store_district", "store", "district"], "description": "This virtual table provides a list of cities where the headquarters of districts are located, based on the stores associated with those districts. The results are grouped by the city name and ordered by the number of stores in each city, with a limit on the number of cities returned as specified by the placeholder.", "virtual_table": "SELECT t3.headquartered_city FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id GROUP BY t3.headquartered_city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4916", "db_id": "store_product", "question": "Find the names of all stores in Khanewal District.", "rationale": ["The query identifies the relevant tables: 'store', 'store_district', and 'district'.", "It selects the 'store_name' column from the 'store' table.", "The query uses JOIN operations to connect 'store' with 'store_district' and then 'store_district' with 'district'.", "A condition is added to filter the results based on the 'district_name' column using a placeholder for string values."], "gold_sql": "SELECT t1.store_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t3.district_name  =  'Khanewal District'", "source_tables": ["store_district", "store", "district"], "description": "This virtual table describes the names of stores located in a specific district. The query joins the 'store', 'store_district', and 'district' tables to filter stores based on the district's name provided as a placeholder.", "virtual_table": "SELECT t1.store_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t3.district_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4928", "db_id": "store_product", "question": "What products are available at store named \"Miramichi\"?", "rationale": ["The query identifies the relevant tables: 'product', 'store_product', and 'store'.", "It selects the 'product' column from the 'product' table.", "The JOIN operations link the 'product' table to the 'store_product' table using 'product_id', and then to the 'store' table using 'store_id'.", "A condition is added to filter the results based on the specified store name using a placeholder for string values."], "gold_sql": "SELECT t1.product FROM product AS t1 JOIN store_product AS t2 ON t1.product_id  =  t2.product_id JOIN store AS t3 ON t2.store_id  =  t3.store_id WHERE t3.store_name  =  'Miramichi'", "source_tables": ["store", "store_product", "product"], "description": "This virtual table describes the products available in a specific store. The placeholder in the WHERE clause represents the name of the store for which the products are being queried.", "virtual_table": "SELECT t1.product FROM product AS t1 JOIN store_product AS t2 ON t1.product_id  =  t2.product_id JOIN store AS t3 ON t2.store_id  =  t3.store_id WHERE t3.store_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4934", "db_id": "store_product", "question": "Find all the product whose name contains the word \"Scanner\".", "rationale": ["The query is identifying the relevant table, which is 'product'.", "Select the column to display, 'product'.", "Add a condition to filter the 'product' column using a LIKE operator for pattern matching with a placeholder for string values."], "gold_sql": "SELECT product FROM product WHERE product LIKE '%Scanner%'", "source_tables": ["product"], "description": "This virtual table describes the products from the 'product' table that match a specific search criterion. The placeholder in the WHERE clause represents a pattern for the product name or description.", "virtual_table": "SELECT product FROM product WHERE product LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.81", "db_id": "student_assessment", "question": "How many registed students do each course have? List course name and the number of their registered students?", "rationale": ["The query identifies the relevant tables: 'Students', 'Student_Course_Registrations', and 'Courses'.", "It selects the 'course_name' from the 'Courses' table and counts the number of registrations.", "The join between 'Students' and 'Student_Course_Registrations' links students to their course registrations.", "The join between 'Student_Course_Registrations' and 'Courses' retrieves the course names associated with each registration.", "The results are grouped by 'course_id' to aggregate the count of students for each course."], "gold_sql": "SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id", "source_tables": ["courses", "student_course_registrations", "students"], "description": "This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve the course names. The result is grouped by course ID to count the number of students per course.", "virtual_table": "SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id"}
{"sample_id": "train.89", "db_id": "student_assessment", "question": "What is the id of the student who most recently registered course 301?", "rationale": ["The query identifies the relevant table, which is 'Student_Course_Attendance'.", "It selects the 'student_id' column to display the identifiers of students who attended a specific course.", "A condition is added to filter the results based on the 'course_id' using a placeholder for numeric values.", "The results are ordered by 'date_of_attendance' in descending order to show the most recent attendance first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT student_id FROM student_course_attendance WHERE course_id = 301 ORDER BY date_of_attendance DESC LIMIT 1", "source_tables": ["student_course_attendance"], "description": "This virtual table provides a list of student identifiers from the 'Student_Course_Attendance' table for a specific course. The results are ordered by the date of attendance in descending order, and the number of results returned is limited by a placeholder for numeric values.", "virtual_table": "SELECT student_id FROM student_course_attendance WHERE course_id = [PLACEHOLDER-TYPE:NUMBER] ORDER BY date_of_attendance DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.78", "db_id": "student_assessment", "question": "What are the details of the student who registered for the most number of courses?", "rationale": ["The query identifies the relevant tables, 'Students' and 'Student_Course_Registrations'.", "It selects the 'student_details' column from the 'Students' table.", "A JOIN operation is performed to link students with their course registrations based on the 'student_id'.", "The results are grouped by 'student_id' to ensure each student appears only once in the results.", "The results are ordered by the count of course registrations in descending order to prioritize students with more registrations.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_course_registrations", "students"], "description": "This virtual table provides a list of student details from the 'Students' table, specifically focusing on those who have registered for courses. The results are grouped by each student to ensure unique entries, and they are ordered by the number of course registrations in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of student details to retrieve.", "virtual_table": "SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.58", "db_id": "student_assessment", "question": "what is id of students who registered some courses but the least number of courses in these students?", "rationale": ["The query identifies the relevant table, which is 'Student_Course_Registrations'.", "It selects the 'student_id' column to display unique student identifiers.", "The results are grouped by 'student_id' to ensure each student is listed only once.", "The results are ordered by the count of registrations for each student to prioritize those with more courses registered.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT 1", "source_tables": ["student_course_registrations"], "description": "This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the limit on the number of results returned can be specified using a placeholder for numeric values.", "virtual_table": "SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.59", "db_id": "student_assessment", "question": "What are the ids of the students who registered for some courses but had the least number of courses for all students?", "rationale": ["The query identifies the relevant table, which is 'Student_Course_Registrations'.", "It selects the 'student_id' column to display unique student identifiers.", "The results are grouped by 'student_id' to ensure each student is listed only once.", "The results are ordered by the count of registrations for each student to prioritize those with more courses registered.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT 1", "source_tables": ["student_course_registrations"], "description": "This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the number of results returned is limited by a specified placeholder value.", "virtual_table": "SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.67", "db_id": "student_assessment", "question": "What is detail of the student who most recently registered course?", "rationale": ["The query identifies the relevant tables, 'Student_Course_Registrations' and 'Students'.", "It selects the 'student_details' column from the 'Students' table.", "A JOIN operation is performed to link the two tables based on the 'student_id'.", "The results are ordered by 'registration_date' in descending order to show the most recent registrations first.", "A placeholder is included to limit the number of results returned."], "gold_sql": "SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT 1", "source_tables": ["student_course_registrations", "students"], "description": "This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.", "virtual_table": "SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.68", "db_id": "student_assessment", "question": "What details do we have on the students who registered for courses most recently?", "rationale": ["The query identifies the relevant tables, which are 'Student_Course_Registrations' and 'Students'.", "It selects the 'student_details' column from the 'Students' table.", "A JOIN operation is performed to link 'Student_Course_Registrations' with 'Students' using the 'student_id'.", "The results are ordered by 'registration_date' in descending order to show the most recent registrations first.", "A placeholder is included to limit the number of results returned."], "gold_sql": "SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT 1", "source_tables": ["student_course_registrations", "students"], "description": "This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.", "virtual_table": "SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.103", "db_id": "student_assessment", "question": "What are all info of students who registered courses but not attended courses?", "rationale": ["The query identifies the relevant table, which is 'student_course_registrations'.", "It selects all columns from this table.", "A subquery is used to filter out students who have attended any courses by checking the 'student_id' in the 'student_course_attendance' table, ensuring only those who have not attended are included."], "gold_sql": "SELECT * FROM student_course_registrations WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)", "source_tables": ["student_course_attendance", "student_course_registrations"], "description": "This virtual table provides a list of all course registrations for students who have not attended any courses. The query retrieves all columns from the 'student_course_registrations' table, filtering out students based on their attendance records.", "virtual_table": "SELECT * FROM student_course_registrations WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)"}
{"sample_id": "train.92", "db_id": "student_assessment", "question": "What are the different cities where people live?", "rationale": ["The query identifies the relevant tables, which are 'Addresses' and 'People_Addresses'.", "It selects distinct cities from the 'Addresses' table to avoid duplicates.", "A JOIN operation is performed between 'Addresses' and 'People_Addresses' on the 'address_id' to link addresses with people."], "gold_sql": "SELECT DISTINCT T1.city FROM addresses AS T1 JOIN people_addresses AS T2 ON T1.address_id = T2.address_id", "source_tables": ["addresses", "people_addresses"], "description": "This virtual table provides a list of unique cities from the 'Addresses' table that are associated with people through the 'People_Addresses' table. The placeholder in the JOIN clause represents the relationship between addresses and people.", "virtual_table": "SELECT DISTINCT T1.city FROM addresses AS T1 JOIN people_addresses AS T2 ON T1.address_id = T2.address_id"}
{"sample_id": "dev.526", "db_id": "student_transcripts_tracking", "question": "What are the names and ids of every course with less than 2 sections?", "rationale": ["The query identifies the relevant tables, which are 'Courses' and 'Sections'.", "It selects the 'course_name' and 'course_id' from the 'Courses' table, aliased as T1.", "A JOIN operation is performed between 'Courses' and 'Sections' on the 'course_id' to link courses with their sections.", "The results are grouped by 'course_id' to aggregate the sections for each course.", "The HAVING clause filters the results to include only those courses that have a count of sections less than or equal to the specified number using a placeholder for numeric values."], "gold_sql": "SELECT T1.course_name ,  T1.course_id FROM Courses AS T1 JOIN Sections AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_id HAVING count(*)  <=  2", "source_tables": ["courses", "sections"], "description": "This virtual table provides a list of course names and their corresponding identifiers from the 'Courses' table, specifically for those courses that have a number of sections less than or equal to a specified threshold. The placeholder in the HAVING clause represents the maximum number of sections allowed for the courses listed.", "virtual_table": "SELECT T1.course_name ,  T1.course_id FROM Courses AS T1 JOIN Sections AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_id HAVING count(*)  <=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.535", "db_id": "student_transcripts_tracking", "question": "Who is enrolled in a Bachelor degree program? List the first name, middle name, last name.", "rationale": ["The query identifies the relevant tables: 'Students', 'Student_Enrolment', and 'Degree_Programs'.", "It selects distinct names (first, middle, last) from the 'Students' table.", "The JOIN operations link the 'Students' table to the 'Student_Enrolment' table using the student ID, and then to the 'Degree_Programs' table using the degree program ID.", "A condition is added to filter the results based on the specified degree program name using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  'Bachelor'", "source_tables": ["student_enrolment", "degree_programs", "students"], "description": "This virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholders in the WHERE clause represent the name of the degree program being queried.", "virtual_table": "SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.572", "db_id": "student_transcripts_tracking", "question": "What is the maximum number of times that a course shows up in different transcripts and what is that course's enrollment id?", "rationale": ["The query identifies the relevant table, which is 'Transcript_Contents'.", "It selects a count of occurrences and the 'student_course_id' to show how many times each course is recorded.", "The results are grouped by 'student_course_id' to aggregate the counts for each course.", "The results are ordered by the count in descending order to prioritize the most frequent courses.", "A placeholder is used in the LIMIT clause to specify the maximum number of results to return."], "gold_sql": "SELECT count(*) ,  student_course_id FROM Transcript_Contents GROUP BY student_course_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["transcript_contents"], "description": "This virtual table provides a count of how many times each student course appears in the transcripts, grouped by the course identifier. The results are ordered by the count in descending order, allowing users to see the most frequently recorded courses. The placeholder in the LIMIT clause represents the maximum number of results to return.", "virtual_table": "SELECT count(*) ,  student_course_id FROM Transcript_Contents GROUP BY student_course_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.575", "db_id": "student_transcripts_tracking", "question": "Find the semester when both Master students and Bachelor students got enrolled in.", "rationale": ["The query is identifying the relevant tables, which are 'Degree_Programs' and 'Student_Enrolment'.", "It selects distinct semester IDs from the 'Student_Enrolment' table that are linked to the 'Degree_Programs' table based on the degree program ID.", "The query uses an INTERSECT operation to find common semesters for the specified degree program name, using placeholders for the degree program name."], "gold_sql": "SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Master' INTERSECT SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Bachelor'", "source_tables": ["student_enrolment", "degree_programs"], "description": "This virtual table identifies the distinct semesters in which students are enrolled in a specific degree program. The placeholders in the query represent the name of the degree program, allowing users to specify which program they are interested in to retrieve the relevant semesters.", "virtual_table": "SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.542", "db_id": "student_transcripts_tracking", "question": "What is the first, middle, and last name, along with the id and number of enrollments, for the student who enrolled the most in any program?", "rationale": ["The query identifies the relevant tables, 'Students' and 'Student_Enrolment'.", "It selects the student ID, first name, middle name, and last name from the 'Students' table.", "It counts the number of enrolments for each student by joining 'Students' with 'Student_Enrolment' on the student ID.", "The results are grouped by the student ID to aggregate the enrolment counts.", "Finally, the results are ordered by the count of enrolments in descending order, and a placeholder is used to limit the number of results returned."], "gold_sql": "SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "students"], "description": "This virtual table provides a list of students along with their first, middle, and last names, and the count of their enrolments in courses. The results are grouped by each student's unique identifier and ordered by the number of enrolments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of students to return.", "virtual_table": "SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.534", "db_id": "student_transcripts_tracking", "question": "What are the first, middle, and last names, along with the ids, of all students who enrolled in 2 degree programs in one semester?", "rationale": ["The query identifies the relevant table, which is 'Students', and aliases it as T1.", "It selects the columns for the student's first name, middle name, last name, and student ID.", "The query joins the 'Students' table with the 'Student_Enrolment' table (aliased as T2) to link students with their enrolment records.", "It groups the results by the student ID to aggregate the enrolment data.", "The HAVING clause filters the results to include only those students who are enrolled in a specific number of courses, using a placeholder for the numeric value."], "gold_sql": "SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  2", "source_tables": ["student_enrolment", "students"], "description": "This virtual table provides the first name, middle name, last name, and unique identifier of students from the 'Students' table who are enrolled in a specific number of courses. The placeholder in the HAVING clause represents the count of courses the students are enrolled in.", "virtual_table": "SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.549", "db_id": "student_transcripts_tracking", "question": "Find the last name of the students who currently live in the state of North Carolina but have not registered in any degree program.", "rationale": ["The query identifies the relevant tables, 'Students' and 'Addresses', to retrieve the last names of students.", "It joins the 'Students' table with the 'Addresses' table on the current address ID to filter students based on their current state.", "The WHERE clause specifies the condition to filter by the state using a placeholder for string values.", "The EXCEPT clause is used to exclude students who are currently enrolled in any degree program by joining the 'Students' table with the 'Student_Enrolment' table."], "gold_sql": "SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  'NorthCarolina' EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id", "source_tables": ["addresses", "student_enrolment", "students"], "description": "This virtual table lists the last names of students who currently reside in a specific state, excluding those who are enrolled in any degree program. The query joins the 'Students' table with the 'Addresses' table to filter by the current address's state, and uses an EXCEPT clause to remove students who are found in the 'Student_Enrolment' table.", "virtual_table": "SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id"}
{"sample_id": "dev.584", "db_id": "student_transcripts_tracking", "question": "What are the first names of the students who live in Haiti permanently or have the cell phone number 09700166582 ?", "rationale": ["The query identifies the relevant tables, which are 'Students' and 'Addresses'.", "It selects the 'first_name' column from the 'Students' table.", "A JOIN operation is performed to link 'Students' with 'Addresses' based on the permanent address ID.", "Conditions are added to filter results where the country matches a specified value or the mobile number matches a specified value, using placeholders for both."], "gold_sql": "select t1.first_name from students as t1 join addresses as t2 on t1.permanent_address_id  =  t2.address_id where t2.country  =  'haiti' or t1.cell_mobile_number  =  '09700166582'", "source_tables": ["addresses", "students"], "description": "This virtual table describes the first names of students from the 'Students' table who either have a permanent address in a specific country or have a specified mobile phone number. The placeholders in the WHERE clause represent the country name and the mobile phone number.", "virtual_table": "select t1.first_name from students as t1 join addresses as t2 on t1.permanent_address_id  =  t2.address_id where t2.country  =  [PLACEHOLDER-TYPE:STRING] or t1.cell_mobile_number  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.548", "db_id": "student_transcripts_tracking", "question": "What is the name of the course with the most students enrolled?", "rationale": ["The query identifies the relevant tables, 'Courses' and 'Student_Enrolment_Courses'.", "It selects the 'course_name' from the 'Courses' table.", "A JOIN operation is performed to link 'Courses' with 'Student_Enrolment_Courses' based on the course identifier.", "The results are grouped by 'course_name' to aggregate enrolment counts.", "The results are ordered by the count of enrolments in descending order to highlight the most popular courses.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT  T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["courses", "student_enrolment_courses"], "description": "This virtual table provides a list of course names from the 'Courses' table that are associated with student enrolments. The results are grouped by course name and ordered by the number of enrolments in descending order, allowing users to see the most popular courses. The placeholder in the LIMIT clause represents the maximum number of course names to return.", "virtual_table": "SELECT  T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.583", "db_id": "student_transcripts_tracking", "question": "Find the first name of the students who permanently live in the country Haiti or have the cell phone number 09700166582 .", "rationale": ["The query identifies the relevant tables, which are 'Students' and 'Addresses'.", "It selects the 'first_name' column from the 'Students' table.", "A JOIN operation is performed between 'Students' and 'Addresses' on the 'permanent_address_id' and 'address_id' columns to link students with their permanent addresses.", "A condition is added to filter results based on the 'country' column from the 'Addresses' table and the 'cell_mobile_number' column from the 'Students' table, using placeholders for string values."], "gold_sql": "select t1.first_name from students as t1 join addresses as t2 on t1.permanent_address_id  =  t2.address_id where t2.country  =  'haiti' or t1.cell_mobile_number  =  '09700166582'", "source_tables": ["addresses", "students"], "description": "This virtual table describes the first names of students from the 'Students' table who either have a permanent address in a specific country or have a specified mobile phone number. The placeholders in the WHERE clause represent the country name and the mobile number.", "virtual_table": "select t1.first_name from students as t1 join addresses as t2 on t1.permanent_address_id  =  t2.address_id where t2.country  =  [PLACEHOLDER-TYPE:STRING] or t1.cell_mobile_number  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.578", "db_id": "student_transcripts_tracking", "question": "What are the different addresses that have students living there?", "rationale": ["The query is identifying the relevant table, which is 'Students'.", "The goal is to count the distinct current addresses, so the COUNT function is used with DISTINCT on the 'current_address_id' column."], "gold_sql": "SELECT count(DISTINCT current_address_id) FROM Students", "source_tables": ["students"], "description": "This virtual table provides the count of distinct current addresses associated with students from the 'Students' table. The placeholder in the SELECT clause represents the unique current address identifiers.", "virtual_table": "SELECT count(DISTINCT current_address_id) FROM Students"}
{"sample_id": "dev.579", "db_id": "student_transcripts_tracking", "question": "List all the student details in reversed lexicographical order.", "rationale": ["The query identifies the relevant table, which is 'Students'.", "Selects the column 'other_student_details' to display additional information about students.", "Orders the results in descending order based on the 'other_student_details' column."], "gold_sql": "SELECT other_student_details FROM Students ORDER BY other_student_details DESC", "source_tables": ["students"], "description": "This virtual table provides a list of additional details related to students from the 'Students' table, sorted in descending order. The placeholder in the SELECT clause represents the specific details of the students.", "virtual_table": "SELECT other_student_details FROM Students ORDER BY other_student_details DESC"}
{"sample_id": "train.4322", "db_id": "tracking_grants_for_research", "question": "List the project details of the project both producing patent and paper as outcomes.", "rationale": ["The query identifies the relevant table, which is 'Projects', and uses an alias for clarity.", "It joins the 'Projects' table with the 'Project_Outcomes' table to access the outcome codes associated with each project.", "The WHERE clause filters the results based on two different outcome codes, ensuring that only projects with both outcomes are selected.", "The INTERSECT operator is used to find projects that meet both outcome criteria, ensuring the results are distinct."], "gold_sql": "SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  'Paper' INTERSECT SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  'Patent'", "source_tables": ["project_outcomes", "projects"], "description": "This virtual table describes the project details from the 'Projects' table that have specific outcomes. It retrieves project details for projects that have two different specified outcome codes, ensuring that only projects meeting both criteria are included in the results. The placeholders in the WHERE clause represent the outcome codes being queried.", "virtual_table": "SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4338", "db_id": "tracking_grants_for_research", "question": "List the project details of the projects which did not hire any staff for a researcher role.", "rationale": ["The query identifies the relevant table, which is 'Projects'.", "It selects the 'project_details' column to display information about the projects.", "The WHERE clause filters out projects that have staff members associated with a specific role by using a subquery that selects 'project_id' from the 'Project_Staff' table where the 'role_code' matches the placeholder for string values."], "gold_sql": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_Staff WHERE role_code  =  'researcher' )", "source_tables": ["project_staff", "projects"], "description": "This virtual table provides a list of project details from the 'Projects' table for projects that do not have any associated staff members with a specific role. The placeholder in the WHERE clause represents the role code that is being filtered out.", "virtual_table": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING] )"}
{"sample_id": "train.4326", "db_id": "tracking_grants_for_research", "question": "List from which date and to which date these staff work: project staff of the project which hires the most staffs", "rationale": ["The query identifies the relevant table, which is 'Project_Staff'.", "It selects the columns 'date_from' and 'date_to' to show the involvement dates of staff members.", "The first part of the query filters projects based on the count of staff members, using a subquery to get the top N projects.", "The second part of the query filters by a specific 'role_code', allowing for a focused view of staff involvement based on their roles."], "gold_sql": "SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT 1 ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  'leader'", "source_tables": ["project_staff"], "description": "This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.", "virtual_table": "SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4321", "db_id": "tracking_grants_for_research", "question": "What are the different grant amounts for documents sent before '1986-08-26 20:49:27' and after the grant ended on '1989-03-16 18:27:16'?", "rationale": ["The query identifies the relevant tables, which are 'Grants' and 'Documents'.", "It selects the 'grant_amount' from the 'Grants' table.", "A JOIN operation is performed between 'Grants' and 'Documents' on the 'grant_id' to link the two tables.", "The first condition filters documents based on the 'sent_date' being earlier than a specified date using a placeholder for string values.", "The INTERSECT operation is used to find common grant amounts that also meet the second condition, which filters grants based on the 'grant_end_date' being later than another specified date, again using a placeholder for string values."], "gold_sql": "SELECT T1.grant_amount FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id WHERE T2.sent_date  <  '1986-08-26 20:49:27' INTERSECT SELECT grant_amount FROM grants WHERE grant_end_date  >  '1989-03-16 18:27:16'", "source_tables": ["grants", "documents"], "description": "This virtual table provides the grant amounts from the 'Grants' table that are associated with documents sent before a specific date and grants that are still active after a certain end date. The placeholders in the WHERE clause represent the dates for filtering the documents and grants.", "virtual_table": "SELECT T1.grant_amount FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id WHERE T2.sent_date  <  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT grant_amount FROM grants WHERE grant_end_date  >  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4339", "db_id": "tracking_grants_for_research", "question": "What are the details for all projects that did not hire any staff in a research role?", "rationale": ["The query identifies the relevant table, which is 'Projects'.", "It selects the 'project_details' column to display information about the projects.", "The WHERE clause filters out projects that have staff members associated with a specific role by using a subquery that selects 'project_id' from the 'Project_Staff' table where the 'role_code' matches the placeholder for string values."], "gold_sql": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_Staff WHERE role_code  =  'researcher' )", "source_tables": ["project_staff", "projects"], "description": "This virtual table provides a list of project details from the 'Projects' table for projects that do not have any associated staff members with a specific role. The placeholder in the WHERE clause represents the role code that is being filtered out.", "virtual_table": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING] )"}
{"sample_id": "train.4323", "db_id": "tracking_grants_for_research", "question": "What are the details of the project that is producing both patents and papers as outcomes?", "rationale": ["The query identifies the relevant table, which is 'Projects', and aliases it as T1.", "It joins the 'Project_Outcomes' table, aliased as T2, on the project_id to link projects with their outcomes.", "The WHERE clause filters the results based on the first outcome_code using a placeholder for string values.", "The INTERSECT operation is used to find projects that also meet a second outcome_code condition, again using a placeholder for string values."], "gold_sql": "SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  'Paper' INTERSECT SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  'Patent'", "source_tables": ["project_outcomes", "projects"], "description": "This virtual table describes the project details from the 'Projects' table that have two specific outcomes. The query uses an INTERSECT operation to find projects that meet both outcome criteria, represented by placeholders for the outcome codes.", "virtual_table": "SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4391", "db_id": "tracking_grants_for_research", "question": "For each project id, how many tasks are there?", "rationale": ["The query identifies the relevant tables, which are 'Projects' and 'Tasks'.", "It selects the count of tasks and the project details from the 'Projects' table.", "A JOIN operation is performed on the 'project_id' to link tasks to their respective projects.", "The results are grouped by 'project_id' to aggregate the task counts for each project."], "gold_sql": "SELECT count(*) ,  T1.project_details FROM Projects AS T1 JOIN Tasks AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id", "source_tables": ["tasks", "projects"], "description": "This virtual table provides a count of tasks associated with each project along with the project details from the 'Projects' table. The count is grouped by the unique project identifier, allowing users to see how many tasks are linked to each project.", "virtual_table": "SELECT count(*) ,  T1.project_details FROM Projects AS T1 JOIN Tasks AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id"}
{"sample_id": "train.4359", "db_id": "tracking_grants_for_research", "question": "What are the details of the project with no outcomes?", "rationale": ["The query identifies the relevant table, which is 'Projects'.", "It selects the 'project_details' column to display information about the projects.", "The WHERE clause uses a subquery to filter out projects that have associated outcomes in the 'Project_Outcomes' table, ensuring only projects without outcomes are included."], "gold_sql": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_outcomes )", "source_tables": ["project_outcomes", "projects"], "description": "This virtual table provides a list of project details from the 'Projects' table for projects that do not have any associated outcomes in the 'Project_Outcomes' table. The placeholder in the WHERE clause indicates that we are filtering projects based on their unique identifiers, ensuring we only retrieve those without outcomes.", "virtual_table": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_outcomes )"}
{"sample_id": "train.4351", "db_id": "tracking_grants_for_research", "question": "For each project id, how many staff does it have? List them in increasing order.", "rationale": ["The query identifies the relevant tables, which are 'Project_Staff' and 'Projects'.", "It selects the 'project_id' from 'Project_Staff' and counts the number of staff members associated with each project.", "The JOIN operation links 'Project_Staff' with 'Projects' based on the 'project_id'.", "The results are grouped by 'project_id' to aggregate the count of staff members for each project.", "Finally, the results are ordered in ascending order based on the count of staff members."], "gold_sql": "SELECT T1.project_id ,  count(*) FROM Project_Staff AS T1 JOIN Projects AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) ASC", "source_tables": ["project_staff", "projects"], "description": "This virtual table provides a count of staff members associated with each project from the 'Project_Staff' table, grouped by project ID. The results are ordered in ascending order based on the number of staff members per project.", "virtual_table": "SELECT T1.project_id ,  count(*) FROM Project_Staff AS T1 JOIN Projects AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) ASC"}
{"sample_id": "train.4385", "db_id": "tracking_grants_for_research", "question": "What are the details for the projects which were launched by the organization with the most projects?", "rationale": ["The query identifies the relevant table, which is 'Projects'.", "It selects the 'project_details' column to display information about the projects.", "The WHERE clause filters the results to include only those organisations that have the highest number of projects, using a subquery that groups by 'organisation_id' and orders by the count of projects in descending order.", "The LIMIT clause uses a placeholder to allow the user to specify how many top organisations to include in the results."], "gold_sql": "SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT 1 )", "source_tables": ["projects"], "description": "This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.", "virtual_table": "SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] )"}
{"sample_id": "train.4393", "db_id": "tracking_grants_for_research", "question": "What roles did staff members play between '2003-04-19 15:06:20' and '2016-03-15 00:33:18'?", "rationale": ["The query identifies the relevant table, which is 'Project_Staff'.", "Select the column to display, 'role_code'.", "Add conditions to filter the 'date_from' and 'date_to' columns for the specified date range using placeholders for string values."], "gold_sql": "SELECT role_code FROM Project_Staff WHERE date_from  >  '2003-04-19 15:06:20' AND date_to  <  '2016-03-15 00:33:18'", "source_tables": ["project_staff"], "description": "This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.", "virtual_table": "SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4332", "db_id": "tracking_grants_for_research", "question": "Which organisation type hires most research staff?", "rationale": ["The query identifies the relevant tables, 'Organisations' and 'Research_Staff'.", "It selects the 'organisation_type' from the 'Organisations' table.", "A JOIN operation is performed to link 'Organisations' with 'Research_Staff' based on the organisation ID.", "The results are grouped by 'organisation_type' to aggregate the data accordingly.", "The results are ordered by the count of research staff in each organisation type in descending order.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "description": "This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type. The results are ordered by the number of research staff in each organisation type, and the placeholder in the LIMIT clause allows for specifying the maximum number of organisation types to return.", "virtual_table": "SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4373", "db_id": "tracking_grants_for_research", "question": "What are the details of all organizations that are described as Sponsors and sort the results in ascending order?", "rationale": ["The query identifies the relevant tables, which are 'Organisations' and 'Organisation_Types'.", "It selects the 'organisation_details' column from the 'Organisations' table.", "A JOIN operation is performed to connect 'Organisations' with 'Organisation_Types' based on the organisation type.", "A condition is added to filter the results based on the organisation type description using a placeholder for string values.", "The results are ordered by 'organisation_details' to present them in a sorted manner."], "gold_sql": "SELECT organisation_details FROM Organisations AS T1 JOIN organisation_Types AS T2 ON T1.organisation_type  =  T2.organisation_type WHERE T2.organisation_type_description  =  'Sponsor' ORDER BY organisation_details", "source_tables": ["organisation_types", "organisations"], "description": "This virtual table provides the details of organisations from the 'Organisations' table that are associated with a specific type of organisation. It joins the 'Organisations' table with the 'Organisation_Types' table to filter organisations based on their type description. The placeholder in the WHERE clause represents the description of the organisation type, and the results are ordered by the organisation details.", "virtual_table": "SELECT organisation_details FROM Organisations AS T1 JOIN organisation_Types AS T2 ON T1.organisation_type  =  T2.organisation_type WHERE T2.organisation_type_description  =  [PLACEHOLDER-TYPE:STRING] ORDER BY organisation_details"}
{"sample_id": "train.4377", "db_id": "tracking_grants_for_research", "question": "How many project members were leaders or started working before '1989-04-24 23:51:54'?", "rationale": ["The query identifies the relevant table, which is 'Project_Staff'.", "It selects a count of all entries in the table.", "The WHERE clause includes conditions to filter by 'role_code' and 'date_from', using placeholders for string values."], "gold_sql": "SELECT count(*) FROM Project_Staff WHERE role_code  =  'leader' OR date_from  <  '1989-04-24 23:51:54'", "source_tables": ["project_staff"], "description": "This virtual table provides a count of staff members associated with projects, filtered by a specific role code or by their involvement start date. The placeholders in the WHERE clause represent the role code and the date from which the staff member's involvement is considered.", "virtual_table": "SELECT count(*) FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING] OR date_from  <  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4396", "db_id": "tracking_grants_for_research", "question": "Which role is most common for the staff?", "rationale": ["The query identifies the relevant table, which is 'Project_Staff'.", "It selects the 'role_code' column to display unique role codes.", "The results are grouped by 'role_code' to ensure uniqueness.", "The results are ordered by the count of each role code in descending order to show the most common roles first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT role_code FROM Project_Staff GROUP BY role_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_staff"], "description": "This virtual table provides a list of unique role codes from the 'Project_Staff' table, grouped by the role code and ordered by the number of occurrences in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of role codes to retrieve.", "virtual_table": "SELECT role_code FROM Project_Staff GROUP BY role_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4357", "db_id": "tracking_grants_for_research", "question": "What are the details and id of the project with the most outcomes?", "rationale": ["The query identifies the relevant tables, 'Projects' and 'Project_Outcomes'.", "It selects the 'project_details' and 'project_id' from the 'Projects' table.", "A JOIN operation is performed between 'Projects' and 'Project_Outcomes' on the 'project_id' to link projects with their outcomes.", "The results are grouped by 'project_id' to aggregate the outcomes for each project.", "The results are ordered by the count of outcomes in descending order to prioritize projects with more outcomes.", "A LIMIT clause is included to restrict the number of results returned based on a placeholder for numeric values."], "gold_sql": "SELECT T1.project_details ,  T1.project_id FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "projects"], "description": "This virtual table provides a list of project details and their corresponding project IDs from the 'Projects' table. It joins with the 'Project_Outcomes' table to aggregate the outcomes associated with each project. The results are grouped by project ID and ordered by the count of outcomes in descending order, allowing the user to limit the number of results returned based on a specified number.", "virtual_table": "SELECT T1.project_details ,  T1.project_id FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4376", "db_id": "tracking_grants_for_research", "question": "How many project staff worked as leaders or started working before '1989-04-24 23:51:54'?", "rationale": ["The query identifies the relevant table, which is 'Project_Staff'.", "It selects a count of all records in the table.", "The WHERE clause includes conditions to filter by 'role_code' and 'date_from', using placeholders for string values."], "gold_sql": "SELECT count(*) FROM Project_Staff WHERE role_code  =  'leader' OR date_from  <  '1989-04-24 23:51:54'", "source_tables": ["project_staff"], "description": "This virtual table provides a count of staff members associated with projects, filtered by a specific role code or by their involvement start date. The placeholders in the WHERE clause represent the role code and the date from which the staff member's involvement is considered.", "virtual_table": "SELECT count(*) FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING] OR date_from  <  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4337", "db_id": "tracking_grants_for_research", "question": "What is the response received date for the document described as Regular that was granted more than 100 dollars?", "rationale": ["The query identifies the relevant tables: 'Documents', 'Document_Types', and 'Grants'.", "It selects the 'response_received_date' from the 'Documents' table.", "Joins are made between 'Documents' and 'Document_Types' on 'document_type_code', and between 'Documents' and 'Grants' on 'grant_id'.", "The WHERE clause filters results based on a specific document description and a condition on the grant amount, using placeholders for user-defined values."], "gold_sql": "SELECT T1.response_received_date FROM Documents AS T1 JOIN Document_Types AS T2 ON T1.document_type_code  =  T2.document_type_code JOIN Grants AS T3 ON T1.grant_id  =  T3.grant_id WHERE T2.document_description  =  'Regular' OR T3.grant_amount  >  100", "source_tables": ["grants", "document_types", "documents"], "description": "This virtual table retrieves the response received dates of documents from the 'Documents' table, joining with 'Document_Types' to filter by a specific document description and with 'Grants' to filter by grant amount. The placeholders in the WHERE clause represent the document description and the grant amount criteria.", "virtual_table": "SELECT T1.response_received_date FROM Documents AS T1 JOIN Document_Types AS T2 ON T1.document_type_code  =  T2.document_type_code JOIN Grants AS T3 ON T1.grant_id  =  T3.grant_id WHERE T2.document_description  =  [PLACEHOLDER-TYPE:STRING] OR T3.grant_amount  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4342", "db_id": "tracking_grants_for_research", "question": "When do all the researcher role staff start to work, and when do they stop working?", "rationale": ["The query identifies the relevant table, which is 'Project_Staff'.", "Select the columns to display, 'date_from' and 'date_to', which represent the involvement period of staff members.", "Add a condition to filter the 'role_code' column for the specified role using a placeholder for string values."], "gold_sql": "SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  'researcher'", "source_tables": ["project_staff"], "description": "This virtual table provides the start and end dates of staff members' involvement in projects from the 'Project_Staff' table, filtered by a specific role code. The placeholder in the WHERE clause represents the role of the staff member.", "virtual_table": "SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4350", "db_id": "tracking_grants_for_research", "question": "How many staff does each project has? List the project id and the number in an ascending order.", "rationale": ["The query identifies the relevant tables, which are 'Project_Staff' and 'Projects'.", "It selects the 'project_id' from 'Project_Staff' and counts the number of staff members associated with each project.", "The JOIN operation links 'Project_Staff' with 'Projects' based on the 'project_id'.", "The results are grouped by 'project_id' to aggregate the count of staff members for each project.", "Finally, the results are ordered in ascending order based on the count of staff members."], "gold_sql": "SELECT T1.project_id ,  count(*) FROM Project_Staff AS T1 JOIN Projects AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) ASC", "source_tables": ["project_staff", "projects"], "description": "This virtual table provides a count of staff members associated with each project from the 'Project_Staff' table, grouped by project ID. The results are ordered in ascending order based on the number of staff members per project.", "virtual_table": "SELECT T1.project_id ,  count(*) FROM Project_Staff AS T1 JOIN Projects AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) ASC"}
{"sample_id": "train.4364", "db_id": "tracking_grants_for_research", "question": "Which document type is described with the prefix 'Initial'?", "rationale": ["The query identifies the relevant table, which is 'Document_Types'.", "Select the column to display, 'document_type_code'.", "Add a condition to filter the 'document_description' column using a placeholder for string values."], "gold_sql": "SELECT document_type_code FROM Document_Types WHERE document_description LIKE 'Initial%'", "source_tables": ["document_types"], "description": "This virtual table retrieves the unique document type codes from the 'Document_Types' table based on a specific description of the document type. The placeholder in the WHERE clause allows for filtering the results according to the desired document description.", "virtual_table": "SELECT document_type_code FROM Document_Types WHERE document_description LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4386", "db_id": "tracking_grants_for_research", "question": "List the research staff details, and order in ascending order.", "rationale": ["The query identifies the relevant table, which is 'Research_Staff'.", "Select the column to display, 'staff_details'.", "Add an ORDER BY clause to sort the results in ascending order based on 'staff_details'."], "gold_sql": "SELECT staff_details FROM Research_Staff ORDER BY staff_details ASC", "source_tables": ["research_staff"], "description": "This virtual table provides a list of details about research staff members from the 'Research_Staff' table, sorted in ascending order. The placeholder in the ORDER BY clause indicates that the user can specify how they want to sort the staff details.", "virtual_table": "SELECT staff_details FROM Research_Staff ORDER BY staff_details ASC"}
{"sample_id": "train.4325", "db_id": "tracking_grants_for_research", "question": "What is the total amount of grant money for research?", "rationale": ["The query identifies the relevant tables: 'Grants', 'Organisations', and 'Organisation_Types'.", "It selects the sum of the 'grant_amount' from the 'Grants' table.", "The query joins 'Grants' with 'Organisations' on the 'organisation_id' to associate grants with their organisations.", "It further joins 'Organisations' with 'Organisation_Types' on 'organisation_type' to filter by organisation type.", "The WHERE clause uses a placeholder to specify the organisation type description for filtering the results."], "gold_sql": "SELECT sum(grant_amount) FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id JOIN organisation_Types AS T3 ON T2.organisation_type  =  T3.organisation_type WHERE T3.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations"], "description": "This virtual table calculates the total grant amount from the 'Grants' table for organisations of a specific type. It joins the 'Grants' table with the 'Organisations' table to link grants to their respective organisations, and further joins with the 'Organisation_Types' table to filter by the organisation type description. The placeholder in the WHERE clause represents the specific organisation type description being queried.", "virtual_table": "SELECT sum(grant_amount) FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id JOIN organisation_Types AS T3 ON T2.organisation_type  =  T3.organisation_type WHERE T3.organisation_type_description  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4353", "db_id": "tracking_grants_for_research", "question": "What is the complete description of the job of a researcher?", "rationale": ["The query identifies the relevant table, which is 'Staff_Roles'.", "Select the column to display, 'role_description'.", "Add a condition to filter the 'role_code' column for the specified role using a placeholder for string values."], "gold_sql": "SELECT role_description FROM Staff_Roles WHERE role_code  =  'researcher'", "source_tables": ["staff_roles"], "description": "This virtual table describes the role descriptions of staff members from the 'Staff_Roles' table based on a specific role code. The placeholder in the WHERE clause represents the role code being queried.", "virtual_table": "SELECT role_description FROM Staff_Roles WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4387", "db_id": "tracking_grants_for_research", "question": "What details are there on the research staff? List the result in ascending alphabetical order.", "rationale": ["The query identifies the relevant table, which is 'Research_Staff'.", "Select the column to display, 'staff_details'.", "Add an ORDER BY clause to sort the results in ascending order based on 'staff_details'."], "gold_sql": "SELECT staff_details FROM Research_Staff ORDER BY staff_details ASC", "source_tables": ["research_staff"], "description": "This virtual table provides a list of details about research staff members from the 'Research_Staff' table, sorted in ascending order. The placeholder in the ORDER BY clause indicates that the user can specify how they want to sort the staff details.", "virtual_table": "SELECT staff_details FROM Research_Staff ORDER BY staff_details ASC"}
{"sample_id": "train.4374", "db_id": "tracking_grants_for_research", "question": "How many Patent outcomes are generated from all the projects?", "rationale": ["The query identifies the relevant table, which is 'Project_Outcomes'.", "It selects a count of all records that match a specific condition.", "The condition filters the records based on the 'outcome_code' column using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM Project_outcomes WHERE outcome_code  =  'Patent'", "source_tables": ["project_outcomes"], "description": "This virtual table provides the count of project outcomes from the 'Project_Outcomes' table that match a specific outcome code. The placeholder in the WHERE clause represents the outcome code being queried.", "virtual_table": "SELECT count(*) FROM Project_outcomes WHERE outcome_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5873", "db_id": "tracking_share_transactions", "question": "Show the number of transactions with transaction type code \"SALE\" for different investors if it is larger than 0.", "rationale": ["The query identifies the relevant table, which is 'Transactions'.", "It selects the 'investor_id' and counts the number of transactions for each investor.", "A condition is added to filter the transactions based on the specified transaction type using a placeholder for string values.", "The results are grouped by 'investor_id' to aggregate the count of transactions per investor."], "gold_sql": "SELECT investor_id ,  COUNT(*) FROM TRANSACTIONS WHERE transaction_type_code  =  'SALE' GROUP BY investor_id", "source_tables": ["transactions"], "description": "This virtual table summarizes the number of transactions for each investor from the 'Transactions' table, filtered by a specific transaction type. The placeholder in the WHERE clause represents the transaction type code.", "virtual_table": "SELECT investor_id ,  COUNT(*) FROM TRANSACTIONS WHERE transaction_type_code  =  [PLACEHOLDER-TYPE:STRING] GROUP BY investor_id"}
{"sample_id": "train.5865", "db_id": "tracking_share_transactions", "question": "What are the lot details of lots associated with transactions whose share count is bigger than 100 and whose type code is \"PUR\"?", "rationale": ["The query identifies the relevant tables: 'Lots', 'Transactions_Lots', and 'Transactions'.", "It selects the 'lot_details' from the 'Lots' table.", "The JOIN operations link the 'Lots' table to the 'Transactions_Lots' table and then to the 'Transactions' table based on their respective identifiers.", "A condition is added to filter the results based on the 'share_count' and 'transaction_type_code', using placeholders for numeric and string values."], "gold_sql": "SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON  T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  >  100 AND T3.transaction_type_code  =  'PUR'", "source_tables": ["lots", "transactions_lots", "transactions"], "description": "This virtual table describes the details of lots associated with transactions that involve a specific number of shares and a particular type of transaction. The placeholders in the WHERE clause represent the minimum share count and the transaction type code.", "virtual_table": "SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON  T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  >  [PLACEHOLDER-TYPE:NUMBER] AND T3.transaction_type_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5876", "db_id": "tracking_share_transactions", "question": "Show the transaction type code that occurs the most frequently.", "rationale": ["The query identifies the relevant table, which is 'Transactions'.", "It selects the 'transaction_type_code' to display the unique types of transactions.", "The GROUP BY clause is used to group the results by 'transaction_type_code'.", "The ORDER BY clause sorts the results based on the count of each transaction type in descending order.", "The LIMIT clause restricts the number of results returned to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT transaction_type_code FROM TRANSACTIONS GROUP BY transaction_type_code ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["transactions"], "description": "This virtual table summarizes the different types of transactions recorded in the 'Transactions' table, grouping them by their unique transaction type codes. The results are ordered by the frequency of each transaction type, allowing users to see the most common transaction types up to a specified limit. The placeholder in the LIMIT clause represents the maximum number of transaction types to return.", "virtual_table": "SELECT transaction_type_code FROM TRANSACTIONS GROUP BY transaction_type_code ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5884", "db_id": "tracking_share_transactions", "question": "What are the details of the lots which are not used in any transactions?", "rationale": ["The query identifies the relevant table, which is 'Lots'.", "It selects the 'lot_details' column to display.", "The EXCEPT clause is used to exclude lot details that are linked to transactions, which are identified by joining the 'Lots' table with the 'Transactions_Lots' table on the 'lot_id' column."], "gold_sql": "SELECT lot_details FROM Lots EXCEPT SELECT T1.lot_details FROM Lots AS T1 JOIN transactions_lots AS T2 ON T1.lot_id  =  T2.lot_id", "source_tables": ["lots", "transactions_lots"], "description": "This virtual table provides the details of lots from the 'Lots' table that are not associated with any transactions. The query uses an EXCEPT clause to filter out lot details that are linked to transactions through the 'Transactions_Lots' table.", "virtual_table": "SELECT lot_details FROM Lots EXCEPT SELECT T1.lot_details FROM Lots AS T1 JOIN transactions_lots AS T2 ON T1.lot_id  =  T2.lot_id"}
{"sample_id": "train.5851", "db_id": "tracking_share_transactions", "question": "Show all dates of transactions whose type code is \"SALE\".", "rationale": ["The query identifies the relevant table, which is 'Transactions'.", "Select the column to display, 'date_of_transaction'.", "Add a condition to filter the 'transaction_type_code' column for the specified transaction type using a placeholder for string values."], "gold_sql": "SELECT date_of_transaction FROM TRANSACTIONS WHERE transaction_type_code  =  'SALE'", "source_tables": ["transactions"], "description": "This virtual table provides the dates of transactions from the 'Transactions' table that correspond to a specific type of transaction. The placeholder in the WHERE clause represents the transaction type code.", "virtual_table": "SELECT date_of_transaction FROM TRANSACTIONS WHERE transaction_type_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5485", "db_id": "voter_2", "question": "What are the first names and last names of the students who are 18 years old and have vice president votes.", "rationale": ["The query identifies the relevant tables, 'Student' and 'Voting_record'.", "It selects distinct first and last names from the 'Student' table.", "A join is performed between 'Student' and 'Voting_record' on the condition that the student's ID matches the vice president vote in the voting record.", "A condition is added to filter the results based on the specified age using a placeholder for numeric values."], "gold_sql": "SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_President_VOTE WHERE T1.age  =  18", "source_tables": ["student", "voting_record"], "description": "This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.", "virtual_table": "SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_President_VOTE WHERE T1.age  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5497", "db_id": "voter_2", "question": "What are the distinct last names of the students who have president votes but do not have 2192 as the advisor?", "rationale": ["The query identifies the relevant tables, 'Student' and 'Voting_record'.", "It selects distinct last names from the 'Student' table (aliased as T1) that are associated with the presidential votes in the 'Voting_record' table (aliased as T2).", "The JOIN condition links the 'StuID' from the 'Student' table to the 'President_Vote' in the 'Voting_record' table.", "The EXCEPT clause is used to exclude students who have a specific advisor, represented by a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote EXCEPT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  '2192'", "source_tables": ["student", "voting_record"], "description": "This virtual table provides a list of unique last names of students who voted for a presidential candidate, excluding those who have a specific academic advisor. The placeholders in the query represent the advisor's name.", "virtual_table": "SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote EXCEPT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5498", "db_id": "voter_2", "question": "Find the distinct last names of all the students who have president votes and whose advisor is 8741.", "rationale": ["The query identifies the relevant tables, 'Student' and 'Voting_record'.", "It selects distinct last names from the 'Student' table where the student has voted for a presidential candidate.", "The JOIN operation connects the 'Student' table with the 'Voting_record' table based on the condition that the student's ID matches the presidential vote.", "The INTERSECT operation ensures that only those students who are also advised by a specific advisor are included in the final result."], "gold_sql": "SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote INTERSECT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  '8741'", "source_tables": ["student", "voting_record"], "description": "This virtual table describes the last names of students who have voted for a presidential candidate and are being advised by a specific academic advisor. The placeholder in the WHERE clause represents the advisor's name.", "virtual_table": "SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote INTERSECT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5482", "db_id": "voter_2", "question": "Find the first and last names of all the female (sex is F) students who have president votes.", "rationale": ["The query identifies the relevant tables, 'Student' and 'Voting_record'.", "It selects distinct first and last names from the 'Student' table.", "A JOIN operation is performed between 'Student' and 'Voting_record' on the condition that the student's ID matches the presidential vote.", "A condition is added to filter the results based on the gender of the students using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.President_VOTE WHERE T1.sex  =  'F'", "source_tables": ["student", "voting_record"], "description": "This virtual table provides a list of distinct first and last names of students from the 'Student' table who have voted for a presidential candidate, filtered by their gender. The placeholder in the WHERE clause represents the gender of the students.", "virtual_table": "SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.President_VOTE WHERE T1.sex  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5484", "db_id": "voter_2", "question": "Find the first and last name of all the students of age 18 who have vice president votes.", "rationale": ["The query identifies the relevant tables, 'Student' and 'Voting_record'.", "It selects distinct first and last names from the 'Student' table.", "A join is performed between 'Student' and 'Voting_record' on the condition that the student's ID matches the vice president vote.", "A filter is applied to the 'age' column to only include students of a specified age using a placeholder for numeric values."], "gold_sql": "SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_President_VOTE WHERE T1.age  =  18", "source_tables": ["student", "voting_record"], "description": "This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.", "virtual_table": "SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_President_VOTE WHERE T1.age  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5483", "db_id": "voter_2", "question": "What are the first and last names of all the female students who have president votes?", "rationale": ["The query identifies the relevant tables, 'Student' and 'Voting_record'.", "It selects distinct first and last names from the 'Student' table.", "A JOIN operation is performed between 'Student' and 'Voting_record' on the condition that the student's ID matches the presidential vote.", "A condition is added to filter the results based on the gender of the students using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.President_VOTE WHERE T1.sex  =  'F'", "source_tables": ["student", "voting_record"], "description": "This virtual table provides a list of distinct first and last names of students who voted for the presidential candidate, filtered by their gender. The placeholder in the WHERE clause represents the gender of the students.", "virtual_table": "SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.President_VOTE WHERE T1.sex  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5465", "db_id": "voter_2", "question": "Return all the distinct secretary votes made in the fall election cycle.", "rationale": ["The query identifies the relevant table, which is 'Voting_record'.", "Select the column to display, 'Secretary_Vote', ensuring that only unique votes are retrieved using DISTINCT.", "Add a condition to filter the 'Election_Cycle' column for the specified election cycle using a placeholder for string values."], "gold_sql": "SELECT DISTINCT Secretary_Vote FROM VOTING_RECORD WHERE ELECTION_CYCLE  =  'Fall'", "source_tables": ["voting_record"], "description": "This virtual table provides a distinct list of votes cast for the secretary position from the 'Voting_record' table during a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.", "virtual_table": "SELECT DISTINCT Secretary_Vote FROM VOTING_RECORD WHERE ELECTION_CYCLE  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5478", "db_id": "voter_2", "question": "Find the distinct Advisor of students who have treasurer votes in the spring election cycle.", "rationale": ["The query identifies the relevant tables, 'Student' and 'Voting_record'.", "It selects the distinct 'Advisor' from the 'Student' table.", "A JOIN operation is performed on 'StuID' to link students with their voting records.", "A condition is added to filter the results based on the specified 'Election_Cycle' using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.Advisor FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Treasurer_Vote WHERE T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "description": "This virtual table provides a list of unique academic advisors for students who voted for a specific treasurer in a given election cycle. The placeholder in the WHERE clause represents the election cycle identifier.", "virtual_table": "SELECT DISTINCT T1.Advisor FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Treasurer_Vote WHERE T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5508", "db_id": "voter_2", "question": "Which major has the most students?", "rationale": ["The query identifies the relevant table, which is 'Student'.", "It selects the 'Major' column to display the different fields of study.", "The results are grouped by the 'Major' to aggregate the data based on the number of students in each major.", "The results are ordered by the count of students in each major in descending order to show the most popular majors first.", "A limit is applied to restrict the number of majors returned, using a placeholder for numeric values."], "gold_sql": "SELECT Major FROM STUDENT GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "description": "This virtual table provides a list of academic majors from the 'Student' table, grouped by the major field of study. The results are ordered by the number of students in each major in descending order, with a limit on the number of majors returned as specified by the placeholder.", "virtual_table": "SELECT Major FROM STUDENT GROUP BY major ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5490", "db_id": "voter_2", "question": "Find the average age of students who live in the city with code \"NYC\" and have secretary votes in the spring election cycle.", "rationale": ["The query identifies the relevant tables, 'Student' and 'Voting_record'.", "It selects the average age from the 'Student' table.", "A JOIN operation is performed on the 'StuID' to link students with their voting records, specifically filtering for those who voted for the secretary candidate.", "Conditions are added to filter students based on their city code and the election cycle using placeholders for string values."], "gold_sql": "SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.city_code  =  'NYC' AND T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "description": "This virtual table calculates the average age of students from the 'Student' table who voted for the secretary candidate in a specific election cycle. The placeholders in the WHERE clause represent the city code where the students reside and the election cycle identifier.", "virtual_table": "SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.city_code  =  [PLACEHOLDER-TYPE:STRING] AND T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5464", "db_id": "voter_2", "question": "What are the distinct secretary votes in the fall election cycle?", "rationale": ["The query identifies the relevant table, which is 'Voting_record'.", "Select the distinct values of the 'Secretary_Vote' column to avoid duplicates.", "Add a condition to filter the records based on the 'Election_Cycle' column using a placeholder for string values."], "gold_sql": "SELECT DISTINCT Secretary_Vote FROM VOTING_RECORD WHERE ELECTION_CYCLE  =  'Fall'", "source_tables": ["voting_record"], "description": "This virtual table provides a distinct list of votes cast for the secretary position from the 'Voting_record' table during a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.", "virtual_table": "SELECT DISTINCT Secretary_Vote FROM VOTING_RECORD WHERE ELECTION_CYCLE  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5487", "db_id": "voter_2", "question": "Count the number of male students who had class senator votes in the fall election cycle.", "rationale": ["The query identifies the relevant tables, which are 'Student' and 'Voting_record'.", "It performs a JOIN operation on the 'StuID' to link students with their voting records.", "The SELECT statement counts the total number of students that meet the specified criteria.", "Conditions are added to filter the results based on the student's gender and the election cycle using placeholders for string values."], "gold_sql": "SELECT count(*) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  Class_Senator_Vote WHERE T1.Sex  =  'M' AND T2.Election_Cycle  =  'Fall'", "source_tables": ["student", "voting_record"], "description": "This virtual table counts the number of students from the 'Student' table who are registered to vote in a specific election cycle and belong to a particular gender. The placeholders in the WHERE clause represent the gender of the students and the election cycle identifier.", "virtual_table": "SELECT count(*) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  Class_Senator_Vote WHERE T1.Sex  =  [PLACEHOLDER-TYPE:STRING] AND T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5477", "db_id": "voter_2", "question": "What are the distinct ages of students who have secretary votes in the fall election cycle?", "rationale": ["The query identifies the relevant tables, 'Student' and 'Voting_record'.", "It selects the distinct ages from the 'Student' table.", "A join is performed between 'Student' and 'Voting_record' on the condition that the student's ID matches the vote cast for the secretary candidate.", "A condition is added to filter the results based on the specified election cycle using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.Age FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Secretary_Vote WHERE T2.Election_Cycle  =  'Fall'", "source_tables": ["student", "voting_record"], "description": "This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.", "virtual_table": "SELECT DISTINCT T1.Age FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Secretary_Vote WHERE T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5493", "db_id": "voter_2", "question": "What is the average age of the female students with secretary votes in the spring election cycle?", "rationale": ["The query identifies the relevant tables, 'Student' and 'Voting_record'.", "It selects the average age from the 'Student' table.", "A JOIN is performed on the 'StuID' to link students with their voting records, specifically filtering for those who voted for the secretary candidate.", "Conditions are added to filter by the student's gender and the election cycle using placeholders for string values."], "gold_sql": "SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.Sex  =  'F' AND T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "description": "This virtual table calculates the average age of students from the 'Student' table who voted for a specific candidate in the 'Voting_record' table. The placeholders in the WHERE clause represent the gender of the students and the election cycle during which the votes were cast.", "virtual_table": "SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.Sex  =  [PLACEHOLDER-TYPE:STRING] AND T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5457", "db_id": "voter_2", "question": "List the major of each male student.", "rationale": ["The query identifies the relevant table, which is 'Student'.", "Select the column to display, 'Major'.", "Add a condition to filter the 'Sex' column for the specified gender using a placeholder for string values."], "gold_sql": "SELECT Major FROM STUDENT WHERE Sex  =  'M'", "source_tables": ["student"], "description": "This virtual table describes the field of study (Major) of students from the 'Student' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the students.", "virtual_table": "SELECT Major FROM STUDENT WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5475", "db_id": "voter_2", "question": "What are the distinct first names of the students who have class president votes?", "rationale": ["The query identifies the relevant tables, which are 'Student' and 'Voting_record'.", "It selects the distinct first names from the 'Student' table.", "A join is performed between 'Student' and 'Voting_record' on the condition that the 'StuID' from 'Student' matches the 'Class_Senator_Vote' in 'Voting_record', ensuring that only students who voted for the class senator are included."], "gold_sql": "SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.CLASS_Senator_VOTE", "source_tables": ["student", "voting_record"], "description": "This virtual table describes the distinct first names of students who have voted for the class senator. The query joins the 'Student' table with the 'Voting_record' table based on the student identifier, ensuring that only those students who participated in the voting for class senator are included.", "virtual_table": "SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.CLASS_Senator_VOTE"}
{"sample_id": "train.6582", "db_id": "wine_1", "question": "What are the countries for appelations with at most 3 wines?", "rationale": ["The query identifies the relevant tables, which are 'appellations' and 'wine'.", "It selects the 'County' column from the 'appellations' table.", "The query performs a JOIN operation between 'appellations' and 'wine' on the 'Appelation' column to link the two tables.", "It groups the results by the 'Appelation' to aggregate the data based on the number of wines.", "The HAVING clause is used to filter the grouped results to include only those with a count of wines less than or equal to the specified number using a placeholder for numeric values."], "gold_sql": "SELECT T1.County FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation GROUP BY T2.Appelation HAVING count(*)  <=  3", "source_tables": ["wine", "appellations"], "description": "This virtual table provides a list of counties from the 'appellations' table that are associated with a specific number of wines produced, as indicated by the placeholder. The query joins the 'appellations' and 'wine' tables on the appellation name, groups the results by appellation, and filters the groups to include only those with a count of wines less than or equal to the specified number.", "virtual_table": "SELECT T1.County FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation GROUP BY T2.Appelation HAVING count(*)  <=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6598", "db_id": "wine_1", "question": "What is the county that produces the most wines scoring higher than 90?", "rationale": ["The query identifies the relevant tables, 'appellations' and 'wine', and establishes a join condition based on the 'Appelation' column.", "It selects the 'County' from the 'appellations' table.", "A condition is added to filter wines based on their 'Score' using a placeholder for numeric values.", "The results are grouped by 'County' to aggregate the data accordingly.", "The results are ordered by the count of wines in descending order to highlight the counties with the most high-scoring wines.", "A limit is applied to restrict the number of counties returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.County FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T2.Score  >  90 GROUP BY T1.County ORDER BY count(*) DESC LIMIT 1", "source_tables": ["wine", "appellations"], "description": "This virtual table provides a list of counties where wines have received a score above a specified threshold. The results are grouped by county and ordered by the number of wines that meet the score criteria, allowing users to identify the most prolific counties for high-scoring wines. The placeholders in the WHERE clause and LIMIT clause represent the score threshold and the maximum number of counties to return, respectively.", "virtual_table": "SELECT T1.County FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T2.Score  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.County ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6587", "db_id": "wine_1", "question": "Find the top 3 wineries with the greatest number of wines made of white color grapes.", "rationale": ["The query identifies the relevant tables, which are 'grapes' and 'wine'.", "It selects the 'Winery' column from the 'wine' table.", "A join is performed between 'grapes' and 'wine' on the grape variety to link the two tables.", "A condition is added to filter the results based on the specified grape color using a placeholder for string values.", "The results are grouped by winery name to aggregate the data.", "The results are ordered by the count of wines produced, in descending order, to show the most prolific wineries first.", "A limit is applied to restrict the number of wineries returned, using a placeholder for numeric values."], "gold_sql": "SELECT T2.Winery FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.GRAPE  =  T2.GRAPE WHERE T1.Color  =  'White' GROUP BY T2.Winery ORDER BY count(*) DESC LIMIT 3", "source_tables": ["wine", "grapes"], "description": "This virtual table lists the names of wineries that produce wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filters the results by the specified grape color, groups the results by winery name, and orders them by the number of wines produced, limiting the output to a specified number of wineries.", "virtual_table": "SELECT T2.Winery FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.GRAPE  =  T2.GRAPE WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T2.Winery ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6548", "db_id": "wine_1", "question": "Find the white grape used to produce wines with scores above 90.", "rationale": ["The query identifies the relevant tables, which are 'grapes' and 'wine'.", "It selects distinct grape varieties from the 'grapes' table.", "A JOIN operation is performed between 'grapes' and 'wine' on the grape variety to filter the results based on the specified conditions.", "The WHERE clause includes a condition to filter by grape color using a placeholder for string values and a condition to filter by wine score using a placeholder for numeric values."], "gold_sql": "SELECT DISTINCT T1.Grape FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'White' AND T2.score  >  90", "source_tables": ["wine", "grapes"], "description": "This virtual table lists distinct grape varieties from the 'grapes' table that have a specific color and are associated with wines that have a score above a certain threshold. The placeholders in the WHERE clause represent the color of the grape and the minimum score for the wine.", "virtual_table": "SELECT DISTINCT T1.Grape FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING] AND T2.score  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6543", "db_id": "wine_1", "question": "What are the names and scores of wines that are made of white color grapes?", "rationale": ["The query identifies the relevant tables, which are 'grapes' and 'wine'.", "It selects the columns to display, 'Name' and 'Score' from the 'wine' table.", "A join is performed between 'grapes' and 'wine' on the 'Grape' column to link the two tables.", "A condition is added to filter the 'Color' column in the 'grapes' table using a placeholder for string values."], "gold_sql": "SELECT T2.Name ,   T2.Score FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'White'", "source_tables": ["wine", "grapes"], "description": "This virtual table provides the names and scores of wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filtering the results to include only those grapes that match the specified color.", "virtual_table": "SELECT T2.Name ,   T2.Score FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6549", "db_id": "wine_1", "question": "What are the wines that have prices higher than 50 and made of Red color grapes?", "rationale": ["The query identifies the relevant tables, which are 'Grapes' and 'Wine'.", "It selects the 'Name' column from the 'Wine' table.", "A JOIN operation is performed between 'Grapes' and 'Wine' on the 'Grape' column to link the two tables based on grape variety.", "Conditions are added to filter the results based on the specified grape color and price using placeholders for string and numeric values."], "gold_sql": "SELECT T2.Name FROM Grapes AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'Red' AND T2.price  >  50", "source_tables": ["wine", "grapes"], "description": "This virtual table describes the names of wines made from grape varieties of a specific color and priced above a certain amount. The placeholders in the WHERE clause represent the grape color and the price threshold.", "virtual_table": "SELECT T2.Name FROM Grapes AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING] AND T2.price  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6534", "db_id": "wine_1", "question": "What are the names of wines made from red grapes?", "rationale": ["The query identifies the relevant tables, which are 'grapes' and 'wine'.", "It uses a JOIN operation to connect the two tables based on the grape variety.", "The SELECT DISTINCT clause is used to ensure that only unique wine names are returned.", "A condition is added to filter the grape color using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T2.Name FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'Red'", "source_tables": ["wine", "grapes"], "description": "This virtual table lists the distinct names of wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filtering the results to include only those grapes that match the specified color.", "virtual_table": "SELECT DISTINCT T2.Name FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6551", "db_id": "wine_1", "question": "What are the wines that have prices lower than 50 and have appelations in Monterey county?", "rationale": ["The query identifies the relevant tables, which are 'appellations' and 'wine'.", "It uses a JOIN operation to combine data from both tables based on the matching 'Appelation' column.", "The SELECT statement specifies that only the 'Name' of the wine should be returned.", "Conditions are added to filter the results based on the specified county and the price of the wine using placeholders for string and numeric values."], "gold_sql": "SELECT T2.Name FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T1.County  =  'Monterey' AND T2.price  <  50", "source_tables": ["wine", "appellations"], "description": "This virtual table lists the names of wines produced in a specific county, filtered by a price threshold. The placeholders in the WHERE clause represent the county name and the maximum price of the wine.", "virtual_table": "SELECT T2.Name FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T1.County  =  [PLACEHOLDER-TYPE:STRING] AND T2.price  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6519", "db_id": "wine_1", "question": "Which winery is the wine that has the highest score from?", "rationale": ["The query identifies the relevant table, which is 'wine'.", "Select the column to display, 'Winery'.", "Order the results by the 'Score' column to prioritize higher-rated wineries.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT Winery FROM WINE ORDER BY SCORE LIMIT 1", "source_tables": ["wine"], "description": "This virtual table lists the names of wineries from the 'wine' table, ordered by their rating scores. The placeholder in the LIMIT clause represents the maximum number of wineries to be displayed.", "virtual_table": "SELECT Winery FROM WINE ORDER BY SCORE LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6562", "db_id": "wine_1", "question": "What are the names of wines, sorted by price ascending?", "rationale": ["The query is identifying the relevant table, which is 'wine'.", "Select the distinct column to display, 'Name', to ensure each wine name appears only once.", "Add an ORDER BY clause to sort the results based on the 'Price' column, which is a string value."], "gold_sql": "SELECT DISTINCT Name FROM WINE ORDER BY price", "source_tables": ["wine"], "description": "This virtual table lists the distinct names of wines from the 'wine' table, ordered by their retail price. The placeholder in the ORDER BY clause represents the price of the wines.", "virtual_table": "SELECT DISTINCT Name FROM WINE ORDER BY price"}
{"sample_id": "train.6560", "db_id": "wine_1", "question": "What are the names of wines, sorted in alphabetical order?", "rationale": ["The query identifies the relevant table, which is 'wine'.", "It selects the 'Name' column to display the names of the wines.", "The DISTINCT keyword is used to ensure that only unique wine names are returned.", "The ORDER BY clause is applied to sort the results alphabetically by the wine name."], "gold_sql": "SELECT DISTINCT Name FROM WINE ORDER BY Name", "source_tables": ["wine"], "description": "This virtual table lists the distinct names of wines from the 'wine' table, sorted in alphabetical order. The query uses the DISTINCT keyword to ensure that each wine name appears only once in the result set, and the ORDER BY clause organizes the names in ascending order.", "virtual_table": "SELECT DISTINCT Name FROM WINE ORDER BY Name"}
{"sample_id": "train.6531", "db_id": "wine_1", "question": "List the names of all distinct wines that have scores higher than 90.", "rationale": ["The query is identifying the relevant table, which is 'wine'.", "Select the column to display, 'Name'.", "Add a condition to filter the 'Score' column for wines that have a score greater than the specified threshold using a placeholder for numeric values."], "gold_sql": "SELECT Name FROM WINE WHERE score  >  90", "source_tables": ["wine"], "description": "This virtual table describes the names of wines from the 'wine' table that have a score higher than a specified value. The placeholder in the WHERE clause represents the minimum score threshold for filtering the wines.", "virtual_table": "SELECT Name FROM WINE WHERE score  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.818", "db_id": "world_1", "question": "What is the total number of countries where Spanish is spoken by the largest percentage of people?", "rationale": ["The query identifies the relevant table, which is 'countrylanguage'.", "It selects the count of countries and the maximum percentage of speakers for the specified language.", "The WHERE clause filters the results based on the specified language using a placeholder for string values.", "The results are grouped by 'CountryCode' to provide the count and maximum percentage for each country."], "gold_sql": "SELECT count(*) ,   max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  'Spanish' GROUP BY CountryCode", "source_tables": ["countrylanguage"], "description": "This virtual table provides the count of countries and the maximum percentage of speakers for a specific language from the 'countrylanguage' table. The placeholder in the WHERE clause represents the language name.", "virtual_table": "SELECT count(*) ,   max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING] GROUP BY CountryCode"}
{"sample_id": "dev.774", "db_id": "world_1", "question": "What are the African countries that have a  population less than any country in Asia?", "rationale": ["The query identifies the relevant table, which is 'country'.", "It selects the 'Name' column to display the names of the countries.", "A condition is added to filter countries based on the specified continent using a placeholder for string values.", "Another condition is included to ensure the population of the country is less than the maximum population of any country in the same continent, which is determined by a subquery."], "gold_sql": "SELECT Name FROM country WHERE Continent  =  'Africa'  AND population  <  (SELECT max(population) FROM country WHERE Continent  =  'Asia')", "source_tables": ["country"], "description": "This virtual table lists the names of countries from the 'country' table that are located in a specific continent and have a population less than the maximum population of any country within the same continent. The placeholders in the WHERE clause represent the continent's name.", "virtual_table": "SELECT Name FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING]  AND population  <  (SELECT max(population) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING])"}
