{"sample_id": "train.3672", "db_id": "baseball_1", "question": "For each year, return the year and the number of times the team Boston Red Stockings won in the postseasons.", "rationale": ["The query identifies the relevant tables, 'postseason' and 'team'.", "It selects the count of wins and the year from the 'postseason' table.", "A JOIN is performed between 'postseason' and 'team' on the winning team identifier.", "A condition is added to filter results based on the specified team name using a placeholder for string values.", "The results are grouped by year to provide a count of wins per year."], "gold_sql": "SELECT count(*) ,  T1.year FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' GROUP BY T1.year", "source_tables": ["postseason", "team"], "description": "This virtual table provides the count of postseason wins for a specific team across different years. The placeholder in the WHERE clause represents the name of the team for which the postseason wins are being queried.", "virtual_table": "SELECT count(*) ,  T1.year FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.year"}
{"sample_id": "train.3677", "db_id": "baseball_1", "question": "What is the total salary paid by team Boston Red Stockings in 2010?", "rationale": ["The query identifies the relevant tables, 'salary' and 'team'.", "It selects the sum of salaries from the 'salary' table (aliased as T1).", "A join is performed between the 'salary' table and the 'team' table on the team_id to link salary records to the respective teams.", "Conditions are added to filter the results based on the specified team name and year using placeholders for string and numeric values."], "gold_sql": "SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings' AND T1.year  =  2010", "source_tables": ["team", "salary"], "description": "This virtual table calculates the total salary of players from a specific team for a given year. The placeholders represent the team's name and the year for which the salary data is being queried.", "virtual_table": "SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3681", "db_id": "baseball_1", "question": "List the 3 highest salaries of the players in 2001?", "rationale": ["The query identifies the relevant table, which is 'salary'.", "Select the 'salary' column to display the salary amounts.", "Add a condition to filter the records for a specific year using a placeholder for numeric values.", "Sort the results in descending order based on salary.", "Limit the number of records returned using a placeholder for numeric values."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2001 ORDER BY salary DESC LIMIT 3;", "source_tables": ["salary"], "description": "This virtual table provides the salary records from the 'salary' table for a specific year, sorted in descending order. The placeholders represent the year for which the salary data is requested and the limit on the number of records to return.", "virtual_table": "SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY salary DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3682", "db_id": "baseball_1", "question": "How much salary did the top 3 well-paid players get in 2001?", "rationale": ["The query identifies the relevant table, which is 'salary'.", "It selects the 'salary' column to display the salary amounts.", "A condition is added to filter the records for a specific year using a placeholder for numeric values.", "The results are ordered by salary in descending order to show the highest salaries first.", "A limit is applied to restrict the number of records returned, using a placeholder for numeric values."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2001 ORDER BY salary DESC LIMIT 3;", "source_tables": ["salary"], "description": "This virtual table provides the salary records from the 'salary' table for a specific year, sorted in descending order. The placeholders represent the year for which the salary data is requested and the limit on the number of records to return.", "virtual_table": "SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY salary DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3683", "db_id": "baseball_1", "question": "What were all the salary values of players in 2010 and 2001?", "rationale": ["The query identifies the relevant table, which is 'salary'.", "It selects the 'salary' column to display the salary amounts.", "The WHERE clause filters the records for two specific years using placeholders for numeric values.", "The UNION operator combines the results from both years into a single result set."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2010 UNION SELECT salary FROM salary WHERE YEAR  =  2001", "source_tables": ["salary"], "description": "This virtual table retrieves the salary records for players in two specific years from the 'salary' table. The placeholders represent the years for which the salary data is being queried.", "virtual_table": "SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3685", "db_id": "baseball_1", "question": "In which year did the least people enter hall of fame?", "rationale": ["The query identifies the relevant table, which is 'hall_of_fame'.", "It selects the 'yearid' column to display the years of induction.", "The results are grouped by 'yearid' to aggregate the data by year.", "The results are ordered by the count of inductees in ascending order to show the years with fewer inductees first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT 1;", "source_tables": ["hall_of_fame"], "description": "This virtual table provides a list of years in which players were inducted into the Hall of Fame, grouped by year. The results are ordered by the number of inductees in ascending order, with a limit set by a placeholder for numeric values to specify how many years to return.", "virtual_table": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3686", "db_id": "baseball_1", "question": "Find the year in which the least people enter hall of fame.", "rationale": ["The query identifies the relevant table, which is 'hall_of_fame'.", "It selects the 'yearid' column to display the years of induction.", "The results are grouped by 'yearid' to aggregate the data for each year.", "The results are ordered by the count of inductees in ascending order to show the years with fewer inductees first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT 1;", "source_tables": ["hall_of_fame"], "description": "This virtual table provides a list of years in which players were inducted into the Hall of Fame, grouped by year. The results are ordered by the number of inductees in ascending order, with a limit set by a placeholder for numeric values.", "virtual_table": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3689", "db_id": "baseball_1", "question": "How many games were played in park \"Columbia Park\" in 1907?", "rationale": ["The query identifies the relevant tables, 'home_game' and 'park'.", "It uses a JOIN operation to connect these tables based on the park identifier.", "The SELECT statement counts the total number of home games.", "The WHERE clause filters the results by the specified year and park name using placeholders for numeric and string values."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 1907 AND T2.park_name = 'Columbia Park';", "source_tables": ["park", "home_game"], "description": "This virtual table provides the total count of home games played in a specific year at a designated park. The placeholders represent the year of the games and the name of the park.", "virtual_table": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T2.park_name = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.3690", "db_id": "baseball_1", "question": "Count the number of games taken place in park \"Columbia Park\" in 1907.", "rationale": ["The query identifies the relevant tables, 'home_game' and 'park'.", "It uses a JOIN operation to connect these tables based on the park identifier.", "The SELECT statement counts the total number of home games.", "The WHERE clause filters the results by the specified year and park name using placeholders for numeric and string values."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 1907 AND T2.park_name = 'Columbia Park';", "source_tables": ["park", "home_game"], "description": "This virtual table provides the total count of home games played in a specific year at a designated park. The placeholders represent the year of the games and the name of the park.", "virtual_table": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T2.park_name = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.3691", "db_id": "baseball_1", "question": "How many games were played in city Atlanta in 2000?", "rationale": ["The query identifies the relevant tables, 'home_game' and 'park'.", "It selects the count of home games by using the count(*) function.", "A JOIN operation is performed between 'home_game' and 'park' on the park_id to link the games to their respective parks.", "A WHERE clause is added to filter the results based on the specified year and city, using placeholders for the year and city values."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year  =  2000 AND T2.city  =  'Atlanta';", "source_tables": ["park", "home_game"], "description": "This virtual table provides the total count of home games played in a specific year at parks located in a specified city. The placeholders represent the year of the home games and the city where the park is situated.", "virtual_table": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] AND T2.city  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.3692", "db_id": "baseball_1", "question": "Find the number of games taken place in city Atlanta in 2000.", "rationale": ["The query identifies the relevant tables, 'home_game' and 'park'.", "It selects the count of home games by using the count(*) function.", "A JOIN operation is performed between 'home_game' and 'park' on the park_id to link the games with their respective parks.", "A WHERE clause is added to filter the results based on the specified year and city, using placeholders for the year and city values."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year  =  2000 AND T2.city  =  'Atlanta';", "source_tables": ["park", "home_game"], "description": "This virtual table provides the total count of home games played in a specific year at parks located in a specified city. The placeholders represent the year of the home games and the city where the park is situated.", "virtual_table": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] AND T2.city  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.3693", "db_id": "baseball_1", "question": "What is the total home game attendance of team Boston Red Stockings from 2000 to 2010?", "rationale": ["The query identifies the relevant tables, 'home_game' and 'team'.", "It selects the sum of the 'attendance' column from the 'home_game' table.", "A join is performed between 'home_game' and 'team' on the 'team_id_br' to link the attendance data to the specific team.", "A condition is added to filter by the team's name using a placeholder for string values.", "Another condition is included to filter the years using placeholders for numeric values."], "gold_sql": "SELECT sum(T1.attendance) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' AND T1.year BETWEEN 2000 AND 2010;", "source_tables": ["team", "home_game"], "description": "This virtual table calculates the total attendance for home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the attendance data.", "virtual_table": "SELECT sum(T1.attendance) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3698", "db_id": "baseball_1", "question": "What are the first name and last name of the players who were paid salary by team Washington Nationals in both 2005 and 2007?", "rationale": ["The query identifies the relevant tables: 'salary', 'player', and 'team'.", "It selects the 'name_first' and 'name_last' columns from the 'player' table.", "The query joins the 'salary' table with the 'player' table using 'player_id' to link salary records to players.", "It also joins the 'team' table using 'team_id_br' to filter players based on the team they were associated with.", "The WHERE clause includes placeholders for the year and team name to filter the results accordingly."], "gold_sql": "SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2005 AND T3.name = 'Washington Nationals' INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2007 AND T3.name = 'Washington Nationals'", "source_tables": ["team", "player", "salary"], "description": "This virtual table retrieves the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the WHERE clause represent the year and the team's name.", "virtual_table": "SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3702", "db_id": "baseball_1", "question": "Find the team that attended the least number of home games in 1980.", "rationale": ["The query identifies the relevant tables, 'home_game' and 'team'.", "It selects the 'name' column from the 'team' table, which contains the names of the teams.", "A JOIN operation is performed between 'home_game' and 'team' on the 'team_id' to link home games with their respective teams.", "A condition is added to filter the results based on the specified year using a placeholder for numeric values.", "The results are ordered by the 'attendance' column in ascending order and limited to a specified number of results using placeholders."], "gold_sql": "SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = 1980 ORDER BY T1.attendance ASC LIMIT 1;", "source_tables": ["team", "home_game"], "description": "This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.", "virtual_table": "SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3709", "db_id": "baseball_1", "question": "Which park had most attendances in 2008?", "rationale": ["The query identifies the relevant tables, 'home_game' and 'park'.", "It selects the 'park_name' from the 'park' table.", "A join is performed between 'home_game' and 'park' on the 'park_id' to link home games to their respective parks.", "A condition is added to filter the results for a specific year using a placeholder for numeric values.", "The results are ordered by attendance in descending order and limited to a specified number using placeholders."], "gold_sql": "SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 2008 ORDER BY T1.attendance DESC LIMIT 1;", "source_tables": ["park", "home_game"], "description": "This virtual table provides a list of park names where home games were played in a specific year, ordered by attendance in descending order. The placeholders represent the year of the home games and the limit on the number of park names to return.", "virtual_table": "SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3857", "db_id": "insurance_policies", "question": "Find the settlement amount of the claim with the largest claim amount. Show both the settlement amount and claim amount.", "rationale": ["The query identifies the relevant table, which is 'Claims'.", "Selects the columns 'Amount_Settled' and 'Amount_Claimed' to display the financial details of the claims.", "Orders the results by 'Amount_Claimed' in descending order to show the highest claims first.", "Includes a limit on the number of records returned, using a placeholder for numeric values."], "gold_sql": "SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Claimed DESC LIMIT 1", "source_tables": ["claims"], "description": "This virtual table provides a summary of the amounts claimed and settled for insurance claims from the 'Claims' table. The results are ordered by the claimed amount in descending order, and the placeholder allows for limiting the number of records returned.", "virtual_table": "SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Claimed DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3862", "db_id": "insurance_policies", "question": "Among all the claims, which settlements have a claimed amount that is no more than the average? List the claim start date.", "rationale": ["The query identifies the relevant table, which is 'Claims'.", "Select the column 'Date_Claim_Made' to display the dates of claims.", "Add a condition to filter the claims where 'Amount_Settled' is less than or equal to the average settled amount, using a subquery to calculate the average settled amount from the 'Claims' table."], "gold_sql": "SELECT Date_Claim_Made FROM Claims WHERE Amount_Settled  <=  ( SELECT avg(Amount_Settled) FROM Claims )", "source_tables": ["claims"], "description": "This virtual table provides the dates when claims were made for those claims that have a settled amount less than or equal to the average settled amount across all claims. The placeholder in the subquery represents the average amount settled for comparison.", "virtual_table": "SELECT Date_Claim_Made FROM Claims WHERE Amount_Settled  <=  ( SELECT avg(Amount_Settled) FROM Claims )"}
{"sample_id": "train.3863", "db_id": "insurance_policies", "question": "Return the claim start date for the claims whose claimed amount is no more than the average", "rationale": ["The query identifies the relevant table, which is 'Claims'.", "It selects the 'Date_Claim_Made' column to display the dates of claims.", "A condition is added to filter claims where 'Amount_Settled' is less than or equal to the average settled amount, which is calculated using a subquery that selects the average from the 'Amount_Settled' column in the 'Claims' table."], "gold_sql": "SELECT Date_Claim_Made FROM Claims WHERE Amount_Settled  <=  ( SELECT avg(Amount_Settled) FROM Claims )", "source_tables": ["claims"], "description": "This virtual table provides the dates when claims were made for those claims that have a settled amount less than or equal to the average settled amount across all claims. The placeholder in the subquery represents the average settled amount calculated from the Claims table.", "virtual_table": "SELECT Date_Claim_Made FROM Claims WHERE Amount_Settled  <=  ( SELECT avg(Amount_Settled) FROM Claims )"}
{"sample_id": "train.3868", "db_id": "insurance_policies", "question": "How many settlements were made on the claim with the most recent claim settlement date? List the number and the claim id.", "rationale": ["The query identifies the relevant tables, which are 'Claims' and 'Settlements'.", "It selects the count of claims and the claim ID from the 'Claims' table.", "A JOIN operation is performed on the claim ID to link claims with their corresponding settlements.", "The results are grouped by the claim ID to aggregate the count of claims for each unique claim.", "The results are ordered by the date the claims were settled in descending order to show the most recent settlements first.", "A placeholder is included in the LIMIT clause to allow the user to specify how many results they want to retrieve."], "gold_sql": "SELECT count(*) ,  T1.claim_id FROM Claims AS T1 JOIN Settlements AS T2 ON T1.claim_id  =  T2.claim_id GROUP BY T1.claim_id ORDER BY T1.Date_Claim_Settled DESC LIMIT 1", "source_tables": ["claims", "settlements"], "description": "This virtual table provides a count of claims along with their unique identifiers from the 'Claims' table, joined with the 'Settlements' table. The results are grouped by the claim ID and ordered by the date the claims were settled in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.", "virtual_table": "SELECT count(*) ,  T1.claim_id FROM Claims AS T1 JOIN Settlements AS T2 ON T1.claim_id  =  T2.claim_id GROUP BY T1.claim_id ORDER BY T1.Date_Claim_Settled DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3869", "db_id": "insurance_policies", "question": "Find the claim id and the number of settlements made for the claim with the most recent settlement date.", "rationale": ["The query identifies the relevant tables, which are 'Claims' and 'Settlements'.", "It selects the count of claims and the claim ID from the 'Claims' table.", "A JOIN operation is performed on the claim ID to link claims with their corresponding settlements.", "The results are grouped by the claim ID to aggregate the count of claims for each unique claim.", "The results are ordered by the date the claims were settled in descending order to show the most recent settlements first.", "A placeholder is included in the LIMIT clause to allow the user to specify how many results they want to retrieve."], "gold_sql": "SELECT count(*) ,  T1.claim_id FROM Claims AS T1 JOIN Settlements AS T2 ON T1.claim_id  =  T2.claim_id GROUP BY T1.claim_id ORDER BY T1.Date_Claim_Settled DESC LIMIT 1", "source_tables": ["claims", "settlements"], "description": "This virtual table provides a count of claims along with their unique identifiers from the 'Claims' table, joined with the 'Settlements' table. The results are grouped by the claim ID and ordered by the date the claims were settled in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.", "virtual_table": "SELECT count(*) ,  T1.claim_id FROM Claims AS T1 JOIN Settlements AS T2 ON T1.claim_id  =  T2.claim_id GROUP BY T1.claim_id ORDER BY T1.Date_Claim_Settled DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3878", "db_id": "insurance_policies", "question": "What is the most popular payment method?", "rationale": ["The query identifies the relevant table, which is 'Payments'.", "It selects the 'Payment_Method_Code' column to display the different payment methods.", "The results are grouped by 'Payment_Method_Code' to aggregate the data based on unique payment methods.", "The results are ordered by the count of each payment method in descending order to show the most frequently used methods first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["payments"], "description": "This virtual table provides a summary of the different payment methods used in the 'Payments' table, grouped by the payment method code. The results are ordered by the frequency of each payment method, allowing users to see the most commonly used methods. The placeholder in the LIMIT clause represents the maximum number of payment methods to return.", "virtual_table": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3879", "db_id": "insurance_policies", "question": "Which payment method is used the most often?", "rationale": ["The query identifies the relevant table, which is 'Payments'.", "It selects the 'Payment_Method_Code' column to display the different payment methods.", "The query groups the results by 'Payment_Method_Code' to aggregate the data based on unique payment methods.", "It orders the results by the count of each payment method in descending order to show the most frequently used methods first.", "The LIMIT clause uses a placeholder to allow the user to specify how many payment methods they want to retrieve."], "gold_sql": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["payments"], "description": "This virtual table provides a summary of the different payment methods used in the 'Payments' table, grouped by the payment method code. The placeholder in the LIMIT clause allows the user to specify the maximum number of payment methods to retrieve, sorted by the frequency of their usage in descending order.", "virtual_table": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3880", "db_id": "insurance_policies", "question": "With which kind of payment method were the least number of payments processed?", "rationale": ["The query identifies the relevant table, which is 'Payments'.", "It selects the 'Payment_Method_Code' column to display unique payment methods.", "The GROUP BY clause is used to group the results by 'Payment_Method_Code'.", "The ORDER BY clause sorts the grouped results by their count in ascending order.", "The LIMIT clause uses a placeholder to allow the user to specify how many unique payment methods they want to retrieve."], "gold_sql": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) ASC LIMIT 1", "source_tables": ["payments"], "description": "This virtual table provides a list of unique payment method codes used in the 'Payments' table, grouped by the payment method code and ordered by the frequency of each method in ascending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of payment methods to retrieve.", "virtual_table": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3886", "db_id": "insurance_policies", "question": "Which kind of policy type was chosen by the most customers?", "rationale": ["The query identifies the relevant table, which is 'Customer_Policies'.", "It selects the 'Policy_Type_Code' to display the different types of insurance policies.", "The GROUP BY clause is used to group the results by 'Policy_Type_Code'.", "The ORDER BY clause sorts the grouped results by their count in descending order to show the most common policy types first.", "The LIMIT clause includes a placeholder to allow the user to specify how many policy types they want to retrieve."], "gold_sql": "SELECT Policy_Type_Code FROM Customer_Policies GROUP BY Policy_Type_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customer_policies"], "description": "This virtual table summarizes the different types of insurance policies from the 'Customer_Policies' table, grouping them by their policy type code. The placeholder in the LIMIT clause allows the user to specify the maximum number of policy types to retrieve, sorted by the frequency of each type in descending order.", "virtual_table": "SELECT Policy_Type_Code FROM Customer_Policies GROUP BY Policy_Type_Code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3893", "db_id": "insurance_policies", "question": "Which customers do not have any policies? Find the details of these customers.", "rationale": ["The query identifies the relevant table, which is 'Customers'.", "It selects the 'customer_details' column to display.", "The EXCEPT clause is used to exclude customer details that are linked to any policies by joining 'Customers' with 'Customer_Policies' on 'Customer_ID' to filter out those customers."], "gold_sql": "SELECT customer_details FROM Customers EXCEPT SELECT T1.customer_details FROM Customers AS T1 JOIN Customer_Policies AS T2 ON T1.customer_id  =  T2.customer_id", "source_tables": ["customer_policies", "customers"], "description": "This virtual table provides a list of customer details from the 'Customers' table, excluding those customers who have associated insurance policies. The query uses an EXCEPT clause to filter out customers that are linked to any policies in the 'Customer_Policies' table.", "virtual_table": "SELECT customer_details FROM Customers EXCEPT SELECT T1.customer_details FROM Customers AS T1 JOIN Customer_Policies AS T2 ON T1.customer_id  =  T2.customer_id"}
{"sample_id": "train.3895", "db_id": "insurance_policies", "question": "Which claims had exactly one settlement? For each, tell me the the date the claim was made, the date it was settled and the amount settled.", "rationale": ["The query identifies the relevant tables, which are 'Claims' and 'Settlements'.", "It selects the columns to display: 'claim_id', 'date_claim_made', and 'Date_Claim_Settled' from the 'Claims' table.", "A JOIN operation is performed to link claims with their corresponding settlements based on the 'Claim_id'.", "The results are grouped by 'claim_id' to aggregate the data for each claim.", "The HAVING clause is used to filter the results based on the count of settlements associated with each claim, using a placeholder for numeric values."], "gold_sql": "SELECT T1.claim_id ,  T1.date_claim_made ,  T1.Date_Claim_Settled FROM Claims AS T1 JOIN Settlements AS T2 ON T1.Claim_id  =  T2.Claim_id GROUP BY T1.claim_id HAVING count(*)  =  1", "source_tables": ["claims", "settlements"], "description": "This virtual table provides a summary of claims from the 'Claims' table that have been linked to settlements in the 'Settlements' table. It displays the claim ID, the date the claim was made, and the date the claim was settled. The placeholder in the HAVING clause represents the number of settlements associated with each claim, allowing users to filter claims based on their settlement count.", "virtual_table": "SELECT T1.claim_id ,  T1.date_claim_made ,  T1.Date_Claim_Settled FROM Claims AS T1 JOIN Settlements AS T2 ON T1.Claim_id  =  T2.Claim_id GROUP BY T1.claim_id HAVING count(*)  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3898", "db_id": "hospital_1", "question": "Which department has the largest number of employees?", "rationale": ["The query identifies the relevant table, which is 'Department'.", "It selects the 'name' column to display the names of the departments.", "The results are grouped by 'departmentID' to aggregate the data based on unique department identifiers.", "The results are ordered by the count of 'departmentID' in descending order to prioritize the most referenced departments.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT 1;", "source_tables": ["department"], "description": "This virtual table provides a list of department names from the 'Department' table, grouped by their unique identifiers. The results are ordered by the count of occurrences of each department ID in descending order, allowing users to see the most frequently referenced departments. The placeholder in the LIMIT clause represents the maximum number of department names to return.", "virtual_table": "SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3899", "db_id": "hospital_1", "question": "Find the department with the most employees.", "rationale": ["The query identifies the relevant table, which is 'Department'.", "It selects the 'name' column to display the names of the departments.", "The results are grouped by 'DepartmentID' to aggregate the data based on unique department identifiers.", "The results are ordered by the count of 'DepartmentID' in descending order to prioritize the most referenced departments.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT 1;", "source_tables": ["department"], "description": "This virtual table provides a list of department names from the 'Department' table, grouped by their unique identifiers. The results are ordered by the count of occurrences of each department ID in descending order, allowing users to see the most frequently referenced departments. The placeholder in the LIMIT clause represents the maximum number of department names to return.", "virtual_table": "SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3901", "db_id": "hospital_1", "question": "Tell me the employee id of the head of the department with the least employees.", "rationale": ["The query identifies the relevant table, which is 'Department'.", "It selects the 'head' column to display the heads of the departments.", "The results are grouped by 'DepartmentID' to ensure unique department heads are listed.", "The results are ordered by the count of 'DepartmentID' to prioritize departments with more occurrences.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT head FROM department GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["department"], "description": "This virtual table provides a list of department heads from the 'Department' table, grouped by their department IDs. The result is ordered by the count of departments, and the number of results returned is limited by a placeholder for numeric values.", "virtual_table": "SELECT head FROM department GROUP BY departmentID ORDER BY count(departmentID) LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3902", "db_id": "hospital_1", "question": "what is the name and position of the head whose department has least number of employees?", "rationale": ["The query identifies the relevant tables, which are 'Department' and 'Physician'.", "It selects the 'name' and 'position' columns from the 'Physician' table (aliased as T2).", "A JOIN operation is performed between 'Department' (aliased as T1) and 'Physician' (T2) on the condition that the head of the department matches the physician's EmployeeID.", "The results are grouped by 'departmentID' to aggregate the data appropriately.", "The results are ordered by the count of 'departmentID' to prioritize departments with more heads, and a limit is applied to restrict the number of results based on a placeholder for numeric values."], "gold_sql": "SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["physician", "department"], "description": "This virtual table provides the names and positions of physicians who are heads of departments. It aggregates the data from the 'Department' and 'Physician' tables, grouping by department ID and ordering the results by the count of departments, limited to a specified number of results.", "virtual_table": "SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3903", "db_id": "hospital_1", "question": "Find the name and position of the head of the department with the least employees.", "rationale": ["The query identifies the relevant tables, which are 'Department' and 'Physician'.", "It selects the 'name' and 'position' columns from the 'Physician' table (aliased as T2).", "A JOIN operation is performed between 'Department' (aliased as T1) and 'Physician' (T2) on the condition that the head of the department matches the physician's EmployeeID.", "The results are grouped by 'departmentID' to aggregate the data appropriately.", "The results are ordered by the count of 'departmentID' to prioritize departments with more heads, and a limit is applied to restrict the number of results based on a placeholder for numeric values."], "gold_sql": "SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["physician", "department"], "description": "This virtual table provides the names and positions of physicians who are heads of departments. It aggregates the data from the 'Department' and 'Physician' tables, grouping by department ID and ordering the results by the count of departments, limited to a specified number of results.", "virtual_table": "SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3904", "db_id": "hospital_1", "question": "What are names of patients who made an appointment?", "rationale": ["The query identifies the relevant tables, which are 'Appointment' and 'Patient'.", "It selects the 'name' column from the 'Patient' table.", "A join is performed between the 'Appointment' table and the 'Patient' table using the patient identifier and Social Security Number, respectively."], "gold_sql": "SELECT name FROM appointment AS T1 JOIN patient AS T2 ON T1.patient  =  T2.ssn", "source_tables": ["patient", "appointment"], "description": "This virtual table provides the names of patients associated with their appointments from the 'Appointment' and 'Patient' tables. The join condition links the patient identifier in the 'Appointment' table to the Social Security Number in the 'Patient' table.", "virtual_table": "SELECT name FROM appointment AS T1 JOIN patient AS T2 ON T1.patient  =  T2.ssn"}
{"sample_id": "train.3914", "db_id": "hospital_1", "question": "Find the names of all physicians and their primary affiliated departments' names.", "rationale": ["The query identifies the relevant tables: 'Physician', 'Affiliated_With', and 'Department'.", "It selects the 'Name' column from both the 'Physician' and 'Department' tables.", "The join condition connects the 'Physician' table to the 'Affiliated_With' table using the 'EmployeeID' and 'Physician' columns.", "Another join connects the 'Affiliated_With' table to the 'Department' table using the 'Department' and 'DepartmentID' columns.", "A condition is added to filter the results based on whether the affiliation is primary, using a placeholder for numeric values."], "gold_sql": "SELECT T1.name ,  T3.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T2.PrimaryAffiliation  =  1", "source_tables": ["physician", "department", "affiliated_with"], "description": "This virtual table describes the names of physicians and their affiliated departments from the 'Physician' and 'Department' tables. The join condition links physicians to their departments through the 'Affiliated_With' table, and the placeholder in the WHERE clause indicates whether the affiliation is primary.", "virtual_table": "SELECT T1.name ,  T3.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T2.PrimaryAffiliation  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3928", "db_id": "hospital_1", "question": "How many patients do each physician take care of? List their names and number of patients they take care of.", "rationale": ["The query identifies the relevant tables, which are 'Physician' and 'Patient'.", "It selects the 'Name' column from the 'Physician' table and counts the number of patients associated with each physician.", "A JOIN operation is performed on the 'EmployeeID' from the 'Physician' table and the 'PCP' from the 'Patient' table to establish the relationship.", "The results are grouped by the physician's unique identifier to count the number of patients for each physician."], "gold_sql": "SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid", "source_tables": ["physician", "patient"], "description": "This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician. The data is sourced from the 'Physician' and 'Patient' tables, where the relationship is established through the primary care physician identifier. The grouping is done by the physician's unique identifier to aggregate the patient counts accordingly.", "virtual_table": "SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid"}
{"sample_id": "train.3930", "db_id": "hospital_1", "question": "Find the name of physicians who are in charge of more than one patient.", "rationale": ["The query identifies the relevant tables, 'Physician' and 'Patient'.", "It selects the 'Name' column from the 'Physician' table, aliased as T1.", "A JOIN operation is performed between 'Physician' and 'Patient' on the condition that the physician's EmployeeID matches the patient's PCP identifier.", "The results are grouped by the physician's EmployeeID to aggregate the patient counts.", "The HAVING clause filters the results to include only those physicians who have more than a specified number of patients, using a placeholder for the numeric value."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  1", "source_tables": ["physician", "patient"], "description": "This virtual table lists the names of physicians who are primary care physicians (PCP) for patients, specifically those who have more than a specified number of patients assigned to them. The placeholder in the HAVING clause represents the minimum count of patients a physician must have to be included in the results.", "virtual_table": "SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3940", "db_id": "hospital_1", "question": "What is the names of the physicians who prescribe medication Thesisin?", "rationale": ["The query identifies the relevant tables: 'Physician', 'Prescribes', and 'Medication'.", "It selects distinct names from the 'Physician' table (aliased as T1).", "The JOIN operation connects 'Physician' with 'Prescribes' on the physician's identifier, and then with 'Medication' on the medication code.", "A condition is added to filter the results based on the medication name using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  'Thesisin'", "source_tables": ["physician", "prescribes", "medication"], "description": "This virtual table provides a list of unique physician names who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.", "virtual_table": "SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3941", "db_id": "hospital_1", "question": "List the names of all the physicians who prescribe Thesisin as medication.", "rationale": ["The query identifies the relevant tables: 'Physician', 'Prescribes', and 'Medication'.", "It selects distinct names from the 'Physician' table (aliased as T1).", "The JOIN operation connects 'Physician' with 'Prescribes' on the physician's identifier, and 'Prescribes' with 'Medication' on the medication code.", "A condition is added to filter the results based on the medication name using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  'Thesisin'", "source_tables": ["physician", "prescribes", "medication"], "description": "This virtual table provides a list of unique physician names who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.", "virtual_table": "SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3944", "db_id": "hospital_1", "question": "Find the number of medications prescribed for each brand.", "rationale": ["The query identifies the relevant tables, which are 'medication' and 'prescribes'.", "It selects a count of prescriptions and the name of the medication from the 'medication' table.", "The JOIN operation links the two tables based on the medication code, ensuring that only prescribed medications are counted.", "The GROUP BY clause organizes the results by the brand of the medication, allowing for a summary count per brand."], "gold_sql": "SELECT count(*) ,  T1.name FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand", "source_tables": ["prescribes", "medication"], "description": "This virtual table provides a count of prescribed medications grouped by their brand names. It combines data from the 'medication' table and the 'prescribes' table, allowing users to see how many times each brand of medication has been prescribed.", "virtual_table": "SELECT count(*) ,  T1.name FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand"}
{"sample_id": "train.3948", "db_id": "hospital_1", "question": "Find the patient who has the most recent undergoing treatment?", "rationale": ["The query identifies the relevant table, which is 'Undergoes'.", "Select the 'patient' column to display the patients who have undergone procedures.", "Order the results by 'dateundergoes' to sort the patients based on when the procedures were performed.", "Use a placeholder in the LIMIT clause to allow the user to specify how many patient records to return."], "gold_sql": "SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT 1", "source_tables": ["undergoes"], "description": "This virtual table provides a list of patients who have undergone medical procedures, sorted by the date of the procedures. The placeholder in the LIMIT clause allows for specifying the maximum number of patients to retrieve.", "virtual_table": "SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3949", "db_id": "hospital_1", "question": "Which patient is undergoing the most recent treatment?", "rationale": ["The query identifies the relevant table, which is 'Undergoes'.", "Select the 'patient' column to display the patients who have undergone procedures.", "Order the results by 'dateundergoes' to sort the patients based on when the procedures were performed.", "Use a placeholder in the LIMIT clause to allow the user to specify how many patient records to return."], "gold_sql": "SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT 1", "source_tables": ["undergoes"], "description": "This virtual table provides a list of patients who have undergone medical procedures, sorted by the date of the procedures. The placeholder in the LIMIT clause allows for specifying the maximum number of patients to retrieve.", "virtual_table": "SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3959", "db_id": "hospital_1", "question": "Find the physician who prescribed the highest dose. What is his or her name?", "rationale": ["The query identifies the relevant tables, which are 'Physician' and 'Prescribes'.", "It selects the 'Name' column from the 'Physician' table, aliased as T1.", "A JOIN operation is performed between 'Physician' (T1) and 'Prescribes' (T2) on the condition that the 'EmployeeID' from 'Physician' matches the 'Physician' identifier in 'Prescribes'.", "The results are ordered by the 'Dose' column from the 'Prescribes' table in descending order to prioritize higher dosages.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT 1", "source_tables": ["physician", "prescribes"], "description": "This virtual table lists the names of physicians from the 'Physician' table who have prescribed medications, ordered by the dosage of the medications in descending order. The placeholder in the LIMIT clause represents the maximum number of physician names to be returned.", "virtual_table": "SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3960", "db_id": "hospital_1", "question": "List the physicians' employee ids together with their primary affiliation departments' ids.", "rationale": ["The query identifies the relevant table, which is 'Affiliated_With'.", "Select the columns to display, 'physician' and 'department'.", "Add a condition to filter the 'primaryaffiliation' column for the specified status using a placeholder for numeric values."], "gold_sql": "SELECT physician ,  department FROM affiliated_with WHERE primaryaffiliation  =  1", "source_tables": ["affiliated_with"], "description": "This virtual table provides a list of physicians along with their associated departments from the 'Affiliated_With' table, filtered by whether the affiliation is marked as primary. The placeholder in the WHERE clause represents the primary affiliation status.", "virtual_table": "SELECT physician ,  department FROM affiliated_with WHERE primaryaffiliation  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3971", "db_id": "hospital_1", "question": "What are the three most costly procedures?", "rationale": ["The query identifies the relevant table, which is 'Procedures'.", "Select the column to display, 'name', which represents the names of the procedures.", "Order the results by the 'cost' column to sort the procedures based on their costs.", "Use a placeholder in the LIMIT clause to allow the user to specify how many procedure names they want to retrieve."], "gold_sql": "SELECT name FROM procedures ORDER BY cost LIMIT 3", "source_tables": ["procedures"], "description": "This virtual table lists the names of medical procedures from the 'Procedures' table, ordered by their associated costs. The placeholder in the LIMIT clause allows the user to specify the maximum number of procedure names to retrieve.", "virtual_table": "SELECT name FROM procedures ORDER BY cost LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3972", "db_id": "hospital_1", "question": "Find the physicians who are trained in a procedure that costs more than 5000.", "rationale": ["The query identifies the relevant tables: 'Physician', 'Trained_In', and 'Procedures'.", "It selects the 'Name' column from the 'Physician' table.", "The JOIN operation connects 'Physician' with 'Trained_In' based on the physician's identifier.", "Another JOIN connects 'Trained_In' with 'Procedures' based on the procedure code.", "A condition is added to filter the procedures based on their cost using a placeholder for numeric values."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  5000", "source_tables": ["physician", "procedures", "trained_in"], "description": "This virtual table describes the names of physicians who are trained in specific procedures that have a cost exceeding a certain amount. The placeholders in the WHERE clause represent the cost threshold for the procedures.", "virtual_table": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3974", "db_id": "hospital_1", "question": "Find the physician who was trained in the most expensive procedure?", "rationale": ["The query identifies the relevant tables: 'Physician', 'Trained_In', and 'Procedures'.", "It selects the 'Name' column from the 'Physician' table (aliased as T1).", "It joins the 'Trained_In' table (aliased as T2) on the 'EmployeeID' of the physician to find their training records.", "It further joins the 'Procedures' table (aliased as T3) on the 'Code' of the procedure to access the cost information.", "The results are ordered by the 'Cost' column from the 'Procedures' table in descending order to prioritize more expensive procedures.", "The LIMIT clause is used to restrict the number of results returned, with a placeholder for the user to specify the desired number."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment ORDER BY T3.cost DESC LIMIT 1", "source_tables": ["physician", "procedures", "trained_in"], "description": "This virtual table lists the names of physicians who are trained in specific medical procedures, ordered by the cost of those procedures in descending order. The placeholder in the LIMIT clause represents the maximum number of physician names to be returned.", "virtual_table": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment ORDER BY T3.cost DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3980", "db_id": "hospital_1", "question": "Find all procedures which cost more than 1000 or which physician John Wen was trained in.", "rationale": ["The query identifies the relevant tables: 'Procedures', 'Physician', and 'Trained_In'.", "It selects the 'name' column from the 'Procedures' table where the 'cost' exceeds a specified number using a placeholder.", "It uses a UNION to combine results with another SELECT statement that retrieves procedure names based on the physician's training.", "The second part of the query joins 'Physician' and 'Trained_In' on the physician's identifier, and then joins with 'Procedures' to get the names of procedures the physician is trained in.", "The placeholders are used for the cost and the physician's name to allow for dynamic querying."], "gold_sql": "SELECT name FROM procedures WHERE cost  >  1000 UNION SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  'John Wen'", "source_tables": ["procedures", "physician", "trained_in"], "description": "This virtual table provides a list of procedure names from the 'Procedures' table that have a cost greater than a specified amount. Additionally, it includes names of procedures that a specific physician is trained in, by joining the 'Physician', 'Trained_In', and 'Procedures' tables. The placeholders represent the cost threshold and the physician's name respectively.", "virtual_table": "SELECT name FROM procedures WHERE cost  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3993", "db_id": "hospital_1", "question": "How many patients are not using Procrastin-X as medication?", "rationale": ["The query identifies the relevant table, which is 'Patient'.", "It uses a subquery to find patients who have been prescribed a specific medication by joining 'Prescribes' and 'Medication' tables.", "The main query counts the patients whose SSN is not in the list of patients returned by the subquery, effectively filtering out those who have received the medication."], "gold_sql": "SELECT count(*) FROM patient WHERE SSN NOT IN ( SELECT T1.patient FROM Prescribes AS T1 JOIN Medication AS T2 ON T1.Medication  =  T2.Code WHERE T2.name  =  'Procrastin-X' )", "source_tables": ["patient", "prescribes", "medication"], "description": "This virtual table counts the number of patients who have not been prescribed a specific medication. It filters the patients based on their Social Security Number (SSN) and checks against a subquery that retrieves the patients who have received the specified medication. The placeholder in the subquery represents the name of the medication.", "virtual_table": "SELECT count(*) FROM patient WHERE SSN NOT IN ( SELECT T1.patient FROM Prescribes AS T1 JOIN Medication AS T2 ON T1.Medication  =  T2.Code WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] )"}
{"sample_id": "train.4256", "db_id": "club_1", "question": "What are the first names of all the students?", "rationale": ["The query is identifying the relevant table, which is 'Student'.", "Select the column to display, 'Fname', and use DISTINCT to ensure that only unique first names are returned."], "gold_sql": "SELECT DISTINCT fname FROM student", "source_tables": ["student"], "description": "The virtual table describes the distinct first names of students from the 'Student' table. The query retrieves unique first names to avoid duplicates.", "virtual_table": "SELECT DISTINCT fname FROM student"}
{"sample_id": "train.4271", "db_id": "club_1", "question": "Give me the first name and last name for all the female members of the club \"Bootup Baltimore\".", "rationale": ["The query identifies the relevant tables: 'Club', 'Member_of_club', and 'Student'.", "It selects the columns to display, which are 'fname' and 'lname' from the 'Student' table.", "The query joins the 'Club' table with the 'Member_of_club' table on 'ClubID' and then joins the 'Member_of_club' table with the 'Student' table on 'StuID'.", "Conditions are added to filter the results based on the specified club name and the gender of the students using placeholders for string values."], "gold_sql": "SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  'Bootup Baltimore' AND t3.sex  =  'F'", "source_tables": ["club", "member_of_club", "student"], "description": "This virtual table describes the first and last names of students who are members of a specific club and belong to a certain gender. The placeholders in the WHERE clause represent the club's name and the student's gender.", "virtual_table": "SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  [PLACEHOLDER-TYPE:STRING] AND t3.sex  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4277", "db_id": "club_1", "question": "Find the club which has the largest number of members majoring in \"600\".", "rationale": ["The query identifies the relevant tables: 'Club', 'Member_of_club', and 'Student'.", "It selects the 'clubname' from the 'Club' table.", "The JOIN operations link the 'Member_of_club' table to the 'Club' and 'Student' tables based on their respective IDs.", "A condition is added to filter the results based on the specified major of the students using a placeholder for string values.", "The results are grouped by 'clubname' to aggregate the data.", "The results are ordered by the count of members in each club in descending order.", "A limit is applied to restrict the number of clubs returned using a placeholder for numeric values."], "gold_sql": "SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.major  =  '600' GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT 1", "source_tables": ["club", "member_of_club", "student"], "description": "This virtual table lists the names of clubs that students, majoring in a specific field of study, are members of. The clubs are grouped by their names and ordered by the number of members in descending order, with a limit on the number of clubs returned. The placeholders in the WHERE clause and LIMIT clause represent the major of the students and the maximum number of clubs to display, respectively.", "virtual_table": "SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.major  =  [PLACEHOLDER-TYPE:STRING] GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4278", "db_id": "club_1", "question": "Find the name of the club that has the most female students.", "rationale": ["The query identifies the relevant tables: 'Club', 'Member_of_club', and 'Student'.", "It selects the 'clubname' from the 'Club' table.", "The JOIN operations link the 'Member_of_club' table to the 'Club' and 'Student' tables based on their respective IDs.", "A condition is added to filter the results based on the gender of the students using a placeholder for string values.", "The results are grouped by 'clubname' to aggregate the counts of members per club.", "The results are ordered by the count of members in descending order to show the most popular clubs first.", "A LIMIT clause is included to restrict the number of clubs returned, using a placeholder for numeric values."], "gold_sql": "SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.sex  =  'F' GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT 1", "source_tables": ["club", "member_of_club", "student"], "description": "This virtual table lists the names of clubs that have the highest number of members of a specific gender. The placeholders in the WHERE clause represent the gender of the students, and the LIMIT clause allows for specifying the maximum number of clubs to return.", "virtual_table": "SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.sex  =  [PLACEHOLDER-TYPE:STRING] GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4312", "db_id": "club_1", "question": "List the clubs that have at least a member with advisor \"1121\".", "rationale": ["The query identifies the relevant tables: 'Club', 'Member_of_club', and 'Student'.", "It selects distinct club names from the 'Club' table.", "The JOIN operations link the 'Member_of_club' table to the 'Club' table and the 'Student' table to filter clubs based on the advisor's ID.", "A condition is added to filter the results based on the advisor's ID using a placeholder for numeric values."], "gold_sql": "SELECT DISTINCT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.advisor  =  1121", "source_tables": ["club", "member_of_club", "student"], "description": "This virtual table lists the distinct names of clubs from the 'Club' table that are associated with students whose academic advisor matches a specified identifier. The placeholder in the WHERE clause represents the advisor's ID.", "virtual_table": "SELECT DISTINCT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.advisor  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4324", "db_id": "tracking_grants_for_research", "question": "What is the total grant amount of the organisations described as research?", "rationale": ["The query identifies the relevant tables: 'Grants', 'Organisations', and 'Organisation_Types'.", "It selects the sum of the 'grant_amount' from the 'Grants' table.", "The query joins 'Grants' with 'Organisations' on the 'organisation_id' to associate grants with their organisations.", "It further joins 'Organisations' with 'Organisation_Types' on 'organisation_type' to filter by organisation type.", "The WHERE clause uses a placeholder to specify the organisation type description for filtering the results."], "gold_sql": "SELECT sum(grant_amount) FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id JOIN organisation_Types AS T3 ON T2.organisation_type  =  T3.organisation_type WHERE T3.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations"], "description": "This virtual table calculates the total grant amount from the 'Grants' table for organisations of a specific type. It joins the 'Grants' table with the 'Organisations' table to link grants to their respective organisations, and further joins with the 'Organisation_Types' table to filter by the organisation type description. The placeholder in the WHERE clause represents the specific organisation type description being queried.", "virtual_table": "SELECT sum(grant_amount) FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id JOIN organisation_Types AS T3 ON T2.organisation_type  =  T3.organisation_type WHERE T3.organisation_type_description  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4327", "db_id": "tracking_grants_for_research", "question": "From what date and to what date do the staff work on a project that has the most staff and has staff in a leader role?", "rationale": ["The query identifies the relevant table, which is 'Project_Staff'.", "It selects the columns 'date_from' and 'date_to' to show the involvement dates of staff members.", "The first part of the query filters projects based on the count of staff members, using a subquery to get the top N projects.", "The second part of the query filters by a specific 'role_code', allowing for a focused view of staff involvement based on their roles."], "gold_sql": "SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT 1 ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  'leader'", "source_tables": ["project_staff"], "description": "This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.", "virtual_table": "SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4328", "db_id": "tracking_grants_for_research", "question": "Find the organisation ids and details of the organisations which are involved in", "rationale": ["The query identifies the relevant tables, 'Grants' and 'Organisations'.", "It selects the columns 'organisation_id' and 'organisation_details' from the 'Organisations' table.", "A JOIN operation is performed on the 'Grants' table to link it with the 'Organisations' table based on the 'organisation_id'.", "The results are grouped by 'organisation_id' to aggregate the grant amounts for each organisation.", "The HAVING clause filters the results to include only those organisations where the total grant amount exceeds a specified numeric value, represented by a placeholder."], "gold_sql": "SELECT T2.organisation_id ,  T2.organisation_details FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id GROUP BY T2.organisation_id HAVING sum(T1.grant_amount)  >  6000", "source_tables": ["grants", "organisations"], "description": "This virtual table provides a list of organisation IDs and their corresponding details from the 'Organisations' table, which are associated with grants from the 'Grants' table. The results are grouped by organisation ID, and only those organisations that have a total grant amount exceeding a specified threshold are included, as indicated by the placeholder in the HAVING clause.", "virtual_table": "SELECT T2.organisation_id ,  T2.organisation_details FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id GROUP BY T2.organisation_id HAVING sum(T1.grant_amount)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4330", "db_id": "tracking_grants_for_research", "question": "What is the organisation type and id of the organisation which has the most number of research staff?", "rationale": ["The query identifies the relevant tables, 'Organisations' and 'Research_Staff'.", "It selects the columns 'organisation_type' and 'organisation_id' from the 'Organisations' table.", "A JOIN operation is performed between 'Organisations' and 'Research_Staff' on the organisation ID to filter the results based on employed research staff.", "The results are grouped by 'organisation_id' to aggregate the data accordingly.", "The results are ordered by the count of research staff in descending order to prioritize organisations with more staff.", "A LIMIT clause is added to restrict the number of results returned based on a placeholder for numeric values."], "gold_sql": "SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "description": "This virtual table provides a list of organisation types and their corresponding organisation IDs from the 'Organisations' table. It joins with the 'Research_Staff' table to filter organisations based on the staff members employed by them. The results are grouped by organisation ID and ordered by the number of research staff associated with each organisation, limiting the output to a specified number of results.", "virtual_table": "SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4331", "db_id": "tracking_grants_for_research", "question": "What is the type and id of the organization that has the most research staff?", "rationale": ["The query identifies the relevant tables, 'Organisations' and 'Research_Staff'.", "It selects the 'organisation_type' and 'organisation_id' from the 'Organisations' table.", "A JOIN operation is performed between 'Organisations' and 'Research_Staff' on the 'organisation_id' and 'employer_organisation_id' fields to filter the organisations based on their research staff.", "The results are grouped by 'organisation_id' to aggregate the data.", "The results are ordered by the count of research staff in descending order to prioritize organisations with more staff.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "description": "This virtual table provides a list of organisation types and their corresponding organisation IDs from the 'Organisations' table. It joins with the 'Research_Staff' table to filter organisations based on the staff members employed by them. The results are grouped by organisation ID and ordered by the count of research staff in descending order, with a limit on the number of results returned as specified by a placeholder.", "virtual_table": "SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4333", "db_id": "tracking_grants_for_research", "question": "What is the type of the organization with the most research staff?", "rationale": ["The query identifies the relevant tables, 'Organisations' and 'Research_Staff'.", "It selects the 'organisation_type' from the 'Organisations' table.", "A JOIN operation is performed to link 'Organisations' with 'Research_Staff' based on the organisation ID.", "The results are grouped by 'organisation_type' to aggregate the data.", "The results are ordered by the count of research staff in each organisation type in descending order.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "description": "This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type and ordered by the number of research staff in each type. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisation types to retrieve.", "virtual_table": "SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4334", "db_id": "tracking_grants_for_research", "question": "Find out the send dates of the documents with the grant amount of more than 5000 were granted by organisation type described", "rationale": ["The query identifies the relevant tables: 'Documents', 'Grants', 'Organisations', and 'Organisation_Types'.", "It selects the 'sent_date' from the 'Documents' table.", "Joins are established between 'Documents' and 'Grants' on 'grant_id', then between 'Grants' and 'Organisations' on 'organisation_id', and finally between 'Organisations' and 'Organisation_Types' on 'organisation_type'.", "A condition is added to filter grants based on the specified grant amount using a placeholder for numeric values.", "Another condition filters organisations based on their type description using a placeholder for string values."], "gold_sql": "SELECT T1.sent_date FROM documents AS T1 JOIN Grants AS T2 ON T1.grant_id  =  T2.grant_id JOIN Organisations AS T3 ON T2.organisation_id  =  T3.organisation_id JOIN organisation_Types AS T4 ON T3.organisation_type  =  T4.organisation_type WHERE T2.grant_amount  >  5000 AND T4.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations", "documents"], "description": "This virtual table provides the sent dates of documents from the 'Documents' table that are associated with grants exceeding a specified amount. The query joins multiple tables: 'Grants' to link grants with documents, 'Organisations' to connect grants to their respective organisations, and 'Organisation_Types' to filter organisations based on their type description. The placeholders represent the grant amount and the organisation type description, allowing users to specify their criteria.", "virtual_table": "SELECT T1.sent_date FROM documents AS T1 JOIN Grants AS T2 ON T1.grant_id  =  T2.grant_id JOIN Organisations AS T3 ON T2.organisation_id  =  T3.organisation_id JOIN organisation_Types AS T4 ON T3.organisation_type  =  T4.organisation_type WHERE T2.grant_amount  >  [PLACEHOLDER-TYPE:NUMBER] AND T4.organisation_type_description  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4335", "db_id": "tracking_grants_for_research", "question": "What are the send dates for all documents that have a grant amount of more than 5000 and are involved in research?", "rationale": ["The query identifies the relevant tables: 'Documents', 'Grants', 'Organisations', and 'Organisation_Types'.", "It selects the 'sent_date' from the 'Documents' table.", "Joins are established between 'Documents' and 'Grants' on 'grant_id', between 'Grants' and 'Organisations' on 'organisation_id', and between 'Organisations' and 'Organisation_Types' on 'organisation_type'.", "A condition is added to filter grants with an amount greater than a specified value using a placeholder for numeric values.", "Another condition filters the organisation type description using a placeholder for string values."], "gold_sql": "SELECT T1.sent_date FROM documents AS T1 JOIN Grants AS T2 ON T1.grant_id  =  T2.grant_id JOIN Organisations AS T3 ON T2.organisation_id  =  T3.organisation_id JOIN organisation_Types AS T4 ON T3.organisation_type  =  T4.organisation_type WHERE T2.grant_amount  >  5000 AND T4.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations", "documents"], "description": "This virtual table provides the sent dates of documents from the 'Documents' table that are associated with grants exceeding a specified amount. The query joins multiple tables: 'Grants' to link grants to documents, 'Organisations' to connect grants to their respective organisations, and 'Organisation_Types' to filter based on the type of organisation. The placeholders represent the grant amount and the organisation type description.", "virtual_table": "SELECT T1.sent_date FROM documents AS T1 JOIN Grants AS T2 ON T1.grant_id  =  T2.grant_id JOIN Organisations AS T3 ON T2.organisation_id  =  T3.organisation_id JOIN organisation_Types AS T4 ON T3.organisation_type  =  T4.organisation_type WHERE T2.grant_amount  >  [PLACEHOLDER-TYPE:NUMBER] AND T4.organisation_type_description  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4343", "db_id": "tracking_grants_for_research", "question": "When did researchers start and stop working?", "rationale": ["The query identifies the relevant table, which is 'Project_Staff'.", "Select the columns to display, 'date_from' and 'date_to', which represent the involvement period of staff members.", "Add a condition to filter the 'role_code' column for the specified role using a placeholder for string values."], "gold_sql": "SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  'researcher'", "source_tables": ["project_staff"], "description": "This virtual table provides the start and end dates of staff members' involvement in projects from the 'Project_Staff' table, filtered by a specific role code. The placeholder in the WHERE clause represents the role of the staff member.", "virtual_table": "SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4349", "db_id": "tracking_grants_for_research", "question": "What are the details for the project whose research has been published?", "rationale": ["The query identifies the relevant tables: 'Projects', 'Project_Outcomes', and 'Research_Outcomes'.", "It selects the 'project_details' column from the 'Projects' table.", "The query uses JOINs to connect 'Projects' with 'Project_Outcomes' on 'project_id' and 'Project_Outcomes' with 'Research_Outcomes' on 'outcome_code'.", "A condition is added to filter the results based on the 'outcome_description' using a placeholder for string values."], "gold_sql": "SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id JOIN Research_outcomes AS T3 ON T2.outcome_code  =  T3.outcome_code WHERE T3.outcome_description LIKE '%Published%'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "description": "This virtual table describes the details of projects from the 'Projects' table that are associated with specific research outcomes. The query joins the 'Projects' table with the 'Project_Outcomes' table and the 'Research_Outcomes' table to filter projects based on a particular outcome description. The placeholder in the WHERE clause represents the outcome description being searched for.", "virtual_table": "SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id JOIN Research_outcomes AS T3 ON T2.outcome_code  =  T3.outcome_code WHERE T3.outcome_description LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4356", "db_id": "tracking_grants_for_research", "question": "Which project made the most number of outcomes? List the project details and the project id.", "rationale": ["The query identifies the relevant tables, 'Projects' and 'Project_Outcomes'.", "It selects the 'project_details' and 'project_id' from the 'Projects' table.", "A JOIN operation is performed between 'Projects' and 'Project_Outcomes' on the 'project_id' to link projects with their outcomes.", "The results are grouped by 'project_id' to aggregate the outcomes for each project.", "The results are ordered by the count of outcomes in descending order to prioritize projects with more outcomes.", "A LIMIT clause is added to restrict the number of results returned based on a placeholder for numeric values."], "gold_sql": "SELECT T1.project_details ,  T1.project_id FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "projects"], "description": "This virtual table provides a list of project details and their corresponding project IDs from the 'Projects' table. It joins with the 'Project_Outcomes' table to aggregate the outcomes associated with each project. The results are grouped by project ID and ordered by the count of outcomes in descending order, allowing the user to limit the number of results returned based on a specified number.", "virtual_table": "SELECT T1.project_details ,  T1.project_id FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4360", "db_id": "tracking_grants_for_research", "question": "Which organisation hired the most number of research staff? List the organisation id, type and detail.", "rationale": ["The query identifies the relevant tables, 'Organisations' and 'Research_Staff'.", "It selects the columns 'organisation_id', 'organisation_type', and 'organisation_details' from the 'Organisations' table.", "A JOIN operation is performed between 'Organisations' and 'Research_Staff' on the condition that the organisation ID matches the employer organisation ID.", "The results are grouped by 'organisation_id' to aggregate the data for each organisation.", "The results are ordered by the count of research staff in descending order to prioritize organisations with more staff.", "A LIMIT clause is added to restrict the number of results returned based on a placeholder for numeric values."], "gold_sql": "SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "description": "This virtual table provides a list of organisations along with their types and details, specifically focusing on those that employ research staff. The results are grouped by organisation ID and ordered by the number of research staff associated with each organisation, with a limit on the number of results returned based on a specified numeric value.", "virtual_table": "SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4361", "db_id": "tracking_grants_for_research", "question": "What are the ids, types, and details of the organization with the most research staff?", "rationale": ["The query identifies the relevant tables, 'Organisations' and 'Research_Staff'.", "It selects the columns 'organisation_id', 'organisation_type', and 'organisation_details' from the 'Organisations' table.", "A JOIN operation is performed between 'Organisations' and 'Research_Staff' on the condition that the organisation ID matches the employer organisation ID.", "The results are grouped by 'organisation_id' to aggregate the data for each organisation.", "The results are ordered by the count of research staff in descending order to prioritize organisations with more staff.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "description": "This virtual table provides a list of organisations along with their types and details, specifically focusing on those that employ research staff. The results are grouped by organisation ID and ordered by the number of research staff associated with each organisation, with a limit on the number of results returned as specified by the placeholder.", "virtual_table": "SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4363", "db_id": "tracking_grants_for_research", "question": "For each staff id, what is the description of the role that is involved with the most number of projects?", "rationale": ["The query identifies the relevant tables: 'Staff_Roles', 'Project_Staff', and 'Project_Outcomes'.", "It selects the 'role_description' from 'Staff_Roles' and 'staff_id' from 'Project_Staff'.", "The JOIN operation is performed on 'role_code' to link staff roles with project staff.", "The query also joins 'Project_Outcomes' to associate project outcomes with the staff members.", "The results are grouped by 'staff_id' to aggregate the data based on the number of project outcomes.", "Finally, the results are ordered by the count of project outcomes in descending order, and a placeholder is added to limit the number of results."], "gold_sql": "SELECT T1.role_description ,  T2.staff_id FROM Staff_Roles AS T1 JOIN Project_Staff AS T2 ON T1.role_code  =  T2.role_code JOIN Project_outcomes AS T3 ON T2.project_id  =  T3.project_id GROUP BY T2.staff_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "project_staff", "staff_roles"], "description": "This virtual table provides a list of staff members along with their role descriptions from the 'Staff_Roles' and 'Project_Staff' tables. It joins these tables based on the role code and groups the results by staff ID to count the number of associated project outcomes. The results are ordered by the count in descending order, and a placeholder is included to limit the number of results returned.", "virtual_table": "SELECT T1.role_description ,  T2.staff_id FROM Staff_Roles AS T1 JOIN Project_Staff AS T2 ON T1.role_code  =  T2.role_code JOIN Project_outcomes AS T3 ON T2.project_id  =  T3.project_id GROUP BY T2.staff_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4367", "db_id": "tracking_grants_for_research", "question": "For grants that have descriptions of Regular and Initial Applications, what are their start dates?", "rationale": ["The query identifies the relevant tables: 'Grants', 'Documents', and 'Document_Types'.", "It selects the 'grant_start_date' from the 'Grants' table.", "Joins are used to connect 'Grants' with 'Documents' and 'Document_Types' based on their foreign key relationships.", "The WHERE clause filters results based on the 'document_description' from the 'Document_Types' table using a placeholder for string values."], "gold_sql": "SELECT T1.grant_start_date FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id JOIN Document_Types AS T3 ON T2.document_type_code  =  T3.document_type_code WHERE T3.document_description  =  'Regular' INTERSECT SELECT T1.grant_start_date FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id JOIN Document_Types AS T3 ON T2.document_type_code  =  T3.document_type_code WHERE T3.document_description  =  'Initial Application'", "source_tables": ["grants", "document_types", "documents"], "description": "This virtual table retrieves the start dates of grants from the 'Grants' table that are associated with documents of a specific type. The query uses joins to connect the 'Grants', 'Documents', and 'Document_Types' tables based on their foreign key relationships. The placeholder in the WHERE clause represents the description of the document type, allowing users to specify which document type they are interested in.", "virtual_table": "SELECT T1.grant_start_date FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id JOIN Document_Types AS T3 ON T2.document_type_code  =  T3.document_type_code WHERE T3.document_description  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.grant_start_date FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id JOIN Document_Types AS T3 ON T2.document_type_code  =  T3.document_type_code WHERE T3.document_description  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4369", "db_id": "tracking_grants_for_research", "question": "For each grant id, how many documents does it have, and which one has the most?", "rationale": ["The query identifies the relevant table, which is 'Documents'.", "It selects the 'grant_id' and counts the number of documents associated with each grant using the COUNT function.", "The results are grouped by 'grant_id' to aggregate the document counts for each grant.", "The results are ordered in descending order based on the count of documents to show the grants with the most documents first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT grant_id ,  count(*) FROM Documents GROUP BY grant_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["documents"], "description": "This virtual table summarizes the number of documents associated with each grant from the 'Documents' table. It groups the results by 'grant_id' and orders them in descending order based on the count of documents, allowing the user to specify a limit on the number of results returned.", "virtual_table": "SELECT grant_id ,  count(*) FROM Documents GROUP BY grant_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4372", "db_id": "tracking_grants_for_research", "question": "What are all the details of the organisations described as 'Sponsor'? Sort the result in an ascending order.", "rationale": ["The query identifies the relevant tables, 'Organisations' and 'Organisation_Types'.", "It selects the 'organisation_details' column from the 'Organisations' table.", "A JOIN operation is performed to link 'Organisations' with 'Organisation_Types' based on the organisation type.", "A condition is added to filter the results based on the 'organisation_type_description' using a placeholder for string values.", "The results are ordered by 'organisation_details' to present them in a structured manner."], "gold_sql": "SELECT organisation_details FROM Organisations AS T1 JOIN organisation_Types AS T2 ON T1.organisation_type  =  T2.organisation_type WHERE T2.organisation_type_description  =  'Sponsor' ORDER BY organisation_details", "source_tables": ["organisation_types", "organisations"], "description": "This virtual table provides the details of organisations that belong to a specific type, as defined in the 'Organisation_Types' table. The placeholder in the WHERE clause represents the description of the organisation type, allowing users to filter the results accordingly.", "virtual_table": "SELECT organisation_details FROM Organisations AS T1 JOIN organisation_Types AS T2 ON T1.organisation_type  =  T2.organisation_type WHERE T2.organisation_type_description  =  [PLACEHOLDER-TYPE:STRING] ORDER BY organisation_details"}
{"sample_id": "train.4380", "db_id": "tracking_grants_for_research", "question": "What are the result description of the project whose detail is 'sint'?", "rationale": ["The query identifies the relevant tables: 'Research_Outcomes', 'Project_Outcomes', and 'Projects'.", "It selects the 'outcome_description' from the 'Research_Outcomes' table.", "The JOIN operations link the 'Research_Outcomes' to 'Project_Outcomes' using the 'outcome_code', and then link 'Project_Outcomes' to 'Projects' using 'project_id'.", "A condition is added to filter the results based on the 'project_details' column from the 'Projects' table, using a placeholder for string values."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code JOIN Projects AS T3 ON T2.project_id  =  T3.project_id WHERE T3.project_details  =  'sint'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "description": "This virtual table describes the outcome descriptions of research outcomes associated with a specific project. The placeholders in the WHERE clause represent the detailed description of the project being queried.", "virtual_table": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code JOIN Projects AS T3 ON T2.project_id  =  T3.project_id WHERE T3.project_details  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4381", "db_id": "tracking_grants_for_research", "question": "What is the description for the results whose project detail is 'sint'?", "rationale": ["The query identifies the relevant tables: 'Research_Outcomes', 'Project_Outcomes', and 'Projects'.", "It selects the 'outcome_description' from the 'Research_Outcomes' table.", "The JOIN operations link the 'Research_Outcomes' to 'Project_Outcomes' using the 'outcome_code', and 'Project_Outcomes' to 'Projects' using the 'project_id'.", "A condition is added to filter the results based on the 'project_details' column from the 'Projects' table using a placeholder for string values."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code JOIN Projects AS T3 ON T2.project_id  =  T3.project_id WHERE T3.project_details  =  'sint'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "description": "This virtual table describes the outcome descriptions of research outcomes associated with specific projects. The query joins the 'Research_Outcomes' table with the 'Project_Outcomes' table and the 'Projects' table to filter the results based on the project details. The placeholder in the WHERE clause represents the specific project details being queried.", "virtual_table": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code JOIN Projects AS T3 ON T2.project_id  =  T3.project_id WHERE T3.project_details  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4383", "db_id": "tracking_grants_for_research", "question": "What is the id of the organization with the maximum number of outcomes and how many outcomes are there?", "rationale": ["The query identifies the relevant tables, 'Projects' and 'Project_Outcomes'.", "It selects the 'organisation_id' from the 'Projects' table and counts the number of project outcomes associated with each organisation.", "The JOIN operation links 'Projects' and 'Project_Outcomes' on the 'project_id' to ensure that only relevant outcomes are counted for each organisation.", "The results are grouped by 'organisation_id' to aggregate the counts for each organisation.", "The ORDER BY clause sorts the results in descending order based on the count of project outcomes, allowing the user to see which organisations have the most outcomes.", "The LIMIT clause uses a placeholder to allow the user to specify how many top organisations they want to retrieve."], "gold_sql": "SELECT T1.organisation_id ,  count(*) FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "projects"], "description": "This virtual table provides a count of projects grouped by organisation, showing how many project outcomes each organisation has. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to display based on their project outcomes.", "virtual_table": "SELECT T1.organisation_id ,  count(*) FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4384", "db_id": "tracking_grants_for_research", "question": "List the project details of the projects launched by the organisation", "rationale": ["The query identifies the relevant table, which is 'Projects'.", "It selects the 'project_details' column to display the details of the projects.", "The WHERE clause filters the results to include only those organisations that have the highest number of projects, using a subquery that groups by 'organisation_id' and orders by the count of projects in descending order.", "The LIMIT clause uses a placeholder to allow the user to specify how many top organisations to return."], "gold_sql": "SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT 1 )", "source_tables": ["projects"], "description": "This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.", "virtual_table": "SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] )"}
{"sample_id": "train.4392", "db_id": "tracking_grants_for_research", "question": "What are the staff roles of the staff who", "rationale": ["The query identifies the relevant table, which is 'Project_Staff'.", "Select the column to display, 'role_code'.", "Add conditions to filter the 'date_from' and 'date_to' columns for the specified date range using placeholders for string values."], "gold_sql": "SELECT role_code FROM Project_Staff WHERE date_from  >  '2003-04-19 15:06:20' AND date_to  <  '2016-03-15 00:33:18'", "source_tables": ["project_staff"], "description": "This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.", "virtual_table": "SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4394", "db_id": "tracking_grants_for_research", "question": "What are the descriptions of all the project outcomes?", "rationale": ["The query identifies the relevant tables, which are 'Research_Outcomes' and 'Project_Outcomes'.", "It selects the 'outcome_description' from the 'Research_Outcomes' table.", "A join is performed between 'Research_Outcomes' and 'Project_Outcomes' on the 'outcome_code' to link research outcomes with project outcomes."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code", "source_tables": ["project_outcomes", "research_outcomes"], "description": "This virtual table describes the outcome descriptions of research outcomes associated with specific project outcomes. The join between the 'Research_Outcomes' and 'Project_Outcomes' tables is based on the matching outcome codes, allowing users to retrieve detailed descriptions of research outcomes linked to their respective projects.", "virtual_table": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code"}
{"sample_id": "train.4397", "db_id": "tracking_grants_for_research", "question": "What is the most common role for the staff?", "rationale": ["The query identifies the relevant table, which is 'Project_Staff'.", "It selects the 'role_code' column to display unique role codes.", "The results are grouped by 'role_code' to aggregate the data based on the role.", "The results are ordered by the count of occurrences of each role code in descending order to show the most common roles first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT role_code FROM Project_Staff GROUP BY role_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_staff"], "description": "This virtual table provides a list of unique role codes from the 'Project_Staff' table, grouped by the role code and ordered by the number of occurrences in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of role codes to retrieve.", "virtual_table": "SELECT role_code FROM Project_Staff GROUP BY role_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4410", "db_id": "network_2", "question": "Who is the oldest person whose job is student?", "rationale": ["The query identifies the relevant table, which is 'Person'.", "It selects the 'name' column to display the names of individuals.", "A condition is added to filter the 'job' column for the specified job title using a placeholder for string values.", "Additionally, it includes a subquery to find the maximum age of individuals with the same job title, ensuring that only the oldest individual(s) are selected."], "gold_sql": "SELECT name FROM Person WHERE job  =  'student' AND age  =  (SELECT max(age) FROM person WHERE job  =  'student' )", "source_tables": ["person"], "description": "This virtual table describes the names of individuals from the 'Person' table who have a specific job title and are the oldest among those with the same job. The placeholders in the WHERE clause represent the job title being queried.", "virtual_table": "SELECT name FROM Person WHERE job  =  [PLACEHOLDER-TYPE:STRING] AND age  =  (SELECT max(age) FROM person WHERE job  =  [PLACEHOLDER-TYPE:STRING] )"}
{"sample_id": "train.4439", "db_id": "network_2", "question": "What is the name and age of every male? Order the results by age.", "rationale": ["The query identifies the relevant table, which is 'Person'.", "Select the column to display, 'name'.", "Add a condition to filter the 'gender' column for the specified gender using a placeholder for string values.", "Order the results by the 'age' column to sort the names accordingly."], "gold_sql": "SELECT name FROM Person WHERE gender  =  'male' ORDER BY age", "source_tables": ["person"], "description": "This virtual table lists the names of individuals from the 'Person' table who belong to a specific gender. The results are ordered by their age, allowing for easy identification of individuals within that gender category.", "virtual_table": "SELECT name FROM Person WHERE gender  =  [PLACEHOLDER-TYPE:STRING] ORDER BY age"}
{"sample_id": "train.4441", "db_id": "network_2", "question": "What are the names and ages of every person who is a friend of both Dan and Alice?", "rationale": ["The query identifies the relevant tables, which are 'Person' and 'PersonFriend'.", "It selects the columns to display, 'name' and 'age', from the 'Person' table.", "The JOIN operation is used to connect 'Person' and 'PersonFriend' based on the person's name.", "The WHERE clause filters the results to include only those persons who are friends with a specified friend, using a placeholder for the friend's name.", "The INTERSECT operation ensures that only persons who have mutual friendships with the specified friend are included in the final result."], "gold_sql": "SELECT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Dan' INTERSECT SELECT T1.name ,   T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Alice'", "source_tables": ["personfriend", "person"], "description": "This virtual table describes the names and ages of persons from the 'Person' table who have mutual friendships with a specific friend. The placeholders in the WHERE clause represent the names of the friends being queried.", "virtual_table": "SELECT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.name ,   T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4444", "db_id": "network_2", "question": "Find the name of the person who has friends with age above 40 and under age 30?", "rationale": ["The query starts by selecting names from the 'Person' table, aliased as T1.", "It joins the 'PersonFriend' table, aliased as T2, on the condition that the names match.", "The first part of the INTERSECT selects names of individuals whose friends are older than a specified age, using a subquery to filter based on age.", "The second part of the INTERSECT selects names of individuals whose friends are younger than a specified age, again using a subquery for filtering."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  40) INTERSECT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  30)", "source_tables": ["personfriend", "person"], "description": "This virtual table identifies individuals from the 'Person' table who have friends that are both older and younger than a specified age. The placeholders in the query represent the age limits for filtering friends.", "virtual_table": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  [PLACEHOLDER-TYPE:NUMBER]) INTERSECT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.4445", "db_id": "network_2", "question": "What are the names of every person who has a friend over 40 and under 30?", "rationale": ["The query starts by selecting names from the 'Person' table, aliased as T1.", "It joins the 'PersonFriend' table, aliased as T2, on the condition that the names match.", "The first part of the INTERSECT selects names of individuals whose friends are older than a specified age, using a subquery to filter based on age.", "The second part of the INTERSECT selects names of individuals whose friends are younger than a specified age, again using a subquery for filtering."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  40) INTERSECT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  30)", "source_tables": ["personfriend", "person"], "description": "This virtual table identifies individuals from the 'Person' table who have friends that are both older and younger than a specified age. The placeholders in the query represent the age limits for filtering friends.", "virtual_table": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  [PLACEHOLDER-TYPE:NUMBER]) INTERSECT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.4449", "db_id": "network_2", "question": "What are the names of the people who have no friends who are students?", "rationale": ["The query starts by selecting names from the 'Person' table.", "It uses the EXCEPT clause to exclude names of friends from the 'PersonFriend' table.", "A JOIN is performed between 'Person' and 'PersonFriend' to find friends of individuals who have a specific job.", "The WHERE clause filters the results based on the job title using a placeholder for string values."], "gold_sql": "SELECT name FROM person EXCEPT SELECT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.job  =  'student'", "source_tables": ["personfriend", "person"], "description": "This virtual table identifies the names of individuals from the 'Person' table who do not have any friends that work in a specific occupation. The placeholder in the query allows for the specification of the job title to filter out those individuals accordingly.", "virtual_table": "SELECT name FROM person EXCEPT SELECT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.job  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4454", "db_id": "network_2", "question": "Find the name of persons who are friends with Bob.", "rationale": ["The query identifies the relevant tables, which are 'Person' and 'PersonFriend'.", "It selects the 'name' column from the 'Person' table, aliased as T1.", "A JOIN operation is performed between 'Person' (T1) and 'PersonFriend' (T2) on the condition that the names match.", "A condition is added to filter the results based on the specified friend's name using a placeholder for string values."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Bob'", "source_tables": ["personfriend", "person"], "description": "This virtual table describes the names of persons from the 'Person' table who have a specific friend listed in the 'PersonFriend' table. The placeholder in the WHERE clause represents the friend's name.", "virtual_table": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4455", "db_id": "network_2", "question": "What are the names of all of Bob's friends?", "rationale": ["The query identifies the relevant tables, 'Person' and 'PersonFriend'.", "It selects the 'name' column from the 'Person' table, which represents the individuals.", "A JOIN operation is performed between 'Person' and 'PersonFriend' on the 'name' column to link individuals with their friends.", "A condition is added to filter the results based on the specified friend's name using a placeholder for string values."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Bob'", "source_tables": ["personfriend", "person"], "description": "This virtual table describes the names of individuals from the 'Person' table who have a specific friend listed in the 'PersonFriend' table. The placeholder in the WHERE clause represents the friend's name.", "virtual_table": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4456", "db_id": "network_2", "question": "Find the names of females who are friends with Zach", "rationale": ["The query identifies the relevant tables, which are 'Person' and 'PersonFriend'.", "It selects the 'name' column from the 'Person' table, aliased as T1.", "A JOIN operation is performed between 'Person' (T1) and 'PersonFriend' (T2) on the condition that their names match.", "Conditions are added to filter the results based on the specified friend's name and the person's gender using placeholders for string values."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Zach' AND T1.gender  =  'female'", "source_tables": ["personfriend", "person"], "description": "This virtual table describes the names of persons from the 'Person' table who have a specific friend and belong to a certain gender. The placeholders in the WHERE clause represent the friend's name and the gender of the person.", "virtual_table": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] AND T1.gender  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4465", "db_id": "network_2", "question": "What are the different names of friends who are younger than the average age for a friend?", "rationale": ["The query identifies the relevant tables, which are 'Person' and 'PersonFriend'.", "It selects distinct names from the 'PersonFriend' table, specifically those who are friends of persons from the 'Person' table.", "A JOIN operation is performed on the 'name' column to link friends to their respective persons.", "A condition is added to filter persons based on their age being less than the average age calculated from the 'Person' table."], "gold_sql": "SELECT DISTINCT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.age  <  (SELECT avg(age) FROM person)", "source_tables": ["personfriend", "person"], "description": "This virtual table lists the distinct names of friends of persons who are younger than the average age of all persons in the 'Person' table. The placeholder in the WHERE clause represents the age condition based on the average age.", "virtual_table": "SELECT DISTINCT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.age  <  (SELECT avg(age) FROM person)"}
{"sample_id": "train.4466", "db_id": "network_2", "question": "Who has friends that are older than the average age? Print their friends and their ages as well", "rationale": ["The query identifies the relevant tables, 'Person' and 'PersonFriend'.", "It selects distinct names and friends from the 'PersonFriend' table and the age from the 'Person' table.", "A JOIN operation is performed on the names to link friends to their respective ages.", "A condition is added to filter friends whose age is greater than the average age calculated from the 'Person' table."], "gold_sql": "SELECT DISTINCT T2.name ,  T2.friend ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.age  >  (SELECT avg(age) FROM person)", "source_tables": ["personfriend", "person"], "description": "This virtual table provides a list of distinct friends and their names along with the ages of those friends who are older than the average age of all persons in the 'Person' table. The placeholders in the query allow for dynamic filtering based on the average age calculation.", "virtual_table": "SELECT DISTINCT T2.name ,  T2.friend ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.age  >  (SELECT avg(age) FROM person)"}
{"sample_id": "train.4467", "db_id": "network_2", "question": "Whare the names, friends, and ages of all people who are older than the average age of a person?", "rationale": ["The query identifies the relevant tables, 'Person' and 'PersonFriend'.", "It selects distinct names and friends from the 'PersonFriend' table and the age from the 'Person' table.", "A JOIN operation is performed on the names to link friends to their respective ages.", "A condition is added to filter friends whose age is greater than the average age calculated from the 'Person' table."], "gold_sql": "SELECT DISTINCT T2.name ,  T2.friend ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.age  >  (SELECT avg(age) FROM person)", "source_tables": ["personfriend", "person"], "description": "This virtual table provides a list of distinct friends and their names along with the ages of those friends who are older than the average age of all persons in the 'Person' table. The placeholders in the query allow for dynamic filtering based on the average age calculation.", "virtual_table": "SELECT DISTINCT T2.name ,  T2.friend ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.age  >  (SELECT avg(age) FROM person)"}
{"sample_id": "train.4473", "db_id": "network_2", "question": "What are the names of all people who are friends with Alice for the shortest amount of time?", "rationale": ["The query identifies the relevant table, which is 'PersonFriend'.", "Select the column to display, 'name', which represents the person who has the specified friend.", "Add a condition to filter the 'friend' column for the specified friend's name using a placeholder for string values.", "Include a subquery to find the minimum year of friendship for the specified friend, ensuring that the results are filtered by the earliest established friendship."], "gold_sql": "SELECT name FROM PersonFriend WHERE friend =  'Alice' AND YEAR  =  (SELECT min(YEAR) FROM PersonFriend WHERE friend =  'Alice')", "source_tables": ["personfriend"], "description": "This virtual table describes the names of persons who have a specific friend, filtered by the year when the friendship was established. The placeholders in the WHERE clause represent the friend's name and the year of the friendship.", "virtual_table": "SELECT name FROM PersonFriend WHERE friend =  [PLACEHOLDER-TYPE:STRING] AND YEAR  =  (SELECT min(YEAR) FROM PersonFriend WHERE friend =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.4475", "db_id": "network_2", "question": "What are the names, ages, and jobs of all people who are friends with Alice for the longest amount of time?", "rationale": ["The query identifies the relevant tables, 'Person' and 'PersonFriend'.", "It selects the columns 'name', 'age', and 'job' from the 'Person' table.", "A JOIN operation is performed on the 'name' column to link 'Person' and 'PersonFriend'.", "Conditions are added to filter results based on the specified friend's name and the most recent year of friendship using subquery with a placeholder for string values."], "gold_sql": "SELECT T1.name ,  T1.age ,  T1.job FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend =  'Alice' AND T2.year  =  (SELECT max(YEAR) FROM PersonFriend WHERE friend =  'Alice')", "source_tables": ["personfriend", "person"], "description": "This virtual table provides the names, ages, and job titles of individuals from the 'Person' table who have a specific friend, along with the most recent year of friendship established with that friend. The placeholders in the WHERE clause represent the friend's name.", "virtual_table": "SELECT T1.name ,  T1.age ,  T1.job FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend =  [PLACEHOLDER-TYPE:STRING] AND T2.year  =  (SELECT max(YEAR) FROM PersonFriend WHERE friend =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.4478", "db_id": "network_2", "question": "Which person whose friends have the oldest average age?", "rationale": ["The query identifies the relevant tables, 'Person' and 'PersonFriend'.", "It selects the friend's name from 'PersonFriend' and calculates the average age of friends from 'Person'.", "A JOIN operation is performed on the names to link friends with their ages.", "The results are grouped by the friend's name to calculate the average age for each friend.", "The results are ordered by the average age in descending order and limited by a placeholder for numeric values."], "gold_sql": "SELECT T2.name ,  avg(T1.age) FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend GROUP BY T2.name ORDER BY avg(T1.age) DESC LIMIT 1", "source_tables": ["personfriend", "person"], "description": "This virtual table provides the names of friends along with the average age of their respective friends from the 'Person' table. The results are grouped by the friend's name and ordered by the average age in descending order, with a limit on the number of results specified by a placeholder.", "virtual_table": "SELECT T2.name ,  avg(T1.age) FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend GROUP BY T2.name ORDER BY avg(T1.age) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4480", "db_id": "network_2", "question": "What is the total number of people who has no friend living in the city of Austin.", "rationale": ["The query identifies the relevant table, which is 'PersonFriend'.", "It counts the distinct names of persons who have friends.", "A subquery is used to filter out friends based on their city of residence from the 'Person' table, using a placeholder for the city name."], "gold_sql": "SELECT count(DISTINCT name) FROM PersonFriend WHERE friend NOT IN (SELECT name FROM person WHERE city  =  'Austin')", "source_tables": ["personfriend", "person"], "description": "This virtual table counts the number of distinct persons from the 'PersonFriend' table who have friends that do not reside in a specified city. The placeholder in the WHERE clause represents the name of the city to filter out friends.", "virtual_table": "SELECT count(DISTINCT name) FROM PersonFriend WHERE friend NOT IN (SELECT name FROM person WHERE city  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.4503", "db_id": "document_management", "question": "Find the types of documents with more than 4 documents.", "rationale": ["The query identifies the relevant table, which is 'Documents'.", "It selects the 'document_type_code' to display the different types of documents.", "The query groups the results by 'document_type_code' to aggregate the data.", "A condition is added to filter the groups using the HAVING clause to include only those with an access count greater than a specified number, using a placeholder for numeric values."], "gold_sql": "SELECT document_type_code FROM documents GROUP BY document_type_code HAVING count(*)  >  4", "source_tables": ["documents"], "description": "This virtual table provides a summary of the different types of documents stored in the 'Documents' table. It groups the documents by their type and filters the results to show only those document types that have been accessed more than a specified number of times, represented by a placeholder for numeric values.", "virtual_table": "SELECT document_type_code FROM documents GROUP BY document_type_code HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4504", "db_id": "document_management", "question": "What are the codes of types of documents of which there are for or more?", "rationale": ["The query identifies the relevant table, which is 'Documents'.", "It selects the 'document_type_code' to display the different types of documents.", "The query groups the results by 'document_type_code' to aggregate the data.", "A condition is added to filter the groups using the HAVING clause to show only those with an access count greater than a specified number, using a placeholder for numeric values."], "gold_sql": "SELECT document_type_code FROM documents GROUP BY document_type_code HAVING count(*)  >  4", "source_tables": ["documents"], "description": "This virtual table provides a summary of the different types of documents stored in the 'Documents' table. It groups the documents by their type and filters the results to show only those document types that have been accessed more than a specified number of times, represented by a placeholder for numeric values.", "virtual_table": "SELECT document_type_code FROM documents GROUP BY document_type_code HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4505", "db_id": "document_management", "question": "Find the total access count of all documents in the most popular document type.", "rationale": ["The query identifies the relevant table, which is 'Documents'.", "It calculates the total access count for each document type using the SUM function.", "The results are grouped by 'document_type_code' to aggregate access counts for each type.", "The results are ordered by the count of documents in descending order to prioritize the most accessed types.", "A placeholder is included in the LIMIT clause to allow the user to specify how many document types they want to retrieve."], "gold_sql": "SELECT sum(access_count) FROM documents GROUP BY document_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["documents"], "description": "This virtual table summarizes the total access counts of documents grouped by their type. The placeholder in the LIMIT clause allows the user to specify the maximum number of document types to retrieve based on their access counts.", "virtual_table": "SELECT sum(access_count) FROM documents GROUP BY document_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4525", "db_id": "document_management", "question": "Find names of the document without any images.", "rationale": ["The query identifies the relevant table, which is 'Documents'.", "It selects the 'document_name' column to display the names of the documents.", "The EXCEPT clause is used to exclude document names that are found in a join between 'Documents', 'Document_Sections', and 'Document_Sections_Images', effectively filtering out documents that have associated images."], "gold_sql": "SELECT document_name FROM documents EXCEPT SELECT t1.document_name FROM documents AS t1 JOIN document_sections AS t2 ON t1.document_code  =  t2.document_code JOIN document_sections_images AS t3 ON t2.section_id  =  t3.section_id", "source_tables": ["document_sections", "document_sections_images", "documents"], "description": "This virtual table lists the names of documents from the 'Documents' table that do not have any associated images in their sections. The query uses an EXCEPT clause to filter out document names that are linked to sections containing images, ensuring only documents without images are returned.", "virtual_table": "SELECT document_name FROM documents EXCEPT SELECT t1.document_name FROM documents AS t1 JOIN document_sections AS t2 ON t1.document_code  =  t2.document_code JOIN document_sections_images AS t3 ON t2.section_id  =  t3.section_id"}
{"sample_id": "train.4532", "db_id": "document_management", "question": "Count the number of users that are logged in.", "rationale": ["The query identifies the relevant table, which is 'Users'.", "It uses the COUNT function to count the total number of records that match the specified condition.", "The condition filters the records based on the 'user_login' column, using a placeholder for numeric values."], "gold_sql": "SELECT count(*) FROM users WHERE user_login  =  1", "source_tables": ["users"], "description": "This virtual table counts the number of users in the 'Users' table based on a specific login username. The placeholder in the WHERE clause represents the user's login name.", "virtual_table": "SELECT count(*) FROM users WHERE user_login  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4733", "db_id": "department_store", "question": "Return the distinct name of customers whose order status is Pending, in the order of customer id.", "rationale": ["The query identifies the relevant tables, which are 'Customers' and 'Customer_Orders'.", "It selects distinct customer names from the 'Customers' table.", "A JOIN operation is performed on 'Customer_Orders' to link customers with their orders based on the customer ID.", "A condition is added to filter the results based on the specified order status code using a placeholder for string values.", "The results are ordered by the customer ID."], "gold_sql": "SELECT DISTINCT T1.customer_name FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  'Pending' ORDER BY T2.customer_id", "source_tables": ["customer_orders", "customers"], "description": "This virtual table provides a list of distinct customer names from the 'Customers' table who have placed orders with a specific status. The placeholder in the WHERE clause represents the order status code that is being filtered.", "virtual_table": "SELECT DISTINCT T1.customer_name FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T2.customer_id"}
{"sample_id": "train.4736", "db_id": "department_store", "question": "What are the names and addressed of customers who have both New and Pending orders?", "rationale": ["The query identifies the relevant table, which is 'Customers' and 'Customer_Orders'.", "It selects the columns to display, 'customer_name' and 'customer_address'.", "The JOIN operation links the 'Customers' table with the 'Customer_Orders' table based on the 'customer_id'.", "The WHERE clause filters the results based on the 'order_status_code', using a placeholder for string values.", "The INTERSECT operation is used to find common customers who have multiple orders with the same status."], "gold_sql": "SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  'New' INTERSECT SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  'Pending'", "source_tables": ["customer_orders", "customers"], "description": "This virtual table provides the names and addresses of customers who have placed orders with a specific status. The query uses an INTERSECT operation to find customers who have multiple orders with the same status, represented by a placeholder in the WHERE clause.", "virtual_table": "SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4749", "db_id": "department_store", "question": "Find the id and name of the staff who has been assigned for the shortest period.", "rationale": ["The query identifies the relevant tables, which are 'Staff' and 'Staff_Department_Assignments'.", "It selects the 'staff_id' and 'staff_name' columns from the 'Staff' table.", "A JOIN operation is performed between 'Staff' and 'Staff_Department_Assignments' on the 'staff_id' to filter staff members with department assignments.", "The results are ordered by the duration of the assignment, calculated as 'date_assigned_to' minus 'date_assigned_from'.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.staff_id ,  T1.staff_name FROM staff AS T1 JOIN Staff_Department_Assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY date_assigned_to - date_assigned_from LIMIT 1", "source_tables": ["staff_department_assignments", "staff"], "description": "This virtual table provides a list of staff members along with their unique identifiers from the 'Staff' table. It joins the 'Staff' table with the 'Staff_Department_Assignments' table to include only those staff members who have been assigned to a department. The results are ordered by the duration of their assignment, calculated as the difference between the end date and the start date of their assignment. The placeholder in the LIMIT clause allows for specifying the maximum number of records to return.", "virtual_table": "SELECT T1.staff_id ,  T1.staff_name FROM staff AS T1 JOIN Staff_Department_Assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY date_assigned_to - date_assigned_from LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
