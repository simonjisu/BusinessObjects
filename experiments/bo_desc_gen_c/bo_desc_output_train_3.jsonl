{"sample_id": "train.6698", "db_id": "driving_school", "question": "How many lessons were in cancelled state?", "rationale": ["The query identifies the relevant table, which is 'Lessons'.", "It selects a count of all records to determine the total number of lessons.", "A condition is added to filter the results based on the 'lesson_status_code' using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM Lessons WHERE lesson_status_code = 'Cancelled';", "source_tables": ["lessons"], "description": "This virtual table provides the total number of lessons from the 'Lessons' table that have a specific status. The placeholder in the WHERE clause represents the lesson's status code.", "virtual_table": "SELECT count(*) FROM Lessons WHERE lesson_status_code = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.6324", "db_id": "e_government", "question": "Find the last name of the first ever contact person of the organization with the highest UK Vat number.", "rationale": ["The query identifies the relevant tables: 'organizations', 'organization_contact_individuals', and 'individuals'.", "It selects the 'individual_last_name' from the 'individuals' table.", "The query joins the 'organizations' table with 'organization_contact_individuals' on 'organization_id' and then joins 'organization_contact_individuals' with 'individuals' on 'individual_id'.", "A subquery is used to find the maximum 'uk_vat_number' from the 'organizations' table to filter the main query.", "The results are ordered by 'date_contact_to' in ascending order to prioritize the most recent contacts.", "The LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT t3.individual_last_name FROM organizations AS t1 JOIN organization_contact_individuals AS t2 ON t1.organization_id  =  t2.organization_id JOIN individuals AS t3 ON t2.individual_id  =  t3.individual_id WHERE t1.uk_vat_number  =  (SELECT max(uk_vat_number) FROM organizations) ORDER BY t2.date_contact_to ASC LIMIT 1", "source_tables": ["organizations", "organization_contact_individuals", "individuals"], "description": "This virtual table retrieves the last names of individuals who have contacted the organization with the highest VAT number. The query joins the 'organizations', 'organization_contact_individuals', and 'individuals' tables to filter the results based on the maximum VAT number and orders the results by the contact end date. The placeholder in the LIMIT clause represents the maximum number of results to return.", "virtual_table": "SELECT t3.individual_last_name FROM organizations AS t1 JOIN organization_contact_individuals AS t2 ON t1.organization_id  =  t2.organization_id JOIN individuals AS t3 ON t2.individual_id  =  t3.individual_id WHERE t1.uk_vat_number  =  (SELECT max(uk_vat_number) FROM organizations) ORDER BY t2.date_contact_to ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6331", "db_id": "e_government", "question": "What are the names of all cities and states?", "rationale": ["The query identifies the relevant table, which is 'Addresses'.", "It selects the 'town_city' column and the 'state_province_county' column.", "The UNION operator is used to combine the results from both columns, ensuring that only unique values are returned."], "gold_sql": "SELECT town_city FROM addresses UNION SELECT state_province_county FROM addresses", "source_tables": ["addresses"], "description": "This virtual table provides a combined list of town/city names and state/province/county names from the 'Addresses' table. The use of UNION allows for the retrieval of unique entries from both columns, ensuring that the results do not contain duplicates.", "virtual_table": "SELECT town_city FROM addresses UNION SELECT state_province_county FROM addresses"}
{"sample_id": "train.6323", "db_id": "e_government", "question": "What is the last name of the contact individual from the Labour party organization who was contacted most recently?", "rationale": ["The query identifies the relevant tables: 'organizations', 'organization_contact_individuals', and 'individuals'.", "It selects the 'individual_last_name' from the 'individuals' table.", "The JOIN operations link the organizations to their contact individuals through the 'organization_contact_individuals' table.", "A condition is added to filter results based on the specified organization name using a placeholder for string values.", "The results are ordered by 'date_contact_to' in descending order to show the most recent contacts first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT t3.individual_last_name FROM organizations AS t1 JOIN organization_contact_individuals AS t2 ON t1.organization_id  =  t2.organization_id JOIN individuals AS t3 ON t2.individual_id  =  t3.individual_id WHERE t1.organization_name  =  'Labour Party' ORDER BY t2.date_contact_to DESC LIMIT 1", "source_tables": ["organizations", "organization_contact_individuals", "individuals"], "description": "This virtual table provides the last names of individuals who have contacted a specific organization. The organization is identified by its name, and the results are ordered by the end date of the contact period, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the organization name and the number of results to display.", "virtual_table": "SELECT t3.individual_last_name FROM organizations AS t1 JOIN organization_contact_individuals AS t2 ON t1.organization_id  =  t2.organization_id JOIN individuals AS t3 ON t2.individual_id  =  t3.individual_id WHERE t1.organization_name  =  [PLACEHOLDER-TYPE:STRING] ORDER BY t2.date_contact_to DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6328", "db_id": "e_government", "question": "Find name of the services that has never been used.", "rationale": ["The query identifies the relevant table, which is 'Services'.", "It selects the 'service_name' column to display the names of the services.", "The EXCEPT clause is used to filter out service names that are linked to any bookings in the 'Party_Services' table, ensuring only unbooked services are listed."], "gold_sql": "SELECT service_name FROM services EXCEPT SELECT t1.service_name FROM services AS t1 JOIN party_services AS t2 ON t1.service_id  =  t2.service_id", "source_tables": ["services", "party_services"], "description": "This virtual table lists the names of services from the 'Services' table that have not been booked by any party. The query uses an EXCEPT clause to exclude service names that are present in the 'Party_Services' table, indicating that those services have been booked. The placeholder in the query allows for future modifications to filter or adjust the selection criteria as needed.", "virtual_table": "SELECT service_name FROM services EXCEPT SELECT t1.service_name FROM services AS t1 JOIN party_services AS t2 ON t1.service_id  =  t2.service_id"}
{"sample_id": "train.6343", "db_id": "e_government", "question": "Give the state corresponding to the line number building \"6862 Kaitlyn Knolls\".", "rationale": ["The query identifies the relevant table, which is 'Addresses'.", "Select the column to display, 'state_province_county'.", "Add a condition to filter the 'line_1_number_building' column using the LIKE operator with a placeholder for string values."], "gold_sql": "SELECT state_province_county FROM addresses WHERE line_1_number_building LIKE '%6862 Kaitlyn Knolls%'", "source_tables": ["addresses"], "description": "This virtual table retrieves the state, province, or county information from the 'Addresses' table based on a specific address line that matches a given pattern. The placeholder in the LIKE clause allows for flexible searching of address lines.", "virtual_table": "SELECT state_province_county FROM addresses WHERE line_1_number_building LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.437", "db_id": "flight_1", "question": "What is the salary and name of the employee who has the most number of certificates on aircrafts with distance more than 5000?", "rationale": ["The query identifies the relevant tables: 'Employee', 'Certificate', and 'Aircraft'.", "It selects the 'name' column from the 'Employee' table.", "The query joins the 'Employee' table with the 'Certificate' table on the employee ID, and then joins the 'Certificate' table with the 'Aircraft' table on the aircraft ID.", "A condition is added to filter aircraft based on their maximum travel distance using a placeholder for numeric values.", "The results are grouped by employee ID to count the number of certificates held by each employee.", "The results are ordered in descending order based on the count of certificates, and a limit is applied to restrict the number of results returned."], "gold_sql": "SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  5000 GROUP BY T1.eid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employee", "certificate", "aircraft"], "description": "This virtual table provides the names of employees who hold certificates for aircraft that can travel a distance greater than a specified value. The results are grouped by employee ID and ordered by the number of certificates held, with a limit on the number of results returned.", "virtual_table": "SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.eid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.429", "db_id": "flight_1", "question": "Show names for all employees who do not have certificate of Boeing 737-800.", "rationale": ["The query identifies the relevant table, which is 'Employee'.", "It selects the 'name' column to display the names of employees.", "The EXCEPT clause is used to exclude employees who hold a certificate for a specific aircraft model.", "A JOIN operation is performed between 'Employee', 'Certificate', and 'Aircraft' to filter out employees based on the aircraft model using a placeholder for string values."], "gold_sql": "SELECT name FROM Employee EXCEPT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  'Boeing 737-800'", "source_tables": ["employee", "certificate", "aircraft"], "description": "This virtual table lists the names of employees from the 'Employee' table who do not hold a certificate for a specific aircraft model. The placeholder in the query represents the name of the aircraft model.", "virtual_table": "SELECT name FROM Employee EXCEPT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.402", "db_id": "flight_1", "question": "What is the average distance and price for all flights from LA?", "rationale": ["The query identifies the relevant table, which is 'Flight'.", "It selects the average values of 'distance' and 'price' columns.", "A condition is added to filter the results based on the 'origin' column using a placeholder for string values."], "gold_sql": "SELECT avg(distance) ,  avg(price) FROM Flight WHERE origin  =  'Los Angeles'", "source_tables": ["flight"], "description": "This virtual table calculates the average distance and average price of flights originating from a specific location. The placeholder in the WHERE clause represents the origin of the flights.", "virtual_table": "SELECT avg(distance) ,  avg(price) FROM Flight WHERE origin  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.434", "db_id": "flight_1", "question": "What is the name and distance of every aircraft that can cover a distance of more than 5000 and which at least 5 people can fly?", "rationale": ["The query identifies the relevant tables, 'Certificate' and 'Aircraft', to retrieve the necessary data.", "It selects the 'name' column from the 'Aircraft' table.", "A JOIN operation is performed between 'Certificate' and 'Aircraft' on the aircraft ID to link certifications to their respective aircraft.", "A condition is added to filter aircraft based on their maximum travel distance using a placeholder for numeric values.", "The results are grouped by aircraft ID to aggregate the data appropriately.", "An ORDER BY clause is included to filter the results based on the count of certifications that meet a specified threshold using a placeholder for numeric values."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  5000 GROUP BY T1.aid ORDER BY count(*)  >=  5", "source_tables": ["aircraft", "certificate"], "description": "This virtual table provides the names of aircraft that have been certified by employees, filtered by the maximum distance the aircraft can travel. The results are grouped by aircraft ID and ordered based on the count of certifications that meet a specified threshold.", "virtual_table": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.aid ORDER BY count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.433", "db_id": "flight_1", "question": "Show the name and distance of the aircrafts with more than 5000 distance and which at least 5 people have its certificate.", "rationale": ["The query identifies the relevant tables, 'Certificate' and 'Aircraft', and establishes a join between them based on the aircraft ID.", "It selects the 'name' column from the 'Aircraft' table.", "A condition is added to filter aircraft based on their maximum travel distance using a placeholder for numeric values.", "The results are grouped by aircraft ID to aggregate the data appropriately.", "An ordering condition is applied to filter the results based on the count of certifications that meet a specified threshold using another placeholder for numeric values."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  5000 GROUP BY T1.aid ORDER BY count(*)  >=  5", "source_tables": ["aircraft", "certificate"], "description": "This virtual table provides the names of aircraft that have been certified by employees, filtered by the maximum distance the aircraft can travel. The results are grouped by aircraft ID and ordered based on the count of certifications that meet a specified threshold.", "virtual_table": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.aid ORDER BY count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.408", "db_id": "flight_1", "question": "What place has the most flights coming from there?", "rationale": ["The query identifies the relevant table, which is 'Flight'.", "It selects the 'origin' column to display the starting locations of flights.", "The results are grouped by the 'origin' to aggregate the data based on unique starting locations.", "The query orders the results by the count of flights from each origin in descending order to show the most popular origins first.", "A limit is applied to restrict the number of origins returned, using a placeholder for numeric values."], "gold_sql": "SELECT origin FROM Flight GROUP BY origin ORDER BY count(*) DESC LIMIT 1", "source_tables": ["flight"], "description": "This virtual table provides a list of flight origins from the 'Flight' table, grouped by the origin location. The results are ordered by the number of flights departing from each origin in descending order, with a limit on the number of origins returned as specified by the placeholder.", "virtual_table": "SELECT origin FROM Flight GROUP BY origin ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.407", "db_id": "flight_1", "question": "Which origin has most number of flights?", "rationale": ["The query identifies the relevant table, which is 'Flight'.", "It selects the 'origin' column to display the starting locations of flights.", "The results are grouped by the 'origin' to aggregate the data based on unique starting locations.", "The query orders the results by the count of flights from each origin in descending order to show the most popular origins first.", "A limit is applied to restrict the number of origins returned, using a placeholder for numeric values."], "gold_sql": "SELECT origin FROM Flight GROUP BY origin ORDER BY count(*) DESC LIMIT 1", "source_tables": ["flight"], "description": "This virtual table provides a list of flight origins from the 'Flight' table, grouped by the origin location. The results are ordered by the number of flights departing from each origin in descending order, with a limit on the number of origins returned as specified by the placeholder.", "virtual_table": "SELECT origin FROM Flight GROUP BY origin ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.387", "db_id": "flight_1", "question": "Show origins of all flights with destination Honolulu.", "rationale": ["The query is identifying the relevant table, which is 'Flight'.", "Select the column to display, 'origin'.", "Add a condition to filter the 'destination' column for the specified destination using a placeholder for string values."], "gold_sql": "SELECT origin FROM Flight WHERE destination  =  'Honolulu'", "source_tables": ["flight"], "description": "This virtual table describes the origins of flights from the 'Flight' table that are headed to a specific destination. The placeholder in the WHERE clause represents the destination's name.", "virtual_table": "SELECT origin FROM Flight WHERE destination  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.400", "db_id": "flight_1", "question": "What are the numbers of the shortest flights?", "rationale": ["The query identifies the relevant table, which is 'Flight'.", "Select the column to display, 'flno', which represents the flight number.", "Order the results by the 'distance' column in ascending order to show the shortest flights first.", "Limit the number of results returned using a placeholder for numeric values to specify how many flight numbers to retrieve."], "gold_sql": "SELECT flno FROM Flight ORDER BY distance ASC LIMIT 3", "source_tables": ["flight"], "description": "This virtual table lists the flight numbers from the 'Flight' table, ordered by the distance of each flight in ascending order. The placeholder in the LIMIT clause represents the maximum number of flight numbers to be returned.", "virtual_table": "SELECT flno FROM Flight ORDER BY distance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.241", "db_id": "flight_2", "question": "Find all airlines that have at least 10 flights.", "rationale": ["The query identifies the relevant tables, which are 'airlines' and 'flights'.", "It selects the 'Airline' column from the 'airlines' table, using an alias for clarity.", "A JOIN operation is performed between 'airlines' and 'flights' on the airline identifier to link the two tables.", "The results are grouped by the airline name to aggregate the flight counts.", "The HAVING clause filters the results to include only those airlines that have a flight count greater than a specified number, using a placeholder for numeric values."], "gold_sql": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  >  10", "source_tables": ["flights", "airlines"], "description": "This virtual table lists the names of airlines that operate more than a specified number of flights. The placeholder in the HAVING clause represents the minimum number of flights an airline must operate to be included in the results.", "virtual_table": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.243", "db_id": "flight_2", "question": "Find all airlines that have fewer than 200 flights.", "rationale": ["The query identifies the relevant tables, which are 'airlines' and 'flights'.", "It selects the 'Airline' column from the 'airlines' table.", "A JOIN operation is performed between 'airlines' and 'flights' on the airline identifier to link the two tables.", "The results are grouped by the airline name to aggregate the flight counts.", "The HAVING clause filters the results to include only those airlines that operate fewer flights than the specified number using a placeholder for numeric values."], "gold_sql": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  <  200", "source_tables": ["flights", "airlines"], "description": "This virtual table lists the names of airlines from the 'airlines' table that operate fewer flights than a specified number. The placeholder in the HAVING clause represents the maximum number of flights an airline can operate.", "virtual_table": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.231", "db_id": "flight_2", "question": "Find the abbreviation and country of the airline that has fewest number of flights?", "rationale": ["The query identifies the relevant tables, which are 'airlines' and 'flights'.", "It selects the 'Abbreviation' and 'Country' columns from the 'airlines' table, aliased as T1.", "A JOIN operation is performed between 'airlines' and 'flights' on the airline identifier to link flights to their respective airlines.", "The results are grouped by the 'Airline' to aggregate the data based on the number of flights operated by each airline.", "The results are ordered by the count of flights in descending order to show the most active airlines first.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.Abbreviation ,  T1.Country FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) LIMIT 1", "source_tables": ["flights", "airlines"], "description": "This virtual table provides a summary of the abbreviations and countries of airlines that operate flights. The data is aggregated by airline, showing the most frequently operating airlines based on the number of flights. The placeholder in the LIMIT clause allows the user to specify the maximum number of results to return.", "virtual_table": "SELECT T1.Abbreviation ,  T1.Country FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.242", "db_id": "flight_2", "question": "Which airlines have at least 10 flights?", "rationale": ["The query identifies the relevant tables, which are 'airlines' and 'flights'.", "It selects the 'Airline' column from the 'airlines' table.", "A JOIN operation is performed between 'airlines' and 'flights' on the airline identifier to link the two tables.", "The results are grouped by the airline name to aggregate the flight counts.", "The HAVING clause filters the results to include only those airlines that operate more than a specified number of flights, using a placeholder for the numeric value."], "gold_sql": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  >  10", "source_tables": ["flights", "airlines"], "description": "This virtual table lists the names of airlines from the 'airlines' table that operate more than a specified number of flights. The placeholder in the HAVING clause represents the minimum number of flights an airline must operate to be included in the results.", "virtual_table": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.228", "db_id": "flight_2", "question": "Give the code of the airport with the least flights.", "rationale": ["The query identifies the relevant tables, which are 'airports' and 'flights'.", "It selects the 'AirportCode' from the 'airports' table.", "A JOIN operation is performed between 'airports' and 'flights' on the condition that the airport code matches either the source or destination airport code.", "The results are grouped by 'AirportCode' to ensure uniqueness.", "The results are ordered by the count of occurrences to prioritize the most frequently used airports.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) LIMIT 1", "source_tables": ["airports", "flights"], "description": "This virtual table lists unique airport codes from the 'airports' table that are either source or destination airports for flights in the 'flights' table. The placeholder in the LIMIT clause represents the maximum number of airport codes to return.", "virtual_table": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.230", "db_id": "flight_2", "question": "What airline serves the most flights?", "rationale": ["The query identifies the relevant tables, 'airlines' and 'flights'.", "It selects the 'Airline' column from the 'airlines' table, using an alias for clarity.", "A JOIN operation is performed between 'airlines' and 'flights' on the airline identifier to link the two tables.", "The results are grouped by the airline name to aggregate the flight counts.", "The results are ordered by the count of flights in descending order to show the most active airlines first.", "A limit is applied to restrict the number of results returned based on a placeholder for numeric values."], "gold_sql": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) DESC LIMIT 1", "source_tables": ["flights", "airlines"], "description": "This virtual table provides a list of airlines from the 'airlines' table that are associated with flights in the 'flights' table. The results are grouped by airline name and ordered by the number of flights in descending order, with a limit on the number of airlines returned based on a specified number.", "virtual_table": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.226", "db_id": "flight_2", "question": "What is the airport code of the airport with the most flights?", "rationale": ["The query identifies the relevant tables, 'airports' and 'flights'.", "It selects the 'AirportCode' from the 'airports' table.", "A JOIN operation is performed between 'airports' and 'flights' on the condition that the airport code matches either the source or destination airport code.", "The results are grouped by 'AirportCode' to aggregate the data.", "The results are ordered by the count of flights associated with each airport in descending order.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "flights"], "description": "This virtual table lists the airport codes from the 'airports' table that are either source or destination airports for flights in the 'flights' table. The results are grouped by airport code and ordered by the number of flights associated with each airport, with a limit on the number of results returned based on a specified number.", "virtual_table": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.246", "db_id": "flight_2", "question": "Which flight numbers correspond to United Airlines flights?", "rationale": ["The query identifies the relevant tables, which are 'flights' and 'airlines'.", "It selects the 'FlightNo' column from the 'flights' table.", "A JOIN operation is performed between 'flights' and 'airlines' on the airline identifier to link the two tables.", "A condition is added to filter the results based on the specified airline name using a placeholder for string values."], "gold_sql": "SELECT T1.FlightNo FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T2.uid  =  T1.Airline WHERE T2.Airline  =  'United Airlines'", "source_tables": ["flights", "airlines"], "description": "This virtual table provides the unique flight numbers from the 'flights' table for a specific airline. The placeholder in the WHERE clause represents the name of the airline being queried.", "virtual_table": "SELECT T1.FlightNo FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T2.uid  =  T1.Airline WHERE T2.Airline  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.245", "db_id": "flight_2", "question": "What are flight numbers of Airline \"United Airlines\"?", "rationale": ["The query identifies the relevant tables, which are 'flights' and 'airlines'.", "It selects the 'FlightNo' column from the 'flights' table.", "A JOIN operation is performed between 'flights' and 'airlines' on the airline identifier to link the two tables.", "A condition is added to filter the results based on the specified airline name using a placeholder for string values."], "gold_sql": "SELECT T1.FlightNo FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T2.uid  =  T1.Airline WHERE T2.Airline  =  'United Airlines'", "source_tables": ["flights", "airlines"], "description": "This virtual table provides the unique flight numbers from the 'flights' table for a specific airline. The placeholder in the WHERE clause represents the name of the airline being queried.", "virtual_table": "SELECT T1.FlightNo FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T2.uid  =  T1.Airline WHERE T2.Airline  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.182", "db_id": "flight_2", "question": "Which abbreviation corresponds to Jetblue Airways?", "rationale": ["The query identifies the relevant table, which is 'airlines'.", "Select the column to display, 'Abbreviation'.", "Add a condition to filter the 'Airline' column for the specified airline name using a placeholder for string values."], "gold_sql": "SELECT Abbreviation FROM AIRLINES WHERE Airline  =  'JetBlue Airways'", "source_tables": ["airlines"], "description": "This virtual table provides the abbreviation of a specific airline from the 'airlines' table based on the airline's name. The placeholder in the WHERE clause represents the name of the airline.", "virtual_table": "SELECT Abbreviation FROM AIRLINES WHERE Airline  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.213", "db_id": "flight_2", "question": "How many flights does airline 'JetBlue Airways' have?", "rationale": ["The query identifies the relevant tables, which are 'flights' and 'airlines'.", "It uses a JOIN operation to connect the 'flights' table with the 'airlines' table based on the airline's unique identifier.", "The SELECT statement counts the total number of flights for the specified airline.", "A condition is added to filter the results by the airline's name using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T1.Airline  =  T2.uid WHERE T2.Airline = 'JetBlue Airways'", "source_tables": ["flights", "airlines"], "description": "This virtual table provides the count of flights operated by a specific airline from the 'flights' table. It joins the 'flights' table with the 'airlines' table to filter the results based on the airline's name. The placeholder in the WHERE clause represents the name of the airline.", "virtual_table": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T1.Airline  =  T2.uid WHERE T2.Airline = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6857", "db_id": "flight_4", "question": "List the cities which have more than 2 airports sorted by the number of airports.", "rationale": ["The query identifies the relevant table, which is 'airports'.", "Select the 'city' column to display the cities with airports.", "Group the results by 'city' to aggregate the data.", "Use the HAVING clause to filter cities that have a count of airports greater than a specified number, using a placeholder for numeric values.", "Order the results by the count of airports in ascending order."], "gold_sql": "SELECT city FROM airports GROUP BY city HAVING count(*)  >  2 ORDER BY count(*)", "source_tables": ["airports"], "description": "This virtual table provides a list of cities that have more than a specified number of airports. The placeholder in the HAVING clause represents the minimum count of airports required for a city to be included in the results.", "virtual_table": "SELECT city FROM airports GROUP BY city HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER] ORDER BY count(*)"}
{"sample_id": "train.6852", "db_id": "flight_4", "question": "What is the number of cities in the United States with more than 3 airports?", "rationale": ["The query identifies the relevant table, which is 'airports'.", "Select the column to display, 'city'.", "Add a condition to filter the 'country' column for the specified country using a placeholder for string values.", "Group the results by 'city' to aggregate the data.", "Use the HAVING clause to filter cities that have a count of airports greater than a specified number, using a placeholder for numeric values."], "gold_sql": "SELECT city FROM airports WHERE country  =  'United States' GROUP BY city HAVING count(*)  >  3", "source_tables": ["airports"], "description": "This virtual table provides a list of cities from the 'airports' table that are located in a specific country. The results are grouped by city, and only those cities with more than a specified number of airports are included. The placeholders in the WHERE clause represent the country's name, and the HAVING clause represents the minimum count of airports required for a city to be included in the results.", "virtual_table": "SELECT city FROM airports WHERE country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY city HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6881", "db_id": "flight_4", "question": "Find the busiest source airport that runs most number of routes in China.", "rationale": ["The query identifies the relevant tables, which are 'airports' and 'routes'.", "It selects the 'name' column from the 'airports' table, aliased as T1.", "A JOIN operation is performed between 'airports' (T1) and 'routes' (T2) on the source airport ID to link routes to their respective airports.", "A condition is added to filter the results based on the specified country using a placeholder for string values.", "The results are grouped by the airport name to aggregate the data.", "The results are ordered by the count of routes in descending order to show the most active airports first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid WHERE T1.country  =  'China' GROUP BY T1.name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "description": "This virtual table provides a list of airport names from the 'airports' table that are located in a specific country. It joins the 'airports' table with the 'routes' table to filter the airports based on their country and counts the number of routes originating from each airport. The results are grouped by airport name and ordered by the number of routes in descending order, with a limit on the number of results returned.", "virtual_table": "SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid WHERE T1.country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6837", "db_id": "flight_4", "question": "Find the name and city of the airport which is the source for the most number of flight routes.", "rationale": ["The query identifies the relevant tables, which are 'airports' and 'routes'.", "It selects the 'name' and 'city' from the 'airports' table and the 'src_apid' from the 'routes' table.", "A JOIN operation is performed on the 'apid' of 'airports' and 'src_apid' of 'routes' to link the data.", "The results are grouped by 'src_apid' to aggregate the data based on source airports.", "The results are ordered by the count of routes in descending order to show the most active source airports first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.name ,  T1.city ,  T2.src_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T2.src_apid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "description": "The virtual table describes the names and cities of airports that serve as source airports for routes, along with their unique identifiers. The results are grouped by the source airport ID and ordered by the number of routes originating from each airport, limited to a specified number of results.", "virtual_table": "SELECT T1.name ,  T1.city ,  T2.src_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T2.src_apid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6844", "db_id": "flight_4", "question": "What are the countries with the most airlines whose active status is Y?", "rationale": ["The query identifies the relevant table, which is 'airlines'.", "It selects the 'country' column to display the countries of the airlines.", "A condition is added to filter the results based on the 'active' status of the airlines using a placeholder for string values.", "The results are grouped by 'country' to aggregate the data accordingly.", "The results are ordered by the count of airlines in each country in descending order, and a limit is set to restrict the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT country FROM airlines WHERE active  =  'Y' GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airlines"], "description": "This virtual table provides a list of countries where active airlines are based, grouped by country. The placeholder in the WHERE clause indicates whether to filter for active airlines, and the LIMIT placeholder specifies the maximum number of countries to return, sorted by the number of active airlines in descending order.", "virtual_table": "SELECT country FROM airlines WHERE active  =  [PLACEHOLDER-TYPE:STRING] GROUP BY country ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6843", "db_id": "flight_4", "question": "Which countries has the most number of airlines whose active status is 'Y'?", "rationale": ["The query identifies the relevant table, which is 'airlines'.", "It selects the 'country' column to display the countries of the airlines.", "A condition is added to filter the results based on the 'active' status of the airlines using a placeholder for string values.", "The results are grouped by 'country' to aggregate the data.", "The results are ordered by the count of airlines in each country in descending order.", "A limit is applied to restrict the number of countries returned, using a placeholder for numeric values."], "gold_sql": "SELECT country FROM airlines WHERE active  =  'Y' GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airlines"], "description": "This virtual table provides a list of countries where active airlines are based, grouped by country. The placeholder in the WHERE clause indicates whether to filter for active airlines, and the LIMIT placeholder specifies the maximum number of countries to return, ordered by the number of active airlines in descending order.", "virtual_table": "SELECT country FROM airlines WHERE active  =  [PLACEHOLDER-TYPE:STRING] GROUP BY country ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6833", "db_id": "flight_4", "question": "Find the name and city of the airport which is the destination of the most number of routes.", "rationale": ["The query identifies the relevant tables, which are 'airports' and 'routes'.", "It selects the 'name' and 'city' columns from the 'airports' table (aliased as T1) and the 'dst_apid' from the 'routes' table (aliased as T2).", "A JOIN operation is performed on the 'apid' of the 'airports' table and the 'dst_apid' of the 'routes' table to link the two tables based on destination airport IDs.", "The results are grouped by 'dst_apid' to aggregate the data for each destination airport.", "The results are ordered by the count of routes to each destination in descending order, and a limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.name ,  T1.city ,  T2.dst_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid GROUP BY T2.dst_apid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "description": "This virtual table provides a list of destination airport names and their corresponding cities from the 'airports' table, along with the destination airport IDs from the 'routes' table. The results are grouped by destination airport ID and ordered by the count of routes to each destination, limited to a specified number of results.", "virtual_table": "SELECT T1.name ,  T1.city ,  T2.dst_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid GROUP BY T2.dst_apid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6859", "db_id": "flight_4", "question": "Find the number of routes for each source airport and the airport name.", "rationale": ["The query identifies the relevant tables, which are 'airports' and 'routes'.", "It selects the count of routes and the name of the airport from the 'airports' table.", "A JOIN operation is performed between 'airports' and 'routes' on the source airport ID to link the two tables.", "The results are grouped by the airport name to provide a count of routes for each airport."], "gold_sql": "SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name", "source_tables": ["airports", "routes"], "description": "This virtual table provides a count of routes originating from each airport, along with the names of those airports. The placeholder in the SELECT statement represents the count of routes, while the GROUP BY clause groups the results by the airport names.", "virtual_table": "SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name"}
{"sample_id": "train.6860", "db_id": "flight_4", "question": "For each airport name, how many routes start at that airport?", "rationale": ["The query identifies the relevant tables, which are 'airports' and 'routes'.", "It selects the count of routes and the name of the airport from the 'airports' table.", "A JOIN operation is performed between 'airports' and 'routes' on the source airport ID to link the two tables.", "The results are grouped by the airport name to provide a count of routes for each airport."], "gold_sql": "SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name", "source_tables": ["airports", "routes"], "description": "This virtual table provides a count of routes originating from each airport, along with the names of those airports. The placeholder in the SELECT statement represents the count of routes, while the GROUP BY clause groups the results by the airport names.", "virtual_table": "SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name"}
{"sample_id": "train.6879", "db_id": "flight_4", "question": "Find the name of airline which runs the most number of routes.", "rationale": ["The query identifies the relevant tables, which are 'airlines' and 'routes'.", "It selects the 'name' column from the 'airlines' table, which contains the names of the airlines.", "A JOIN operation is performed between 'airlines' and 'routes' on the airline ID to associate each airline with its routes.", "The results are grouped by airline name to aggregate the count of routes for each airline.", "The results are ordered in descending order based on the count of routes, so that the airlines with the most routes appear first.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.name FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["routes", "airlines"], "description": "The virtual table describes the names of airlines that operate the most routes, based on the data from the 'airlines' and 'routes' tables. The placeholder in the LIMIT clause represents the maximum number of airline names to return.", "virtual_table": "SELECT T1.name FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6846", "db_id": "flight_4", "question": "How many airlines operate out of each country in descending order?", "rationale": ["The query identifies the relevant table, which is 'airlines'.", "It selects the 'country' column and counts the number of entries for each country using the COUNT function.", "The GROUP BY clause is used to aggregate the results by country, and the ORDER BY clause sorts the results in descending order based on the count of airlines."], "gold_sql": "SELECT country ,  count(*) FROM airlines GROUP BY country ORDER BY count(*) DESC", "source_tables": ["airlines"], "description": "This virtual table summarizes the number of airlines grouped by their country of origin. The placeholder in the SELECT statement allows for dynamic querying of the country and the count of airlines associated with it.", "virtual_table": "SELECT country ,  count(*) FROM airlines GROUP BY country ORDER BY count(*) DESC"}
{"sample_id": "train.6836", "db_id": "flight_4", "question": "For the airline ids with the top 10 most routes operated, what are their names?", "rationale": ["The query identifies the relevant tables, 'airlines' and 'routes'.", "It selects the 'name' column from the 'airlines' table and the 'alid' column from the 'routes' table.", "A JOIN operation is performed on the airline ID to combine data from both tables.", "The results are grouped by the airline ID to aggregate the number of routes per airline.", "The results are ordered by the count of routes in descending order to show the most active airlines first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.name ,  T2.alid FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T2.alid ORDER BY count(*) DESC LIMIT 10", "source_tables": ["routes", "airlines"], "description": "This virtual table provides a list of airline names along with their unique identifiers from the 'airlines' table, based on the routes they operate. The results are grouped by airline ID and ordered by the number of routes in descending order, with a limit set by a placeholder for numeric values.", "virtual_table": "SELECT T1.name ,  T2.alid FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T2.alid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6835", "db_id": "flight_4", "question": "Find the names of the top 10 airlines that operate the most number of routes.", "rationale": ["The query identifies the relevant tables, 'airlines' and 'routes'.", "It selects the 'name' column from the 'airlines' table and the 'alid' column from the 'routes' table.", "A JOIN operation is performed on the airline ID to combine data from both tables.", "The results are grouped by the airline ID to aggregate the number of routes per airline.", "The results are ordered by the count of routes in descending order to show the most active airlines first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.name ,  T2.alid FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T2.alid ORDER BY count(*) DESC LIMIT 10", "source_tables": ["routes", "airlines"], "description": "This virtual table provides a list of airline names along with their unique identifiers from the 'airlines' table, based on the routes they operate. The results are grouped by airline ID and ordered by the number of routes in descending order, with a limit set by a placeholder for numeric values.", "virtual_table": "SELECT T1.name ,  T2.alid FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T2.alid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6874", "db_id": "flight_4", "question": "What is the number of routes that end at John F Kennedy International Airport?", "rationale": ["The query identifies the relevant tables, which are 'airports' and 'routes'.", "It uses a JOIN operation to connect the two tables based on the destination airport ID.", "The SELECT statement counts the number of routes that match the specified destination airport name using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.name  =  'John F Kennedy International Airport'", "source_tables": ["airports", "routes"], "description": "This virtual table provides the count of routes that lead to a specific destination airport from the 'airports' and 'routes' tables. The placeholder in the WHERE clause represents the name of the destination airport.", "virtual_table": "SELECT count(*) FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6822", "db_id": "flight_4", "question": "How many airports' names have the word Interanation in them?", "rationale": ["The query identifies the relevant table, which is 'airports'.", "It selects a count of all records that meet a certain condition.", "The condition filters the 'name' column using a LIKE operator with a placeholder for string values, allowing for partial matches."], "gold_sql": "SELECT count(*) FROM airports WHERE name LIKE '%International%'", "source_tables": ["airports"], "description": "This virtual table provides the count of airports from the 'airports' table that match a specific name pattern. The placeholder in the WHERE clause allows for dynamic input of the airport name to filter the results accordingly.", "virtual_table": "SELECT count(*) FROM airports WHERE name LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6816", "db_id": "flight_4", "question": "What are the countries of all airlines whose names start with Orbit?", "rationale": ["The query identifies the relevant table, which is 'airlines'.", "Select the column to display, 'country'.", "Add a condition to filter the 'name' column using a LIKE operator for pattern matching with a placeholder for string values."], "gold_sql": "SELECT country FROM airlines WHERE name LIKE 'Orbit%'", "source_tables": ["airlines"], "description": "This virtual table provides the country of airlines from the 'airlines' table that match a specific name pattern. The placeholder in the WHERE clause allows for flexible searching of airline names.", "virtual_table": "SELECT country FROM airlines WHERE name LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6872", "db_id": "flight_4", "question": "What is the number of routes operated by the airline American Airlines whose destinations are in Italy?", "rationale": ["The query identifies the relevant tables: 'routes', 'airports', and 'airlines'.", "It uses JOIN operations to connect these tables based on their foreign key relationships: 'dst_apid' from 'routes' with 'apid' from 'airports', and 'alid' from 'routes' with 'alid' from 'airlines'.", "The SELECT statement counts the total number of routes that meet the specified conditions.", "The WHERE clause filters the results based on the country of the destination airport and the name of the airline, using placeholders for these values."], "gold_sql": "SELECT count(*) FROM routes AS T1 JOIN airports AS T2 ON T1.dst_apid  =  T2.apid JOIN airlines AS T3 ON T1.alid  =  T3.alid WHERE T2.country  =  'Italy' AND T3.name  =  'American Airlines'", "source_tables": ["routes", "airlines", "airports"], "description": "This virtual table provides the count of routes that lead to airports located in a specific country and are operated by a particular airline. The placeholders in the WHERE clause represent the country and airline name respectively.", "virtual_table": "SELECT count(*) FROM routes AS T1 JOIN airports AS T2 ON T1.dst_apid  =  T2.apid JOIN airlines AS T3 ON T1.alid  =  T3.alid WHERE T2.country  =  [PLACEHOLDER-TYPE:STRING] AND T3.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6379", "db_id": "flight_company", "question": "List the name of the pilots who have flied for both a company that mainly provide 'Cargo' services and a company that runs 'Catering services' activities.", "rationale": ["The query identifies the relevant tables, which are 'operate_company' and 'flight'.", "It selects the 'pilot' column from the 'flight' table, which is linked to the 'operate_company' table.", "The JOIN operation connects the two tables based on the company ID.", "The WHERE clause filters the results based on the 'principal_activities' of the operating companies, using placeholders for string values.", "The INTERSECT operation is used to find common pilots from two sets of results based on the same principal activities."], "gold_sql": "SELECT T2.pilot FROM operate_company AS T1 JOIN flight AS t2 ON T1.id  =  T2.company_id WHERE T1.principal_activities  =  'Cargo' INTERSECT SELECT T2.pilot FROM operate_company AS T1 JOIN flight AS t2 ON T1.id  =  T2.company_id WHERE T1.principal_activities  =  'Catering services'", "source_tables": ["flight", "operate_company"], "description": "This virtual table describes the pilots operating flights from companies that engage in specific principal activities. The query uses an INTERSECT operation to find pilots from two different sets of operating companies that share the same principal activities, represented by placeholders in the WHERE clause.", "virtual_table": "SELECT T2.pilot FROM operate_company AS T1 JOIN flight AS t2 ON T1.id  =  T2.company_id WHERE T1.principal_activities  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.pilot FROM operate_company AS T1 JOIN flight AS t2 ON T1.id  =  T2.company_id WHERE T1.principal_activities  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6384", "db_id": "flight_company", "question": "which pilot is in charge of the most number of flights?", "rationale": ["The query identifies the relevant table, which is 'flight'.", "Select the column to display, 'pilot', which represents the name of the pilot operating the flight.", "Group the results by the 'pilot' column to aggregate the data based on each pilot's name.", "Order the results by the count of flights operated by each pilot in descending order to show the most active pilots first.", "Limit the number of results returned to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT pilot FROM flight GROUP BY pilot ORDER BY count(*) DESC LIMIT 1", "source_tables": ["flight"], "description": "This virtual table provides a list of pilots from the 'flight' table, grouped by their names. The results are ordered by the number of flights each pilot has operated, in descending order, and limited to a specified number of top pilots. The placeholder in the LIMIT clause represents the maximum number of pilots to be returned.", "virtual_table": "SELECT pilot FROM flight GROUP BY pilot ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6370", "db_id": "flight_company", "question": "What is the velocity of the pilot named 'Thompson'?", "rationale": ["The query identifies the relevant table, which is 'flight'.", "It selects the average of the 'velocity' column to compute the average speed.", "A condition is added to filter the results based on the specified pilot's name using a placeholder for string values."], "gold_sql": "SELECT avg(velocity) FROM flight WHERE pilot  =  'Thompson'", "source_tables": ["flight"], "description": "This virtual table calculates the average speed of flights operated by a specific pilot from the 'flight' table. The placeholder in the WHERE clause represents the name of the pilot.", "virtual_table": "SELECT avg(velocity) FROM flight WHERE pilot  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2179", "db_id": "formula_1", "question": "Find the id and forenames of drivers who participated both the races with name Australian Grand Prix and the races with name Chinese Grand Prix?", "rationale": ["The query identifies the relevant tables: 'races', 'results', and 'drivers'.", "It selects the 'driverId' and 'forename' columns to display the driver's unique identifier and first name.", "The query uses JOIN operations to connect the 'races' table with the 'results' and 'drivers' tables based on their relationships.", "The WHERE clause filters the results based on the names of the races, using placeholders for the race names.", "The INTERSECT operator is used to find drivers who participated in both specified races."], "gold_sql": "SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = 'Australian Grand Prix' INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = 'Chinese Grand Prix'", "source_tables": ["races", "drivers", "results"], "description": "This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.", "virtual_table": "SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2180", "db_id": "formula_1", "question": "What is the id and first name of all the drivers who participated in the Australian Grand Prix and the Chinese Grand Prix?", "rationale": ["The query identifies the relevant tables: 'races', 'results', and 'drivers'.", "It selects the 'driverId' and 'forename' columns to display the unique identifiers and first names of the drivers.", "The query uses JOIN operations to connect the 'races' table with the 'results' and 'drivers' tables based on their relationships.", "The WHERE clause filters the results based on the names of the races, using placeholders for the race names.", "The INTERSECT operator is used to find drivers who participated in both specified races."], "gold_sql": "SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = 'Australian Grand Prix' INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = 'Chinese Grand Prix'", "source_tables": ["races", "drivers", "results"], "description": "This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.", "virtual_table": "SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2181", "db_id": "formula_1", "question": "What are the forenames and surnames of drivers who participated in the races named Australian Grand Prix but not the races named Chinese Grand Prix?", "rationale": ["The query identifies the relevant tables: 'races', 'results', and 'drivers'.", "It selects the columns to display, which are 'forename' and 'surname' from the 'drivers' table.", "The query uses JOINs to connect the 'races' table with the 'results' and 'drivers' tables based on their relationships.", "A condition is added to filter the results based on the name of the race using a placeholder for string values.", "The EXCEPT clause is used to exclude drivers who participated in another specified race, again using a placeholder for the race name."], "gold_sql": "SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Australian Grand Prix' EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Chinese Grand Prix'", "source_tables": ["races", "drivers", "results"], "description": "This virtual table describes the first and last names of drivers who participated in a specific race, excluding those who also participated in another specified race. The placeholders in the WHERE clause represent the names of the races.", "virtual_table": "SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2174", "db_id": "formula_1", "question": "How many drivers did not race in 2009?", "rationale": ["The query identifies the relevant table, which is 'results', to count the distinct drivers.", "It uses a subquery to filter out race IDs from the 'races' table based on the specified year using a placeholder for numeric values.", "The final output is the count of distinct driver IDs from the 'results' table for races that are not in the specified year."], "gold_sql": "SELECT count(DISTINCT driverId) FROM results WHERE raceId NOT IN( SELECT raceId FROM races WHERE YEAR != 2009 )", "source_tables": ["results", "races"], "description": "This virtual table counts the distinct number of drivers who participated in races, excluding those that took place in a specific year. The placeholder in the WHERE clause represents the year to filter out races.", "virtual_table": "SELECT count(DISTINCT driverId) FROM results WHERE raceId NOT IN( SELECT raceId FROM races WHERE YEAR != [PLACEHOLDER-TYPE:NUMBER] )"}
{"sample_id": "train.2223", "db_id": "formula_1", "question": "What are the maximum fastest lap speed in races held after 2004 grouped by race name and ordered by year?", "rationale": ["The query identifies the relevant tables, 'races' and 'results'.", "It selects the maximum fastest lap speed from the 'results' table and the race name and year from the 'races' table.", "A JOIN operation is performed on the raceId to combine data from both tables.", "A condition is added to filter races that occurred after a specified year using a placeholder for numeric values.", "The results are grouped by race name to ensure unique entries and ordered by year."], "gold_sql": "SELECT max(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "description": "This virtual table provides the maximum fastest lap speed recorded for each race, along with the official name of the race and the year it took place. The placeholder in the WHERE clause represents the year threshold for filtering the races.", "virtual_table": "SELECT max(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.name ORDER BY T1.year"}
{"sample_id": "train.2173", "db_id": "formula_1", "question": "How many drivers did not participate in the races held in 2009?", "rationale": ["The query identifies the relevant table, which is 'results', to count distinct drivers.", "It uses a subquery to filter out race IDs from the 'races' table based on the specified year using a placeholder for numeric values.", "The final output is the count of distinct driver IDs from the 'results' table that meet the criteria."], "gold_sql": "SELECT count(DISTINCT driverId) FROM results WHERE raceId NOT IN( SELECT raceId FROM races WHERE YEAR != 2009 )", "source_tables": ["results", "races"], "description": "This virtual table provides the count of distinct drivers who participated in races, excluding those that took place in a specific year. The placeholder in the WHERE clause represents the year to filter out races.", "virtual_table": "SELECT count(DISTINCT driverId) FROM results WHERE raceId NOT IN( SELECT raceId FROM races WHERE YEAR != [PLACEHOLDER-TYPE:NUMBER] )"}
{"sample_id": "train.2190", "db_id": "formula_1", "question": "For each constructor id, how many races are there?", "rationale": ["The query identifies the relevant table, which is 'constructorStandings'.", "It selects a count of entries and groups the results by 'constructorId' to summarize the standings for each constructor."], "gold_sql": "SELECT count(*) ,  constructorid FROM constructorStandings GROUP BY constructorid", "source_tables": ["constructorstandings"], "description": "This virtual table provides a count of the total number of constructor standings grouped by each constructor's identifier from the 'constructorStandings' table. The placeholder in the SELECT clause represents the constructor's ID.", "virtual_table": "SELECT count(*) ,  constructorid FROM constructorStandings GROUP BY constructorid"}
{"sample_id": "train.2217", "db_id": "formula_1", "question": "Find the names of Japanese constructors that have once earned more than 5 points?", "rationale": ["The query identifies the relevant tables, which are 'constructors' and 'constructorStandings'.", "It selects the 'name' column from the 'constructors' table.", "A JOIN operation is performed between 'constructors' and 'constructorStandings' on the 'constructorId' to link constructors with their standings.", "Conditions are added to filter constructors based on their nationality using a placeholder for string values and to ensure they have more points than a specified number using a placeholder for numeric values."], "gold_sql": "SELECT T1.name FROM constructors AS T1 JOIN constructorstandings AS T2 ON T1.constructorid = T2.constructorid WHERE T1.nationality = 'Japanese' AND T2.points > 5", "source_tables": ["constructorstandings", "constructors"], "description": "This virtual table describes the official names of constructors from the 'constructors' table who are from a specific nationality and have scored more points than a specified threshold in the constructor standings. The placeholders in the WHERE clause represent the constructor's nationality and the points threshold.", "virtual_table": "SELECT T1.name FROM constructors AS T1 JOIN constructorstandings AS T2 ON T1.constructorid = T2.constructorid WHERE T1.nationality = [PLACEHOLDER-TYPE:STRING] AND T2.points > [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2184", "db_id": "formula_1", "question": "What are all the different first names of the drivers who are in position as standing and won?", "rationale": ["The query identifies the relevant tables, which are 'drivers' and 'driverStandings'.", "It selects distinct first names from the 'drivers' table.", "A JOIN operation is performed between 'drivers' and 'driverStandings' on the driver ID to combine relevant data.", "Conditions are added to filter the results based on the specified position and number of wins using placeholders for numeric values."], "gold_sql": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = 1 AND T2.wins = 1", "source_tables": ["drivers", "driverstandings"], "description": "This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.", "virtual_table": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = [PLACEHOLDER-TYPE:NUMBER] AND T2.wins = [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2194", "db_id": "formula_1", "question": "What are the names of all races held after 2000 in Spain?", "rationale": ["The query identifies the relevant tables, which are 'races' and 'circuits'.", "It selects distinct race names from the 'races' table.", "A JOIN operation is performed between 'races' and 'circuits' on the circuitId to link races to their respective circuits.", "Conditions are added to filter the results based on the specified country and year using placeholders for string and numeric values."], "gold_sql": "SELECT DISTINCT T1.name FROM races AS T1 JOIN circuits AS T2 ON T1.circuitid = T2.circuitid WHERE T2.country = 'Spain' AND T1.year > 2000", "source_tables": ["races", "circuits"], "description": "This virtual table provides a list of unique race names from the 'races' table that were held at circuits located in a specific country and after a certain year. The placeholders in the WHERE clause represent the country name and the year threshold.", "virtual_table": "SELECT DISTINCT T1.name FROM races AS T1 JOIN circuits AS T2 ON T1.circuitid = T2.circuitid WHERE T2.country = [PLACEHOLDER-TYPE:STRING] AND T1.year > [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2202", "db_id": "formula_1", "question": "What are the different names of all the races in reverse alphabetical order?", "rationale": ["The query identifies the relevant table, which is 'races'.", "It selects the 'name' column to display distinct race names.", "The DISTINCT keyword ensures that only unique race names are returned.", "The results are ordered in descending order based on the race names."], "gold_sql": "SELECT DISTINCT name FROM races ORDER BY name DESC", "source_tables": ["races"], "description": "This virtual table provides a distinct list of race names from the 'races' table, sorted in descending order. The placeholder in the ORDER BY clause indicates that the results will be organized based on the race names.", "virtual_table": "SELECT DISTINCT name FROM races ORDER BY name DESC"}
{"sample_id": "train.2219", "db_id": "formula_1", "question": "What is the average fastest lap speed in race named 'Monaco Grand Prix' in 2008 ?", "rationale": ["The query identifies the relevant tables, which are 'races' and 'results'.", "It joins the 'races' table with the 'results' table on the race ID to correlate race data with results.", "The SELECT statement calculates the average of the 'fastestLapSpeed' from the 'results' table.", "A condition is added to filter the results based on the specified year and race name using placeholders for numeric and string values."], "gold_sql": "SELECT avg(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "description": "This virtual table calculates the average fastest lap speed from the 'results' table for races that occurred in a specific year and have a particular name. The placeholders in the WHERE clause represent the year of the race and the name of the race.", "virtual_table": "SELECT avg(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T1.name = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2167", "db_id": "formula_1", "question": "What is the id and family name of the driver who has the longest laptime?", "rationale": ["The query identifies the relevant tables, which are 'drivers' and 'lapTimes'.", "It selects the 'driverId' and 'surname' from the 'drivers' table.", "A JOIN operation is performed between 'drivers' and 'lapTimes' on the 'driverId' to associate drivers with their lap times.", "The results are ordered by the 'milliseconds' column from the 'lapTimes' table in descending order to get the fastest times first.", "The LIMIT clause is included to allow the user to specify how many top results they want to retrieve."], "gold_sql": "SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT 1", "source_tables": ["laptimes", "drivers"], "description": "This virtual table provides a list of drivers along with their surnames from the 'drivers' table, ordered by their lap times recorded in the 'lapTimes' table. The placeholder in the LIMIT clause allows the user to specify the number of top results to retrieve based on the fastest lap times.", "virtual_table": "SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2168", "db_id": "formula_1", "question": "What is the id and last name of the driver with the longest laptime?", "rationale": ["The query identifies the relevant tables, which are 'drivers' and 'lapTimes'.", "It selects the 'driverId' and 'surname' from the 'drivers' table.", "A JOIN operation is performed between 'drivers' and 'lapTimes' on the 'driverId' to associate drivers with their lap times.", "The results are ordered by the 'milliseconds' column from the 'lapTimes' table in descending order to show the fastest lap times first.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT 1", "source_tables": ["laptimes", "drivers"], "description": "This virtual table provides a list of drivers along with their surnames from the 'drivers' table, ordered by their lap times recorded in the 'lapTimes' table. The results are limited to a specified number of entries, represented by a placeholder for numeric values.", "virtual_table": "SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6027", "db_id": "game_1", "question": "Show all male student ids who don't play football.", "rationale": ["The query is identifying the relevant table, which is 'Student'.", "Select the column to display, 'StuID', which is the unique identifier for each student.", "Add a condition to filter the 'sex' column for the specified gender using a placeholder for string values.", "Use the EXCEPT clause to exclude students who are participating in a specific sport by referencing the 'SportsInfo' table and filtering on 'SportName' with a placeholder for string values."], "gold_sql": "SELECT StuID FROM Student WHERE sex  =  'M' EXCEPT SELECT StuID FROM Sportsinfo WHERE sportname  =  'Football'", "source_tables": ["sportsinfo", "student"], "description": "This virtual table identifies students from the 'Student' table who are of a specific gender and are not participating in a specified sport. The placeholders in the WHERE clause represent the gender and the sport's name.", "virtual_table": "SELECT StuID FROM Student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT StuID FROM Sportsinfo WHERE sportname  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6017", "db_id": "game_1", "question": "What is the first name and last name of the student who have most number of sports?", "rationale": ["The query identifies the relevant tables, 'SportsInfo' and 'Student'.", "It selects the first name and last name from the 'Student' table.", "A join is performed between 'SportsInfo' and 'Student' on the 'StuID' to link students with their sports participation.", "The results are grouped by 'StuID' to aggregate the data for each student.", "The results are ordered by the count of sports played in descending order to show the most active students first.", "A limit is applied to restrict the number of results returned based on a placeholder for numeric values."], "gold_sql": "SELECT T2.Fname ,  T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID GROUP BY T1.StuID ORDER BY count(*) DESC LIMIT 1", "source_tables": ["sportsinfo", "student"], "description": "This virtual table provides the first and last names of students who participate in sports, along with a count of their participation. The results are grouped by student ID and ordered by the number of sports they are involved in, with a limit on the number of results returned based on a specified number.", "virtual_table": "SELECT T2.Fname ,  T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID GROUP BY T1.StuID ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6013", "db_id": "game_1", "question": "Show all student IDs with the number of sports and total number of games played", "rationale": ["The query identifies the relevant table, which is 'SportsInfo'.", "It selects the 'StuID' to group the results by each student.", "The count function is used to count the number of entries for each student, and the sum function calculates the total games played by each student.", "The results are grouped by 'StuID' to provide a summary for each student."], "gold_sql": "SELECT StuID ,  count(*) ,  sum(gamesplayed) FROM Sportsinfo GROUP BY StuID", "source_tables": ["sportsinfo"], "description": "This virtual table summarizes the total number of games played by each student from the 'SportsInfo' table. It includes the unique student identifier and counts the number of entries for each student, as well as the total games played, using placeholders for the respective values.", "virtual_table": "SELECT StuID ,  count(*) ,  sum(gamesplayed) FROM Sportsinfo GROUP BY StuID"}
{"sample_id": "train.5998", "db_id": "game_1", "question": "What are the advisors", "rationale": ["The query identifies the relevant table, which is 'Student'.", "Select the 'advisor' column to display.", "Group the results by 'advisor' to aggregate the data based on each advisor.", "Use the HAVING clause to filter advisors who have advised a number of students greater than or equal to a specified threshold, represented by a placeholder for numeric values."], "gold_sql": "SELECT advisor FROM Student GROUP BY advisor HAVING count(*)  >=  2", "source_tables": ["student"], "description": "This virtual table provides a list of academic advisors from the 'Student' table who have advised a significant number of students. The placeholder in the HAVING clause represents the minimum number of students that an advisor must have to be included in the results.", "virtual_table": "SELECT advisor FROM Student GROUP BY advisor HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6018", "db_id": "game_1", "question": "What is the first and last name of the student who played the most sports?", "rationale": ["The query identifies the relevant tables, 'SportsInfo' and 'Student'.", "It selects the first name and last name of students from the 'Student' table.", "The query joins 'SportsInfo' with 'Student' using the 'StuID' to link the two tables.", "Results are grouped by 'StuID' to aggregate the data for each student.", "The results are ordered by the count of sports participation in descending order.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T2.Fname ,  T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID GROUP BY T1.StuID ORDER BY count(*) DESC LIMIT 1", "source_tables": ["sportsinfo", "student"], "description": "This virtual table provides the first and last names of students who participate in sports, along with the count of their participation. The query joins the 'SportsInfo' table with the 'Student' table based on the unique student identifier. The results are grouped by student ID and ordered by the number of sports they participate in, with a limit on the number of results returned, specified by a placeholder for numeric values.", "virtual_table": "SELECT T2.Fname ,  T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID GROUP BY T1.StuID ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6023", "db_id": "game_1", "question": "Show student ids who are on scholarship and have major 600.", "rationale": ["The query is identifying the relevant table, which is 'Student' and 'SportsInfo'.", "Select the column 'StuID' to display the unique identifier of the students.", "Add a condition to filter the 'major' column for the specified major using a placeholder for numeric values.", "Use the INTERSECT operator to find students who are also in the 'SportsInfo' table with a condition on the 'OnScholarship' column using a placeholder for string values."], "gold_sql": "SELECT StuID FROM Student WHERE major  =  600 INTERSECT SELECT StuID FROM Sportsinfo WHERE onscholarship  =  'Y'", "source_tables": ["sportsinfo", "student"], "description": "This virtual table identifies students who are majoring in a specific field of study and are also participating in sports on a scholarship. The placeholders in the query represent the major and the scholarship status.", "virtual_table": "SELECT StuID FROM Student WHERE major  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT StuID FROM Sportsinfo WHERE onscholarship  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6029", "db_id": "game_1", "question": "Show total hours per week and number of games played for student David Shieber.", "rationale": ["The query identifies the relevant tables, which are 'SportsInfo' and 'Student'.", "It selects the sum of 'HoursPerWeek' and 'GamesPlayed' from the 'SportsInfo' table.", "A JOIN operation is performed on 'StuID' to combine data from 'SportsInfo' and 'Student'.", "Conditions are added to filter the results based on the specified first and last names using placeholders for string values."], "gold_sql": "SELECT sum(hoursperweek) ,  sum(gamesplayed) FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.Fname  =  'David' AND T2.Lname  =  'Shieber'", "source_tables": ["sportsinfo", "student"], "description": "This virtual table summarizes the total hours per week dedicated to sports and the total number of games played by students from the 'SportsInfo' table, filtered by the first and last names of the students from the 'Student' table. The placeholders in the WHERE clause represent the student's first and last names.", "virtual_table": "SELECT sum(hoursperweek) ,  sum(gamesplayed) FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.Fname  =  [PLACEHOLDER-TYPE:STRING] AND T2.Lname  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5986", "db_id": "game_1", "question": "What type has the most games?", "rationale": ["The query identifies the relevant table, which is 'Video_Games'.", "It selects the 'GType' column to display the types of video games.", "The GROUP BY clause is used to group the results by 'GType'.", "The ORDER BY clause sorts the grouped results by the count of games in each genre in descending order.", "The LIMIT clause uses a placeholder to allow the user to specify how many genres to return."], "gold_sql": "SELECT gtype FROM Video_games GROUP BY gtype ORDER BY count(*) DESC LIMIT 1", "source_tables": ["video_games"], "description": "This virtual table provides a summary of the types or genres of video games from the 'Video_Games' table, grouped by their type. The placeholder in the LIMIT clause allows the user to specify the maximum number of genres to retrieve, sorted by the number of games in each genre in descending order.", "virtual_table": "SELECT gtype FROM Video_games GROUP BY gtype ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6009", "db_id": "game_1", "question": "How many games are played for all football games by students on scholarship?", "rationale": ["The query identifies the relevant table, which is 'SportsInfo'.", "It selects the sum of the 'GamesPlayed' column to get the total number of games played.", "Conditions are added to filter the results based on the specified 'SportName' and whether the student is 'OnScholarship', using placeholders for string values."], "gold_sql": "SELECT sum(gamesplayed) FROM Sportsinfo WHERE sportname  =  'Football' AND onscholarship  =  'Y'", "source_tables": ["sportsinfo"], "description": "This virtual table summarizes the total number of games played by students involved in a specific sport and who are on a sports scholarship. The placeholders in the WHERE clause represent the sport's name and the scholarship status.", "virtual_table": "SELECT sum(gamesplayed) FROM Sportsinfo WHERE sportname  =  [PLACEHOLDER-TYPE:STRING] AND onscholarship  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6031", "db_id": "game_1", "question": "Show total hours per week and number of games played for students under 20.", "rationale": ["The query identifies the relevant tables, which are 'SportsInfo' and 'Student'.", "It uses a JOIN operation to combine records from both tables based on the common 'StuID' field.", "The SELECT statement aggregates the total hours per week and total games played using the SUM function.", "A condition is added to filter students based on their age, using a placeholder for numeric values."], "gold_sql": "SELECT sum(hoursperweek) ,  sum(gamesplayed) FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.age  <  20", "source_tables": ["sportsinfo", "student"], "description": "This virtual table summarizes the total hours per week and total games played by students from the 'SportsInfo' table who are younger than a specified age. The placeholders in the SELECT statement represent the aggregated values for hours and games, while the WHERE clause uses a placeholder for the age limit.", "virtual_table": "SELECT sum(hoursperweek) ,  sum(gamesplayed) FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.age  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5982", "db_id": "game_1", "question": "Count the number of video games with Massively multiplayer online game type .", "rationale": ["The query identifies the relevant table, which is 'Video_Games'.", "It selects the count of all entries in the table.", "A condition is added to filter the 'GType' column for the specified genre using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM Video_games WHERE gtype  =  'Massively multiplayer online game'", "source_tables": ["video_games"], "description": "This virtual table provides the count of video games from the 'Video_Games' table that belong to a specific genre. The placeholder in the WHERE clause represents the type of the video game.", "virtual_table": "SELECT count(*) FROM Video_games WHERE gtype  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5978", "db_id": "game_1", "question": "What are the names of all video games that are collectible cards?", "rationale": ["The query is identifying the relevant table, which is 'Video_Games'.", "Select the column to display, 'GName'.", "Add a condition to filter the 'GType' column for the specified genre using a placeholder for string values."], "gold_sql": "SELECT gname FROM Video_games WHERE gtype  =  'Collectible card game'", "source_tables": ["video_games"], "description": "This virtual table describes the names of video games from the 'Video_Games' table that belong to a specific genre. The placeholder in the WHERE clause represents the type of the video game.", "virtual_table": "SELECT gname FROM Video_games WHERE gtype  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5977", "db_id": "game_1", "question": "Show all video games with type Collectible card game.", "rationale": ["The query is identifying the relevant table, which is 'Video_Games'.", "Select the column to display, 'GName'.", "Add a condition to filter the 'GType' column for the specified genre using a placeholder for string values."], "gold_sql": "SELECT gname FROM Video_games WHERE gtype  =  'Collectible card game'", "source_tables": ["video_games"], "description": "This virtual table describes the names of video games from the 'Video_Games' table that belong to a specific genre. The placeholder in the WHERE clause represents the type of the video game.", "virtual_table": "SELECT gname FROM Video_games WHERE gtype  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6005", "db_id": "game_1", "question": "Show last names for all student who are on scholarship.", "rationale": ["The query identifies the relevant tables, 'SportsInfo' and 'Student'.", "It selects the 'LName' column from the 'Student' table.", "A JOIN operation is performed on the 'StuID' column to link the two tables based on the student identifier.", "A condition is added to filter the results based on the 'OnScholarship' column in the 'SportsInfo' table using a placeholder for string values."], "gold_sql": "SELECT T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T1.onscholarship  =  'Y'", "source_tables": ["sportsinfo", "student"], "description": "This virtual table describes the last names of students from the 'Student' table who are participating in sports and are on a sports scholarship. The placeholder in the WHERE clause represents the scholarship status.", "virtual_table": "SELECT T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T1.onscholarship  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3985", "db_id": "hospital_1", "question": "What procedures cost less than 5000 and have John Wen as a trained physician?", "rationale": ["The query identifies the relevant tables, which are 'procedures' and 'physician' with their associated relationships through 'trained_in'.", "It selects the 'name' of procedures where the 'cost' is less than a specified value using a placeholder for numeric values.", "It uses an INTERSECT to find procedures that are both less than the specified cost and are treatments that the specified physician is trained in, indicated by the physician's name placeholder."], "gold_sql": "SELECT name FROM procedures WHERE cost  <  5000 INTERSECT SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  'John Wen'", "source_tables": ["procedures", "physician", "trained_in"], "description": "This virtual table describes the names of medical procedures that are less expensive than a specified cost and are also treatments that a specific physician is certified to perform. The placeholders in the query represent the cost limit and the physician's name.", "virtual_table": "SELECT name FROM procedures WHERE cost  <  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3931", "db_id": "hospital_1", "question": "Which physicians are in charge of more than one patient? Give me their names.", "rationale": ["The query identifies the relevant tables, which are 'Physician' and 'Patient'.", "It selects the 'Name' column from the 'Physician' table, aliased as T1.", "A JOIN operation is performed between 'Physician' and 'Patient' on the condition that the physician's EmployeeID matches the patient's PCP identifier.", "The results are grouped by the physician's EmployeeID to aggregate the patient counts.", "The HAVING clause filters the results to include only those physicians who have more patients than the specified number, using a placeholder for numeric values."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  1", "source_tables": ["physician", "patient"], "description": "This virtual table lists the names of physicians who are primary care physicians (PCP) for a number of patients exceeding a specified threshold. The placeholder in the HAVING clause represents the minimum number of patients a physician must have to be included in the results.", "virtual_table": "SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3934", "db_id": "hospital_1", "question": "Find the number of rooms for different block code?", "rationale": ["The query identifies the relevant tables, which are 'Block' and 'Room'.", "It selects a count of rooms and the block code from the 'Block' table.", "The JOIN operation is used to combine data from 'Block' and 'Room' based on matching block floor and block code values.", "The results are grouped by the block code to provide a summary count for each unique block code."], "gold_sql": "SELECT count(*) ,  T1.blockcode FROM BLOCK AS T1 JOIN room AS T2 ON T1.blockfloor  =  T2.blockfloor AND T1.blockcode  =  T2.blockcode GROUP BY T1.blockcode", "source_tables": ["block", "room"], "description": "This virtual table provides a count of rooms grouped by their block code status from the 'Block' and 'Room' tables. The placeholders represent the block floor and block code statuses used for filtering the results.", "virtual_table": "SELECT count(*) ,  T1.blockcode FROM BLOCK AS T1 JOIN room AS T2 ON T1.blockfloor  =  T2.blockfloor AND T1.blockcode  =  T2.blockcode GROUP BY T1.blockcode"}
{"sample_id": "train.3915", "db_id": "hospital_1", "question": "What are the name and primarily affiliated department name of each physician?", "rationale": ["The query identifies the relevant tables: 'Physician', 'Affiliated_With', and 'Department'.", "It selects the 'Name' column from both the 'Physician' and 'Department' tables.", "The join condition connects the 'Physician' table to the 'Affiliated_With' table using the 'EmployeeID' and 'Physician' columns, and then connects to the 'Department' table using the 'DepartmentID'.", "A condition is added to filter the results based on whether the affiliation is primary, using a placeholder for numeric values."], "gold_sql": "SELECT T1.name ,  T3.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T2.PrimaryAffiliation  =  1", "source_tables": ["physician", "department", "affiliated_with"], "description": "This virtual table describes the names of physicians along with the names of their affiliated departments from the 'Physician' and 'Department' tables. The join condition links physicians to their departments through the 'Affiliated_With' table, and the placeholder in the WHERE clause indicates whether the affiliation is primary.", "virtual_table": "SELECT T1.name ,  T3.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T2.PrimaryAffiliation  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3961", "db_id": "hospital_1", "question": "What are each physician's employee id and department id primarily affiliated.", "rationale": ["The query identifies the relevant table, which is 'Affiliated_With'.", "Select the columns to display, 'physician' and 'department'.", "Add a condition to filter the 'primaryaffiliation' column for the specified status using a placeholder for numeric values."], "gold_sql": "SELECT physician ,  department FROM affiliated_with WHERE primaryaffiliation  =  1", "source_tables": ["affiliated_with"], "description": "This virtual table provides a list of physicians along with their associated departments from the 'Affiliated_With' table, filtered by whether the affiliation is marked as primary. The placeholder in the WHERE clause represents the primary affiliation status.", "virtual_table": "SELECT physician ,  department FROM affiliated_with WHERE primaryaffiliation  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3929", "db_id": "hospital_1", "question": "Return the name of each physician and the number of patients he or she treats.", "rationale": ["The query identifies the relevant tables, which are 'Physician' and 'Patient'.", "It selects the 'Name' column from the 'Physician' table and counts the number of patients associated with each physician.", "A JOIN operation is performed between the 'Physician' table and the 'Patient' table using the physician's employee ID and the patient's PCP identifier.", "The results are grouped by the physician's employee ID to provide a count of patients for each physician."], "gold_sql": "SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid", "source_tables": ["physician", "patient"], "description": "This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.", "virtual_table": "SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid"}
{"sample_id": "train.3981", "db_id": "hospital_1", "question": "What are the procedures that cost more than 1000 or are specialized in by physician John Wen?", "rationale": ["The query identifies the relevant tables: 'Procedures', 'Physician', and 'Trained_In'.", "It selects the 'name' column from the 'Procedures' table where the 'cost' exceeds a specified number using a placeholder.", "It uses a UNION to combine results with another SELECT statement that retrieves procedure names based on the physician's training.", "The second part of the query joins 'Physician' and 'Trained_In' on the physician's identifier, and then joins with 'Procedures' to get the names of procedures the physician is trained in.", "The placeholders are used for the cost value and the physician's name to allow for dynamic querying."], "gold_sql": "SELECT name FROM procedures WHERE cost  >  1000 UNION SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  'John Wen'", "source_tables": ["procedures", "physician", "trained_in"], "description": "This virtual table provides a list of procedure names from the 'Procedures' table that have a cost greater than a specified amount. Additionally, it includes names of procedures that a specific physician is trained in, by joining the 'Physician', 'Trained_In', and 'Procedures' tables. The placeholders represent the cost threshold and the physician's name respectively.", "virtual_table": "SELECT name FROM procedures WHERE cost  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3945", "db_id": "hospital_1", "question": "How many medications are prescribed for each brand?", "rationale": ["The query identifies the relevant tables, which are 'medication' and 'prescribes'.", "It selects a count of prescriptions and the name of the medication from the 'medication' table.", "The JOIN operation links the two tables on the medication code, ensuring that only prescribed medications are counted.", "The GROUP BY clause organizes the results by the brand of the medication, allowing for a summary count per brand."], "gold_sql": "SELECT count(*) ,  T1.name FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand", "source_tables": ["prescribes", "medication"], "description": "This virtual table provides a count of prescribed medications grouped by their brand names. It combines data from the 'medication' table and the 'prescribes' table, allowing users to see how many times each brand of medication has been prescribed.", "virtual_table": "SELECT count(*) ,  T1.name FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand"}
{"sample_id": "train.3964", "db_id": "hospital_1", "question": "What nurses are on call with block floor 1 and block code 1? Tell me their names.", "rationale": ["The query identifies the relevant table, which is 'On_Call'.", "Select the column to display, 'nurse'.", "Add conditions to filter the 'blockfloor' and 'blockcode' columns using placeholders for numeric values."], "gold_sql": "SELECT nurse FROM on_call WHERE blockfloor  =  1 AND blockcode  =  1", "source_tables": ["on_call"], "description": "This virtual table provides a list of nurses who are on call, filtered by specific block floor and block code statuses. The placeholders in the WHERE clause represent the identifiers for the blocked floor and blocked code statuses.", "virtual_table": "SELECT nurse FROM on_call WHERE blockfloor  =  [PLACEHOLDER-TYPE:NUMBER] AND blockcode  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3962", "db_id": "hospital_1", "question": "List the names of departments where some physicians are primarily affiliated with.", "rationale": ["The query identifies the relevant tables, 'Affiliated_With' and 'Department'.", "It selects distinct department names from the 'Department' table.", "A JOIN operation is performed between 'Affiliated_With' and 'Department' on the department identifier.", "A condition is added to filter the results based on the primary affiliation status using a placeholder for numeric values."], "gold_sql": "SELECT DISTINCT T2.name FROM affiliated_with AS T1 JOIN department AS T2 ON T1.department = T2.departmentid WHERE PrimaryAffiliation  =  1", "source_tables": ["department", "affiliated_with"], "description": "This virtual table provides a list of distinct department names from the 'Department' table that are associated with physicians based on their primary affiliation. The placeholder in the WHERE clause represents whether the affiliation is primary or not.", "virtual_table": "SELECT DISTINCT T2.name FROM affiliated_with AS T1 JOIN department AS T2 ON T1.department = T2.departmentid WHERE PrimaryAffiliation  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3900", "db_id": "hospital_1", "question": "What is the employee id of the head whose department has the least number of employees?", "rationale": ["The query identifies the relevant table, which is 'Department'.", "It selects the 'head' column to display the heads of the departments.", "The results are grouped by 'DepartmentID' to ensure unique department heads are listed.", "The results are ordered by the count of 'DepartmentID' to prioritize departments with more occurrences.", "A placeholder is included to limit the number of results returned."], "gold_sql": "SELECT head FROM department GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["department"], "description": "This virtual table provides a list of department heads from the 'Department' table, grouped by their department identifiers. The result is ordered by the count of departments, and a placeholder is used to limit the number of results returned.", "virtual_table": "SELECT head FROM department GROUP BY departmentID ORDER BY count(departmentID) LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3963", "db_id": "hospital_1", "question": "What are the names of departments that have primarily affiliated physicians.", "rationale": ["The query identifies the relevant tables, 'Affiliated_With' and 'Department'.", "It selects distinct department names from the 'Department' table.", "A JOIN operation is performed between 'Affiliated_With' and 'Department' on the department identifier.", "A condition is added to filter the results based on the primary affiliation status using a placeholder for numeric values."], "gold_sql": "SELECT DISTINCT T2.name FROM affiliated_with AS T1 JOIN department AS T2 ON T1.department = T2.departmentid WHERE PrimaryAffiliation  =  1", "source_tables": ["department", "affiliated_with"], "description": "This virtual table provides a list of distinct department names from the 'Department' table that are associated with physicians based on their primary affiliation. The placeholder in the WHERE clause represents whether the affiliation is primary or not.", "virtual_table": "SELECT DISTINCT T2.name FROM affiliated_with AS T1 JOIN department AS T2 ON T1.department = T2.departmentid WHERE PrimaryAffiliation  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3924", "db_id": "hospital_1", "question": "Find the patient who most recently stayed in room 111.", "rationale": ["The query identifies the relevant table, which is 'Stay'.", "It selects the 'patient' column to display the patients staying in the specified room.", "A condition is added to filter the 'room' column for the specified room number using a placeholder for numeric values.", "The results are ordered by 'StayStart' in descending order to show the most recent stays first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT patient FROM stay WHERE room  =  111 ORDER BY staystart DESC LIMIT 1", "source_tables": ["stay"], "description": "This virtual table provides a list of patients currently staying in a specific room, ordered by the start date of their stay in descending order. The placeholders represent the room number and the limit on the number of patients to retrieve.", "virtual_table": "SELECT patient FROM stay WHERE room  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY staystart DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3905", "db_id": "hospital_1", "question": "List the names of patients who have made appointments.", "rationale": ["The query identifies the relevant tables, which are 'Appointment' and 'Patient'.", "It selects the 'name' column from the 'Patient' table.", "A join is performed between the 'Appointment' table and the 'Patient' table using the patient identifier and Social Security Number, respectively."], "gold_sql": "SELECT name FROM appointment AS T1 JOIN patient AS T2 ON T1.patient  =  T2.ssn", "source_tables": ["patient", "appointment"], "description": "This virtual table provides the names of patients associated with their appointments from the 'Appointment' and 'Patient' tables. The join condition links the patient identifier in the 'Appointment' table to the Social Security Number in the 'Patient' table.", "virtual_table": "SELECT name FROM appointment AS T1 JOIN patient AS T2 ON T1.patient  =  T2.ssn"}
{"sample_id": "train.3973", "db_id": "hospital_1", "question": "Which physicians are trained in procedures that are more expensive than 5000?", "rationale": ["The query identifies the relevant tables: 'Physician', 'Trained_In', and 'Procedures'.", "It selects the 'Name' column from the 'Physician' table.", "The query joins 'Physician' with 'Trained_In' on the 'EmployeeID' and 'Physician' identifiers to link physicians with their training.", "It further joins 'Trained_In' with 'Procedures' on the 'Code' and 'Treatment' identifiers to associate procedures with their costs.", "A condition is added to filter procedures based on their cost using a placeholder for numeric values."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  5000", "source_tables": ["physician", "procedures", "trained_in"], "description": "This virtual table describes the names of physicians who are trained in specific procedures that have a cost exceeding a certain amount. The placeholders in the WHERE clause represent the cost threshold for the procedures.", "virtual_table": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3910", "db_id": "hospital_1", "question": "List the name of physicians who took some appointment.", "rationale": ["The query identifies the relevant tables, which are 'Appointment' and 'Physician'.", "It selects the 'Name' column from the 'Physician' table, which contains the names of the physicians.", "The join condition links the 'Physician' column in the 'Appointment' table to the 'EmployeeID' column in the 'Physician' table, ensuring that only the names of physicians conducting appointments are retrieved."], "gold_sql": "SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID", "source_tables": ["physician", "appointment"], "description": "This virtual table describes the names of physicians who are conducting appointments. The query joins the 'Appointment' table with the 'Physician' table based on the physician's unique identifier, allowing for the retrieval of physician names associated with each appointment.", "virtual_table": "SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID"}
{"sample_id": "train.3970", "db_id": "hospital_1", "question": "Find the three most expensive procedures.", "rationale": ["The query identifies the relevant table, which is 'Procedures'.", "Select the column to display, 'Name', which represents the names of the procedures.", "Order the results by the 'Cost' column to sort the procedures based on their costs.", "Use a placeholder in the LIMIT clause to allow the user to specify how many procedure names they want to retrieve."], "gold_sql": "SELECT name FROM procedures ORDER BY cost LIMIT 3", "source_tables": ["procedures"], "description": "This virtual table lists the names of medical procedures from the 'Procedures' table, ordered by their associated costs. The placeholder in the LIMIT clause allows the user to specify the maximum number of procedure names to retrieve.", "virtual_table": "SELECT name FROM procedures ORDER BY cost LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3911", "db_id": "hospital_1", "question": "What are the names of all the physicians who took appointments.", "rationale": ["The query identifies the relevant tables, which are 'Appointment' and 'Physician'.", "It selects the 'Name' column from the 'Physician' table, which contains the names of the physicians.", "A JOIN operation is performed between the 'Appointment' table and the 'Physician' table using the 'Physician' identifier to link the two tables."], "gold_sql": "SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID", "source_tables": ["physician", "appointment"], "description": "The virtual table describes the names of physicians who are conducting appointments. It retrieves the physician's name from the 'Physician' table by joining it with the 'Appointment' table based on the physician's unique identifier. This allows for a clear association between appointments and the physicians responsible for them.", "virtual_table": "SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID"}
{"sample_id": "train.3958", "db_id": "hospital_1", "question": "What are the names of the physician who prescribed the highest dose?", "rationale": ["The query identifies the relevant tables, which are 'Physician' and 'Prescribes'.", "It selects the 'Name' column from the 'Physician' table, aliased as T1.", "A JOIN operation is performed between 'Physician' (T1) and 'Prescribes' (T2) on the condition that the 'EmployeeID' from 'Physician' matches the 'Physician' identifier in 'Prescribes'.", "The results are ordered by the 'Dose' column from the 'Prescribes' table in descending order to prioritize higher dosages.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT 1", "source_tables": ["physician", "prescribes"], "description": "This virtual table lists the names of physicians from the 'Physician' table who have prescribed medications, ordered by the dosage of the medications in descending order. The placeholder in the LIMIT clause represents the maximum number of physician names to be returned.", "virtual_table": "SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3516", "db_id": "hr_1", "question": "What are the department ids, full names, and salaries for employees who make the most in their departments?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Selects the columns to display: 'first_name', 'last_name', 'salary', and 'department_id'.", "Uses the MAX function to find the highest salary within each department.", "Groups the results by 'department_id' to aggregate the data accordingly."], "gold_sql": "SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id", "source_tables": ["employees"], "description": "This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.", "virtual_table": "SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id"}
{"sample_id": "train.3458", "db_id": "hr_1", "question": "What are the job ids for jobs done more than once for a period of more than 300 days?", "rationale": ["The query identifies the relevant table, which is 'job_history'.", "It selects the 'job_id' column to display the job identifiers.", "A condition is added to filter the records where the difference between 'end_date' and 'start_date' is greater than a specified number using a placeholder for numeric values.", "The results are grouped by 'job_id' to aggregate the data.", "A HAVING clause is included to filter the groups to only those with a count of occurrences greater than or equal to a specified number, using another placeholder for numeric values."], "gold_sql": "SELECT job_id FROM job_history WHERE end_date - start_date  > 300 GROUP BY job_id HAVING COUNT(*) >= 2", "source_tables": ["job_history"], "description": "This virtual table provides a list of job identifiers from the 'job_history' table where the duration of the job (calculated as the difference between the end date and start date) exceeds a specified number of days. Additionally, it groups the results by job identifier and filters to include only those jobs that have been held for a minimum number of occurrences, as indicated by the placeholders.", "virtual_table": "SELECT job_id FROM job_history WHERE end_date - start_date  > [PLACEHOLDER-TYPE:NUMBER] GROUP BY job_id HAVING COUNT(*) >= [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3473", "db_id": "hr_1", "question": "Find the first name and last name and department id for those employees who earn such amount of salary which is the smallest salary of any of the departments.", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Select the columns to display: 'first_name', 'last_name', and 'department_id'.", "Add a condition to filter employees whose salary matches the minimum salary in their department using a subquery that groups by 'department_id' and selects the minimum salary."], "gold_sql": "SELECT first_name ,  last_name ,  department_id FROM employees WHERE salary IN (SELECT MIN(salary) FROM employees GROUP BY department_id)", "source_tables": ["employees"], "description": "This virtual table provides the first and last names of employees along with their department identifiers from the 'employees' table, specifically targeting those employees who earn the minimum salary within their respective departments. The subquery identifies the minimum salary for each department, and the placeholder in the WHERE clause allows for dynamic filtering based on salary criteria.", "virtual_table": "SELECT first_name ,  last_name ,  department_id FROM employees WHERE salary IN (SELECT MIN(salary) FROM employees GROUP BY department_id)"}
{"sample_id": "train.3509", "db_id": "hr_1", "question": "display the employee number, name( first name and last name ) and job title for all employees whose salary is more than any salary of those employees whose job title is PU_MAN.", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Select the columns to display: 'employee_id', 'first_name', 'last_name', and 'job_id'.", "Add a condition to filter employees based on their salary being greater than a maximum salary derived from a subquery.", "The subquery selects the maximum salary from the 'employees' table where the job identifier matches the specified job, using a placeholder for string values."], "gold_sql": "SELECT employee_id ,  first_name ,  last_name ,  job_id FROM employees WHERE salary  >  ( SELECT max(salary) FROM employees WHERE job_id  =  'PU_MAN' )", "source_tables": ["employees"], "description": "This virtual table provides a list of employees, including their unique identifiers, first names, last names, and job identifiers, who earn a salary greater than the maximum salary for a specified job. The placeholder in the subquery represents the job identifier for which the maximum salary is being compared.", "virtual_table": "SELECT employee_id ,  first_name ,  last_name ,  job_id FROM employees WHERE salary  >  ( SELECT max(salary) FROM employees WHERE job_id  =  [PLACEHOLDER-TYPE:STRING] )"}
{"sample_id": "train.3417", "db_id": "hr_1", "question": "display the full name (first and last), hire date, salary, and department number for those employees whose first name does not containing the letter M.", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Selects the columns to display: 'first_name', 'last_name', 'hire_date', 'salary', and 'department_id'.", "Adds a condition to filter out employees whose first names match a specific pattern using a placeholder for string values."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%'", "source_tables": ["employees"], "description": "This virtual table provides a list of employees' first names, last names, hire dates, salaries, and their department identifiers from the 'employees' table, excluding those whose first names match a specific pattern. The placeholder in the WHERE clause allows for filtering based on the first name criteria.", "virtual_table": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3504", "db_id": "hr_1", "question": "What are the ids and full names for employees who work in a department that has someone with a first name that contains the letter T?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Select the columns to display: 'employee_id', 'first_name', and 'last_name'.", "Add a condition to filter the 'department_id' based on a subquery that selects 'department_id' from the 'employees' table where the 'first_name' matches a specified pattern using a placeholder for string values."], "gold_sql": "SELECT employee_id ,  first_name ,  last_name FROM employees WHERE department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE '%T%' )", "source_tables": ["employees"], "description": "This virtual table describes the employee ID, first name, and last name of employees from the 'employees' table who belong to the same department as a specified employee. The placeholder in the WHERE clause allows for filtering based on the first name of the employee.", "virtual_table": "SELECT employee_id ,  first_name ,  last_name FROM employees WHERE department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE [PLACEHOLDER-TYPE:STRING] )"}
{"sample_id": "train.3510", "db_id": "hr_1", "question": "What are the employee ids, full names, and job ids for employees who make more than the highest earning employee with title PU_MAN?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Select the columns to display: 'employee_id', 'first_name', 'last_name', and 'job_id'.", "Add a condition to filter employees based on their salary being greater than a maximum salary from a subquery.", "The subquery selects the maximum salary from the 'employees' table where the 'job_id' matches a specified job, using a placeholder for string values."], "gold_sql": "SELECT employee_id ,  first_name ,  last_name ,  job_id FROM employees WHERE salary  >  ( SELECT max(salary) FROM employees WHERE job_id  =  'PU_MAN' )", "source_tables": ["employees"], "description": "This virtual table provides a list of employees, including their unique identifiers, first names, last names, and job identifiers, who earn a salary greater than the maximum salary for a specified job. The placeholder in the subquery represents the job identifier for which the maximum salary is being compared.", "virtual_table": "SELECT employee_id ,  first_name ,  last_name ,  job_id FROM employees WHERE salary  >  ( SELECT max(salary) FROM employees WHERE job_id  =  [PLACEHOLDER-TYPE:STRING] )"}
