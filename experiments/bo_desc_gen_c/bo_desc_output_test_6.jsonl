{"sample_id": "train.6777", "db_id": "activity_1", "question": "Show the names of all the activities Mark Giuliano participates in.", "rationale": ["The query identifies the relevant tables: 'Faculty', 'Faculty_Participates_in', and 'Activity'.", "It selects the 'activity_name' from the 'Activity' table.", "The query joins the 'Faculty' table with 'Faculty_Participates_in' on the faculty ID, and then joins 'Faculty_Participates_in' with 'Activity' on the activity ID.", "Conditions are added to filter the results based on the specified first and last names of the faculty member using placeholders for string values."], "gold_sql": "SELECT T3.activity_name FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN Activity AS T3 ON T3.actid  =  T2.actid WHERE T1.fname  =  'Mark' AND T1.lname  =  'Giuliano'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "description": "This virtual table describes the names of activities in which a specific faculty member participates. The placeholders in the WHERE clause represent the first and last names of the faculty member.", "virtual_table": "SELECT T3.activity_name FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN Activity AS T3 ON T3.actid  =  T2.actid WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6779", "db_id": "activity_1", "question": "Show the first and last name of all the faculty members who participated in some activity, together with the number of activities they participated in.", "rationale": ["The query identifies the relevant tables, which are 'Faculty' and 'Faculty_Participates_in'.", "It selects the first name and last name of faculty members from the 'Faculty' table.", "It counts the number of activities each faculty member participates in by using the COUNT function.", "The JOIN operation links the 'Faculty' table with the 'Faculty_Participates_in' table based on the faculty identifier.", "The results are grouped by the unique identifier of each faculty member to aggregate their activity participation."], "gold_sql": "SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID", "source_tables": ["faculty", "faculty_participates_in"], "description": "This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is grouped by each faculty member's unique identifier. The placeholders represent the faculty member's first name, last name, and the count of their participation in activities.", "virtual_table": "SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID"}
{"sample_id": "train.6789", "db_id": "activity_1", "question": "Show the ids for all the students who participate in an activity and are under 20.", "rationale": ["The query is identifying the relevant tables, which are 'Participates_in' and 'Student'.", "The INTERSECT operator is used to find common student IDs from both tables.", "The first SELECT statement retrieves student IDs from the 'Participates_in' table.", "The second SELECT statement retrieves student IDs from the 'Student' table, applying a condition to filter students based on their age using a placeholder for numeric values."], "gold_sql": "SELECT StuID FROM Participates_in INTERSECT SELECT StuID FROM Student WHERE age  <  20", "source_tables": ["student", "participates_in"], "description": "This virtual table identifies students who participate in activities and are younger than a specified age. The placeholder in the WHERE clause represents the age limit for filtering the students.", "virtual_table": "SELECT StuID FROM Participates_in INTERSECT SELECT StuID FROM Student WHERE age  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6797", "db_id": "activity_1", "question": "Find the first names of professors who are not playing Canoeing or Kayaking.", "rationale": ["The query identifies the relevant table, which is 'Faculty'.", "It selects the 'lname' column to display the last names of faculty members.", "A condition is added to filter faculty by their 'rank' using a placeholder for string values.", "The EXCEPT clause is used to exclude faculty members who participate in activities, which involves joining the 'Faculty', 'Faculty_Participates_in', and 'Activity' tables.", "The join condition links faculty members to their activities, and the WHERE clause filters based on the activity names using placeholders for string values."], "gold_sql": "SELECT lname FROM faculty WHERE rank  =  'Professor' EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "description": "This virtual table lists the last names of faculty members who hold a specific academic rank but do not participate in certain activities. The placeholders in the query represent the rank of the faculty and the names of the activities they are not involved in.", "virtual_table": "SELECT lname FROM faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6798", "db_id": "activity_1", "question": "What are the first names of the professors who do not play Canoeing or Kayaking as activities?", "rationale": ["The query identifies the relevant table, which is 'Faculty'.", "It selects the 'lname' column to display the last names of faculty members.", "A condition is added to filter faculty by their 'rank' using a placeholder for string values.", "The EXCEPT clause is used to exclude faculty members who participate in activities, which is determined by joining the 'Faculty' table with 'Faculty_Participates_in' and 'Activity' tables.", "The activities to be excluded are specified using placeholders for their names."], "gold_sql": "SELECT lname FROM faculty WHERE rank  =  'Professor' EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "description": "This virtual table lists the last names of faculty members who hold a specific academic rank but do not participate in certain activities. The placeholders in the query represent the rank of the faculty and the names of the activities they may or may not be involved in.", "virtual_table": "SELECT lname FROM faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6799", "db_id": "activity_1", "question": "Find the first names of the faculty members who participate in Canoeing and Kayaking.", "rationale": ["The query identifies the relevant tables, which are 'Faculty', 'Faculty_Participates_in', and 'Activity'.", "It selects the 'lname' column from the 'Faculty' table.", "The JOIN operations link faculty members to the activities they participate in through the 'Faculty_Participates_in' table.", "The WHERE clause filters the results based on the specified activity name using a placeholder for string values.", "The INTERSECT operation ensures that only faculty members participating in the same activity are included in the final result."], "gold_sql": "SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' INTERSECT SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "description": "This virtual table describes the last names of faculty members who participate in a specific activity. The query uses an INTERSECT operation to ensure that only faculty members who are involved in the same activity are selected. The placeholders in the WHERE clause represent the name of the activity.", "virtual_table": "SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6801", "db_id": "activity_1", "question": "Find the ids of the students who participate in Canoeing and Kayaking.", "rationale": ["The query is identifying the relevant tables, which are 'Participates_in' and 'Activity'.", "It selects the 'stuid' column from the 'Participates_in' table.", "The query uses a JOIN to connect 'Participates_in' with 'Activity' based on the 'actid'.", "It filters the results based on the 'activity_name' for the first activity using a placeholder.", "The INTERSECT operator is used to find students who participate in both activities, requiring a second selection with a similar structure and another placeholder for the second activity's name."], "gold_sql": "SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  'Canoeing' INTERSECT SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  'Kayaking'", "source_tables": ["activity", "participates_in"], "description": "This virtual table identifies students who participate in two specific activities from the 'Activity' table. The placeholders in the WHERE clause represent the names of the activities being compared.", "virtual_table": "SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6825", "db_id": "flight_4", "question": "Find the number of routes operated by American Airlines.", "rationale": ["The query identifies the relevant tables, which are 'airlines' and 'routes'.", "It uses a JOIN operation to connect the two tables based on the airline ID ('alid').", "The SELECT statement counts the number of routes associated with the specified airline name, using a placeholder for the airline's name in the WHERE clause."], "gold_sql": "SELECT count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid WHERE T1.name  =  'American Airlines'", "source_tables": ["routes", "airlines"], "description": "This virtual table provides the count of routes operated by a specific airline from the 'airlines' and 'routes' tables. The placeholder in the WHERE clause represents the name of the airline for which the route count is being queried.", "virtual_table": "SELECT count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6826", "db_id": "flight_4", "question": "How many routes does American Airlines operate?", "rationale": ["The query identifies the relevant tables, which are 'airlines' and 'routes'.", "It uses a JOIN operation to connect the two tables based on the airline ID ('alid').", "The SELECT statement counts the number of routes associated with the specified airline name, using a placeholder for the airline's name in the WHERE clause."], "gold_sql": "SELECT count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid WHERE T1.name  =  'American Airlines'", "source_tables": ["routes", "airlines"], "description": "This virtual table provides the count of routes operated by a specific airline from the 'airlines' and 'routes' tables. The placeholder in the WHERE clause represents the name of the airline for which the route count is being queried.", "virtual_table": "SELECT count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6831", "db_id": "flight_4", "question": "Find the name, city, and country of the airport that has the highest latitude.", "rationale": ["The query identifies the relevant table, which is 'airports'.", "Select the columns to display: 'name', 'city', and 'country'.", "Add an ORDER BY clause to sort the results by the 'elevation' column in descending order.", "Include a LIMIT clause with a placeholder to specify the maximum number of records to return."], "gold_sql": "SELECT name ,  city ,  country FROM airports ORDER BY elevation DESC LIMIT 1", "source_tables": ["airports"], "description": "This virtual table provides a list of airport names, their respective cities, and countries from the 'airports' table, sorted by elevation in descending order. The placeholder in the LIMIT clause represents the maximum number of records to return.", "virtual_table": "SELECT name ,  city ,  country FROM airports ORDER BY elevation DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6834", "db_id": "flight_4", "question": "What is the name and city of the airport that the most routes end at?", "rationale": ["The query identifies the relevant tables, which are 'airports' and 'routes'.", "It selects the 'name' and 'city' columns from the 'airports' table (aliased as T1) and the 'dst_apid' from the 'routes' table (aliased as T2).", "A JOIN operation is performed on the 'apid' of the 'airports' table and the 'dst_apid' of the 'routes' table to link the destination airports with their routes.", "The results are grouped by 'dst_apid' to aggregate the data based on destination airport IDs.", "The results are ordered by the count of routes to each destination in descending order, and a limit is applied to restrict the number of results based on a placeholder for numeric values."], "gold_sql": "SELECT T1.name ,  T1.city ,  T2.dst_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid GROUP BY T2.dst_apid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "description": "This virtual table provides a list of destination airport names and their corresponding cities from the 'airports' table, along with the destination airport IDs from the 'routes' table. The results are grouped by destination airport ID and ordered by the count of routes to each destination, limited to a specified number of results.", "virtual_table": "SELECT T1.name ,  T1.city ,  T2.dst_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid GROUP BY T2.dst_apid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6838", "db_id": "flight_4", "question": "What is the name and city of the airport from most of the routes start?", "rationale": ["The query identifies the relevant tables, 'airports' and 'routes'.", "It selects the 'name' and 'city' columns from the 'airports' table and the 'src_apid' from the 'routes' table.", "A JOIN operation is performed on the 'apid' of 'airports' and 'src_apid' of 'routes' to combine relevant data.", "The results are grouped by 'src_apid' to aggregate the data based on source airports.", "The results are ordered by the count of routes in descending order to show the most active source airports first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.name ,  T1.city ,  T2.src_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T2.src_apid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "description": "This virtual table provides a list of airport names and their corresponding cities from the 'airports' table, along with the source airport IDs from the 'routes' table. The results are grouped by source airport ID and ordered by the number of routes originating from each airport, limited to a specified number of results.", "virtual_table": "SELECT T1.name ,  T1.city ,  T2.src_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T2.src_apid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6841", "db_id": "flight_4", "question": "Which countries has the most number of airlines?", "rationale": ["The query identifies the relevant table, which is 'airlines'.", "It selects the 'country' column to display the countries where airlines are based.", "The results are grouped by 'country' to aggregate the data.", "The query orders the results by the count of airlines in each country in descending order.", "A limit is applied to restrict the number of countries returned, using a placeholder for numeric values."], "gold_sql": "SELECT country FROM airlines GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airlines"], "description": "This virtual table provides a list of countries where airlines are based, grouped by country and ordered by the number of airlines in each country. The placeholder in the LIMIT clause allows the user to specify the maximum number of countries to return.", "virtual_table": "SELECT country FROM airlines GROUP BY country ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6842", "db_id": "flight_4", "question": "What is the name of the country with the most number of home airlines?", "rationale": ["The query identifies the relevant table, which is 'airlines'.", "It selects the 'country' column to display the countries where airlines are based.", "The GROUP BY clause is used to group the results by 'country'.", "The ORDER BY clause sorts the countries based on the count of airlines in descending order.", "The LIMIT clause uses a placeholder to allow the user to specify how many countries to return."], "gold_sql": "SELECT country FROM airlines GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airlines"], "description": "This virtual table provides a list of countries where airlines are based, grouped by country and ordered by the number of airlines in each country. The placeholder in the LIMIT clause allows the user to specify the maximum number of countries to return.", "virtual_table": "SELECT country FROM airlines GROUP BY country ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6858", "db_id": "flight_4", "question": "What are the cities that have more than 2 airports sorted by number of airports?", "rationale": ["The query identifies the relevant table, which is 'airports'.", "It selects the 'city' column to display the names of cities.", "The GROUP BY clause is used to group the results by city.", "The HAVING clause filters the groups to include only those cities that have a count of airports greater than a specified number, using a placeholder for numeric values.", "Finally, the results are ordered by the count of airports in ascending order."], "gold_sql": "SELECT city FROM airports GROUP BY city HAVING count(*)  >  2 ORDER BY count(*)", "source_tables": ["airports"], "description": "This virtual table provides a list of cities that have more than a specified number of airports. The placeholder in the HAVING clause represents the minimum count of airports required for a city to be included in the results.", "virtual_table": "SELECT city FROM airports GROUP BY city HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER] ORDER BY count(*)"}
{"sample_id": "train.6862", "db_id": "flight_4", "question": "For each  airport name, how many routes start at that airport, ordered from most to least?", "rationale": ["The query identifies the relevant tables, which are 'airports' and 'routes'.", "It selects the count of routes and the name of the airport from the 'airports' table, using an alias for clarity.", "A JOIN operation is performed between 'airports' and 'routes' on the source airport ID to link the two tables.", "The results are grouped by the airport name to aggregate the count of routes for each airport.", "Finally, the results are ordered in descending order based on the count of routes to show the most active airports first."], "gold_sql": "SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name ORDER BY count(*) DESC", "source_tables": ["airports", "routes"], "description": "This virtual table provides a count of routes originating from each airport, along with the airport names. The data is aggregated by airport name and sorted in descending order based on the number of routes.", "virtual_table": "SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name ORDER BY count(*) DESC"}
{"sample_id": "train.6867", "db_id": "flight_4", "question": "For each country and airline name, how many routes are there?", "rationale": ["The query identifies the relevant tables, which are 'airlines' and 'routes'.", "It selects the 'country' and 'name' columns from the 'airlines' table and counts the number of routes associated with each airline.", "The JOIN operation links the 'airlines' table with the 'routes' table based on the airline ID, ensuring that only routes operated by the airlines are counted.", "The GROUP BY clause is used to aggregate the results by 'country' and 'name', providing a count of routes for each airline in each country."], "gold_sql": "SELECT T1.country ,  T1.name ,  count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.country ,  T1.name", "source_tables": ["routes", "airlines"], "description": "This virtual table summarizes the number of routes operated by each airline, grouped by the country and name of the airline. The placeholders in the query allow for dynamic filtering based on the airline's country and name.", "virtual_table": "SELECT T1.country ,  T1.name ,  count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.country ,  T1.name"}
{"sample_id": "train.6868", "db_id": "flight_4", "question": "What is the total number of routes for each country and airline in that country?", "rationale": ["The query identifies the relevant tables, which are 'airlines' and 'routes'.", "It selects the 'country' and 'name' columns from the 'airlines' table and counts the number of routes associated with each airline.", "The JOIN operation links the 'airlines' table with the 'routes' table based on the airline ID, ensuring that only routes operated by the airlines are counted.", "The GROUP BY clause is used to aggregate the results by 'country' and 'name', providing a count of routes for each airline in each country."], "gold_sql": "SELECT T1.country ,  T1.name ,  count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.country ,  T1.name", "source_tables": ["routes", "airlines"], "description": "This virtual table summarizes the number of routes operated by each airline, grouped by the country and name of the airline. The placeholders in the query allow for dynamic filtering based on the airline's country and name.", "virtual_table": "SELECT T1.country ,  T1.name ,  count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.country ,  T1.name"}
{"sample_id": "train.6873", "db_id": "flight_4", "question": "Find the number of routes that have destination John F Kennedy International Airport.", "rationale": ["The query identifies the relevant tables, which are 'airports' and 'routes'.", "It uses a JOIN operation to connect the two tables based on the destination airport ID.", "The SELECT statement counts the number of routes that match the specified destination airport name using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.name  =  'John F Kennedy International Airport'", "source_tables": ["airports", "routes"], "description": "This virtual table provides the count of routes that lead to a specific destination airport from the 'airports' and 'routes' tables. The placeholder in the WHERE clause represents the name of the destination airport.", "virtual_table": "SELECT count(*) FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6880", "db_id": "flight_4", "question": "What is the name of the airline with the most routes?", "rationale": ["The query identifies the relevant tables, which are 'airlines' and 'routes'.", "It selects the 'name' column from the 'airlines' table, aliased as T1.", "A JOIN operation is performed between 'airlines' and 'routes' on the airline ID (alid) to associate airlines with their routes.", "The results are grouped by the airline name to aggregate the count of routes for each airline.", "The results are ordered in descending order based on the count of routes, allowing us to see which airlines operate the most routes.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.name FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["routes", "airlines"], "description": "This virtual table provides a list of airline names from the 'airlines' table that are associated with routes in the 'routes' table. The results are grouped by airline name and ordered by the number of routes each airline operates, with a limit on the number of results returned as specified by the placeholder.", "virtual_table": "SELECT T1.name FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6883", "db_id": "flight_4", "question": "Find the busiest destination airport that runs most number of routes in China.", "rationale": ["The query identifies the relevant tables, which are 'airports' and 'routes'.", "It selects the 'name' column from the 'airports' table, aliased as T1.", "The query joins the 'airports' table with the 'routes' table on the destination airport ID.", "A condition is added to filter the results based on the specified country using a placeholder for string values.", "The results are grouped by airport name to aggregate the data.", "The results are ordered by the count of routes in descending order to show the most popular destinations first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.country  =  'China' GROUP BY T1.name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "description": "The virtual table describes the names of airports located in a specific country that serve as destinations for routes. The query joins the 'airports' table with the 'routes' table to filter the airports based on the specified country. The results are grouped by airport name and ordered by the number of routes to each airport in descending order, with a limit on the number of results returned.", "virtual_table": "SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6884", "db_id": "flight_4", "question": "What is the name of the airport that is the destination of the most number of routes that start in China?", "rationale": ["The query identifies the relevant tables, which are 'airports' and 'routes'.", "It selects the 'name' column from the 'airports' table, aliased as T1.", "The query joins the 'airports' table with the 'routes' table on the destination airport ID to filter the results.", "A condition is added to filter the airports based on the specified country using a placeholder for string values.", "The results are grouped by airport name to aggregate the data.", "The results are ordered by the count of routes in descending order to show the most popular destinations first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.country  =  'China' GROUP BY T1.name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "description": "The virtual table describes the names of airports located in a specific country that serve as destinations for routes. The query joins the 'airports' table with the 'routes' table to filter and group the results based on the country of the airports. The placeholders in the WHERE clause represent the country name, and the LIMIT clause allows for specifying the maximum number of results to return.", "virtual_table": "SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6980", "db_id": "culture_company", "question": "Show all publishers which do not have a book in 1989.", "rationale": ["The query identifies the relevant table, which is 'book_club'.", "It selects the 'publisher' column to display.", "The EXCEPT clause is used to exclude publishers from the results based on a specific year, using a placeholder for numeric values."], "gold_sql": "SELECT publisher FROM book_club EXCEPT SELECT publisher FROM book_club WHERE YEAR  =  1989", "source_tables": ["book_club"], "description": "This virtual table lists the publishers of books discussed in the 'book_club' table, excluding those publishers whose books were discussed in a specific year. The placeholder in the WHERE clause represents the year to filter out the publishers.", "virtual_table": "SELECT publisher FROM book_club EXCEPT SELECT publisher FROM book_club WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6990", "db_id": "culture_company", "question": "Show all director names who have a movie in the year 1999 or 2000.", "rationale": ["The query identifies the relevant table, which is 'movie'.", "Select the column to display, 'director'.", "Add a condition to filter the 'Year' column for the specified years using placeholders for numeric values."], "gold_sql": "SELECT director FROM movie WHERE YEAR  =  1999 OR YEAR  =  2000", "source_tables": ["movie"], "description": "The virtual table describes the directors of movies released in specific years from the 'movie' table. The placeholders in the WHERE clause represent the years of interest.", "virtual_table": "SELECT director FROM movie WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER] OR YEAR  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6991", "db_id": "culture_company", "question": "Which directors had a movie in either 1999 or 2000?", "rationale": ["The query identifies the relevant table, which is 'movie'.", "Select the column to display, 'director'.", "Add a condition to filter the 'Year' column for the specified years using placeholders for numeric values."], "gold_sql": "SELECT director FROM movie WHERE YEAR  =  1999 OR YEAR  =  2000", "source_tables": ["movie"], "description": "This virtual table provides the names of directors from the 'movie' table for movies released in specific years. The placeholders in the WHERE clause represent the years of interest.", "virtual_table": "SELECT director FROM movie WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER] OR YEAR  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6996", "db_id": "culture_company", "question": "Show the movie titles and book titles for all companies in China.", "rationale": ["The query identifies the relevant tables: 'movie', 'culture_company', and 'book_club'.", "It selects the 'title' from the 'movie' table and 'book_title' from the 'book_club' table.", "The JOIN operations link the 'movie' table to the 'culture_company' table using 'movie_id', and the 'culture_company' table to the 'book_club' table using 'book_club_id'.", "A condition is added to filter results based on the 'incorporated_in' year from the 'culture_company' table using a placeholder for string values."], "gold_sql": "SELECT T1.title ,  T3.book_title FROM movie AS T1 JOIN culture_company AS T2 ON T1.movie_id  =  T2.movie_id JOIN book_club AS T3 ON T3.book_club_id  =  T2.book_club_id WHERE T2.incorporated_in  =  'China'", "source_tables": ["culture_company", "movie", "book_club"], "description": "This virtual table describes the titles of movies and the corresponding book titles discussed in book clubs, filtered by the year a cultural company was incorporated. The placeholders in the WHERE clause represent the year of incorporation.", "virtual_table": "SELECT T1.title ,  T3.book_title FROM movie AS T1 JOIN culture_company AS T2 ON T1.movie_id  =  T2.movie_id JOIN book_club AS T3 ON T3.book_club_id  =  T2.book_club_id WHERE T2.incorporated_in  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.95", "db_id": "car_1", "question": "Which model of the car has the minimum horsepower?", "rationale": ["The query identifies the relevant tables, 'car_names' and 'cars_data'.", "It selects the 'Model' column from the 'car_names' table.", "A JOIN operation is performed between 'car_names' and 'cars_data' on the condition that 'MakeId' from 'car_names' matches 'Id' from 'cars_data'.", "The results are ordered by the 'horsepower' column from 'cars_data' in ascending order.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "description": "This virtual table lists the car models from the 'car_names' table, ordered by their horsepower in ascending order. The placeholder in the LIMIT clause represents the maximum number of car models to be displayed.", "virtual_table": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.103", "db_id": "car_1", "question": "Which distinct car models are the produced after 1980?", "rationale": ["The query identifies the relevant tables: 'model_list', 'car_names', and 'cars_data'.", "It selects distinct car models from the 'model_list' table.", "The JOIN operations link the 'model_list' to 'car_names' based on the model name, and then to 'cars_data' using the MakeId.", "A condition is added to filter the results to include only those models manufactured after a specified year, using a placeholder for numeric values."], "gold_sql": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  1980;", "source_tables": ["model_list", "car_names", "cars_data"], "description": "This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.", "virtual_table": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.106", "db_id": "car_1", "question": "What is the name of each continent and how many car makers are there in each one?", "rationale": ["The query identifies the relevant tables: 'continents', 'countries', and 'car_makers'.", "It selects the 'Continent' from the 'continents' table and counts the number of entries.", "The JOIN operations link the 'countries' table to the 'continents' table using the continent identifier, and the 'car_makers' table to the 'countries' table using the country identifier.", "The GROUP BY clause is used to aggregate the count of car makers for each continent."], "gold_sql": "SELECT T1.Continent ,  count(*) FROM CONTINENTS AS T1 JOIN COUNTRIES AS T2 ON T1.ContId  =  T2.continent JOIN car_makers AS T3 ON T2.CountryId  =  T3.Country GROUP BY T1.Continent;", "source_tables": ["countries", "car_makers", "continents"], "description": "This virtual table provides a count of car makers grouped by continent. It joins the 'continents' table with the 'countries' table to associate each country with its continent, and then further joins with the 'car_makers' table to count the number of car makers from each continent. The placeholder in the SELECT statement represents the continent's name.", "virtual_table": "SELECT T1.Continent ,  count(*) FROM CONTINENTS AS T1 JOIN COUNTRIES AS T2 ON T1.ContId  =  T2.continent JOIN car_makers AS T3 ON T2.CountryId  =  T3.Country GROUP BY T1.Continent;"}
{"sample_id": "dev.111", "db_id": "car_1", "question": "What is the accelerate of the car make amc hornet sportabout (sw)?", "rationale": ["The query identifies the relevant tables, which are 'cars_data' and 'car_names'.", "It selects the 'Accelerate' column from the 'cars_data' table.", "A JOIN operation is performed to link 'cars_data' with 'car_names' based on the matching 'Id' and 'MakeId'.", "A condition is added to filter the results based on the specified car make using a placeholder for string values."], "gold_sql": "SELECT T1.Accelerate FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Make  =  'amc hornet sportabout (sw)';", "source_tables": ["cars_data", "car_names"], "description": "The virtual table describes the acceleration times of cars from the 'cars_data' table, filtered by a specific car make from the 'car_names' table. The placeholder in the WHERE clause represents the name of the car make.", "virtual_table": "SELECT T1.Accelerate FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Make  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "dev.113", "db_id": "car_1", "question": "How many car makers are there in france?", "rationale": ["The query identifies the relevant tables, which are 'car_makers' and 'countries'.", "It uses a JOIN operation to connect these tables based on the country identifier.", "The SELECT statement counts the number of car makers that match the specified country name using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  'france';", "source_tables": ["car_makers", "countries"], "description": "This virtual table provides the count of car makers based in a specific country. It joins the 'car_makers' table with the 'countries' table using the country identifier, and filters the results based on the specified country name.", "virtual_table": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "dev.114", "db_id": "car_1", "question": "What is the number of makers of care in France?", "rationale": ["The query identifies the relevant tables, which are 'car_makers' and 'countries'.", "It uses a JOIN operation to combine these tables based on the country identifier.", "The SELECT statement counts the number of car makers that match the specified country name using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  'france';", "source_tables": ["car_makers", "countries"], "description": "This virtual table provides the count of car makers based in a specific country. It joins the 'car_makers' table with the 'countries' table using the country identifier, and filters the results based on the specified country name.", "virtual_table": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "dev.115", "db_id": "car_1", "question": "How many car models are produced in the usa?", "rationale": ["The query identifies the relevant tables: 'model_list', 'car_makers', and 'countries'.", "It uses JOIN operations to connect these tables based on their foreign key relationships: 'Maker' in 'model_list' with 'Id' in 'car_makers', and 'Country' in 'car_makers' with 'CountryId' in 'countries'.", "The SELECT statement counts the number of car models that meet the specified condition.", "A condition is added to filter the results based on the 'CountryName' column in the 'countries' table using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  'usa';", "source_tables": ["car_makers", "model_list", "countries"], "description": "This virtual table provides the count of car models from the 'model_list' table that are associated with car makers from a specific country. The placeholders in the WHERE clause represent the name of the country being queried.", "virtual_table": "SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "dev.129", "db_id": "car_1", "question": "Which countries in europe have at least 3 car manufacturers?", "rationale": ["The query identifies the relevant tables: 'countries', 'continents', and 'car_makers'.", "It selects the 'CountryName' from the 'countries' table.", "The JOIN operation connects 'countries' with 'continents' based on the continent identifier, allowing filtering by continent.", "Another JOIN connects 'countries' with 'car_makers' to ensure that only countries with car makers are included.", "The GROUP BY clause groups the results by 'CountryName' to aggregate the data.", "The HAVING clause filters the grouped results to include only those countries that have a count of car makers greater than or equal to a specified number."], "gold_sql": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  'europe' GROUP BY T1.CountryName HAVING count(*)  >=  3;", "source_tables": ["continents", "car_makers", "countries"], "description": "This virtual table lists the names of countries from the 'countries' table that belong to a specific continent. It joins the 'continents' table to filter countries by continent and the 'car_makers' table to ensure that the countries have associated car makers. The placeholders in the WHERE clause represent the continent's name and the minimum count of car makers per country.", "virtual_table": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.CountryName HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.131", "db_id": "car_1", "question": "What is the maximum horsepower and the make of the car models with 3 cylinders?", "rationale": ["The query identifies the relevant tables, 'car_names' and 'cars_data', and uses a JOIN to combine them based on the relationship between 'MakeId' and 'Id'.", "It selects the 'Make' from 'car_names' and 'horsepower' from 'cars_data'.", "A condition is added to filter the results based on the number of cylinders using a placeholder for numeric values.", "The results are ordered by 'horsepower' in descending order to show the most powerful cars first.", "A limit is applied to restrict the number of results returned, using another placeholder for numeric values."], "gold_sql": "SELECT T2.horsepower ,  T1.Make FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.cylinders  =  3 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "description": "This virtual table provides a list of car makes along with their corresponding horsepower from the 'car_names' and 'cars_data' tables. The results are filtered to include only those cars with a specific number of cylinders, represented by a placeholder for numeric values. Additionally, the results are ordered by horsepower in descending order, and the number of results returned is limited by another numeric placeholder.", "virtual_table": "SELECT T2.horsepower ,  T1.Make FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.cylinders  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY T2.horsepower DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.133", "db_id": "car_1", "question": "Which model saves the most gasoline? That is to say, have the maximum miles per gallon.", "rationale": ["The query identifies the relevant tables, 'car_names' and 'cars_data'.", "It selects the 'Model' column from the 'car_names' table.", "A JOIN operation is performed between 'car_names' and 'cars_data' on the 'MakeId' and 'Id' columns to combine data from both tables.", "The results are ordered by the 'MPG' column from the 'cars_data' table in descending order to show the most fuel-efficient models first.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.mpg DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "description": "The virtual table describes the car models from the 'car_names' table, ordered by their fuel efficiency (MPG) in descending order. The placeholder in the LIMIT clause represents the maximum number of car models to return.", "virtual_table": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.mpg DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.150", "db_id": "car_1", "question": "What are the names and ids of all makers with more than 3 models?", "rationale": ["The query identifies the relevant tables, which are 'car_makers' and 'model_list'.", "It selects the 'FullName' and 'Id' columns from the 'car_makers' table.", "A JOIN operation is performed between 'car_makers' and 'model_list' on the 'Id' and 'Maker' columns respectively to associate car makers with their models.", "The results are grouped by the 'Id' of the car makers to aggregate the number of models they have produced.", "The HAVING clause is used to filter the grouped results to include only those car makers that have produced more than a specified number of models, using a placeholder for numeric values."], "gold_sql": "SELECT T1.FullName ,  T1.Id FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >  3;", "source_tables": ["car_makers", "model_list"], "description": "This virtual table provides a list of car makers along with their unique identifiers from the 'car_makers' table. It filters the results to include only those car makers that have produced more than a specified number of car models, as indicated by the placeholder in the HAVING clause.", "virtual_table": "SELECT T1.FullName ,  T1.Id FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.158", "db_id": "car_1", "question": "For a volvo model, how many cylinders does the version with least accelerate have?", "rationale": ["The query identifies the relevant tables, 'cars_data' and 'car_names'.", "It selects the 'cylinders' column from the 'cars_data' table.", "A JOIN operation is performed to connect 'cars_data' with 'car_names' based on the matching 'Id' and 'MakeId'.", "A condition is added to filter results based on a specific car model using a placeholder for string values.", "The results are ordered by the 'accelerate' column in ascending order.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  'volvo' ORDER BY T1.accelerate ASC LIMIT 1;", "source_tables": ["cars_data", "car_names"], "description": "This virtual table provides the number of cylinders for cars from the 'cars_data' table, filtered by a specific car model from the 'car_names' table. The results are ordered by the acceleration time in ascending order, and the query limits the output to a specified number of entries. The placeholders represent the car model name and the limit on the number of results.", "virtual_table": "SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.accelerate ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.160", "db_id": "car_1", "question": "What is the number of cars with a greater accelerate than the one with the most horsepower?", "rationale": ["The query identifies the relevant table, which is 'cars_data'.", "It counts the number of entries in 'cars_data' where the 'Accelerate' value is greater than a certain threshold.", "The threshold is determined by a subquery that selects the 'Accelerate' value from the top specified number of cars ordered by 'Horsepower' in descending order, using a placeholder for the number of top cars."], "gold_sql": "SELECT COUNT(*) FROM CARS_DATA WHERE Accelerate  >  ( SELECT Accelerate FROM CARS_DATA ORDER BY Horsepower DESC LIMIT 1 );", "source_tables": ["cars_data"], "description": "This virtual table provides a count of cars from the 'cars_data' table that have an acceleration time greater than the acceleration time of the top specified number of cars with the highest horsepower. The placeholder in the subquery represents the number of top cars to consider based on horsepower.", "virtual_table": "SELECT COUNT(*) FROM CARS_DATA WHERE Accelerate  >  ( SELECT Accelerate FROM CARS_DATA ORDER BY Horsepower DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] );"}
{"sample_id": "dev.165", "db_id": "car_1", "question": "For the cars with 4 cylinders, which model has the largest horsepower?", "rationale": ["The query identifies the relevant tables, 'car_names' and 'cars_data'.", "It selects the 'Model' column from the 'car_names' table.", "A JOIN operation is performed between 'car_names' and 'cars_data' on the 'MakeId' and 'Id' columns to combine relevant data.", "A condition is added to filter the results based on the number of cylinders using a placeholder for numeric values.", "The results are ordered by the 'horsepower' column in descending order to show the most powerful cars first.", "A LIMIT clause is included to restrict the number of results returned, using another placeholder for numeric values."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  4 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "description": "This virtual table lists the car models from the 'car_names' table that have a specific number of cylinders. The results are ordered by the horsepower of the cars in descending order, and the number of results returned is limited by a placeholder value.", "virtual_table": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY T2.horsepower DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.166", "db_id": "car_1", "question": "For all of the 4 cylinder cars, which model has the most horsepower?", "rationale": ["The query identifies the relevant tables, 'car_names' and 'cars_data'.", "It selects the 'Model' column from the 'car_names' table.", "A JOIN operation is performed between 'car_names' and 'cars_data' on the 'MakeId' and 'Id' columns respectively to combine relevant data.", "A condition is added to filter the results based on the number of cylinders using a placeholder for numeric values.", "The results are ordered by the 'horsepower' column in descending order to show the most powerful cars first.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  4 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "description": "This virtual table lists the car models from the 'car_names' table that have a specific number of cylinders. The results are ordered by the horsepower of the cars in descending order, and the number of results returned is limited by a placeholder value.", "virtual_table": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY T2.horsepower DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.168", "db_id": "car_1", "question": "Among the cars that do not have the minimum horsepower , what are the make ids and names of all those with less than 4 cylinders ?", "rationale": ["The query identifies the relevant tables, 'cars_data' and 'car_names'.", "It selects the 'makeid' and 'make' columns from the 'car_names' table.", "A JOIN operation is performed on 'cars_data' and 'car_names' using the 'id' and 'makeid' columns to link the data.", "A condition is added to filter cars with horsepower greater than the minimum horsepower from 'cars_data'.", "Another condition is included to filter cars with a cylinder count less than a specified number using a placeholder for numeric values."], "gold_sql": "select t2.makeid ,  t2.make from cars_data as t1 join car_names as t2 on t1.id  =  t2.makeid where t1.horsepower  >  (select min(horsepower) from cars_data) and t1.cylinders  <  4;", "source_tables": ["cars_data", "car_names"], "description": "This virtual table provides a list of car makes and their identifiers from the 'car_names' table, specifically for cars that have a horsepower greater than the minimum horsepower recorded in the 'cars_data' table and have a cylinder count less than a specified number. The placeholder in the WHERE clause represents the maximum number of cylinders allowed.", "virtual_table": "select t2.makeid ,  t2.make from cars_data as t1 join car_names as t2 on t1.id  =  t2.makeid where t1.horsepower  >  (select min(horsepower) from cars_data) and t1.cylinders  <  [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.176", "db_id": "car_1", "question": "What are the ids and makers of all car makers that produce at least 2 models and make more than 3 cars?", "rationale": ["The query identifies the relevant tables, which are 'CAR_MAKERS', 'MODEL_LIST', and 'CAR_NAMES'.", "It selects the 'Id' and 'Maker' columns from 'CAR_MAKERS' and joins it with 'MODEL_LIST' to count the number of models for each maker.", "The first part of the query groups by 'Id' and filters those with a count of models greater than or equal to a specified number using a placeholder.", "The second part of the query performs a similar operation but includes an additional join with 'CAR_NAMES' to count the number of names associated with each model.", "The use of INTERSECT ensures that only car makers who meet both criteria are included in the final result."], "gold_sql": "SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >=  2 INTERSECT SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker JOIN CAR_NAMES AS T3 ON T2.model  =  T3.model GROUP BY T1.Id HAVING count(*)  >  3;", "source_tables": ["car_makers", "car_names", "model_list"], "description": "This virtual table identifies car makers who have produced a significant number of car models, as well as those who have a specific number of car names associated with their models. The placeholders in the HAVING clauses represent the minimum counts of models and names, respectively.", "virtual_table": "SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker JOIN CAR_NAMES AS T3 ON T2.model  =  T3.model GROUP BY T1.Id HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.180", "db_id": "flight_2", "question": "What country is Jetblue Airways affiliated with?", "rationale": ["The query identifies the relevant table, which is 'airlines'.", "Select the column to display, 'Country'.", "Add a condition to filter the 'Airline' column for the specified airline using a placeholder for string values."], "gold_sql": "SELECT Country FROM AIRLINES WHERE Airline  =  'JetBlue Airways'", "source_tables": ["airlines"], "description": "This virtual table provides the country of an airline based on its name. The placeholder in the WHERE clause represents the specific airline's name for which the country is being queried.", "virtual_table": "SELECT Country FROM AIRLINES WHERE Airline  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.194", "db_id": "flight_2", "question": "Give the airline with abbreviation 'UAL'.", "rationale": ["The query is identifying the relevant table, which is 'airlines'.", "Select the column to display, 'Airline'.", "Add a condition to filter the 'Abbreviation' column for the specified abbreviation using a placeholder for string values."], "gold_sql": "SELECT Airline FROM AIRLINES WHERE Abbreviation  =  'UAL'", "source_tables": ["airlines"], "description": "This virtual table describes the names of airlines from the 'airlines' table that match a specific abbreviation. The placeholder in the WHERE clause represents the abbreviation of the airline.", "virtual_table": "SELECT Airline FROM AIRLINES WHERE Abbreviation  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.214", "db_id": "flight_2", "question": "Give the number of Jetblue Airways flights.", "rationale": ["The query identifies the relevant tables, which are 'flights' and 'airlines'.", "It uses a JOIN operation to connect the 'flights' table with the 'airlines' table based on the airline's unique identifier.", "The SELECT statement counts the total number of flights for the specified airline.", "A condition is added to filter the results by the airline's name using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T1.Airline  =  T2.uid WHERE T2.Airline = 'JetBlue Airways'", "source_tables": ["flights", "airlines"], "description": "This virtual table provides the count of flights operated by a specific airline from the 'flights' table. It joins the 'flights' table with the 'airlines' table to filter the results based on the airline's name. The placeholder in the WHERE clause represents the name of the airline for which the flight count is being queried.", "virtual_table": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T1.Airline  =  T2.uid WHERE T2.Airline = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.225", "db_id": "flight_2", "question": "What is the code of airport that has the highest number of flights?", "rationale": ["The query identifies the relevant tables, 'airports' and 'flights'.", "It selects the 'AirportCode' from the 'airports' table.", "A JOIN operation is performed between 'airports' and 'flights' on the condition that the airport code matches either the source or destination airport code.", "The results are grouped by 'AirportCode' to aggregate the data.", "The results are ordered by the count of flights associated with each airport in descending order.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "flights"], "description": "This virtual table lists the airport codes from the 'airports' table that are either source or destination airports for flights in the 'flights' table. The results are grouped by airport code and ordered by the number of flights associated with each airport, with a limit on the number of results returned based on a specified number.", "virtual_table": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.227", "db_id": "flight_2", "question": "What is the code of airport that has fewest number of flights?", "rationale": ["The query identifies the relevant tables, which are 'airports' and 'flights'.", "It selects the 'AirportCode' from the 'airports' table.", "A JOIN operation is performed between 'airports' and 'flights' on the condition that the airport code matches either the source or destination airport code.", "The results are grouped by 'AirportCode' to ensure uniqueness.", "The results are ordered by the count of flights associated with each airport code, and a limit is applied to restrict the number of results returned based on a placeholder for numeric values."], "gold_sql": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) LIMIT 1", "source_tables": ["airports", "flights"], "description": "This virtual table lists unique airport codes from the 'airports' table that are either source or destination for flights in the 'flights' table. The placeholder in the LIMIT clause represents the maximum number of airport codes to return.", "virtual_table": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.229", "db_id": "flight_2", "question": "Which airline has most number of flights?", "rationale": ["The query identifies the relevant tables, which are 'airlines' and 'flights'.", "It selects the 'Airline' column from the 'airlines' table, using an alias for clarity.", "A JOIN operation is performed between the 'airlines' and 'flights' tables based on the unique identifier of the airline.", "The results are grouped by the airline name to aggregate the flight counts.", "The results are ordered by the count of flights in descending order to show the most active airlines first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) DESC LIMIT 1", "source_tables": ["flights", "airlines"], "description": "This virtual table provides a list of airlines from the 'airlines' table that are associated with flights in the 'flights' table. The results are grouped by airline name and ordered by the number of flights in descending order, with a limit on the number of results specified by a placeholder for numeric values.", "virtual_table": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.232", "db_id": "flight_2", "question": "What is the abbreviation of the airilne has the fewest flights and what country is it in?", "rationale": ["The query identifies the relevant tables, which are 'airlines' and 'flights'.", "It selects the 'Abbreviation' and 'Country' columns from the 'airlines' table, aliased as T1.", "A JOIN operation is performed between 'airlines' and 'flights' on the airline identifier to link the two tables.", "The results are grouped by the 'Airline' to aggregate the data based on the number of flights operated.", "The ORDER BY clause is used to sort the results by the count of flights in descending order.", "The LIMIT clause is included to allow the user to specify the maximum number of results to return."], "gold_sql": "SELECT T1.Abbreviation ,  T1.Country FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) LIMIT 1", "source_tables": ["flights", "airlines"], "description": "This virtual table provides a summary of the abbreviations and countries of airlines that operate flights. The data is aggregated by airline, showing the most frequently operating airlines based on the number of flights. The placeholder in the LIMIT clause allows the user to specify how many results they want to retrieve.", "virtual_table": "SELECT T1.Abbreviation ,  T1.Country FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.244", "db_id": "flight_2", "question": "Which airlines have less than 200 flights?", "rationale": ["The query identifies the relevant tables, which are 'airlines' and 'flights'.", "It selects the 'Airline' column from the 'airlines' table.", "A JOIN operation is performed between 'airlines' and 'flights' on the airline identifier to link the two tables.", "The results are grouped by the airline name to aggregate the flight counts.", "The HAVING clause filters the groups to include only those airlines that operate fewer flights than the specified number using a placeholder for numeric values."], "gold_sql": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  <  200", "source_tables": ["flights", "airlines"], "description": "This virtual table lists the names of airlines from the 'airlines' table that operate fewer flights than a specified number. The placeholder in the HAVING clause represents the maximum number of flights an airline can operate.", "virtual_table": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.258", "db_id": "flight_2", "question": "Which airports do not have departing or arriving flights?", "rationale": ["The query identifies the relevant table, which is 'Airports'.", "It selects the 'AirportName' column to display the names of the airports.", "The condition filters out airports that are either source or destination for any flights by using a subquery that combines both source and destination airports with a UNION operation."], "gold_sql": "SELECT AirportName FROM Airports WHERE AirportCode NOT IN (SELECT SourceAirport FROM Flights UNION SELECT DestAirport FROM Flights)", "source_tables": ["airports", "flights"], "description": "This virtual table lists the names of airports from the 'Airports' table that do not serve as departure or arrival points for any flights. The query uses a subquery to identify airports that are involved in flights, ensuring that only airports without any flight connections are included.", "virtual_table": "SELECT AirportName FROM Airports WHERE AirportCode NOT IN (SELECT SourceAirport FROM Flights UNION SELECT DestAirport FROM Flights)"}
{"sample_id": "dev.308", "db_id": "cre_Doc_Template_Mgt", "question": "Count the number of documents that use the PPT template type.", "rationale": ["The query identifies the relevant tables, which are 'Documents' and 'Templates'.", "It uses a JOIN operation to link the two tables based on the 'Template_ID'.", "The SELECT statement counts the number of documents that match the specified template type code, using a placeholder for string values in the WHERE clause."], "gold_sql": "SELECT count(*) FROM Documents AS T1 JOIN Templates AS T2 ON T1.Template_ID  =  T2.Template_ID WHERE T2.Template_Type_Code  =  'PPT'", "source_tables": ["templates", "documents"], "description": "This virtual table provides a count of documents associated with a specific type of template from the 'Documents' and 'Templates' tables. The placeholder in the WHERE clause represents the unique code for the template type.", "virtual_table": "SELECT count(*) FROM Documents AS T1 JOIN Templates AS T2 ON T1.Template_ID  =  T2.Template_ID WHERE T2.Template_Type_Code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.311", "db_id": "cre_Doc_Template_Mgt", "question": "What is the id and type code for the template used by the most documents?", "rationale": ["The query identifies the relevant tables, 'Documents' and 'Templates', and uses an alias for clarity.", "It selects the 'template_id' from the 'Documents' table and the 'Template_Type_Code' from the 'Templates' table.", "A JOIN operation is performed on the 'template_id' to link documents with their respective templates.", "The results are grouped by 'template_id' to aggregate the data accordingly.", "The results are ordered by the count of documents associated with each template in descending order.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.template_id ,  T2.Template_Type_Code FROM Documents AS T1 JOIN Templates AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["templates", "documents"], "description": "This virtual table provides a list of template IDs along with their corresponding template type codes from the 'Documents' and 'Templates' tables. The results are grouped by template ID and ordered by the count of documents associated with each template, limited to a specified number of results.", "virtual_table": "SELECT T1.template_id ,  T2.Template_Type_Code FROM Documents AS T1 JOIN Templates AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.312", "db_id": "cre_Doc_Template_Mgt", "question": "Return the id and type code of the template that is used for the greatest number of documents.", "rationale": ["The query identifies the relevant tables, 'Documents' and 'Templates', and uses an alias for clarity.", "It selects the 'template_id' from the 'Documents' table and the 'Template_Type_Code' from the 'Templates' table.", "A JOIN operation is performed on the 'template_id' to link documents with their respective templates.", "The results are grouped by 'template_id' to aggregate the data accordingly.", "The results are ordered by the count of documents associated with each template in descending order.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.template_id ,  T2.Template_Type_Code FROM Documents AS T1 JOIN Templates AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["templates", "documents"], "description": "This virtual table provides a list of template IDs along with their corresponding template type codes from the 'Documents' and 'Templates' tables. The results are grouped by template ID and ordered by the count of documents associated with each template, limited to a specified number of results.", "virtual_table": "SELECT T1.template_id ,  T2.Template_Type_Code FROM Documents AS T1 JOIN Templates AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.341", "db_id": "cre_Doc_Template_Mgt", "question": "Show all template type codes and the number of documents using each type.", "rationale": ["The query identifies the relevant tables, which are 'Templates' and 'Documents'.", "It selects the 'template_type_code' from the 'Templates' table and counts the number of documents associated with each template type.", "A JOIN operation is performed between 'Templates' and 'Documents' on the 'template_id' to link templates with their corresponding documents.", "The results are grouped by 'template_type_code' to provide a count of documents for each template type."], "gold_sql": "SELECT T1.template_type_code ,  count(*) FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_type_code", "source_tables": ["templates", "documents"], "description": "This virtual table summarizes the count of documents associated with each template type from the 'Templates' and 'Documents' tables. The placeholder in the SELECT statement represents the template type code, and the count indicates the number of documents linked to each template type.", "virtual_table": "SELECT T1.template_type_code ,  count(*) FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_type_code"}
{"sample_id": "dev.346", "db_id": "cre_Doc_Template_Mgt", "question": "What are the codes of template types that are not used for any document?", "rationale": ["The query starts by selecting the 'template_type_code' from the 'Templates' table.", "It uses an EXCEPT clause to find template types that do not have any associated documents.", "The second part of the query involves a JOIN between 'Templates' and 'Documents' on 'template_id' to identify which template types are linked to documents."], "gold_sql": "SELECT template_type_code FROM Templates EXCEPT SELECT template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id", "source_tables": ["templates", "documents"], "description": "This virtual table identifies the unique template type codes from the 'Templates' table that are not associated with any documents in the 'Documents' table. The query uses an EXCEPT clause to filter out template types that have been linked to documents, ensuring that only those template types without any corresponding documents are returned.", "virtual_table": "SELECT template_type_code FROM Templates EXCEPT SELECT template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id"}
{"sample_id": "dev.361", "db_id": "cre_Doc_Template_Mgt", "question": "Show paragraph details for paragraph with text 'Korea ' .", "rationale": ["The query identifies the relevant table, which is 'Paragraphs'.", "Select the column to display, 'Other_Details'.", "Add a condition to filter the 'Paragraph_Text' column using a LIKE clause for the specified text pattern, represented by a placeholder for string values."], "gold_sql": "select other_details from paragraphs where paragraph_text like 'korea'", "source_tables": ["paragraphs"], "description": "This virtual table retrieves additional details from the 'Paragraphs' table for paragraphs that contain specific text. The placeholder in the WHERE clause represents the text pattern to search for within the paragraph content.", "virtual_table": "select other_details from paragraphs where paragraph_text like [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.367", "db_id": "cre_Doc_Template_Mgt", "question": "Show all document ids and the number of paragraphs in each document. Order by document id.", "rationale": ["The query identifies the relevant table, which is 'Paragraphs'.", "It selects the 'document_id' and counts the number of paragraphs associated with each document using the count function.", "The results are grouped by 'document_id' to aggregate the paragraph counts for each document.", "Finally, the results are ordered by 'document_id' to present the data in a structured manner."], "gold_sql": "SELECT document_id ,  count(*) FROM Paragraphs GROUP BY document_id ORDER BY document_id", "source_tables": ["paragraphs"], "description": "This virtual table provides a count of paragraphs associated with each document from the 'Paragraphs' table. The results are grouped by the document identifier, allowing users to see how many paragraphs belong to each document, sorted by the document ID.", "virtual_table": "SELECT document_id ,  count(*) FROM Paragraphs GROUP BY document_id ORDER BY document_id"}
{"sample_id": "dev.439", "db_id": "wta_1", "question": "Find the highest rank of losers in all matches.", "rationale": ["The query identifies the relevant table, which is 'matches'.", "It selects the minimum value of the 'loser_rank' column to find the lowest rank of losing players.", "The use of the aggregate function 'min' allows for the calculation of the minimum rank across all matches."], "gold_sql": "SELECT min(loser_rank) FROM matches", "source_tables": ["matches"], "description": "This virtual table provides the minimum rank of losing players from the 'matches' table. The query aggregates the data to find the lowest rank among all losing players in the recorded matches.", "virtual_table": "SELECT min(loser_rank) FROM matches"}
{"sample_id": "dev.458", "db_id": "wta_1", "question": "What are the full names of all left handed players, in order of birth date?", "rationale": ["The query identifies the relevant table, which is 'players'.", "Select the columns to display, 'first_name' and 'last_name'.", "Add a condition to filter the 'hand' column for the specified playing hand using a placeholder for string values.", "Order the results by 'birth_date' to sort players by their date of birth."], "gold_sql": "SELECT first_name ,  last_name FROM players WHERE hand  =  'L' ORDER BY birth_date", "source_tables": ["players"], "description": "This virtual table describes the first and last names of players from the 'players' table who play with a specific hand. The results are ordered by the players' birth dates. The placeholder in the WHERE clause represents the playing hand of the players.", "virtual_table": "SELECT first_name ,  last_name FROM players WHERE hand  =  [PLACEHOLDER-TYPE:STRING] ORDER BY birth_date"}
{"sample_id": "dev.464", "db_id": "wta_1", "question": "What is the name of the winner who has won the most matches, and how many rank points does this player have?", "rationale": ["The query identifies the relevant table, which is 'matches'.", "Select the columns to display, 'winner_name' and 'winner_rank_points'.", "Group the results by 'winner_name' to aggregate the data based on the winners.", "Order the results by the count of matches won in descending order to highlight the most successful players.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT winner_name ,  winner_rank_points FROM matches GROUP BY winner_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["matches"], "description": "This virtual table provides the names and ranking points of the winning players from the 'matches' table, grouped by the winner's name. The results are ordered by the number of matches won in descending order, with a limit on the number of results returned, specified by a placeholder for numeric values.", "virtual_table": "SELECT winner_name ,  winner_rank_points FROM matches GROUP BY winner_name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.471", "db_id": "wta_1", "question": "Find the total ranking points for each player and their first name.", "rationale": ["The query identifies the relevant tables, which are 'players' and 'rankings'.", "It selects the sum of 'ranking_points' to calculate the total points for each player.", "The 'first_name' from the 'players' table is included to display the player's name alongside their total ranking points.", "A JOIN operation is performed on 'player_id' to link the two tables, ensuring that the ranking points correspond to the correct player.", "The results are grouped by 'first_name' to aggregate the ranking points for each player."], "gold_sql": "SELECT sum(ranking_points) ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.first_name", "source_tables": ["rankings", "players"], "description": "This virtual table summarizes the total ranking points for each player by their first name. It combines data from the 'players' and 'rankings' tables, grouping the results by the player's first name to provide a clear view of their accumulated ranking points.", "virtual_table": "SELECT sum(ranking_points) ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.first_name"}
{"sample_id": "dev.479", "db_id": "wta_1", "question": "Find the total number of tours for each ranking date.", "rationale": ["The query identifies the relevant table, which is 'rankings'.", "It selects the aggregated sum of the 'tours' column to get the total number of tours for each ranking date.", "The 'ranking_date' column is included to group the results, allowing us to see the total tours for each specific date."], "gold_sql": "SELECT sum(tours) ,  ranking_date FROM rankings GROUP BY ranking_date", "source_tables": ["rankings"], "description": "This virtual table summarizes the total number of tours or events considered for player rankings on each ranking date. The placeholder in the SELECT clause represents the aggregated sum of tours, while the GROUP BY clause organizes the results by the ranking date.", "virtual_table": "SELECT sum(tours) ,  ranking_date FROM rankings GROUP BY ranking_date"}
{"sample_id": "dev.480", "db_id": "wta_1", "question": "How many total tours were there for each ranking date?", "rationale": ["The query identifies the relevant table, which is 'rankings'.", "It selects the sum of the 'tours' column to aggregate the total number of tours for each ranking date.", "The 'ranking_date' column is included to group the results, allowing for a summary of tours per date."], "gold_sql": "SELECT sum(tours) ,  ranking_date FROM rankings GROUP BY ranking_date", "source_tables": ["rankings"], "description": "This virtual table summarizes the total number of tours or events considered for player rankings on each ranking date. The placeholder in the SELECT clause represents the aggregated sum of tours, while the GROUP BY clause organizes the results by the ranking date.", "virtual_table": "SELECT sum(tours) ,  ranking_date FROM rankings GROUP BY ranking_date"}
{"sample_id": "dev.533", "db_id": "student_transcripts_tracking", "question": "Who are enrolled in 2 degree programs in one semester? List the first name, middle name and last name and the id.", "rationale": ["The query identifies the relevant table, which is 'Students', and aliases it as T1.", "It selects the columns to display: 'first_name', 'middle_name', 'last_name', and 'student_id'.", "The query joins the 'Students' table with the 'Student_Enrolment' table (aliased as T2) to link students with their enrolment records.", "It groups the results by 'student_id' to aggregate the data for each student.", "The HAVING clause filters the results to include only those students who are enrolled in a specific number of courses, using a placeholder for numeric values."], "gold_sql": "SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  2", "source_tables": ["student_enrolment", "students"], "description": "This virtual table provides the first name, middle name, last name, and unique identifier of students from the 'Students' table who are enrolled in a specific number of courses. The placeholder in the HAVING clause represents the count of courses the students are enrolled in.", "virtual_table": "SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.536", "db_id": "student_transcripts_tracking", "question": "What are the first, middle, and last names for everybody enrolled in a Bachelors program?", "rationale": ["The query identifies the relevant tables: 'Students', 'Student_Enrolment', and 'Degree_Programs'.", "It selects distinct names (first, middle, last) from the 'Students' table.", "The JOIN operations link the 'Students' table to the 'Student_Enrolment' table using the student ID, and then to the 'Degree_Programs' table using the degree program ID.", "A condition is added to filter the results based on the specified degree program name using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  'Bachelor'", "source_tables": ["student_enrolment", "degree_programs", "students"], "description": "This virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholders in the WHERE clause represent the name of the degree program being queried.", "virtual_table": "SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.537", "db_id": "student_transcripts_tracking", "question": "Find the kind of program which most number of students are enrolled in?", "rationale": ["The query identifies the relevant tables, 'Degree_Programs' and 'Student_Enrolment'.", "It selects the 'degree_summary_name' from the 'Degree_Programs' table.", "A JOIN operation is performed to link 'Degree_Programs' with 'Student_Enrolment' based on the 'degree_program_id'.", "The results are grouped by 'degree_summary_name' to aggregate enrolment counts.", "The results are ordered by the count of enrolments in descending order to highlight the most popular programs.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_summary_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "degree_programs"], "description": "This virtual table provides a list of degree program names from the 'Degree_Programs' table, which are associated with student enrolments. The results are grouped by the degree program name and ordered by the number of enrolments in descending order, allowing users to see the most popular degree programs. The placeholder in the LIMIT clause represents the maximum number of results to return.", "virtual_table": "SELECT T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_summary_name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.539", "db_id": "student_transcripts_tracking", "question": "Find the program which most number of students are enrolled in. List both the id and the summary.", "rationale": ["The query identifies the relevant tables, 'Degree_Programs' and 'Student_Enrolment'.", "It selects the degree program ID and name from the 'Degree_Programs' table.", "A JOIN operation is performed between 'Degree_Programs' and 'Student_Enrolment' on the degree program ID to link degree programs with their enrollments.", "The results are grouped by the degree program ID to aggregate the number of students enrolled in each program.", "The results are ordered by the count of enrollments in descending order to highlight the most popular programs.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.degree_program_id ,  T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_program_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "degree_programs"], "description": "This virtual table provides a list of degree programs along with their unique identifiers from the 'Degree_Programs' table. It joins with the 'Student_Enrolment' table to count the number of students enrolled in each degree program. The results are grouped by the degree program ID and ordered by the number of enrollments in descending order, allowing users to see the most popular degree programs. The placeholder in the LIMIT clause represents the maximum number of results to return.", "virtual_table": "SELECT T1.degree_program_id ,  T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_program_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.541", "db_id": "student_transcripts_tracking", "question": "Which student has enrolled for the most times in any program? List the id, first name, middle name, last name, the number of enrollments and student id.", "rationale": ["The query identifies the relevant tables, 'Students' and 'Student_Enrolment'.", "It selects the student ID, first name, middle name, and last name from the 'Students' table.", "It counts the number of enrolments for each student by joining 'Students' with 'Student_Enrolment' on the student ID.", "The results are grouped by the student ID to aggregate the enrolment counts.", "Finally, the results are ordered by the count of enrolments in descending order, and a placeholder is used to limit the number of results returned."], "gold_sql": "SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "students"], "description": "This virtual table provides a list of students along with their first, middle, and last names, and the count of their enrolments in courses. The results are grouped by each student's unique identifier and ordered by the number of enrolments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of students to return.", "virtual_table": "SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.547", "db_id": "student_transcripts_tracking", "question": "What's the name of the course with most number of enrollments?", "rationale": ["The query identifies the relevant tables, 'Courses' and 'Student_Enrolment_Courses'.", "It selects the 'course_name' from the 'Courses' table.", "A JOIN operation is performed between 'Courses' and 'Student_Enrolment_Courses' on the 'course_id' to link courses with their enrolments.", "The results are grouped by 'course_name' to aggregate the data based on course popularity.", "The results are ordered by the count of enrolments in descending order to highlight the most popular courses.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT  T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["courses", "student_enrolment_courses"], "description": "This virtual table provides a list of course names from the 'Courses' table that are associated with student enrolments. The results are grouped by course name and ordered by the number of enrolments in descending order, allowing users to see the most popular courses. The placeholder in the LIMIT clause represents the maximum number of course names to return.", "virtual_table": "SELECT  T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.550", "db_id": "student_transcripts_tracking", "question": "What are the last name of the students who live in North Carolina but have not registered in any degree programs?", "rationale": ["The query identifies the relevant tables, 'Students' and 'Addresses', to retrieve the last names of students.", "It joins the 'Students' table with the 'Addresses' table on the current address ID to access the state information.", "A condition is added to filter the results based on the specified state using a placeholder for string values.", "The EXCEPT clause is used to exclude students who are currently enrolled in any degree program by joining the 'Students' table with the 'Student_Enrolment' table."], "gold_sql": "SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  'NorthCarolina' EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id", "source_tables": ["addresses", "student_enrolment", "students"], "description": "This virtual table lists the last names of students who currently reside in a specific state, excluding those who are enrolled in any degree program. The placeholders in the query represent the state name and ensure that the results are filtered accordingly.", "virtual_table": "SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id"}
{"sample_id": "dev.554", "db_id": "student_transcripts_tracking", "question": "What is the mobile phone number of the student named Timmothy Ward ?", "rationale": ["The query identifies the relevant table, which is 'Students'.", "Select the column to display, 'cell_mobile_number'.", "Add conditions to filter the 'first_name' and 'last_name' columns for the specified student using placeholders for string values."], "gold_sql": "select cell_mobile_number from students where first_name  =  'timmothy' and last_name  =  'ward'", "source_tables": ["students"], "description": "This virtual table provides the mobile phone numbers of students from the 'Students' table based on their first and last names. The placeholders in the WHERE clause represent the student's first and last names.", "virtual_table": "select cell_mobile_number from students where first_name  =  [PLACEHOLDER-TYPE:STRING] and last_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.561", "db_id": "student_transcripts_tracking", "question": "Which address holds the most number of students currently? List the address id and all lines.", "rationale": ["The query identifies the relevant tables, which are 'Addresses' and 'Students'.", "It selects the columns 'address_id', 'line_1', and 'line_2' from the 'Addresses' table.", "A JOIN operation is performed to link 'Addresses' with 'Students' based on the current address ID.", "The results are grouped by 'address_id' to ensure uniqueness of addresses.", "The results are ordered by the count of students associated with each address in descending order.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.address_id ,  T1.line_1 ,  T1.line_2 FROM Addresses AS T1 JOIN Students AS T2 ON T1.address_id  =  T2.current_address_id GROUP BY T1.address_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "students"], "description": "This virtual table provides a list of unique addresses that are currently associated with students, including the address ID and the primary and secondary address lines. The results are grouped by address ID and ordered by the number of students associated with each address, allowing for a limit on the number of results returned.", "virtual_table": "SELECT T1.address_id ,  T1.line_1 ,  T1.line_2 FROM Addresses AS T1 JOIN Students AS T2 ON T1.address_id  =  T2.current_address_id GROUP BY T1.address_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.576", "db_id": "student_transcripts_tracking", "question": "What is the id of the semester that had both Masters and Bachelors students enrolled?", "rationale": ["The query is identifying the relevant tables, which are 'Degree_Programs' and 'Student_Enrolment'.", "It selects distinct semester IDs from the 'Student_Enrolment' table that are associated with a specific degree program.", "The query uses an INTERSECT operation to find common semesters for the same degree program, ensuring that the results reflect semesters where students are enrolled in that program."], "gold_sql": "SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Master' INTERSECT SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Bachelor'", "source_tables": ["student_enrolment", "degree_programs"], "description": "This virtual table identifies the distinct semesters in which students are enrolled in a specific degree program. The placeholders in the query represent the name of the degree program, allowing users to specify which program's semesters they are interested in.", "virtual_table": "SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.580", "db_id": "student_transcripts_tracking", "question": "What other details can you tell me about students in reverse alphabetical order?", "rationale": ["The query identifies the relevant table, which is 'Students'.", "Selects the column 'other_student_details' to display additional information about students.", "Orders the results in descending order based on the 'other_student_details' column."], "gold_sql": "SELECT other_student_details FROM Students ORDER BY other_student_details DESC", "source_tables": ["students"], "description": "This virtual table provides a list of additional details related to students from the 'Students' table, sorted in descending order. The placeholder in the SELECT clause represents the specific details of the students.", "virtual_table": "SELECT other_student_details FROM Students ORDER BY other_student_details DESC"}
{"sample_id": "dev.581", "db_id": "student_transcripts_tracking", "question": "Describe the section h.", "rationale": ["The query identifies the relevant table, which is 'Sections'.", "Select the column to display, 'section_description'.", "Add a condition to filter the 'section_name' column for the specified section using a placeholder for string values."], "gold_sql": "SELECT section_description FROM Sections WHERE section_name  =  'h'", "source_tables": ["sections"], "description": "This virtual table provides the description of a specific section from the 'Sections' table based on the section's name. The placeholder in the WHERE clause represents the name of the section being queried.", "virtual_table": "SELECT section_description FROM Sections WHERE section_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.705", "db_id": "world_1", "question": "How many countries have governments that are republics?", "rationale": ["The query identifies the relevant table, which is 'country'.", "It selects a count of all entries in the table.", "A condition is added to filter the results based on the 'GovernmentForm' column using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM country WHERE GovernmentForm  =  'Republic'", "source_tables": ["country"], "description": "This virtual table provides the count of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.", "virtual_table": "SELECT count(*) FROM country WHERE GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.730", "db_id": "world_1", "question": "What is the average GNP and total population in all nations whose government is US territory?", "rationale": ["The query identifies the relevant table, which is 'country'.", "It selects the average GNP and the sum of the population columns to provide aggregate data.", "A condition is added to filter the results based on the 'GovernmentForm' column using a placeholder for string values."], "gold_sql": "SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  'US Territory'", "source_tables": ["country"], "description": "This virtual table calculates the average Gross National Product (GNP) and the total population of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.", "virtual_table": "SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.734", "db_id": "world_1", "question": "How many type of governments are in Africa?", "rationale": ["The query identifies the relevant table, which is 'country'.", "It selects the count of distinct values in the 'GovernmentForm' column.", "A condition is added to filter the results based on the 'Continent' column using a placeholder for string values."], "gold_sql": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  'Africa'", "source_tables": ["country"], "description": "This virtual table provides the count of distinct government forms present in countries located within a specific continent. The placeholder in the WHERE clause represents the continent's name.", "virtual_table": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.735", "db_id": "world_1", "question": "How many different forms of governments are there in Africa?", "rationale": ["The query identifies the relevant table, which is 'country'.", "It selects the count of distinct values in the 'GovernmentForm' column.", "A condition is added to filter the results based on the 'Continent' column using a placeholder for string values."], "gold_sql": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  'Africa'", "source_tables": ["country"], "description": "This virtual table provides the count of distinct government forms present in countries located within a specific continent. The placeholder in the WHERE clause represents the continent's name.", "virtual_table": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.742", "db_id": "world_1", "question": "Which continent has the most diverse languages?", "rationale": ["The query identifies the relevant tables, which are 'country' and 'countrylanguage'.", "It selects the 'Continent' column from the 'country' table (aliased as T1).", "A JOIN operation is performed between 'country' and 'countrylanguage' on the 'CountryCode' to associate languages with their respective countries.", "The results are grouped by 'Continent' to aggregate the count of countries per continent.", "The ORDER BY clause sorts the continents based on the count of countries in descending order.", "The LIMIT clause uses a placeholder to allow the user to specify how many continents to return."], "gold_sql": "SELECT T1.Continent FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["country", "countrylanguage"], "description": "This virtual table provides a list of continents along with the count of countries that speak languages from those continents. The placeholder in the LIMIT clause allows the user to specify the maximum number of continents to retrieve.", "virtual_table": "SELECT T1.Continent FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.743", "db_id": "world_1", "question": "Which continent speaks the most languages?", "rationale": ["The query identifies the relevant tables, which are 'country' and 'countrylanguage'.", "It selects the 'Continent' column from the 'country' table.", "A JOIN operation is performed between 'country' and 'countrylanguage' on the 'CountryCode' to associate countries with their languages.", "The results are grouped by 'Continent' to aggregate the count of countries per continent.", "The ORDER BY clause sorts the continents based on the count of countries in descending order.", "The LIMIT clause uses a placeholder to allow the user to specify how many continents to return."], "gold_sql": "SELECT T1.Continent FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["country", "countrylanguage"], "description": "This virtual table provides a list of continents along with the count of countries that speak languages from those continents. The placeholder in the LIMIT clause allows the user to specify the maximum number of continents to retrieve based on the number of countries speaking languages from each continent.", "virtual_table": "SELECT T1.Continent FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.746", "db_id": "world_1", "question": "What are the names of nations speak both English and French?", "rationale": ["The query identifies the relevant tables, which are 'country' and 'countrylanguage'.", "It uses a JOIN operation to connect the 'country' table with the 'countrylanguage' table based on the country code.", "The query filters the results to include only those countries where the specified languages are spoken, using placeholders for the language names.", "The INTERSECT operator is used to ensure that only countries that have both languages are included in the final result."], "gold_sql": "SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English' INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'French'", "source_tables": ["country", "countrylanguage"], "description": "This virtual table describes the names of countries that have two specific languages spoken within them. The placeholders in the WHERE clause represent the names of the languages being queried.", "virtual_table": "SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.755", "db_id": "world_1", "question": "Which countries have either English or Dutch as an official language?", "rationale": ["The query identifies the relevant tables, which are 'country' and 'countrylanguage'.", "It performs a JOIN operation on these tables based on the country code to combine their data.", "The WHERE clause filters the results to include only those records where the specified language is spoken and indicates whether it is an official language, using placeholders for these values.", "The UNION operator is used to combine results from two similar queries, allowing for flexibility in the language and official status criteria."], "gold_sql": "SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English' AND IsOfficial  =  'T' UNION SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'Dutch' AND IsOfficial  =  'T'", "source_tables": ["country", "countrylanguage"], "description": "This virtual table provides a comprehensive view of countries and their languages by joining the 'country' and 'countrylanguage' tables. It filters the results to show only those countries where a specific language is spoken, and whether that language is official or not. The placeholders in the WHERE clause represent the language name and its official status.", "virtual_table": "SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] AND IsOfficial  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] AND IsOfficial  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.766", "db_id": "world_1", "question": "What is the total number of people living in the nations that do not use English?", "rationale": ["The query identifies the relevant table, which is 'country'.", "It uses the SUM function to calculate the total population of countries.", "A subquery is included to filter out countries that have the specified language as an official language.", "The placeholder in the subquery represents the language name that is being checked against the countries."], "gold_sql": "SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English')", "source_tables": ["country", "countrylanguage"], "description": "This virtual table calculates the total population of countries that do not have a specific language as an official language. The placeholder in the subquery represents the language name that is being checked against the countries.", "virtual_table": "SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "dev.767", "db_id": "world_1", "question": "How many people live in countries that do not speak English?", "rationale": ["The query identifies the relevant table, which is 'country'.", "It uses the SUM function to calculate the total population of countries.", "A subquery is included to filter out countries that have the specified language as an official language.", "The placeholder in the subquery represents the language name that is being checked against the countries."], "gold_sql": "SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English')", "source_tables": ["country", "countrylanguage"], "description": "This virtual table calculates the total population of countries that do not have a specific language as an official language. The placeholder in the subquery represents the language name that is being checked against the countries.", "virtual_table": "SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "dev.783", "db_id": "world_1", "question": "Return the codes of countries that do not speak English and do not have Republics for governments.", "rationale": ["The query is identifying the relevant table, which is 'country'.", "Select the 'Code' column from the 'country' table where the 'GovernmentForm' does not match the specified placeholder.", "Use the EXCEPT clause to exclude countries that have a specific language from the 'countrylanguage' table, using a placeholder for the language."], "gold_sql": "SELECT Code FROM country WHERE GovernmentForm != 'Republic' EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  'English'", "source_tables": ["country", "countrylanguage"], "description": "This virtual table identifies the unique codes of countries that do not have a specific form of government and are not associated with a particular language. The placeholders in the query represent the government form and the language of interest.", "virtual_table": "SELECT Code FROM country WHERE GovernmentForm != [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.784", "db_id": "world_1", "question": "Which cities are in European countries where English is not the official language?", "rationale": ["The query identifies the relevant tables, which are 'country' and 'city'.", "It selects distinct city names from the 'city' table.", "A JOIN operation is performed between 'country' and 'city' based on the country code to filter cities by continent.", "A subquery is used to exclude cities from countries where a specified language is official, using placeholders for the language and its official status."], "gold_sql": "SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  'Europe' AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  'T' AND T4.Language  =  'English')", "source_tables": ["country", "city", "countrylanguage"], "description": "This virtual table provides a list of distinct city names from the 'city' table that are located in a specific continent, as defined in the 'country' table. The query also filters out cities from countries where a specified language is an official language, ensuring that only cities from countries without that official language are included. The placeholders in the WHERE clause represent the continent and the language criteria.", "virtual_table": "SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  [PLACEHOLDER-TYPE:STRING] AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  [PLACEHOLDER-TYPE:STRING] AND T4.Language  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "dev.785", "db_id": "world_1", "question": "What are the names of cities in Europe for which English is not the official language?", "rationale": ["The query identifies the relevant tables, which are 'country' and 'city'.", "It selects distinct city names from the 'city' table.", "A join is performed between 'city' and 'country' on the CountryCode to filter cities based on the continent of the country.", "An additional condition is added to exclude cities from countries where a specified language is official, using a subquery that checks the 'countrylanguage' table for the official status of the language."], "gold_sql": "SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  'Europe' AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  'T' AND T4.Language  =  'English')", "source_tables": ["country", "city", "countrylanguage"], "description": "This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.", "virtual_table": "SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  [PLACEHOLDER-TYPE:STRING] AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  [PLACEHOLDER-TYPE:STRING] AND T4.Language  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "dev.788", "db_id": "world_1", "question": "What are the name, independence year, and surface area of the country with the smallest population?", "rationale": ["The query identifies the relevant table, which is 'country'.", "Select the columns to display: 'Name', 'SurfaceArea', and 'IndepYear'.", "Order the results by the 'Population' column to sort countries based on their population size.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT 1", "source_tables": ["country"], "description": "This virtual table provides a list of countries, displaying their names, surface areas, and the year they gained independence. The results are ordered by the population of the countries, and the number of entries returned is limited by a specified placeholder for numeric values.", "virtual_table": "SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.789", "db_id": "world_1", "question": "Give the name, year of independence, and surface area of the country that has the lowest population.", "rationale": ["The query identifies the relevant table, which is 'country'.", "Select the columns to display: 'Name', 'SurfaceArea', and 'IndepYear'.", "Order the results by the 'Population' column to sort countries based on their population size.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT 1", "source_tables": ["country"], "description": "This virtual table provides a list of countries, displaying their names, surface areas, and the year they gained independence. The results are ordered by the population of the countries, and the number of entries returned is limited by a specified placeholder for numeric values.", "virtual_table": "SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.793", "db_id": "world_1", "question": "What are the names of countries that speak more than 2 languages, as well as how many languages they speak?", "rationale": ["The query identifies the relevant tables, which are 'country' and 'countrylanguage'.", "It selects the count of languages (T2.Language) and the name of the country (T1.Name).", "A JOIN operation is performed on the country code to link the two tables.", "The results are grouped by the country's name to aggregate the language counts.", "A HAVING clause is used to filter the results to include only those countries with a language count greater than a specified number, using a placeholder for numeric values."], "gold_sql": "SELECT COUNT(T2.Language) ,  T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Name HAVING COUNT(*)  >  2", "source_tables": ["country", "countrylanguage"], "description": "This virtual table provides a count of languages spoken in each country from the 'country' table, along with the country's name. The query filters the results to only include countries where the number of languages spoken exceeds a specified threshold, represented by a placeholder for numeric values.", "virtual_table": "SELECT COUNT(T2.Language) ,  T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Name HAVING COUNT(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.796", "db_id": "world_1", "question": "Find the government form name and total population for each government form whose average life expectancy is longer than 72.", "rationale": ["The query identifies the relevant table, which is 'country'.", "It selects the sum of the 'Population' column and the 'GovernmentForm' column.", "The results are grouped by 'GovernmentForm' to aggregate the population data accordingly.", "A condition is added to filter the results using the HAVING clause, which checks if the average 'LifeExpectancy' is greater than a specified number, using a placeholder for numeric values."], "gold_sql": "SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  72", "source_tables": ["country"], "description": "This virtual table summarizes the total population of countries grouped by their government form, filtering for those government forms where the average life expectancy exceeds a specified threshold. The placeholder in the HAVING clause represents the minimum average life expectancy value.", "virtual_table": "SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.797", "db_id": "world_1", "question": "What are the different government forms and what is the total population of each for government forms that have an average life expectancy greater than 72?", "rationale": ["The query identifies the relevant table, which is 'country'.", "It selects the sum of the 'Population' column and the 'GovernmentForm' column.", "The results are grouped by 'GovernmentForm' to aggregate the population data accordingly.", "A condition is added to filter the results using the HAVING clause, which checks if the average 'LifeExpectancy' is greater than a specified number, using a placeholder for numeric values."], "gold_sql": "SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  72", "source_tables": ["country"], "description": "This virtual table summarizes the total population of countries grouped by their government form, filtering for those government forms where the average life expectancy exceeds a specified threshold. The placeholder in the HAVING clause represents the minimum average life expectancy value.", "virtual_table": "SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.801", "db_id": "world_1", "question": "Return the names and surface areas of the 5 largest countries.", "rationale": ["The query identifies the relevant table, which is 'country'.", "Select the columns to display, 'Name' and 'SurfaceArea'.", "Order the results by 'SurfaceArea' in descending order to show the largest countries first.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT Name ,  SurfaceArea FROM country ORDER BY SurfaceArea DESC LIMIT 5", "source_tables": ["country"], "description": "This virtual table provides a list of country names along with their surface areas, sorted in descending order by surface area. The placeholder in the LIMIT clause allows the user to specify the maximum number of countries to retrieve.", "virtual_table": "SELECT Name ,  SurfaceArea FROM country ORDER BY SurfaceArea DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.810", "db_id": "world_1", "question": "What is the total population and average area of countries in the continent of North America whose area is bigger than 3000 ?", "rationale": ["The query identifies the relevant table, which is 'country'.", "It selects the sum of the 'population' and the average of the 'surfacearea' columns to provide aggregate data.", "A condition is added to filter the results based on the specified continent and a minimum surface area using placeholders for string and numeric values."], "gold_sql": "select sum(population) ,  avg(surfacearea) from country where continent  =  'north america' and surfacearea  >  3000", "source_tables": ["country"], "description": "This virtual table provides the total population and average surface area of countries located in a specific continent that have a surface area greater than a specified value. The placeholders in the WHERE clause represent the continent's name and the minimum surface area.", "virtual_table": "select sum(population) ,  avg(surfacearea) from country where continent  =  [PLACEHOLDER-TYPE:STRING] and surfacearea  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.811", "db_id": "world_1", "question": "Give the total population and average surface area corresponding to countries in North America that have a surface area greater than 3000 .", "rationale": ["The query identifies the relevant table, which is 'country'.", "It selects the sum of the 'population' and the average of the 'surfacearea' columns to provide aggregate data.", "A condition is added to filter the results based on the specified continent and a minimum surface area using placeholders for string and numeric values."], "gold_sql": "select sum(population) ,  avg(surfacearea) from country where continent  =  'north america' and surfacearea  >  3000", "source_tables": ["country"], "description": "This virtual table provides the total population and average surface area of countries located in a specific continent that have a surface area greater than a specified value. The placeholders in the WHERE clause represent the continent's name and the minimum surface area.", "virtual_table": "select sum(population) ,  avg(surfacearea) from country where continent  =  [PLACEHOLDER-TYPE:STRING] and surfacearea  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.812", "db_id": "world_1", "question": "What are the cities whose population is between 160000 and 900000?", "rationale": ["The query identifies the relevant table, which is 'city'.", "Select the column to display, 'name'.", "Add a condition to filter the 'Population' column for values between the specified range using placeholders for numeric values."], "gold_sql": "SELECT name FROM city WHERE Population BETWEEN 160000 AND 900000", "source_tables": ["city"], "description": "This virtual table describes the names of cities from the 'city' table that have a population within a specified range. The placeholders in the WHERE clause represent the lower and upper limits of the population range.", "virtual_table": "SELECT name FROM city WHERE Population BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.921", "db_id": "dog_kennels", "question": "Find the average age of the dogs who went through treatments.", "rationale": ["The query identifies the relevant table, which is 'Dogs'.", "It selects the average age of dogs using the AVG function.", "The WHERE clause filters the dogs to include only those that have treatment records, which is determined by a subquery that selects dog_ids from the 'Treatments' table."], "gold_sql": "SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )", "source_tables": ["dogs", "treatments"], "description": "This virtual table calculates the average age of dogs that have received treatments. The placeholder in the WHERE clause allows for filtering based on specific dog identifiers if needed.", "virtual_table": "SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )"}
