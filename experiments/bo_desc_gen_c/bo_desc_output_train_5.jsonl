{"sample_id": "train.3600", "db_id": "music_1", "question": "What is the maximum and minimum resolution of all songs that are approximately 3 minutes long?", "rationale": ["The query identifies the relevant tables, which are 'files' and 'song'.", "It uses a JOIN operation to connect these tables based on the foreign key relationship between 'files.f_id' and 'song.f_id'.", "The SELECT statement retrieves the maximum and minimum values of the 'resolution' column from the 'song' table.", "A condition is added to filter the results based on the 'duration' column from the 'files' table using a placeholder for string values."], "gold_sql": "SELECT max(T2.resolution) ,  min(T2.resolution) FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.duration LIKE '3:%'", "source_tables": ["files", "song"], "description": "This virtual table provides the maximum and minimum audio resolutions of songs from the 'song' table, filtered by the duration of the associated files in the 'files' table. The placeholder in the WHERE clause represents the specific duration pattern to match.", "virtual_table": "SELECT max(T2.resolution) ,  min(T2.resolution) FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.duration LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3565", "db_id": "music_1", "question": "Return the gender and name of artist who produced the song with the lowest resolution.", "rationale": ["The query identifies the relevant tables, which are 'artist' and 'song'.", "It selects the 'gender' and 'artist_name' columns from the 'artist' table.", "A JOIN operation is performed on the 'artist' and 'song' tables based on the 'artist_name' column to combine relevant data.", "The results are ordered by the 'resolution' column from the 'song' table.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.gender ,  T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.resolution LIMIT 1", "source_tables": ["artist", "song"], "description": "This virtual table provides the gender and name of artists from the 'artist' table who have songs listed in the 'song' table. The results are ordered by the audio resolution of the songs, and the number of results returned is limited by a placeholder for numeric values.", "virtual_table": "SELECT T1.gender ,  T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.resolution LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3541", "db_id": "music_1", "question": "What is the name of the artist who produced the shortest song?", "rationale": ["The query identifies the relevant tables, 'song' and 'files', and uses a JOIN to connect them based on the file identifier (f_id).", "It selects the 'artist_name' from the 'song' table (aliased as T1).", "The results are ordered by the 'duration' from the 'files' table (aliased as T2).", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.artist_name FROM song AS T1 JOIN files AS T2 ON T1.f_id  =  T2.f_id ORDER BY T2.duration LIMIT 1", "source_tables": ["files", "song"], "description": "This virtual table lists the names of artists from the 'song' table, joined with the 'files' table to access the duration of their songs. The results are ordered by the duration of the audio files, and a placeholder is used to limit the number of results returned.", "virtual_table": "SELECT T1.artist_name FROM song AS T1 JOIN files AS T2 ON T1.f_id  =  T2.f_id ORDER BY T2.duration LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3551", "db_id": "music_1", "question": "What is the most popular file format?", "rationale": ["The query identifies the relevant table, which is 'files'.", "Select the column to display, 'formats'.", "Group the results by the 'formats' column to aggregate the data.", "Order the results by the count of files in each format in descending order to prioritize the most common formats.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT formats FROM files GROUP BY formats ORDER BY COUNT (*) DESC LIMIT 1", "source_tables": ["files"], "description": "This virtual table provides a list of audio file formats from the 'files' table, grouped by format type. The results are ordered by the count of files in each format, allowing users to see the most common formats used. The placeholder in the LIMIT clause represents the maximum number of formats to return.", "virtual_table": "SELECT formats FROM files GROUP BY formats ORDER BY COUNT (*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3529", "db_id": "music_1", "question": "What is the name of the song that was released in the most recent year?", "rationale": ["The query identifies the relevant table, which is 'song'.", "Selects the columns to display, 'song_name' and 'releasedate'.", "Orders the results by 'releasedate' in descending order to show the latest songs first.", "Limits the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT song_name ,  releasedate FROM song ORDER BY releasedate DESC LIMIT 1", "source_tables": ["song"], "description": "This virtual table provides a list of song titles along with their release dates from the 'song' table, sorted by the most recent release date. The placeholder in the LIMIT clause indicates the maximum number of records to return.", "virtual_table": "SELECT song_name ,  releasedate FROM song ORDER BY releasedate DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3530", "db_id": "music_1", "question": "What is the name of the song that was released most recently?", "rationale": ["The query identifies the relevant table, which is 'song'.", "Selects the columns to display, 'song_name' and 'releasedate'.", "Orders the results by 'releasedate' in descending order to show the latest songs first.", "Limits the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT song_name ,  releasedate FROM song ORDER BY releasedate DESC LIMIT 1", "source_tables": ["song"], "description": "This virtual table provides a list of song titles along with their release dates from the 'song' table, sorted by the most recent release date. The placeholder in the LIMIT clause indicates the maximum number of records to return.", "virtual_table": "SELECT song_name ,  releasedate FROM song ORDER BY releasedate DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3546", "db_id": "music_1", "question": "What is the count of the songs that last approximately 4 minutes?", "rationale": ["The query identifies the relevant table, which is 'files'.", "It selects a count of all records that meet a certain condition.", "The condition filters the records based on the 'duration' column using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM files WHERE duration LIKE '4:%'", "source_tables": ["files"], "description": "This virtual table provides a count of audio files from the 'files' table that match a specific duration pattern. The placeholder in the WHERE clause represents the duration criteria to filter the files.", "virtual_table": "SELECT count(*) FROM files WHERE duration LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3531", "db_id": "music_1", "question": "What is the id of the longest song?", "rationale": ["The query identifies the relevant table, which is 'files'.", "It selects the 'f_id' column to display the unique identifiers for the files.", "The results are ordered by the 'duration' column in descending order to show the longest files first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT f_id FROM files ORDER BY duration DESC LIMIT 1", "source_tables": ["files"], "description": "This virtual table provides a list of file identifiers from the 'files' table, sorted by the duration of the audio files in descending order. The placeholder in the LIMIT clause indicates the maximum number of file identifiers to return.", "virtual_table": "SELECT f_id FROM files ORDER BY duration DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3543", "db_id": "music_1", "question": "What are the names and countries of origin for the artists who produced the top three highly rated songs.", "rationale": ["The query identifies the relevant tables, which are 'artist' and 'song'.", "It selects the columns 'artist_name' and 'country' from the 'artist' table.", "A JOIN operation is performed on the 'artist' and 'song' tables based on the 'artist_name' column to link artists with their songs.", "The results are ordered by the 'rating' column from the 'song' table in descending order to show the highest-rated songs first.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.artist_name ,  T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.rating DESC LIMIT 3", "source_tables": ["artist", "song"], "description": "This virtual table provides a list of artist names and their corresponding countries from the 'artist' table, joined with the 'song' table to include only those artists who have songs. The results are ordered by the rating of the songs in descending order, and the number of results is limited by a placeholder for numeric values.", "virtual_table": "SELECT T1.artist_name ,  T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.rating DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6191", "db_id": "music_4", "question": "Show the famous titles of the artists with both volumes that lasted more than 2 weeks on top and volumes that lasted less than 2 weeks on top.", "rationale": ["The query identifies the relevant tables, which are 'artist' and 'volume'.", "It selects the 'Famous_Title' from the 'artist' table.", "The JOIN operation links the 'artist' and 'volume' tables based on the 'Artist_ID'.", "The first condition filters for songs that have spent more than a specified number of weeks at the top using a placeholder for numeric values.", "The INTERSECT operation is used to find titles that also meet the second condition of spending less than a different specified number of weeks at the top, again using a placeholder for numeric values."], "gold_sql": "SELECT T1.Famous_Title FROM artist AS T1 JOIN volume AS T2 ON T1.Artist_ID  =  T2.Artist_ID WHERE T2.Weeks_on_Top  >  2 INTERSECT SELECT T1.Famous_Title FROM artist AS T1 JOIN volume AS T2 ON T1.Artist_ID  =  T2.Artist_ID WHERE T2.Weeks_on_Top  <  2", "source_tables": ["artist", "volume"], "description": "This virtual table describes the famous titles of songs by artists who have had varying success on the charts. It retrieves titles of songs that have spent more than a certain number of weeks at the top of the charts and also those that have spent less than a different specified number of weeks. The placeholders in the WHERE clause represent the numeric values for the weeks spent at the top.", "virtual_table": "SELECT T1.Famous_Title FROM artist AS T1 JOIN volume AS T2 ON T1.Artist_ID  =  T2.Artist_ID WHERE T2.Weeks_on_Top  >  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T1.Famous_Title FROM artist AS T1 JOIN volume AS T2 ON T1.Artist_ID  =  T2.Artist_ID WHERE T2.Weeks_on_Top  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6156", "db_id": "music_4", "question": "Return the categories of music festivals that have the result \"Awarded\".", "rationale": ["The query identifies the relevant table, which is 'music_festival'.", "Select the column to display, 'Category'.", "Add a condition to filter the 'RESULT' column for the specified result using a placeholder for string values."], "gold_sql": "SELECT Category FROM music_festival WHERE RESULT  =  'Awarded'", "source_tables": ["music_festival"], "description": "This virtual table provides the categories of awards or recognitions from the 'music_festival' table based on a specific result. The placeholder in the WHERE clause represents the outcome of the festival participation.", "virtual_table": "SELECT Category FROM music_festival WHERE RESULT  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6165", "db_id": "music_4", "question": "Please show the date of ceremony of the volumes that last more than 2 weeks on top.", "rationale": ["The query identifies the relevant tables, 'music_festival' and 'volume'.", "It selects the 'Date_of_ceremony' from the 'music_festival' table.", "A JOIN operation is performed between 'music_festival' and 'volume' on the 'Volume' and 'Volume_ID' columns to link the two tables.", "A condition is added to filter the results based on the 'Weeks_on_Top' column from the 'volume' table using a placeholder for numeric values."], "gold_sql": "SELECT T1.Date_of_ceremony FROM music_festival AS T1 JOIN volume AS T2 ON T1.Volume  =  T2.Volume_ID WHERE T2.Weeks_on_Top  >  2", "source_tables": ["music_festival", "volume"], "description": "This virtual table provides the dates of ceremonies from the 'music_festival' table for volumes that have songs which stayed at the top for a specified number of weeks. The placeholder in the WHERE clause represents the minimum number of weeks a song must have been at the top.", "virtual_table": "SELECT T1.Date_of_ceremony FROM music_festival AS T1 JOIN volume AS T2 ON T1.Volume  =  T2.Volume_ID WHERE T2.Weeks_on_Top  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6162", "db_id": "music_4", "question": "What are the the songs in volumes, listed in ascending order?", "rationale": ["The query identifies the relevant table, which is 'volume'.", "Select the column to display, 'Song'.", "Add an ORDER BY clause to sort the results based on the 'Song' column."], "gold_sql": "SELECT Song FROM volume ORDER BY Song", "source_tables": ["volume"], "description": "This virtual table lists the identifiers of songs from the 'volume' table, ordered by the song identifier. The placeholder in the ORDER BY clause allows for dynamic sorting based on the song identifier.", "virtual_table": "SELECT Song FROM volume ORDER BY Song"}
{"sample_id": "train.6184", "db_id": "music_4", "question": "Return the result that is most frequent at music festivals.", "rationale": ["The query identifies the relevant table, which is 'music_festival'.", "It selects the 'RESULT' column to display the outcomes of the festivals.", "The results are grouped by the 'RESULT' column to aggregate similar outcomes.", "The results are ordered by the count of occurrences in descending order to show the most common results first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT RESULT FROM music_festival GROUP BY RESULT ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["music_festival"], "description": "This virtual table summarizes the results of music festivals, showing the outcomes grouped by their result type. The placeholder in the LIMIT clause allows the user to specify the maximum number of results to return, enabling them to control how many of the most frequent results they wish to see.", "virtual_table": "SELECT RESULT FROM music_festival GROUP BY RESULT ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6188", "db_id": "music_4", "question": "Return the song in the volume that has spent the most weeks on top?", "rationale": ["The query identifies the relevant table, which is 'volume'.", "Select the 'Song' column to display the song identifiers.", "Order the results by 'Weeks_on_Top' in descending order to show the most successful songs first.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT Song FROM volume ORDER BY Weeks_on_Top DESC LIMIT 1", "source_tables": ["volume"], "description": "This virtual table lists the songs from the 'volume' table, ordered by the number of weeks they stayed at the top, with a limit on the number of results returned. The placeholder in the LIMIT clause represents the maximum number of songs to display.", "virtual_table": "SELECT Song FROM volume ORDER BY Weeks_on_Top DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4443", "db_id": "network_2", "question": "What are the different names and ages of every friend of either Dan or alice?", "rationale": ["The query identifies the relevant tables, 'Person' and 'PersonFriend'.", "It selects distinct names and ages from the 'Person' table.", "A JOIN operation is performed on the 'name' column to link the two tables based on friendships.", "The WHERE clause filters the results to include only those individuals who have specific friends, using placeholders for the friends' names."], "gold_sql": "SELECT DISTINCT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Dan' OR T2.friend  =  'Alice'", "source_tables": ["personfriend", "person"], "description": "This virtual table provides a distinct list of names and ages of individuals from the 'Person' table who have specific friends listed in the 'PersonFriend' table. The placeholders in the WHERE clause represent the names of the friends being queried.", "virtual_table": "SELECT DISTINCT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] OR T2.friend  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4474", "db_id": "network_2", "question": "Find the name, age, and job title of persons who are friends with Alice for the longest years.", "rationale": ["The query identifies the relevant tables, 'Person' and 'PersonFriend'.", "It selects the columns 'name', 'age', and 'job' from the 'Person' table.", "A JOIN operation is performed on the 'name' column to link 'Person' and 'PersonFriend'.", "Conditions are added to filter results based on the specified friend's name and the most recent year of friendship using subquery with a placeholder for string values."], "gold_sql": "SELECT T1.name ,  T1.age ,  T1.job FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend =  'Alice' AND T2.year  =  (SELECT max(YEAR) FROM PersonFriend WHERE friend =  'Alice')", "source_tables": ["personfriend", "person"], "description": "This virtual table provides the names, ages, and job titles of individuals from the 'Person' table who have a specific friend, along with the most recent year the friendship was established. The placeholders in the WHERE clause represent the friend's name.", "virtual_table": "SELECT T1.name ,  T1.age ,  T1.job FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend =  [PLACEHOLDER-TYPE:STRING] AND T2.year  =  (SELECT max(YEAR) FROM PersonFriend WHERE friend =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.4440", "db_id": "network_2", "question": "Find the name and age of the person who is a friend of both Dan and Alice.", "rationale": ["The query identifies the relevant tables, which are 'Person' and 'PersonFriend'.", "It selects the columns to display, 'name' and 'age', from the 'Person' table.", "The JOIN operation is used to connect 'Person' and 'PersonFriend' based on the person's name.", "The WHERE clause filters the results to include only those persons who are friends with a specific individual, using a placeholder for the friend's name.", "The INTERSECT operation ensures that only persons who have mutual friendships with the specified friend are included in the final result."], "gold_sql": "SELECT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Dan' INTERSECT SELECT T1.name ,   T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Alice'", "source_tables": ["personfriend", "person"], "description": "This virtual table describes the names and ages of persons from the 'Person' table who have mutual friendships with a specific friend. The placeholders in the WHERE clause represent the names of the friends being queried.", "virtual_table": "SELECT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.name ,   T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4448", "db_id": "network_2", "question": "Find the name of the person who has no student friends.", "rationale": ["The query starts by selecting names from the 'Person' table.", "It uses the EXCEPT clause to exclude names of friends from the 'PersonFriend' table.", "A JOIN operation is performed between 'Person' and 'PersonFriend' to find friends of individuals who have a specific job.", "The WHERE clause filters the results based on the job title using a placeholder for string values."], "gold_sql": "SELECT name FROM person EXCEPT SELECT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.job  =  'student'", "source_tables": ["personfriend", "person"], "description": "This virtual table identifies the names of individuals from the 'Person' table who do not have any friends that work in a specific occupation. The placeholder in the query allows for the specification of the job title to filter out those individuals accordingly.", "virtual_table": "SELECT name FROM person EXCEPT SELECT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.job  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4442", "db_id": "network_2", "question": "Find the name and age of the person who is a friend of Dan or Alice.", "rationale": ["The query identifies the relevant tables, 'Person' and 'PersonFriend'.", "It selects distinct names and ages from the 'Person' table.", "A JOIN operation is performed on the 'name' column to link the two tables based on friendships.", "The WHERE clause filters the results to include only those individuals who have specific friends, using placeholders for the friends' names."], "gold_sql": "SELECT DISTINCT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Dan' OR T2.friend  =  'Alice'", "source_tables": ["personfriend", "person"], "description": "This virtual table provides a distinct list of names and ages of individuals from the 'Person' table who have specific friends listed in the 'PersonFriend' table. The placeholders in the WHERE clause represent the names of the friends being queried.", "virtual_table": "SELECT DISTINCT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] OR T2.friend  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4446", "db_id": "network_2", "question": "Find the name of the person who has friends with age above 40 but not under age 30?", "rationale": ["The query starts by selecting names from the 'Person' table, aliased as T1.", "It joins the 'PersonFriend' table, aliased as T2, on the condition that the names match.", "The first condition filters friends who are older than a specified age using a subquery on the 'Person' table.", "The EXCEPT clause is used to exclude names from the result where friends are younger than the specified age, again using a subquery on the 'Person' table."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  40) EXCEPT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  30)", "source_tables": ["personfriend", "person"], "description": "This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.", "virtual_table": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  [PLACEHOLDER-TYPE:NUMBER]) EXCEPT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.4447", "db_id": "network_2", "question": "What are the names of the people who are older 40 but no friends under age 30?", "rationale": ["The query starts by selecting names from the 'Person' table, aliased as T1.", "It joins the 'PersonFriend' table, aliased as T2, on the condition that the names match.", "The first part of the WHERE clause filters friends who are older than a specified age using a subquery on the 'Person' table.", "The EXCEPT clause is used to exclude names from the result where friends are younger than the specified age, again using a subquery on the 'Person' table."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  40) EXCEPT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  30)", "source_tables": ["personfriend", "person"], "description": "This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.", "virtual_table": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  [PLACEHOLDER-TYPE:NUMBER]) EXCEPT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.4481", "db_id": "network_2", "question": "What is the total number of people who have no friends living in Austin?", "rationale": ["The query identifies the relevant table, which is 'PersonFriend'.", "It counts the distinct names of persons who have friends.", "A subquery is used to filter out friends based on their city of residence from the 'Person' table, using a placeholder for the city name."], "gold_sql": "SELECT count(DISTINCT name) FROM PersonFriend WHERE friend NOT IN (SELECT name FROM person WHERE city  =  'Austin')", "source_tables": ["personfriend", "person"], "description": "This virtual table counts the number of distinct persons from the 'PersonFriend' table who have friends that do not reside in a specified city. The placeholder in the WHERE clause represents the name of the city to filter out friends.", "virtual_table": "SELECT count(DISTINCT name) FROM PersonFriend WHERE friend NOT IN (SELECT name FROM person WHERE city  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.4469", "db_id": "network_2", "question": "Which friend of Zach has the longest-lasting friendship?", "rationale": ["The query identifies the relevant table, which is 'PersonFriend'.", "Select the column to display, 'friend'.", "Add a condition to filter the 'name' column for the specified person's name using a placeholder for string values.", "Include a subquery to find the maximum year of friendship for the specified person, ensuring that only the most recent friendships are displayed."], "gold_sql": "SELECT friend FROM PersonFriend WHERE name =  'Zach' AND YEAR  =  (SELECT max(YEAR) FROM PersonFriend WHERE name =  'Zach')", "source_tables": ["personfriend"], "description": "This virtual table lists the friends of a specific person from the 'PersonFriend' table, filtered by the most recent year of friendship established. The placeholders in the WHERE clause represent the person's name.", "virtual_table": "SELECT friend FROM PersonFriend WHERE name =  [PLACEHOLDER-TYPE:STRING] AND YEAR  =  (SELECT max(YEAR) FROM PersonFriend WHERE name =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.4408", "db_id": "network_2", "question": "Who is the oldest person?", "rationale": ["The query identifies the relevant table, which is 'Person'.", "It selects the 'name' column to display.", "A subquery is used to find the maximum age from the 'Person' table, and the main query filters the results to find the name of the person with that maximum age."], "gold_sql": "SELECT name FROM Person WHERE age  =  (SELECT max(age) FROM person)", "source_tables": ["person"], "description": "This virtual table retrieves the name of the oldest person from the 'Person' table. The placeholder in the WHERE clause is used to filter the age based on the maximum age found in the table.", "virtual_table": "SELECT name FROM Person WHERE age  =  (SELECT max(age) FROM person)"}
{"sample_id": "train.4411", "db_id": "network_2", "question": "What is the name of the oldest student?", "rationale": ["The query identifies the relevant table, which is 'Person'.", "Select the column to display, 'name'.", "Add a condition to filter the 'job' column for the specified job title using a placeholder for string values.", "Include a subquery to find the maximum age of individuals with the same job title, ensuring that only the oldest individual is selected."], "gold_sql": "SELECT name FROM Person WHERE job  =  'student' AND age  =  (SELECT max(age) FROM person WHERE job  =  'student' )", "source_tables": ["person"], "description": "This virtual table describes the names of individuals from the 'Person' table who have a specific job title and are the oldest among those with the same job. The placeholders in the WHERE clause represent the job title being queried.", "virtual_table": "SELECT name FROM Person WHERE job  =  [PLACEHOLDER-TYPE:STRING] AND age  =  (SELECT max(age) FROM person WHERE job  =  [PLACEHOLDER-TYPE:STRING] )"}
{"sample_id": "train.4438", "db_id": "network_2", "question": "Find the name and age of all males in order of their age.", "rationale": ["The query identifies the relevant table, which is 'Person'.", "Select the column to display, 'name'.", "Add a condition to filter the 'gender' column for the specified gender using a placeholder for string values.", "Order the results by the 'age' column to sort the names accordingly."], "gold_sql": "SELECT name FROM Person WHERE gender  =  'male' ORDER BY age", "source_tables": ["person"], "description": "This virtual table lists the names of individuals from the 'Person' table who belong to a specific gender. The results are ordered by their age, allowing for easy identification of individuals within that gender category.", "virtual_table": "SELECT name FROM Person WHERE gender  =  [PLACEHOLDER-TYPE:STRING] ORDER BY age"}
{"sample_id": "train.4457", "db_id": "network_2", "question": "What are the names of all females who are friends with Zach?", "rationale": ["The query identifies the relevant tables, which are 'Person' and 'PersonFriend'.", "It selects the 'name' column from the 'Person' table, aliased as T1.", "A JOIN operation is performed between 'Person' (T1) and 'PersonFriend' (T2) on the condition that their names match.", "Conditions are added to filter the results based on the specified friend's name and the person's gender using placeholders for string values."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Zach' AND T1.gender  =  'female'", "source_tables": ["personfriend", "person"], "description": "This virtual table describes the names of persons from the 'Person' table who have a specific friend and belong to a certain gender. The placeholders in the WHERE clause represent the friend's name and the gender of the person.", "virtual_table": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] AND T1.gender  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4463", "db_id": "network_2", "question": "What are the names of all friends who are from New York?", "rationale": ["The query identifies the relevant tables, which are 'Person' and 'PersonFriend'.", "It uses a JOIN operation to connect the two tables based on the condition that the friend's name in 'PersonFriend' matches the name in 'Person'.", "A condition is added to filter the results based on the specified city using a placeholder for string values."], "gold_sql": "SELECT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.city  =  'new york city'", "source_tables": ["personfriend", "person"], "description": "This virtual table describes the names of friends of persons who reside in a specific city. The query joins the 'Person' table with the 'PersonFriend' table to find friends based on the city of residence, with a placeholder for the city name.", "virtual_table": "SELECT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.city  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2057", "db_id": "party_people", "question": "Show all party names and the number of members in each party.", "rationale": ["The query identifies the relevant tables, which are 'Member' and 'Party'.", "It selects the 'party_name' from the 'Party' table and counts the number of members from the 'Member' table.", "A JOIN operation is performed on the 'party_id' to link members to their respective parties.", "The results are grouped by 'party_id' to provide a count of members for each political party."], "gold_sql": "SELECT T2.party_name ,  count(*) FROM Member AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id", "source_tables": ["party", "member"], "description": "This virtual table summarizes the number of members associated with each political party from the 'Member' and 'Party' tables. The placeholder in the SELECT statement represents the party's name, and the count function aggregates the total number of members for each party.", "virtual_table": "SELECT T2.party_name ,  count(*) FROM Member AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id"}
{"sample_id": "train.2072", "db_id": "party_people", "question": "How many events are there for each party?", "rationale": ["The query identifies the relevant tables, which are 'party_events' and 'party'.", "It uses a JOIN operation to connect 'party_events' with 'party' based on the 'party_id'.", "The SELECT clause specifies the party name and counts the number of events for each party.", "The GROUP BY clause groups the results by 'party_id' to ensure the count is calculated for each distinct party."], "gold_sql": "SELECT T2.party_name ,  count(*) FROM party_events AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id", "source_tables": ["party", "party_events"], "description": "This virtual table summarizes the number of events organized by each political party from the 'party_events' table. It joins the 'party' table to retrieve the party names associated with the events. The placeholder in the SELECT clause represents the party name, while the count function aggregates the total number of events for each party.", "virtual_table": "SELECT T2.party_name ,  count(*) FROM party_events AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id"}
{"sample_id": "train.2082", "db_id": "party_people", "question": "Count the number of Annual Meeting events that took place in the region of the United Kingdom.", "rationale": ["The query identifies the relevant tables: 'region', 'party', and 'party_events'.", "It uses JOIN operations to connect these tables based on their foreign key relationships: 'region_id' from 'party' to 'region' and 'party_id' from 'party_events' to 'party'.", "The SELECT statement counts the total number of events that match the specified criteria.", "The WHERE clause filters the results based on the specified 'region_name' and 'Event_Name', using placeholders for these string values."], "gold_sql": "SELECT count(*) FROM region AS t1 JOIN party AS t2 ON t1.region_id  =  t2.region_id JOIN party_events AS t3 ON t2.party_id  =  t3.party_id WHERE t1.region_name  =  'United Kingdom' AND t3.Event_Name  =  'Annaual Meeting'", "source_tables": ["party", "party_events", "region"], "description": "This virtual table provides a count of party events associated with a specific region and event name. It joins the 'region', 'party', and 'party_events' tables to filter the results based on the specified region name and event name. The placeholders in the WHERE clause represent the region's name and the event's name.", "virtual_table": "SELECT count(*) FROM region AS t1 JOIN party AS t2 ON t1.region_id  =  t2.region_id JOIN party_events AS t3 ON t2.party_id  =  t3.party_id WHERE t1.region_name  =  [PLACEHOLDER-TYPE:STRING] AND t3.Event_Name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2050", "db_id": "party_people", "question": "Which ministers are not a part of the Progress Party?", "rationale": ["The query identifies the relevant table, which is 'party'.", "Select the column to display, 'minister'.", "Add a condition to filter the 'party_name' column to exclude the specified party using a placeholder for string values."], "gold_sql": "SELECT minister FROM party WHERE party_name != 'Progress Party'", "source_tables": ["party"], "description": "This virtual table describes the ministers associated with political parties from the 'party' table, excluding a specific party name. The placeholder in the WHERE clause represents the name of the party to be excluded.", "virtual_table": "SELECT minister FROM party WHERE party_name != [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.315", "db_id": "product_catalog", "question": "What are the entry names of catalog with the attribute possessed by most entries.", "rationale": ["The query identifies the relevant tables, which are 'Catalog_Contents' and 'Catalog_Contents_Additional_Attributes'.", "It selects the 'catalog_entry_name' from 'Catalog_Contents'.", "A JOIN operation is performed on 'catalog_entry_id' to link the two tables.", "A subquery is used to find the most common 'attribute_value' from 'Catalog_Contents_Additional_Attributes', with a placeholder for the limit on the number of results."], "gold_sql": "SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.attribute_value  =  (SELECT attribute_value FROM Catalog_Contents_Additional_Attributes GROUP BY attribute_value ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["catalog_contents", "catalog_contents_additional_attributes"], "description": "This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that have a specific attribute value. The query joins the 'Catalog_Contents' table with the 'Catalog_Contents_Additional_Attributes' table to filter entries based on the most common attribute value, represented by a placeholder for numeric values.", "virtual_table": "SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.attribute_value  =  (SELECT attribute_value FROM Catalog_Contents_Additional_Attributes GROUP BY attribute_value ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.337", "db_id": "product_catalog", "question": "Find the dates on which more than one revisions were made.", "rationale": ["The query identifies the relevant table, which is 'Catalogs'.", "It selects the 'date_of_latest_revision' column to display the latest revision dates.", "The GROUP BY clause is used to group the results by 'date_of_latest_revision'.", "The HAVING clause filters the groups to only include those with a count greater than a specified number, using a placeholder for numeric values."], "gold_sql": "SELECT date_of_latest_revision FROM Catalogs GROUP BY date_of_latest_revision HAVING count(*)  >  1", "source_tables": ["catalogs"], "description": "The virtual table provides the latest revision dates of catalogs from the 'Catalogs' table, grouped by the revision date. The placeholder in the HAVING clause represents the minimum count of catalogs that must share the same revision date.", "virtual_table": "SELECT date_of_latest_revision FROM Catalogs GROUP BY date_of_latest_revision HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.312", "db_id": "product_catalog", "question": "Find the catalog publisher that has the most catalogs.", "rationale": ["The query identifies the relevant table, which is 'Catalogs'.", "It selects the 'catalog_publisher' column to display the names of publishers.", "The GROUP BY clause is used to group the results by 'catalog_publisher'.", "The ORDER BY clause sorts the grouped results by the count of catalogs for each publisher in descending order.", "The LIMIT clause restricts the number of results returned to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT catalog_publisher FROM catalogs GROUP BY catalog_publisher ORDER BY count(*) DESC LIMIT 1", "source_tables": ["catalogs"], "description": "This virtual table provides a list of catalog publishers from the 'Catalogs' table, grouped by publisher name. The results are ordered by the number of catalogs each publisher has, in descending order, and limited to a specified number of publishers. The placeholder in the LIMIT clause represents the maximum number of publishers to return.", "virtual_table": "SELECT catalog_publisher FROM catalogs GROUP BY catalog_publisher ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.329", "db_id": "product_catalog", "question": "Find the names of catalog entries with level number 8.", "rationale": ["The query identifies the relevant tables, 'Catalog_Contents' and 'Catalog_Contents_Additional_Attributes'.", "It selects the 'catalog_entry_name' from 'Catalog_Contents'.", "A JOIN operation is performed to link 'Catalog_Contents' with 'Catalog_Contents_Additional_Attributes' based on the 'catalog_entry_id'.", "A condition is added to filter the results based on 'catalog_level_number' using a placeholder for string values."], "gold_sql": "SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.catalog_level_number  =  '8'", "source_tables": ["catalog_contents", "catalog_contents_additional_attributes"], "description": "This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that are associated with specific additional attributes. The placeholder in the WHERE clause represents the level number of the catalog entry, allowing users to filter results based on this attribute.", "virtual_table": "SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.catalog_level_number  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.311", "db_id": "product_catalog", "question": "Which catalog publisher has published the most catalogs?", "rationale": ["The query identifies the relevant table, which is 'Catalogs'.", "It selects the 'catalog_publisher' column to display the names of publishers.", "The GROUP BY clause is used to group the results by 'catalog_publisher'.", "The ORDER BY clause sorts the grouped results based on the count of catalogs for each publisher in descending order.", "The LIMIT clause restricts the number of results returned to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT catalog_publisher FROM catalogs GROUP BY catalog_publisher ORDER BY count(*) DESC LIMIT 1", "source_tables": ["catalogs"], "description": "This virtual table provides a list of catalog publishers from the 'Catalogs' table, grouped by publisher name. The results are ordered by the number of catalogs each publisher has, in descending order, and limited to a specified number of publishers. The placeholder in the LIMIT clause represents the maximum number of publishers to return.", "virtual_table": "SELECT catalog_publisher FROM catalogs GROUP BY catalog_publisher ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.319", "db_id": "product_catalog", "question": "What is the level name of the cheapest catalog (in USD)?", "rationale": ["The query identifies the relevant tables, which are 'Catalog_Contents' and 'Catalog_Structure'.", "It selects the 'catalog_level_name' from the 'Catalog_Structure' table.", "A JOIN operation is performed on the 'catalog_level_number' to link the two tables based on their relationship.", "The results are ordered by the 'price_in_dollars' from the 'Catalog_Contents' table.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT t2.catalog_level_name FROM catalog_contents AS t1 JOIN catalog_structure AS t2 ON t1.catalog_level_number  =  t2.catalog_level_number ORDER BY t1.price_in_dollars LIMIT 1", "source_tables": ["catalog_structure", "catalog_contents"], "description": "The virtual table describes the names of catalog levels from the 'Catalog_Structure' table that are associated with entries in the 'Catalog_Contents' table. The results are ordered by the price in dollars of the catalog entries, and the number of results returned is limited by a placeholder for numeric values.", "virtual_table": "SELECT t2.catalog_level_name FROM catalog_contents AS t1 JOIN catalog_structure AS t2 ON t1.catalog_level_number  =  t2.catalog_level_number ORDER BY t1.price_in_dollars LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.320", "db_id": "product_catalog", "question": "Find the level name of the catalog with the lowest price (in USD).", "rationale": ["The query identifies the relevant tables, which are 'Catalog_Contents' and 'Catalog_Structure'.", "It selects the 'catalog_level_name' from the 'Catalog_Structure' table.", "A JOIN operation is performed on the 'catalog_level_number' to link the two tables based on their relationship.", "The results are ordered by the 'price_in_dollars' from the 'Catalog_Contents' table.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT t2.catalog_level_name FROM catalog_contents AS t1 JOIN catalog_structure AS t2 ON t1.catalog_level_number  =  t2.catalog_level_number ORDER BY t1.price_in_dollars LIMIT 1", "source_tables": ["catalog_structure", "catalog_contents"], "description": "The virtual table describes the names of catalog levels from the 'Catalog_Structure' table that are associated with entries in the 'Catalog_Contents' table. The results are ordered by the price in dollars of the catalog entries, and the number of results returned is limited by a placeholder for numeric values.", "virtual_table": "SELECT t2.catalog_level_name FROM catalog_contents AS t1 JOIN catalog_structure AS t2 ON t1.catalog_level_number  =  t2.catalog_level_number ORDER BY t1.price_in_dollars LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5589", "db_id": "products_gen_characteristics", "question": "What are the names of products that are not 'white' in color and are not measured by the unit 'Handful'?", "rationale": ["The query identifies the relevant tables: 'Products', 'Ref_Product_Categories', and 'Ref_Colors'.", "It selects the 'product_name' column from the 'Products' table.", "The query joins 'Products' with 'Ref_Product_Categories' on the 'product_category_code' to filter by product category.", "It also joins 'Products' with 'Ref_Colors' on the 'color_code' to filter by color.", "The WHERE clause includes conditions to filter products based on the specified color description and excludes those with a specific unit of measure using placeholders."], "gold_sql": "SELECT t1.product_name FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code JOIN ref_colors AS t3 ON t1.color_code  =  t3.color_code WHERE t3.color_description  =  'white' AND t2.unit_of_measure != 'Handful'", "source_tables": ["products", "ref_colors", "ref_product_categories"], "description": "This virtual table describes the names of products from the 'Products' table that are associated with a specific color and do not belong to a certain unit of measure. The placeholders in the WHERE clause represent the color description and the unit of measure respectively.", "virtual_table": "SELECT t1.product_name FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code JOIN ref_colors AS t3 ON t1.color_code  =  t3.color_code WHERE t3.color_description  =  [PLACEHOLDER-TYPE:STRING] AND t2.unit_of_measure != [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5535", "db_id": "products_gen_characteristics", "question": "How many products are in the 'Spices' category and have a typical price of over 1000?", "rationale": ["The query identifies the relevant table, which is 'Products'.", "It uses the COUNT function to count the number of products that meet specific criteria.", "The WHERE clause filters products based on the 'product_category_code' and 'typical_buying_price', using placeholders for the string and numeric values."], "gold_sql": "SELECT count(*) FROM products WHERE product_category_code  =  'Spices' AND typical_buying_price  >  1000", "source_tables": ["products"], "description": "This virtual table provides a count of products from the 'Products' table that belong to a specific product category and have a typical buying price above a certain threshold. The placeholders in the WHERE clause represent the product category code and the minimum buying price.", "virtual_table": "SELECT count(*) FROM products WHERE product_category_code  =  [PLACEHOLDER-TYPE:STRING] AND typical_buying_price  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5576", "db_id": "products_gen_characteristics", "question": "Count the products that have the color description \"white\" or have the characteristic name \"hot\".", "rationale": ["The query identifies the relevant tables: 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors'.", "It uses JOIN operations to link these tables based on their foreign key relationships.", "The SELECT statement counts the total number of products that meet the specified conditions.", "The WHERE clause filters the results based on either the color description or the characteristic name, using placeholders for user-defined values."], "gold_sql": "SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  'white' OR t3.characteristic_name  =  'hot'", "source_tables": ["products", "ref_colors", "characteristics", "product_characteristics"], "description": "This virtual table provides a count of products that either match a specific color description or have a specific characteristic name. It combines data from multiple tables, including 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors', using their respective foreign key relationships. The placeholders in the WHERE clause represent the color description and characteristic name that the user can specify.", "virtual_table": "SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  [PLACEHOLDER-TYPE:STRING] OR t3.characteristic_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5562", "db_id": "products_gen_characteristics", "question": "List all characteristics of product named \"sesame\" with type code \"Grade\".", "rationale": ["The query identifies the relevant tables: 'Products', 'Product_Characteristics', and 'Characteristics'.", "It selects the 'characteristic_name' from the 'Characteristics' table.", "The JOIN operations link the 'Products' table to 'Product_Characteristics' and then to 'Characteristics' using their respective IDs.", "The WHERE clause filters the results based on the specified product name and characteristic type code, using placeholders for these values."], "gold_sql": "SELECT t3.characteristic_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  'sesame' AND t3.characteristic_type_code  =  'Grade'", "source_tables": ["products", "characteristics", "product_characteristics"], "description": "This virtual table describes the names of characteristics associated with a specific product from the 'Products' table. The query joins the 'Products', 'Product_Characteristics', and 'Characteristics' tables to filter characteristics based on the product's name and the type of characteristic. The placeholders in the WHERE clause represent the product's name and the characteristic type code.", "virtual_table": "SELECT t3.characteristic_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING] AND t3.characteristic_type_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5593", "db_id": "products_gen_characteristics", "question": "Give the color description that is least common across products.", "rationale": ["The query identifies the relevant tables, which are 'Products' and 'Ref_Colors'.", "It selects the 'color_description' from the 'Ref_Colors' table.", "A JOIN operation is performed on the 'color_code' to link products with their respective colors.", "The results are grouped by 'color_description' to aggregate the product counts for each color.", "The results are ordered by the count of products in ascending order, and a limit is applied to restrict the number of returned color descriptions using a placeholder for numeric values."], "gold_sql": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) ASC LIMIT 1", "source_tables": ["products", "ref_colors"], "description": "The virtual table describes the color descriptions of products from the 'Products' table, grouped by color and ordered by the count of products for each color. The placeholder in the LIMIT clause represents the maximum number of color descriptions to return.", "virtual_table": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5557", "db_id": "products_gen_characteristics", "question": "Count the number of different characteristic names the product 'cumin' has.", "rationale": ["The query identifies the relevant tables: 'Products', 'Product_Characteristics', and 'Characteristics'.", "It uses JOIN operations to link these tables based on their relationships: 'Products' to 'Product_Characteristics' via 'product_id', and 'Product_Characteristics' to 'Characteristics' via 'characteristic_id'.", "The SELECT statement counts the distinct 'characteristic_name' from the 'Characteristics' table.", "A condition is added to filter the results based on the specified product name using a placeholder for string values."], "gold_sql": "SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  'sesame'", "source_tables": ["products", "characteristics", "product_characteristics"], "description": "This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.", "virtual_table": "SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5542", "db_id": "products_gen_characteristics", "question": "Find the category descriptions of the products whose descriptions include letter 't'.", "rationale": ["The query identifies the relevant tables, which are 'Ref_Product_Categories' and 'Products'.", "It selects the 'product_category_description' from 'Ref_Product_Categories'.", "A JOIN is performed between 'Ref_Product_Categories' and 'Products' on the 'product_category_code' to link the product categories with their respective products.", "A condition is added to filter the results based on the 'product_description' using a placeholder for string values."], "gold_sql": "SELECT T1.product_category_description FROM ref_product_categories AS T1 JOIN products AS T2 ON T1.product_category_code  =  T2.product_category_code WHERE T2.product_description LIKE '%t%'", "source_tables": ["products", "ref_product_categories"], "description": "This virtual table provides the descriptions of product categories from the 'Ref_Product_Categories' table for products that have a specific description. The placeholder in the WHERE clause allows for filtering products based on their description.", "virtual_table": "SELECT T1.product_category_description FROM ref_product_categories AS T1 JOIN products AS T2 ON T1.product_category_code  =  T2.product_category_code WHERE T2.product_description LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5526", "db_id": "products_gen_characteristics", "question": "Find the names of all the product characteristics.", "rationale": ["The query is identifying the relevant table, which is 'Characteristics'.", "Select the column to display, 'characteristic_name'.", "Use the DISTINCT keyword to ensure that only unique characteristic names are returned."], "gold_sql": "SELECT DISTINCT characteristic_name FROM CHARACTERISTICS", "source_tables": ["characteristics"], "description": "The virtual table describes the distinct names of characteristics from the 'Characteristics' table. This allows users to retrieve unique characteristic names without duplicates.", "virtual_table": "SELECT DISTINCT characteristic_name FROM CHARACTERISTICS"}
{"sample_id": "train.5652", "db_id": "railway", "question": "Show the countries that have managers of age above 50 or below 46.", "rationale": ["The query identifies the relevant table, which is 'manager'.", "Select the column to display, 'Country'.", "Add a condition to filter the 'Age' column for managers who are either older than or younger than specified age limits using placeholders for numeric values."], "gold_sql": "SELECT Country FROM manager WHERE Age  >  50 OR Age  <  46", "source_tables": ["manager"], "description": "This virtual table provides a list of countries where managers are based, filtered by their age. The placeholders in the WHERE clause represent the age limits for the managers, allowing users to specify a range of ages to retrieve the relevant countries.", "virtual_table": "SELECT Country FROM manager WHERE Age  >  [PLACEHOLDER-TYPE:NUMBER] OR Age  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5635", "db_id": "railway", "question": "What is the maximum level of managers in countries that are not \"Australia\"?", "rationale": ["The query identifies the relevant table, which is 'manager'.", "It selects the maximum value of the 'Level' column to find the highest management level.", "A condition is added to filter out managers based on their country using a placeholder for string values."], "gold_sql": "SELECT max(LEVEL) FROM manager WHERE Country != 'Australia\t'", "source_tables": ["manager"], "description": "This virtual table provides the highest management level of managers from the 'manager' table who are not based in a specific country. The placeholder in the WHERE clause represents the name of the country to exclude from the results.", "virtual_table": "SELECT max(LEVEL) FROM manager WHERE Country != [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5639", "db_id": "railway", "question": "What is the name of the oldest manager?", "rationale": ["The query identifies the relevant table, which is 'manager'.", "Select the column to display, 'Name'.", "Order the results by the 'Age' column in descending order to show the oldest managers first.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT Name FROM manager ORDER BY Age DESC LIMIT 1", "source_tables": ["manager"], "description": "This virtual table lists the names of managers from the 'manager' table, ordered by their age in descending order. The placeholder in the LIMIT clause represents the maximum number of manager names to be displayed.", "virtual_table": "SELECT Name FROM manager ORDER BY Age DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1299", "db_id": "soccer_1", "question": "List the names of all players who have a crossing score higher than 90 and prefer their right foot.", "rationale": ["The query identifies the relevant tables, 'Player' and 'Player_Attributes'.", "It selects distinct player names from the 'Player' table.", "A JOIN operation is performed on 'Player' and 'Player_Attributes' using the 'player_api_id' to link player attributes to their respective players.", "Conditions are added to filter players based on their crossing ability and preferred foot using placeholders for numeric and string values."], "gold_sql": "SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.crossing  >  90 AND T2.preferred_foot  =  'right'", "source_tables": ["player_attributes", "player"], "description": "This virtual table lists the distinct names of players from the 'Player' table who have a crossing ability greater than a specified value and have a preferred foot that matches a given specification. The placeholders in the WHERE clause represent the crossing ability threshold and the preferred foot of the players.", "virtual_table": "SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.crossing  >  [PLACEHOLDER-TYPE:NUMBER] AND T2.preferred_foot  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1300", "db_id": "soccer_1", "question": "List the names of all left-footed players who have overall rating between 85 and 90.", "rationale": ["The query identifies the relevant tables, 'Player' and 'Player_Attributes'.", "It selects distinct player names from the 'Player' table.", "A JOIN operation is performed on the 'player_api_id' to combine player data with their attributes.", "Conditions are added to filter players based on their preferred foot and overall rating using placeholders for string and numeric values."], "gold_sql": "SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.preferred_foot  =  'left' AND T2.overall_rating  >=  85 AND T2.overall_rating  <=  90", "source_tables": ["player_attributes", "player"], "description": "This virtual table lists the distinct names of players from the 'Player' table who have a specific preferred foot and whose overall skill rating falls within a defined range. The placeholders in the WHERE clause represent the preferred foot and the minimum and maximum overall ratings.", "virtual_table": "SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.preferred_foot  =  [PLACEHOLDER-TYPE:STRING] AND T2.overall_rating  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.overall_rating  <=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1298", "db_id": "soccer_1", "question": "What are the names of players who have the best dribbling?", "rationale": ["The query identifies the relevant tables, which are 'Player' and 'Player_Attributes'.", "It selects distinct player names from the 'Player' table.", "The join condition links the 'Player' table with the 'Player_Attributes' table using the 'player_api_id'.", "A subquery is used to find the maximum overall rating from the 'Player_Attributes' table.", "The WHERE clause filters the results to include only those players whose dribbling attribute equals the maximum overall rating."], "gold_sql": "SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.dribbling  =  ( SELECT max(overall_rating) FROM Player_Attributes)", "source_tables": ["player_attributes", "player"], "description": "This virtual table lists the distinct names of players from the 'Player' table who have the highest overall skill rating recorded in the 'Player_Attributes' table. The query joins the 'Player' and 'Player_Attributes' tables based on the player's API identifier and filters the results to only include players whose dribbling attribute matches the maximum overall rating found in the 'Player_Attributes' table.", "virtual_table": "SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.dribbling  =  ( SELECT max(overall_rating) FROM Player_Attributes)"}
{"sample_id": "train.1297", "db_id": "soccer_1", "question": "List all player names who have an overall rating higher than the average.", "rationale": ["The query identifies the relevant tables, 'Player' and 'Player_Attributes'.", "It selects distinct player names from the 'Player' table.", "A join is performed between 'Player' and 'Player_Attributes' on the 'player_api_id' to link player names with their attributes.", "A condition is added to filter players whose overall rating is greater than the average overall rating calculated from a subquery on the 'Player_Attributes' table."], "gold_sql": "SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.overall_rating  >  ( SELECT avg(overall_rating) FROM Player_Attributes )", "source_tables": ["player_attributes", "player"], "description": "This virtual table lists the names of players from the 'Player' table who have an overall skill rating higher than the average overall rating of all players recorded in the 'Player_Attributes' table. The query uses a subquery to calculate the average overall rating and filters the results accordingly.", "virtual_table": "SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.overall_rating  >  ( SELECT avg(overall_rating) FROM Player_Attributes )"}
{"sample_id": "train.1305", "db_id": "soccer_1", "question": "Who are the top 3 players in terms of overall rating?", "rationale": ["The query identifies the relevant tables, 'Player' and 'Player_Attributes'.", "It selects distinct player names from the 'Player' table (aliased as T1).", "A join is performed on the 'player_api_id' to link player attributes from the 'Player_Attributes' table (aliased as T2).", "The results are ordered by the 'overall_rating' in descending order to prioritize higher-rated players.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id  =  T2.player_api_id ORDER BY overall_rating DESC LIMIT 3", "source_tables": ["player_attributes", "player"], "description": "This virtual table provides a list of unique player names from the 'Player' table, joined with their corresponding attributes from the 'Player_Attributes' table. The results are ordered by the players' overall skill ratings in descending order, and the number of results returned is limited by a specified placeholder for numeric values.", "virtual_table": "SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id  =  T2.player_api_id ORDER BY overall_rating DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1296", "db_id": "soccer_1", "question": "What is the maximum and minimum height of all players?", "rationale": ["The query identifies the relevant table, which is 'Player'.", "It selects the maximum and minimum values of the 'weight' column.", "The use of aggregate functions 'max' and 'min' allows for the retrieval of the highest and lowest weights of players."], "gold_sql": "SELECT max(weight) ,  min(weight) FROM Player", "source_tables": ["player"], "description": "This virtual table provides the maximum and minimum weights of players from the 'Player' table. The placeholders in the SELECT clause represent the weight values being aggregated.", "virtual_table": "SELECT max(weight) ,  min(weight) FROM Player"}
{"sample_id": "train.5035", "db_id": "soccer_2", "question": "What are the names of all the states with college students playing in the mid position but no goalies?", "rationale": ["The query identifies the relevant tables, 'College' and 'Tryout'.", "It uses a JOIN operation to connect these tables based on the college name ('cName').", "The WHERE clause filters the results to include only those tryouts for a specific position using a placeholder for string values.", "The EXCEPT clause is applied to exclude states that have hosted tryouts for the same position, ensuring the final result contains unique states."], "gold_sql": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'mid' EXCEPT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'goalie'", "source_tables": ["tryout", "college"], "description": "This virtual table provides a list of states where colleges are located, specifically focusing on the states of colleges that have hosted tryouts for a particular position. The query uses a JOIN operation to connect the 'College' and 'Tryout' tables based on the college name, filtering the results by the player's position. The EXCEPT clause is used to exclude states from the second selection that also hosted tryouts for the same position, ensuring that only unique states are returned.", "virtual_table": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5024", "db_id": "soccer_2", "question": "Find the names of either colleges in LA with greater than 15000 size or in state AZ with less than 13000 enrollment.", "rationale": ["The query identifies the relevant table, which is 'College'.", "It selects the 'cName' column to display the names of the colleges.", "Two conditions are added to filter the colleges based on their enrollment numbers and state, using placeholders for numeric and string values.", "The UNION operator is used to combine the results of the two queries, allowing for both conditions to be satisfied."], "gold_sql": "SELECT cName FROM College WHERE enr  <  13000 AND state = 'AZ' UNION SELECT cName FROM College WHERE enr  >  15000 AND state = 'LA'", "source_tables": ["college"], "description": "This virtual table describes the names of colleges located in a specific state that have an enrollment number either less than or greater than a specified value. The placeholders in the WHERE clauses represent the enrollment numbers and the state name.", "virtual_table": "SELECT cName FROM College WHERE enr  <  [PLACEHOLDER-TYPE:NUMBER] AND state = [PLACEHOLDER-TYPE:STRING] UNION SELECT cName FROM College WHERE enr  >  [PLACEHOLDER-TYPE:NUMBER] AND state = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4993", "db_id": "soccer_2", "question": "What is the name of the school with smallest enrollment size per state?", "rationale": ["The query identifies the relevant table, which is 'College'.", "It selects the columns 'cName', 'state', and the minimum enrollment number 'enr'.", "The GROUP BY clause is used to group the results by 'state', allowing us to find the minimum enrollment for each state."], "gold_sql": "SELECT cName ,  state ,  min(enr) FROM college GROUP BY state", "source_tables": ["college"], "description": "This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college's name, state, and the minimum enrollment number.", "virtual_table": "SELECT cName ,  state ,  min(enr) FROM college GROUP BY state"}
{"sample_id": "train.5015", "db_id": "soccer_2", "question": "For each position, what is the maximum number of  hours for students who spent more than 1000 hours training?", "rationale": ["The query identifies the relevant tables, which are 'Player' and 'Tryout'.", "It selects the maximum high school value from the 'Player' table and the position from the 'Tryout' table.", "A JOIN operation is performed on the player ID to combine data from both tables.", "A condition is added to filter players based on their high school attendance using a placeholder for numeric values.", "The results are grouped by the position the player is trying out for."], "gold_sql": "SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  1000 GROUP BY T2.pPos", "source_tables": ["player", "tryout"], "description": "This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.", "virtual_table": "SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos"}
{"sample_id": "train.4992", "db_id": "soccer_2", "question": "What is the name of school that has the smallest enrollment in each state?", "rationale": ["The query identifies the relevant table, which is 'College'.", "It selects the columns 'cName', 'state', and the minimum enrollment number 'min(enr)'.", "The GROUP BY clause is used to group the results by the 'state' column, allowing for aggregation of enrollment numbers per state."], "gold_sql": "SELECT cName ,  state ,  min(enr) FROM college GROUP BY state", "source_tables": ["college"], "description": "This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college name, state, and the minimum enrollment number.", "virtual_table": "SELECT cName ,  state ,  min(enr) FROM college GROUP BY state"}
{"sample_id": "train.5027", "db_id": "soccer_2", "question": "What are the names of all schools that have students trying out for the position of goal and 'mid'-field.", "rationale": ["The query identifies the relevant table, which is 'Tryout'.", "It selects the 'cName' column to display the names of colleges.", "The query uses the INTERSECT operator to find colleges where players are trying out for two different positions, using placeholders for the position values."], "gold_sql": "SELECT cName FROM  tryout WHERE pPos  =  'goalie' INTERSECT SELECT cName FROM  tryout WHERE pPos  =  'mid'", "source_tables": ["tryout"], "description": "The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.", "virtual_table": "SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5014", "db_id": "soccer_2", "question": "What is the maximum training hours for the students whose training hours is greater than 1000 in different positions?", "rationale": ["The query identifies the relevant tables, which are 'Player' and 'Tryout'.", "It selects the maximum high school identifier and the position from the 'Player' table.", "A JOIN operation is performed between 'Player' and 'Tryout' on the player ID to combine relevant data.", "A condition is added to filter players based on their high school identifier using a placeholder for numeric values.", "The results are grouped by the position of the players in the tryout."], "gold_sql": "SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  1000 GROUP BY T2.pPos", "source_tables": ["player", "tryout"], "description": "This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.", "virtual_table": "SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos"}
{"sample_id": "train.5041", "db_id": "soccer_2", "question": "What are the names of the colleges that are larger than at least one college in Florida?", "rationale": ["The query identifies the relevant table, which is 'College'.", "It selects distinct college names from the 'cName' column.", "A subquery is used to find the minimum enrollment number from the 'College' table filtered by the specified state using a placeholder for string values."], "gold_sql": "SELECT DISTINCT cName FROM college WHERE enr  >  (SELECT min(enr) FROM college WHERE state  =  'FL')", "source_tables": ["college"], "description": "This virtual table lists the distinct names of colleges from the 'College' table that have an enrollment number greater than the minimum enrollment number of colleges located in a specific state. The placeholder in the WHERE clause represents the state name.", "virtual_table": "SELECT DISTINCT cName FROM college WHERE enr  >  (SELECT min(enr) FROM college WHERE state  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.5043", "db_id": "soccer_2", "question": "What are the names of all colleges with a larger enrollment than the largest college in Florida?", "rationale": ["The query identifies the relevant table, which is 'College'.", "It selects the 'cName' column to display the names of the colleges.", "A subquery is used to find the maximum enrollment number from the 'College' table filtered by a specific state, using a placeholder for string values in the WHERE clause."], "gold_sql": "SELECT cName FROM college WHERE enr  >  (SELECT max(enr) FROM college WHERE state  =  'FL')", "source_tables": ["college"], "description": "This virtual table lists the names of colleges from the 'College' table that have an enrollment number greater than the maximum enrollment number of colleges located in a specific state. The placeholder in the WHERE clause represents the state name.", "virtual_table": "SELECT cName FROM college WHERE enr  >  (SELECT max(enr) FROM college WHERE state  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.5011", "db_id": "soccer_2", "question": "What is the average and maximum number of hours students who made the team practiced?", "rationale": ["The query identifies the relevant tables, which are 'Player' and 'Tryout'.", "It selects the average and maximum values of the 'HS' column from the 'Player' table.", "A JOIN operation is performed on the 'pID' column to link players with their tryout decisions.", "A condition is added to filter the results based on the 'decision' column in the 'Tryout' table using a placeholder for string values."], "gold_sql": "SELECT avg(T1.HS) ,  max(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes'", "source_tables": ["player", "tryout"], "description": "This virtual table calculates the average and maximum high school identifier of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.", "virtual_table": "SELECT avg(T1.HS) ,  max(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5002", "db_id": "soccer_2", "question": "Find the name and hours of the students whose tryout decision is yes.", "rationale": ["The query identifies the relevant tables, which are 'Player' and 'Tryout'.", "It selects the columns to display, 'pName' and 'HS' from the 'Player' table.", "A JOIN operation is performed between 'Player' and 'Tryout' on the 'pID' column to link players with their tryout information.", "A condition is added to filter the results based on the 'decision' column in the 'Tryout' table using a placeholder for string values."], "gold_sql": "SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes'", "source_tables": ["player", "tryout"], "description": "This virtual table describes the names and high schools of players from the 'Player' table who have a specific decision regarding their tryout. The placeholder in the WHERE clause represents the decision made about the player's tryout.", "virtual_table": "SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5010", "db_id": "soccer_2", "question": "Find the average and maximum hours for the students whose tryout decision is yes.", "rationale": ["The query identifies the relevant tables, which are 'Player' and 'Tryout'.", "It selects the average and maximum values of the 'HS' column from the 'Player' table, aliased as T1.", "A JOIN operation is performed between 'Player' and 'Tryout' on the player ID to link the two tables.", "A condition is added to filter the results based on the 'decision' column from the 'Tryout' table using a placeholder for string values."], "gold_sql": "SELECT avg(T1.HS) ,  max(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes'", "source_tables": ["player", "tryout"], "description": "This virtual table provides the average and maximum high school identifiers of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.", "virtual_table": "SELECT avg(T1.HS) ,  max(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4997", "db_id": "soccer_2", "question": "What are the different states that had students successfully try out?", "rationale": ["The query identifies the relevant tables, which are 'College' and 'Tryout'.", "It selects distinct states from the 'College' table to avoid duplicates.", "A JOIN operation is performed between 'College' and 'Tryout' on the college name to link the two tables.", "A condition is added to filter the results based on the 'decision' column in the 'Tryout' table using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  'yes'", "source_tables": ["tryout", "college"], "description": "This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.", "virtual_table": "SELECT DISTINCT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4980", "db_id": "soccer_2", "question": "Find the name of players whose card is yes in the descending order of training hours.", "rationale": ["The query identifies the relevant table, which is 'Player'.", "Select the column to display, 'pName'.", "Add a condition to filter the 'yCard' column for the specified year of eligibility using a placeholder for string values.", "Order the results by the 'HS' column in descending order."], "gold_sql": "SELECT pName FROM Player WHERE yCard  =  'yes' ORDER BY HS DESC", "source_tables": ["player"], "description": "This virtual table describes the names of players from the 'Player' table who have a specific year of eligibility. The results are ordered by the high school attended by the players in descending order. The placeholder in the WHERE clause represents the year of the player's card or eligibility.", "virtual_table": "SELECT pName FROM Player WHERE yCard  =  [PLACEHOLDER-TYPE:STRING] ORDER BY HS DESC"}
{"sample_id": "train.4957", "db_id": "soccer_2", "question": "What are the names and number of hours spent training for each player who trains for less than 1500 hours?", "rationale": ["The query is identifying the relevant table, which is 'Player'.", "Select the columns to display, 'pName' and 'HS'.", "Add a condition to filter the 'HS' column for high schools with an enrollment number less than the specified value using a placeholder for numeric values."], "gold_sql": "SELECT pName ,  HS FROM Player WHERE HS  <  1500", "source_tables": ["player"], "description": "This virtual table describes the names and high schools of players from the 'Player' table who attended high schools with an enrollment number less than a specified value. The placeholder in the WHERE clause represents the enrollment number of students.", "virtual_table": "SELECT pName ,  HS FROM Player WHERE HS  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4972", "db_id": "soccer_2", "question": "Find the players whose names contain letter 'a'.", "rationale": ["The query identifies the relevant table, which is 'Player'.", "It selects the distinct column 'pName' to ensure unique player names are returned.", "A condition is added to filter the 'pName' column using a LIKE clause with a placeholder for string values, allowing for pattern matching."], "gold_sql": "SELECT DISTINCT pName FROM Player WHERE pName LIKE '%a%'", "source_tables": ["player"], "description": "This virtual table provides a list of unique player names from the 'Player' table that match a specific pattern. The placeholder in the WHERE clause allows for filtering player names based on a given string pattern.", "virtual_table": "SELECT DISTINCT pName FROM Player WHERE pName LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5019", "db_id": "soccer_2", "question": "What college has a student who successfully made the team in the role of a goalie?", "rationale": ["The query identifies the relevant table, which is 'Tryout'.", "Select the column to display, 'cName', which represents the college name.", "Add conditions to filter the 'decision' and 'pPos' columns for the specified values using placeholders for string values."], "gold_sql": "SELECT cName FROM  tryout WHERE decision  =  'yes' AND pPos  =  'goalie'", "source_tables": ["tryout"], "description": "This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.", "virtual_table": "SELECT cName FROM  tryout WHERE decision  =  [PLACEHOLDER-TYPE:STRING] AND pPos  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5009", "db_id": "soccer_2", "question": "In which state is the college that Charles attends?", "rationale": ["The query identifies the relevant tables: 'College', 'Tryout', and 'Player'.", "It selects the 'state' column from the 'College' table.", "The JOIN operations link the 'Tryout' table to the 'College' table using the college name, and the 'Player' table to the 'Tryout' table using the player ID.", "A condition is added to filter the results based on the player's name using a placeholder for string values."], "gold_sql": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName JOIN player AS T3 ON T2.pID  =  T3.pID WHERE T3.pName  =  'Charles'", "source_tables": ["player", "tryout", "college"], "description": "This virtual table provides the states of colleges where a specific player has participated in tryouts. The placeholder in the WHERE clause represents the player's name.", "virtual_table": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName JOIN player AS T3 ON T2.pID  =  T3.pID WHERE T3.pName  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4960", "db_id": "soccer_2", "question": "What are the unique types of player positions in the tryout?", "rationale": ["The query is identifying the relevant table, which is 'Tryout'.", "The goal is to count the distinct values in the 'pPos' column, which represents the positions players are trying out for.", "Using the COUNT function along with DISTINCT allows us to get the unique count of positions from the tryout records."], "gold_sql": "SELECT count(DISTINCT pPos) FROM tryout", "source_tables": ["tryout"], "description": "This virtual table provides the count of distinct positions that players are trying out for in the 'Tryout' table. The result will give an overview of the variety of positions available for players during tryouts.", "virtual_table": "SELECT count(DISTINCT pPos) FROM tryout"}
{"sample_id": "train.4954", "db_id": "soccer_2", "question": "What is the average training hours of all players?", "rationale": ["The query is identifying the relevant table, which is 'Player'.", "Select the column to calculate the average, which is 'HS'.", "Use the AVG function to compute the average of the high school values."], "gold_sql": "SELECT avg(HS) FROM Player", "source_tables": ["player"], "description": "This virtual table calculates the average high school attended by players from the 'Player' table. The placeholder in the SELECT clause represents the high school data that will be averaged.", "virtual_table": "SELECT avg(HS) FROM Player"}
{"sample_id": "train.5031", "db_id": "soccer_2", "question": "How many schools have students playing in goalie and mid-field positions?", "rationale": ["The query identifies the relevant table, which is 'Tryout'.", "It uses a subquery to select the college names where players are trying out for the first specified position.", "It uses another subquery to select the college names where players are trying out for the second specified position.", "The INTERSECT operator is used to find colleges that appear in both subqueries, indicating they have players trying out for both positions.", "Finally, the COUNT function is used to count the number of colleges returned by the INTERSECT operation."], "gold_sql": "SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  'goalie' INTERSECT SELECT cName FROM  tryout WHERE pPos  =  'mid')", "source_tables": ["tryout"], "description": "This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.", "virtual_table": "SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.5001", "db_id": "soccer_2", "question": "What are the names of all students who tried out in alphabetical order?", "rationale": ["The query identifies the relevant tables, which are 'Player' and 'Tryout'.", "It selects the 'pName' column from the 'Player' table.", "A JOIN operation is performed on the 'pID' column to link players with their corresponding tryouts.", "The results are ordered by the player's name to provide a sorted list."], "gold_sql": "SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName", "source_tables": ["player", "tryout"], "description": "This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.", "virtual_table": "SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName"}
{"sample_id": "train.5000", "db_id": "soccer_2", "question": "Find the name of all students who were in the tryout sorted in alphabetic order.", "rationale": ["The query identifies the relevant tables, which are 'Player' and 'Tryout'.", "It selects the 'pName' column from the 'Player' table.", "A JOIN operation is performed between 'Player' and 'Tryout' on the 'pID' column to link players with their tryout information.", "The results are ordered by the player's name to provide a sorted list."], "gold_sql": "SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName", "source_tables": ["player", "tryout"], "description": "This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.", "virtual_table": "SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName"}
{"sample_id": "train.4965", "db_id": "soccer_2", "question": "What is the number of students playing as a goalie?", "rationale": ["The query identifies the relevant table, which is 'Tryout'.", "It selects the count of all entries in the 'Tryout' table.", "A condition is added to filter the results based on the 'pPos' column, using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM tryout WHERE pPos  =  'goalie'", "source_tables": ["tryout"], "description": "This virtual table provides the total number of players who are trying out for a specific position from the 'Tryout' table. The placeholder in the WHERE clause represents the position for which the count of players is being requested.", "virtual_table": "SELECT count(*) FROM tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4969", "db_id": "soccer_2", "question": "What is average number of students enrolled in Florida colleges?", "rationale": ["The query identifies the relevant table, which is 'College'.", "It selects the average of the 'enr' column to compute the average enrollment number.", "A condition is added to filter the results based on the 'state' column using a placeholder for string values."], "gold_sql": "SELECT avg(enr) FROM College WHERE state  =  'FL'", "source_tables": ["college"], "description": "This virtual table calculates the average enrollment number of colleges located in a specific state. The placeholder in the WHERE clause represents the name of the state.", "virtual_table": "SELECT avg(enr) FROM College WHERE state  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4964", "db_id": "soccer_2", "question": "How many students whose are playing the role of goalie?", "rationale": ["The query identifies the relevant table, which is 'Tryout'.", "It selects the count of all entries in the 'Tryout' table.", "A condition is added to filter the results based on the 'pPos' column, using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM tryout WHERE pPos  =  'goalie'", "source_tables": ["tryout"], "description": "This virtual table provides the total number of players who are trying out for a specific position from the 'Tryout' table. The placeholder in the WHERE clause represents the position for which the count is being calculated.", "virtual_table": "SELECT count(*) FROM tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4950", "db_id": "soccer_2", "question": "How many players have more than 1000 hours of training?", "rationale": ["The query identifies the relevant table, which is 'Player'.", "It uses the COUNT function to count the total number of players.", "A condition is added to filter players based on the enrollment number of their high school using a placeholder for numeric values."], "gold_sql": "SELECT count(*) FROM Player WHERE HS  >  1000", "source_tables": ["player"], "description": "This virtual table counts the number of players from the 'Player' table who attended high schools with an enrollment number greater than a specified value. The placeholder in the WHERE clause represents the enrollment number of students at the high school.", "virtual_table": "SELECT count(*) FROM Player WHERE HS  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5012", "db_id": "soccer_2", "question": "Find the average hours for the students whose tryout decision is no.", "rationale": ["The query identifies the relevant tables, which are 'Player' and 'Tryout'.", "It joins the 'Player' table with the 'Tryout' table on the player ID to associate players with their tryout decisions.", "The SELECT statement is used to calculate the average of the 'HS' column from the 'Player' table.", "A condition is added to filter the results based on the 'decision' column from the 'Tryout' table using a placeholder for string values."], "gold_sql": "SELECT avg(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'no'", "source_tables": ["player", "tryout"], "description": "This virtual table calculates the average high school identifier of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.", "virtual_table": "SELECT avg(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4951", "db_id": "soccer_2", "question": "How many different players trained for more than 1000 hours?", "rationale": ["The query identifies the relevant table, which is 'Player'.", "It selects the count of players, which is an aggregate function to get the total number of records that meet the criteria.", "A condition is added to filter the 'HS' column for high schools with an enrollment number greater than the specified value using a placeholder for numeric values."], "gold_sql": "SELECT count(*) FROM Player WHERE HS  >  1000", "source_tables": ["player"], "description": "This virtual table provides the count of players from the 'Player' table who attended high schools with an enrollment number greater than a specified value. The placeholder in the WHERE clause represents the minimum enrollment number of students at the high school.", "virtual_table": "SELECT count(*) FROM Player WHERE HS  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3385", "db_id": "sports_competition", "question": "which countries did participated in both Friendly and Tournament type competitions.", "rationale": ["The query is identifying the relevant table, which is 'competition'.", "It selects the 'country' column to display the countries where competitions were held.", "The INTERSECT operator is used to find common countries between two queries that filter by the same competition type, using placeholders for string values."], "gold_sql": "SELECT country FROM competition WHERE competition_type  =  'Friendly' INTERSECT SELECT country FROM competition WHERE competition_type  =  'Tournament'", "source_tables": ["competition"], "description": "This virtual table identifies the countries that hosted competitions of a specific type, by finding the intersection of countries from two separate queries for the same competition type. The placeholders in the WHERE clause represent the type of competition being queried.", "virtual_table": "SELECT country FROM competition WHERE competition_type  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT country FROM competition WHERE competition_type  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3387", "db_id": "sports_competition", "question": "Find the countries that have never participated in any competition with Friendly type.", "rationale": ["The query identifies the relevant table, which is 'competition'.", "It selects the 'country' column to display the countries where competitions took place.", "The EXCEPT clause is used to exclude countries that hosted competitions of a specific type, with a placeholder for the competition type in the WHERE clause."], "gold_sql": "SELECT country FROM competition EXCEPT SELECT country FROM competition WHERE competition_type  =  'Friendly'", "source_tables": ["competition"], "description": "This virtual table lists the countries where competitions were held, excluding those countries that hosted competitions of a specific type. The placeholder in the WHERE clause represents the type of competition to be excluded.", "virtual_table": "SELECT country FROM competition EXCEPT SELECT country FROM competition WHERE competition_type  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3386", "db_id": "sports_competition", "question": "What are the countries that participated in both friendly and tournament type competitions?", "rationale": ["The query is identifying the relevant table, which is 'competition'.", "Select the 'country' column to display the countries where competitions were held.", "Use the INTERSECT operator to find common countries between two different competition types, each specified by a placeholder for string values."], "gold_sql": "SELECT country FROM competition WHERE competition_type  =  'Friendly' INTERSECT SELECT country FROM competition WHERE competition_type  =  'Tournament'", "source_tables": ["competition"], "description": "This virtual table identifies the countries that hosted competitions of two specific types. The placeholders in the query represent the types of competitions being compared.", "virtual_table": "SELECT country FROM competition WHERE competition_type  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT country FROM competition WHERE competition_type  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3370", "db_id": "sports_competition", "question": "What are the types of competition that have most 5 competitions for that type?", "rationale": ["The query identifies the relevant table, which is 'competition'.", "It selects the 'Competition_type' column to display the different types of competitions.", "The GROUP BY clause is used to group the results by 'Competition_type'.", "The HAVING clause filters the groups to include only those with a count of occurrences less than or equal to the specified number using a placeholder for numeric values."], "gold_sql": "SELECT Competition_type FROM competition GROUP BY Competition_type HAVING COUNT(*)  <=  5", "source_tables": ["competition"], "description": "This virtual table summarizes the types of competitions from the 'competition' table that have a count of occurrences less than or equal to a specified number. The placeholder in the HAVING clause represents the maximum count of competitions for each type.", "virtual_table": "SELECT Competition_type FROM competition GROUP BY Competition_type HAVING COUNT(*)  <=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3367", "db_id": "sports_competition", "question": "List the most common type of competition.", "rationale": ["The query identifies the relevant table, which is 'competition'.", "It selects the 'Competition_type' column to display the different types of competitions.", "The results are grouped by 'Competition_type' to aggregate the data.", "The results are ordered by the count of each competition type in descending order to show the most common types first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT Competition_type FROM competition GROUP BY Competition_type ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["competition"], "description": "This virtual table summarizes the types of competitions held, grouped by their type, and orders them by the number of occurrences in descending order. The placeholder in the LIMIT clause represents the maximum number of competition types to display.", "virtual_table": "SELECT Competition_type FROM competition GROUP BY Competition_type ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3368", "db_id": "sports_competition", "question": "What is the most common competition type?", "rationale": ["The query identifies the relevant table, which is 'competition'.", "It selects the 'Competition_type' column to display the different types of competitions.", "The results are grouped by 'Competition_type' to aggregate the data.", "The results are ordered by the count of each competition type in descending order to show the most common types first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT Competition_type FROM competition GROUP BY Competition_type ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["competition"], "description": "This virtual table summarizes the types of competitions held, grouped by their type, and orders them by the number of occurrences in descending order. The placeholder in the LIMIT clause represents the maximum number of competition types to display.", "virtual_table": "SELECT Competition_type FROM competition GROUP BY Competition_type ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3344", "db_id": "sports_competition", "question": "What are the types of every competition and in which countries are they located?", "rationale": ["The query identifies the relevant table, which is 'competition'.", "Select the columns to display, 'Competition_type' and 'Country'.", "No filtering conditions are applied, so it retrieves all records from the 'competition' table."], "gold_sql": "SELECT Competition_type ,  Country FROM competition", "source_tables": ["competition"], "description": "This virtual table provides information about the types of competitions and the countries where they are held from the 'competition' table. The placeholders represent the specific competition type and country details.", "virtual_table": "SELECT Competition_type ,  Country FROM competition"}
{"sample_id": "train.3356", "db_id": "sports_competition", "question": "What are the names and players of all the clubs?", "rationale": ["The query identifies the relevant tables, which are 'club' and 'player'.", "It selects the 'name' column from the 'club' table and the 'Player_ID' column from the 'player' table.", "A JOIN operation is performed on the 'Club_ID' column to associate players with their respective clubs."], "gold_sql": "SELECT T1.name ,  T2.Player_id FROM club AS T1 JOIN player AS T2 ON T1.Club_ID  =  T2.Club_ID", "source_tables": ["club", "player"], "description": "This virtual table describes the names of clubs along with the unique identifiers of players associated with those clubs. The join operation links the 'club' table and the 'player' table based on the common 'Club_ID' field, allowing for the retrieval of player information for each club.", "virtual_table": "SELECT T1.name ,  T2.Player_id FROM club AS T1 JOIN player AS T2 ON T1.Club_ID  =  T2.Club_ID"}
{"sample_id": "train.565", "db_id": "store_1", "question": "List the state in the US with the most invoices.", "rationale": ["The query identifies the relevant table, which is 'invoices'.", "It selects the 'billing_state' and counts the number of invoices for each state.", "A condition is added to filter the results based on the specified 'billing_country' using a placeholder for string values.", "The results are grouped by 'billing_state' to aggregate the counts.", "The results are ordered by the count of invoices in descending order to show the states with the most invoices first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT 1;", "source_tables": ["invoices"], "description": "This virtual table summarizes the number of invoices issued per state within a specific country. The placeholder in the WHERE clause represents the country's name, and the placeholder in the LIMIT clause specifies the maximum number of states to return, ordered by the count of invoices in descending order.", "virtual_table": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.604", "db_id": "store_1", "question": "How many employees who are IT staff are from each city?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "It selects the count of employees and the city they reside in.", "A condition is added to filter employees based on their job title using a placeholder for string values.", "The results are grouped by city to provide a count of employees in each city for the specified job title."], "gold_sql": "SELECT count(*) ,  city FROM employees WHERE title  =  'IT Staff' GROUP BY city", "source_tables": ["employees"], "description": "This virtual table provides a count of employees grouped by their city from the 'employees' table, specifically for those who hold a certain job title. The placeholder in the WHERE clause represents the job title of the employees.", "virtual_table": "SELECT count(*) ,  city FROM employees WHERE title  =  [PLACEHOLDER-TYPE:STRING] GROUP BY city"}
{"sample_id": "train.587", "db_id": "store_1", "question": "What is the title, phone and hire date of Nancy Edwards?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Select the columns to display: 'title', 'phone', and 'hire_date'.", "Add conditions to filter the 'first_name' and 'last_name' columns for the specified employee using placeholders for string values."], "gold_sql": "SELECT title ,  phone ,  hire_date FROM employees WHERE first_name = 'Nancy' AND last_name = 'Edwards';", "source_tables": ["employees"], "description": "This virtual table describes the titles, phone numbers, and hire dates of employees from the 'employees' table who have a specific first and last name. The placeholders in the WHERE clause represent the first and last names of the employee.", "virtual_table": "SELECT title ,  phone ,  hire_date FROM employees WHERE first_name = [PLACEHOLDER-TYPE:STRING] AND last_name = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.567", "db_id": "store_1", "question": "List the number of invoices and the invoice total from California.", "rationale": ["The query identifies the relevant table, which is 'invoices'.", "It selects the 'billing_state' column, counts the number of invoices, and sums the total amount for those invoices.", "A condition is added to filter the results based on the specified billing state using a placeholder for string values."], "gold_sql": "SELECT billing_state ,  COUNT(*) ,  SUM(total) FROM invoices WHERE billing_state  =  'CA';", "source_tables": ["invoices"], "description": "This virtual table summarizes the total number of invoices and the total amount billed for a specific billing state from the 'invoices' table. The placeholder in the WHERE clause represents the billing state being queried.", "virtual_table": "SELECT billing_state ,  COUNT(*) ,  SUM(total) FROM invoices WHERE billing_state  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.594", "db_id": "store_1", "question": "What is the full name of the employee who has the most customers?", "rationale": ["The query identifies the relevant tables, which are 'employees' and 'customers'.", "It selects the 'first_name' and 'last_name' columns from the 'employees' table, aliased as T1.", "A JOIN operation is performed between 'employees' and 'customers' on the condition that the employee's ID matches the support representative ID in the customers table.", "The results are grouped by the employee's ID to aggregate the number of customers they support.", "The results are ordered by the count of customers in descending order to show the most supported employees first.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employees", "customers"], "description": "This virtual table provides the first and last names of employees who serve as support representatives for customers. The results are grouped by the employee's unique identifier and ordered by the number of customers they support in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of employees to return.", "virtual_table": "SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.606", "db_id": "store_1", "question": "What are the first and last names of all the employees and how many people report to them?", "rationale": ["The query identifies the relevant table, which is 'employees', and uses an alias to differentiate between managers (T2) and employees (T1).", "It selects the first and last names of the managers (T2.first_name, T2.last_name) and counts the number of employees reporting to each manager (count(T1.reports_to)).", "The JOIN operation connects employees to their respective managers using the reports_to field.", "The results are grouped by the manager's ID (T1.reports_to) to aggregate the count of employees for each manager.", "The results are ordered by the count of reports in descending order to show the managers with the most reports first.", "A limit is applied to restrict the number of results returned based on a specified number."], "gold_sql": "SELECT T2.first_name , T2.last_name ,  count(T1.reports_to) FROM employees AS T1 JOIN employees AS T2 ON T1.reports_to = T2.id GROUP BY T1.reports_to ORDER BY count(T1.reports_to) DESC LIMIT 1;", "source_tables": ["employees"], "description": "This virtual table provides a summary of employees and their managers from the 'employees' table. It lists the first and last names of managers along with the count of employees reporting to each manager. The results are grouped by the manager's identifier and ordered by the number of reports in descending order, with a limit on the number of results returned based on a specified number.", "virtual_table": "SELECT T2.first_name , T2.last_name ,  count(T1.reports_to) FROM employees AS T1 JOIN employees AS T2 ON T1.reports_to = T2.id GROUP BY T1.reports_to ORDER BY count(T1.reports_to) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
