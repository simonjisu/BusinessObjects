{"sample_id": "train.2380", "db_id": "csu_1", "question": "How many faculty lines are there in the university that conferred the most number of degrees in year 2002?", "rationale": ["The query identifies the relevant tables: 'campuses', 'faculty', and 'degrees'.", "It selects the 'faculty' column from the 'faculty' table.", "The query joins the 'campuses' table with the 'faculty' table on the campus identifier to link faculty data to the correct campus.", "It also joins the 'degrees' table to order the results based on the number of degrees awarded.", "A condition is added to filter the results by a specific year using a placeholder for numeric values.", "The results are ordered by the number of degrees in descending order and limited to a specified number of results using placeholders."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2002 ORDER BY t3.degrees DESC LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "description": "This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to ensure that the faculty data corresponds to the correct campus and also joins the 'degrees' table to order the results based on the number of degrees awarded in descending order. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the year and the number of results to return.", "virtual_table": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2351", "db_id": "csu_1", "question": "What campus has the most faculties in 2003?", "rationale": ["The query identifies the relevant tables, 'Campuses' and 'faculty'.", "It selects the 'campus' column from the 'Campuses' table.", "A JOIN operation is performed between 'Campuses' and 'faculty' on the campus identifier to combine data from both tables.", "A condition is added to filter the results based on the specified year using a placeholder for numeric values.", "The results are ordered by the number of faculty members in descending order and limited to a specified number using placeholders."], "gold_sql": "SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  2003 ORDER BY T2.faculty DESC LIMIT 1", "source_tables": ["faculty", "campuses"], "description": "This virtual table lists the names of campuses from the 'Campuses' table that have faculty data for a specific year. The results are ordered by the number of faculty members in descending order, and the number of campuses returned is limited by a placeholder value.", "virtual_table": "SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY T2.faculty DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2348", "db_id": "csu_1", "question": "Which campus has the most degrees conferred in all times?", "rationale": ["The query identifies the relevant table, which is 'degrees'.", "It selects the 'campus' column to display the campuses where degrees were awarded.", "The results are grouped by 'campus' to aggregate the data for each campus.", "The ordering is done based on the sum of degrees awarded, in descending order, to highlight the campuses with the most degrees.", "A limit is applied to restrict the number of campuses returned, using a placeholder for numeric values."], "gold_sql": "SELECT campus FROM degrees GROUP BY campus ORDER BY sum(degrees) DESC LIMIT 1", "source_tables": ["degrees"], "description": "This virtual table provides a list of campuses from the 'degrees' table, grouped by campus name and ordered by the total number of degrees awarded in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of campuses to return.", "virtual_table": "SELECT campus FROM degrees GROUP BY campus ORDER BY sum(degrees) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2327", "db_id": "csu_1", "question": "What campuses are located in Chico?", "rationale": ["The query is identifying the relevant table, which is 'Campuses'.", "Select the column to display, 'Campus'.", "Add a condition to filter the 'Location' column for the specified location using a placeholder for string values."], "gold_sql": "SELECT campus FROM campuses WHERE LOCATION  =  'Chico'", "source_tables": ["campuses"], "description": "This virtual table describes the campuses from the 'Campuses' table that are located in a specific geographical location. The placeholder in the WHERE clause represents the location of interest.", "virtual_table": "SELECT campus FROM campuses WHERE LOCATION  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2347", "db_id": "csu_1", "question": "In what year was the most degrees conferred?", "rationale": ["The query identifies the relevant table, which is 'degrees'.", "It selects the 'Year' column to display the years when degrees were awarded.", "The results are grouped by 'Year' to aggregate the data.", "The ordering is done based on the sum of degrees awarded in descending order to show the most significant years first.", "The LIMIT clause uses a placeholder to specify how many years to return."], "gold_sql": "SELECT YEAR FROM degrees GROUP BY YEAR ORDER BY sum(degrees) DESC LIMIT 1", "source_tables": ["degrees"], "description": "This virtual table summarizes the years in which degrees were awarded, grouped by year and ordered by the total number of degrees awarded in descending order. The placeholder in the LIMIT clause represents the maximum number of years to return.", "virtual_table": "SELECT YEAR FROM degrees GROUP BY YEAR ORDER BY sum(degrees) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2325", "db_id": "csu_1", "question": "What campuses are located in the county of Los Angeles?", "rationale": ["The query is identifying the relevant table, which is 'Campuses'.", "Select the column to display, 'campus'.", "Add a condition to filter the 'county' column for the specified county using a placeholder for string values."], "gold_sql": "SELECT campus FROM campuses WHERE county  =  'Los Angeles'", "source_tables": ["campuses"], "description": "This virtual table describes the campuses located in a specific county from the 'Campuses' table. The placeholder in the WHERE clause represents the name of the county.", "virtual_table": "SELECT campus FROM campuses WHERE county  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2369", "db_id": "csu_1", "question": "How many degrees were conferred at San Jose State University in 2000?", "rationale": ["The query identifies the relevant tables, 'Campuses' and 'degrees'.", "It selects the 'Degrees' column from the 'degrees' table.", "A JOIN operation is performed to link 'Campuses' and 'degrees' based on the campus identifier.", "Conditions are added to filter results for a specific campus and year using placeholders for string and numeric values."], "gold_sql": "SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  'San Jose State University' AND t2.year  =  2000", "source_tables": ["degrees", "campuses"], "description": "This virtual table describes the types of degrees awarded at a specific campus during a particular year. The placeholders in the WHERE clause represent the campus name and the year of the degrees awarded.", "virtual_table": "SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  [PLACEHOLDER-TYPE:STRING] AND t2.year  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2365", "db_id": "csu_1", "question": "How many campuses exist are in the county of LA?", "rationale": ["The query identifies the relevant table, which is 'Campuses'.", "It selects a count of all records to determine the number of campuses.", "A condition is added to filter the results based on the 'county' column using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM campuses WHERE county  =  'Los Angeles'", "source_tables": ["campuses"], "description": "This virtual table provides the total count of campuses located in a specific county from the 'Campuses' table. The placeholder in the WHERE clause represents the name of the county.", "virtual_table": "SELECT count(*) FROM campuses WHERE county  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2367", "db_id": "csu_1", "question": "What campuses are in Los Angeles county?", "rationale": ["The query is identifying the relevant table, which is 'Campuses'.", "Select the column to display, 'Campus'.", "Add a condition to filter the 'County' column for the specified county using a placeholder for string values."], "gold_sql": "SELECT campus FROM campuses WHERE county  =  'Los Angeles'", "source_tables": ["campuses"], "description": "This virtual table describes the names of campuses from the 'Campuses' table that are located in a specific county. The placeholder in the WHERE clause represents the name of the county.", "virtual_table": "SELECT campus FROM campuses WHERE county  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2387", "db_id": "csu_1", "question": "How many people graduated from San Francisco State University in 2004?", "rationale": ["The query identifies the relevant tables, 'discipline_enrollments' and 'campuses'.", "It uses a JOIN operation to connect the two tables based on the campus identifier.", "The SUM function is applied to the 'graduate' column to calculate the total number of graduate enrollments.", "Conditions are added to filter the results by the specified year and campus name using placeholders for numeric and string values."], "gold_sql": "SELECT sum(t1.graduate) FROM discipline_enrollments AS t1 JOIN campuses AS t2 ON t1.campus  =  t2.id WHERE t1.year  =  2004 AND t2.campus  =  'San Francisco State University'", "source_tables": ["discipline_enrollments", "campuses"], "description": "This virtual table calculates the total number of graduate enrollments from the 'discipline_enrollments' table for a specific campus and year. The placeholders in the WHERE clause represent the year of enrollment and the name of the campus.", "virtual_table": "SELECT sum(t1.graduate) FROM discipline_enrollments AS t1 JOIN campuses AS t2 ON t1.campus  =  t2.id WHERE t1.year  =  [PLACEHOLDER-TYPE:NUMBER] AND t2.campus  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6981", "db_id": "culture_company", "question": "Which publishers did not publish a book in 1989?", "rationale": ["The query identifies the relevant table, which is 'book_club'.", "It selects the 'publisher' column to display.", "The EXCEPT clause is used to exclude publishers from the results based on a specific year, using a placeholder for numeric values."], "gold_sql": "SELECT publisher FROM book_club EXCEPT SELECT publisher FROM book_club WHERE YEAR  =  1989", "source_tables": ["book_club"], "description": "This virtual table lists the publishers of books discussed in the 'book_club' table, excluding those publishers whose books were published in a specific year. The placeholder in the WHERE clause represents the year to be excluded.", "virtual_table": "SELECT publisher FROM book_club EXCEPT SELECT publisher FROM book_club WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6972", "db_id": "culture_company", "question": "What is the publisher with most number of books?", "rationale": ["The query identifies the relevant table, which is 'book_club'.", "It selects the 'publisher' column to display.", "The results are grouped by the 'publisher' to aggregate the data.", "The results are ordered by the count of books associated with each publisher in descending order.", "A limit is applied to restrict the number of publishers returned, using a placeholder for numeric values."], "gold_sql": "SELECT publisher FROM book_club GROUP BY publisher ORDER BY count(*) DESC LIMIT 1", "source_tables": ["book_club"], "description": "This virtual table provides a list of publishers from the 'book_club' table, grouped by the publisher's name. The results are ordered by the number of books published by each publisher in descending order, with a limit on the number of publishers returned based on a specified number.", "virtual_table": "SELECT publisher FROM book_club GROUP BY publisher ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6995", "db_id": "culture_company", "question": "What are all the company names that have a book published by Alyson?", "rationale": ["The query identifies the relevant tables, which are 'culture_company' and 'book_club'.", "It selects the 'company_name' column from the 'culture_company' table.", "A JOIN operation is performed to link 'culture_company' with 'book_club' using the foreign key 'book_club_id'.", "A condition is added to filter the results based on the 'publisher' column from the 'book_club' table, using a placeholder for string values."], "gold_sql": "SELECT T1.company_name FROM culture_company AS T1 JOIN book_club AS T2 ON T1.book_club_id  =  T2.book_club_id WHERE T2.publisher  =  'Alyson'", "source_tables": ["culture_company", "book_club"], "description": "This virtual table describes the names of cultural companies associated with book club entries from the 'book_club' table, filtered by a specific publisher. The placeholder in the WHERE clause represents the publisher's name.", "virtual_table": "SELECT T1.company_name FROM culture_company AS T1 JOIN book_club AS T2 ON T1.book_club_id  =  T2.book_club_id WHERE T2.publisher  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6994", "db_id": "culture_company", "question": "List all company names with a book published by Alyson.", "rationale": ["The query identifies the relevant tables, which are 'culture_company' and 'book_club'.", "It selects the 'company_name' column from the 'culture_company' table.", "A JOIN operation is performed between 'culture_company' and 'book_club' on the 'book_club_id' to link the two tables.", "A condition is added to filter the results based on the 'publisher' column from the 'book_club' table using a placeholder for string values."], "gold_sql": "SELECT T1.company_name FROM culture_company AS T1 JOIN book_club AS T2 ON T1.book_club_id  =  T2.book_club_id WHERE T2.publisher  =  'Alyson'", "source_tables": ["culture_company", "book_club"], "description": "This virtual table describes the names of cultural companies associated with book clubs that have a specific publisher. The placeholder in the WHERE clause represents the name of the publisher.", "virtual_table": "SELECT T1.company_name FROM culture_company AS T1 JOIN book_club AS T2 ON T1.book_club_id  =  T2.book_club_id WHERE T2.publisher  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5779", "db_id": "customer_complaints", "question": "Return the names of products that have had complaints filed by the customer who has filed the fewest complaints.", "rationale": ["The query identifies the relevant tables: 'Products', 'Complaints', and 'Customers'.", "It selects distinct product names from the 'Products' table.", "The query joins the 'Products' table with the 'Complaints' table on the product identifier to link complaints to products.", "It groups the results by customer identifier to aggregate the data based on the number of complaints per customer.", "The ORDER BY clause is used to sort the results based on the count of complaints, and the LIMIT clause specifies the maximum number of results to return using a placeholder for numeric values."], "gold_sql": "SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "products", "customers"], "description": "The virtual table describes the distinct product names from the 'Products' table that are associated with complaints made by customers. It joins the 'Products' table with the 'Complaints' table based on the product identifier and groups the results by customer identifier to count the number of complaints per customer. The placeholder in the LIMIT clause represents the maximum number of distinct product names to return.", "virtual_table": "SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5772", "db_id": "customer_complaints", "question": "Which city has the least number of customers whose type code is \"Good Credit Rating\"?", "rationale": ["The query identifies the relevant table, which is 'Customers'.", "Select the column to display, 'town_city'.", "Add a condition to filter the 'customer_type_code' column for the specified customer type using a placeholder for string values.", "Group the results by 'town_city' to ensure unique entries.", "Order the results by the count of occurrences to prioritize the most common towns or cities.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT town_city FROM customers WHERE customer_type_code  =  'Good Credit Rating' GROUP BY town_city ORDER BY count(*) LIMIT 1", "source_tables": ["customers"], "description": "This virtual table provides a list of unique town or city names from the 'Customers' table, filtered by a specific customer type code. The results are grouped by town or city and ordered by the count of occurrences, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the customer type code and the maximum number of results to display.", "virtual_table": "SELECT town_city FROM customers WHERE customer_type_code  =  [PLACEHOLDER-TYPE:STRING] GROUP BY town_city ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5776", "db_id": "customer_complaints", "question": "Find the emails of customers who has filed a complaints of the product with the most complaints.", "rationale": ["The query identifies the relevant tables, which are 'Customers' and 'Complaints'.", "It selects the 'email_address' from the 'Customers' table, aliased as 't1'.", "A JOIN operation is performed between 'Customers' and 'Complaints' on the 'customer_id' to link customers with their complaints.", "The results are grouped by 'customer_id' to ensure unique email addresses are returned for each customer.", "The results are ordered by the count of complaints to prioritize customers with more complaints.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "customers"], "description": "This virtual table provides a list of email addresses of customers who have made complaints, grouped by customer ID. The results are ordered by the number of complaints each customer has made, and the number of results returned can be limited using a placeholder for numeric values.", "virtual_table": "SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5813", "db_id": "customer_complaints", "question": "Give the state that has the most customers.", "rationale": ["The query identifies the relevant table, which is 'Customers'.", "It selects the 'state' column to display the states of the customers.", "The results are grouped by 'state' to aggregate customer counts per state.", "The results are ordered by the count of customers in each state to prioritize states with more customers.", "The LIMIT clause uses a placeholder to allow the user to specify how many states to return."], "gold_sql": "SELECT state FROM customers GROUP BY state ORDER BY count(*) LIMIT 1", "source_tables": ["customers"], "description": "This virtual table summarizes the states where customers reside, grouping the results by state and ordering them by the number of customers in each state. The placeholder in the LIMIT clause allows for specifying the maximum number of states to return.", "virtual_table": "SELECT state FROM customers GROUP BY state ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5800", "db_id": "customer_complaints", "question": "How many customers are there in the customer type with the most customers?", "rationale": ["The query identifies the relevant table, which is 'Customers'.", "It uses the COUNT function to count the number of customers for each type, grouping the results by 'customer_type_code'.", "The results are ordered in descending order based on the count of customers, allowing the most common customer types to appear first.", "A LIMIT clause is included to restrict the number of results returned, with a placeholder for the user to specify the desired number."], "gold_sql": "SELECT count(*) FROM customers GROUP BY customer_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers"], "description": "This virtual table provides a count of customers grouped by their type, allowing for an analysis of the distribution of different customer types. The placeholder in the LIMIT clause represents the maximum number of customer types to display, enabling users to specify how many top customer types they wish to see.", "virtual_table": "SELECT count(*) FROM customers GROUP BY customer_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5812", "db_id": "customer_complaints", "question": "Which state has the most customers?", "rationale": ["The query identifies the relevant table, which is 'Customers'.", "It selects the 'state' column to display the states of customers.", "The results are grouped by 'state' to aggregate customer counts per state.", "The results are ordered by the count of customers in each state to prioritize states with more customers.", "The LIMIT clause uses a placeholder to allow the user to specify how many states to return."], "gold_sql": "SELECT state FROM customers GROUP BY state ORDER BY count(*) LIMIT 1", "source_tables": ["customers"], "description": "This virtual table summarizes the states where customers reside, grouping the results by state and ordering them by the number of customers in each state. The placeholder in the LIMIT clause allows for specifying the maximum number of states to return.", "virtual_table": "SELECT state FROM customers GROUP BY state ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5802", "db_id": "customer_complaints", "question": "What is the last name of the staff who has handled the first ever complaint?", "rationale": ["The query identifies the relevant tables, which are 'staff' and 'complaints'.", "It selects the 'last_name' column from the 'staff' table.", "A JOIN operation is performed between 'staff' and 'complaints' on the 'staff_id' to link staff members to the complaints they are handling.", "The results are ordered by the 'date_complaint_raised' from the 'complaints' table to show the most recent complaints first.", "The LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id ORDER BY t2.date_complaint_raised LIMIT 1", "source_tables": ["complaints", "staff"], "description": "This virtual table provides the last names of staff members who are handling complaints, ordered by the date the complaints were raised. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.", "virtual_table": "SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id ORDER BY t2.date_complaint_raised LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5794", "db_id": "customer_complaints", "question": "Find the last name of the staff member who processed the complaint of the cheapest product.", "rationale": ["The query identifies the relevant tables: 'staff', 'complaints', and 'products'.", "It selects the 'last_name' column from the 'staff' table.", "The query joins the 'staff' table with the 'complaints' table on the 'staff_id' to link staff members to the complaints they handle.", "It further joins the 'complaints' table with the 'products' table on the 'product_id' to associate complaints with the respective products.", "The results are ordered by the 'product_price' from the 'products' table, ensuring that the staff names are listed according to the price of the products involved in the complaints.", "The LIMIT clause uses a placeholder for a numeric value to allow users to specify how many results they want."], "gold_sql": "SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT 1", "source_tables": ["complaints", "products", "staff"], "description": "This virtual table provides a list of last names of staff members who are handling complaints related to products, ordered by the price of those products. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.", "virtual_table": "SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2857", "db_id": "customer_deliveries", "question": "List the state names and the number of customers living in each state.", "rationale": ["The query identifies the relevant tables, which are 'Customer_Addresses' and 'Addresses'.", "It selects the 'state_province_county' column from the 'Addresses' table and counts the number of occurrences.", "A JOIN operation is performed between 'Customer_Addresses' and 'Addresses' on the 'address_id' to link customer addresses with their corresponding details.", "The results are grouped by 'state_province_county' to provide a count for each unique state, province, or county."], "gold_sql": "SELECT t2.state_province_county ,  count(*) FROM customer_addresses AS t1 JOIN addresses AS t2 ON t1.address_id  =  t2.address_id GROUP BY t2.state_province_county", "source_tables": ["addresses", "customer_addresses"], "description": "This virtual table summarizes the count of customer addresses grouped by state, province, or county from the 'Customer_Addresses' and 'Addresses' tables. The placeholder in the SELECT statement represents the state, province, or county being counted.", "virtual_table": "SELECT t2.state_province_county ,  count(*) FROM customer_addresses AS t1 JOIN addresses AS t2 ON t1.address_id  =  t2.address_id GROUP BY t2.state_province_county"}
{"sample_id": "train.2843", "db_id": "customer_deliveries", "question": "Find the name and price of the product that has been ordered the greatest number of times.", "rationale": ["The query identifies the relevant tables, 'Products' and 'Regular_Order_Products'.", "It selects the columns 'product_name' and 'product_price' from the 'Products' table.", "A JOIN operation is performed between 'Products' and 'Regular_Order_Products' on the product ID to link products with their orders.", "The results are grouped by 'product_id' to count the occurrences of each product in the orders.", "The results are ordered by the count of orders in descending order to highlight the most frequently ordered products.", "A LIMIT clause is added to restrict the number of results returned based on a placeholder for numeric values."], "gold_sql": "SELECT t1.product_name ,   t1.product_price FROM products AS t1 JOIN regular_order_products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t2.product_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["regular_order_products", "products"], "description": "The virtual table provides a list of product names and their prices from the 'Products' table, specifically focusing on products that are part of regular orders. The results are grouped by product ID to aggregate the data, ordered by the frequency of orders in descending order, and limited to a specified number of top products.", "virtual_table": "SELECT t1.product_name ,   t1.product_price FROM products AS t1 JOIN regular_order_products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t2.product_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2854", "db_id": "customer_deliveries", "question": "Find the payment method that is used most frequently.", "rationale": ["The query identifies the relevant table, which is 'Customers'.", "It selects the 'payment_method' column to display the preferred payment methods.", "The results are grouped by 'payment_method' to aggregate the data.", "The results are ordered by the count of each payment method in descending order to show the most popular methods first.", "A limit is applied to restrict the number of payment methods returned, using a placeholder for numeric values."], "gold_sql": "SELECT payment_method FROM Customers GROUP BY payment_method ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers"], "description": "This virtual table summarizes the preferred payment methods of customers from the 'Customers' table. It groups the results by payment method and orders them by the frequency of each method, allowing the user to specify a limit on the number of payment methods returned.", "virtual_table": "SELECT payment_method FROM Customers GROUP BY payment_method ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2853", "db_id": "customer_deliveries", "question": "Find the name of the first 5 customers.", "rationale": ["The query identifies the relevant table, which is 'Customers'.", "Select the column to display, 'customer_name'.", "Order the results by 'date_became_customer' to show the most recent customers first.", "Use a placeholder in the LIMIT clause to allow the user to specify how many customer names to retrieve."], "gold_sql": "SELECT customer_name FROM Customers ORDER BY date_became_customer LIMIT 5", "source_tables": ["customers"], "description": "This virtual table provides a list of customer names from the 'Customers' table, ordered by the date they became customers. The placeholder in the LIMIT clause allows for specifying the maximum number of customer names to retrieve.", "virtual_table": "SELECT customer_name FROM Customers ORDER BY date_became_customer LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6106", "db_id": "customers_and_addresses", "question": "What are the name and active date of the customers whose contact channel code is email?", "rationale": ["The query identifies the relevant tables, which are 'Customers' and 'Customer_Contact_Channels'.", "It selects the 'customer_name' from the 'Customers' table and 'active_from_date' from the 'Customer_Contact_Channels' table.", "A JOIN operation is performed on the 'customer_id' to link the two tables based on the customer identifier.", "A condition is added to filter the results based on the 'channel_code' using a placeholder for string values."], "gold_sql": "SELECT t1.customer_name ,  t2.active_from_date FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t2.channel_code  =  'Email'", "source_tables": ["customer_contact_channels", "customers"], "description": "This virtual table provides the names of customers along with the activation dates of their preferred contact channels. The data is sourced from the 'Customers' table and the 'Customer_Contact_Channels' table, linked by the customer identifier. The placeholder in the WHERE clause represents the specific contact channel code being queried.", "virtual_table": "SELECT t1.customer_name ,  t2.active_from_date FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t2.channel_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6105", "db_id": "customers_and_addresses", "question": "Find the name and active date of the customer that use email as the contact channel.", "rationale": ["The query identifies the relevant tables, which are 'Customers' and 'Customer_Contact_Channels'.", "It selects the 'customer_name' from the 'Customers' table and 'active_from_date' from the 'Customer_Contact_Channels' table.", "A JOIN operation is performed on the 'customer_id' to link the two tables based on the customer identifier.", "A condition is added to filter the results based on the 'channel_code' using a placeholder for string values."], "gold_sql": "SELECT t1.customer_name ,  t2.active_from_date FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t2.channel_code  =  'Email'", "source_tables": ["customer_contact_channels", "customers"], "description": "This virtual table provides the names of customers along with the activation dates of their preferred contact channels. The data is sourced from the 'Customers' table and the 'Customer_Contact_Channels' table, linked by the customer identifier. The placeholder in the WHERE clause represents the specific contact channel code being queried.", "virtual_table": "SELECT t1.customer_name ,  t2.active_from_date FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t2.channel_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6104", "db_id": "customers_and_addresses", "question": "Return the channel code and contact number of the customer contact channel whose active duration was the longest.", "rationale": ["The query identifies the relevant table, which is 'Customer_Contact_Channels'.", "Select the columns to display, 'channel_code' and 'contact_number'.", "Add a condition to filter the results based on the active duration of the contact channels, using a subquery to find the maximum active duration and a placeholder for the number of records to limit the results."], "gold_sql": "SELECT channel_code ,  contact_number FROM customer_contact_channels WHERE active_to_date - active_from_date  =  (SELECT active_to_date - active_from_date FROM customer_contact_channels ORDER BY (active_to_date - active_from_date) DESC LIMIT 1)", "source_tables": ["customer_contact_channels"], "description": "This virtual table provides the channel codes and contact numbers of customer contact channels that have the longest active duration. The placeholder in the LIMIT clause allows for specifying the number of records to retrieve based on the longest active duration.", "virtual_table": "SELECT channel_code ,  contact_number FROM customer_contact_channels WHERE active_to_date - active_from_date  =  (SELECT active_to_date - active_from_date FROM customer_contact_channels ORDER BY (active_to_date - active_from_date) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.6134", "db_id": "customers_and_addresses", "question": "What are all the addresses in East Julianaside, Texas or in Gleasonmouth, Arizona.", "rationale": ["The query identifies the relevant table, which is 'Addresses'.", "It selects the 'address_content' column to display the detailed description of the addresses.", "The query includes two separate conditions to filter the results based on the specified city and state, using placeholders for string values.", "The UNION operator is used to combine the results of two queries that have the same structure."], "gold_sql": "SELECT address_content FROM addresses WHERE city  =  'East Julianaside' AND state_province_county  =  'Texas' UNION SELECT address_content FROM addresses WHERE city  =  'Gleasonmouth' AND state_province_county  =  'Arizona'", "source_tables": ["addresses"], "description": "This virtual table retrieves the detailed address content from the 'Addresses' table for specific cities and states, allowing for the combination of results from two different queries based on the same criteria. The placeholders in the WHERE clauses represent the city and state names.", "virtual_table": "SELECT address_content FROM addresses WHERE city  =  [PLACEHOLDER-TYPE:STRING] AND state_province_county  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT address_content FROM addresses WHERE city  =  [PLACEHOLDER-TYPE:STRING] AND state_province_county  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6129", "db_id": "customers_and_addresses", "question": "Which product has been ordered most number of times?", "rationale": ["The query identifies the relevant tables, 'Order_Items' and 'Products'.", "It selects the 'product_details' from the 'Products' table.", "The join condition links 'Order_Items' and 'Products' on 'product_id'.", "The results are grouped by 'product_id' to aggregate the order quantities.", "The results are ordered by the count of orders in descending order to show the most ordered products first.", "A placeholder is included in the LIMIT clause to allow the user to specify how many product details to return."], "gold_sql": "SELECT t2.product_details FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["products", "order_items"], "description": "This virtual table provides a list of product details from the 'Products' table based on the quantity of each product ordered. The query joins the 'Order_Items' table with the 'Products' table to retrieve the product specifications, grouping the results by product ID and ordering them by the count of orders in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of product details to return.", "virtual_table": "SELECT t2.product_details FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6065", "db_id": "customers_and_addresses", "question": "Which payment method is used by most customers?", "rationale": ["The query identifies the relevant table, which is 'Customers'.", "It selects the 'payment_method' column to display the preferred payment methods.", "The results are grouped by 'payment_method' to aggregate the data.", "The query orders the results by the count of each payment method in descending order to show the most popular methods first.", "A limit is applied to restrict the number of payment methods returned, using a placeholder for numeric values."], "gold_sql": "SELECT payment_method FROM customers GROUP BY payment_method ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers"], "description": "This virtual table summarizes the preferred payment methods used by customers from the 'Customers' table. It groups the results by payment method and orders them by the frequency of each method, allowing the user to specify a limit on the number of payment methods returned.", "virtual_table": "SELECT payment_method FROM customers GROUP BY payment_method ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6098", "db_id": "customers_and_addresses", "question": "Find the contact channel code that was used by the customer named \"Tillman Ernser\".", "rationale": ["The query identifies the relevant tables, which are 'Customers' and 'Customer_Contact_Channels'.", "It selects distinct values from the 'channel_code' column to avoid duplicates.", "The JOIN operation links the two tables using the 'customer_id' to ensure that the contact channels correspond to the correct customer.", "A condition is added to filter the results based on the specified customer's name using a placeholder for string values."], "gold_sql": "SELECT DISTINCT channel_code FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  'Tillman Ernser'", "source_tables": ["customer_contact_channels", "customers"], "description": "This virtual table provides a distinct list of contact channels used by customers from the 'Customers' table based on their name. The placeholder in the WHERE clause represents the specific customer's name.", "virtual_table": "SELECT DISTINCT channel_code FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6066", "db_id": "customers_and_addresses", "question": "Find the payment method that is used most frequently.", "rationale": ["The query identifies the relevant table, which is 'Customers'.", "It selects the 'payment_method' column to display the preferred payment methods.", "The results are grouped by 'payment_method' to aggregate the data.", "The query orders the results by the count of each payment method in descending order to show the most popular methods first.", "A limit is applied to restrict the number of payment methods returned, using a placeholder for numeric values."], "gold_sql": "SELECT payment_method FROM customers GROUP BY payment_method ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers"], "description": "This virtual table summarizes the preferred payment methods used by customers from the 'Customers' table. It groups the results by payment method and orders them by the frequency of each method, allowing the user to specify a limit on the number of payment methods returned.", "virtual_table": "SELECT payment_method FROM customers GROUP BY payment_method ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6099", "db_id": "customers_and_addresses", "question": "What is the \"active to date\" of the latest contact channel used by \"Tillman Ernser\"?", "rationale": ["The query identifies the relevant tables, which are 'Customers' and 'Customer_Contact_Channels'.", "It selects the maximum value of 'active_to_date' from 'Customer_Contact_Channels' to find the most recent deactivation date.", "A JOIN operation is performed on 'customer_id' to link the two tables based on the customer.", "A condition is added to filter the results based on the specified customer's name using a placeholder for string values."], "gold_sql": "SELECT max(t2.active_to_date) FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  'Tillman Ernser'", "source_tables": ["customer_contact_channels", "customers"], "description": "This virtual table retrieves the most recent deactivation date of a contact channel for a specific customer from the 'Customers' and 'Customer_Contact_Channels' tables. The placeholder in the WHERE clause represents the customer's name.", "virtual_table": "SELECT max(t2.active_to_date) FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6072", "db_id": "customers_and_addresses", "question": "Return the the details of all products.", "rationale": ["The query is identifying the relevant table, which is 'Products'.", "Select the column to display, 'product_details'.", "Use DISTINCT to ensure that only unique product specifications are returned."], "gold_sql": "SELECT DISTINCT product_details FROM products", "source_tables": ["products"], "description": "This virtual table provides a unique list of product specifications from the 'Products' table. The placeholder in the SELECT clause represents the product details that can be filtered or modified as needed.", "virtual_table": "SELECT DISTINCT product_details FROM products"}
{"sample_id": "train.6059", "db_id": "customers_and_addresses", "question": "What is the average amount of items ordered in each order?", "rationale": ["The query identifies the relevant table, which is 'Order_Items'.", "It selects the average of the 'order_quantity' column to determine the typical quantity of products ordered."], "gold_sql": "SELECT avg(order_quantity) FROM order_items", "source_tables": ["order_items"], "description": "This virtual table calculates the average quantity of products ordered from the 'Order_Items' table. The result provides insights into the typical order size for products.", "virtual_table": "SELECT avg(order_quantity) FROM order_items"}
{"sample_id": "train.6102", "db_id": "customers_and_addresses", "question": "Compute the average active time span of contact channels.", "rationale": ["The query identifies the relevant table, which is 'Customer_Contact_Channels'.", "It calculates the average duration of active contact channels by subtracting 'active_from_date' from 'active_to_date'.", "The result is aggregated using the AVG function to provide the average duration of active contact channels."], "gold_sql": "SELECT avg(active_to_date - active_from_date) FROM customer_contact_channels", "source_tables": ["customer_contact_channels"], "description": "This virtual table calculates the average duration that contact channels remain active for customers in the 'Customer_Contact_Channels' table. The placeholder in the SELECT clause represents the calculation of the difference between the active dates.", "virtual_table": "SELECT avg(active_to_date - active_from_date) FROM customer_contact_channels"}
{"sample_id": "train.6127", "db_id": "customers_and_addresses", "question": "Who made the latest order?", "rationale": ["The query identifies the relevant tables, which are 'Customers' and 'Customer_Orders'.", "It selects the 'customer_name' column from the 'Customers' table.", "A JOIN operation is performed to link 'Customers' with 'Customer_Orders' based on the 'customer_id'.", "The results are ordered by 'order_date' in descending order to show the most recent orders first.", "The LIMIT clause uses a placeholder to allow the user to specify how many customer names to return."], "gold_sql": "SELECT t1.customer_name FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id ORDER BY t2.order_date DESC LIMIT 1", "source_tables": ["customer_orders", "customers"], "description": "This virtual table provides a list of customer names from the 'Customers' table who have placed orders, sorted by the most recent order date. The placeholder in the LIMIT clause allows for specifying the maximum number of customer names to retrieve.", "virtual_table": "SELECT t1.customer_name FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id ORDER BY t2.order_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1590", "db_id": "customers_and_invoices", "question": "Return the names and ids of each account, as well as the number of transactions.", "rationale": ["The query identifies the relevant tables, which are 'Financial_Transactions' and 'Accounts'.", "It selects the 'account_name' from the 'Accounts' table and 'account_id' from the 'Financial_Transactions' table.", "The count function is used to aggregate the number of transactions for each account.", "A JOIN operation is performed on the 'account_id' to link transactions to their respective accounts.", "Finally, the results are grouped by 'account_id' to provide a count of transactions per account."], "gold_sql": "SELECT T2.account_name ,  T1.account_id ,  count(*) FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id GROUP BY T1.account_id", "source_tables": ["accounts", "financial_transactions"], "description": "This virtual table summarizes the total number of financial transactions associated with each account. It displays the account name and account ID from the 'Accounts' table, along with a count of transactions from the 'Financial_Transactions' table, grouped by account ID.", "virtual_table": "SELECT T2.account_name ,  T1.account_id ,  count(*) FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id GROUP BY T1.account_id"}
{"sample_id": "train.1570", "db_id": "customers_and_invoices", "question": "What are the the full names and ids for all customers, and how many accounts does each have?", "rationale": ["The query identifies the relevant tables, 'Accounts' and 'Customers'.", "It selects the 'customer_id', 'customer_first_name', and 'customer_last_name' from the 'Customers' table.", "It counts the number of accounts for each customer using the COUNT function.", "The JOIN operation links the 'Accounts' table with the 'Customers' table based on the 'customer_id'.", "The GROUP BY clause groups the results by 'customer_id' to aggregate the account counts for each customer."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id", "source_tables": ["accounts", "customers"], "description": "This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, last name, and the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.", "virtual_table": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id"}
{"sample_id": "train.1569", "db_id": "customers_and_invoices", "question": "Show id, first name and last name for all customers and the number of accounts.", "rationale": ["The query identifies the relevant tables, 'Accounts' and 'Customers'.", "It selects the 'customer_id', 'customer_first_name', and 'customer_last_name' from the 'Customers' table.", "It counts the number of accounts for each customer using the COUNT function.", "The JOIN operation links the 'Accounts' table with the 'Customers' table based on the 'customer_id'.", "The GROUP BY clause groups the results by 'customer_id' to aggregate the account counts for each customer."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id", "source_tables": ["accounts", "customers"], "description": "This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, and last name, along with the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.", "virtual_table": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id"}
{"sample_id": "train.1610", "db_id": "customers_and_invoices", "question": "Return the order ids and details for orderes with two or more invoices.", "rationale": ["The query identifies the relevant tables, which are 'Invoices' and 'Orders'.", "It selects the columns 'order_id' and 'order_details' from the 'Orders' table.", "A JOIN operation is performed between 'Invoices' and 'Orders' on the 'order_id' to link the two tables.", "The results are grouped by 'order_id' to aggregate the data.", "The HAVING clause filters the results to include only those orders that have more than a specified number of associated invoices, using a placeholder for the numeric value."], "gold_sql": "SELECT T2.order_id ,  T2.order_details FROM Invoices AS T1 JOIN Orders AS T2 ON T1.order_id  =  T2.order_id GROUP BY T2.order_id HAVING count(*)  >  2", "source_tables": ["orders", "invoices"], "description": "This virtual table provides a list of order IDs and their corresponding details from the 'Orders' table, specifically for those orders that are associated with invoices. The results are grouped by order ID, and only those orders that have more than a specified number of associated invoices are included. The placeholder in the HAVING clause represents the minimum count of invoices required for an order to be displayed.", "virtual_table": "SELECT T2.order_id ,  T2.order_details FROM Invoices AS T1 JOIN Orders AS T2 ON T1.order_id  =  T2.order_id GROUP BY T2.order_id HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1623", "db_id": "customers_and_invoices", "question": "Show order ids and the number of products in each order.", "rationale": ["The query identifies the relevant table, which is 'Order_Items'.", "It selects the 'order_id' to group the results by each order.", "The count function is used to count the distinct 'product_id' for each order, ensuring that only unique products are counted."], "gold_sql": "SELECT order_id ,  count(DISTINCT product_id) FROM Order_items GROUP BY order_id", "source_tables": ["order_items"], "description": "This virtual table summarizes the total number of distinct products associated with each order from the 'Order_Items' table. The placeholder in the SELECT clause represents the order identifier, while the count function calculates the unique product count for each order.", "virtual_table": "SELECT order_id ,  count(DISTINCT product_id) FROM Order_items GROUP BY order_id"}
{"sample_id": "train.1607", "db_id": "customers_and_invoices", "question": "Show the order ids and the number of invoices for each order.", "rationale": ["The query identifies the relevant table, which is 'Invoices'.", "It selects the 'order_id' to group the results by each order.", "The count function is used to calculate the total number of invoices for each order, and the results are grouped by 'order_id' to provide a summary for each unique order."], "gold_sql": "SELECT order_id ,  count(*) FROM Invoices GROUP BY order_id", "source_tables": ["invoices"], "description": "This virtual table summarizes the total number of invoices associated with each order from the 'Invoices' table. The placeholder in the SELECT clause represents the unique identifier for each order, while the count function aggregates the number of invoices per order.", "virtual_table": "SELECT order_id ,  count(*) FROM Invoices GROUP BY order_id"}
{"sample_id": "train.1621", "db_id": "customers_and_invoices", "question": "Show all product names and the number of customers having an order on each product.", "rationale": ["The query identifies the relevant tables: 'Order_Items', 'Products', and 'Orders'.", "It selects the 'product_name' from the 'Products' table and counts the occurrences of each product ordered.", "The JOIN operations link 'Order_Items' to 'Products' using 'product_id' and to 'Orders' using 'order_id'.", "The GROUP BY clause groups the results by 'product_name' to aggregate the count of ordered items for each product."], "gold_sql": "SELECT T2.product_name ,  count(*) FROM Order_items AS T1 JOIN Products AS T2 ON T1.product_id  =  T2.product_id JOIN Orders AS T3 ON T3.order_id  =  T1.order_id GROUP BY T2.product_name", "source_tables": ["orders", "products", "order_items"], "description": "This virtual table summarizes the total quantity of each product ordered from the 'Products' table by joining it with the 'Order_Items' and 'Orders' tables. The placeholder in the SELECT statement represents the product name, and the count function aggregates the total number of items ordered for each product.", "virtual_table": "SELECT T2.product_name ,  count(*) FROM Order_items AS T1 JOIN Products AS T2 ON T1.product_id  =  T2.product_id JOIN Orders AS T3 ON T3.order_id  =  T1.order_id GROUP BY T2.product_name"}
{"sample_id": "train.1622", "db_id": "customers_and_invoices", "question": "What are teh names of the different products, as well as the number of customers who have ordered each product.", "rationale": ["The query identifies the relevant tables: 'Order_Items', 'Products', and 'Orders'.", "It selects the 'product_name' from the 'Products' table and counts the occurrences of each product ordered.", "The JOIN operations link 'Order_Items' to 'Products' using 'product_id' and to 'Orders' using 'order_id'.", "The GROUP BY clause groups the results by 'product_name' to provide a count for each distinct product."], "gold_sql": "SELECT T2.product_name ,  count(*) FROM Order_items AS T1 JOIN Products AS T2 ON T1.product_id  =  T2.product_id JOIN Orders AS T3 ON T3.order_id  =  T1.order_id GROUP BY T2.product_name", "source_tables": ["orders", "products", "order_items"], "description": "This virtual table summarizes the total quantity of each product ordered from the 'Products' table by joining it with the 'Order_Items' and 'Orders' tables. The placeholder in the SELECT statement represents the product name, and the count function aggregates the total number of items ordered for each product.", "virtual_table": "SELECT T2.product_name ,  count(*) FROM Order_items AS T1 JOIN Products AS T2 ON T1.product_id  =  T2.product_id JOIN Orders AS T3 ON T3.order_id  =  T1.order_id GROUP BY T2.product_name"}
{"sample_id": "train.1549", "db_id": "customers_and_invoices", "question": "How many customers have opened an account?", "rationale": ["The query is identifying the relevant table, which is 'Accounts'.", "The goal is to count the distinct 'customer_id' values to determine the number of unique customers with accounts.", "Using the COUNT function with DISTINCT ensures that only unique customer IDs are counted."], "gold_sql": "SELECT count(DISTINCT customer_id) FROM Accounts", "source_tables": ["accounts"], "description": "This virtual table provides the count of unique customers who have opened accounts in the 'Accounts' table. The placeholder in the SELECT statement allows for potential filtering or additional conditions to be applied if needed.", "virtual_table": "SELECT count(DISTINCT customer_id) FROM Accounts"}
{"sample_id": "train.1580", "db_id": "customers_and_invoices", "question": "Count the number of financial transactions that correspond to each account id.", "rationale": ["The query identifies the relevant table, which is 'Financial_Transactions'.", "It selects a count of all transactions and groups them by 'account_id'.", "The use of count(*) allows for the aggregation of transaction records per account, providing a summary of transactions associated with each account."], "gold_sql": "SELECT count(*) ,  account_id FROM Financial_transactions", "source_tables": ["financial_transactions"], "description": "This virtual table provides a count of financial transactions grouped by account ID from the 'Financial_Transactions' table. The placeholder in the SELECT clause represents the account ID for which the transaction count is being retrieved.", "virtual_table": "SELECT count(*) ,  account_id FROM Financial_transactions"}
{"sample_id": "train.727", "db_id": "customers_card_transactions", "question": "Show the customer ids and firstname without a credit card.", "rationale": ["The query identifies the relevant table, which is 'Customers', to select customer IDs and first names.", "It uses the EXCEPT clause to exclude customers who have a specific card type.", "The subquery joins 'Customers_cards' and 'Customers' to find customers with the specified card type, using a placeholder for the card type code."], "gold_sql": "SELECT customer_id ,  customer_first_name FROM Customers EXCEPT SELECT T1.customer_id ,  T2.customer_first_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE card_type_code  =  'Credit'", "source_tables": ["customers", "customers_cards"], "description": "This virtual table provides a list of customer IDs and their first names from the 'Customers' table, excluding those customers who have a specific type of card. The placeholder in the EXCEPT clause represents the card type code that is used to filter out customers who possess that card type.", "virtual_table": "SELECT customer_id ,  customer_first_name FROM Customers EXCEPT SELECT T1.customer_id ,  T2.customer_first_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE card_type_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.716", "db_id": "customers_card_transactions", "question": "What are the ids and full names of customers who hold two or more cards?", "rationale": ["The query identifies the relevant tables, 'Customers_cards' and 'Customers'.", "It selects the 'customer_id', 'customer_first_name', and 'customer_last_name' columns to display.", "A JOIN operation is performed on 'customer_id' to link the two tables together.", "The results are grouped by 'customer_id' to aggregate the data based on each customer.", "The HAVING clause is used to filter the results to only include customers with a specified minimum number of cards, using a placeholder for numeric values."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id HAVING count(*)  >=  2", "source_tables": ["customers", "customers_cards"], "description": "This virtual table provides a list of customer IDs along with their first and last names from the 'Customers' table, specifically for customers who have a certain number of cards associated with them. The placeholder in the HAVING clause represents the minimum count of cards a customer must have to be included in the results.", "virtual_table": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.682", "db_id": "customers_card_transactions", "question": "Give the full name and customer id of the customer with the fewest accounts.", "rationale": ["The query identifies the relevant tables, 'Accounts' and 'Customers', and uses a JOIN to combine them based on the 'customer_id'.", "It selects the 'customer_first_name' and 'customer_last_name' from the 'Customers' table and the 'customer_id' from the 'Accounts' table.", "The results are grouped by 'customer_id' to aggregate the data for each customer.", "The results are ordered by the count of accounts associated with each customer in ascending order.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T2.customer_first_name ,  T2.customer_last_name ,  T1.customer_id FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) ASC LIMIT 1", "source_tables": ["accounts", "customers"], "description": "This virtual table provides a list of customer first and last names along with their associated customer IDs from the 'Accounts' and 'Customers' tables. The data is grouped by customer ID and ordered by the count of accounts associated with each customer in ascending order, with a limit on the number of results returned as specified by the placeholder.", "virtual_table": "SELECT T2.customer_first_name ,  T2.customer_last_name ,  T1.customer_id FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.728", "db_id": "customers_card_transactions", "question": "What are the ids and first names of customers who do not hold a credit card?", "rationale": ["The query identifies the relevant table, which is 'Customers', to select customer IDs and first names.", "It uses the EXCEPT clause to exclude customers who have a specific card type.", "The subquery joins 'Customers_cards' and 'Customers' to find customers with the specified card type, using a placeholder for the card type code."], "gold_sql": "SELECT customer_id ,  customer_first_name FROM Customers EXCEPT SELECT T1.customer_id ,  T2.customer_first_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE card_type_code  =  'Credit'", "source_tables": ["customers", "customers_cards"], "description": "This virtual table provides a list of customer IDs and their first names from the 'Customers' table, excluding those customers who have a specific type of card. The placeholder in the EXCEPT clause represents the card type code that is used to filter out customers who possess that card type.", "virtual_table": "SELECT customer_id ,  customer_first_name FROM Customers EXCEPT SELECT T1.customer_id ,  T2.customer_first_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE card_type_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.694", "db_id": "customers_card_transactions", "question": "What are the ids, full names, and phones of each customer?", "rationale": ["The query identifies the relevant table, which is 'Customers'.", "Select the columns to display: 'customer_id', 'customer_first_name', 'customer_last_name', and 'customer_phone'.", "No filtering conditions are applied, allowing for a broad selection of customer information."], "gold_sql": "SELECT customer_id ,  customer_first_name ,  customer_last_name ,  customer_phone FROM Customers", "source_tables": ["customers"], "description": "This virtual table describes the customer ID, first name, last name, and phone number of customers from the 'Customers' table. The placeholders represent the specific values that can be filtered or modified as needed.", "virtual_table": "SELECT customer_id ,  customer_first_name ,  customer_last_name ,  customer_phone FROM Customers"}
{"sample_id": "train.722", "db_id": "customers_card_transactions", "question": "Return the code of the card type that is most common.", "rationale": ["The query identifies the relevant table, which is 'Customers_Cards'.", "It selects the 'card_type_code' to show the different types of cards.", "The results are grouped by 'card_type_code' to aggregate the counts of each type.", "The results are ordered by the count of each card type in descending order to show the most common types first.", "A placeholder is included to allow the user to specify the limit on the number of card types returned."], "gold_sql": "SELECT card_type_code FROM Customers_cards GROUP BY card_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers_cards"], "description": "The virtual table summarizes the different types of cards issued to customers, displaying the card type codes from the 'Customers_Cards' table. The results are grouped by card type code and ordered by the frequency of each type, allowing the user to specify a limit on the number of types returned.", "virtual_table": "SELECT card_type_code FROM Customers_cards GROUP BY card_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.677", "db_id": "customers_card_transactions", "question": "Show all customer ids and the number of accounts for each customer.", "rationale": ["The query identifies the relevant table, which is 'Accounts'.", "Select the 'customer_id' column to group the results by customer.", "Use the count function to calculate the total number of accounts for each customer, grouping the results by 'customer_id'."], "gold_sql": "SELECT customer_id ,  count(*) FROM Accounts GROUP BY customer_id", "source_tables": ["accounts"], "description": "This virtual table summarizes the number of accounts associated with each customer from the 'Accounts' table. The placeholder in the SELECT clause represents the customer identifier, and the count function aggregates the total number of accounts per customer.", "virtual_table": "SELECT customer_id ,  count(*) FROM Accounts GROUP BY customer_id"}
{"sample_id": "train.745", "db_id": "customers_card_transactions", "question": "Show the account id and the number of transactions for each account", "rationale": ["The query identifies the relevant table, which is 'Financial_Transactions'.", "Select the 'account_id' to display along with a count of transactions.", "Use the GROUP BY clause to aggregate the results by 'account_id', allowing us to see the number of transactions for each account."], "gold_sql": "SELECT account_id ,  count(*) FROM Financial_transactions GROUP BY account_id", "source_tables": ["financial_transactions"], "description": "This virtual table summarizes the number of transactions associated with each account from the 'Financial_Transactions' table. The placeholder in the SELECT clause represents the account identifier, while the count function aggregates the total number of transactions for each account.", "virtual_table": "SELECT account_id ,  count(*) FROM Financial_transactions GROUP BY account_id"}
{"sample_id": "train.707", "db_id": "customers_card_transactions", "question": "How many debit cards do we have?", "rationale": ["The query identifies the relevant table, which is 'Customers_Cards'.", "It selects a count of all records that meet the specified condition.", "A condition is added to filter the 'card_type_code' column for the specified card type using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM Customers_cards WHERE card_type_code  =  'Debit'", "source_tables": ["customers_cards"], "description": "This virtual table provides the count of customer cards from the 'Customers_Cards' table that match a specific card type. The placeholder in the WHERE clause represents the card type code being queried.", "virtual_table": "SELECT count(*) FROM Customers_cards WHERE card_type_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.729", "db_id": "customers_card_transactions", "question": "Show all card type codes.", "rationale": ["The query is identifying the relevant table, which is 'Customers_Cards'.", "Select the column to display, 'card_type_code', ensuring that only unique values are retrieved using DISTINCT."], "gold_sql": "SELECT DISTINCT card_type_code FROM Customers_Cards", "source_tables": ["customers_cards"], "description": "This virtual table provides a list of unique card type codes from the 'Customers_Cards' table. The placeholder in the SELECT statement allows for the retrieval of distinct card types without any filtering conditions.", "virtual_table": "SELECT DISTINCT card_type_code FROM Customers_Cards"}
{"sample_id": "train.4740", "db_id": "department_store", "question": "What are the ids and names of department stores with both marketing and managing departments?", "rationale": ["The query identifies the relevant tables, which are 'departments' and 'department_stores'.", "It selects the 'dept_store_id' and 'store_name' columns from the 'department_stores' table.", "The JOIN operation connects 'departments' to 'department_stores' based on the 'dept_store_id'.", "The WHERE clause filters the results based on the specified department names using placeholders for string values.", "The INTERSECT operation is used to find department stores that are associated with both specified departments."], "gold_sql": "SELECT T2.dept_store_id ,  T2.store_name FROM departments AS T1 JOIN department_stores AS T2 ON T1.dept_store_id  =  T2.dept_store_id WHERE T1.department_name  =  'marketing' INTERSECT SELECT T2.dept_store_id ,  T2.store_name FROM departments AS T1 JOIN department_stores AS T2 ON T1.dept_store_id  =  T2.dept_store_id WHERE T1.department_name  =  'managing'", "source_tables": ["departments", "department_stores"], "description": "This virtual table describes the department store IDs and names from the 'Department_Stores' table that have two specific departments, as indicated by the department names provided in the placeholders. The query uses an INTERSECT operation to find common department stores associated with both specified departments.", "virtual_table": "SELECT T2.dept_store_id ,  T2.store_name FROM departments AS T1 JOIN department_stores AS T2 ON T1.dept_store_id  =  T2.dept_store_id WHERE T1.department_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.dept_store_id ,  T2.store_name FROM departments AS T1 JOIN department_stores AS T2 ON T1.dept_store_id  =  T2.dept_store_id WHERE T1.department_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4739", "db_id": "department_store", "question": "What is the id and name of the department store that has both marketing and managing department?", "rationale": ["The query identifies the relevant tables, which are 'departments' and 'department_stores'.", "It selects the 'dept_store_id' and 'store_name' columns from the 'department_stores' table.", "The JOIN operation links the 'departments' table to the 'department_stores' table based on the 'dept_store_id'.", "The WHERE clause filters the results based on the specified department names using placeholders for string values.", "The INTERSECT operation is used to find department stores that are associated with both specified departments."], "gold_sql": "SELECT T2.dept_store_id ,  T2.store_name FROM departments AS T1 JOIN department_stores AS T2 ON T1.dept_store_id  =  T2.dept_store_id WHERE T1.department_name  =  'marketing' INTERSECT SELECT T2.dept_store_id ,  T2.store_name FROM departments AS T1 JOIN department_stores AS T2 ON T1.dept_store_id  =  T2.dept_store_id WHERE T1.department_name  =  'managing'", "source_tables": ["departments", "department_stores"], "description": "This virtual table describes the department store IDs and names from the 'Department_Stores' table that have two specific departments, as indicated by the department names provided in the placeholders. The query uses an INTERSECT operation to find common department stores associated with both specified departments.", "virtual_table": "SELECT T2.dept_store_id ,  T2.store_name FROM departments AS T1 JOIN department_stores AS T2 ON T1.dept_store_id  =  T2.dept_store_id WHERE T1.department_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.dept_store_id ,  T2.store_name FROM departments AS T1 JOIN department_stores AS T2 ON T1.dept_store_id  =  T2.dept_store_id WHERE T1.department_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4791", "db_id": "department_store", "question": "Find the id and name of customers whose address contains WY state and do not use credit card for payment.", "rationale": ["The query identifies the relevant table, which is 'Customers'.", "Select the columns to display, 'customer_id' and 'customer_name'.", "Add conditions to filter the 'customer_address' using a LIKE clause for a specific pattern and exclude customers with a certain 'payment_method_code' using a NOT EQUAL condition with a placeholder for string values."], "gold_sql": "SELECT customer_id ,  customer_name FROM customers WHERE customer_address LIKE '%WY%' AND payment_method_code != 'Credit Card'", "source_tables": ["customers"], "description": "This virtual table describes the unique identifiers and names of customers from the 'Customers' table who have a specific address pattern and do not use a certain payment method. The placeholders in the WHERE clause represent the address pattern and the payment method code.", "virtual_table": "SELECT customer_id ,  customer_name FROM customers WHERE customer_address LIKE [PLACEHOLDER-TYPE:STRING] AND payment_method_code != [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4735", "db_id": "department_store", "question": "Find the name and address of the customers who have both New and Pending orders.", "rationale": ["The query identifies the relevant tables, which are 'Customers' and 'Customer_Orders'.", "It selects the columns to display, 'customer_name' and 'customer_address'.", "The query uses a JOIN to connect the 'Customers' table with the 'Customer_Orders' table based on the 'customer_id'.", "It adds a condition to filter the results based on the 'order_status_code' using placeholders for string values.", "The INTERSECT operator is used to find common results between two queries with the same structure, both filtering by order status code."], "gold_sql": "SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  'New' INTERSECT SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  'Pending'", "source_tables": ["customer_orders", "customers"], "description": "This virtual table describes the names and addresses of customers who have placed orders with a specific status. The query retrieves customer information from the 'Customers' table and filters it based on the order status from the 'Customer_Orders' table. The placeholders in the WHERE clause represent the order status codes that can be specified by the user.", "virtual_table": "SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4756", "db_id": "department_store", "question": "Return the id of the staff whose Staff Department Assignment was earlier than that of any Clerical Staff.", "rationale": ["The query identifies the relevant table, which is 'Staff_Department_Assignments'.", "It selects the 'staff_id' column to display the unique identifiers of staff members.", "A condition is added to filter the results based on the 'date_assigned_to' column, ensuring it is less than the maximum 'date_assigned_to' for a specific 'job_title_code'.", "The subquery retrieves the maximum assignment end date for the specified job title using a placeholder for string values."], "gold_sql": "SELECT staff_id FROM Staff_Department_Assignments WHERE date_assigned_to  <  (SELECT max(date_assigned_to) FROM Staff_Department_Assignments WHERE job_title_code  =  'Clerical Staff')", "source_tables": ["staff_department_assignments"], "description": "This virtual table lists the unique identifiers of staff members who were assigned to a department and whose assignment ended before the most recent assignment date for a specific job title. The placeholder in the subquery represents the job title code to filter the results accordingly.", "virtual_table": "SELECT staff_id FROM Staff_Department_Assignments WHERE date_assigned_to  <  (SELECT max(date_assigned_to) FROM Staff_Department_Assignments WHERE job_title_code  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.4754", "db_id": "department_store", "question": "What are the distinct ids of customers who made an order after any order that was Cancelled?", "rationale": ["The query identifies the relevant table, which is 'Customer_Orders'.", "It selects distinct customer IDs to ensure each customer is listed only once.", "A condition is added to filter orders based on the order date, which must be greater than the minimum order date for a specified order status, using a subquery and a placeholder for the order status code."], "gold_sql": "SELECT DISTINCT customer_id FROM Customer_Orders WHERE order_date  >  (SELECT min(order_date) FROM Customer_Orders WHERE order_status_code  =  'Cancelled')", "source_tables": ["customer_orders"], "description": "This virtual table provides a list of unique customer identifiers from the 'Customer_Orders' table for orders placed after a specific date. The date is determined by finding the earliest order date associated with a particular order status, represented by a placeholder.", "virtual_table": "SELECT DISTINCT customer_id FROM Customer_Orders WHERE order_date  >  (SELECT min(order_date) FROM Customer_Orders WHERE order_status_code  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.4717", "db_id": "department_store", "question": "What are the staff ids and genders of all staffs whose job title is Department Manager?", "rationale": ["The query identifies the relevant tables, which are 'Staff' and 'Staff_Department_Assignments'.", "It selects the columns to display, 'staff_id' and 'staff_gender'.", "A JOIN operation is performed to link 'Staff' with 'Staff_Department_Assignments' based on the 'staff_id'.", "A condition is added to filter the results based on the 'job_title_code' using a placeholder for string values."], "gold_sql": "SELECT T1.staff_id ,  T1.staff_gender FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.job_title_code  =  'Department Manager'", "source_tables": ["staff_department_assignments", "staff"], "description": "This virtual table describes the staff members' IDs and genders from the 'Staff' table who are assigned to a specific job title. The placeholder in the WHERE clause represents the job title code.", "virtual_table": "SELECT T1.staff_id ,  T1.staff_gender FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.job_title_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4759", "db_id": "department_store", "question": "Return the name and gender of the staff who was assigned in 2016.", "rationale": ["The query identifies the relevant tables, which are 'Staff' and 'Staff_Department_Assignments'.", "It selects the columns to display, 'staff_name' and 'staff_gender'.", "A JOIN operation is performed between 'Staff' and 'Staff_Department_Assignments' on the 'staff_id' to link staff members with their department assignments.", "A condition is added to filter the results based on the 'date_assigned_from' column using a placeholder for string values."], "gold_sql": "SELECT T1.staff_name ,  T1.staff_gender FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.date_assigned_from LIKE '2016%'", "source_tables": ["staff_department_assignments", "staff"], "description": "This virtual table describes the names and genders of staff members from the 'Staff' table who have been assigned to a department starting from a specific date. The placeholder in the WHERE clause represents the date of assignment.", "virtual_table": "SELECT T1.staff_name ,  T1.staff_gender FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.date_assigned_from LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4730", "db_id": "department_store", "question": "Return the name and job title of the staff with the latest date assigned.", "rationale": ["The query identifies the relevant tables, which are 'Staff' and 'Staff_Department_Assignments'.", "It selects the 'staff_name' from the 'Staff' table and 'job_title_code' from the 'Staff_Department_Assignments' table.", "A JOIN operation is performed on the 'staff_id' to combine data from both tables.", "The results are ordered by 'date_assigned_to' in descending order to show the most recent assignments first.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.staff_name ,  T2.job_title_code FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY T2.date_assigned_to DESC LIMIT 1", "source_tables": ["staff_department_assignments", "staff"], "description": "This virtual table provides a list of staff members along with their job titles from the 'Staff' and 'Staff_Department_Assignments' tables. The results are ordered by the end date of their assignments, allowing users to see the most recently assigned staff members first. The placeholder in the LIMIT clause represents the maximum number of records to return.", "virtual_table": "SELECT T1.staff_name ,  T2.job_title_code FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY T2.date_assigned_to DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4794", "db_id": "department_store", "question": "What is the average price of clothes?", "rationale": ["The query identifies the relevant table, which is 'Products'.", "It selects the average of the 'product_price' column to compute the average price.", "A condition is added to filter the 'product_type_code' column for the specified product type using a placeholder for string values."], "gold_sql": "SELECT avg(product_price) FROM products WHERE product_type_code  =  'Clothes'", "source_tables": ["products"], "description": "This virtual table calculates the average price of products from the 'Products' table that belong to a specific product type. The placeholder in the WHERE clause represents the product type code.", "virtual_table": "SELECT avg(product_price) FROM products WHERE product_type_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4709", "db_id": "department_store", "question": "What are the ids of the top three products that were purchased in the largest amount?", "rationale": ["The query identifies the relevant table, which is 'Product_Suppliers'.", "Select the column to display, 'product_id'.", "Order the results by 'total_amount_purchased' in descending order to get the most purchased products first.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT product_id FROM product_suppliers ORDER BY total_amount_purchased DESC LIMIT 3", "source_tables": ["product_suppliers"], "description": "The virtual table lists the product IDs from the 'Product_Suppliers' table, ordered by the total amount purchased in descending order. The placeholder in the LIMIT clause allows the user to specify the number of top products to retrieve based on their purchase quantity.", "virtual_table": "SELECT product_id FROM product_suppliers ORDER BY total_amount_purchased DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4729", "db_id": "department_store", "question": "What is the name and job title of the staff who was assigned the latest?", "rationale": ["The query identifies the relevant tables, which are 'Staff' and 'Staff_Department_Assignments'.", "It selects the 'staff_name' from the 'Staff' table and 'job_title_code' from the 'Staff_Department_Assignments' table.", "A JOIN operation is performed on the 'staff_id' to combine data from both tables.", "The results are ordered by 'date_assigned_to' in descending order to show the most recent assignments first.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.staff_name ,  T2.job_title_code FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY T2.date_assigned_to DESC LIMIT 1", "source_tables": ["staff_department_assignments", "staff"], "description": "This virtual table provides a list of staff members along with their job titles from the 'Staff' and 'Staff_Department_Assignments' tables. The results are ordered by the end date of their assignments, allowing users to see the most recently assigned staff members first. The placeholder in the LIMIT clause represents the maximum number of records to return.", "virtual_table": "SELECT T1.staff_name ,  T2.job_title_code FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY T2.date_assigned_to DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4521", "db_id": "document_management", "question": "List all the username and passwords of users with the most popular role.", "rationale": ["The query identifies the relevant table, which is 'Users'.", "Selects the columns to display, 'user_name' and 'password'.", "Groups the results by 'role_code' to aggregate users under their respective roles.", "Orders the results by the count of users in each role in descending order to show the most populated roles first.", "Limits the number of results returned based on a specified numeric placeholder."], "gold_sql": "SELECT user_name ,  password FROM users GROUP BY role_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["users"], "description": "This virtual table provides a list of user names and their corresponding passwords from the 'Users' table, grouped by their role codes. The results are ordered by the number of users in each role, showing the most populated roles first, with a limit on the number of results returned as specified by the placeholder.", "virtual_table": "SELECT user_name ,  password FROM users GROUP BY role_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4522", "db_id": "document_management", "question": "What are the usernames and passwords of users that have the most common role?", "rationale": ["The query identifies the relevant table, which is 'Users'.", "It selects the columns 'user_name' and 'password' to display.", "The results are grouped by 'role_code' to aggregate users by their roles.", "The results are ordered by the count of users in each role in descending order.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT user_name ,  password FROM users GROUP BY role_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["users"], "description": "This virtual table provides a list of user names and their corresponding passwords from the 'Users' table, grouped by their role codes. The results are ordered by the number of users in each role, showing the top roles based on user count, with a limit specified by a placeholder for numeric values.", "virtual_table": "SELECT user_name ,  password FROM users GROUP BY role_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4535", "db_id": "document_management", "question": "Find the average access count of documents with the least popular structure.", "rationale": ["The query identifies the relevant table, which is 'Documents'.", "It calculates the average of the 'access_count' column.", "The results are grouped by 'document_structure_code' to aggregate the access counts for each structure.", "The results are ordered in ascending order based on the count of documents in each group.", "A placeholder is included in the LIMIT clause to allow the user to specify how many groups to return."], "gold_sql": "SELECT avg(access_count) FROM documents GROUP BY document_structure_code ORDER BY count(*) ASC LIMIT 1", "source_tables": ["documents"], "description": "This virtual table calculates the average access count of documents grouped by their document structure code. The placeholder in the LIMIT clause allows the user to specify the maximum number of groups to return, based on the ascending order of their count.", "virtual_table": "SELECT avg(access_count) FROM documents GROUP BY document_structure_code ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4509", "db_id": "document_management", "question": "What is the structure of the document with the least number of accesses?", "rationale": ["The query identifies the relevant tables, 'Documents' and 'Document_Structures'.", "It selects the 'document_structure_description' from the 'Document_Structures' table.", "A JOIN operation is performed on the 'document_structure_code' to link documents with their respective structures.", "The results are grouped by 'document_structure_code' to aggregate the data based on the structure.", "The results are ordered by the count of documents associated with each structure in descending order.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT t2.document_structure_description FROM documents AS t1 JOIN document_structures AS t2 ON t1.document_structure_code  =  t2.document_structure_code GROUP BY t1.document_structure_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["document_structures", "documents"], "description": "This virtual table provides a list of document structure descriptions from the 'Document_Structures' table, which are associated with documents in the 'Documents' table. The results are grouped by the document structure code and ordered by the number of documents associated with each structure, limited to a specified number of results.", "virtual_table": "SELECT t2.document_structure_description FROM documents AS t1 JOIN document_structures AS t2 ON t1.document_structure_code  =  t2.document_structure_code GROUP BY t1.document_structure_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4531", "db_id": "document_management", "question": "How many users are logged in?", "rationale": ["The query is identifying the relevant table, which is 'Users'.", "The count function is used to determine the number of records that match the specified condition.", "Add a condition to filter the 'user_login' column for the specified username using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM users WHERE user_login  =  1", "source_tables": ["users"], "description": "This virtual table counts the number of users from the 'Users' table based on a specific login username. The placeholder in the WHERE clause represents the user's login name.", "virtual_table": "SELECT count(*) FROM users WHERE user_login  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4526", "db_id": "document_management", "question": "What are the names of documents that do not have any images?", "rationale": ["The query identifies the relevant table, which is 'Documents'.", "It selects the 'document_name' column to display the names of the documents.", "The EXCEPT clause is used to filter out document names that are associated with sections containing images by joining 'Documents', 'Document_Sections', and 'Document_Sections_Images' on their respective keys."], "gold_sql": "SELECT document_name FROM documents EXCEPT SELECT t1.document_name FROM documents AS t1 JOIN document_sections AS t2 ON t1.document_code  =  t2.document_code JOIN document_sections_images AS t3 ON t2.section_id  =  t3.section_id", "source_tables": ["document_sections", "document_sections_images", "documents"], "description": "This virtual table lists the names of documents from the 'Documents' table that do not have any associated images in their sections. The query uses an EXCEPT clause to exclude document names that are linked to sections containing images.", "virtual_table": "SELECT document_name FROM documents EXCEPT SELECT t1.document_name FROM documents AS t1 JOIN document_sections AS t2 ON t1.document_code  =  t2.document_code JOIN document_sections_images AS t3 ON t2.section_id  =  t3.section_id"}
{"sample_id": "dev.936", "db_id": "dog_kennels", "question": "Which owner has paid for the most treatments on his or her dogs? List the owner id and last name.", "rationale": ["The query identifies the relevant tables: 'Owners', 'Dogs', and 'Treatments'.", "It selects the 'owner_id' and 'last_name' from the 'Owners' table, using an alias for clarity.", "The JOIN operation links 'Owners' to 'Dogs' based on the 'owner_id', and then links 'Dogs' to 'Treatments' based on 'dog_id'.", "The GROUP BY clause groups the results by 'owner_id' to aggregate the treatment counts for each owner.", "The ORDER BY clause sorts the results by the count of treatments in descending order, ensuring that owners with the most treatments appear first.", "The LIMIT clause uses a placeholder to allow the user to specify how many results they want to retrieve."], "gold_sql": "SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["owners", "dogs", "treatments"], "description": "This virtual table provides a list of owners along with their last names who have had dogs treated, sorted by the number of treatments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of owners to display.", "virtual_table": "SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.944", "db_id": "dog_kennels", "question": "What are the first name and last name of the professionals who have done treatment with cost below average?", "rationale": ["The query identifies the relevant tables, which are 'Professionals' and 'Treatments'.", "It selects distinct first and last names from the 'Professionals' table.", "A join is performed between 'Professionals' and 'Treatments' to link professionals with the treatments they administered.", "A condition is added to filter treatments where the cost is less than the average cost of treatments, calculated using a subquery."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T1.last_name FROM Professionals AS T1 JOIN Treatments AS T2 WHERE cost_of_treatment  <  ( SELECT avg(cost_of_treatment) FROM Treatments )", "source_tables": ["professionals", "treatments"], "description": "This virtual table provides a list of unique first and last names of professionals who have administered treatments that cost less than the average treatment cost. The query joins the 'Professionals' table with the 'Treatments' table to filter based on the treatment cost, using a subquery to calculate the average cost of treatments.", "virtual_table": "SELECT DISTINCT T1.first_name ,  T1.last_name FROM Professionals AS T1 JOIN Treatments AS T2 WHERE cost_of_treatment  <  ( SELECT avg(cost_of_treatment) FROM Treatments )"}
{"sample_id": "dev.945", "db_id": "dog_kennels", "question": "Which professionals have operated a treatment that costs less than the average? Give me theor first names and last names.", "rationale": ["The query identifies the relevant tables, 'Professionals' and 'Treatments'.", "It selects distinct first and last names from the 'Professionals' table.", "A join is performed between 'Professionals' and 'Treatments' to link professionals with the treatments they administered.", "A condition is added to filter treatments based on their cost being less than the average cost of treatments, which is calculated using a subquery."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T1.last_name FROM Professionals AS T1 JOIN Treatments AS T2 WHERE cost_of_treatment  <  ( SELECT avg(cost_of_treatment) FROM Treatments )", "source_tables": ["professionals", "treatments"], "description": "This virtual table provides a list of unique first and last names of professionals who have administered treatments that cost less than the average cost of treatments recorded in the database. The placeholders in the query allow for dynamic filtering based on treatment costs.", "virtual_table": "SELECT DISTINCT T1.first_name ,  T1.last_name FROM Professionals AS T1 JOIN Treatments AS T2 WHERE cost_of_treatment  <  ( SELECT avg(cost_of_treatment) FROM Treatments )"}
{"sample_id": "dev.925", "db_id": "dog_kennels", "question": "What are the names of the dogs for which the owner has not spend more than 1000 for treatment ?", "rationale": ["The query identifies the relevant table, which is 'Dogs'.", "It selects the 'name' column to display the names of the dogs.", "The subquery filters out dogs that have received treatments by summing the 'cost_of_treatment' from the 'Treatments' table.", "The condition in the WHERE clause uses a placeholder for the maximum treatment cost to exclude dogs that exceed this amount."], "gold_sql": "select name from dogs where dog_id not in ( select dog_id from treatments group by dog_id having sum(cost_of_treatment)  >  1000 )", "source_tables": ["dogs", "treatments"], "description": "This virtual table lists the names of dogs from the 'Dogs' table that have not received treatments exceeding a specified total cost. The placeholder in the HAVING clause represents the maximum treatment cost threshold.", "virtual_table": "select name from dogs where dog_id not in ( select dog_id from treatments group by dog_id having sum(cost_of_treatment)  >  [PLACEHOLDER-TYPE:NUMBER] )"}
{"sample_id": "dev.951", "db_id": "dog_kennels", "question": "What are each owner's first name, last name, and the size of their dog?", "rationale": ["The query identifies the relevant tables, which are 'Owners' and 'Dogs'.", "It selects the columns 'first_name' and 'last_name' from the 'Owners' table (aliased as T1) and 'size_code' from the 'Dogs' table (aliased as T2).", "A JOIN operation is performed on the 'owner_id' to link the two tables, ensuring that the data corresponds to the same owner and their dog."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id", "source_tables": ["owners", "dogs"], "description": "This virtual table provides the first and last names of dog owners along with the size code of their dogs. It combines data from the 'Owners' table and the 'Dogs' table, linking them through the owner_id. The placeholders represent the relevant fields from each table.", "virtual_table": "SELECT T1.first_name ,  T1.last_name ,  T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id"}
{"sample_id": "dev.961", "db_id": "dog_kennels", "question": "Who owns the youngest dog? Give me his or her last name.", "rationale": ["The query identifies the relevant tables, which are 'Owners' and 'Dogs'.", "It selects the 'last_name' column from the 'Owners' table.", "A JOIN operation is performed between 'Owners' and 'Dogs' on the 'owner_id' to link owners to their dogs.", "A subquery is used to find the maximum age of dogs in the 'Dogs' table, which is then used to filter the results in the WHERE clause."], "gold_sql": "SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )", "source_tables": ["owners", "dogs"], "description": "This virtual table describes the last names of owners who own the oldest dog in the 'Dogs' table. The query joins the 'Owners' and 'Dogs' tables based on the owner ID and filters the results to find the maximum age of dogs, using a subquery to determine which dog is the oldest.", "virtual_table": "SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )"}
{"sample_id": "dev.920", "db_id": "dog_kennels", "question": "What is the average age of the dogs who have gone through any treatments?", "rationale": ["The query identifies the relevant table, which is 'Dogs'.", "It selects the average age of dogs from the 'Dogs' table.", "A subquery is used to filter the dogs that have treatment records in the 'Treatments' table, ensuring only those dogs are included in the average age calculation."], "gold_sql": "SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )", "source_tables": ["dogs", "treatments"], "description": "This virtual table calculates the average age of dogs that have received treatments. The placeholder in the WHERE clause represents the specific dog identifiers that have undergone treatments.", "virtual_table": "SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )"}
{"sample_id": "dev.996", "db_id": "dog_kennels", "question": "What are all the possible breed type and size type combinations?", "rationale": ["The query identifies the relevant table, which is 'Dogs'.", "It selects distinct values for 'breed_code' and 'size_code' to ensure that each combination is unique.", "The use of DISTINCT ensures that duplicate entries are not included in the results."], "gold_sql": "SELECT DISTINCT breed_code ,  size_code FROM dogs", "source_tables": ["dogs"], "description": "This virtual table provides a unique list of breed codes and size codes for dogs from the 'Dogs' table. The placeholders represent the breed and size categories associated with the dogs.", "virtual_table": "SELECT DISTINCT breed_code ,  size_code FROM dogs"}
{"sample_id": "dev.998", "db_id": "dog_kennels", "question": "List the first name of all the professionals along with the description of the treatment they have done.", "rationale": ["The query identifies the relevant tables: 'Professionals', 'Treatments', and 'Treatment_Types'.", "It selects the 'first_name' from the 'Professionals' table and 'treatment_type_description' from the 'Treatment_Types' table.", "The JOIN operations link the 'Treatments' table to both the 'Professionals' and 'Treatment_Types' tables based on their respective foreign keys.", "The DISTINCT keyword is used to ensure that only unique combinations of professional first names and treatment descriptions are returned."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code", "source_tables": ["professionals", "treatments", "treatment_types"], "description": "This virtual table provides a list of unique first names of professionals along with the descriptions of the treatment types they have administered. The data is sourced from the 'Professionals', 'Treatments', and 'Treatment_Types' tables, ensuring that only distinct combinations of professional names and treatment descriptions are displayed.", "virtual_table": "SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code"}
{"sample_id": "train.5729", "db_id": "dorm_1", "question": "What is the average age and how many male students are there in each city?", "rationale": ["The query identifies the relevant table, which is 'Student'.", "It selects the count of students and the average age, along with the city code.", "A condition is added to filter the results based on the 'Sex' column for the specified gender using a placeholder for string values.", "The results are grouped by 'city_code' to provide a summary for each city."], "gold_sql": "SELECT count(*) ,  avg(age) ,  city_code FROM student WHERE sex  =  'M' GROUP BY city_code", "source_tables": ["student"], "description": "This virtual table provides a summary of the number of students and their average age, grouped by the city code, for a specific gender. The placeholder in the WHERE clause represents the gender of the students being queried.", "virtual_table": "SELECT count(*) ,  avg(age) ,  city_code FROM student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] GROUP BY city_code"}
{"sample_id": "train.5739", "db_id": "dorm_1", "question": "For each dorm, how many amenities does it have?", "rationale": ["The query identifies the relevant tables, 'dorm' and 'has_amenity'.", "It selects the count of amenities and the dormitory ID from the 'dorm' table.", "A JOIN operation is performed between 'dorm' and 'has_amenity' on the dormitory ID to link dormitories with their amenities.", "A condition is added to filter dormitories based on their student capacity using a placeholder for numeric values.", "The results are grouped by the dormitory ID to provide a count of amenities for each qualifying dormitory."], "gold_sql": "SELECT count(*) ,  T1.dormid FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid WHERE T1.student_capacity  >  100 GROUP BY T1.dormid", "source_tables": ["has_amenity", "dorm"], "description": "This virtual table provides a count of amenities available in dormitories that can accommodate more than a specified number of students. The placeholder in the WHERE clause represents the minimum student capacity for filtering the dormitories.", "virtual_table": "SELECT count(*) ,  T1.dormid FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid WHERE T1.student_capacity  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.dormid"}
{"sample_id": "train.5699", "db_id": "dorm_1", "question": "What are the names and types of the dorms that have a capacity greater than 300 or less than 100?", "rationale": ["The query identifies the relevant table, which is 'Dorm'.", "Select the columns to display, 'dorm_name' and 'gender'.", "Add a condition to filter the 'student_capacity' column for values greater than or less than the specified number using placeholders for numeric values."], "gold_sql": "SELECT dorm_name ,  gender FROM dorm WHERE student_capacity  >  300 OR student_capacity  <  100", "source_tables": ["dorm"], "description": "This virtual table provides the names and gender designations of dormitories from the 'Dorm' table that have a student capacity exceeding or falling below a specified number. The placeholders in the WHERE clause represent the capacity limits for filtering the dormitories.", "virtual_table": "SELECT dorm_name ,  gender FROM dorm WHERE student_capacity  >  [PLACEHOLDER-TYPE:NUMBER] OR student_capacity  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5706", "db_id": "dorm_1", "question": "Find the last name of students who is either female (sex is F) and living in the city of code BAL or male (sex is M) and in age of below 20.", "rationale": ["The query identifies the relevant table, which is 'Student'.", "It selects the 'LName' column to display the last names of students.", "The first part of the query filters students by 'sex' and 'city_code' using placeholders for string values.", "The second part of the query filters students by 'sex' and 'age' using a placeholder for numeric values, and combines the results using UNION."], "gold_sql": "SELECT lname FROM student WHERE sex  =  'F' AND city_code  =  'BAL' UNION SELECT lname FROM student WHERE sex  =  'M' AND age  <  20", "source_tables": ["student"], "description": "This virtual table provides a list of last names of students from the 'Student' table based on specific criteria. It includes students of a certain gender residing in a specific city, as well as students of the same gender who are younger than a specified age. The placeholders in the WHERE clauses represent the gender, city code, and age criteria.", "virtual_table": "SELECT lname FROM student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND city_code  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT lname FROM student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND age  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5755", "db_id": "dorm_1", "question": "What is the most common amenity in the dorms?", "rationale": ["The query identifies the relevant tables, 'dorm_amenity' and 'has_amenity'.", "It selects the 'amenity_name' from the 'dorm_amenity' table, using an alias for clarity.", "A JOIN operation is performed between 'dorm_amenity' and 'has_amenity' on the 'amenid' to link amenities to dormitories.", "The results are grouped by 'amenid' to aggregate the amenities.", "The results are ordered by the count of occurrences in descending order to show the most common amenities first.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.amenity_name FROM dorm_amenity AS T1 JOIN has_amenity AS T2 ON T1.amenid  =  T2.amenid GROUP BY T2.amenid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["has_amenity", "dorm_amenity"], "description": "The virtual table lists the names of amenities available in dormitories, grouped by their identifiers and ordered by the count of occurrences in descending order. The placeholder in the LIMIT clause represents the maximum number of amenities to display.", "virtual_table": "SELECT T1.amenity_name FROM dorm_amenity AS T1 JOIN has_amenity AS T2 ON T1.amenid  =  T2.amenid GROUP BY T2.amenid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5757", "db_id": "dorm_1", "question": "What are the first names of all students who live in the dorm with the most amenities?", "rationale": ["The query identifies the relevant tables, which are 'Student', 'Lives_in', 'Dorm', 'Has_amenity', and 'Dorm_amenity'.", "It selects the 'fname' column from the 'Student' table.", "The query joins 'Student' with 'Lives_in' to link students to their respective dormitories.", "A subquery is used to find dormitories that have the most amenities by joining 'Dorm', 'Has_amenity', and 'Dorm_amenity', grouping by dormitory ID and ordering by the count of amenities.", "The outer query filters the dormitories based on the result of the subquery, limiting the number of dorms returned using a placeholder for numeric values."], "gold_sql": "SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["has_amenity", "lives_in", "student", "dorm_amenity", "dorm"], "description": "This virtual table describes the first names of students who reside in dormitories that have the most amenities. The query joins the 'Student' table with the 'Lives_in' table to find students living in specific dorms, and it filters those dorms based on the count of amenities they offer, limited by a specified number placeholder.", "virtual_table": "SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.5669", "db_id": "dorm_1", "question": "What are the names of the all-female dorms?", "rationale": ["The query is identifying the relevant table, which is 'Dorm'.", "Select the column to display, 'dorm_name'.", "Add a condition to filter the 'gender' column for the specified gender using a placeholder for string values."], "gold_sql": "SELECT dorm_name FROM dorm WHERE gender  =  'F'", "source_tables": ["dorm"], "description": "This virtual table lists the names of dormitories from the 'Dorm' table that are designated for a specific gender. The placeholder in the WHERE clause represents the gender designation for the dormitory.", "virtual_table": "SELECT dorm_name FROM dorm WHERE gender  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5688", "db_id": "dorm_1", "question": "Find the average and total capacity of dorms for the students with gender X.", "rationale": ["The query identifies the relevant table, which is 'Dorm'.", "It selects the average and sum of the 'student_capacity' column.", "A condition is added to filter the 'gender' column for the specified gender using a placeholder for string values."], "gold_sql": "SELECT avg(student_capacity) ,  sum(student_capacity) FROM dorm WHERE gender  =  'X'", "source_tables": ["dorm"], "description": "This virtual table provides the average and total student capacity of dormitories filtered by a specific gender designation. The placeholder in the WHERE clause represents the gender of the dormitory.", "virtual_table": "SELECT avg(student_capacity) ,  sum(student_capacity) FROM dorm WHERE gender  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6677", "db_id": "driving_school", "question": "How many lessons did the customer Ryan Goodwin complete?", "rationale": ["The query identifies the relevant tables, 'Lessons' and 'Customers', that are needed to retrieve the count of lessons.", "It uses a JOIN operation to link the 'Lessons' table with the 'Customers' table based on the customer ID.", "The SELECT statement counts the total number of lessons that match the specified conditions.", "The WHERE clause filters the results based on the customer's first name, last name, and the lesson status code, using placeholders for these values."], "gold_sql": "SELECT count(*) FROM Lessons AS T1 JOIN Customers AS T2 ON T1.customer_id  = T2.customer_id WHERE T2.first_name = 'Rylan' AND T2.last_name = 'Goodwin' AND T1.lesson_status_code = 'Completed';", "source_tables": ["lessons", "customers"], "description": "This virtual table provides the count of lessons attended by a specific customer identified by their first and last name, along with the status of those lessons. The placeholders in the WHERE clause represent the customer's first name, last name, and the lesson status code.", "virtual_table": "SELECT count(*) FROM Lessons AS T1 JOIN Customers AS T2 ON T1.customer_id  = T2.customer_id WHERE T2.first_name = [PLACEHOLDER-TYPE:STRING] AND T2.last_name = [PLACEHOLDER-TYPE:STRING] AND T1.lesson_status_code = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.6654", "db_id": "driving_school", "question": "Which city lives most of staffs? List the city name and number of staffs.", "rationale": ["The query identifies the relevant tables, which are 'Addresses' and 'Staff'.", "It selects the 'city' from the 'Addresses' table and counts the number of staff members associated with each city.", "A JOIN operation is performed on the 'address_id' from 'Addresses' and 'staff_address_id' from 'Staff' to link the two tables.", "The results are grouped by 'city' to aggregate the count of staff members per city.", "The results are ordered in descending order based on the count of staff members, and a LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.city ,  count(*) FROM Addresses AS T1 JOIN Staff AS T2 ON T1.address_id = T2.staff_address_id GROUP BY T1.city ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["addresses", "staff"], "description": "This virtual table provides a summary of the number of staff members located in each city, derived from the 'Addresses' and 'Staff' tables. The placeholder in the LIMIT clause allows the user to specify the maximum number of cities to display based on the count of staff members.", "virtual_table": "SELECT T1.city ,  count(*) FROM Addresses AS T1 JOIN Staff AS T2 ON T1.address_id = T2.staff_address_id GROUP BY T1.city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.6689", "db_id": "driving_school", "question": "What is the city with the most customers?", "rationale": ["The query identifies the relevant tables, which are 'Customers' and 'Addresses'.", "It selects the 'city' column from the 'Addresses' table.", "A JOIN operation is performed to link 'Customers' with 'Addresses' using the 'customer_address_id' foreign key.", "The results are grouped by 'city' to aggregate customer counts per city.", "The results are ordered in descending order based on the count of customers in each city.", "A LIMIT clause is added to restrict the number of cities returned based on a placeholder for numeric values."], "gold_sql": "SELECT T2.city FROM Customers AS T1 JOIN Addresses AS T2 ON T1.customer_address_id = T2.address_id GROUP BY T2.city ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["addresses", "customers"], "description": "This virtual table provides a list of cities where customers are located, derived from the 'Customers' and 'Addresses' tables. The results are grouped by city and ordered by the number of customers in each city, with a limit on the number of cities returned based on a specified number.", "virtual_table": "SELECT T2.city FROM Customers AS T1 JOIN Addresses AS T2 ON T1.customer_address_id = T2.address_id GROUP BY T2.city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.6627", "db_id": "driving_school", "question": "What are the details of the car with id 1?", "rationale": ["The query is identifying the relevant table, which is 'Vehicles'.", "Select the column to display, 'vehicle_details'.", "Add a condition to filter the 'vehicle_id' column for the specified vehicle using a placeholder for numeric values."], "gold_sql": "SELECT vehicle_details FROM Vehicles WHERE vehicle_id = 1;", "source_tables": ["vehicles"], "description": "This virtual table describes the details of a specific vehicle from the 'Vehicles' table based on its unique identifier. The placeholder in the WHERE clause represents the vehicle's ID.", "virtual_table": "SELECT vehicle_details FROM Vehicles WHERE vehicle_id = [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.6699", "db_id": "driving_school", "question": "How many lessons have been cancelled?", "rationale": ["The query identifies the relevant table, which is 'Lessons'.", "It uses the COUNT function to count the total number of records that match the specified condition.", "A condition is added to filter the 'lesson_status_code' column for the specified status using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM Lessons WHERE lesson_status_code = 'Cancelled';", "source_tables": ["lessons"], "description": "This virtual table provides the total number of lessons from the 'Lessons' table that have a specific status. The placeholder in the WHERE clause represents the lesson status code being queried.", "virtual_table": "SELECT count(*) FROM Lessons WHERE lesson_status_code = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.6651", "db_id": "driving_school", "question": "How many employees live in Georgia?", "rationale": ["The query identifies the relevant table, which is 'Addresses'.", "It selects a count of all entries in the table to determine how many addresses exist for a given state, province, or county.", "A condition is added to filter the results based on the 'state_province_county' column using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM Addresses WHERE state_province_county = 'Georgia';", "source_tables": ["addresses"], "description": "This virtual table provides the count of addresses from the 'Addresses' table that are located in a specific state, province, or county. The placeholder in the WHERE clause represents the name of the state, province, or county being queried.", "virtual_table": "SELECT count(*) FROM Addresses WHERE state_province_county = [PLACEHOLDER-TYPE:STRING];"}
