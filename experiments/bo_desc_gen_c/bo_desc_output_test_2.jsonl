{"sample_id": "train.2612", "db_id": "inn_1", "question": "Find the name of the room with the maximum occupancy.", "rationale": ["The query identifies the relevant table, which is 'Rooms'.", "Select the column to display, 'roomName'.", "Order the results by 'maxOccupancy' in descending order to show the rooms with the highest capacity first.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT roomName FROM Rooms ORDER BY maxOccupancy DESC LIMIT 1;", "source_tables": ["rooms"], "description": "This virtual table lists the names of rooms from the 'Rooms' table, ordered by their maximum occupancy in descending order. The placeholder in the LIMIT clause represents the maximum number of room names to be displayed.", "virtual_table": "SELECT roomName FROM Rooms ORDER BY maxOccupancy DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.2621", "db_id": "inn_1", "question": "What is the average minimum and price of the rooms for each different decor.", "rationale": ["The query identifies the relevant table, which is 'Rooms'.", "Select the 'decor' column to group the results by room decor.", "Calculate the average and minimum of the 'basePrice' column for each decor group using aggregate functions.", "Group the results by the 'decor' column to provide a summary for each unique decor type."], "gold_sql": "SELECT decor , avg(basePrice) ,  min(basePrice) FROM Rooms GROUP BY decor;", "source_tables": ["rooms"], "description": "This virtual table provides a summary of the average and minimum base prices of rooms, grouped by their decor descriptions. The placeholders represent the decor type and pricing information.", "virtual_table": "SELECT decor , avg(basePrice) ,  min(basePrice) FROM Rooms GROUP BY decor;"}
{"sample_id": "train.2628", "db_id": "inn_1", "question": "List the name of rooms with king or queen bed.", "rationale": ["The query is identifying the relevant table, which is 'Rooms'.", "Select the column to display, 'roomName'.", "Add a condition to filter the 'bedType' column for the specified bed types using placeholders for string values. The condition uses an OR operator to allow for multiple bed types."], "gold_sql": "SELECT roomName FROM Rooms WHERE bedType  =  'King' OR bedType  =  'Queen';", "source_tables": ["rooms"], "description": "This virtual table describes the names of rooms from the 'Rooms' table that have a specific type of bed. The placeholders in the WHERE clause represent the types of beds being queried.", "virtual_table": "SELECT roomName FROM Rooms WHERE bedType  =  [PLACEHOLDER-TYPE:STRING] OR bedType  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.2639", "db_id": "inn_1", "question": "For each room, find its name and the number of times reservations were made for it.", "rationale": ["The query identifies the relevant tables, 'Reservations' and 'Rooms'.", "It selects the 'roomName' from the 'Rooms' table and counts the number of reservations from the 'Reservations' table.", "A JOIN operation is performed on the 'Room' column from 'Reservations' and 'RoomId' from 'Rooms' to link the two tables.", "The results are grouped by the room identifier to aggregate the count of reservations for each room."], "gold_sql": "SELECT T2.roomName ,  count(*) ,  T1.Room FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room", "source_tables": ["rooms", "reservations"], "description": "This virtual table provides a summary of room reservations, showing the room names along with the count of reservations for each room. The placeholders in the query allow for dynamic filtering based on room identifiers.", "virtual_table": "SELECT T2.roomName ,  count(*) ,  T1.Room FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room"}
{"sample_id": "train.2846", "db_id": "customer_deliveries", "question": "Show the details of all trucks in the order of their license number.", "rationale": ["The query identifies the relevant table, which is 'Trucks'.", "Select the column to display, 'truck_details'.", "Order the results by 'truck_licence_number' to sort the trucks based on their license numbers."], "gold_sql": "SELECT truck_details FROM trucks ORDER BY truck_licence_number", "source_tables": ["trucks"], "description": "The virtual table provides details about trucks from the 'Trucks' table, specifically focusing on the truck's detailed information. The results are ordered by the truck's license number to facilitate easy identification and sorting of the trucks.", "virtual_table": "SELECT truck_details FROM trucks ORDER BY truck_licence_number"}
{"sample_id": "train.2848", "db_id": "customer_deliveries", "question": "Find the names of customers who are not living in the state of California.", "rationale": ["The query identifies the relevant table, which is 'Customers'.", "It selects the 'customer_name' column to display the names of customers.", "The EXCEPT clause is used to exclude customers who have an address in a specified state, province, or county.", "To achieve this, a JOIN is performed between 'Customers', 'Customer_Addresses', and 'Addresses' tables to filter based on the 'state_province_county' column using a placeholder for string values."], "gold_sql": "SELECT customer_name FROM customers EXCEPT SELECT t1.customer_name FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id WHERE t3.state_province_county  =  'California'", "source_tables": ["addresses", "customers", "customer_addresses"], "description": "This virtual table provides a list of customer names from the 'Customers' table who do not have an address in a specific state, province, or county. The placeholder in the WHERE clause represents the name of the state, province, or county to filter out customers with addresses in that location.", "virtual_table": "SELECT customer_name FROM customers EXCEPT SELECT t1.customer_name FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id WHERE t3.state_province_county  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2856", "db_id": "customer_deliveries", "question": "Find the name of route that has the highest number of deliveries.", "rationale": ["The query identifies the relevant tables, which are 'Delivery_Routes' and 'Delivery_Route_Locations'.", "It selects the 'route_name' from 'Delivery_Routes' and joins it with 'Delivery_Route_Locations' on the 'route_id'.", "The results are grouped by 'route_id' to aggregate the delivery locations associated with each route.", "The results are ordered by the count of delivery locations in descending order to highlight the most popular routes.", "A placeholder is included in the LIMIT clause to specify the maximum number of routes to return."], "gold_sql": "SELECT t1.route_name FROM Delivery_Routes AS t1 JOIN Delivery_Route_Locations AS t2 ON t1.route_id  =  t2.route_id GROUP BY t1.route_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["delivery_route_locations", "delivery_routes"], "description": "This virtual table provides a list of delivery route names from the 'Delivery_Routes' table, grouped by their unique identifiers. The results are ordered by the number of associated delivery locations in descending order, allowing users to see the most utilized routes. The placeholder in the LIMIT clause represents the maximum number of routes to be displayed.", "virtual_table": "SELECT t1.route_name FROM Delivery_Routes AS t1 JOIN Delivery_Route_Locations AS t2 ON t1.route_id  =  t2.route_id GROUP BY t1.route_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3175", "db_id": "college_1", "question": "How many professors are teaching class with code ACCT-211?", "rationale": ["The query identifies the relevant table, which is 'CLASS'.", "It counts the distinct 'PROF_NUM' to determine the number of unique professors.", "A condition is added to filter the results based on the 'CRS_CODE' using a placeholder for string values."], "gold_sql": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["class"], "description": "This virtual table provides the count of distinct professors teaching classes associated with a specific course code from the 'CLASS' table. The placeholder in the WHERE clause represents the course code being queried.", "virtual_table": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3176", "db_id": "college_1", "question": "How many professors teach a class with the code ACCT-211?", "rationale": ["The query identifies the relevant table, which is 'CLASS'.", "It counts the distinct 'PROF_NUM' to determine the number of unique professors.", "A condition is added to filter the results based on the 'CRS_CODE' using a placeholder for string values."], "gold_sql": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["class"], "description": "This virtual table provides the count of distinct professors teaching classes associated with a specific course code from the 'CLASS' table. The placeholder in the WHERE clause represents the course code being queried.", "virtual_table": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3179", "db_id": "college_1", "question": "What are the first names and date of birth of professors teaching course ACCT-211?", "rationale": ["The query identifies the relevant tables, which are 'employee' and 'CLASS'.", "It selects the columns to display, which are 'EMP_FNAME' and 'EMP_DOB' from the 'employee' table.", "A JOIN operation is performed between 'employee' and 'CLASS' on the condition that the professor's identifier matches the professor number in the class.", "A condition is added to filter the results based on the specified course code using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["employee", "class"], "description": "This virtual table provides a distinct list of first names and dates of birth of professors from the 'employee' table who are teaching classes associated with a specific course code. The placeholder in the WHERE clause represents the course code for which the professors are being queried.", "virtual_table": "SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3188", "db_id": "college_1", "question": "Where is the history department?", "rationale": ["The query identifies the relevant table, which is 'DEPARTMENT'.", "Select the column to display, 'dept_address'.", "Add a condition to filter the 'dept_name' column for the specified department using a placeholder for string values."], "gold_sql": "SELECT dept_address FROM department WHERE dept_name  =  'History'", "source_tables": ["department"], "description": "This virtual table provides the physical address of a department from the 'DEPARTMENT' table based on the specified department name. The placeholder in the WHERE clause represents the name of the department being queried.", "virtual_table": "SELECT dept_address FROM department WHERE dept_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3190", "db_id": "college_1", "question": "What are the different locations of the school with the code BUS?", "rationale": ["The query identifies the relevant table, which is 'DEPARTMENT'.", "It selects a count of distinct values from the 'dept_address' column.", "A condition is added to filter the results based on the 'school_code' using a placeholder for string values."], "gold_sql": "SELECT count(DISTINCT dept_address) FROM department WHERE school_code  =  'BUS'", "source_tables": ["department"], "description": "This virtual table counts the distinct addresses of departments from the 'DEPARTMENT' table that belong to a specific school. The placeholder in the WHERE clause represents the school code.", "virtual_table": "SELECT count(DISTINCT dept_address) FROM department WHERE school_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3201", "db_id": "college_1", "question": "What is the total credit does each department offer?", "rationale": ["The query identifies the relevant table, which is 'COURSE'.", "It selects the sum of 'CRS_CREDIT' to calculate the total credit hours.", "The 'DEPT_CODE' is included to group the results by department, allowing for a summary of credit hours per department."], "gold_sql": "SELECT sum(crs_credit) ,  dept_code FROM course GROUP BY dept_code", "source_tables": ["course"], "description": "This virtual table summarizes the total credit hours offered by each department from the 'COURSE' table. The placeholder in the SELECT clause represents the total credit hours, while the GROUP BY clause groups the results by department code.", "virtual_table": "SELECT sum(crs_credit) ,  dept_code FROM course GROUP BY dept_code"}
{"sample_id": "train.3202", "db_id": "college_1", "question": "How many credits does the department offer?", "rationale": ["The query identifies the relevant table, which is 'COURSE'.", "It selects the sum of 'crs_credit' to calculate the total credit hours for each department.", "The query groups the results by 'dept_code' to provide a summary for each department."], "gold_sql": "SELECT sum(crs_credit) ,  dept_code FROM course GROUP BY dept_code", "source_tables": ["course"], "description": "This virtual table summarizes the total credit hours for courses grouped by their respective department codes from the 'COURSE' table. The placeholder in the SELECT clause represents the total credit hours, while the GROUP BY clause organizes the results by department code.", "virtual_table": "SELECT sum(crs_credit) ,  dept_code FROM course GROUP BY dept_code"}
{"sample_id": "train.3213", "db_id": "college_1", "question": "Which school has the smallest amount of professors?", "rationale": ["The query identifies the relevant tables, which are 'department' and 'professor'.", "It selects the 'school_code' from the 'department' table.", "A JOIN operation is performed between 'department' and 'professor' on the 'dept_code' to associate professors with their respective departments.", "The results are grouped by 'school_code' to aggregate the data based on the number of professors per school.", "The results are ordered by the count of professors in descending order to prioritize schools with more professors.", "A LIMIT clause is included to allow the user to specify how many school codes they want to retrieve."], "gold_sql": "SELECT T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code ORDER BY count(*) LIMIT 1", "source_tables": ["department", "professor"], "description": "This virtual table provides a list of school codes from the 'department' table, grouped by school code and ordered by the count of professors associated with each school. The placeholder in the LIMIT clause allows the user to specify the maximum number of school codes to retrieve.", "virtual_table": "SELECT T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3215", "db_id": "college_1", "question": "Find the number of professors with a Ph.D. degree in each department.", "rationale": ["The query identifies the relevant table, which is 'professor'.", "It selects a count of professors and groups the results by 'dept_code'.", "A condition is added to filter the results based on the 'prof_high_degree' column using a placeholder for string values."], "gold_sql": "SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  'Ph.D.' GROUP BY dept_code", "source_tables": ["professor"], "description": "This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree level being queried.", "virtual_table": "SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY dept_code"}
{"sample_id": "train.3217", "db_id": "college_1", "question": "Find the number of students for each department.", "rationale": ["The query identifies the relevant table, which is 'student'.", "It selects the count of students and groups the results by 'dept_code'.", "The use of count(*) allows for the aggregation of student records based on their department code."], "gold_sql": "SELECT count(*) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "description": "This virtual table provides a count of students grouped by their respective department codes from the 'student' table. The placeholder in the SELECT statement represents the total number of students in each department.", "virtual_table": "SELECT count(*) ,  dept_code FROM student GROUP BY dept_code"}
{"sample_id": "train.3219", "db_id": "college_1", "question": "Find the total number of hours have done for all students in each department.", "rationale": ["The query identifies the relevant table, which is 'student'.", "It selects the sum of 'stu_hrs' to calculate the total credit hours for each department.", "The GROUP BY clause is used to aggregate the results based on 'dept_code', allowing for a summary of credit hours per department."], "gold_sql": "SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "description": "This virtual table summarizes the total credit hours completed by students, grouped by their respective departments. The placeholder in the SELECT clause represents the total credit hours, while the GROUP BY clause organizes the results by department code.", "virtual_table": "SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code"}
{"sample_id": "train.3240", "db_id": "college_1", "question": "Which department offers the most credits all together?", "rationale": ["The query identifies the relevant tables: 'COURSE', 'CLASS', and 'DEPARTMENT'.", "It joins these tables based on their foreign key relationships to link courses to their respective departments.", "The SELECT statement retrieves the 'dept_name' from the 'DEPARTMENT' table.", "The GROUP BY clause groups the results by 'dept_code' to aggregate the total credit hours for each department.", "The ORDER BY clause sorts the departments based on the sum of their credit hours in descending order.", "The LIMIT clause uses a placeholder to allow the user to specify how many department names to return."], "gold_sql": "SELECT T3.dept_name FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code JOIN department AS T3 ON T1.dept_code  =  T3.dept_code GROUP BY T1.dept_code ORDER BY sum(T1.crs_credit) DESC LIMIT 1", "source_tables": ["course", "department", "class"], "description": "This virtual table provides a list of department names from the 'DEPARTMENT' table, which are associated with courses from the 'COURSE' table. The query joins the 'COURSE', 'CLASS', and 'DEPARTMENT' tables to aggregate the total credit hours for each department, ordering the results in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of department names to retrieve.", "virtual_table": "SELECT T3.dept_name FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code JOIN department AS T3 ON T1.dept_code  =  T3.dept_code GROUP BY T1.dept_code ORDER BY sum(T1.crs_credit) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3243", "db_id": "college_1", "question": "What is the first name of each student enrolled in class ACCT-211?", "rationale": ["The query identifies the relevant tables: 'CLASS', 'ENROLL', and 'STUDENT'.", "It selects the 'stu_fname' column from the 'STUDENT' table to display the first names of students.", "The JOIN operations link the 'CLASS' table to the 'ENROLL' table using 'class_code', and the 'ENROLL' table to the 'STUDENT' table using 'stu_num'.", "A condition is added to filter the results based on the 'crs_code' from the 'CLASS' table using a placeholder for string values."], "gold_sql": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  'ACCT-211'", "source_tables": ["student", "class", "enroll"], "description": "This virtual table describes the first names of students enrolled in classes associated with a specific course code from the 'CLASS', 'ENROLL', and 'STUDENT' tables. The placeholder in the WHERE clause represents the course code.", "virtual_table": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3245", "db_id": "college_1", "question": "What is the first name of students enrolled in class ACCT-211 and got grade C?", "rationale": ["The query identifies the relevant tables: CLASS, ENROLL, and STUDENT.", "It selects the 'stu_fname' column from the STUDENT table.", "The JOIN operations link the CLASS table to the ENROLL table using 'class_code', and the ENROLL table to the STUDENT table using 'stu_num'.", "Conditions are added to filter the results based on the specified course code and the grade received, using placeholders for string values."], "gold_sql": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  'ACCT-211' AND T2.enroll_grade  =  'C'", "source_tables": ["student", "class", "enroll"], "description": "This virtual table describes the first names of students enrolled in classes associated with a specific course code and who have received a particular grade. The placeholders in the WHERE clause represent the course code and the grade received by the students.", "virtual_table": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  [PLACEHOLDER-TYPE:STRING] AND T2.enroll_grade  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3254", "db_id": "college_1", "question": "What is the name of the department with the most students enrolled?", "rationale": ["The query identifies the relevant tables: 'CLASS', 'ENROLL', 'COURSE', and 'DEPARTMENT'.", "It joins these tables based on their foreign key relationships to connect classes with their respective courses and departments.", "The SELECT statement retrieves the 'dept_name' from the 'DEPARTMENT' table.", "The GROUP BY clause groups the results by department code to count the number of classes per department.", "The ORDER BY clause sorts the results in descending order based on the count of classes, allowing the most populated departments to appear first.", "The LIMIT clause restricts the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T4.dept_name FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code GROUP BY T3.dept_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["course", "department", "class", "enroll"], "description": "This virtual table provides a list of department names from the 'DEPARTMENT' table that are associated with classes in the 'CLASS' table. The query joins multiple tables to aggregate the number of classes per department, allowing users to see which departments have the most classes offered. The placeholder in the LIMIT clause represents the maximum number of department names to return.", "virtual_table": "SELECT T4.dept_name FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code GROUP BY T3.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3257", "db_id": "college_1", "question": "List the codes of all courses that take place in room KLR209.", "rationale": ["The query is identifying the relevant table, which is 'CLASS'.", "Select the column to display, 'class_code'.", "Add a condition to filter the 'class_room' column for the specified room using a placeholder for string values."], "gold_sql": "SELECT class_code FROM CLASS WHERE class_room  =  'KLR209'", "source_tables": ["class"], "description": "This virtual table describes the unique class codes from the 'CLASS' table for classes held in a specific room. The placeholder in the WHERE clause represents the room's identifier.", "virtual_table": "SELECT class_code FROM CLASS WHERE class_room  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3258", "db_id": "college_1", "question": "What are the codes of all the courses that are located in room KLR209?", "rationale": ["The query identifies the relevant table, which is 'CLASS'.", "Select the column to display, 'class_code'.", "Add a condition to filter the 'class_room' column for the specified room using a placeholder for string values."], "gold_sql": "SELECT class_code FROM CLASS WHERE class_room  =  'KLR209'", "source_tables": ["class"], "description": "This virtual table describes the unique class codes from the 'CLASS' table that are held in a specific classroom. The placeholder in the WHERE clause represents the room where the class is conducted.", "virtual_table": "SELECT class_code FROM CLASS WHERE class_room  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3267", "db_id": "college_1", "question": "What is the first name of students who got grade C in any class?", "rationale": ["The query identifies the relevant tables, which are 'student' and 'enroll'.", "It selects the distinct first names of students from the 'student' table.", "A JOIN operation is performed between 'student' and 'enroll' on the student number to link students with their enrollments.", "A condition is added to filter the results based on the grade received by the students using a placeholder for string values."], "gold_sql": "SELECT DISTINCT stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE enroll_grade  =  'C'", "source_tables": ["enroll", "student"], "description": "This virtual table provides a list of distinct first names of students who have received a specific grade in their enrolled classes. The placeholder in the WHERE clause represents the grade that the user wants to filter by.", "virtual_table": "SELECT DISTINCT stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE enroll_grade  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3273", "db_id": "college_1", "question": "What are the first names of the professors who do not teach a class.", "rationale": ["The query identifies the relevant table, which is 'employee'.", "Select the column to display, 'emp_fname'.", "Add a condition to filter the 'emp_jobcode' column for the specified job code using a placeholder for string values.", "Use the EXCEPT clause to exclude first names of employees who are professors by joining the 'employee' table with the 'CLASS' table on the professor's identifier."], "gold_sql": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  'PROF' EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num", "source_tables": ["employee", "class"], "description": "This virtual table describes the first names of employees from the 'employee' table who hold a specific job code, excluding those who are professors teaching any class. The placeholder in the WHERE clause represents the job code of the employees.", "virtual_table": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num"}
{"sample_id": "train.3274", "db_id": "college_1", "question": "What are the first names of all professors not teaching any classes?", "rationale": ["The query identifies the relevant table, which is 'employee'.", "Select the column to display, 'emp_fname'.", "Add a condition to filter the 'emp_jobcode' column for the specified job code using a placeholder for string values.", "Use the EXCEPT clause to exclude first names of employees who are professors by joining the 'employee' table with the 'class' table on the professor's identifier."], "gold_sql": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  'PROF' EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num", "source_tables": ["employee", "class"], "description": "This virtual table describes the first names of employees from the 'employee' table who hold a specific job code, excluding those who are professors teaching any class. The placeholder in the WHERE clause represents the job code of the employees.", "virtual_table": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num"}
{"sample_id": "train.3288", "db_id": "college_1", "question": "How many professors attained either Ph.D. or Masters degrees?", "rationale": ["The query identifies the relevant table, which is 'professor'.", "It uses the COUNT function to count the number of records that meet the specified criteria.", "The WHERE clause filters the results based on the 'prof_high_degree' column, allowing for two different degree values using placeholders for string values."], "gold_sql": "SELECT count(*) FROM professor WHERE prof_high_degree  =  'Ph.D.' OR prof_high_degree  =  'MA'", "source_tables": ["professor"], "description": "This virtual table counts the number of professors from the 'professor' table who have a specific highest degree. The placeholders in the WHERE clause represent the degrees being queried.", "virtual_table": "SELECT count(*) FROM professor WHERE prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] OR prof_high_degree  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3292", "db_id": "college_1", "question": "What is the first name of the professor who is teaching CIS-220 and QM-261?", "rationale": ["The query identifies the relevant tables, which are 'employee' and 'class'.", "It selects the 'emp_fname' column from the 'employee' table, which contains the first names of professors.", "The JOIN operation links the 'employee' table to the 'class' table based on the professor's identifier.", "The WHERE clause filters the results based on the specified course code using a placeholder for string values.", "The INTERSECT operation is used to find common results from two identical queries, ensuring that only professors teaching the same course code are returned."], "gold_sql": "SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  'CIS-220' INTERSECT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  'QM-261'", "source_tables": ["employee", "class"], "description": "This virtual table describes the first names of professors who are teaching a specific course, identified by its course code. The query uses an INTERSECT operation to find professors who are associated with the same course code in two different instances, ensuring that only those professors who meet both conditions are returned. The placeholders in the WHERE clause represent the course code being queried.", "virtual_table": "SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3293", "db_id": "college_1", "question": "Find the first name of student who is taking classes from accounting and Computer Info. Systems departments", "rationale": ["The query identifies the relevant tables: 'student', 'enroll', 'class', 'course', and 'department'.", "It selects the 'stu_fname' column from the 'student' table.", "The JOIN operations link the tables based on their foreign key relationships to ensure that only students enrolled in the specified classes are considered.", "The WHERE clause filters the results based on the department name, using a placeholder for string values.", "The INTERSECT operation is used to find students who are enrolled in classes from the same department in two separate queries, ensuring that only those students who meet both conditions are included."], "gold_sql": "SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Accounting' INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Computer Info. Systems'", "source_tables": ["course", "enroll", "department", "class", "student"], "description": "This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the department's name.", "virtual_table": "SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3308", "db_id": "college_1", "question": "What are the first names and office of the professors who are in the history department and have a Ph.D?", "rationale": ["The query identifies the relevant tables: 'employee', 'professor', and 'department'.", "It selects the 'emp_fname' from the 'employee' table and 'prof_office' from the 'professor' table.", "The join condition links the 'employee' and 'professor' tables through the 'emp_num' field, ensuring we get the correct professor for each employee.", "Another join is made with the 'department' table to filter based on the department name.", "The WHERE clause includes conditions to filter by the specified department name and the highest degree of the professors, using placeholders for string values."], "gold_sql": "SELECT T1.emp_fname ,  T2.prof_office FROM employee AS T1 JOIN professor AS T2 ON T1.emp_num  =  T2.emp_num JOIN department AS T3 ON T3.dept_code  =  T2.dept_code WHERE T3.dept_name  =  'History' AND T2.prof_high_degree  =  'Ph.D.'", "source_tables": ["employee", "professor", "department"], "description": "This virtual table provides the first names of employees and the office locations of professors from the 'employee' and 'professor' tables, respectively. It filters the results based on a specific department name and the highest degree obtained by the professors, both represented by placeholders for string values.", "virtual_table": "SELECT T1.emp_fname ,  T2.prof_office FROM employee AS T1 JOIN professor AS T2 ON T1.emp_num  =  T2.emp_num JOIN department AS T3 ON T3.dept_code  =  T2.dept_code WHERE T3.dept_name  =  [PLACEHOLDER-TYPE:STRING] AND T2.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3319", "db_id": "college_1", "question": "Find names of all students who took some course and got A or C.", "rationale": ["The query identifies the relevant tables, which are 'student' and 'enroll'.", "It selects the columns to display, 'stu_fname' and 'stu_lname' from the 'student' table.", "A JOIN operation is performed between 'student' and 'enroll' on the 'stu_num' column to link students with their enrollments.", "Conditions are added to filter the results based on the 'enroll_grade' column for the specified grades using placeholders for string values."], "gold_sql": "SELECT T1.stu_fname ,  T1.stu_lname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE T2.enroll_grade  =  'C' OR T2.enroll_grade  =  'A'", "source_tables": ["enroll", "student"], "description": "This virtual table describes the first and last names of students from the 'student' table who have received specific grades in their enrolled classes. The placeholders in the WHERE clause represent the grades being queried.", "virtual_table": "SELECT T1.stu_fname ,  T1.stu_lname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE T2.enroll_grade  =  [PLACEHOLDER-TYPE:STRING] OR T2.enroll_grade  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3324", "db_id": "college_1", "question": "What are the different first names and highest degree attained for professors teaching in the Computer Information Systems department?", "rationale": ["The query identifies the relevant tables: 'CLASS', 'EMPLOYEE', 'PROFESSOR', and 'DEPARTMENT'.", "It selects distinct first names of employees and their highest degrees.", "The join conditions link the professor to their respective employee and department, ensuring the correct relationships are maintained.", "A condition is added to filter results based on the department name using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T2.emp_fname ,  T3.prof_high_degree FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN professor AS T3 ON T2.emp_num  =  T3.emp_num JOIN department AS T4 ON T4.dept_code  =  T3.dept_code WHERE T4.dept_name  =  'Computer Info. Systems'", "source_tables": ["employee", "professor", "class", "department"], "description": "This virtual table provides a distinct list of first names of employees and their highest degrees from the 'CLASS', 'EMPLOYEE', 'PROFESSOR', and 'DEPARTMENT' tables. The results are filtered based on a specific department name provided as a placeholder.", "virtual_table": "SELECT DISTINCT T2.emp_fname ,  T3.prof_high_degree FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN professor AS T3 ON T2.emp_num  =  T3.emp_num JOIN department AS T4 ON T4.dept_code  =  T3.dept_code WHERE T4.dept_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3333", "db_id": "college_1", "question": "Find the name of department that offers the class whose description has the word \"Statistics\".", "rationale": ["The query identifies the relevant tables, which are 'course' and 'department'.", "It selects the 'dept_name' column from the 'department' table.", "A JOIN operation is performed on the 'dept_code' to link courses with their respective departments.", "A condition is added to filter the courses based on their description using a placeholder for string values."], "gold_sql": "SELECT T2.dept_name FROM course AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.crs_description LIKE '%Statistics%'", "source_tables": ["course", "department"], "description": "This virtual table provides the names of departments that offer courses matching a specific description. The query joins the 'course' table with the 'department' table based on the department code, filtering the results to include only those courses whose descriptions contain a specified string.", "virtual_table": "SELECT T2.dept_name FROM course AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.crs_description LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3343", "db_id": "sports_competition", "question": "What are the types and countries of competitions?", "rationale": ["The query identifies the relevant table, which is 'competition'.", "Select the columns to display, 'Competition_type' and 'Country'.", "No filtering conditions are applied, so all records from the 'competition' table will be retrieved."], "gold_sql": "SELECT Competition_type ,  Country FROM competition", "source_tables": ["competition"], "description": "This virtual table describes the types of competitions and the countries where they are held from the 'competition' table. The placeholders represent the specific competition type and country details.", "virtual_table": "SELECT Competition_type ,  Country FROM competition"}
{"sample_id": "train.3355", "db_id": "sports_competition", "question": "Please show the names and the players of clubs.", "rationale": ["The query identifies the relevant tables, which are 'club' and 'player'.", "It selects the 'name' column from the 'club' table and the 'Player_ID' column from the 'player' table.", "A JOIN operation is performed on the 'Club_ID' column to link players to their respective clubs, ensuring that only players belonging to the selected clubs are included in the results."], "gold_sql": "SELECT T1.name ,  T2.Player_id FROM club AS T1 JOIN player AS T2 ON T1.Club_ID  =  T2.Club_ID", "source_tables": ["club", "player"], "description": "This virtual table describes the names of clubs along with the unique identifiers of players associated with those clubs. The join operation links the 'club' table and the 'player' table based on the common 'Club_ID' field, allowing for the retrieval of player information for each club.", "virtual_table": "SELECT T1.name ,  T2.Player_id FROM club AS T1 JOIN player AS T2 ON T1.Club_ID  =  T2.Club_ID"}
{"sample_id": "train.3364", "db_id": "sports_competition", "question": "What are the positions of players whose average number of points scored by that position is larger than 20?", "rationale": ["The query identifies the relevant table, which is 'player'.", "It selects the 'Position' column to display the playing positions of players.", "The GROUP BY clause is used to group the results by player name to calculate the average points.", "The HAVING clause filters the results to include only those players whose average points meet or exceed the specified threshold using a placeholder for numeric values."], "gold_sql": "SELECT POSITION FROM player GROUP BY name HAVING avg(Points)  >=  20", "source_tables": ["player"], "description": "This virtual table provides the playing positions of players from the 'player' table who have an average score of points greater than or equal to a specified threshold. The placeholder in the HAVING clause represents the minimum average points required.", "virtual_table": "SELECT POSITION FROM player GROUP BY name HAVING avg(Points)  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3374", "db_id": "sports_competition", "question": "What are the positions of both players that have more than 20 20 points and less than 10 points?", "rationale": ["The query identifies the relevant table, which is 'player'.", "It selects the 'Position' column to display the playing positions of players.", "The INTERSECT operator is used to find positions of players whose points are greater than a specified lower bound and less than a specified upper bound, using placeholders for numeric values."], "gold_sql": "SELECT POSITION FROM player WHERE Points  >  20 INTERSECT SELECT POSITION FROM player WHERE Points  <  10", "source_tables": ["player"], "description": "This virtual table describes the playing positions of players from the 'player' table who have a total points score that falls between two specified numeric values. The placeholders in the query represent the lower and upper bounds for the points scored by the players.", "virtual_table": "SELECT POSITION FROM player WHERE Points  >  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT POSITION FROM player WHERE Points  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3383", "db_id": "sports_competition", "question": "which country did participated in the most number of Tournament competitions?", "rationale": ["The query identifies the relevant table, which is 'competition'.", "It selects the 'country' column to display the countries where competitions are held.", "A condition is added to filter the results based on the 'competition_type' using a placeholder for string values.", "The results are grouped by 'country' to aggregate the data accordingly.", "The results are ordered by the count of competitions in descending order to show the most frequent countries first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT country FROM competition WHERE competition_type  =  'Tournament' GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["competition"], "description": "This virtual table provides a list of countries where competitions of a specific type have taken place. The results are grouped by country and ordered by the number of competitions, allowing users to see which countries host the most events of that type. The placeholders in the query represent the competition type and the limit on the number of results returned.", "virtual_table": "SELECT country FROM competition WHERE competition_type  =  [PLACEHOLDER-TYPE:STRING] GROUP BY country ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3384", "db_id": "sports_competition", "question": "what is the name of the country that participated in the most tournament competitions?", "rationale": ["The query identifies the relevant table, which is 'competition'.", "It selects the 'country' column to display the countries where competitions are held.", "A condition is added to filter the results based on the 'competition_type' using a placeholder for string values.", "The results are grouped by 'country' to aggregate the data.", "The results are ordered by the count of occurrences in descending order to show the most frequent countries first.", "A limit is applied to restrict the number of countries returned, using a placeholder for numeric values."], "gold_sql": "SELECT country FROM competition WHERE competition_type  =  'Tournament' GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["competition"], "description": "This virtual table provides a list of countries where competitions of a specific type have taken place. The results are grouped by country and ordered by the number of occurrences, allowing users to see which countries host the most competitions of that type. The placeholders in the query represent the competition type and the limit on the number of countries to return.", "virtual_table": "SELECT country FROM competition WHERE competition_type  =  [PLACEHOLDER-TYPE:STRING] GROUP BY country ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3388", "db_id": "sports_competition", "question": "What are the countries that have never participated in any friendly-type competitions?", "rationale": ["The query identifies the relevant table, which is 'competition'.", "It selects the 'country' column to display the countries where competitions took place.", "The EXCEPT clause is used to exclude countries that hosted competitions of a specific type, with a placeholder for the competition type in the WHERE clause."], "gold_sql": "SELECT country FROM competition EXCEPT SELECT country FROM competition WHERE competition_type  =  'Friendly'", "source_tables": ["competition"], "description": "This virtual table lists the countries where competitions were held, excluding those countries that hosted competitions of a specific type. The placeholder in the WHERE clause represents the type of competition to be excluded.", "virtual_table": "SELECT country FROM competition EXCEPT SELECT country FROM competition WHERE competition_type  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3407", "db_id": "hr_1", "question": "List the full name (first and last name), and salary for those employees who earn below 6000.", "rationale": ["The query is identifying the relevant table, which is 'employees'.", "Select the columns to display, 'first_name', 'last_name', and 'salary'.", "Add a condition to filter the 'salary' column for employees earning less than the specified amount using a placeholder for numeric values."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees WHERE salary  <  6000", "source_tables": ["employees"], "description": "This virtual table describes the first names, last names, and salaries of employees from the 'employees' table who earn less than a specified salary. The placeholder in the WHERE clause represents the salary threshold.", "virtual_table": "SELECT first_name ,  last_name ,  salary FROM employees WHERE salary  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3418", "db_id": "hr_1", "question": "What are the full name, hire date, salary, and department id for employees without the letter M in their first name?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Selects the columns to display: 'first_name', 'last_name', 'hire_date', 'salary', and 'department_id'.", "Adds a condition to filter out employees whose first names do not match a specified pattern using a placeholder for string values."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%'", "source_tables": ["employees"], "description": "This virtual table provides a list of employees' first names, last names, hire dates, salaries, and their department identifiers from the 'employees' table, excluding those whose first names match a specific pattern. The placeholder in the WHERE clause represents the pattern to filter out certain first names.", "virtual_table": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3419", "db_id": "hr_1", "question": "display the full name (first and last), hire date, salary, and department number for those employees whose first name does not containing the letter M and make the result set in ascending order by department number.", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Selects the columns to display: 'first_name', 'last_name', 'hire_date', 'salary', and 'department_id'.", "Adds a condition to filter out employees whose first names match a specific pattern using a placeholder for string values.", "Orders the results by 'department_id' to group employees by their respective departments."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id", "source_tables": ["employees"], "description": "This virtual table provides a list of employees' first names, last names, hire dates, salaries, and their department identifiers from the 'employees' table, excluding those whose first names match a specific pattern. The placeholder in the WHERE clause allows for filtering based on the first name criteria.", "virtual_table": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE [PLACEHOLDER-TYPE:STRING] ORDER BY department_id"}
{"sample_id": "train.3420", "db_id": "hr_1", "question": "What are the full name, hire data, salary and department id for employees without the letter M in their first name, ordered by ascending department id?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Selects the columns to display: 'first_name', 'last_name', 'hire_date', 'salary', and 'department_id'.", "Adds a condition to filter out employees whose first names match a specified pattern using a placeholder for string values.", "Orders the results by 'department_id' to group employees by their respective departments."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id", "source_tables": ["employees"], "description": "This virtual table provides a list of employees' first names, last names, hire dates, salaries, and their department identifiers from the 'employees' table, excluding those whose first names match a specific pattern. The placeholder in the WHERE clause allows for filtering based on the first name criteria.", "virtual_table": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE [PLACEHOLDER-TYPE:STRING] ORDER BY department_id"}
{"sample_id": "train.3442", "db_id": "hr_1", "question": "Which job titles correspond to jobs with salaries over 9000?", "rationale": ["The query identifies the relevant table, which is 'jobs'.", "Select the column to display, 'job_title'.", "Add a condition to filter the 'min_salary' column for values greater than the specified amount using a placeholder for numeric values."], "gold_sql": "SELECT job_title FROM jobs WHERE min_salary  >  9000", "source_tables": ["jobs"], "description": "This virtual table lists the job titles from the 'jobs' table where the minimum salary exceeds a specified amount. The placeholder in the WHERE clause represents the minimum salary threshold.", "virtual_table": "SELECT job_title FROM jobs WHERE min_salary  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3444", "db_id": "hr_1", "question": "What are the job titles, and range of salaries for jobs with maximum salary between 12000 and 18000?", "rationale": ["The query identifies the relevant table, which is 'jobs'.", "Select the columns to display, 'job_title' and the calculated difference between 'max_salary' and 'min_salary'.", "Add a condition to filter the 'max_salary' column to ensure it falls within the specified range using placeholders for numeric values."], "gold_sql": "SELECT job_title ,  max_salary - min_salary FROM jobs WHERE max_salary BETWEEN 12000 AND 18000", "source_tables": ["jobs"], "description": "This virtual table provides the job titles along with the salary range (calculated as the difference between maximum and minimum salary) for jobs in the 'jobs' table that have a maximum salary falling within a specified range. The placeholders in the WHERE clause represent the lower and upper limits of the salary range.", "virtual_table": "SELECT job_title ,  max_salary - min_salary FROM jobs WHERE max_salary BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3448", "db_id": "hr_1", "question": "What are the employee ids for each employee and final dates of employment at their last job?", "rationale": ["The query identifies the relevant table, which is 'job_history'.", "Select the column 'employee_id' to display the unique identifier for each employee.", "Use the MAX function to find the latest 'end_date' for each employee's job history.", "Group the results by 'employee_id' to ensure that the maximum end date is calculated for each individual employee."], "gold_sql": "SELECT employee_id ,  MAX(end_date) FROM job_history GROUP BY employee_id", "source_tables": ["job_history"], "description": "This virtual table provides a summary of the most recent job end dates for each employee from the 'job_history' table. The placeholder in the SELECT clause represents the unique identifier for each employee, while the MAX function is used to retrieve the latest end date for their job history.", "virtual_table": "SELECT employee_id ,  MAX(end_date) FROM job_history GROUP BY employee_id"}
{"sample_id": "train.3453", "db_id": "hr_1", "question": "display the average salary of employees for each department who gets a commission percentage.", "rationale": ["The query identifies the relevant table, which is 'employees'.", "It selects the 'department_id' and calculates the average salary using the AVG function.", "A condition is added to filter out employees with a null commission percentage using a placeholder for string values.", "The results are grouped by 'department_id' to provide the average salary for each department."], "gold_sql": "SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != 'null' GROUP BY department_id", "source_tables": ["employees"], "description": "This virtual table provides the average salary of employees grouped by their department. The placeholder in the WHERE clause indicates that only employees with a non-null commission percentage are considered in the calculation.", "virtual_table": "SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != [PLACEHOLDER-TYPE:STRING] GROUP BY department_id"}
{"sample_id": "train.3454", "db_id": "hr_1", "question": "What is the average salary of employees who have a commission percentage that is not null?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "It selects the 'department_id' and calculates the average salary using the AVG function.", "A condition is added to filter out employees with a null commission percentage using a placeholder for string values.", "The results are grouped by 'department_id' to provide the average salary for each department."], "gold_sql": "SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != 'null' GROUP BY department_id", "source_tables": ["employees"], "description": "This virtual table provides the average salary of employees grouped by their department. The placeholder in the WHERE clause indicates that only departments with employees who have a non-null commission percentage are included in the results.", "virtual_table": "SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != [PLACEHOLDER-TYPE:STRING] GROUP BY department_id"}
{"sample_id": "train.3455", "db_id": "hr_1", "question": "display the country ID and number of cities for each country.", "rationale": ["The query identifies the relevant table, which is 'locations'.", "It selects the 'country_id' to group the results by each country.", "The COUNT function is used to count the number of locations for each country, and the results are grouped by 'country_id' to provide a summary of locations per country."], "gold_sql": "SELECT country_id ,  COUNT(*) FROM locations GROUP BY country_id", "source_tables": ["locations"], "description": "This virtual table summarizes the number of locations associated with each country in the 'locations' table. The placeholder in the SELECT clause represents the unique identifier for each country, while the COUNT function aggregates the total number of locations per country.", "virtual_table": "SELECT country_id ,  COUNT(*) FROM locations GROUP BY country_id"}
{"sample_id": "train.3456", "db_id": "hr_1", "question": "Give the country id and corresponding count of cities in each country.", "rationale": ["The query identifies the relevant table, which is 'locations'.", "It selects the 'country_id' to group the results by each country.", "The COUNT function is used to count the number of locations for each country, and the results are grouped by 'country_id' to provide a summary of locations per country."], "gold_sql": "SELECT country_id ,  COUNT(*) FROM locations GROUP BY country_id", "source_tables": ["locations"], "description": "This virtual table summarizes the number of locations associated with each country from the 'locations' table. The placeholder in the SELECT clause represents the unique identifier for each country, while the COUNT function aggregates the total number of locations per country.", "virtual_table": "SELECT country_id ,  COUNT(*) FROM locations GROUP BY country_id"}
{"sample_id": "train.3465", "db_id": "hr_1", "question": "Can you return all detailed info of jobs which was done by any of the employees who is presently earning a salary on and above 12000?", "rationale": ["The query identifies the relevant tables, which are 'job_history' and 'employees'.", "It selects all columns from the joined tables using the wildcard '*'.", "The JOIN operation is performed on the employee identifier to link job history with employee details.", "A condition is added to filter employees based on their salary using a placeholder for numeric values."], "gold_sql": "SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  12000", "source_tables": ["job_history", "employees"], "description": "This virtual table provides a comprehensive view of the job history of employees who have a salary greater than or equal to a specified amount. It combines data from the 'job_history' and 'employees' tables, linking them through the employee identifier. The placeholder in the WHERE clause represents the minimum salary threshold for filtering the results.", "virtual_table": "SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3482", "db_id": "hr_1", "question": "What is all the information regarding employees who are managers?", "rationale": ["The query identifies the relevant tables, which are 'employees' and 'departments'.", "It performs a JOIN operation on the 'department_id' to link employees with their respective departments.", "The WHERE clause filters the results to include only those employees whose 'employee_id' matches the 'manager_id' in the departments table."], "gold_sql": "SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T1.employee_id  =  T2.manager_id", "source_tables": ["employees", "departments"], "description": "This virtual table provides a list of employees who are also managers in their respective departments. It combines data from the 'employees' and 'departments' tables, ensuring that only those employees whose 'employee_id' matches the 'manager_id' of their department are included. The use of DISTINCT ensures that each employee-manager pair is unique.", "virtual_table": "SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T1.employee_id  =  T2.manager_id"}
{"sample_id": "train.3487", "db_id": "hr_1", "question": "What are the unique ids of those departments where any manager is managing 4 or more employees.", "rationale": ["The query identifies the relevant table, which is 'employees'.", "It selects distinct 'department_id' to ensure unique entries.", "The results are grouped by 'department_id' and 'manager_id' to aggregate the data accordingly.", "A HAVING clause is used to filter groups based on the count of 'employee_id', ensuring only departments with a specified minimum number of employees are included, using a placeholder for numeric values."], "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"], "description": "This virtual table lists unique department identifiers from the 'employees' table, grouped by department and manager. It filters the results to include only those departments that have a specified minimum number of employees, represented by a placeholder for numeric values.", "virtual_table": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3488", "db_id": "hr_1", "question": "Give the distinct department ids of departments in which a manager is in charge of 4 or more employees?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "It selects distinct 'department_id' to ensure unique departments are listed.", "The results are grouped by 'department_id' and 'manager_id' to aggregate employee counts per department and manager.", "The HAVING clause is used to filter groups based on the count of 'employee_id', ensuring only departments with a specified minimum number of employees are included, using a placeholder for numeric values."], "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"], "description": "This virtual table lists unique department identifiers from the 'employees' table, grouped by department and manager. It filters the results to include only those departments that have a specified minimum number of employees. The placeholder in the HAVING clause represents the minimum count of employees required for a department to be included in the results.", "virtual_table": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3496", "db_id": "hr_1", "question": "What is all the information regarding employees with salaries above the minimum and under 2500?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "It selects all columns from the 'employees' table.", "A condition is added to filter employees based on their salary, using a subquery to find the minimum salary and a placeholder for the upper limit of the salary range."], "gold_sql": "SELECT * FROM employees WHERE salary BETWEEN (SELECT MIN(salary) FROM employees) AND 2500", "source_tables": ["employees"], "description": "This virtual table retrieves all employee records from the 'employees' table whose salary falls within a specified range. The lower limit of the salary range is dynamically determined by selecting the minimum salary from the same table, while the upper limit is represented by a placeholder for numeric values.", "virtual_table": "SELECT * FROM employees WHERE salary BETWEEN (SELECT MIN(salary) FROM employees) AND [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3500", "db_id": "hr_1", "question": "What are the full names and hire dates for employees in the same department as someone with the first name Clara?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Select the columns to display: 'first_name', 'last_name', and 'hire_date'.", "Add a condition to filter the 'department_id' by using a subquery that retrieves the 'department_id' of an employee based on their first name, with a placeholder for the first name value."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  (SELECT department_id FROM employees WHERE first_name  =  'Clara')", "source_tables": ["employees"], "description": "This virtual table provides the first names, last names, and hire dates of employees from the 'employees' table who belong to the same department as a specified employee. The placeholder in the subquery represents the first name of the employee whose department is being queried.", "virtual_table": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  (SELECT department_id FROM employees WHERE first_name  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.3502", "db_id": "hr_1", "question": "What are the full names and hire dates for employees in the same department as someone with the first name Clara, not including Clara?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Select the columns to display: 'first_name', 'last_name', and 'hire_date'.", "Add a condition to filter the 'department_id' by using a subquery that finds the department of a specified employee based on their first name.", "Include an additional condition to exclude the specified employee's first name from the results."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  ( SELECT department_id FROM employees WHERE first_name  =  'Clara') AND first_name != 'Clara'", "source_tables": ["employees"], "description": "This virtual table provides the first names, last names, and hire dates of employees from the 'employees' table who belong to the same department as a specified employee, while excluding the specified employee's name. The placeholders in the WHERE clause represent the first name of the employee to find the department and the first name to exclude.", "virtual_table": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  ( SELECT department_id FROM employees WHERE first_name  =  [PLACEHOLDER-TYPE:STRING]) AND first_name != [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3503", "db_id": "hr_1", "question": "display the employee number and name( first name and last name ) for all employees who work in a department with any employee whose name contains a \u2019T\u2019.", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Select the columns to display: 'employee_id', 'first_name', and 'last_name'.", "Add a condition to filter the 'department_id' using a subquery that selects 'department_id' from the 'employees' table where the 'first_name' matches a specified value, using a placeholder for string values."], "gold_sql": "SELECT employee_id ,  first_name ,  last_name FROM employees WHERE department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE '%T%' )", "source_tables": ["employees"], "description": "This virtual table describes the employee ID, first name, and last name of employees from the 'employees' table who belong to the same department as a specified employee. The placeholder in the WHERE clause represents the first name of the employee whose department is being queried.", "virtual_table": "SELECT employee_id ,  first_name ,  last_name FROM employees WHERE department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE [PLACEHOLDER-TYPE:STRING] )"}
{"sample_id": "train.3507", "db_id": "hr_1", "question": "display the employee number and job id for all employees whose salary is smaller than any salary of those employees whose job title is MK_MAN.", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Select the columns to display, 'employee_id' and 'job_id'.", "Add a condition to filter employees whose salary is less than a certain value.", "The subquery retrieves the minimum salary for a specified job using a placeholder for the job identifier."], "gold_sql": "SELECT employee_id ,  job_id FROM employees WHERE salary  <  ( SELECT min(salary) FROM employees WHERE job_id  =  'MK_MAN' )", "source_tables": ["employees"], "description": "This virtual table provides a list of employee IDs and their corresponding job IDs from the 'employees' table, specifically for those employees whose salary is less than the minimum salary for a specified job. The placeholder in the subquery represents the job identifier for which the minimum salary is being compared.", "virtual_table": "SELECT employee_id ,  job_id FROM employees WHERE salary  <  ( SELECT min(salary) FROM employees WHERE job_id  =  [PLACEHOLDER-TYPE:STRING] )"}
{"sample_id": "train.3512", "db_id": "hr_1", "question": "What are total salaries and department id for each department that has more than 2 employees?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "It selects the 'department_id' and calculates the total salary using SUM(salary).", "The results are grouped by 'department_id' to aggregate the salaries for each department.", "A condition is added in the HAVING clause to filter departments based on the number of employees, using a placeholder for numeric values."], "gold_sql": "SELECT department_id ,  SUM(salary) FROM employees GROUP BY department_id HAVING count(*)  >=  2", "source_tables": ["employees"], "description": "This virtual table summarizes the total salary of employees grouped by their department. It includes only those departments that have a minimum number of employees, as specified by the placeholder in the HAVING clause.", "virtual_table": "SELECT department_id ,  SUM(salary) FROM employees GROUP BY department_id HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3515", "db_id": "hr_1", "question": "display the department ID, full name (first and last name), salary for those employees who is highest salary in every department.", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Selects the columns to display: 'first_name', 'last_name', 'salary', and 'department_id'.", "Uses the MAX function to find the highest salary within each department.", "Groups the results by 'department_id' to aggregate the data accordingly."], "gold_sql": "SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id", "source_tables": ["employees"], "description": "This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.", "virtual_table": "SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id"}
{"sample_id": "train.3520", "db_id": "hr_1", "question": "What are the full names and cities of employees who have the letter Z in their first names?", "rationale": ["The query identifies the relevant tables: 'employees', 'departments', and 'locations'.", "It selects the 'first_name' and 'last_name' from the 'employees' table and 'city' from the 'locations' table.", "A JOIN operation is performed between 'employees' and 'departments' on 'department_id', and between 'departments' and 'locations' on 'location_id'.", "A condition is added to filter the results based on the 'first_name' using a placeholder for string values."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T3.city FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id WHERE T1.first_name LIKE '%z%'", "source_tables": ["employees", "departments", "locations"], "description": "This virtual table provides the first and last names of employees along with the city of their department's location. The data is sourced from the 'employees', 'departments', and 'locations' tables, with a filter applied to the first name of the employees using a placeholder for string values.", "virtual_table": "SELECT T1.first_name ,  T1.last_name ,  T3.city FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id WHERE T1.first_name LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3523", "db_id": "hr_1", "question": "display the full name (first and last name ) of employee with ID and name of the country presently where (s)he is working.", "rationale": ["The query identifies the relevant tables: 'employees', 'departments', 'locations', and 'countries'.", "It selects the 'first_name', 'last_name', and 'employee_id' from the 'employees' table (aliased as T1).", "It joins the 'departments' table (T2) on the 'department_id' to associate employees with their departments.", "It further joins the 'locations' table (T3) on 'location_id' to link departments to their locations.", "Finally, it joins the 'countries' table (T4) on 'country_id' to retrieve the country names associated with the locations."], "gold_sql": "SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id", "source_tables": ["countries", "employees", "departments", "locations"], "description": "This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.", "virtual_table": "SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id"}
{"sample_id": "train.3525", "db_id": "hr_1", "question": "display the department name and number of employees in each of the department.", "rationale": ["The query identifies the relevant tables, which are 'employees' and 'departments'.", "It selects the 'department_name' from the 'departments' table and counts the number of employees from the 'employees' table.", "A JOIN operation is performed on the 'department_id' to link employees to their respective departments.", "The results are grouped by 'department_name' to provide a count of employees per department."], "gold_sql": "SELECT department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY department_name", "source_tables": ["employees", "departments"], "description": "This virtual table provides a summary of the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT statement allows for the retrieval of the department name along with the count of employees in that department.", "virtual_table": "SELECT department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY department_name"}
{"sample_id": "train.3526", "db_id": "hr_1", "question": "What are the department names and how many employees work in each of them?", "rationale": ["The query identifies the relevant tables, which are 'employees' and 'departments'.", "It selects the 'department_name' from the 'departments' table and counts the number of employees in each department.", "A JOIN operation is performed on the 'department_id' to link employees to their respective departments.", "The results are grouped by 'department_name' to provide a count of employees per department."], "gold_sql": "SELECT department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY department_name", "source_tables": ["employees", "departments"], "description": "This virtual table provides a count of employees grouped by their respective department names from the 'employees' and 'departments' tables. The placeholder in the COUNT function allows for dynamic counting of employees in each department.", "virtual_table": "SELECT department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY department_name"}
{"sample_id": "train.3527", "db_id": "hr_1", "question": "display the full name (first and last name), and salary of those employees who working in any department located in London.", "rationale": ["The query identifies the relevant tables: 'employees', 'departments', and 'locations'.", "It selects the columns to display: 'first_name', 'last_name', and 'salary'.", "It joins the 'employees' table with the 'departments' table on the 'department_id' column.", "It further joins the 'departments' table with the 'locations' table on the 'location_id' column.", "A condition is added to filter the results based on the 'city' column in the 'locations' table using a placeholder for string values."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  'London'", "source_tables": ["employees", "departments", "locations"], "description": "This virtual table describes the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.", "virtual_table": "SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3528", "db_id": "hr_1", "question": "What are full names and salaries of employees working in the city of London?", "rationale": ["The query identifies the relevant tables: 'employees', 'departments', and 'locations'.", "It selects the columns to display: 'first_name', 'last_name', and 'salary'.", "It joins the 'employees' table with the 'departments' table on the 'department_id' column.", "It further joins the 'departments' table with the 'locations' table on the 'location_id' column.", "A condition is added to filter the results based on the 'city' column in the 'locations' table using a placeholder for string values."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  'London'", "source_tables": ["employees", "departments", "locations"], "description": "This virtual table describes the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.", "virtual_table": "SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3532", "db_id": "music_1", "question": "Find the id of the song that lasts the longest.", "rationale": ["The query identifies the relevant table, which is 'files'.", "It selects the 'f_id' column to display the unique identifiers of the files.", "The results are ordered by the 'duration' column in descending order to show the longest files first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT f_id FROM files ORDER BY duration DESC LIMIT 1", "source_tables": ["files"], "description": "This virtual table provides a list of file identifiers from the 'files' table, ordered by the duration of the audio files in descending order. The placeholder in the LIMIT clause indicates the maximum number of file identifiers to return.", "virtual_table": "SELECT f_id FROM files ORDER BY duration DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3542", "db_id": "music_1", "question": "What are the names of the artists who sang the shortest song?", "rationale": ["The query identifies the relevant tables, 'song' and 'files', and uses a JOIN to combine them based on the matching 'f_id'.", "It selects the 'artist_name' from the 'song' table (aliased as T1).", "The JOIN condition ensures that only songs with corresponding files are included.", "The results are ordered by the 'duration' from the 'files' table (aliased as T2).", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.artist_name FROM song AS T1 JOIN files AS T2 ON T1.f_id  =  T2.f_id ORDER BY T2.duration LIMIT 1", "source_tables": ["files", "song"], "description": "This virtual table lists the names of artists from the 'song' table, joined with the 'files' table to access the duration of their songs. The results are ordered by the duration of the audio files, and a placeholder is used to limit the number of results returned.", "virtual_table": "SELECT T1.artist_name FROM song AS T1 JOIN files AS T2 ON T1.f_id  =  T2.f_id ORDER BY T2.duration LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3545", "db_id": "music_1", "question": "How many songs have 4 minute duration?", "rationale": ["The query identifies the relevant table, which is 'files'.", "It selects a count of all records that meet a certain condition.", "The condition filters the records based on the 'duration' column using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM files WHERE duration LIKE '4:%'", "source_tables": ["files"], "description": "This virtual table provides a count of audio files from the 'files' table that match a specific duration pattern. The placeholder in the WHERE clause represents the duration criteria to filter the files.", "virtual_table": "SELECT count(*) FROM files WHERE duration LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3549", "db_id": "music_1", "question": "What is the average rating of songs produced by female artists?", "rationale": ["The query identifies the relevant tables, which are 'artist' and 'song'.", "It uses a JOIN operation to connect these tables based on the 'artist_name' column.", "The SELECT statement calculates the average of the 'rating' column from the 'song' table.", "A WHERE clause is added to filter the results based on the 'gender' column from the 'artist' table, using a placeholder for string values."], "gold_sql": "SELECT avg(T2.rating) FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  'Female'", "source_tables": ["artist", "song"], "description": "This virtual table calculates the average rating of songs performed by artists of a specific gender. It joins the 'artist' and 'song' tables based on the artist's name, filtering the results to include only those artists whose gender matches the specified placeholder.", "virtual_table": "SELECT avg(T2.rating) FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3552", "db_id": "music_1", "question": "Find the file format that is used by the most files.", "rationale": ["The query identifies the relevant table, which is 'files'.", "Select the 'formats' column to display the different audio file formats.", "Group the results by 'formats' to aggregate the data based on format type.", "Order the results by the count of files in each format in descending order to show the most common formats first.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT formats FROM files GROUP BY formats ORDER BY COUNT (*) DESC LIMIT 1", "source_tables": ["files"], "description": "This virtual table provides a list of audio file formats from the 'files' table, grouped by format type. The results are ordered by the count of files in each format, allowing users to see the most common formats used. The placeholder in the LIMIT clause represents the maximum number of formats to return.", "virtual_table": "SELECT formats FROM files GROUP BY formats ORDER BY COUNT (*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3556", "db_id": "music_1", "question": "What is the id of the files that are available in the format of mp4 and a resolution smaller than 1000?", "rationale": ["The query is identifying the relevant tables, which are 'files' and 'song'.", "Select the column to display, 'f_id', which is the unique identifier for the file.", "Add a condition to filter the 'formats' column in the 'files' table for the specified format using a placeholder for string values.", "Use an INTERSECT to find common 'f_id' values between the two tables based on the specified conditions.", "Add a condition to filter the 'resolution' column in the 'song' table for values less than the specified number using a placeholder for numeric values."], "gold_sql": "SELECT f_id FROM files WHERE formats  =  'mp4' INTERSECT SELECT f_id FROM song WHERE resolution  <  1000", "source_tables": ["files", "song"], "description": "This virtual table identifies the unique file identifiers from the 'files' table that are available in a specific format and also exist in the 'song' table with a resolution lower than a specified value. The placeholders in the WHERE clauses represent the format of the file and the maximum resolution allowed.", "virtual_table": "SELECT f_id FROM files WHERE formats  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT f_id FROM song WHERE resolution  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3557", "db_id": "music_1", "question": "What is the country of origin of the artist who is female and produced a song in Bangla?", "rationale": ["The query identifies the relevant tables, 'artist' and 'song', and establishes a join condition based on the 'artist_name' column.", "It selects the 'country' column from the 'artist' table.", "The WHERE clause filters the results based on the specified gender of the artist and the languages of the songs, using placeholders for these values."], "gold_sql": "SELECT T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  'Female' AND T2.languages  =  'bangla'", "source_tables": ["artist", "song"], "description": "This virtual table provides a list of countries from which artists originate, filtered by the gender of the artist and the languages in which their songs are available. The placeholders in the WHERE clause represent the specific gender and language criteria.", "virtual_table": "SELECT T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  [PLACEHOLDER-TYPE:STRING] AND T2.languages  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3558", "db_id": "music_1", "question": "What countries are the female artists who sung in the language Bangla from?", "rationale": ["The query identifies the relevant tables, 'artist' and 'song', and establishes a join condition based on the artist's name.", "It selects the 'country' column from the 'artist' table.", "The WHERE clause filters the results based on the artist's gender and the languages of the songs, using placeholders for these criteria."], "gold_sql": "SELECT T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  'Female' AND T2.languages  =  'bangla'", "source_tables": ["artist", "song"], "description": "This virtual table provides a list of countries from which artists originate, filtered by the gender of the artist and the languages in which their songs are available. The placeholders in the WHERE clause represent the specific gender and language criteria.", "virtual_table": "SELECT T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  [PLACEHOLDER-TYPE:STRING] AND T2.languages  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3566", "db_id": "music_1", "question": "What is the gender and name of the artist who sang the song with the smallest resolution?", "rationale": ["The query identifies the relevant tables, which are 'artist' and 'song'.", "It selects the 'gender' and 'artist_name' columns from the 'artist' table (aliased as T1).", "A JOIN operation is performed between the 'artist' table and the 'song' table based on the 'artist_name' column to link artists with their songs.", "The results are ordered by the 'resolution' column from the 'song' table (aliased as T2).", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.gender ,  T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.resolution LIMIT 1", "source_tables": ["artist", "song"], "description": "This virtual table provides a list of artists along with their gender from the 'artist' table, specifically for those artists who have songs in the 'song' table. The results are ordered by the audio resolution of the songs, and the number of results returned is limited by a placeholder for numeric values.", "virtual_table": "SELECT T1.gender ,  T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.resolution LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3567", "db_id": "music_1", "question": "For each file format, return the number of artists who released songs in that format.", "rationale": ["The query identifies the relevant table, which is 'files'.", "It selects the count of files and groups the results by the 'formats' column.", "The use of count(*) allows us to aggregate the number of files for each unique format available."], "gold_sql": "SELECT count(*) ,  formats FROM files GROUP BY formats", "source_tables": ["files"], "description": "This virtual table provides a count of audio files grouped by their available formats from the 'files' table. The placeholder in the SELECT clause represents the count of files for each format.", "virtual_table": "SELECT count(*) ,  formats FROM files GROUP BY formats"}
{"sample_id": "train.3576", "db_id": "music_1", "question": "What are the names and genders of all artists who released songs in the month of March?", "rationale": ["The query identifies the relevant tables, which are 'artist' and 'song'.", "It selects the columns to display, 'artist_name' and 'gender' from the 'artist' table.", "A JOIN operation is performed on the 'artist' and 'song' tables based on the 'artist_name' column to link the two tables.", "A condition is added to filter the results based on the 'releasedate' column from the 'song' table using a placeholder for string values."], "gold_sql": "SELECT T1.artist_name ,  T1.gender FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.releasedate LIKE '%Mar%'", "source_tables": ["artist", "song"], "description": "This virtual table describes the names and genders of artists from the 'artist' table who have released songs on a specific date. The placeholder in the WHERE clause represents the release date of the songs.", "virtual_table": "SELECT T1.artist_name ,  T1.gender FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.releasedate LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3586", "db_id": "music_1", "question": "What are the languages that are used most often in songs?", "rationale": ["The query identifies the relevant table, which is 'song'.", "It selects the 'languages' column to display.", "The results are grouped by 'languages' to aggregate the data.", "The results are ordered by the count of songs in each language in descending order.", "A limit is applied to restrict the number of languages returned, using a placeholder for numeric values."], "gold_sql": "SELECT languages FROM song GROUP BY languages ORDER BY count(*) DESC LIMIT 1", "source_tables": ["song"], "description": "This virtual table provides a list of languages in which songs are available, grouped by language and ordered by the number of songs in each language. The placeholder in the LIMIT clause allows the user to specify the maximum number of languages to retrieve.", "virtual_table": "SELECT languages FROM song GROUP BY languages ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3590", "db_id": "music_1", "question": "What are the names of all male British artists?", "rationale": ["The query is identifying the relevant table, which is 'artist'.", "Select the column to display, 'artist_name'.", "Add conditions to filter the 'country' and 'gender' columns for the specified values using placeholders for string values."], "gold_sql": "SELECT artist_name FROM artist WHERE country  =  'UK' AND gender  =  'Male'", "source_tables": ["artist"], "description": "This virtual table describes the names of artists from the 'artist' table who are from a specific country and belong to a specific gender. The placeholders in the WHERE clause represent the country and gender of the artists.", "virtual_table": "SELECT artist_name FROM artist WHERE country  =  [PLACEHOLDER-TYPE:STRING] AND gender  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3598", "db_id": "music_1", "question": "What is the average rating and resolution of all bangla songs?", "rationale": ["The query identifies the relevant table, which is 'song'.", "It selects the average of the 'rating' and 'resolution' columns to provide aggregated data.", "A condition is added to filter the songs based on the specified language using a placeholder for string values."], "gold_sql": "SELECT avg(rating) ,  avg(resolution) FROM song WHERE languages  =  'bangla'", "source_tables": ["song"], "description": "This virtual table calculates the average rating and average resolution of songs from the 'song' table that are available in a specific language. The placeholder in the WHERE clause represents the language of the songs.", "virtual_table": "SELECT avg(rating) ,  avg(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3599", "db_id": "music_1", "question": "What are the maximum and minimum resolution of songs whose duration is 3 minutes?", "rationale": ["The query identifies the relevant tables, which are 'files' and 'song'.", "It uses a JOIN operation to connect these tables based on the foreign key relationship between 'files.f_id' and 'song.f_id'.", "The SELECT statement retrieves the maximum and minimum values of the 'resolution' column from the 'song' table.", "A condition is added to filter the results based on the 'duration' column from the 'files' table using a placeholder for string values."], "gold_sql": "SELECT max(T2.resolution) ,  min(T2.resolution) FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.duration LIKE '3:%'", "source_tables": ["files", "song"], "description": "This virtual table provides the maximum and minimum audio resolutions of songs from the 'song' table, filtered by the duration of the associated files in the 'files' table. The placeholder in the WHERE clause represents the specific duration pattern to match.", "virtual_table": "SELECT max(T2.resolution) ,  min(T2.resolution) FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.duration LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3601", "db_id": "music_1", "question": "What are the maximum duration and resolution of songs grouped and ordered by languages?", "rationale": ["The query identifies the relevant tables, 'files' and 'song', and uses a JOIN to connect them based on the foreign key relationship between 'f_id'.", "It selects the maximum duration from the 'files' table and the maximum resolution from the 'song' table, along with the languages from the 'song' table.", "The results are grouped by languages to provide a summary for each language category, and ordered by languages for better readability."], "gold_sql": "SELECT max(T1.duration) ,  max(T2.resolution) ,  T2.languages FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.languages ORDER BY T2.languages", "source_tables": ["files", "song"], "description": "This virtual table provides the maximum duration and resolution of audio files, along with the languages in which the songs are available. The data is aggregated by languages, allowing users to see the longest audio files and their highest resolutions for each language category.", "virtual_table": "SELECT max(T1.duration) ,  max(T2.resolution) ,  T2.languages FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.languages ORDER BY T2.languages"}
{"sample_id": "train.3603", "db_id": "music_1", "question": "What are the shortest duration and lowest rating of songs grouped by genre and ordered by genre?", "rationale": ["The query identifies the relevant tables, which are 'files' and 'song'.", "It selects the minimum duration from the 'files' table and the minimum rating from the 'song' table, along with the genre of the song.", "The JOIN operation links the two tables based on the file identifier, ensuring that the data corresponds correctly between audio files and songs.", "The results are grouped by the genre of the song to aggregate the data accordingly, and ordered by the genre for better readability."], "gold_sql": "SELECT min(T1.duration) ,  min(T2.rating) ,  T2.genre_is FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.genre_is ORDER BY T2.genre_is", "source_tables": ["files", "song"], "description": "This virtual table provides the minimum duration of audio files and the minimum rating of songs grouped by their genre. The placeholders represent the necessary fields from the 'files' and 'song' tables, allowing users to analyze the relationship between audio file durations and song ratings across different genres.", "virtual_table": "SELECT min(T1.duration) ,  min(T2.rating) ,  T2.genre_is FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.genre_is ORDER BY T2.genre_is"}
{"sample_id": "train.3607", "db_id": "music_1", "question": "Find the name and country of origin for all artists who have release at least one song of resolution above 900.", "rationale": ["The query identifies the relevant tables, which are 'artist' and 'song'.", "It selects the columns 'artist_name' and 'country' from the 'artist' table.", "A JOIN operation is performed between 'artist' and 'song' on the 'artist_name' column to combine relevant data.", "A condition is added to filter songs based on their resolution using a placeholder for numeric values.", "The results are grouped by 'artist_name' to aggregate the data for each artist.", "A HAVING clause is used to filter the grouped results to include only those artists with a count of songs that meets the specified threshold."], "gold_sql": "SELECT T1.artist_name ,  T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.resolution  >  900 GROUP BY T2.artist_name HAVING count(*)  >=  1", "source_tables": ["artist", "song"], "description": "This virtual table provides the names and countries of artists from the 'artist' table who have songs in the 'song' table with a resolution greater than a specified value. The results are grouped by artist name, and only those artists with a count of songs meeting the resolution criteria that is greater than or equal to a specified number are included.", "virtual_table": "SELECT T1.artist_name ,  T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.resolution  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.artist_name HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3619", "db_id": "music_1", "question": "Find the top 3 artists who have the largest number of songs works whose language is Bangla.", "rationale": ["The query identifies the relevant tables, which are 'artist' and 'song'.", "It selects the 'artist_name' from the 'artist' table.", "A JOIN operation is performed on the 'artist_name' column to link the two tables.", "A condition is added to filter the songs based on the specified language using a placeholder for string values.", "The results are grouped by 'artist_name' to aggregate the data.", "The results are ordered by the count of songs in descending order to show the most prolific artists first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.languages  =  'bangla' GROUP BY T2.artist_name ORDER BY count(*) DESC LIMIT 3", "source_tables": ["artist", "song"], "description": "This virtual table lists the names of artists from the 'artist' table who have songs available in a specific language. The query joins the 'artist' and 'song' tables on the artist's name, filters the results based on the specified language, groups the results by artist name, and orders them by the number of songs in descending order, limiting the output to a specified number of artists.", "virtual_table": "SELECT T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.languages  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T2.artist_name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3623", "db_id": "music_1", "question": "List the duration, file size and format of songs whose genre is pop, ordered by title?", "rationale": ["The query identifies the relevant tables, 'files' and 'song', and uses a JOIN to connect them based on the file identifier 'f_id'.", "It selects the columns 'duration', 'file_size', and 'formats' from the 'files' table.", "A condition is added to filter the results based on the genre of the songs using a placeholder for string values.", "The results are ordered by the song name for better organization."], "gold_sql": "SELECT T1.duration ,  T1.file_size ,  T1.formats FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T2.genre_is  =  'pop' ORDER BY T2.song_name", "source_tables": ["files", "song"], "description": "This virtual table provides information about the duration, file size, and available formats of audio files associated with songs from a specific genre. The placeholder in the WHERE clause represents the genre of the songs being queried.", "virtual_table": "SELECT T1.duration ,  T1.file_size ,  T1.formats FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T2.genre_is  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T2.song_name"}
{"sample_id": "train.3624", "db_id": "music_1", "question": "What is the duration, file size, and song format for every pop song, ordered by title alphabetically?", "rationale": ["The query identifies the relevant tables, 'files' and 'song', and uses a JOIN to connect them based on the file identifier 'f_id'.", "It selects the columns 'duration', 'file_size', and 'formats' from the 'files' table.", "A condition is added to filter the results based on the genre of the song using a placeholder for string values.", "The results are ordered by the song name for better organization."], "gold_sql": "SELECT T1.duration ,  T1.file_size ,  T1.formats FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T2.genre_is  =  'pop' ORDER BY T2.song_name", "source_tables": ["files", "song"], "description": "This virtual table provides information about the duration, file size, and available formats of audio files associated with songs from a specific genre. The placeholder in the WHERE clause represents the genre of interest.", "virtual_table": "SELECT T1.duration ,  T1.file_size ,  T1.formats FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T2.genre_is  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T2.song_name"}
{"sample_id": "train.3631", "db_id": "baseball_1", "question": "What is average salary of the players in the team named 'Boston Red Stockings' ?", "rationale": ["The query identifies the relevant tables, which are 'salary' and 'team'.", "It selects the average salary from the 'salary' table.", "A join is performed between the 'salary' table and the 'team' table using the team identifier to ensure the correct team is referenced.", "A condition is added to filter the results based on the specified team name using a placeholder for string values."], "gold_sql": "SELECT avg(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings'", "source_tables": ["team", "salary"], "description": "This virtual table calculates the average salary of players from a specific team. It joins the 'salary' table with the 'team' table based on the team identifier, filtering the results to include only the team with the specified name.", "virtual_table": "SELECT avg(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3650", "db_id": "baseball_1", "question": "What are the three countries that the least players are from?", "rationale": ["The query identifies the relevant table, which is 'player'.", "It selects the 'birth_country' column to display the countries of birth.", "The GROUP BY clause is used to group the results by 'birth_country'.", "The ORDER BY clause sorts the results by the count of players from each country in ascending order.", "The LIMIT clause uses a placeholder to allow the user to specify how many countries to return."], "gold_sql": "SELECT birth_country FROM player GROUP BY birth_country ORDER BY count(*) ASC LIMIT 3;", "source_tables": ["player"], "description": "This virtual table provides a list of countries where players were born, grouped by country and ordered by the number of players from each country in ascending order. The placeholder in the LIMIT clause allows for specifying the maximum number of countries to return.", "virtual_table": "SELECT birth_country FROM player GROUP BY birth_country ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3657", "db_id": "baseball_1", "question": "What is the highest salary among each team? List the team name, id and maximum salary.", "rationale": ["The query identifies the relevant tables, which are 'team' and 'salary'.", "It selects the 'name' and 'team_id' from the 'team' table and the maximum salary from the 'salary' table.", "A JOIN operation is performed on the 'team_id' to link the two tables based on the team identifier.", "The results are grouped by 'team_id' to ensure that each team appears only once with its maximum salary."], "gold_sql": "SELECT T1.name ,  T1.team_id ,  max(T2.salary) FROM team AS T1 JOIN salary AS T2 ON T1.team_id  =  T2.team_id GROUP BY T1.team_id;", "source_tables": ["team", "salary"], "description": "This virtual table provides the names and identifiers of teams along with their highest recorded salary from the 'salary' table. The data is grouped by team identifiers to ensure that each team is represented only once with its maximum salary.", "virtual_table": "SELECT T1.name ,  T1.team_id ,  max(T2.salary) FROM team AS T1 JOIN salary AS T2 ON T1.team_id  =  T2.team_id GROUP BY T1.team_id;"}
{"sample_id": "train.3658", "db_id": "baseball_1", "question": "For each team, return the team name, id and the maximum salary among the team.", "rationale": ["The query identifies the relevant tables, which are 'team' and 'salary'.", "It selects the 'name' and 'team_id' from the 'team' table and the maximum salary from the 'salary' table.", "A JOIN operation is performed on the 'team_id' to link the two tables based on the team identifier.", "The results are grouped by 'team_id' to ensure that each team appears only once with its maximum salary."], "gold_sql": "SELECT T1.name ,  T1.team_id ,  max(T2.salary) FROM team AS T1 JOIN salary AS T2 ON T1.team_id  =  T2.team_id GROUP BY T1.team_id;", "source_tables": ["team", "salary"], "description": "This virtual table provides the names and identifiers of teams along with their highest recorded salary from the 'salary' table. The data is grouped by team identifiers to ensure that each team is represented only once with its maximum salary.", "virtual_table": "SELECT T1.name ,  T1.team_id ,  max(T2.salary) FROM team AS T1 JOIN salary AS T2 ON T1.team_id  =  T2.team_id GROUP BY T1.team_id;"}
{"sample_id": "train.3659", "db_id": "baseball_1", "question": "What are the name and id of the team offering the lowest average salary?", "rationale": ["The query identifies the relevant tables, 'team' and 'salary'.", "It selects the 'name' and 'team_id' from the 'team' table (aliased as T1).", "It joins the 'team' table with the 'salary' table (aliased as T2) on the 'team_id' column to associate teams with their players' salaries.", "The results are grouped by 'team_id' to calculate the average salary for each team.", "The results are ordered by the average salary in ascending order.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.name ,  T1.team_id FROM team AS T1 JOIN salary AS T2 ON T1.team_id = T2.team_id GROUP BY T1.team_id ORDER BY avg(T2.salary) ASC LIMIT 1;", "source_tables": ["team", "salary"], "description": "This virtual table provides a list of team names and their corresponding team IDs from the 'team' table, along with the average salary of players from each team. The results are ordered by the average salary in ascending order, and the number of results returned is limited by a placeholder for numeric values.", "virtual_table": "SELECT T1.name ,  T1.team_id FROM team AS T1 JOIN salary AS T2 ON T1.team_id = T2.team_id GROUP BY T1.team_id ORDER BY avg(T2.salary) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3661", "db_id": "baseball_1", "question": "Find the players' first name and last name who won award both in 1960 and in 1961.", "rationale": ["The query starts by selecting the first and last names of players from the 'player' table, aliased as T1.", "It joins the 'player_award' table, aliased as T2, to filter players based on the year of the award.", "The first part of the query specifies a year using a placeholder for numeric values.", "The INTERSECT operator is used to find players who also received awards in a second specified year, again using a placeholder for numeric values."], "gold_sql": "SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1960 INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1961", "source_tables": ["player_award", "player"], "description": "This virtual table identifies players who received awards in two different years. It selects the first and last names of players from the 'player' table who have awards recorded in the 'player_award' table for the specified years. The use of INTERSECT ensures that only players who received awards in both years are included in the results.", "virtual_table": "SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3663", "db_id": "baseball_1", "question": "List players' first name and last name who have weight greater than 220 or height shorter than 75.", "rationale": ["The query identifies the relevant table, which is 'player'.", "Select the columns to display, 'name_first' and 'name_last'.", "Add conditions to filter the 'weight' and 'height' columns using placeholders for numeric values."], "gold_sql": "SELECT name_first ,  name_last FROM player WHERE weight  >  220 OR height  <  75", "source_tables": ["player"], "description": "This virtual table describes the first and last names of players from the 'player' table who either weigh more than a specified amount or are shorter than a specified height. The placeholders in the WHERE clause represent the weight and height criteria.", "virtual_table": "SELECT name_first ,  name_last FROM player WHERE weight  >  [PLACEHOLDER-TYPE:NUMBER] OR height  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3664", "db_id": "baseball_1", "question": "What are the first name and last name of the players who have weight above 220 or height below 75?", "rationale": ["The query identifies the relevant table, which is 'player'.", "Select the columns to display, 'name_first' and 'name_last'.", "Add a condition to filter the 'weight' column for values greater than a specified number and the 'height' column for values less than a specified number using placeholders for numeric values."], "gold_sql": "SELECT name_first ,  name_last FROM player WHERE weight  >  220 OR height  <  75", "source_tables": ["player"], "description": "This virtual table describes the first and last names of players from the 'player' table who either weigh more than a specified amount or are shorter than a specified height. The placeholders in the WHERE clause represent the weight and height criteria.", "virtual_table": "SELECT name_first ,  name_last FROM player WHERE weight  >  [PLACEHOLDER-TYPE:NUMBER] OR height  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3665", "db_id": "baseball_1", "question": "List the maximum scores of the team Boston Red Stockings when the team won in postseason?", "rationale": ["The query identifies the relevant tables, 'postseason' and 'team'.", "It selects the maximum wins from the 'postseason' table.", "A JOIN is performed between 'postseason' and 'team' on the winning team identifier to link the team name.", "A condition is added to filter the results based on the specified team name using a placeholder for string values."], "gold_sql": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings';", "source_tables": ["postseason", "team"], "description": "This virtual table calculates the maximum number of wins achieved by any team in the postseason from the 'postseason' table, specifically for the team identified by its name in the 'team' table. The placeholder in the WHERE clause represents the name of the team being queried.", "virtual_table": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.3666", "db_id": "baseball_1", "question": "What are the maximum scores the team Boston Red Stockings got when the team won in postseason?", "rationale": ["The query identifies the relevant tables, 'postseason' and 'team'.", "It selects the maximum wins from the 'postseason' table.", "A JOIN operation is performed to link the winning team from the 'postseason' table with the corresponding team name from the 'team' table.", "A condition is added to filter the results based on the specified team name using a placeholder for string values."], "gold_sql": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings';", "source_tables": ["postseason", "team"], "description": "This virtual table calculates the maximum number of wins achieved by any team in the postseason, specifically for a team identified by its name. The placeholder in the WHERE clause represents the name of the team being queried.", "virtual_table": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING];"}
