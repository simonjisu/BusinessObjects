{"sample_id": "train.2418", "db_id": "candidate_poll", "question": "which gender got the highest average uncertain ratio.", "rationale": ["The query identifies the relevant tables, 'people' and 'candidate', and establishes a join condition on the 'People_ID' field.", "It selects the 'sex' column from the 'people' table.", "The results are grouped by 'sex' to aggregate the data accordingly.", "The average of the 'unsure_rate' from the 'candidate' table is calculated to order the results.", "The LIMIT clause includes a placeholder to specify how many results to return."], "gold_sql": "SELECT t1.sex FROM people AS t1 JOIN candidate AS t2 ON t1.people_id  =  t2.people_id GROUP BY t1.sex ORDER BY avg(t2.unsure_rate) DESC LIMIT 1", "source_tables": ["candidate", "people"], "description": "This virtual table provides the gender distribution of candidates based on their support rates. It joins the 'people' and 'candidate' tables on the 'People_ID' field, grouping the results by gender and ordering them by the average unsure rate of the candidates. The placeholder in the LIMIT clause allows for specifying the number of results to return.", "virtual_table": "SELECT t1.sex FROM people AS t1 JOIN candidate AS t2 ON t1.people_id  =  t2.people_id GROUP BY t1.sex ORDER BY avg(t2.unsure_rate) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2398", "db_id": "candidate_poll", "question": "what are the top 3 highest support rates?", "rationale": ["The query identifies the relevant table, which is 'candidate'.", "It selects the 'support_rate' column to display the support rates of candidates.", "The results are ordered in descending order based on the support rate to show the highest rates first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT support_rate FROM candidate ORDER BY support_rate DESC LIMIT 3", "source_tables": ["candidate"], "description": "This virtual table provides the support rates of candidates from the 'candidate' table, ordered from highest to lowest. The placeholder in the LIMIT clause indicates the maximum number of results to return.", "virtual_table": "SELECT support_rate FROM candidate ORDER BY support_rate DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.161", "db_id": "car_1", "question": "How many countries has more than 2 car makers ?", "rationale": ["The query identifies the relevant tables, which are 'countries' and 'car_makers'.", "It performs a join between these tables on the country identifier to associate car makers with their respective countries.", "The query counts the number of car makers for each country using the COUNT function and groups the results by country.", "The HAVING clause filters the results to include only those countries that have a count of car makers greater than a specified number, represented by a placeholder."], "gold_sql": "select count(*) from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  2", "source_tables": ["car_makers", "countries"], "description": "This virtual table provides the count of car makers for each country from the 'countries' and 'car_makers' tables. The placeholder in the HAVING clause represents the minimum number of car makers required for a country to be included in the results.", "virtual_table": "select count(*) from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.162", "db_id": "car_1", "question": "What is the number of countries with more than 2 car makers ?", "rationale": ["The query identifies the relevant tables, which are 'countries' and 'car_makers'.", "It performs a join between these two tables on the country identifier to associate car makers with their respective countries.", "The query counts the number of car makers for each country using the COUNT function and groups the results by country.", "A condition is added in the HAVING clause to filter the results to only include countries with a count of car makers greater than a specified number, using a placeholder for numeric values."], "gold_sql": "select count(*) from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  2", "source_tables": ["car_makers", "countries"], "description": "This virtual table provides the count of car makers for each country from the 'countries' and 'car_makers' tables. It filters the results to show only those countries that have more than a specified number of car makers, represented by a placeholder in the HAVING clause.", "virtual_table": "select count(*) from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.175", "db_id": "car_1", "question": "Which are the car makers which produce at least 2 models and more than 3 car makers ? List the id and the maker .", "rationale": ["The query starts by selecting the 'id' and 'maker' from the 'car_makers' table, aliased as t1.", "It joins the 'model_list' table, aliased as t2, on the condition that the 'id' from 'car_makers' matches the 'maker' in 'model_list'.", "The results are grouped by 'id' and filtered using a HAVING clause to ensure that the count of models is greater than or equal to a specified number, represented by a placeholder.", "The query then intersects with another selection that also retrieves 'id' and 'maker' from 'car_makers', joining with 'model_list' and 'car_names' to ensure that the models have associated names.", "This second part also groups by 'id' and filters with a HAVING clause for a count greater than a different specified number, also represented by a placeholder."], "gold_sql": "select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker group by t1.id having count(*)  >=  2 intersect select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker join car_names as t3 on t2.model  =  t3.model group by t1.id having count(*)  >  3;", "source_tables": ["car_makers", "car_names", "model_list"], "description": "This virtual table identifies car makers who have produced a significant number of car models and have those models associated with specific car names. The placeholders in the HAVING clauses represent the minimum counts of models and names that must be met for the car makers to be included in the results.", "virtual_table": "select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker group by t1.id having count(*)  >=  [PLACEHOLDER-TYPE:NUMBER] intersect select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker join car_names as t3 on t2.model  =  t3.model group by t1.id having count(*)  >  [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.102", "db_id": "car_1", "question": "What is the maker of the carr produced in the earliest year and what year was it?", "rationale": ["The query identifies the relevant tables, which are 'cars_data' and 'car_names'.", "It selects the 'Make' from 'car_names' and 'Year' from 'cars_data'.", "A JOIN operation is performed on 'cars_data' and 'car_names' using the 'Id' and 'MakeId' columns to link the car data with their respective makes.", "A subquery is used to find the minimum year from the 'cars_data' table, ensuring that only the earliest manufactured cars are included in the results."], "gold_sql": "SELECT T2.Make ,  T1.Year FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T1.Year  =  (SELECT min(YEAR) FROM CARS_DATA);", "source_tables": ["cars_data", "car_names"], "description": "This virtual table provides the make of the car and the year it was manufactured from the 'cars_data' and 'car_names' tables. The query filters the results to show only the car models that were manufactured in the earliest year recorded in the 'cars_data' table.", "virtual_table": "SELECT T2.Make ,  T1.Year FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T1.Year  =  (SELECT min(YEAR) FROM CARS_DATA);"}
{"sample_id": "dev.171", "db_id": "car_1", "question": "Which models are lighter than 3500 but not built by the 'Ford Motor Company'?", "rationale": ["The query identifies the relevant tables: 'model_list', 'car_names', 'cars_data', and 'car_makers'.", "It selects distinct car models from the 'model_list' table.", "The query joins the 'model_list' with 'car_names' to link models to their makes.", "It further joins with 'cars_data' to filter based on the weight of the cars.", "Finally, it joins with 'car_makers' to exclude certain car makers based on their full name, using a placeholder for the name."], "gold_sql": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.Model  =  T2.Model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.Id JOIN CAR_MAKERS AS T4 ON T1.Maker  =  T4.Id WHERE T3.weight  <  3500 AND T4.FullName != 'Ford Motor Company';", "source_tables": ["car_makers", "model_list", "car_names", "cars_data"], "description": "This virtual table provides a list of distinct car models from the 'model_list' table that meet specific criteria. It filters the results based on the weight of the cars from the 'cars_data' table, ensuring that only cars lighter than a specified weight are included. Additionally, it excludes car makers based on their full name from the 'car_makers' table, using a placeholder for the name to be excluded.", "virtual_table": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.Model  =  T2.Model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.Id JOIN CAR_MAKERS AS T4 ON T1.Maker  =  T4.Id WHERE T3.weight  <  [PLACEHOLDER-TYPE:NUMBER] AND T4.FullName != [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "dev.130", "db_id": "car_1", "question": "What are the names of all European countries with at least 3 manufacturers?", "rationale": ["The query identifies the relevant tables: 'countries', 'continents', and 'car_makers'.", "It selects the 'CountryName' from the 'countries' table.", "The JOIN operation connects 'countries' with 'continents' based on the continent identifier, allowing filtering by continent.", "Another JOIN connects 'countries' with 'car_makers' to ensure that only countries with car makers are included.", "The WHERE clause filters the results based on the specified continent using a placeholder for string values.", "The GROUP BY clause groups the results by 'CountryName' to aggregate the data.", "The HAVING clause ensures that only countries with a count of car makers greater than or equal to a specified number are included, using a placeholder for numeric values."], "gold_sql": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  'europe' GROUP BY T1.CountryName HAVING count(*)  >=  3;", "source_tables": ["continents", "car_makers", "countries"], "description": "This virtual table lists the names of countries from the 'countries' table that belong to a specific continent. It joins the 'continents' table to filter countries by continent and the 'car_makers' table to ensure that the countries have car makers associated with them. The placeholders in the WHERE clause represent the continent's name and the minimum count of car makers per country.", "virtual_table": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.CountryName HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.141", "db_id": "car_1", "question": "Which model has the most version(make) of cars?", "rationale": ["The query identifies the relevant table, which is 'car_names'.", "It selects the 'Model' column to display the names of car models.", "The results are grouped by 'Model' to aggregate the data based on unique model names.", "The query orders the results by the count of each model in descending order to show the most common models first.", "Finally, it limits the output to a specified number of top models using a placeholder for numeric values."], "gold_sql": "SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["car_names"], "description": "The virtual table describes the car models from the 'car_names' table, grouped by model name. It orders the results by the count of occurrences of each model in descending order and limits the output to a specified number of top models. The placeholder in the LIMIT clause represents the maximum number of models to return.", "virtual_table": "SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.142", "db_id": "car_1", "question": "What model has the most different versions?", "rationale": ["The query identifies the relevant table, which is 'car_names'.", "It selects the 'Model' column to display the names of car models.", "The results are grouped by 'Model' to aggregate the data based on model names.", "The query orders the grouped results by the count of each model in descending order to show the most common models first.", "Finally, it limits the output to a specified number of top models using a placeholder for numeric values."], "gold_sql": "SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["car_names"], "description": "The virtual table describes the car models from the 'car_names' table, grouped by model name. It orders the results by the count of occurrences of each model in descending order and limits the output to a specified number of top models. The placeholder in the LIMIT clause represents the maximum number of models to return.", "virtual_table": "SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.104", "db_id": "car_1", "question": "What are the different models for the cards produced after 1980?", "rationale": ["The query identifies the relevant tables: 'model_list', 'car_names', and 'cars_data'.", "It selects distinct car models from the 'model_list' table.", "The join operation connects 'model_list' with 'car_names' based on the model name.", "Another join connects 'car_names' with 'cars_data' using the MakeId to filter the results.", "A condition is added to filter the results based on the manufacturing year using a placeholder for numeric values."], "gold_sql": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  1980;", "source_tables": ["model_list", "car_names", "cars_data"], "description": "This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models and then further joins with the 'cars_data' table to filter based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.", "virtual_table": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.157", "db_id": "car_1", "question": "For model volvo, how many cylinders does the car with the least accelerate have?", "rationale": ["The query identifies the relevant tables, 'cars_data' and 'car_names', and uses a JOIN to connect them based on the matching 'Id' and 'MakeId'.", "It selects the 'cylinders' column from the 'cars_data' table.", "A condition is added to filter results based on the specified car model using a placeholder for string values.", "The results are ordered by the 'accelerate' column in ascending order to show the fastest accelerating cars first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  'volvo' ORDER BY T1.accelerate ASC LIMIT 1;", "source_tables": ["cars_data", "car_names"], "description": "This virtual table provides the number of cylinders for cars from the 'cars_data' table, filtered by a specific car model from the 'car_names' table. The results are ordered by the acceleration time in ascending order, and the limit on the number of results can be specified using a placeholder for numeric values.", "virtual_table": "SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.accelerate ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.97", "db_id": "car_1", "question": "Find the model of the car whose weight is below the average weight.", "rationale": ["The query identifies the relevant tables, which are 'car_names' and 'cars_data'.", "It selects the 'model' column from the 'car_names' table.", "A JOIN operation is performed between 'car_names' and 'cars_data' on the condition that 'MakeId' from 'car_names' matches 'Id' from 'cars_data'.", "A condition is added to filter the results where the weight of the cars in 'cars_data' is less than the average weight calculated from the same table using a subquery."], "gold_sql": "SELECT T1.model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Weight  <  (SELECT avg(Weight) FROM CARS_DATA)", "source_tables": ["car_names", "cars_data"], "description": "The virtual table describes the car models from the 'car_names' table that have a weight less than the average weight of all cars in the 'cars_data' table. The query uses a subquery to calculate the average weight, ensuring that only lighter models are selected.", "virtual_table": "SELECT T1.model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Weight  <  (SELECT avg(Weight) FROM CARS_DATA)"}
{"sample_id": "dev.121", "db_id": "car_1", "question": "What are all the makers and models?", "rationale": ["The query identifies the relevant table, which is 'model_list'.", "Select the columns to display, 'Maker' and 'Model'.", "This query provides a list of car makers along with their corresponding car models without any filtering conditions."], "gold_sql": "SELECT Maker ,  Model FROM MODEL_LIST;", "source_tables": ["model_list"], "description": "This virtual table describes the relationship between car makers and their respective car models from the 'model_list' table. The placeholders represent the identifiers for the car makers and models.", "virtual_table": "SELECT Maker ,  Model FROM MODEL_LIST;"}
{"sample_id": "dev.122", "db_id": "car_1", "question": "What are the makers and models?", "rationale": ["The query identifies the relevant table, which is 'model_list'.", "Select the columns to display, 'Maker' and 'Model'.", "This query provides a list of car makers along with their corresponding car models without any filtering conditions."], "gold_sql": "SELECT Maker ,  Model FROM MODEL_LIST;", "source_tables": ["model_list"], "description": "The virtual table describes the relationship between car makers and their respective car models from the 'model_list' table. The placeholders represent the identifiers for the car makers and models.", "virtual_table": "SELECT Maker ,  Model FROM MODEL_LIST;"}
{"sample_id": "dev.112", "db_id": "car_1", "question": "How much does the car accelerate that makes amc hornet sportabout (sw)?", "rationale": ["The query identifies the relevant tables, which are 'cars_data' and 'car_names'.", "It selects the 'Accelerate' column from the 'cars_data' table.", "A JOIN operation is performed to link 'cars_data' with 'car_names' based on the matching 'Id' and 'MakeId'.", "A condition is added to filter the results based on the specified car make using a placeholder for string values."], "gold_sql": "SELECT T1.Accelerate FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Make  =  'amc hornet sportabout (sw)';", "source_tables": ["cars_data", "car_names"], "description": "The virtual table describes the acceleration times of cars from the 'cars_data' table, filtered by a specific car make from the 'car_names' table. The placeholder in the WHERE clause represents the name of the car make.", "virtual_table": "SELECT T1.Accelerate FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Make  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "dev.134", "db_id": "car_1", "question": "What is the car model with the highest mpg ?", "rationale": ["The query identifies the relevant tables, 'car_names' and 'cars_data'.", "It selects the 'model' column from the 'car_names' table, which contains the names of the car models.", "A JOIN operation is performed between 'car_names' and 'cars_data' on the condition that 'makeid' from 'car_names' matches 'id' from 'cars_data'.", "The results are ordered by the 'mpg' column from 'cars_data' in descending order to show the most fuel-efficient models first.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "select t1.model from car_names as t1 join cars_data as t2 on t1.makeid  =  t2.id order by t2.mpg desc limit 1;", "source_tables": ["car_names", "cars_data"], "description": "This virtual table lists car models from the 'car_names' table, ordered by their miles per gallon (MPG) fuel efficiency from the 'cars_data' table. The placeholder in the LIMIT clause represents the maximum number of car models to display.", "virtual_table": "select t1.model from car_names as t1 join cars_data as t2 on t1.makeid  =  t2.id order by t2.mpg desc limit [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.96", "db_id": "car_1", "question": "What is the model of the car with the smallest amount of horsepower?", "rationale": ["The query identifies the relevant tables, which are 'car_names' and 'cars_data'.", "It selects the 'Model' column from the 'car_names' table.", "A JOIN operation is performed between 'car_names' and 'cars_data' on the condition that 'MakeId' from 'car_names' matches 'Id' from 'cars_data'.", "The results are ordered by the 'horsepower' column from 'cars_data' in ascending order.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "description": "The virtual table describes the car models from the 'car_names' table, ordered by their horsepower in ascending order. The placeholder in the LIMIT clause represents the maximum number of car models to be returned.", "virtual_table": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.116", "db_id": "car_1", "question": "What is the count of the car models produced in the United States?", "rationale": ["The query identifies the relevant tables: 'model_list', 'car_makers', and 'countries'.", "It uses a JOIN operation to connect 'model_list' with 'car_makers' based on the 'Maker' identifier.", "Another JOIN is performed to connect 'car_makers' with 'countries' using the 'Country' identifier.", "The query counts the number of car models that match the specified country name, using a placeholder for the country name in the WHERE clause."], "gold_sql": "SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  'usa';", "source_tables": ["car_makers", "model_list", "countries"], "description": "This virtual table provides the count of car models from the 'model_list' table that are associated with car makers from a specific country. The placeholders in the WHERE clause represent the name of the country being queried.", "virtual_table": "SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.6290", "db_id": "city_record", "question": "Give me a list of cities whose temperature in Mar is lower than that in July and which have also served as host cities?", "rationale": ["The query is identifying the relevant tables, which are 'city', 'temperature', and 'hosting_city'.", "It selects the 'city' column from the 'city' table.", "The first part of the query filters cities based on the condition that the average temperature in March is less than in July using a join with the 'temperature' table.", "The second part of the query identifies cities that have hosted a match by joining the 'city' table with the 'hosting_city' table.", "The INTERSECT operator is used to find common cities that meet both conditions."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul INTERSECT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "description": "This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.", "virtual_table": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul INTERSECT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city"}
{"sample_id": "train.6291", "db_id": "city_record", "question": "Which cities have lower temperature in March than in July and have been once host cities?", "rationale": ["The query is identifying the relevant tables, which are 'city', 'temperature', and 'hosting_city'.", "It selects the 'city' column from the 'city' table.", "The first part of the query filters cities based on the condition that the average temperature in March is less than in July using a join with the 'temperature' table.", "The second part of the query identifies cities that have hosted a match by joining the 'city' table with the 'hosting_city' table.", "The INTERSECT operator is used to find common cities that meet both conditions."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul INTERSECT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "description": "This virtual table identifies cities where the average temperature in March is lower than in July and that have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.", "virtual_table": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul INTERSECT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city"}
{"sample_id": "train.6299", "db_id": "city_record", "question": "Which cities have regional population above 8000000 or below 5000000?", "rationale": ["The query identifies the relevant table, which is 'city'.", "It selects the 'city' column to display the names of the cities.", "The first condition filters cities with a regional population greater than a specified number using a placeholder for numeric values.", "The second condition filters cities with a regional population less than a specified number using another placeholder for numeric values.", "The UNION operator combines the results of both conditions to provide a comprehensive list of cities that meet either criterion."], "gold_sql": "SELECT city FROM city WHERE regional_population  >  10000000 UNION SELECT city FROM city WHERE regional_population  <  5000000", "source_tables": ["city"], "description": "This virtual table retrieves the names of cities from the 'city' table where the regional population is either greater than or less than specified numeric values. The placeholders in the WHERE clauses represent the population thresholds for filtering the cities.", "virtual_table": "SELECT city FROM city WHERE regional_population  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT city FROM city WHERE regional_population  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6295", "db_id": "city_record", "question": "Which cities have higher temperature in Feb than in Jun or have once served as host cities?", "rationale": ["The query identifies the relevant tables, which are 'city', 'temperature', and 'hosting_city'.", "It selects the 'city' column from the 'city' table.", "The first part of the query joins 'city' and 'temperature' tables to filter cities based on the condition that the average temperature in February is greater than in June.", "The second part of the query selects cities from the 'hosting_city' table that have hosted matches, ensuring that the results include cities from both conditions.", "The use of UNION combines the results from both queries into a single list of cities."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Feb  >  T2.Jun UNION SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "description": "This virtual table provides a list of cities based on specific temperature conditions and hosting events. It retrieves cities where the average temperature in February is greater than in June, and also includes cities that have hosted matches. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.", "virtual_table": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Feb  >  T2.Jun UNION SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city"}
{"sample_id": "train.6275", "db_id": "city_record", "question": "Find the city that hosted the most events.", "rationale": ["The query identifies the relevant tables, 'city' and 'hosting_city'.", "It selects the 'city' from the 'city' table, using an alias T1 for clarity.", "A JOIN operation is performed between 'city' and 'hosting_city' on the condition that the city ID matches the host city ID.", "The results are grouped by the host city to aggregate the count of matches hosted in each city.", "The results are ordered in descending order based on the count of matches, allowing us to identify the most frequent host cities.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for the user to specify the desired number."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["hosting_city", "city"], "description": "This virtual table lists the cities that have hosted the most matches, derived from the 'city' and 'hosting_city' tables. The placeholder in the LIMIT clause allows the user to specify the number of top cities to retrieve.", "virtual_table": "SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6276", "db_id": "city_record", "question": "What is the venue of the competition \"1994 FIFA World Cup qualification\" hosted by \"Nanjing ( Jiangsu )\"?", "rationale": ["The query identifies the relevant tables: 'city', 'hosting_city', and 'match'.", "It selects the 'venue' column from the 'match' table.", "The JOIN operations link the 'city' table to the 'hosting_city' table using the 'city_id' and 'host_city' columns, and then link the 'hosting_city' table to the 'match' table using the 'match_id'.", "The WHERE clause filters results based on the specified city name and competition identifier, both represented by placeholders."], "gold_sql": "SELECT T3.venue FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id = T2.host_city JOIN MATCH AS T3 ON T2.match_id = T3.match_id WHERE T1.city = 'Nanjing ( Jiangsu )' AND T3.competition = '1994 FIFA World Cup qualification'", "source_tables": ["hosting_city", "city", "match"], "description": "This virtual table provides the venue information for matches hosted in a specific city during a particular competition. The placeholders in the WHERE clause represent the city name and the competition identifier.", "virtual_table": "SELECT T3.venue FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id = T2.host_city JOIN MATCH AS T3 ON T2.match_id = T3.match_id WHERE T1.city = [PLACEHOLDER-TYPE:STRING] AND T3.competition = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6282", "db_id": "city_record", "question": "Which three cities have the largest regional population?", "rationale": ["The query identifies the relevant table, which is 'city'.", "Select the column to display, 'city'.", "Order the results by 'regional_population' in descending order to show the most populated cities first.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT city FROM city ORDER BY regional_population DESC LIMIT 3", "source_tables": ["city"], "description": "This virtual table lists the names of cities from the 'city' table, ordered by their regional population in descending order. The placeholder in the LIMIT clause represents the maximum number of cities to be displayed.", "virtual_table": "SELECT city FROM city ORDER BY regional_population DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6283", "db_id": "city_record", "question": "What are the three largest cities in terms of regional population?", "rationale": ["The query identifies the relevant table, which is 'city'.", "Select the column to display, 'city'.", "Order the results by 'regional_population' in descending order to show the most populated cities first.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT city FROM city ORDER BY regional_population DESC LIMIT 3", "source_tables": ["city"], "description": "This virtual table lists the names of cities from the 'city' table, ordered by their regional population in descending order. The placeholder in the LIMIT clause represents the maximum number of cities to be displayed.", "virtual_table": "SELECT city FROM city ORDER BY regional_population DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4270", "db_id": "club_1", "question": "Find all the female members of club \"Bootup Baltimore\". Show the first name and last name.", "rationale": ["The query identifies the relevant tables: 'Club', 'Member_of_club', and 'Student'.", "It selects the columns to display, which are 'fname' and 'lname' from the 'Student' table.", "The query joins the 'Club' table with the 'Member_of_club' table on 'ClubID' and then joins the 'Member_of_club' table with the 'Student' table on 'StuID'.", "Conditions are added to filter the results based on the specified club name and the gender of the students using placeholders for string values."], "gold_sql": "SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  'Bootup Baltimore' AND t3.sex  =  'F'", "source_tables": ["club", "member_of_club", "student"], "description": "This virtual table describes the first and last names of students who are members of a specific club and belong to a certain gender. The placeholders in the WHERE clause represent the club's name and the student's gender.", "virtual_table": "SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  [PLACEHOLDER-TYPE:STRING] AND t3.sex  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4276", "db_id": "club_1", "question": "Which club has the most members majoring in \"600\"?", "rationale": ["The query identifies the relevant tables: 'Club', 'Member_of_club', and 'Student'.", "It selects the 'clubname' from the 'Club' table.", "The JOIN operations link the 'Member_of_club' table to both the 'Club' and 'Student' tables based on their respective IDs.", "A condition is added to filter the results based on the specified major of the students using a placeholder for string values.", "The results are grouped by 'clubname' to aggregate the data.", "The results are ordered by the count of members in each club in descending order.", "A limit is applied to restrict the number of clubs returned, using a placeholder for numeric values."], "gold_sql": "SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.major  =  '600' GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT 1", "source_tables": ["club", "member_of_club", "student"], "description": "This virtual table lists the names of clubs that students with a specific major are members of. The results are grouped by club name and ordered by the number of members in descending order, with a limit on the number of clubs returned. The placeholders in the WHERE clause and LIMIT clause represent the major of the students and the maximum number of clubs to display, respectively.", "virtual_table": "SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.major  =  [PLACEHOLDER-TYPE:STRING] GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4279", "db_id": "club_1", "question": "Which club has the most female students as their members? Give me the name of the club.", "rationale": ["The query identifies the relevant tables: 'Club', 'Member_of_club', and 'Student'.", "It selects the 'clubname' from the 'Club' table.", "The query joins the 'Club' table with the 'Member_of_club' table on 'ClubID' and then with the 'Student' table on 'StuID'.", "A condition is added to filter the results based on the 'sex' of the students using a placeholder for string values.", "The results are grouped by 'clubname' to aggregate the data and ordered by the count of members in descending order.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.sex  =  'F' GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT 1", "source_tables": ["club", "member_of_club", "student"], "description": "This virtual table provides a list of club names from the 'Club' table that are associated with students of a specific gender. The query joins the 'Club', 'Member_of_club', and 'Student' tables to filter clubs based on the gender of the students. The results are grouped by club name and ordered by the number of members in descending order, with a limit on the number of results returned.", "virtual_table": "SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.sex  =  [PLACEHOLDER-TYPE:STRING] GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4267", "db_id": "club_1", "question": "How many clubs does \"Linda Smith\" have membership for?", "rationale": ["The query identifies the relevant tables: 'club', 'member_of_club', and 'student'.", "It uses JOIN operations to connect these tables based on the foreign key relationships: 'ClubID' and 'StuID'.", "The SELECT statement counts the number of clubs associated with the specified student.", "The WHERE clause filters the results based on the student's first and last names using placeholders for string values."], "gold_sql": "SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.fname  =  'Linda' AND t3.lname  =  'Smith'", "source_tables": ["club", "member_of_club", "student"], "description": "This virtual table provides the count of clubs that a specific student is a member of, based on their first and last names. The placeholders in the WHERE clause represent the student's first and last names.", "virtual_table": "SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.fname  =  [PLACEHOLDER-TYPE:STRING] AND t3.lname  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4257", "db_id": "club_1", "question": "Find each student's first name.", "rationale": ["The query is identifying the relevant table, which is 'Student'.", "Select the column to display, 'Fname', ensuring that only unique first names are retrieved by using the DISTINCT keyword."], "gold_sql": "SELECT DISTINCT fname FROM student", "source_tables": ["student"], "description": "This virtual table provides a list of unique first names of students from the 'Student' table. The use of DISTINCT ensures that each first name appears only once in the result set.", "virtual_table": "SELECT DISTINCT fname FROM student"}
{"sample_id": "train.3221", "db_id": "college_1", "question": "Find the max, average, and minimum gpa of all students in each department.", "rationale": ["The query identifies the relevant table, which is 'student'.", "It selects the maximum, average, and minimum GPA from the 'stu_gpa' column.", "The results are grouped by the 'dept_code' to provide a summary for each department."], "gold_sql": "SELECT max(stu_gpa) ,  avg(stu_gpa) ,  min(stu_gpa) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "description": "This virtual table summarizes the academic performance of students by department. It calculates the maximum, average, and minimum GPA for students in each department, grouping the results by the department code.", "virtual_table": "SELECT max(stu_gpa) ,  avg(stu_gpa) ,  min(stu_gpa) ,  dept_code FROM student GROUP BY dept_code"}
{"sample_id": "train.3294", "db_id": "college_1", "question": "What are the first names of all students taking accoutning and Computer Information Systems classes?", "rationale": ["The query identifies the relevant tables: 'student', 'enroll', 'class', 'course', and 'department'.", "It selects the 'stu_fname' column from the 'student' table.", "The JOIN operations link the tables based on their foreign key relationships to ensure that the data is correctly associated.", "The WHERE clause filters the results based on the department name, using a placeholder for the specific department.", "The INTERSECT operation is used to find students who are enrolled in classes from the same department in two separate queries, ensuring that only those students who meet both conditions are included."], "gold_sql": "SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Accounting' INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Computer Info. Systems'", "source_tables": ["course", "enroll", "department", "class", "student"], "description": "This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the department's name.", "virtual_table": "SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3271", "db_id": "college_1", "question": "What is the name of department where has the largest number of professors with a Ph.D. degree?", "rationale": ["The query identifies the relevant tables, which are 'professor' and 'department'.", "It selects the 'dept_name' from the 'department' table and 'dept_code' from the 'professor' table.", "A JOIN operation is performed on the 'dept_code' to combine data from both tables.", "A condition is added to filter professors based on their highest degree using a placeholder for string values.", "The results are grouped by 'dept_code' to aggregate the data by department.", "The results are ordered by the count of professors in each department in descending order.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  'Ph.D.' GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["department", "professor"], "description": "This virtual table provides a list of department names and their corresponding department codes from the 'professor' and 'department' tables. It filters the results based on the highest degree obtained by professors, using a placeholder for the degree type. The results are grouped by department code and ordered by the number of professors in each department, limited to a specified number of results.", "virtual_table": "SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3272", "db_id": "college_1", "question": "Which department has the most professors with a Ph.D.?", "rationale": ["The query identifies the relevant tables, 'professor' and 'department', and establishes a join between them based on the department code.", "It selects the department name and department code to display in the results.", "A condition is added to filter professors based on their highest degree using a placeholder for string values.", "The results are grouped by department code to aggregate the data appropriately.", "The results are ordered by the count of professors in each department in descending order, and a limit is set on the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  'Ph.D.' GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["department", "professor"], "description": "This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.", "virtual_table": "SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3216", "db_id": "college_1", "question": "How many professors have a Ph.D. in each department?", "rationale": ["The query identifies the relevant table, which is 'professor'.", "It selects a count of professors and groups the results by 'dept_code'.", "A condition is added to filter the results based on the 'prof_high_degree' column using a placeholder for string values."], "gold_sql": "SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  'Ph.D.' GROUP BY dept_code", "source_tables": ["professor"], "description": "This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree level being queried.", "virtual_table": "SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY dept_code"}
{"sample_id": "train.3323", "db_id": "college_1", "question": "Find the first names and degree of all professors who are teaching some class in Computer Info. Systems department.", "rationale": ["The query identifies the relevant tables: 'CLASS', 'EMPLOYEE', 'PROFESSOR', and 'DEPARTMENT'.", "It selects distinct first names of employees and their highest degrees.", "The JOIN operations link the tables based on their foreign key relationships, ensuring that the correct employee and professor data is associated with the classes.", "A condition is added to filter results by the department name using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T2.emp_fname ,  T3.prof_high_degree FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN professor AS T3 ON T2.emp_num  =  T3.emp_num JOIN department AS T4 ON T4.dept_code  =  T3.dept_code WHERE T4.dept_name  =  'Computer Info. Systems'", "source_tables": ["employee", "professor", "class", "department"], "description": "This virtual table provides a distinct list of first names of employees and their highest degrees from the 'CLASS', 'EMPLOYEE', 'PROFESSOR', and 'DEPARTMENT' tables. The results are filtered based on a specific department name provided as a placeholder.", "virtual_table": "SELECT DISTINCT T2.emp_fname ,  T3.prof_high_degree FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN professor AS T3 ON T2.emp_num  =  T3.emp_num JOIN department AS T4 ON T4.dept_code  =  T3.dept_code WHERE T4.dept_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3222", "db_id": "college_1", "question": "What is the highest, lowest, and average student GPA for every department?", "rationale": ["The query identifies the relevant table, which is 'student'.", "It selects the maximum, average, and minimum GPA from the 'stu_gpa' column.", "The results are grouped by the 'dept_code' to provide a summary for each department."], "gold_sql": "SELECT max(stu_gpa) ,  avg(stu_gpa) ,  min(stu_gpa) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "description": "This virtual table summarizes the academic performance of students by department. It calculates the maximum, average, and minimum GPA of students grouped by their respective department codes. The placeholders in the SELECT statement represent the GPA metrics and department code.", "virtual_table": "SELECT max(stu_gpa) ,  avg(stu_gpa) ,  min(stu_gpa) ,  dept_code FROM student GROUP BY dept_code"}
{"sample_id": "train.3180", "db_id": "college_1", "question": "What are the first names and birthdates of the professors in charge of ACCT-211?", "rationale": ["The query identifies the relevant tables, which are 'employee' and 'CLASS'.", "It selects the columns to display, which are 'EMP_FNAME' and 'EMP_DOB' from the 'employee' table.", "A JOIN operation is performed between 'employee' and 'CLASS' on the condition that the professor's identifier matches the professor number in the class.", "A condition is added to filter the results based on the specified course code using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["employee", "class"], "description": "This virtual table provides a distinct list of first names and dates of birth of professors from the 'employee' table who are teaching classes associated with a specific course code. The placeholder in the WHERE clause represents the course code for which the professors are being queried.", "virtual_table": "SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3189", "db_id": "college_1", "question": "How many different locations does the school with code BUS has?", "rationale": ["The query identifies the relevant table, which is 'DEPARTMENT'.", "It selects the count of distinct values in the 'dept_address' column.", "A condition is added to filter the results based on the 'school_code' using a placeholder for string values."], "gold_sql": "SELECT count(DISTINCT dept_address) FROM department WHERE school_code  =  'BUS'", "source_tables": ["department"], "description": "This virtual table provides the count of distinct department addresses from the 'DEPARTMENT' table for a specific school. The placeholder in the WHERE clause represents the school code being queried.", "virtual_table": "SELECT count(DISTINCT dept_address) FROM department WHERE school_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3210", "db_id": "college_1", "question": "How many different professors are there for the different schools?", "rationale": ["The query identifies the relevant tables, which are 'Department' and 'Professor'.", "It selects the count of professors and groups the results by the school code from the 'Department' table.", "A JOIN operation is performed between 'Department' and 'Professor' on the department code to associate professors with their respective departments."], "gold_sql": "SELECT count(*) ,  T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code", "source_tables": ["department", "professor"], "description": "This virtual table provides a count of professors grouped by the school code from the 'Department' table. The placeholder in the SELECT statement represents the count of professors, while the school code is derived from the department associated with each professor.", "virtual_table": "SELECT count(*) ,  T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code"}
{"sample_id": "train.3237", "db_id": "college_1", "question": "Find the total credits of all classes offered by each department.", "rationale": ["The query identifies the relevant tables, which are 'COURSE' and 'CLASS'.", "It selects the sum of credit hours from the 'COURSE' table and groups the results by department code.", "The join condition links the 'COURSE' table to the 'CLASS' table using the course code, ensuring that only related records are considered."], "gold_sql": "SELECT sum(T1.crs_credit) ,  T1.dept_code FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY T1.dept_code", "source_tables": ["course", "class"], "description": "This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables, allowing for the aggregation of credit hours per department.", "virtual_table": "SELECT sum(T1.crs_credit) ,  T1.dept_code FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY T1.dept_code"}
{"sample_id": "train.3253", "db_id": "college_1", "question": "What is the name of the department that has the largest number of students enrolled?", "rationale": ["The query identifies the relevant tables: 'CLASS', 'ENROLL', 'COURSE', and 'DEPARTMENT'.", "It joins these tables based on their foreign key relationships to connect classes to enrollments, courses, and departments.", "The 'GROUP BY' clause is used to aggregate results by department code, allowing for counting the number of classes per department.", "The 'ORDER BY' clause sorts the results in descending order based on the count of classes, ensuring that departments with the most classes appear first.", "A limit is applied to restrict the number of department names returned, using a placeholder for numeric values."], "gold_sql": "SELECT T4.dept_name FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code GROUP BY T3.dept_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["course", "department", "class", "enroll"], "description": "This virtual table provides a list of department names from the 'DEPARTMENT' table that are associated with classes in the 'CLASS' table. It joins the 'ENROLL' table to link students to classes, the 'COURSE' table to connect classes to their respective courses, and finally the 'DEPARTMENT' table to retrieve the department names. The results are grouped by department code and ordered by the number of classes in descending order, with a limit on the number of departments returned as specified by a placeholder.", "virtual_table": "SELECT T4.dept_name FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code GROUP BY T3.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3206", "db_id": "college_1", "question": "How many classes are held in each department?", "rationale": ["The query identifies the relevant tables, which are 'CLASS' and 'COURSE'.", "It selects the count of classes and groups the results by 'dept_code'.", "The JOIN operation connects the 'CLASS' table with the 'COURSE' table based on the 'crs_code' to ensure that the count reflects the correct department associated with each class."], "gold_sql": "SELECT count(*) ,  dept_code FROM CLASS AS T1 JOIN course AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY dept_code", "source_tables": ["course", "class"], "description": "This virtual table provides a count of classes grouped by department code from the 'CLASS' and 'COURSE' tables. The placeholder in the SELECT statement represents the count of classes for each department.", "virtual_table": "SELECT count(*) ,  dept_code FROM CLASS AS T1 JOIN course AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY dept_code"}
{"sample_id": "train.3238", "db_id": "college_1", "question": "What are the total number of credits offered by each department?", "rationale": ["The query identifies the relevant tables, which are 'COURSE' and 'CLASS'.", "It selects the sum of credit hours from the 'COURSE' table and groups the results by department code.", "The JOIN operation is used to connect the 'COURSE' and 'CLASS' tables based on the course code, ensuring that only related records are considered."], "gold_sql": "SELECT sum(T1.crs_credit) ,  T1.dept_code FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY T1.dept_code", "source_tables": ["course", "class"], "description": "This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables. The placeholder in the SELECT clause represents the total credit hours, while the department code is used for grouping the results.", "virtual_table": "SELECT sum(T1.crs_credit) ,  T1.dept_code FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY T1.dept_code"}
{"sample_id": "train.3205", "db_id": "college_1", "question": "Find the number of classes in each department.", "rationale": ["The query identifies the relevant tables, which are 'CLASS' and 'COURSE'.", "It selects the count of classes and groups the results by 'dept_code'.", "The JOIN operation links the 'CLASS' table with the 'COURSE' table based on the 'crs_code' to ensure that the count reflects the correct department associated with each class."], "gold_sql": "SELECT count(*) ,  dept_code FROM CLASS AS T1 JOIN course AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY dept_code", "source_tables": ["course", "class"], "description": "This virtual table provides a count of classes grouped by department code from the 'CLASS' and 'COURSE' tables. The placeholder in the SELECT statement represents the count of classes for each department.", "virtual_table": "SELECT count(*) ,  dept_code FROM CLASS AS T1 JOIN course AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY dept_code"}
{"sample_id": "train.3315", "db_id": "college_1", "question": "Find the first names and offices of all instructors who have taught some course and the course description and the department name.", "rationale": ["The query identifies the relevant tables: 'CLASS', 'EMPLOYEE', 'COURSE', 'PROFESSOR', and 'DEPARTMENT'.", "It selects the first name of the professor from the 'EMPLOYEE' table, the office location from the 'PROFESSOR' table, the course description from the 'COURSE' table, and the department name from the 'DEPARTMENT' table.", "The joins are established based on the foreign key relationships between the tables, linking professors to their classes and departments, and courses to their respective classes."], "gold_sql": "SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description ,  T5.dept_name FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num JOIN department AS T5 ON T4.dept_code  =  T5.dept_code", "source_tables": ["course", "department", "professor", "class", "employee"], "description": "This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.", "virtual_table": "SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description ,  T5.dept_name FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num JOIN department AS T5 ON T4.dept_code  =  T5.dept_code"}
{"sample_id": "train.3220", "db_id": "college_1", "question": "How many hours do the students spend studying in each department?", "rationale": ["The query identifies the relevant table, which is 'student'.", "It selects the sum of 'stu_hrs' to calculate the total credit hours for each department.", "The GROUP BY clause is used to aggregate the results based on 'dept_code', allowing for a summary of credit hours per department."], "gold_sql": "SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "description": "This virtual table summarizes the total credit hours completed by students, grouped by their respective departments. The placeholder in the SELECT clause represents the total credit hours, while the GROUP BY clause organizes the results by department code.", "virtual_table": "SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code"}
{"sample_id": "train.3218", "db_id": "college_1", "question": "How many students are in each department?", "rationale": ["The query identifies the relevant table, which is 'student'.", "It selects the count of students and groups the results by 'dept_code'.", "The use of count(*) allows for the aggregation of student records based on their department code."], "gold_sql": "SELECT count(*) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "description": "This virtual table provides a count of students grouped by their department codes from the 'student' table. The placeholder in the SELECT statement represents the department code for which the count of students is being aggregated.", "virtual_table": "SELECT count(*) ,  dept_code FROM student GROUP BY dept_code"}
{"sample_id": "train.3214", "db_id": "college_1", "question": "Which school has the fewest professors?", "rationale": ["The query identifies the relevant tables, which are 'department' and 'professor'.", "It selects the 'school_code' from the 'department' table.", "A JOIN operation is performed between 'department' and 'professor' on the 'dept_code' to associate professors with their respective departments.", "The results are grouped by 'school_code' to aggregate the data based on the number of professors per school.", "The results are ordered by the count of professors in descending order to prioritize schools with more professors.", "A LIMIT clause is included to allow the user to specify how many school codes they want to retrieve."], "gold_sql": "SELECT T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code ORDER BY count(*) LIMIT 1", "source_tables": ["department", "professor"], "description": "This virtual table provides a list of school codes from the 'department' table, grouped by the school code and ordered by the count of professors associated with each school. The placeholder in the LIMIT clause allows the user to specify the maximum number of school codes to retrieve.", "virtual_table": "SELECT T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3209", "db_id": "college_1", "question": "What is the number of professors for different school?", "rationale": ["The query identifies the relevant tables, which are 'Department' and 'Professor'.", "It selects the count of professors and groups the results by the school code from the 'Department' table.", "The JOIN operation links the 'Department' and 'Professor' tables based on the department code, allowing for aggregation of professors by school code."], "gold_sql": "SELECT count(*) ,  T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code", "source_tables": ["department", "professor"], "description": "This virtual table provides a count of professors grouped by the school code from the 'Department' table. The placeholder in the SELECT clause represents the count of professors, while the school code is derived from the department associated with each professor.", "virtual_table": "SELECT count(*) ,  T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code"}
{"sample_id": "train.3300", "db_id": "college_1", "question": "What is the name of the department with the student that has the lowest GPA?", "rationale": ["The query identifies the relevant tables, 'student' and 'department'.", "It selects the 'dept_name' from the 'department' table.", "A JOIN operation is performed on the 'dept_code' to link students with their respective departments.", "The results are ordered by the students' GPA to prioritize higher-performing students.", "The LIMIT clause uses a placeholder to allow the user to specify how many department names to return."], "gold_sql": "SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT 1", "source_tables": ["department", "student"], "description": "This virtual table provides a list of department names associated with students, ordered by their GPA. The placeholder in the LIMIT clause allows for specifying the maximum number of department names to retrieve.", "virtual_table": "SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3241", "db_id": "college_1", "question": "How many students enrolled in class ACCT-211?", "rationale": ["The query identifies the relevant tables, which are 'CLASS' and 'ENROLL'.", "It uses a JOIN operation to connect these tables based on the 'class_code' column.", "The SELECT statement counts the number of records, which corresponds to the number of students enrolled in the specified class.", "A condition is added to filter the results based on the 'crs_code' column using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code WHERE T1.crs_code  =  'ACCT-211'", "source_tables": ["class", "enroll"], "description": "This virtual table provides the count of students enrolled in classes associated with a specific course code from the 'CLASS' and 'ENROLL' tables. The placeholder in the WHERE clause represents the course code for which the enrollment count is being queried.", "virtual_table": "SELECT count(*) FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code WHERE T1.crs_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3314", "db_id": "college_1", "question": "What are the first names, office locations of all lecturers who have taught some course?", "rationale": ["The query identifies the relevant tables: 'CLASS', 'EMPLOYEE', 'COURSE', and 'PROFESSOR'.", "It selects the 'emp_fname' from the 'EMPLOYEE' table, 'prof_office' from the 'PROFESSOR' table, and 'crs_description' from the 'COURSE' table.", "The joins are established based on the foreign key relationships: 'CLASS.prof_num' with 'EMPLOYEE.emp_num', 'CLASS.crs_code' with 'COURSE.crs_code', and 'EMPLOYEE.emp_num' with 'PROFESSOR.emp_num'."], "gold_sql": "SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num", "source_tables": ["course", "employee", "professor", "class"], "description": "This virtual table provides the first names of employees, the office locations of professors, and descriptions of courses from the respective tables. The data is retrieved by joining the 'CLASS' table with the 'EMPLOYEE', 'COURSE', and 'PROFESSOR' tables based on their relationships, specifically linking professors to their classes and courses.", "virtual_table": "SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num"}
{"sample_id": "train.3299", "db_id": "college_1", "question": "What is the department name of the students with lowest gpa belongs to?", "rationale": ["The query identifies the relevant tables, 'student' and 'department'.", "It selects the 'dept_name' from the 'department' table.", "A JOIN operation is performed on the 'dept_code' to link students with their respective departments.", "The results are ordered by the students' GPA to prioritize higher-performing students.", "The LIMIT clause includes a placeholder for the number of results to return."], "gold_sql": "SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT 1", "source_tables": ["department", "student"], "description": "This virtual table provides a list of department names associated with students, ordered by their GPA. The placeholder in the LIMIT clause allows for specifying the maximum number of department names to retrieve.", "virtual_table": "SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3234", "db_id": "college_1", "question": "How many courses does the department of Computer Information Systmes offer?", "rationale": ["The query identifies the relevant tables, which are 'DEPARTMENT' and 'COURSE'.", "It uses a JOIN operation to connect the two tables based on the 'dept_code' foreign key relationship.", "The SELECT statement counts the number of courses associated with the specified department.", "A condition is added to filter the results based on the department's name using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM department AS T1 JOIN course AS T2 ON T1.dept_code  =  T2.dept_code WHERE dept_name  =  'Computer Info. Systems'", "source_tables": ["course", "department"], "description": "This virtual table provides the count of courses offered by a specific department from the 'DEPARTMENT' and 'COURSE' tables. The placeholder in the WHERE clause represents the name of the department for which the course count is being queried.", "virtual_table": "SELECT count(*) FROM department AS T1 JOIN course AS T2 ON T1.dept_code  =  T2.dept_code WHERE dept_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3309", "db_id": "college_1", "question": "Find the first names of all instructors who have taught some course and the course code.", "rationale": ["The query identifies the relevant tables, which are 'CLASS' and 'EMPLOYEE'.", "Select the columns to display, 'emp_fname' from the 'EMPLOYEE' table and 'crs_code' from the 'CLASS' table.", "Use a JOIN operation to connect the 'CLASS' table and the 'EMPLOYEE' table based on the professor's identifier, ensuring that the correct professor's name is associated with the course they teach."], "gold_sql": "SELECT T2.emp_fname ,  T1.crs_code FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num", "source_tables": ["employee", "class"], "description": "This virtual table describes the first names of professors and the course codes they teach from the 'CLASS' and 'EMPLOYEE' tables. The join condition links the professor's identifier in the 'CLASS' table to the corresponding identifier in the 'EMPLOYEE' table.", "virtual_table": "SELECT T2.emp_fname ,  T1.crs_code FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num"}
{"sample_id": "dev.370", "db_id": "cre_Doc_Template_Mgt", "question": "What are the ids and names of each document, as well as the number of paragraphs in each?", "rationale": ["The query identifies the relevant tables, 'Paragraphs' and 'Documents'.", "It selects the 'document_id' from 'Paragraphs' and 'document_name' from 'Documents'.", "The JOIN operation is used to link 'Paragraphs' and 'Documents' based on the 'document_id'.", "The COUNT function is applied to count the number of paragraphs for each document.", "The GROUP BY clause is used to group the results by 'document_id' to get the count for each document."], "gold_sql": "SELECT T1.document_id ,  T2.document_name ,  count(*) FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id GROUP BY T1.document_id", "source_tables": ["paragraphs", "documents"], "description": "This virtual table provides a summary of documents along with the count of paragraphs associated with each document. It retrieves the unique document identifier and the document name from the 'Documents' table, while counting the number of paragraphs linked to each document from the 'Paragraphs' table. The grouping is done based on the document identifier to ensure that the count reflects the number of paragraphs per document.", "virtual_table": "SELECT T1.document_id ,  T2.document_name ,  count(*) FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id GROUP BY T1.document_id"}
{"sample_id": "dev.369", "db_id": "cre_Doc_Template_Mgt", "question": "Show all document ids, names and the number of paragraphs in each document.", "rationale": ["The query identifies the relevant tables, 'Paragraphs' and 'Documents'.", "It selects the 'document_id' from the 'Paragraphs' table and 'document_name' from the 'Documents' table.", "A count of paragraphs is calculated for each document by using the COUNT function.", "The JOIN operation links the two tables on the 'document_id' to ensure that only related records are counted.", "The GROUP BY clause is used to aggregate the results by 'document_id', allowing for the count of paragraphs per document."], "gold_sql": "SELECT T1.document_id ,  T2.document_name ,  count(*) FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id GROUP BY T1.document_id", "source_tables": ["paragraphs", "documents"], "description": "This virtual table provides a summary of documents along with the count of paragraphs associated with each document. It retrieves the document ID and document name from the 'Documents' table and counts the number of paragraphs linked to each document from the 'Paragraphs' table. The grouping is done by document ID to aggregate the paragraph counts for each document.", "virtual_table": "SELECT T1.document_id ,  T2.document_name ,  count(*) FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id GROUP BY T1.document_id"}
{"sample_id": "dev.368", "db_id": "cre_Doc_Template_Mgt", "question": "Return the different document ids along with the number of paragraphs corresponding to each, ordered by id.", "rationale": ["The query identifies the relevant table, which is 'Paragraphs'.", "It selects the 'document_id' and counts the number of paragraphs associated with each document using the count function.", "The results are grouped by 'document_id' to aggregate the paragraph counts for each document.", "Finally, the results are ordered by 'document_id' to present the data in a structured manner."], "gold_sql": "SELECT document_id ,  count(*) FROM Paragraphs GROUP BY document_id ORDER BY document_id", "source_tables": ["paragraphs"], "description": "This virtual table provides a count of paragraphs associated with each document from the 'Paragraphs' table. The results are grouped by the document identifier, allowing users to see how many paragraphs belong to each document, sorted by the document ID.", "virtual_table": "SELECT document_id ,  count(*) FROM Paragraphs GROUP BY document_id ORDER BY document_id"}
{"sample_id": "dev.342", "db_id": "cre_Doc_Template_Mgt", "question": "What are the different template type codes, and how many documents use each type?", "rationale": ["The query identifies the relevant tables, which are 'Templates' and 'Documents'.", "It selects the 'template_type_code' from the 'Templates' table and counts the number of documents associated with each template type.", "A JOIN operation is performed between 'Templates' and 'Documents' on the 'template_id' to link templates with their corresponding documents.", "The results are grouped by 'template_type_code' to provide a count of documents for each template type."], "gold_sql": "SELECT T1.template_type_code ,  count(*) FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_type_code", "source_tables": ["templates", "documents"], "description": "This virtual table summarizes the count of documents associated with each template type from the 'Templates' and 'Documents' tables. The placeholder in the SELECT statement represents the template type code, and the count indicates the number of documents linked to each template type.", "virtual_table": "SELECT T1.template_type_code ,  count(*) FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_type_code"}
{"sample_id": "dev.309", "db_id": "cre_Doc_Template_Mgt", "question": "Show all template ids and number of documents using each template.", "rationale": ["The query identifies the relevant table, which is 'Documents'.", "It selects the 'template_id' to group the results by each template.", "The count function is used to calculate the total number of documents for each template, and the results are grouped by 'template_id' to provide a summary of document counts per template."], "gold_sql": "SELECT template_id ,  count(*) FROM Documents GROUP BY template_id", "source_tables": ["documents"], "description": "This virtual table summarizes the number of documents associated with each template from the 'Documents' table. The placeholder in the SELECT clause represents the unique identifier of the template, while the count function aggregates the total number of documents linked to each template.", "virtual_table": "SELECT template_id ,  count(*) FROM Documents GROUP BY template_id"}
{"sample_id": "dev.362", "db_id": "cre_Doc_Template_Mgt", "question": "What are the details for the paragraph that includes the text 'Korea ' ?", "rationale": ["The query identifies the relevant table, which is 'Paragraphs'.", "Select the column to display, 'Other_Details'.", "Add a condition to filter the 'Paragraph_Text' column using a LIKE clause for the specified text pattern, represented by a placeholder for string values."], "gold_sql": "select other_details from paragraphs where paragraph_text like 'korea'", "source_tables": ["paragraphs"], "description": "This virtual table retrieves additional details from the 'Paragraphs' table for paragraphs that contain specific text. The placeholder in the WHERE clause represents the text pattern to search for within the paragraph content.", "virtual_table": "select other_details from paragraphs where paragraph_text like [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.336", "db_id": "cre_Doc_Template_Mgt", "question": "Return the lowest version number, along with its corresponding template type code.", "rationale": ["The query identifies the relevant table, which is 'Templates'.", "It selects the minimum version number of templates using the aggregate function min().", "The query groups the results by 'Template_Type_Code' to categorize the minimum version numbers according to their respective template types."], "gold_sql": "SELECT min(Version_Number) ,  template_type_code FROM Templates", "source_tables": ["templates"], "description": "This virtual table provides the minimum version number of templates grouped by their type code from the 'Templates' table. The placeholder in the SELECT clause represents the version number, while the template type code is used to categorize the templates.", "virtual_table": "SELECT min(Version_Number) ,  template_type_code FROM Templates"}
{"sample_id": "dev.345", "db_id": "cre_Doc_Template_Mgt", "question": "Show all template type codes that are not used by any document.", "rationale": ["The query starts by selecting the 'template_type_code' from the 'Templates' table.", "It uses an EXCEPT clause to find template types that do not have any associated documents.", "The second part of the query involves a JOIN between 'Templates' and 'Documents' on 'template_id' to identify which template types are linked to documents."], "gold_sql": "SELECT template_type_code FROM Templates EXCEPT SELECT template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id", "source_tables": ["templates", "documents"], "description": "This virtual table identifies the unique template type codes from the 'Templates' table that are not associated with any documents in the 'Documents' table. The query uses an EXCEPT clause to filter out template types that have been linked to documents, ensuring that only those template types without any corresponding documents are returned.", "virtual_table": "SELECT template_type_code FROM Templates EXCEPT SELECT template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id"}
{"sample_id": "dev.335", "db_id": "cre_Doc_Template_Mgt", "question": "What the smallest version number and its template type code?", "rationale": ["The query identifies the relevant table, which is 'Templates'.", "It selects the minimum version number of templates using the aggregate function min().", "The query groups the results by 'Template_Type_Code' to categorize the minimum version numbers according to their respective template types."], "gold_sql": "SELECT min(Version_Number) ,  template_type_code FROM Templates", "source_tables": ["templates"], "description": "This virtual table provides the minimum version number of templates grouped by their type code from the 'Templates' table. The placeholder in the SELECT clause represents the version number, while the template type code is used to categorize the templates.", "virtual_table": "SELECT min(Version_Number) ,  template_type_code FROM Templates"}
{"sample_id": "train.5170", "db_id": "cre_Drama_Workshop_Groups", "question": "What is the description of the service type which offers both the photo product and the film product?", "rationale": ["The query identifies the relevant tables, which are 'Ref_Service_Types' and 'Services'.", "It selects the 'Service_Type_Description' from 'Ref_Service_Types' by joining it with 'Services' on the 'Service_Type_Code'.", "The WHERE clause filters the results based on the 'Product_Name' from the 'Services' table using a placeholder for string values.", "The INTERSECT operator is used to ensure that only the service types associated with the same product name are returned in both parts of the query."], "gold_sql": "SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  'photo' INTERSECT SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  'film'", "source_tables": ["services", "ref_service_types"], "description": "This virtual table retrieves the descriptions of service types associated with a specific product name from the 'Services' table, ensuring that the same product name is used in both parts of the query. The placeholders represent the product name that the user can specify to filter the results accordingly.", "virtual_table": "SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5135", "db_id": "cre_Drama_Workshop_Groups", "question": "Find the names of the workshop groups where services with product name \"film\" are performed.", "rationale": ["The query identifies the relevant tables, 'Drama_Workshop_Groups' and 'Services'.", "It selects the columns 'Store_Phone' and 'Store_Email_Address' from the 'Drama_Workshop_Groups' table.", "A JOIN operation is performed between 'Drama_Workshop_Groups' and 'Services' on the 'Workshop_Group_ID' to link the two tables.", "A condition is added to filter the results based on the 'Product_Name' from the 'Services' table using a placeholder for string values."], "gold_sql": "SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T2.Product_Name  =  'film'", "source_tables": ["services", "drama_workshop_groups"], "description": "This virtual table provides the phone number and email address of stores associated with specific drama workshop groups that offer a particular product. The placeholder in the WHERE clause represents the name of the product being queried.", "virtual_table": "SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T2.Product_Name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5168", "db_id": "cre_Drama_Workshop_Groups", "question": "What is the product ID of the most frequently ordered item on invoices?", "rationale": ["The query identifies the relevant table, which is 'Invoices'.", "It selects the 'Product_ID' column to display.", "The results are grouped by 'Product_ID' to aggregate the data.", "The results are ordered by the count of occurrences of each product ID in descending order to show the most frequently invoiced products first.", "The LIMIT clause uses a placeholder to allow the user to specify how many product IDs they want to retrieve."], "gold_sql": "SELECT Product_ID FROM INVOICES GROUP BY Product_ID ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["invoices"], "description": "This virtual table provides a list of product IDs from the 'Invoices' table, grouped by product ID and ordered by the count of occurrences in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of product IDs to retrieve.", "virtual_table": "SELECT Product_ID FROM INVOICES GROUP BY Product_ID ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5169", "db_id": "cre_Drama_Workshop_Groups", "question": "Find the id of the product ordered the most often on invoices.", "rationale": ["The query identifies the relevant table, which is 'Invoices'.", "It selects the 'Product_ID' column to display.", "The results are grouped by 'Product_ID' to aggregate the data.", "The results are ordered by the count of each product ID in descending order to show the most frequently invoiced products first.", "The LIMIT clause uses a placeholder to allow the user to specify how many product IDs they want to retrieve."], "gold_sql": "SELECT Product_ID FROM INVOICES GROUP BY Product_ID ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["invoices"], "description": "This virtual table provides a list of product IDs from the 'Invoices' table, grouped by product ID and ordered by the count of occurrences in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of product IDs to retrieve.", "virtual_table": "SELECT Product_ID FROM INVOICES GROUP BY Product_ID ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5126", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the descriptions of the service types with product price above 100?", "rationale": ["The query identifies the relevant tables, 'Ref_Service_Types' and 'Services'.", "It selects the 'Service_Type_Description' from 'Ref_Service_Types'.", "A JOIN is performed on 'Service_Type_Code' to link the two tables based on their relationship.", "A condition is added to filter services where the 'Product_Price' is greater than a specified numeric value using a placeholder."], "gold_sql": "SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Price  >  100", "source_tables": ["services", "ref_service_types"], "description": "This virtual table provides a list of service type descriptions from the 'Ref_Service_Types' table that are associated with services having a product price greater than a specified amount. The placeholder in the WHERE clause represents the minimum product price to filter the results.", "virtual_table": "SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Price  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5132", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the phones and emails of workshop groups in which services are performed?", "rationale": ["The query identifies the relevant tables, which are 'Drama_Workshop_Groups' and 'Services'.", "It selects the columns 'Store_Phone' and 'Store_Email_Address' from the 'Drama_Workshop_Groups' table.", "A JOIN operation is performed between 'Drama_Workshop_Groups' and 'Services' on the 'Workshop_Group_ID' to link the two tables based on their common identifier."], "gold_sql": "SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID", "source_tables": ["services", "drama_workshop_groups"], "description": "This virtual table provides the phone numbers and email addresses of stores associated with specific drama workshop groups. The data is retrieved by joining the 'Drama_Workshop_Groups' table with the 'Services' table based on the workshop group identifier, allowing for the extraction of relevant contact information for each store linked to the workshop groups.", "virtual_table": "SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID"}
{"sample_id": "train.5166", "db_id": "cre_Drama_Workshop_Groups", "question": "What is the average quantities ordered with payment method code \"MasterCard\" on invoices?", "rationale": ["The query identifies the relevant table, which is 'Invoices'.", "It selects the average of the 'Order_Quantity' column to calculate the average quantity of products ordered.", "A condition is added to filter the results based on the 'payment_method_code' using a placeholder for string values."], "gold_sql": "SELECT avg(Order_Quantity) FROM Invoices WHERE payment_method_code  =  'MasterCard'", "source_tables": ["invoices"], "description": "This virtual table calculates the average quantity of products ordered from the 'Invoices' table for a specific payment method. The placeholder in the WHERE clause represents the payment method code used for filtering the results.", "virtual_table": "SELECT avg(Order_Quantity) FROM Invoices WHERE payment_method_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5167", "db_id": "cre_Drama_Workshop_Groups", "question": "Check the invoices record and compute the average quantities ordered with the payment method \"MasterCard\".", "rationale": ["The query identifies the relevant table, which is 'Invoices'.", "It selects the average of the 'Order_Quantity' column to compute the average quantity of products ordered.", "A condition is added to filter the results based on the 'payment_method_code' using a placeholder for string values."], "gold_sql": "SELECT avg(Order_Quantity) FROM Invoices WHERE payment_method_code  =  'MasterCard'", "source_tables": ["invoices"], "description": "This virtual table calculates the average quantity of products ordered from the 'Invoices' table for a specific payment method. The placeholder in the WHERE clause represents the payment method code used for filtering the results.", "virtual_table": "SELECT avg(Order_Quantity) FROM Invoices WHERE payment_method_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5133", "db_id": "cre_Drama_Workshop_Groups", "question": "Give me all the phone numbers and email addresses of the workshop groups where services are performed.", "rationale": ["The query identifies the relevant tables, which are 'Drama_Workshop_Groups' and 'Services'.", "It selects the columns 'Store_Phone' and 'Store_Email_Address' from the 'Drama_Workshop_Groups' table.", "A JOIN operation is performed between 'Drama_Workshop_Groups' and 'Services' on the 'Workshop_Group_ID' to link the workshop groups with their associated services."], "gold_sql": "SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID", "source_tables": ["services", "drama_workshop_groups"], "description": "This virtual table provides the phone numbers and email addresses of stores associated with specific drama workshop groups. The data is retrieved by joining the 'Drama_Workshop_Groups' table with the 'Services' table based on the workshop group identifier, allowing for the extraction of relevant contact information for each store linked to the workshop groups.", "virtual_table": "SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID"}
{"sample_id": "train.5103", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the minimum, average, and maximum quantities ordered? Check all the invoices.", "rationale": ["The query identifies the relevant table, which is 'Invoices'.", "It selects the minimum, average, and maximum values of the 'Order_Quantity' column to provide a summary of product quantities ordered.", "The use of aggregate functions (min, avg, max) allows for a concise summary of the order quantities."], "gold_sql": "SELECT min(Order_Quantity) ,  avg(Order_Quantity) ,  max(Order_Quantity) FROM INVOICES", "source_tables": ["invoices"], "description": "This virtual table summarizes the minimum, average, and maximum quantities of products ordered as recorded in the 'Invoices' table. The placeholders in the SELECT statement represent the aggregated values of the order quantities.", "virtual_table": "SELECT min(Order_Quantity) ,  avg(Order_Quantity) ,  max(Order_Quantity) FROM INVOICES"}
{"sample_id": "train.5965", "db_id": "cre_Theme_park", "question": "What are the names of tourist attraction that Alison visited but Rosalind did not visit?", "rationale": ["The query identifies the relevant tables: 'Tourist_Attractions', 'Visitors', and 'Visits'.", "It selects the 'Name' of the tourist attractions from 'Tourist_Attractions'.", "The JOIN operations link the tables based on the tourist attraction ID and tourist ID to find the relevant visits.", "A WHERE clause filters the results based on the tourist's details using a placeholder for string values.", "The EXCEPT clause is used to exclude attractions visited by another tourist with the same details, ensuring only unique visits are returned."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  'Alison' EXCEPT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  'Rosalind'", "source_tables": ["visits", "visitors", "tourist_attractions"], "description": "This virtual table lists the names of tourist attractions that have been visited by a specific tourist, identified by their details, while excluding those attractions that have also been visited by another tourist with the same details. The placeholders in the query represent the tourist's details for filtering purposes.", "virtual_table": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5964", "db_id": "cre_Theme_park", "question": "Which tourist attractions do the tourists Vincent and Marcelle visit? Tell me the names of the attractions.", "rationale": ["The query identifies the relevant tables: 'Tourist_Attractions', 'Visitors', and 'Visits'.", "It selects the 'Name' of the tourist attractions from 'Tourist_Attractions'.", "The JOIN operations link the tables based on the relationships defined by the foreign keys.", "The WHERE clause filters the results based on the details of two different tourists, using placeholders for their specific details.", "The INTERSECT operator ensures that only the attractions visited by both tourists are included in the final result."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  'Vincent' INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  'Marcelle'", "source_tables": ["visits", "visitors", "tourist_attractions"], "description": "This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.", "virtual_table": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5951", "db_id": "cre_Theme_park", "question": "Show different tourist attractions' names, ids, and the corresponding number of visits.", "rationale": ["The query identifies the relevant tables, 'Tourist_Attractions' and 'Visits'.", "It selects the name of the tourist attraction from 'Tourist_Attractions' and the unique identifier from 'Visits'.", "The COUNT function is used to count the number of visits for each attraction.", "The JOIN operation links the two tables based on the 'Tourist_Attraction_ID'.", "The results are grouped by 'Tourist_Attraction_ID' to aggregate the visit counts for each attraction."], "gold_sql": "SELECT T1.Name ,  T2.Tourist_Attraction_ID ,   COUNT(*) FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID", "source_tables": ["visits", "tourist_attractions"], "description": "This virtual table provides a summary of tourist attractions along with the count of visits for each attraction. It combines data from the 'Tourist_Attractions' table and the 'Visits' table, grouping the results by the unique identifier of each tourist attraction. The placeholders represent the specific details of the attractions and the count of visits associated with them.", "virtual_table": "SELECT T1.Name ,  T2.Tourist_Attraction_ID ,   COUNT(*) FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID"}
{"sample_id": "train.5952", "db_id": "cre_Theme_park", "question": "What are the name, id and the corresponding number of visits for each  tourist attraction?", "rationale": ["The query identifies the relevant tables, which are 'Tourist_Attractions' and 'Visits'.", "It selects the 'Name' of the tourist attraction from 'Tourist_Attractions' and the 'Tourist_Attraction_ID' from 'Visits'.", "The COUNT function is used to count the number of visits for each attraction.", "The JOIN operation links the two tables on the 'Tourist_Attraction_ID' to associate visits with their respective attractions.", "Finally, the results are grouped by 'Tourist_Attraction_ID' to aggregate the visit counts for each attraction."], "gold_sql": "SELECT T1.Name ,  T2.Tourist_Attraction_ID ,   COUNT(*) FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID", "source_tables": ["visits", "tourist_attractions"], "description": "This virtual table provides a summary of tourist attractions along with the count of visits for each attraction. It combines data from the 'Tourist_Attractions' table and the 'Visits' table, grouping the results by the unique identifier of each tourist attraction. The placeholders in the SELECT statement represent the name of the attraction and its corresponding visit count.", "virtual_table": "SELECT T1.Name ,  T2.Tourist_Attraction_ID ,   COUNT(*) FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID"}
{"sample_id": "train.5943", "db_id": "cre_Theme_park", "question": "Show the details and star ratings of the 3 least expensive hotels.", "rationale": ["The query identifies the relevant table, which is 'Hotels'.", "Selects the columns 'other_hotel_details' and 'star_rating_code' to display information about the hotels.", "Orders the results by 'price_range' in ascending order to show cheaper hotels first.", "Limits the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT 3", "source_tables": ["hotels"], "description": "This virtual table provides details about hotels, specifically their additional information and star rating codes. The results are ordered by the price range of the hotels in ascending order, and the number of results returned is limited by a placeholder for numeric values.", "virtual_table": "SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5927", "db_id": "cre_Theme_park", "question": "What are the details of the markets that can be accessed by walk or bus?", "rationale": ["The query identifies the relevant tables, 'Street_Markets' and 'Tourist_Attractions'.", "It selects the 'Market_Details' from the 'Street_Markets' table.", "A JOIN operation is performed to link 'Street_Markets' with 'Tourist_Attractions' using the 'Market_ID' and 'Tourist_Attraction_ID'.", "Conditions are added to filter the results based on the 'How_to_Get_There' column from 'Tourist_Attractions', allowing for two different sets of instructions using placeholders."], "gold_sql": "SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  'walk' OR  T2.How_to_Get_There  =  'bus'", "source_tables": ["street_markets", "tourist_attractions"], "description": "This virtual table provides details about street markets that are linked to tourist attractions based on specific directions on how to reach them. The placeholders in the WHERE clause represent the different sets of instructions for accessing the attractions.", "virtual_table": "SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING] OR  T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5897", "db_id": "cre_Theme_park", "question": "Show the average price range of hotels that have 5 star ratings and allow pets.", "rationale": ["The query identifies the relevant table, which is 'Hotels'.", "It selects the average of the 'price_range' column to provide a summary of hotel prices.", "Conditions are added to filter the results based on 'star_rating_code' and 'pets_allowed_yn', using placeholders for user-defined values."], "gold_sql": "SELECT avg(price_range) FROM HOTELS WHERE star_rating_code  =  '5' AND pets_allowed_yn  =  1", "source_tables": ["hotels"], "description": "This virtual table calculates the average price range of hotels from the 'Hotels' table that meet specific criteria. The placeholders in the WHERE clause represent the star rating code and whether pets are allowed, allowing users to specify their desired conditions.", "virtual_table": "SELECT avg(price_range) FROM HOTELS WHERE star_rating_code  =  [PLACEHOLDER-TYPE:STRING] AND pets_allowed_yn  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5928", "db_id": "cre_Theme_park", "question": "Find the details of all the markets that are accessible by walk or bus.", "rationale": ["The query identifies the relevant tables, 'Street_Markets' and 'Tourist_Attractions'.", "It selects the 'Market_Details' from the 'Street_Markets' table.", "A JOIN operation is performed to link 'Street_Markets' with 'Tourist_Attractions' based on the matching 'Market_ID' and 'Tourist_Attraction_ID'.", "The WHERE clause filters the results based on the 'How_to_Get_There' column from 'Tourist_Attractions', allowing for two different methods of access using placeholders for string values."], "gold_sql": "SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  'walk' OR  T2.How_to_Get_There  =  'bus'", "source_tables": ["street_markets", "tourist_attractions"], "description": "This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access.", "virtual_table": "SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING] OR  T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5894", "db_id": "cre_Theme_park", "question": "What is the detail of each visitor?", "rationale": ["The query identifies the relevant table, which is 'Visitors'.", "Select the column to display, 'Tourist_Details'."], "gold_sql": "SELECT Tourist_Details FROM VISITORS", "source_tables": ["visitors"], "description": "This virtual table provides details about tourists from the 'Visitors' table. The placeholder in the SELECT clause represents the specific details related to each tourist.", "virtual_table": "SELECT Tourist_Details FROM VISITORS"}
{"sample_id": "train.5893", "db_id": "cre_Theme_park", "question": "Show details of all visitors.", "rationale": ["The query identifies the relevant table, which is 'Visitors'.", "Select the column to display, 'Tourist_Details'."], "gold_sql": "SELECT Tourist_Details FROM VISITORS", "source_tables": ["visitors"], "description": "This virtual table provides details about tourists from the 'Visitors' table. The placeholder in the SELECT clause represents the specific details related to each tourist.", "virtual_table": "SELECT Tourist_Details FROM VISITORS"}
{"sample_id": "train.5921", "db_id": "cre_Theme_park", "question": "What are the details and ways to get to tourist attractions related to royal family?", "rationale": ["The query identifies the relevant tables, which are 'Royal_Family' and 'Tourist_Attractions'.", "It selects the 'Royal_Family_Details' from the 'Royal_Family' table and 'How_to_Get_There' from the 'Tourist_Attractions' table.", "A JOIN operation is performed on the two tables using the foreign key relationship where 'Royal_Family_ID' in 'Royal_Family' matches 'Tourist_Attraction_ID' in 'Tourist_Attractions'."], "gold_sql": "SELECT T1.Royal_Family_Details ,  T2.How_to_Get_There FROM ROYAL_FAMILY AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Royal_Family_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["royal_family", "tourist_attractions"], "description": "This virtual table provides details about royal families and the instructions on how to reach the associated tourist attractions. The data is retrieved by joining the 'Royal_Family' table with the 'Tourist_Attractions' table based on the unique identifier for the royal family that corresponds to the tourist attraction.", "virtual_table": "SELECT T1.Royal_Family_Details ,  T2.How_to_Get_There FROM ROYAL_FAMILY AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Royal_Family_ID  =  T2.Tourist_Attraction_ID"}
{"sample_id": "train.5914", "db_id": "cre_Theme_park", "question": "Give me the star rating descriptions of the hotels that cost more than 10000.", "rationale": ["The query identifies the relevant tables, 'HOTELS' and 'Ref_Hotel_Star_Ratings'.", "It selects the 'star_rating_description' from the 'Ref_Hotel_Star_Ratings' table.", "A JOIN operation is performed on the 'star_rating_code' to link hotels with their respective star ratings.", "A condition is added to filter hotels based on their 'price_range' using a placeholder for numeric values."], "gold_sql": "SELECT T2.star_rating_description FROM HOTELS AS T1 JOIN Ref_Hotel_Star_Ratings AS T2 ON T1.star_rating_code  =  T2.star_rating_code WHERE T1.price_range  >  10000", "source_tables": ["ref_hotel_star_ratings", "hotels"], "description": "This virtual table provides the descriptions of star ratings for hotels that fall within a specified price range. The placeholder in the WHERE clause represents the price range threshold for filtering the hotels.", "virtual_table": "SELECT T2.star_rating_description FROM HOTELS AS T1 JOIN Ref_Hotel_Star_Ratings AS T2 ON T1.star_rating_code  =  T2.star_rating_code WHERE T1.price_range  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5902", "db_id": "cre_Theme_park", "question": "Return the detail of the location named \"UK Gallery\".", "rationale": ["The query identifies the relevant table, which is 'Locations'.", "Select the column to display, 'Other_Details'.", "Add a condition to filter the 'Location_Name' column for the specified location using a placeholder for string values."], "gold_sql": "SELECT Other_Details FROM LOCATIONS WHERE Location_Name  =  'UK Gallery'", "source_tables": ["locations"], "description": "This virtual table provides additional information about a specific location from the 'Locations' table based on the location's name. The placeholder in the WHERE clause represents the name of the location being queried.", "virtual_table": "SELECT Other_Details FROM LOCATIONS WHERE Location_Name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5924", "db_id": "cre_Theme_park", "question": "Find the details of the shops that can be reached by walk.", "rationale": ["The query identifies the relevant tables, which are 'SHOPS' and 'TOURIST_ATTRACTIONS'.", "It selects the 'Shop_Details' column from the 'SHOPS' table.", "A JOIN operation is performed to link 'SHOPS' with 'TOURIST_ATTRACTIONS' based on the matching 'Shop_ID' and 'Tourist_Attraction_ID'.", "A condition is added to filter the results based on the 'How_to_Get_There' column from the 'TOURIST_ATTRACTIONS' table, using a placeholder for string values."], "gold_sql": "SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  'walk'", "source_tables": ["shops", "tourist_attractions"], "description": "This virtual table provides the details of shops associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.", "virtual_table": "SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5887", "db_id": "cre_Theme_park", "question": "What are the price ranges of hotels?", "rationale": ["The query identifies the relevant table, which is 'Hotels'.", "Select the column to display, 'price_range'.", "This query is straightforward as it retrieves the price range for all hotels without any filtering conditions."], "gold_sql": "SELECT price_range FROM HOTELS", "source_tables": ["hotels"], "description": "The virtual table provides the price range of hotels from the 'Hotels' table. The placeholder in the SELECT statement allows for the specification of different hotel records based on the user's needs.", "virtual_table": "SELECT price_range FROM HOTELS"}
{"sample_id": "train.5901", "db_id": "cre_Theme_park", "question": "What is the detail of the location UK Gallery?", "rationale": ["The query identifies the relevant table, which is 'Locations'.", "Select the column to display, 'Other_Details'.", "Add a condition to filter the 'Location_Name' column for the specified location using a placeholder for string values."], "gold_sql": "SELECT Other_Details FROM LOCATIONS WHERE Location_Name  =  'UK Gallery'", "source_tables": ["locations"], "description": "This virtual table provides additional information about a specific location from the 'Locations' table based on the location's name. The placeholder in the WHERE clause represents the name of the location being queried.", "virtual_table": "SELECT Other_Details FROM LOCATIONS WHERE Location_Name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5888", "db_id": "cre_Theme_park", "question": "Tell me the price ranges for all the hotels.", "rationale": ["The query identifies the relevant table, which is 'Hotels'.", "Select the column to display, 'price_range'.", "The query does not include any filtering conditions, making it a straightforward selection of the price range for all hotels."], "gold_sql": "SELECT price_range FROM HOTELS", "source_tables": ["hotels"], "description": "The virtual table provides the price range of hotels from the 'Hotels' table. The placeholder in the SELECT statement allows for filtering based on specific criteria if needed.", "virtual_table": "SELECT price_range FROM HOTELS"}
{"sample_id": "train.2335", "db_id": "csu_1", "question": "What campuses are located in Northridge, Los Angeles or in San Francisco, San Francisco?", "rationale": ["The query identifies the relevant table, which is 'Campuses'.", "It selects the 'Campus' column to display the names of the campuses.", "The WHERE clause filters the results based on the specified 'Location' and 'County', using placeholders for string values.", "The UNION operator is used to combine results from two identical queries, allowing for campuses that meet either condition to be included."], "gold_sql": "SELECT campus FROM campuses WHERE LOCATION  =  'Northridge' AND county  =  'Los Angeles' UNION SELECT campus FROM campuses WHERE LOCATION  =  'San Francisco' AND county  =  'San Francisco'", "source_tables": ["campuses"], "description": "This virtual table retrieves the names of campuses from the 'Campuses' table that are located in a specific geographical location and county. The query uses placeholders for the location and county to allow for flexible input.", "virtual_table": "SELECT campus FROM campuses WHERE LOCATION  =  [PLACEHOLDER-TYPE:STRING] AND county  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT campus FROM campuses WHERE LOCATION  =  [PLACEHOLDER-TYPE:STRING] AND county  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2357", "db_id": "csu_1", "question": "how many degrees were conferred between 1998 and 2002?", "rationale": ["The query identifies the relevant tables, 'Campuses' and 'degrees'.", "It selects the 'campus' from the 'Campuses' table and sums the 'degrees' from the 'degrees' table.", "A JOIN operation is performed on the 'Campus' identifier to link the two tables.", "The WHERE clause filters the results based on a specified range of years using placeholders for numeric values.", "The results are grouped by 'campus' to provide a total count of degrees awarded per campus."], "gold_sql": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  1998 AND T2.year  <=  2002 GROUP BY T1.campus", "source_tables": ["degrees", "campuses"], "description": "This virtual table summarizes the total number of degrees awarded for each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.", "virtual_table": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.year  <=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus"}
{"sample_id": "train.2378", "db_id": "csu_1", "question": "List the campus that have between 600 and 1000 faculty lines in year 2004.", "rationale": ["The query identifies the relevant tables, which are 'Campuses' and 'faculty'.", "It selects the 'campus' column from the 'Campuses' table.", "The query joins the 'Campuses' table with the 'faculty' table using the campus identifier.", "Conditions are added to filter the results based on the number of faculty members using placeholders for numeric values.", "Another condition is added to filter the results based on the year using a placeholder for numeric values."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  600 AND t2.faculty  <=  1000 AND T1.year  =  2004", "source_tables": ["faculty", "campuses"], "description": "This virtual table lists the campuses from the 'Campuses' table that have a number of faculty members within a specified range. The query joins the 'Campuses' table with the 'faculty' table based on the campus identifier, and filters the results based on the number of faculty members and the year of the data record. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the specific year.", "virtual_table": "SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  [PLACEHOLDER-TYPE:NUMBER] AND t2.faculty  <=  [PLACEHOLDER-TYPE:NUMBER] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2379", "db_id": "csu_1", "question": "What are the campuses that had between 600 and 1000 faculty members in 2004?", "rationale": ["The query identifies the relevant tables, 'Campuses' and 'faculty'.", "It selects the 'campus' column from the 'Campuses' table.", "A JOIN operation is performed between 'Campuses' and 'faculty' on the campus identifier.", "Conditions are added to filter the faculty count to be within a specified range using placeholders for numeric values.", "Another condition is added to filter the results based on the specified year using a placeholder for numeric values."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  600 AND t2.faculty  <=  1000 AND T1.year  =  2004", "source_tables": ["faculty", "campuses"], "description": "This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.", "virtual_table": "SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  [PLACEHOLDER-TYPE:NUMBER] AND t2.faculty  <=  [PLACEHOLDER-TYPE:NUMBER] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2358", "db_id": "csu_1", "question": "For each Orange county campus, report the number of degrees granted after 2000.", "rationale": ["The query identifies the relevant tables, 'Campuses' and 'degrees'.", "It selects the 'campus' from the 'Campuses' table and sums the 'degrees' from the 'degrees' table.", "A JOIN operation is performed on the 'Campus' identifier to link the two tables.", "Conditions are added to filter the results based on the specified county and year using placeholders for string and numeric values.", "The results are grouped by campus to provide a total count of degrees awarded per campus."], "gold_sql": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  'Orange' AND T2.year  >=  2000 GROUP BY T1.campus", "source_tables": ["degrees", "campuses"], "description": "This virtual table summarizes the total number of degrees awarded by campus for a specific county and year range. The placeholders in the WHERE clause represent the county name and the minimum year for filtering the data.", "virtual_table": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  [PLACEHOLDER-TYPE:STRING] AND T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus"}
{"sample_id": "train.2349", "db_id": "csu_1", "question": "What campus has the most degrees  conferrred over its entire existence?", "rationale": ["The query identifies the relevant table, which is 'degrees'.", "It selects the 'campus' column to display the names of the campuses.", "The results are grouped by 'campus' to aggregate the data.", "The campuses are ordered by the sum of degrees awarded in descending order to show the campuses with the highest number of degrees first.", "A limit is applied to restrict the number of campuses returned, using a placeholder for numeric values."], "gold_sql": "SELECT campus FROM degrees GROUP BY campus ORDER BY sum(degrees) DESC LIMIT 1", "source_tables": ["degrees"], "description": "This virtual table provides a list of campuses from the 'degrees' table, grouped by campus name. The campuses are ordered by the total number of degrees awarded, in descending order, and the result is limited to a specified number of campuses. The placeholder in the LIMIT clause represents the maximum number of campuses to return.", "virtual_table": "SELECT campus FROM degrees GROUP BY campus ORDER BY sum(degrees) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
