{"sample_id": "train.56", "db_id": "student_assessment", "question": "which course has most number of registered students?", "rationale": ["Identify the relevant tables: We need to look at the 'Student_Course_Registrations' table to find out how many students are registered for each course.", "Count the number of students for each course: We can use the COUNT() function to count the number of student IDs associated with each course ID.", "Group the results by course: We will use GROUP BY to aggregate the counts for each course.", "Order the results: To find the course with the most registered students, we will order the results in descending order based on the count of students.", "Limit the results to one: Since we only want the course with the most students, we will use LIMIT 1 to get the top result."], "gold_sql": "SELECT T1.course_name FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_Id GROUP BY T1.course_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["courses", "student_course_registrations"], "pred_sql": "SELECT course_id, COUNT(student_id) AS number_of_students \nFROM Student_Course_Registrations \nGROUP BY course_id \nORDER BY number_of_students DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of all course registrations for students who have not attended any courses. The query retrieves all columns from the 'student_course_registrations' table, filtering out students based on their attendance records.\",\n        \"virtual_table\": \"SELECT * FROM student_course_registrations WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)\"\n    }\n}\n"}
{"sample_id": "train.64", "db_id": "student_assessment", "question": "List the id of students who attended some courses?", "rationale": ["The question asks for the IDs of students who attended some courses.", "To find students who attended courses, we need to look at the 'Student_Course_Attendance' table, which records attendance by student ID and course ID.", "We can select the distinct student IDs from the 'Student_Course_Attendance' table to ensure we only get unique IDs of students who have attended at least one course."], "gold_sql": "SELECT student_id FROM student_course_attendance", "source_tables": ["student_course_attendance"], "pred_sql": "SELECT DISTINCT student_id FROM Student_Course_Attendance;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of all course registrations for students who have not attended any courses. The query retrieves all columns from the 'student_course_registrations' table, filtering out students based on their attendance records.\",\n        \"virtual_table\": \"SELECT * FROM student_course_registrations WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)\"\n    }\n}\n"}
{"sample_id": "train.65", "db_id": "student_assessment", "question": "What are the ids of all students who have attended at least one course?", "rationale": ["We need to find the IDs of all students who have attended at least one course.", "To do this, we will query the 'Student_Course_Attendance' table, which records attendance for students in courses.", "We will select the 'student_id' from the 'Student_Course_Attendance' table.", "Using DISTINCT ensures that we only get unique student IDs, as a student may have attended multiple courses."], "gold_sql": "SELECT student_id FROM student_course_attendance", "source_tables": ["student_course_attendance"], "pred_sql": "SELECT DISTINCT student_id FROM Student_Course_Attendance;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of all course registrations for students who have not attended any courses. The query retrieves all columns from the 'student_course_registrations' table, filtering out students based on their attendance records.\",\n        \"virtual_table\": \"SELECT * FROM student_course_registrations WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)\"\n    }\n}\n"}
{"sample_id": "train.76", "db_id": "student_assessment", "question": "What is the id of the candidate who most recently accessed the course?", "rationale": ["Identify the relevant tables: Candidates, Student_Course_Attendance, and Student_Course_Registrations.", "We need to find the candidate who accessed a course, which means we need to join Candidates with Student_Course_Attendance.", "The join condition will be based on the candidate_id matching the student_id in Student_Course_Attendance.", "We also need to ensure that we are considering the correct course, so we will join with Student_Course_Registrations on student_id and course_id.", "To find the most recent access, we will order the results by date_of_attendance in descending order.", "Finally, we will limit the results to 1 to get the most recent candidate."], "gold_sql": "SELECT candidate_id FROM candidate_assessments ORDER BY assessment_date DESC LIMIT 1", "source_tables": ["candidate_assessments"], "pred_sql": "SELECT c.candidate_id\nFROM Candidates c\nJOIN Student_Course_Attendance sca ON c.candidate_id = sca.student_id\nJOIN Student_Course_Registrations scr ON sca.student_id = scr.student_id AND sca.course_id = scr.course_id\nORDER BY sca.date_of_attendance DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.77", "db_id": "student_assessment", "question": "What is detail of the student who registered the most number of courses?", "rationale": ["We need to find the student who registered for the most number of courses.", "To do this, we will join the 'Student_Course_Registrations' table with the 'Students' table using the student_id.", "We will group the results by student_id to count the number of courses each student has registered for.", "We will order the results in descending order based on the count of course registrations.", "Finally, we will limit the results to 1 to get the student with the highest number of registrations."], "gold_sql": "SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_course_registrations", "students"], "pred_sql": "SELECT T2.student_details \nFROM Student_Course_Registrations AS T1 \nJOIN Students AS T2 ON T1.student_id = T2.student_id \nGROUP BY T1.student_id \nORDER BY COUNT(T1.course_id) DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of all course registrations for students who have not attended any courses. The query retrieves all columns from the 'student_course_registrations' table, filtering out students based on their attendance records.\",\n        \"virtual_table\": \"SELECT * FROM student_course_registrations WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)\"\n    }\n}\n"}
{"sample_id": "train.82", "db_id": "student_assessment", "question": "For each course id, how many students are registered and what are the course names?", "rationale": ["We need to retrieve the course ID and course names along with the count of registered students for each course.", "To achieve this, we will join the 'Student_Course_Registrations' table with the 'Courses' table using the course_id as the common key.", "We will use the COUNT() function to count the number of students registered for each course.", "We will group the results by course_id and course_name to get the count for each course."], "gold_sql": "SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id", "source_tables": ["courses", "student_course_registrations", "students"], "pred_sql": "SELECT SC.course_id, C.course_name, COUNT(SC.student_id) AS student_count \nFROM Student_Course_Registrations AS SC \nJOIN Courses AS C ON SC.course_id = C.course_id \nGROUP BY SC.course_id, C.course_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of all course registrations for students who have not attended any courses. The query retrieves all columns from the 'student_course_registrations' table, filtering out students based on their attendance records.\",\n        \"virtual_table\": \"SELECT * FROM student_course_registrations WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)\"\n    }\n}\n"}
{"sample_id": "train.90", "db_id": "student_assessment", "question": "What are the ids of the students who registered for course 301 most recently?", "rationale": ["Identify the relevant tables: We need to look at the 'Student_Course_Registrations' table to find students registered for a specific course.", "Filter by course_id: We will filter the results to only include registrations for course 301.", "Order by registration_date: To find the most recent registration, we will order the results by the 'registration_date' in descending order.", "Limit the results: Since we only want the most recent registration, we will limit the results to 1."], "gold_sql": "SELECT student_id FROM student_course_attendance WHERE course_id = 301 ORDER BY date_of_attendance DESC LIMIT 1", "source_tables": ["student_course_attendance"], "pred_sql": "SELECT student_id FROM Student_Course_Registrations WHERE course_id = '301' ORDER BY registration_date DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.93", "db_id": "student_assessment", "question": "Find distinct cities of address of students?", "rationale": ["We need to find distinct cities of addresses associated with students.", "The 'Addresses' table contains the city information.", "The 'People_Addresses' table links people to their addresses.", "The 'Students' table contains the student information and links to the 'People' table via the 'person_id'.", "To get the distinct cities of addresses for students, we will join the 'Addresses', 'People_Addresses', and 'Students' tables.", "The SQL query will select distinct cities from the 'Addresses' table where the addresses are linked to students through the 'People_Addresses' table."], "gold_sql": "SELECT DISTINCT T1.city FROM addresses AS T1 JOIN people_addresses AS T2 ON T1.address_id = T2.address_id JOIN students AS T3 ON T2.person_id = T3.student_id", "source_tables": ["addresses", "people_addresses", "students"], "pred_sql": "SELECT DISTINCT T1.city FROM Addresses AS T1 JOIN People_Addresses AS T2 ON T1.address_id = T2.address_id JOIN Students AS T3 ON T2.person_id = T3.student_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique cities from the 'Addresses' table that are associated with people through the 'People_Addresses' table. The placeholder in the JOIN clause represents the relationship between addresses and people.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.city FROM addresses AS T1 JOIN people_addresses AS T2 ON T1.address_id = T2.address_id\"\n    }\n}\n"}
{"sample_id": "train.104", "db_id": "student_assessment", "question": "What are all details of the students who registered but did not attend any course?", "rationale": ["We need to find all details of students who registered for courses but did not attend any courses.", "First, we identify students who registered for courses by querying the 'Student_Course_Registrations' table.", "Next, we need to filter out those students who have attended any courses by checking against the 'Student_Course_Attendance' table.", "We can use a subquery to get the list of student IDs from 'Student_Course_Attendance' and exclude them from our main query.", "Finally, we join this information with the 'Students' table to get all details of the students who meet the criteria."], "gold_sql": "SELECT * FROM student_course_registrations WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)", "source_tables": ["student_course_attendance", "student_course_registrations"], "pred_sql": "SELECT S.* FROM Students AS S WHERE S.student_id IN (SELECT SCR.student_id FROM Student_Course_Registrations AS SCR WHERE SCR.student_id NOT IN (SELECT SCA.student_id FROM Student_Course_Attendance AS SCA))", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of all course registrations for students who have not attended any courses. The query retrieves all columns from the 'student_course_registrations' table, filtering out students based on their attendance records.\",\n        \"virtual_table\": \"SELECT * FROM student_course_registrations WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.105", "db_id": "student_assessment", "question": "List the id of students who registered course statistics in the order of registration date.", "rationale": ["Identify the relevant tables: We need to look at the 'Student_Course_Registrations' table to find students who registered for courses, and the 'Courses' table to filter for the course named 'Statistics'.", "Join the 'Student_Course_Registrations' table with the 'Courses' table to filter registrations specifically for the course 'Statistics'.", "Select the 'student_id' from the filtered results to get the IDs of students who registered for the course.", "Order the results by 'registration_date' to meet the requirement of listing them in the order of registration."], "gold_sql": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = 'statistics' ORDER BY T2.registration_date", "source_tables": ["courses", "student_course_registrations"], "pred_sql": "SELECT student_id FROM Student_Course_Registrations WHERE course_id = (SELECT course_id FROM Courses WHERE course_name = 'Statistics') ORDER BY registration_date;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of all course registrations for students who have not attended any courses. The query retrieves all columns from the 'student_course_registrations' table, filtering out students based on their attendance records.\",\n        \"virtual_table\": \"SELECT * FROM student_course_registrations WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)\"\n    }\n}\n"}
{"sample_id": "train.106", "db_id": "student_assessment", "question": "What are the ids of the students who registered course statistics by order of registration date?", "rationale": ["Identify the relevant tables: We need to use the 'Student_Course_Registrations' table to find students who registered for courses and the 'Students' table to get student details.", "Filter for the specific course: We need to filter the registrations to only include those for the course 'Statistics'.", "Join the tables: We will join 'Student_Course_Registrations' with 'Students' on the student_id to get the student details along with their registration information.", "Order by registration date: We will order the results by the registration date to get the ids in the order they registered.", "Select the student ids: Finally, we will select the student ids from the joined result."], "gold_sql": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = 'statistics' ORDER BY T2.registration_date", "source_tables": ["courses", "student_course_registrations"], "pred_sql": "SELECT T1.student_id FROM Student_Course_Registrations AS T1 JOIN Students AS T2 ON T1.student_id = T2.student_id WHERE T1.course_id = (SELECT course_id FROM Courses WHERE course_name = 'Statistics') ORDER BY T1.registration_date;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of all course registrations for students who have not attended any courses. The query retrieves all columns from the 'student_course_registrations' table, filtering out students based on their attendance records.\",\n        \"virtual_table\": \"SELECT * FROM student_course_registrations WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)\"\n    }\n}\n"}
{"sample_id": "train.123", "db_id": "bike_1", "question": "For each zip code, return the average mean temperature of August there.", "rationale": ["Identify the relevant table: The 'weather' table contains the temperature data and zip codes.", "Determine the required fields: We need the 'zip_code' and the average of 'mean_temperature_f'.", "Filter the data for August: We will filter the records to include only those from August (assuming the year is 2023 for this example).", "Group the results by zip code: To get the average temperature for each zip code, we will use the GROUP BY clause.", "Construct the SQL query: Combine all the elements into a complete SQL query."], "gold_sql": "SELECT zip_code  ,  avg(mean_temperature_f) FROM weather WHERE date LIKE '8/%' GROUP BY zip_code", "source_tables": ["weather"], "pred_sql": "SELECT zip_code, AVG(mean_temperature_f) AS average_mean_temperature\nFROM weather\nWHERE date BETWEEN '2023-08-01' AND '2023-08-31'\nGROUP BY zip_code;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates and zip codes of weather reports where the maximum temperature reached a specified threshold. The placeholder in the WHERE clause represents the minimum temperature value to filter the results.\",\n        \"virtual_table\": \"SELECT date ,  zip_code FROM weather WHERE max_temperature_f  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the dates and zip codes of weather reports where the maximum temperature reached a specified threshold. The placeholder in the WHERE clause represents the minimum temperature value to filter the results.\",\n        \"virtual_table\": \"SELECT date ,  zip_code FROM weather WHERE max_temperature_f  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average latitude and longitude of bike stations from the 'station' table where trips have started. The placeholders in the query allow for further filtering or modifications based on specific criteria.\",\n        \"virtual_table\": \"SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id\"\n    }\n}\n"}
{"sample_id": "train.135", "db_id": "bike_1", "question": "Which bike traveled the most often in zip code 94002?", "rationale": ["Identify the relevant table: The 'trip' table contains information about bike trips, including the bike ID and zip code.", "Filter trips by zip code: We need to focus on trips that started in the zip code 94002, so we will add a WHERE clause to filter by zip_code.", "Count the number of trips for each bike: We will use the COUNT function to count how many times each bike_id appears in the filtered results.", "Group the results by bike_id: To get the count of trips for each bike, we will use the GROUP BY clause on bike_id.", "Order the results: We want to find the bike that traveled the most often, so we will order the results in descending order based on the trip count.", "Limit the results to one: Since we only want the bike that traveled the most often, we will use the LIMIT clause to return only the top result."], "gold_sql": "SELECT bike_id FROM trip WHERE zip_code  =  94002 GROUP BY bike_id ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["trip"], "pred_sql": "SELECT bike_id, COUNT(*) as trip_count \nFROM trip \nWHERE zip_code = '94002' \nGROUP BY bike_id \nORDER BY trip_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the unique identifiers of trips from the 'trip' table, specifically focusing on those that started at various bike stations. The results are ordered by the number of docks available at each station in descending order, allowing users to see which stations with the most docks are associated with the trips. The placeholder in the LIMIT clause represents the maximum number of trip IDs to return.\",\n        \"virtual_table\": \"SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average latitude and longitude of bike stations from the 'station' table where trips have started. The placeholders in the query allow for further filtering or modifications based on specific criteria.\",\n        \"virtual_table\": \"SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average latitude and longitude of bike stations from the 'station' table where trips have started. The placeholders in the query allow for further filtering or modifications based on specific criteria.\",\n        \"virtual_table\": \"SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id\"\n    }\n}\n"}
{"sample_id": "train.136", "db_id": "bike_1", "question": "What is the id of the bike that traveled the most in 94002?", "rationale": ["Identify the relevant table: The 'trip' table contains information about bike trips, including the bike ID and duration.", "Filter trips by zip code: We need to focus on trips that started in the zip code '94002'.", "Order the results: To find the bike that traveled the most, we will order the trips by their duration in descending order.", "Limit the results: We only need the bike ID of the trip with the maximum duration, so we will limit the results to 1."], "gold_sql": "SELECT bike_id FROM trip WHERE zip_code  =  94002 GROUP BY bike_id ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["trip"], "pred_sql": "SELECT bike_id FROM trip WHERE zip_code = '94002' ORDER BY duration DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the unique identifiers of trips from the 'trip' table, specifically focusing on those that started at various bike stations. The results are ordered by the number of docks available at each station in descending order, allowing users to see which stations with the most docks are associated with the trips. The placeholder in the LIMIT clause represents the maximum number of trip IDs to return.\",\n        \"virtual_table\": \"SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average latitude and longitude of bike stations from the 'station' table where trips have started. The placeholders in the query allow for further filtering or modifications based on specific criteria.\",\n        \"virtual_table\": \"SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average latitude and longitude of bike stations from the 'station' table where trips have started. The placeholders in the query allow for further filtering or modifications based on specific criteria.\",\n        \"virtual_table\": \"SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id\"\n    }\n}\n"}
{"sample_id": "train.143", "db_id": "bike_1", "question": "What are the names and ids of stations that had more than 14 bikes available on average or were installed in December?", "rationale": ["We need to select the names and ids of stations.", "The relevant tables are 'station' and 'status' because we need bike availability and station details.", "We will join the 'station' table with the 'status' table on the station id.", "We need to calculate the average number of bikes available for each station, so we will use GROUP BY on the station id.", "We will use HAVING to filter the results where the average bikes available is greater than 14 or the installation date is in December.", "To check the month of the installation date, we can use the strftime function to extract the month from the installation_date."], "gold_sql": "SELECT T1.name ,  T1.id FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(T2.bikes_available)  >  14 UNION SELECT name ,  id FROM station WHERE installation_date LIKE '12/%'", "source_tables": ["status", "station"], "pred_sql": "SELECT s.name, s.id \nFROM station s \nJOIN status st ON s.id = st.station_id \nGROUP BY s.id \nHAVING AVG(st.bikes_available) > 14 OR strftime('%m', s.installation_date) = '12';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the unique identifiers of trips from the 'trip' table, specifically focusing on those that started at various bike stations. The results are ordered by the number of docks available at each station in descending order, allowing users to see which stations with the most docks are associated with the trips. The placeholder in the LIMIT clause represents the maximum number of trip IDs to return.\",\n        \"virtual_table\": \"SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average latitude and longitude of bike stations from the 'station' table where trips have started. The placeholders in the query allow for further filtering or modifications based on specific criteria.\",\n        \"virtual_table\": \"SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average latitude and longitude of bike stations from the 'station' table where trips have started. The placeholders in the query allow for further filtering or modifications based on specific criteria.\",\n        \"virtual_table\": \"SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id\"\n    }\n}\n"}
{"sample_id": "train.144", "db_id": "bike_1", "question": "What are the names and ids of all stations that have more than 14 bikes available on average or had bikes installed in December?", "rationale": ["We need to find the names and ids of all stations that meet two criteria: (1) have more than 14 bikes available on average, and (2) had bikes installed in December.", "To achieve this, we will join the 'station' table with the 'status' table on the station id.", "We will group the results by station id to calculate the average number of bikes available for each station.", "We will use the HAVING clause to filter the results based on the average number of bikes available being greater than 14.", "Additionally, we will check if the installation date of the station falls in December using the LIKE operator with a pattern that matches December dates."], "gold_sql": "SELECT T1.name ,  T1.id FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(T2.bikes_available)  >  14 UNION SELECT name ,  id FROM station WHERE installation_date LIKE '12/%'", "source_tables": ["status", "station"], "pred_sql": "SELECT s.name, s.id \nFROM station s \nJOIN status st ON s.id = st.station_id \nGROUP BY s.id \nHAVING AVG(st.bikes_available) > 14 \n   OR s.installation_date LIKE '____-12-%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the unique identifiers of trips from the 'trip' table, specifically focusing on those that started at various bike stations. The results are ordered by the number of docks available at each station in descending order, allowing users to see which stations with the most docks are associated with the trips. The placeholder in the LIMIT clause represents the maximum number of trip IDs to return.\",\n        \"virtual_table\": \"SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average latitude and longitude of bike stations from the 'station' table where trips have started. The placeholders in the query allow for further filtering or modifications based on specific criteria.\",\n        \"virtual_table\": \"SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average latitude and longitude of bike stations from the 'station' table where trips have started. The placeholders in the query allow for further filtering or modifications based on specific criteria.\",\n        \"virtual_table\": \"SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id\"\n    }\n}\n"}
{"sample_id": "train.145", "db_id": "bike_1", "question": "What is the 3 most common cloud cover rates in the region of zip code 94107?", "rationale": ["Identify the relevant table: The question pertains to cloud cover rates, which are found in the 'weather' table.", "Filter by zip code: We need to filter the results to only include records where the zip code is 94107.", "Group by cloud cover: To find the most common cloud cover rates, we will group the results by the 'cloud_cover' column.", "Count occurrences: We will count the occurrences of each cloud cover rate using COUNT(cloud_cover).", "Order by count: To get the most common rates, we will order the results in descending order based on the count.", "Limit the results: Finally, we will limit the results to the top 3 most common cloud cover rates."], "gold_sql": "SELECT cloud_cover FROM weather WHERE zip_code  =  94107 GROUP BY cloud_cover ORDER BY COUNT (*) DESC LIMIT 3", "source_tables": ["weather"], "pred_sql": "SELECT cloud_cover, COUNT(cloud_cover) as count FROM weather WHERE zip_code = 94107 GROUP BY cloud_cover ORDER BY count DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates and zip codes of weather reports where the maximum temperature reached a specified threshold. The placeholder in the WHERE clause represents the minimum temperature value to filter the results.\",\n        \"virtual_table\": \"SELECT date ,  zip_code FROM weather WHERE max_temperature_f  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the dates and zip codes of weather reports where the maximum temperature reached a specified threshold. The placeholder in the WHERE clause represents the minimum temperature value to filter the results.\",\n        \"virtual_table\": \"SELECT date ,  zip_code FROM weather WHERE max_temperature_f  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.161", "db_id": "bike_1", "question": "For each trip, return its ending station's installation date.", "rationale": ["Identify the relevant tables: We need to use the 'trip' table to get the trips and the 'station' table to get the installation dates of the ending stations.", "Join the 'trip' table with the 'station' table on the ending station ID to access the installation date.", "Select the ending station ID and the installation date from the joined tables."], "gold_sql": "SELECT T1.id ,  T2.installation_date FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id", "source_tables": ["trip", "station"], "pred_sql": "SELECT T1.end_station_id, S.installation_date FROM trip AS T1 JOIN station AS S ON T1.end_station_id = S.id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the unique identifiers of trips from the 'trip' table, specifically focusing on those that started at various bike stations. The results are ordered by the number of docks available at each station in descending order, allowing users to see which stations with the most docks are associated with the trips. The placeholder in the LIMIT clause represents the maximum number of trip IDs to return.\",\n        \"virtual_table\": \"SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average latitude and longitude of bike stations from the 'station' table where trips have started. The placeholders in the query allow for further filtering or modifications based on specific criteria.\",\n        \"virtual_table\": \"SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average latitude and longitude of bike stations from the 'station' table where trips have started. The placeholders in the query allow for further filtering or modifications based on specific criteria.\",\n        \"virtual_table\": \"SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id\"\n    }\n}\n"}
{"sample_id": "train.162", "db_id": "bike_1", "question": "What is the installation date for each ending station on all the trips?", "rationale": ["Identify the relevant tables: We need information from the 'station' table for installation dates and the 'trip' table to link trips to their ending stations.", "Determine the relationship: The 'trip' table has 'end_station_id' which corresponds to 'id' in the 'station' table.", "Construct the SQL query: We will join the 'station' table with the 'trip' table on the condition that the 'id' of the station matches the 'end_station_id' of the trip.", "Select the distinct installation dates from the 'station' table for each ending station involved in the trips."], "gold_sql": "SELECT T1.id ,  T2.installation_date FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id", "source_tables": ["trip", "station"], "pred_sql": "SELECT DISTINCT S.installation_date FROM station AS S JOIN trip AS T ON S.id = T.end_station_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the unique identifiers of trips from the 'trip' table, specifically focusing on those that started at various bike stations. The results are ordered by the number of docks available at each station in descending order, allowing users to see which stations with the most docks are associated with the trips. The placeholder in the LIMIT clause represents the maximum number of trip IDs to return.\",\n        \"virtual_table\": \"SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average latitude and longitude of bike stations from the 'station' table where trips have started. The placeholders in the query allow for further filtering or modifications based on specific criteria.\",\n        \"virtual_table\": \"SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average latitude and longitude of bike stations from the 'station' table where trips have started. The placeholders in the query allow for further filtering or modifications based on specific criteria.\",\n        \"virtual_table\": \"SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id\"\n    }\n}\n"}
{"sample_id": "train.163", "db_id": "bike_1", "question": "Which trip started from the station with the largest dock count? Give me the trip id.", "rationale": ["Identify the relevant tables: 'trip' for trip details and 'station' for station details.", "Join the 'trip' table with the 'station' table on the condition that the start_station_id in 'trip' matches the id in 'station'.", "Select the trip id from the 'trip' table (aliased as T1).", "Order the results by the dock_count from the 'station' table (aliased as T2) in descending order to get the station with the largest dock count first.", "Limit the results to 1 to get only the trip that started from the station with the largest dock count."], "gold_sql": "SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT 1", "source_tables": ["trip", "station"], "pred_sql": "SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id = T2.id ORDER BY T2.dock_count DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the unique identifiers of trips from the 'trip' table, specifically focusing on those that started at various bike stations. The results are ordered by the number of docks available at each station in descending order, allowing users to see which stations with the most docks are associated with the trips. The placeholder in the LIMIT clause represents the maximum number of trip IDs to return.\",\n        \"virtual_table\": \"SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of trip identifiers and their corresponding durations from the 'trip' table, sorted in descending order by duration. The placeholder in the LIMIT clause allows the user to specify the maximum number of records to return.\",\n        \"virtual_table\": \"SELECT id ,  duration FROM trip ORDER BY duration DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average latitude and longitude of bike stations from the 'station' table where trips have started. The placeholders in the query allow for further filtering or modifications based on specific criteria.\",\n        \"virtual_table\": \"SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id\"\n    }\n}\n"}
{"sample_id": "train.165", "db_id": "bike_1", "question": "Count the number of trips that did not end in San Francisco city.", "rationale": ["Identify the relevant tables: We need to count trips from the 'trip' table and filter based on the 'station' table for the city.", "Join the 'trip' table with the 'station' table on the end station ID to access the city information.", "Use a WHERE clause to filter out trips that ended in 'San Francisco'.", "Count the remaining trips that do not meet the criteria."], "gold_sql": "SELECT count(*) FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id WHERE T2.city !=  'San Francisco'", "source_tables": ["trip", "station"], "pred_sql": "SELECT COUNT(*) FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id = T2.id WHERE T2.city != 'San Francisco';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the unique identifiers of trips from the 'trip' table, specifically focusing on those that started at various bike stations. The results are ordered by the number of docks available at each station in descending order, allowing users to see which stations with the most docks are associated with the trips. The placeholder in the LIMIT clause represents the maximum number of trip IDs to return.\",\n        \"virtual_table\": \"SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.166", "db_id": "bike_1", "question": "How many trips did not end in San Francisco?", "rationale": ["Identify the relevant table: The 'trip' table contains information about trips, including the end station name.", "Determine the condition: We need to count trips that did not end in San Francisco, which means we will filter the results where the 'end_station_name' is not equal to 'San Francisco'.", "Construct the SQL query: We will use the COUNT function to count the number of trips that meet the condition. The final query will select the count from the 'trip' table with the specified condition."], "gold_sql": "SELECT count(*) FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id WHERE T2.city != 'San Francisco'", "source_tables": ["trip", "station"], "pred_sql": "SELECT COUNT(*) FROM trip WHERE end_station_name != 'San Francisco';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the unique identifiers of trips from the 'trip' table, specifically focusing on those that started at various bike stations. The results are ordered by the number of docks available at each station in descending order, allowing users to see which stations with the most docks are associated with the trips. The placeholder in the LIMIT clause represents the maximum number of trip IDs to return.\",\n        \"virtual_table\": \"SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.167", "db_id": "bike_1", "question": "In zip code 94107, on which day neither Fog nor Rain was not observed?", "rationale": ["Identify the relevant table: The question pertains to weather conditions, so we will use the 'weather' table.", "Filter by zip code: We need to focus on records where the zip code is 94107.", "Exclude specific weather events: We need to ensure that the events do not include 'Fog' or 'Rain'.", "Construct the SQL query: We will select the 'date' from the 'weather' table where the zip code is 94107 and the events do not include 'Fog' or 'Rain'."], "gold_sql": "SELECT date FROM weather WHERE zip_code  =  94107 AND EVENTS != 'Fog' AND EVENTS != 'Rain'", "source_tables": ["weather"], "pred_sql": "SELECT date FROM weather WHERE zip_code = 94107 AND events NOT LIKE '%Fog%' AND events NOT LIKE '%Rain%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates and zip codes of weather reports where the maximum temperature reached a specified threshold. The placeholder in the WHERE clause represents the minimum temperature value to filter the results.\",\n        \"virtual_table\": \"SELECT date ,  zip_code FROM weather WHERE max_temperature_f  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the dates and zip codes of weather reports where the maximum temperature reached a specified threshold. The placeholder in the WHERE clause represents the minimum temperature value to filter the results.\",\n        \"virtual_table\": \"SELECT date ,  zip_code FROM weather WHERE max_temperature_f  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.168", "db_id": "bike_1", "question": "On which day has it neither been foggy nor rained in the zip code of 94107?", "rationale": ["Identify the relevant table: The 'weather' table contains the necessary information about weather events and precipitation.", "Filter by zip code: We need to focus on the zip code 94107, so we will include a WHERE clause for this zip code.", "Check for no fog or rain: We need to ensure that there are no weather events (fog or rain), which can be checked by ensuring the 'events' column is NULL, and also check that 'precipitation_inches' is 0 to confirm no rain occurred.", "Select the date: Finally, we want to retrieve the date(s) that meet these criteria."], "gold_sql": "SELECT date FROM weather WHERE zip_code  =  94107 AND EVENTS != 'Fog' AND EVENTS != 'Rain'", "source_tables": ["weather"], "pred_sql": "SELECT date FROM weather WHERE zip_code = 94107 AND events IS NULL AND precipitation_inches = 0;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates and zip codes of weather reports where the maximum temperature reached a specified threshold. The placeholder in the WHERE clause represents the minimum temperature value to filter the results.\",\n        \"virtual_table\": \"SELECT date ,  zip_code FROM weather WHERE max_temperature_f  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the dates and zip codes of weather reports where the maximum temperature reached a specified threshold. The placeholder in the WHERE clause represents the minimum temperature value to filter the results.\",\n        \"virtual_table\": \"SELECT date ,  zip_code FROM weather WHERE max_temperature_f  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.183", "db_id": "bike_1", "question": "List all the cities in a decreasing order of each city's stations' highest latitude.", "rationale": ["We need to list all the cities from the station table.", "To find the highest latitude for each city, we can use the MAX function on the 'lat' column.", "We will group the results by 'city' to ensure we get the highest latitude for each city.", "Finally, we will order the results in descending order based on the highest latitude."], "gold_sql": "SELECT city FROM station GROUP BY city ORDER BY max(lat) DESC", "source_tables": ["station"], "pred_sql": "SELECT city, MAX(lat) AS highest_latitude \nFROM station \nGROUP BY city \nORDER BY highest_latitude DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average latitude and longitude of bike stations from the 'station' table where trips have started. The placeholders in the query allow for further filtering or modifications based on specific criteria.\",\n        \"virtual_table\": \"SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average latitude and longitude of bike stations from the 'station' table where trips have started. The placeholders in the query allow for further filtering or modifications based on specific criteria.\",\n        \"virtual_table\": \"SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the unique identifiers of trips from the 'trip' table, specifically focusing on those that started at various bike stations. The results are ordered by the number of docks available at each station in descending order, allowing users to see which stations with the most docks are associated with the trips. The placeholder in the LIMIT clause represents the maximum number of trip IDs to return.\",\n        \"virtual_table\": \"SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.184", "db_id": "bike_1", "question": "For each city, list their names in decreasing order by their highest station latitude.", "rationale": ["We need to list the names of bike stations for each city ordered by their highest latitude.", "To find the highest latitude for each city, we can use a subquery that selects the maximum latitude from the station table, grouped by city.", "We will then join this result back to the station table to get the names of the stations that correspond to these maximum latitudes.", "Finally, we will order the results by latitude in descending order to meet the requirement of the query."], "gold_sql": "SELECT city FROM station GROUP BY city ORDER BY max(lat) DESC", "source_tables": ["station"], "pred_sql": "SELECT city, name FROM station WHERE lat = (SELECT MAX(lat) FROM station GROUP BY city) ORDER BY lat DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average latitude and longitude of bike stations from the 'station' table where trips have started. The placeholders in the query allow for further filtering or modifications based on specific criteria.\",\n        \"virtual_table\": \"SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average latitude and longitude of bike stations from the 'station' table where trips have started. The placeholders in the query allow for further filtering or modifications based on specific criteria.\",\n        \"virtual_table\": \"SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the unique identifiers of trips from the 'trip' table, specifically focusing on those that started at various bike stations. The results are ordered by the number of docks available at each station in descending order, allowing users to see which stations with the most docks are associated with the trips. The placeholder in the LIMIT clause represents the maximum number of trip IDs to return.\",\n        \"virtual_table\": \"SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.189", "db_id": "bike_1", "question": "For each station, return its longitude and the average duration of trips that started from the station.", "rationale": ["We need to select the longitude of each station and the average duration of trips that started from that station.", "To get the longitude, we will select the 'long' column from the 'station' table.", "To calculate the average duration of trips, we will use the 'duration' column from the 'trip' table.", "We will join the 'station' table with the 'trip' table on the condition that the station's id matches the start_station_id in the trip table.", "We will group the results by the station id to ensure we get the average duration for each station."], "gold_sql": "SELECT T1.name ,  T1.long ,  avg(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id GROUP BY T2.start_station_id", "source_tables": ["trip", "station"], "pred_sql": "SELECT S.long, AVG(T.duration) AS average_duration\nFROM station AS S\nJOIN trip AS T ON S.id = T.start_station_id\nGROUP BY S.id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average latitude and longitude of bike stations from the 'station' table where trips have started. The placeholders in the query allow for further filtering or modifications based on specific criteria.\",\n        \"virtual_table\": \"SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average latitude and longitude of bike stations from the 'station' table where trips have started. The placeholders in the query allow for further filtering or modifications based on specific criteria.\",\n        \"virtual_table\": \"SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the unique identifiers of trips from the 'trip' table, specifically focusing on those that started at various bike stations. The results are ordered by the number of docks available at each station in descending order, allowing users to see which stations with the most docks are associated with the trips. The placeholder in the LIMIT clause represents the maximum number of trip IDs to return.\",\n        \"virtual_table\": \"SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.190", "db_id": "bike_1", "question": "For each start station id, what is its name, longitude and average duration of trips started there?", "rationale": ["We need to retrieve the start station id, name, longitude, and average duration of trips for each start station.", "The 'station' table contains the station details including id, name, and longitude.", "The 'trip' table contains the trip details including start_station_id and duration.", "To get the average duration of trips for each station, we will join the 'station' table with the 'trip' table on the station id and start station id.", "We will use the AVG() function to calculate the average duration of trips for each station.", "Finally, we will group the results by station id, name, and longitude to ensure we get one result per station."], "gold_sql": "SELECT T1.name ,  T1.long ,  avg(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id GROUP BY T2.start_station_id", "source_tables": ["trip", "station"], "pred_sql": "SELECT T1.id, T1.name, T1.long, AVG(T2.duration) AS average_duration\nFROM station AS T1\nJOIN trip AS T2 ON T1.id = T2.start_station_id\nGROUP BY T1.id, T1.name, T1.long;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average latitude and longitude of bike stations from the 'station' table where trips have started. The placeholders in the query allow for further filtering or modifications based on specific criteria.\",\n        \"virtual_table\": \"SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average latitude and longitude of bike stations from the 'station' table where trips have started. The placeholders in the query allow for further filtering or modifications based on specific criteria.\",\n        \"virtual_table\": \"SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the unique identifiers of trips from the 'trip' table, specifically focusing on those that started at various bike stations. The results are ordered by the number of docks available at each station in descending order, allowing users to see which stations with the most docks are associated with the trips. The placeholder in the LIMIT clause represents the maximum number of trip IDs to return.\",\n        \"virtual_table\": \"SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.192", "db_id": "bike_1", "question": "For each end station id, what is its name, latitude, and minimum duration for trips ended there?", "rationale": ["Identify the relevant tables: We need to gather information from the 'trip' and 'station' tables.", "Determine the required fields: We need the end station id, name, latitude, and minimum duration for trips that ended at each station.", "Join the tables: We will join the 'trip' table with the 'station' table on the end station id to get the station details.", "Group the results: We will group by the end station id to calculate the minimum duration for trips ending at each station.", "Select the minimum duration: Use the MIN() function to get the minimum duration for trips that ended at each station."], "gold_sql": "SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id", "source_tables": ["trip", "station"], "pred_sql": "SELECT T3.end_station_id, T2.name, T2.lat, MIN(T1.duration) AS min_duration\nFROM trip AS T1\nJOIN station AS T2 ON T1.end_station_id = T2.id\nGROUP BY T3.end_station_id, T2.name, T2.lat;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the unique identifiers of trips from the 'trip' table, specifically focusing on those that started at various bike stations. The results are ordered by the number of docks available at each station in descending order, allowing users to see which stations with the most docks are associated with the trips. The placeholder in the LIMIT clause represents the maximum number of trip IDs to return.\",\n        \"virtual_table\": \"SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average latitude and longitude of bike stations from the 'station' table where trips have started. The placeholders in the query allow for further filtering or modifications based on specific criteria.\",\n        \"virtual_table\": \"SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average latitude and longitude of bike stations from the 'station' table where trips have started. The placeholders in the query allow for further filtering or modifications based on specific criteria.\",\n        \"virtual_table\": \"SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id\"\n    }\n}\n"}
{"sample_id": "train.196", "db_id": "bike_1", "question": "What are all the different zip codes that have a maximum dew point that was always below 70?", "rationale": ["Identify the requirement to find distinct zip codes.", "Focus on the weather table since it contains the relevant data about dew points and zip codes.", "Use the condition that the maximum dew point must be below 70 degrees.", "Select distinct zip codes to ensure that each zip code is listed only once."], "gold_sql": "SELECT DISTINCT zip_code FROM weather EXCEPT SELECT DISTINCT zip_code FROM weather WHERE max_dew_point_f  >=  70", "source_tables": ["weather"], "pred_sql": "SELECT DISTINCT zip_code FROM weather WHERE max_dew_point_f < 70", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates and zip codes of weather reports where the maximum temperature reached a specified threshold. The placeholder in the WHERE clause represents the minimum temperature value to filter the results.\",\n        \"virtual_table\": \"SELECT date ,  zip_code FROM weather WHERE max_temperature_f  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the dates and zip codes of weather reports where the maximum temperature reached a specified threshold. The placeholder in the WHERE clause represents the minimum temperature value to filter the results.\",\n        \"virtual_table\": \"SELECT date ,  zip_code FROM weather WHERE max_temperature_f  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.205", "db_id": "bike_1", "question": "Give me the zip code where the average mean humidity is below 70 and at least 100 trips took place.", "rationale": ["We need to find zip codes where the average mean humidity is below 70 and at least 100 trips took place.", "To achieve this, we will join the 'weather' table with the 'trip' table on the zip code column.", "We will group the results by zip code to calculate the average mean humidity and count the number of trips for each zip code.", "The HAVING clause will filter the results to only include those zip codes where the average mean humidity is less than 70 and the count of trips is at least 100."], "gold_sql": "SELECT zip_code FROM weather GROUP BY zip_code HAVING avg(mean_humidity)  <  70 INTERSECT SELECT zip_code FROM trip GROUP BY zip_code HAVING count(*)  >=  100", "source_tables": ["weather", "trip"], "pred_sql": "SELECT zip_code \nFROM weather \nJOIN trip ON weather.zip_code = trip.zip_code \nGROUP BY zip_code \nHAVING AVG(mean_humidity) < 70 AND COUNT(trip.id) >= 100;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates and zip codes of weather reports where the maximum temperature reached a specified threshold. The placeholder in the WHERE clause represents the minimum temperature value to filter the results.\",\n        \"virtual_table\": \"SELECT date ,  zip_code FROM weather WHERE max_temperature_f  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the dates and zip codes of weather reports where the maximum temperature reached a specified threshold. The placeholder in the WHERE clause represents the minimum temperature value to filter the results.\",\n        \"virtual_table\": \"SELECT date ,  zip_code FROM weather WHERE max_temperature_f  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.206", "db_id": "bike_1", "question": "What are the zip codes that have an average mean humidity below 70 and had at least 100 trips come through there?", "rationale": ["Identify the requirement to find zip codes with average mean humidity below 70 and at least 100 trips.", "To achieve this, we need to use the 'weather' table to filter zip codes based on average mean humidity.", "We will group the weather data by zip code and calculate the average mean humidity, applying the condition that it must be below 70.", "Next, we will use the 'trip' table to count the number of trips associated with each zip code.", "We will group the trips by zip code and apply the condition that the count of trips must be at least 100.", "Finally, we will combine these two conditions using a subquery to filter the zip codes accordingly."], "gold_sql": "SELECT zip_code FROM weather GROUP BY zip_code HAVING avg(mean_humidity)  <  70 INTERSECT SELECT zip_code FROM trip GROUP BY zip_code HAVING count(*)  >=  100", "source_tables": ["weather", "trip"], "pred_sql": "SELECT zip_code \nFROM trip \nWHERE zip_code IN (\n    SELECT zip_code \n    FROM weather \n    GROUP BY zip_code \n    HAVING AVG(mean_humidity) < 70\n) \nGROUP BY zip_code \nHAVING COUNT(id) >= 100;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates and zip codes of weather reports where the maximum temperature reached a specified threshold. The placeholder in the WHERE clause represents the minimum temperature value to filter the results.\",\n        \"virtual_table\": \"SELECT date ,  zip_code FROM weather WHERE max_temperature_f  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the dates and zip codes of weather reports where the maximum temperature reached a specified threshold. The placeholder in the WHERE clause represents the minimum temperature value to filter the results.\",\n        \"virtual_table\": \"SELECT date ,  zip_code FROM weather WHERE max_temperature_f  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.304", "db_id": "product_catalog", "question": "What are the attribute data types with more than 3 attribute definitions?", "rationale": ["Identify the table that contains the attribute data types, which is 'Attribute_Definitions'.", "We need to group the results by 'attribute_data_type' to count how many definitions exist for each type.", "Use the COUNT function to count the number of 'attribute_id' for each 'attribute_data_type'.", "Apply the HAVING clause to filter the groups where the count is greater than 3."], "gold_sql": "SELECT attribute_data_type FROM Attribute_Definitions GROUP BY attribute_data_type HAVING count(*)  >  3", "source_tables": ["attribute_definitions"], "pred_sql": "SELECT attribute_data_type\nFROM Attribute_Definitions\nGROUP BY attribute_data_type\nHAVING COUNT(attribute_id) > 3;", "hint": "\n"}
{"sample_id": "train.316", "db_id": "product_catalog", "question": "Find the entry names of the catalog with the attribute that have the most entries.", "rationale": ["Identify the relevant tables: Catalog_Contents for entry names and Catalog_Contents_Additional_Attributes for attributes associated with those entries.", "Join Catalog_Contents with Catalog_Contents_Additional_Attributes on catalog_entry_id to link entries with their attributes.", "Group the results by catalog_entry_id to count the number of attributes associated with each entry.", "Order the results by the count of attributes in descending order to find the entry with the most attributes.", "Limit the results to 1 to get only the entry name with the most attributes."], "gold_sql": "SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.attribute_value  =  (SELECT attribute_value FROM Catalog_Contents_Additional_Attributes GROUP BY attribute_value ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["catalog_contents", "catalog_contents_additional_attributes"], "pred_sql": "SELECT cc.catalog_entry_name\nFROM Catalog_Contents cc\nJOIN Catalog_Contents_Additional_Attributes cca ON cc.catalog_entry_id = cca.catalog_entry_id\nGROUP BY cc.catalog_entry_id\nORDER BY COUNT(cca.attribute_id) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the names of catalog levels from the 'Catalog_Structure' table that are associated with entries in the 'Catalog_Contents' table. The results are ordered by the price in dollars of the catalog entries, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t2.catalog_level_name FROM catalog_contents AS t1 JOIN catalog_structure AS t2 ON t1.catalog_level_number  =  t2.catalog_level_number ORDER BY t1.price_in_dollars LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table describes the names of catalog levels from the 'Catalog_Structure' table that are associated with entries in the 'Catalog_Contents' table. The results are ordered by the price in dollars of the catalog entries, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t2.catalog_level_name FROM catalog_contents AS t1 JOIN catalog_structure AS t2 ON t1.catalog_level_number  =  t2.catalog_level_number ORDER BY t1.price_in_dollars LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.317", "db_id": "product_catalog", "question": "What is the entry name of the most expensive catalog (in USD)?", "rationale": ["Identify the table that contains the entry names and prices, which is 'Catalog_Contents'.", "To find the most expensive catalog entry, we need to order the results by 'price_in_dollars' in descending order.", "We will limit the results to 1 to get only the most expensive entry.", "The final SQL query selects the 'catalog_entry_name' from 'Catalog_Contents', orders by 'price_in_dollars' in descending order, and limits the result to 1."], "gold_sql": "SELECT catalog_entry_name FROM catalog_contents ORDER BY price_in_dollars DESC LIMIT 1", "source_tables": ["catalog_contents"], "pred_sql": "SELECT catalog_entry_name FROM Catalog_Contents ORDER BY price_in_dollars DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the names of catalog levels from the 'Catalog_Structure' table that are associated with entries in the 'Catalog_Contents' table. The results are ordered by the price in dollars of the catalog entries, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t2.catalog_level_name FROM catalog_contents AS t1 JOIN catalog_structure AS t2 ON t1.catalog_level_number  =  t2.catalog_level_number ORDER BY t1.price_in_dollars LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table describes the names of catalog levels from the 'Catalog_Structure' table that are associated with entries in the 'Catalog_Contents' table. The results are ordered by the price in dollars of the catalog entries, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t2.catalog_level_name FROM catalog_contents AS t1 JOIN catalog_structure AS t2 ON t1.catalog_level_number  =  t2.catalog_level_number ORDER BY t1.price_in_dollars LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.330", "db_id": "product_catalog", "question": "What are the names of catalog entries with level number 8?", "rationale": ["Identify the relevant table: Catalog_Contents contains the catalog entries.", "Determine the condition: We need entries with a specific level number, which is '8'.", "Construct the SQL query to select the catalog_entry_name from Catalog_Contents where catalog_level_number is '8'."], "gold_sql": "SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.catalog_level_number  =  '8'", "source_tables": ["catalog_contents", "catalog_contents_additional_attributes"], "pred_sql": "SELECT catalog_entry_name FROM Catalog_Contents WHERE catalog_level_number = '8'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the names of catalog levels from the 'Catalog_Structure' table that are associated with entries in the 'Catalog_Contents' table. The results are ordered by the price in dollars of the catalog entries, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t2.catalog_level_name FROM catalog_contents AS t1 JOIN catalog_structure AS t2 ON t1.catalog_level_number  =  t2.catalog_level_number ORDER BY t1.price_in_dollars LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table describes the names of catalog levels from the 'Catalog_Structure' table that are associated with entries in the 'Catalog_Contents' table. The results are ordered by the price in dollars of the catalog entries, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t2.catalog_level_name FROM catalog_contents AS t1 JOIN catalog_structure AS t2 ON t1.catalog_level_number  =  t2.catalog_level_number ORDER BY t1.price_in_dollars LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.331", "db_id": "product_catalog", "question": "Find the names of the products with length smaller than 3 or height greater than 5.", "rationale": ["Identify the table that contains product information, which is the Catalog_Contents table.", "Determine the relevant columns needed for the query: catalog_entry_name for product names, length for the length condition, and height for the height condition.", "Construct the SELECT statement to retrieve the catalog_entry_name from the Catalog_Contents table.", "Add the WHERE clause to filter products based on the conditions: length smaller than 3 or height greater than 5."], "gold_sql": "SELECT catalog_entry_name FROM catalog_contents WHERE LENGTH  <  3 OR width  >  5", "source_tables": ["catalog_contents"], "pred_sql": "SELECT catalog_entry_name \nFROM Catalog_Contents \nWHERE length < 3 OR height > 5;", "hint": "\n"}
{"sample_id": "train.332", "db_id": "product_catalog", "question": "Which catalog contents have length below 3 or above 5? Find the catalog entry names.", "rationale": ["Identify the relevant table: Catalog_Contents contains the catalog entry names and their lengths.", "Determine the condition: We need to find entries where the length is below 3 or above 5.", "Construct the SQL query: Use a SELECT statement to retrieve catalog_entry_name from Catalog_Contents where the length meets the specified conditions."], "gold_sql": "SELECT catalog_entry_name FROM catalog_contents WHERE LENGTH  <  3 OR width  >  5", "source_tables": ["catalog_contents"], "pred_sql": "SELECT catalog_entry_name FROM Catalog_Contents WHERE length < 3 OR length > 5;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the names of catalog levels from the 'Catalog_Structure' table that are associated with entries in the 'Catalog_Contents' table. The results are ordered by the price in dollars of the catalog entries, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t2.catalog_level_name FROM catalog_contents AS t1 JOIN catalog_structure AS t2 ON t1.catalog_level_number  =  t2.catalog_level_number ORDER BY t1.price_in_dollars LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table describes the names of catalog levels from the 'Catalog_Structure' table that are associated with entries in the 'Catalog_Contents' table. The results are ordered by the price in dollars of the catalog entries, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t2.catalog_level_name FROM catalog_contents AS t1 JOIN catalog_structure AS t2 ON t1.catalog_level_number  =  t2.catalog_level_number ORDER BY t1.price_in_dollars LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.338", "db_id": "product_catalog", "question": "On which days more than one revisions were made on catalogs.", "rationale": ["Identify the relevant table: The question pertains to revisions of catalogs, so we will focus on the 'Catalogs' table.", "Determine the relevant columns: We need the 'date_of_latest_revision' to group by the revision dates and count the number of revisions.", "Group the results: We will group the results by 'date_of_latest_revision' to count how many revisions occurred on each date.", "Filter the results: We will use the HAVING clause to filter out dates where the count of revisions is more than one."], "gold_sql": "SELECT date_of_latest_revision FROM Catalogs GROUP BY date_of_latest_revision HAVING count(*)  >  1", "source_tables": ["catalogs"], "pred_sql": "SELECT date_of_latest_revision, COUNT(*) as revision_count \nFROM Catalogs \nGROUP BY date_of_latest_revision \nHAVING COUNT(*) > 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the names of catalog levels from the 'Catalog_Structure' table that are associated with entries in the 'Catalog_Contents' table. The results are ordered by the price in dollars of the catalog entries, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t2.catalog_level_name FROM catalog_contents AS t1 JOIN catalog_structure AS t2 ON t1.catalog_level_number  =  t2.catalog_level_number ORDER BY t1.price_in_dollars LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table describes the names of catalog levels from the 'Catalog_Structure' table that are associated with entries in the 'Catalog_Contents' table. The results are ordered by the price in dollars of the catalog entries, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t2.catalog_level_name FROM catalog_contents AS t1 JOIN catalog_structure AS t2 ON t1.catalog_level_number  =  t2.catalog_level_number ORDER BY t1.price_in_dollars LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.388", "db_id": "flight_1", "question": "What are the origins of all flights that are headed to Honolulu?", "rationale": ["Identify the relevant table: The 'flight' table contains information about flight origins and destinations.", "Determine the required information: We need the origins of flights that are headed to Honolulu.", "Construct the SQL query: Use a SELECT statement to retrieve the 'origin' column from the 'flight' table where the 'destination' is 'Honolulu'."], "gold_sql": "SELECT origin FROM Flight WHERE destination  =  'Honolulu'", "source_tables": ["flight"], "pred_sql": "SELECT origin FROM flight WHERE destination = 'Honolulu'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the origins of flights from the 'Flight' table that are headed to a specific destination. The placeholder in the WHERE clause represents the destination's name.\",\n        \"virtual_table\": \"SELECT origin FROM Flight WHERE destination  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the flight numbers from the 'Flight' table, ordered by the distance of each flight in ascending order. The placeholder in the LIMIT clause represents the maximum number of flight numbers to be returned.\",\n        \"virtual_table\": \"SELECT flno FROM Flight ORDER BY distance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.390", "db_id": "flight_1", "question": "What are the departure and arrival dates of all flights from LA to Honolulu?", "rationale": ["Identify the relevant table: The 'flight' table contains the information about flights, including departure and arrival dates.", "Determine the required columns: We need the 'departure_date' and 'arrival_date' for the flights.", "Specify the conditions: We are interested in flights that originate from 'LA' and have 'Honolulu' as their destination.", "Construct the SQL query: Using the SELECT statement to retrieve the specified columns from the 'flight' table with the appropriate WHERE clause."], "gold_sql": "SELECT departure_date ,  arrival_date FROM Flight WHERE origin  =  'Los Angeles' AND destination  =  'Honolulu'", "source_tables": ["flight"], "pred_sql": "SELECT departure_date, arrival_date FROM flight WHERE origin = 'LA' AND destination = 'Honolulu';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the origins of flights from the 'Flight' table that are headed to a specific destination. The placeholder in the WHERE clause represents the destination's name.\",\n        \"virtual_table\": \"SELECT origin FROM Flight WHERE destination  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the flight numbers from the 'Flight' table, ordered by the distance of each flight in ascending order. The placeholder in the LIMIT clause represents the maximum number of flight numbers to be returned.\",\n        \"virtual_table\": \"SELECT flno FROM Flight ORDER BY distance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.394", "db_id": "flight_1", "question": "What is the average price for flights from LA to Honolulu?", "rationale": ["Identify the relevant table: The 'flight' table contains the necessary information about flights, including their prices and routes.", "Determine the columns needed: We need the 'price' column to calculate the average price and the 'origin' and 'destination' columns to filter the flights from LA to Honolulu.", "Construct the SQL query: Use the AVG() function to calculate the average price, and include a WHERE clause to filter for flights originating from LA and heading to Honolulu."], "gold_sql": "SELECT avg(price) FROM Flight WHERE origin  =  'Los Angeles' AND destination  =  'Honolulu'", "source_tables": ["flight"], "pred_sql": "SELECT AVG(price) AS average_price FROM flight WHERE origin = 'LA' AND destination = 'Honolulu';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the origins of flights from the 'Flight' table that are headed to a specific destination. The placeholder in the WHERE clause represents the destination's name.\",\n        \"virtual_table\": \"SELECT origin FROM Flight WHERE destination  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the flight numbers from the 'Flight' table, ordered by the distance of each flight in ascending order. The placeholder in the LIMIT clause represents the maximum number of flight numbers to be returned.\",\n        \"virtual_table\": \"SELECT flno FROM Flight ORDER BY distance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.415", "db_id": "flight_1", "question": "Show aircraft names and number of flights for each aircraft.", "rationale": ["We need to retrieve the names of the aircraft and the number of flights associated with each aircraft.", "To do this, we will select the 'name' column from the 'aircraft' table.", "We will also count the number of flight numbers ('flno') from the 'flight' table to get the number of flights for each aircraft.", "To connect the two tables, we will use a LEFT JOIN on the 'aid' column, which is the common key between 'aircraft' and 'flight'.", "Finally, we will group the results by the aircraft ID ('aid') and name to ensure we get the count of flights for each aircraft."], "gold_sql": "SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid", "source_tables": ["aircraft", "flight"], "pred_sql": "SELECT a.name, COUNT(f.flno) AS number_of_flights\nFROM aircraft a\nLEFT JOIN flight f ON a.aid = f.aid\nGROUP BY a.aid, a.name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the flight numbers from the 'Flight' table, ordered by the distance of each flight in ascending order. The placeholder in the LIMIT clause represents the maximum number of flight numbers to be returned.\",\n        \"virtual_table\": \"SELECT flno FROM Flight ORDER BY distance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.416", "db_id": "flight_1", "question": "What is the name of each aircraft and how many flights does each one complete?", "rationale": ["Identify the tables needed: 'aircraft' for aircraft names and 'flight' for flight information.", "We need to count the number of flights for each aircraft, so we will use a COUNT function on the flight numbers (flno).", "To associate flights with their respective aircraft, we will perform a LEFT JOIN between the 'aircraft' table and the 'flight' table on the aircraft ID (aid).", "We will group the results by the aircraft name to get the count of flights for each aircraft.", "The final SQL query will select the aircraft name and the count of flights, using the appropriate SQL syntax."], "gold_sql": "SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid", "source_tables": ["aircraft", "flight"], "pred_sql": "SELECT aircraft.name, COUNT(flight.flno) AS flight_count \nFROM aircraft \nLEFT JOIN flight ON aircraft.aid = flight.aid \nGROUP BY aircraft.name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the origins of flights from the 'Flight' table that are headed to a specific destination. The placeholder in the WHERE clause represents the destination's name.\",\n        \"virtual_table\": \"SELECT origin FROM Flight WHERE destination  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the flight numbers from the 'Flight' table, ordered by the distance of each flight in ascending order. The placeholder in the LIMIT clause represents the maximum number of flight numbers to be returned.\",\n        \"virtual_table\": \"SELECT flno FROM Flight ORDER BY distance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.430", "db_id": "flight_1", "question": "What are the names of all employees who are not certified to fly Boeing 737-800s?", "rationale": ["Identify the main table to query from, which is the 'employee' table to get employee names.", "We need to find employees who are not certified to fly a specific aircraft, in this case, the 'Boeing 737-800'.", "To find certified employees, we will use the 'certificate' table and join it with the 'aircraft' table to filter by aircraft name.", "The subquery will select employee IDs (eid) from the 'certificate' table where the associated aircraft is 'Boeing 737-800'.", "The main query will select names from the 'employee' table where the employee ID is not in the list of IDs returned by the subquery."], "gold_sql": "SELECT name FROM Employee EXCEPT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  'Boeing 737-800'", "source_tables": ["employee", "certificate", "aircraft"], "pred_sql": "SELECT e.name \nFROM employee e \nWHERE e.eid NOT IN (\n    SELECT c.eid \n    FROM certificate c \n    JOIN aircraft a ON c.aid = a.aid \n    WHERE a.name = 'Boeing 737-800'\n);", "hint": "\n"}
{"sample_id": "train.431", "db_id": "flight_1", "question": "Show the name of aircraft which fewest people have its certificate.", "rationale": ["We need to find the name of the aircraft that has the fewest people holding its certificate.", "To do this, we will join the 'aircraft' table with the 'certificate' table on the aircraft ID (aid).", "We will group the results by the aircraft ID to count how many certificates each aircraft has.", "We will then order the results by the count of certificates in ascending order to get the aircraft with the fewest certificates at the top.", "Finally, we will limit the results to just one entry to get the aircraft with the fewest certificates."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["aircraft", "certificate"], "pred_sql": "SELECT a.name\nFROM aircraft a\nJOIN certificate c ON a.aid = c.aid\nGROUP BY a.aid\nORDER BY COUNT(c.eid) ASC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.432", "db_id": "flight_1", "question": "What are the names of the aircraft that the least people are certified to fly?", "rationale": ["Identify the relevant tables: We need to find aircraft names and the number of employees certified to fly each aircraft, so we will use the 'aircraft' and 'certificate' tables.", "Join the tables: We will join the 'aircraft' table with the 'certificate' table on the aircraft ID (aid) to associate each aircraft with its certified employees.", "Group by aircraft: We will group the results by the aircraft ID to count the number of certifications for each aircraft.", "Count certifications: Use COUNT(c.eid) to count the number of employees certified for each aircraft.", "Order by count: We will order the results in ascending order based on the count of certifications to find the aircraft with the least certifications.", "Limit the results: Finally, we will limit the results to 1 to get the aircraft with the least number of certified employees."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["aircraft", "certificate"], "pred_sql": "SELECT a.name\nFROM aircraft a\nJOIN certificate c ON a.aid = c.aid\nGROUP BY a.aid\nORDER BY COUNT(c.eid) ASC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.438", "db_id": "flight_1", "question": "What is the salaray and name of the employee with the most certificates to fly planes more than 5000?", "rationale": ["Identify the relevant tables: employee, certificate, and aircraft.", "We need to find employees who have certificates to fly aircraft with a maximum distance greater than 5000.", "Join the employee table with the certificate table on employee ID (eid) and then join with the aircraft table on aircraft ID (aid).", "Filter the results to include only those aircraft where the distance is greater than 5000.", "Group the results by employee ID to count the number of certificates each employee has.", "Order the results by the count of certificates in descending order to find the employee with the most certificates.", "Limit the results to 1 to get only the top employee."], "gold_sql": "SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  5000 GROUP BY T1.eid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employee", "certificate", "aircraft"], "pred_sql": "SELECT e.salary, e.name \nFROM employee e \nJOIN certificate c ON e.eid = c.eid \nJOIN aircraft a ON c.aid = a.aid \nWHERE a.distance > 5000 \nGROUP BY e.eid \nORDER BY COUNT(c.aid) DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.448", "db_id": "allergy_1", "question": "What are all the different food allergies?", "rationale": ["The question asks for all the different food allergies, which implies we need to retrieve unique allergy names.", "We will use the 'Allergy_Type' table since it contains the names of the allergies.", "To get distinct allergy names, we will use the SELECT DISTINCT statement on the 'Allergy' column from the 'Allergy_Type' table."], "gold_sql": "SELECT DISTINCT allergy FROM Allergy_type WHERE allergytype  =  'food'", "source_tables": ["allergy_type"], "pred_sql": "SELECT DISTINCT Allergy FROM Allergy_Type", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the type or category of a specific allergy from the 'Allergy_Type' table. The placeholder in the WHERE clause represents the name of the allergy being queried.\",\n        \"virtual_table\": \"SELECT allergytype FROM Allergy_type WHERE allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of distinct allergy types from the 'Allergy_Type' table. The result will indicate how many unique categories of allergies are present in the database.\",\n        \"virtual_table\": \"SELECT count(DISTINCT allergytype) FROM Allergy_type\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.452", "db_id": "allergy_1", "question": "How many animal type allergies exist?", "rationale": ["The question asks for the number of distinct animal type allergies.", "To find this, we need to count the unique entries in the 'AllergyType' column of the 'Allergy_Type' table.", "The provided hint suggests using a virtual table that counts distinct allergy types, which aligns with our goal.", "Thus, the SQL query will be: SELECT count(DISTINCT AllergyType) FROM Allergy_Type."], "gold_sql": "SELECT count(*) FROM Allergy_type WHERE allergytype  =  'animal'", "source_tables": ["allergy_type"], "pred_sql": "SELECT count(DISTINCT AllergyType) FROM Allergy_Type", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of distinct allergy types from the 'Allergy_Type' table. The result will indicate how many unique categories of allergies are present in the database.\",\n        \"virtual_table\": \"SELECT count(DISTINCT allergytype) FROM Allergy_type\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.455", "db_id": "allergy_1", "question": "Which allergy type has most number of allergies?", "rationale": ["We need to find out which allergy type has the most number of allergies.", "To do this, we will join the 'Has_Allergy' table with the 'Allergy_Type' table on the Allergy column.", "We will group the results by the AllergyType to count how many allergies fall under each type.", "We will use COUNT(*) to count the number of allergies for each type.", "To find the type with the most allergies, we will order the results in descending order based on the count.", "Finally, we will limit the results to just one entry to get the allergy type with the highest count."], "gold_sql": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT 1", "source_tables": ["allergy_type"], "pred_sql": "SELECT T2.AllergyType, COUNT(*) AS AllergyCount \nFROM Has_Allergy AS T1 \nJOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy \nGROUP BY T2.AllergyType \nORDER BY AllergyCount DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of distinct allergy types from the 'Allergy_Type' table. The result will indicate how many unique categories of allergies are present in the database.\",\n        \"virtual_table\": \"SELECT count(DISTINCT allergytype) FROM Allergy_type\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.458", "db_id": "allergy_1", "question": "Which allergy type is the least common?", "rationale": ["To find the least common allergy type, we need to count how many students have each type of allergy.", "We will join the 'Has_Allergy' table with the 'Allergy_Type' table to get the allergy types associated with each student.", "We will group the results by the allergy type to get the count of students for each type.", "Next, we will order the results by the count in ascending order to find the least common allergy type.", "Finally, we will limit the results to 1 to get only the least common allergy type."], "gold_sql": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) ASC LIMIT 1", "source_tables": ["allergy_type"], "pred_sql": "SELECT T2.allergytype, COUNT(*) AS allergy_count \nFROM Has_Allergy AS T1 \nJOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy \nGROUP BY T2.allergytype \nORDER BY allergy_count ASC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the type or category of a specific allergy from the 'Allergy_Type' table. The placeholder in the WHERE clause represents the name of the allergy being queried.\",\n        \"virtual_table\": \"SELECT allergytype FROM Allergy_type WHERE allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of distinct allergy types from the 'Allergy_Type' table. The result will indicate how many unique categories of allergies are present in the database.\",\n        \"virtual_table\": \"SELECT count(DISTINCT allergytype) FROM Allergy_type\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.462", "db_id": "allergy_1", "question": "What are the full names of all students", "rationale": ["Identify the table that contains student names, which is the 'Student' table.", "To get the full names, we need to concatenate the 'Fname' and 'LName' columns.", "Use the SQL SELECT statement to retrieve the concatenated names as 'FullName'."], "gold_sql": "SELECT Fname ,  Lname FROM Student", "source_tables": ["student"], "pred_sql": "SELECT Fname || ' ' || LName AS FullName FROM Student;", "hint": "\n"}
{"sample_id": "train.472", "db_id": "allergy_1", "question": "What are the student ids for all male students?", "rationale": ["Identify the relevant table: The 'Student' table contains the information about students, including their gender.", "Determine the required information: We need the student IDs (StuID) for all male students.", "Use the provided hint: The hint suggests a virtual table that selects StuID from the Student table where Sex matches a specific value.", "Replace the placeholder in the hint with 'Male' to filter for male students."], "gold_sql": "SELECT StuID FROM Student WHERE Sex  =  'M'", "source_tables": ["student"], "pred_sql": "SELECT StuID FROM Student WHERE Sex = 'Male'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the unique identifiers of students from the 'Student' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the students.\",\n        \"virtual_table\": \"SELECT StuID FROM Student WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.492", "db_id": "allergy_1", "question": "What is the largest major?", "rationale": ["Identify the table that contains the major information, which is the 'Student' table.", "To find the largest major, we need to count the number of students in each major.", "We will use the COUNT function to count the number of students for each major.", "We will group the results by the 'Major' column to get the count for each major.", "To find the largest major, we will order the results in descending order based on the count of students.", "Finally, we will limit the results to 1 to get only the largest major."], "gold_sql": "SELECT major FROM Student GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Major FROM Student GROUP BY Major ORDER BY COUNT(*) DESC LIMIT 1;", "hint": "\n"}
{"sample_id": "train.502", "db_id": "allergy_1", "question": "Give the advisor with the most students.", "rationale": ["Identify the relevant table: The 'Student' table contains the 'Advisor' and 'StuID' columns.", "Count the number of students for each advisor: Use COUNT(StuID) to count the number of students associated with each advisor.", "Group the results by advisor: Use GROUP BY Advisor to aggregate the counts for each advisor.", "Order the results: Use ORDER BY StudentCount DESC to sort the advisors by the number of students in descending order.", "Limit the results to the top advisor: Use LIMIT 1 to get only the advisor with the most students."], "gold_sql": "SELECT advisor FROM Student GROUP BY advisor ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Advisor, COUNT(StuID) AS StudentCount\nFROM Student\nGROUP BY Advisor\nORDER BY StudentCount DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.503", "db_id": "allergy_1", "question": "How many students have cat allergies?", "rationale": ["The question asks for the number of students with cat allergies.", "We need to count the number of students who have a specific allergy, which is 'cat'.", "To do this, we will join the 'Has_Allergy' table with the 'Allergy_Type' table on the Allergy column.", "We will then filter the results to only include those records where the AllergyType is 'cat'.", "Finally, we will use the COUNT function to get the total number of students with cat allergies."], "gold_sql": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  'Cat'", "source_tables": ["has_allergy"], "pred_sql": "SELECT count(*) FROM Has_Allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.AllergyType = 'cat'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies students from the 'Student' table who do not have any allergies recorded in the 'Has_Allergy' table. The query uses the EXCEPT clause to exclude students with allergies from the list of all students.\",\n        \"virtual_table\": \"SELECT StuID FROM Student EXCEPT SELECT StuID FROM Has_allergy\"\n    }\n}\n"}
{"sample_id": "train.504", "db_id": "allergy_1", "question": "How many students are affected by cat allergies?", "rationale": ["Identify the tables involved: Has_Allergy and Allergy_Type.", "Determine the relationship: Has_Allergy links students to their allergies, and Allergy_Type categorizes those allergies.", "We need to count the number of students affected by cat allergies, which means we need to filter the results based on the allergy type 'cat'.", "Use a JOIN to combine the two tables on the Allergy column.", "Use the COUNT function to count the number of records that match the criteria.", "Construct the SQL query using the identified elements."], "gold_sql": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  'Cat'", "source_tables": ["has_allergy"], "pred_sql": "SELECT count(*) FROM Has_Allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.AllergyType = 'cat'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of distinct allergy types from the 'Allergy_Type' table. The result will indicate how many unique categories of allergies are present in the database.\",\n        \"virtual_table\": \"SELECT count(DISTINCT allergytype) FROM Allergy_type\"\n    }\n}\n"}
{"sample_id": "train.510", "db_id": "allergy_1", "question": "How many students who are female are allergic to milk or eggs?", "rationale": ["Identify the tables needed: We need to access the Student table to filter by gender, the Has_Allergy table to link students to their allergies, and the Allergy_Type table to specify the allergies (milk and eggs).", "Join the tables: We will join the Student table with the Has_Allergy table on StuID, and then join the result with the Allergy_Type table on the Allergy column.", "Filter by gender: We need to filter the results to include only female students, which is done by adding a WHERE clause for S.Sex = 'Female'.", "Filter by allergies: We also need to filter the allergies to include only those that are either 'Milk' or 'Eggs'. This is done using an OR condition in the WHERE clause.", "Count distinct students: Since we want the number of unique female students with these allergies, we will use COUNT(DISTINCT S.StuID) to ensure we do not double count any students."], "gold_sql": "SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  'F' AND T1.allergy  =  'Milk' OR T1.allergy  =  'Eggs'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT COUNT(DISTINCT S.StuID) \nFROM Student AS S \nJOIN Has_Allergy AS HA ON S.StuID = HA.StuID \nJOIN Allergy_Type AS AT ON HA.Allergy = AT.Allergy \nWHERE S.Sex = 'Female' AND (AT.Allergy = 'Milk' OR AT.Allergy = 'Eggs');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies students from the 'Student' table who do not have any allergies recorded in the 'Has_Allergy' table. The query uses the EXCEPT clause to exclude students with allergies from the list of all students.\",\n        \"virtual_table\": \"SELECT StuID FROM Student EXCEPT SELECT StuID FROM Has_allergy\"\n    }\n}\n"}
{"sample_id": "train.514", "db_id": "allergy_1", "question": "Which allergy is the most common?", "rationale": ["To find the most common allergy, we need to count how many students have each allergy.", "We will join the 'Has_Allergy' table with the 'Allergy_Type' table to get the names of the allergies along with their counts.", "We will use the COUNT function to count the number of occurrences of each allergy.", "We will group the results by the allergy name to get the count for each allergy.", "To find the most common allergy, we will order the results by the count in descending order.", "Finally, we will limit the results to 1 to get only the most common allergy."], "gold_sql": "SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT 1", "source_tables": ["has_allergy"], "pred_sql": "SELECT T2.Allergy, COUNT(*) as AllergyCount \nFROM Has_Allergy AS T1 \nJOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy \nGROUP BY T2.Allergy \nORDER BY AllergyCount DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of distinct allergy types from the 'Allergy_Type' table. The result will indicate how many unique categories of allergies are present in the database.\",\n        \"virtual_table\": \"SELECT count(DISTINCT allergytype) FROM Allergy_type\"\n    }\n}\n"}
{"sample_id": "train.519", "db_id": "allergy_1", "question": "Find the last name and age of the student who has allergy to both milk and cat.", "rationale": ["Identify the tables needed: We need to get student information (last name and age) from the Student table and the allergies from the Has_Allergy table.", "We need to find students who have both 'milk' and 'cat' allergies. This requires joining the Has_Allergy table twice: once for each allergy.", "Join the Student table with the Has_Allergy table twice, once for each allergy, using the student ID (StuID) as the key.", "In the WHERE clause, specify the conditions that the first instance of Has_Allergy must have 'milk' and the second instance must have 'cat'.", "Select the last name (LName) and age (Age) of the students who meet these criteria."], "gold_sql": "SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT S.LName, S.Age \nFROM Student S \nJOIN Has_Allergy HA1 ON S.StuID = HA1.StuID \nJOIN Has_Allergy HA2 ON S.StuID = HA2.StuID \nWHERE HA1.Allergy = 'milk' AND HA2.Allergy = 'cat';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies students from the 'Student' table who do not have any allergies recorded in the 'Has_Allergy' table. The query uses the EXCEPT clause to exclude students with allergies from the list of all students.\",\n        \"virtual_table\": \"SELECT StuID FROM Student EXCEPT SELECT StuID FROM Has_allergy\"\n    }\n}\n"}
{"sample_id": "train.520", "db_id": "allergy_1", "question": "What are the last names and ages of the students who are allergic to milk and cat?", "rationale": ["Identify the tables needed: We need to retrieve student information (last names and ages) from the 'Student' table and their allergies from the 'Has_Allergy' table.", "Determine the relationship: The 'Has_Allergy' table links students to their allergies using the 'StuID' column.", "Specify the allergies of interest: We are looking for students who are allergic to both 'milk' and 'cat'.", "Join the 'Student' table with the 'Has_Allergy' table on 'StuID' to get the relevant student data along with their allergies.", "Use a WHERE clause to filter the results to only include students with allergies to 'milk' and 'cat'.", "Group the results by 'StuID' to ensure we can count the distinct allergies for each student.", "Use HAVING to ensure that we only select students who have both allergies (count of distinct allergies should be 2)."], "gold_sql": "SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT S.LName, S.Age \nFROM Student S \nJOIN Has_Allergy HA ON S.StuID = HA.StuID \nWHERE HA.Allergy IN ('milk', 'cat') \nGROUP BY S.StuID \nHAVING COUNT(DISTINCT HA.Allergy) = 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies students from the 'Student' table who do not have any allergies recorded in the 'Has_Allergy' table. The query uses the EXCEPT clause to exclude students with allergies from the list of all students.\",\n        \"virtual_table\": \"SELECT StuID FROM Student EXCEPT SELECT StuID FROM Has_allergy\"\n    }\n}\n"}
{"sample_id": "train.523", "db_id": "allergy_1", "question": "Find the first name and gender of the student who has allergy to milk but not cat.", "rationale": ["Identify the columns needed: first name (Fname) and gender (Sex) of the student.", "We need to filter students based on their allergies: specifically, those who have an allergy to milk and do not have an allergy to cat.", "To find students with an allergy to milk, we can use a subquery that selects StuID from the Has_Allergy table where Allergy is 'milk'.", "To find students without an allergy to cat, we can use another subquery that selects StuID from the Has_Allergy table where Allergy is 'cat'.", "We can combine these conditions using the IN and NOT IN clauses in the WHERE statement of the main query, which selects from the Student table."], "gold_sql": "SELECT fname ,  sex FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' EXCEPT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT Fname, Sex FROM Student WHERE StuID IN (SELECT StuID FROM Has_Allergy WHERE Allergy = 'milk') AND StuID NOT IN (SELECT StuID FROM Has_Allergy WHERE Allergy = 'cat')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies students from the 'Student' table who do not have any allergies recorded in the 'Has_Allergy' table. The query uses the EXCEPT clause to exclude students with allergies from the list of all students.\",\n        \"virtual_table\": \"SELECT StuID FROM Student EXCEPT SELECT StuID FROM Has_allergy\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.524", "db_id": "allergy_1", "question": "What are the first name and gender of the students who have allergy to milk but can put up with cats?", "rationale": ["Identify the information needed: first name and gender of students with specific allergies.", "Determine the allergies of interest: students who have an allergy to 'milk' and do not have an allergy to 'cats'.", "Use a subquery to find students with an allergy to 'milk' by selecting their StuID from the Has_Allergy table.", "Use another subquery to find students with an allergy to 'cats' to exclude them from the results.", "Combine the results using the IN and NOT IN clauses to filter the students accordingly.", "Select the first name (Fname) and gender (Sex) from the Student table where the StuID matches the criteria from the subqueries."], "gold_sql": "SELECT fname ,  sex FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' EXCEPT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT Fname, Sex FROM Student WHERE StuID IN (SELECT StuID FROM Has_Allergy WHERE Allergy = 'milk') AND StuID NOT IN (SELECT StuID FROM Has_Allergy WHERE Allergy = 'cats')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies students from the 'Student' table who do not have any allergies recorded in the 'Has_Allergy' table. The query uses the EXCEPT clause to exclude students with allergies from the list of all students.\",\n        \"virtual_table\": \"SELECT StuID FROM Student EXCEPT SELECT StuID FROM Has_allergy\"\n    }\n}\n"}
{"sample_id": "train.525", "db_id": "allergy_1", "question": "Find the average age of the students who have allergies with food and animal types.", "rationale": ["Identify the tables needed: We need to get student ages from the 'Student' table and filter based on allergies from the 'Has_Allergy' and 'Allergy_Type' tables.", "Join the 'Student' table with the 'Has_Allergy' table on 'StuID' to link students with their allergies.", "Join the result with the 'Allergy_Type' table on 'Allergy' to categorize the allergies.", "Filter the results to include only those students who have allergies of type 'food' or 'animal'.", "Calculate the average age of the filtered students using the AVG() function, ensuring to cast the 'Age' column to an integer for accurate calculation."], "gold_sql": "SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food' INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'animal')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT AVG(CAST(Age AS INTEGER)) FROM Student AS S JOIN Has_Allergy AS HA ON S.StuID = HA.StuID JOIN Allergy_Type AS AT ON HA.Allergy = AT.Allergy WHERE AT.AllergyType IN ('food', 'animal')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of distinct allergy types from the 'Allergy_Type' table. The result will indicate how many unique categories of allergies are present in the database.\",\n        \"virtual_table\": \"SELECT count(DISTINCT allergytype) FROM Allergy_type\"\n    }\n}\n"}
{"sample_id": "train.528", "db_id": "allergy_1", "question": "What is the full name of each student who is not allergic to any type of food.", "rationale": ["Identify the main goal: to find the full names of students who are not allergic to any type of food.", "Understand that we need to select the first name (Fname) and last name (LName) from the Student table.", "To find students without allergies, we can use a subquery that selects StuID from the Has_Allergy table.", "The subquery will be used in a NOT IN clause to filter out students who have allergies from the main query.", "The final SQL query combines these elements to retrieve the desired information."], "gold_sql": "SELECT fname ,  lname FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT Fname, LName FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_Allergy)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies students from the 'Student' table who do not have any allergies recorded in the 'Has_Allergy' table. The query uses the EXCEPT clause to exclude students with allergies from the list of all students.\",\n        \"virtual_table\": \"SELECT StuID FROM Student EXCEPT SELECT StuID FROM Has_allergy\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.530", "db_id": "allergy_1", "question": "How many male students (sex is 'M') are allergic to any type of food?", "rationale": ["We need to count the number of male students who are allergic to any type of food.", "To do this, we will join the 'Has_Allergy' table with the 'Allergy_Type' table to filter allergies by type.", "We also need to join the 'Student' table to filter by gender (male).", "The WHERE clause will specify that the allergy type is 'Food' and the student's sex is 'M'.", "Finally, we will use the COUNT function to get the total number of male students with food allergies."], "gold_sql": "SELECT count(*) FROM Student WHERE sex  =  'M' AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT count(*) FROM Has_Allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy JOIN Student AS S ON T1.StuID = S.StuID WHERE T2.AllergyType = 'Food' AND S.Sex = 'M'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies students from the 'Student' table who do not have any allergies recorded in the 'Has_Allergy' table. The query uses the EXCEPT clause to exclude students with allergies from the list of all students.\",\n        \"virtual_table\": \"SELECT StuID FROM Student EXCEPT SELECT StuID FROM Has_allergy\"\n    }\n}\n"}
{"sample_id": "train.531", "db_id": "allergy_1", "question": "Find the different first names and cities of the students who have allergy to milk or cat.", "rationale": ["Identify the tables involved: We need to get student information from the 'Student' table and allergy information from the 'Has_Allergy' table.", "We need to find students who have allergies to either 'milk' or 'cat'.", "To do this, we will join the 'Student' table with the 'Has_Allergy' table on the 'StuID' column.", "We will select distinct first names and city codes of students who have the specified allergies.", "The final SQL query will include a WHERE clause to filter for allergies 'milk' and 'cat'."], "gold_sql": "SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  'Milk' OR T2.Allergy  =  'Cat'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT DISTINCT S.Fname, S.city_code \nFROM Student S \nJOIN Has_Allergy HA ON S.StuID = HA.StuID \nWHERE HA.Allergy IN ('milk', 'cat');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies students from the 'Student' table who do not have any allergies recorded in the 'Has_Allergy' table. The query uses the EXCEPT clause to exclude students with allergies from the list of all students.\",\n        \"virtual_table\": \"SELECT StuID FROM Student EXCEPT SELECT StuID FROM Has_allergy\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.532", "db_id": "allergy_1", "question": "What are the distinct first names and cities of the students who have allergy either to milk or to cat?", "rationale": ["Identify the tables needed: We need data from the 'Student' table for first names and city codes, and the 'Has_Allergy' table to filter students based on their allergies.", "We need to join the 'Student' table with the 'Has_Allergy' table on the 'StuID' column to link students with their allergies.", "We want to filter the results to include only those students who have allergies to either 'milk' or 'cat'.", "We will use the DISTINCT keyword to ensure that we only get unique combinations of first names and city codes in the result set."], "gold_sql": "SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  'Milk' OR T2.Allergy  =  'Cat'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT DISTINCT S.Fname, S.city_code \nFROM Student S \nJOIN Has_Allergy HA ON S.StuID = HA.StuID \nWHERE HA.Allergy IN ('milk', 'cat');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies students from the 'Student' table who do not have any allergies recorded in the 'Has_Allergy' table. The query uses the EXCEPT clause to exclude students with allergies from the list of all students.\",\n        \"virtual_table\": \"SELECT StuID FROM Student EXCEPT SELECT StuID FROM Has_allergy\"\n    }\n}\n"}
{"sample_id": "train.542", "db_id": "store_1", "question": "What are the names of the countries and average invoice size of the top countries by size?", "rationale": ["Identify the relevant table: The invoices table contains the billing country and total amount of each invoice.", "Select the columns needed: We need the billing_country and the average of the total column.", "Use the AVG() function to calculate the average invoice size for each country.", "Group the results by billing_country to get the average for each country.", "Order the results by average_invoice_size in descending order to get the top countries by size.", "Limit the results to the top 10 countries."], "gold_sql": "SELECT billing_country ,  AVG(total) FROM invoices GROUP BY billing_country ORDER BY AVG(total) DESC LIMIT 10;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_country, AVG(total) AS average_invoice_size\nFROM invoices\nGROUP BY billing_country\nORDER BY average_invoice_size DESC\nLIMIT 10;", "hint": "\n"}
{"sample_id": "train.564", "db_id": "store_1", "question": "How many invoices were billed from each state?", "rationale": ["Identify the relevant table: The invoices table contains the billing information including the state.", "Determine the required information: We need to count the number of invoices for each state.", "Use the COUNT() function to count invoices and GROUP BY to group the results by billing_state.", "Construct the SQL query to select the billing_state and the count of invoices, grouping by billing_state."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_state, COUNT(*) AS invoice_count\nFROM invoices\nGROUP BY billing_state;", "hint": "\n"}
{"sample_id": "train.566", "db_id": "store_1", "question": "What are the states with the most invoices?", "rationale": ["Identify the relevant table: The 'invoices' table contains the billing information including the state.", "Determine the required information: We need to count the number of invoices per state.", "Use the COUNT() function to count invoices grouped by 'billing_state'.", "Group the results by 'billing_state' to aggregate the counts for each state.", "Order the results in descending order to find the states with the most invoices."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT 1;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_state, COUNT(*) AS invoice_count\nFROM invoices\nGROUP BY billing_state\nORDER BY invoice_count DESC;", "hint": "\n"}
{"sample_id": "train.568", "db_id": "store_1", "question": "What is the number of invoices and total money billed in them from CA?", "rationale": ["Identify the relevant tables: invoices and customers.", "We need to count the number of invoices and sum the total billed amount.", "Join the invoices table with the customers table on the customer_id to access customer information.", "Filter the results to include only those customers who are located in California (CA).", "Select the count of invoices and the sum of the total amount billed."], "gold_sql": "SELECT billing_state ,  COUNT(*) ,  SUM(total) FROM invoices WHERE billing_state  =  'CA';", "source_tables": ["invoices"], "pred_sql": "SELECT COUNT(*) AS number_of_invoices, SUM(total) AS total_billed\nFROM invoices\nJOIN customers ON invoices.customer_id = customers.id\nWHERE customers.state = 'CA';", "hint": "\n"}
{"sample_id": "train.575", "db_id": "store_1", "question": "What is Astrid Gruber's email and phone number?", "rationale": ["Identify the table that contains the information needed: the 'employees' table has the email and phone number.", "Determine the specific columns to select: 'email' and 'phone'.", "Filter the results to find the specific employee by their first and last name: 'Astrid Gruber'.", "Construct the SQL query using the SELECT statement with the appropriate WHERE clause."], "gold_sql": "SELECT email ,  phone FROM customers WHERE first_name = 'Astrid' AND last_name = 'Gruber';", "source_tables": ["customers"], "pred_sql": "SELECT email, phone FROM employees WHERE first_name = 'Astrid' AND last_name = 'Gruber';", "hint": "\n"}
{"sample_id": "train.580", "db_id": "store_1", "question": "How many customers are from California?", "rationale": ["Identify the relevant table: The question asks about customers, so we will use the 'customers' table.", "Determine the required information: We need to count the number of customers from California.", "Formulate the SQL query: We will use the COUNT() function to count the number of rows where the state is 'California'.", "Construct the SELECT statement: We will select the count from the customers table with the appropriate WHERE clause."], "gold_sql": "SELECT count(*) FROM customers WHERE state = 'CA';", "source_tables": ["customers"], "pred_sql": "SELECT COUNT(*) AS customer_count FROM customers WHERE state = 'California';", "hint": "\n"}
{"sample_id": "train.593", "db_id": "store_1", "question": "Find the full name of employee who supported the most number of customers.", "rationale": ["Identify the relevant tables: employees and customers.", "We need to find the employee who has supported the most customers, which means we need to join the employees table with the customers table on the support_rep_id.", "Use GROUP BY to group the results by employee ID to count the number of customers each employee supports.", "Use COUNT to count the number of customers for each employee.", "Order the results in descending order based on the count of customers supported.", "Limit the results to 1 to get the employee with the highest count."], "gold_sql": "SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employees", "customers"], "pred_sql": "SELECT e.first_name || ' ' || e.last_name AS full_name\nFROM employees e\nJOIN customers c ON e.id = c.support_rep_id\nGROUP BY e.id\nORDER BY COUNT(c.id) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.608", "db_id": "store_1", "question": "How many orders does Luca Mancini have in his invoices?", "rationale": ["Identify the relevant tables: invoices and customers.", "We need to count the number of invoices associated with a specific customer, Luca Mancini.", "Join the invoices table with the customers table on the customer_id field.", "Filter the results to only include invoices for the customer with first name 'Luca' and last name 'Mancini'.", "Use the COUNT() function to count the number of invoices that match the criteria."], "gold_sql": "SELECT count(*) FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id WHERE T1.first_name = 'Lucas' AND T1.last_name = 'Mancini';", "source_tables": ["customers", "invoices"], "pred_sql": "SELECT COUNT(*) AS order_count \nFROM invoices \nJOIN customers ON invoices.customer_id = customers.id \nWHERE customers.first_name = 'Luca' AND customers.last_name = 'Mancini';", "hint": "\n"}
{"sample_id": "train.623", "db_id": "store_1", "question": "What is title of album which track Balls to the Wall belongs to?", "rationale": ["Identify the relevant tables: We need to find the album title from the 'albums' table and the track name from the 'tracks' table.", "Determine the relationship: The 'tracks' table has a foreign key 'album_id' that links to the 'albums' table's 'id'.", "Use a JOIN operation: We will join the 'albums' table with the 'tracks' table on the condition that 'albums.id' matches 'tracks.album_id'.", "Filter by track name: We need to filter the results to only include the track named 'Balls to the Wall'.", "Construct the SQL query: Based on the above steps, the SQL query is constructed to select the album title where the track name matches 'Balls to the Wall'."], "gold_sql": "SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T2.name = 'Balls to the Wall';", "source_tables": ["albums", "tracks"], "pred_sql": "SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.album_id WHERE T2.name = 'Balls to the Wall';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of tracks from the 'tracks' table that belong to a specific album title in the 'albums' table. The placeholder in the WHERE clause represents the title of the album.\",\n        \"virtual_table\": \"SELECT T2.name FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T1.title = [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the titles of albums from the 'albums' table that contain tracks of a specific name. The placeholder in the WHERE clause represents the name of the track.\",\n        \"virtual_table\": \"SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T2.name = [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the titles of all albums from the 'albums' table, sorted in alphabetical order. The query retrieves the 'title' column and orders the results by the album title.\",\n        \"virtual_table\": \"SELECT title FROM albums ORDER BY title;\"\n    }\n}\n"}
{"sample_id": "train.626", "db_id": "store_1", "question": "What is the name of all tracks in the album named Balls to the Wall?", "rationale": ["Identify the relevant tables: 'albums' for album titles and 'tracks' for track names.", "Join the 'albums' table with the 'tracks' table using the foreign key relationship (albums.id = tracks.album_id).", "Filter the results to only include tracks from the album titled 'Balls to the Wall'.", "Select the track names from the joined tables."], "gold_sql": "SELECT T2.name FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T1.title = 'Balls to the Wall';", "source_tables": ["albums", "tracks"], "pred_sql": "SELECT T2.name FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.album_id WHERE T1.title = 'Balls to the Wall';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of tracks from the 'tracks' table that belong to a specific album title in the 'albums' table. The placeholder in the WHERE clause represents the title of the album.\",\n        \"virtual_table\": \"SELECT T2.name FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T1.title = [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the titles of albums from the 'albums' table that contain tracks of a specific name. The placeholder in the WHERE clause represents the name of the track.\",\n        \"virtual_table\": \"SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T2.name = [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the titles of all albums from the 'albums' table, sorted in alphabetical order. The query retrieves the 'title' column and orders the results by the album title.\",\n        \"virtual_table\": \"SELECT title FROM albums ORDER BY title;\"\n    }\n}\n"}
{"sample_id": "train.630", "db_id": "store_1", "question": "What are the names of all Rock tracks that are stored on MPEG audio files?", "rationale": ["Identify the relevant tables: We need to find track names, which are in the 'tracks' table, and we need to filter by genre and media type.", "Join the 'tracks' table with the 'genres' table to filter for Rock tracks. The 'genre_id' in the 'tracks' table corresponds to the 'id' in the 'genres' table.", "Join the 'tracks' table with the 'media_types' table to filter for MPEG audio files. The 'media_type_id' in the 'tracks' table corresponds to the 'id' in the 'media_types' table.", "Construct the SQL query to select the names of tracks where the genre is 'Rock' and the media type is 'MPEG audio'."], "gold_sql": "SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = 'Rock' AND T3.name = 'MPEG audio file';", "source_tables": ["tracks", "genres", "media_types"], "pred_sql": "SELECT T2.name \nFROM tracks AS T2 \nJOIN media_types AS T3 ON T2.media_type_id = T3.id \nJOIN genres AS T1 ON T2.genre_id = T1.id \nWHERE T1.name = 'Rock' AND T3.name = 'MPEG audio';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of tracks from the 'tracks' table that belong to a specific album title in the 'albums' table. The placeholder in the WHERE clause represents the title of the album.\",\n        \"virtual_table\": \"SELECT T2.name FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T1.title = [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the titles of albums from the 'albums' table that contain tracks of a specific name. The placeholder in the WHERE clause represents the name of the track.\",\n        \"virtual_table\": \"SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T2.name = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.632", "db_id": "store_1", "question": "What are the names of all tracks that belong to the Rock genre and whose media type is MPEG?", "rationale": ["Identify the relevant tables: tracks, media_types, and genres.", "We need to join these tables to access the track names, media types, and genre names.", "The tracks table contains the track names and has foreign keys to both media_types and genres.", "Join the tracks table (T1) with media_types (T2) on media_type_id and with genres (T3) on genre_id.", "Filter the results where the genre name is 'Rock' and the media type name is 'MPEG'.", "Select the name of the tracks that meet these criteria."], "gold_sql": "SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = 'Rock' OR T3.name = 'MPEG audio file';", "source_tables": ["tracks", "genres", "media_types"], "pred_sql": "SELECT T1.name \nFROM tracks AS T1 \nJOIN media_types AS T2 ON T1.media_type_id = T2.id \nJOIN genres AS T3 ON T1.genre_id = T3.id \nWHERE T3.name = 'Rock' AND T2.name = 'MPEG';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of different media types from the 'media_types' table. The query retrieves all media type names without any filtering conditions.\",\n        \"virtual_table\": \"SELECT name FROM media_types;\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of tracks from the 'tracks' table that belong to a specific album title in the 'albums' table. The placeholder in the WHERE clause represents the title of the album.\",\n        \"virtual_table\": \"SELECT T2.name FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T1.title = [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the titles of albums from the 'albums' table that contain tracks of a specific name. The placeholder in the WHERE clause represents the name of the track.\",\n        \"virtual_table\": \"SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T2.name = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.640", "db_id": "store_1", "question": "What are the tracks that Dean Peeters bought?", "rationale": ["Identify the customer by the name 'Dean Peeters'.", "Join the 'customers' table with the 'invoices' table to find invoices associated with Dean Peeters.", "Join the 'invoices' table with the 'invoice_lines' table to find the specific tracks purchased in those invoices.", "Join the 'invoice_lines' table with the 'tracks' table to get the names of the tracks that were purchased.", "Filter the results to only include tracks purchased by Dean Peeters."], "gold_sql": "SELECT T1.name FROM tracks AS T1 JOIN invoice_lines AS T2 ON T1.id = T2.track_id JOIN invoices AS T3 ON T3.id = T2.invoice_id JOIN customers AS T4 ON T4.id = T3.customer_id WHERE T4.first_name = 'Daan' AND T4.last_name = 'Peeters';", "source_tables": ["tracks", "invoice_lines", "customers", "invoices"], "pred_sql": "SELECT T3.name FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id JOIN invoice_lines AS T4 ON T2.id = T4.invoice_id JOIN tracks AS T3 ON T4.track_id = T3.id WHERE T1.first_name = 'Dean' AND T1.last_name = 'Peeters';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of tracks from the 'tracks' table that belong to a specific album title in the 'albums' table. The placeholder in the WHERE clause represents the title of the album.\",\n        \"virtual_table\": \"SELECT T2.name FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T1.title = [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the titles of albums from the 'albums' table that contain tracks of a specific name. The placeholder in the WHERE clause represents the name of the track.\",\n        \"virtual_table\": \"SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T2.name = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.686", "db_id": "customers_card_transactions", "question": "What are the full names of customers who do not have any accounts?", "rationale": ["Identify the information needed: full names of customers without accounts.", "To get the full names, we need to concatenate the first and last names from the Customers table.", "We need to filter customers who do not have any accounts, which requires checking the Accounts table.", "Use a subquery to find customer_ids that exist in the Accounts table and exclude them from the main query.", "The final SQL query selects the concatenated full names of customers whose customer_id is not in the list of customer_ids from the Accounts table."], "gold_sql": "SELECT customer_first_name ,  customer_last_name FROM Customers EXCEPT SELECT T1.customer_first_name ,  T1.customer_last_name FROM Customers AS T1 JOIN Accounts AS T2 ON T1.customer_id  =  T2.customer_id", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT customer_first_name || ' ' || customer_last_name AS full_name\nFROM Customers\nWHERE customer_id NOT IN (\n    SELECT customer_id\n    FROM Accounts\n);", "hint": "\n"}
{"sample_id": "train.688", "db_id": "customers_card_transactions", "question": "What are the full names of customers who have accounts?", "rationale": ["Identify the tables involved: Customers and Accounts.", "Determine the relationship: Customers have a one-to-many relationship with Accounts (one customer can have multiple accounts).", "Select the required fields: We need the full names of customers, which can be constructed by concatenating the first and last names.", "Use a JOIN clause to combine the Customers and Accounts tables based on the customer_id field, which is common to both tables.", "Construct the SQL query to select the concatenated full name from the Customers table where there is a corresponding account in the Accounts table."], "gold_sql": "SELECT DISTINCT T1.customer_first_name ,  T1.customer_last_name FROM Customers AS T1 JOIN Accounts AS T2 ON T1.customer_id  =  T2.customer_id", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT Customers.customer_first_name || ' ' || Customers.customer_last_name AS full_name\nFROM Customers\nJOIN Accounts ON Customers.customer_id = Accounts.customer_id;", "hint": "\n"}
{"sample_id": "train.704", "db_id": "customers_card_transactions", "question": "Return the full name and phone of the customer who has card number 4560596484842.", "rationale": ["Identify the required information: full name and phone number of the customer.", "The full name can be constructed by concatenating the first name and last name of the customer.", "The phone number is directly available in the Customers table.", "To find the customer associated with a specific card number, we need to join the Customers table with the Customers_Cards table on the customer_id.", "The WHERE clause will filter the results to only include the customer with the specified card number."], "gold_sql": "SELECT T2.customer_first_name ,  T2.customer_last_name ,  T2.customer_phone FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T1.card_number  =  '4560596484842'", "source_tables": ["customers", "customers_cards"], "pred_sql": "SELECT Customers.customer_first_name || ' ' || Customers.customer_last_name AS full_name, Customers.customer_phone \nFROM Customers \nJOIN Customers_Cards ON Customers.customer_id = Customers_Cards.customer_id \nWHERE Customers_Cards.card_number = '4560596484842';", "hint": "\n"}
{"sample_id": "train.717", "db_id": "customers_card_transactions", "question": "What is the customer id, first and last name with least number of accounts.", "rationale": ["Identify the relevant tables: Customers and Accounts.", "We need to find the customer with the least number of accounts, so we will join the Customers table with the Accounts table on the customer_id.", "Group the results by customer_id, customer_first_name, and customer_last_name to count the number of accounts per customer.", "Use COUNT(a.account_id) to count the number of accounts for each customer.", "Order the results by the count of accounts in ascending order to get the customer with the least number of accounts at the top.", "Limit the results to 1 to get only the customer with the least number of accounts."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) ASC LIMIT 1", "source_tables": ["customers", "customers_cards"], "pred_sql": "SELECT c.customer_id, c.customer_first_name, c.customer_last_name\nFROM Customers c\nJOIN Accounts a ON c.customer_id = a.customer_id\nGROUP BY c.customer_id, c.customer_first_name, c.customer_last_name\nORDER BY COUNT(a.account_id) ASC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.718", "db_id": "customers_card_transactions", "question": "Return the id and full name of the customer who has the fewest accounts.", "rationale": ["Identify the relevant tables: Customers and Accounts.", "We need to join these tables on the customer_id to link customers with their accounts.", "Group the results by customer_id to count the number of accounts each customer has.", "Order the results by the count of accounts in ascending order to find the customer with the fewest accounts.", "Limit the results to 1 to get only the customer with the fewest accounts.", "Select the customer_id and concatenate the first and last name to get the full name."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) ASC LIMIT 1", "source_tables": ["customers", "customers_cards"], "pred_sql": "SELECT c.customer_id, c.customer_first_name || ' ' || c.customer_last_name AS full_name\nFROM Customers c\nJOIN Accounts a ON c.customer_id = a.customer_id\nGROUP BY c.customer_id\nORDER BY COUNT(a.account_id) ASC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.721", "db_id": "customers_card_transactions", "question": "What is the card type code with most number of cards?", "rationale": ["We need to find the card type code with the most number of cards.", "First, we will group the records in the Customers_Cards table by card_type_code to aggregate the counts of each type.", "Next, we will count the number of card_id entries for each card_type_code using COUNT(card_id).", "To find the card type code with the highest count, we will order the results in descending order based on the count.", "Finally, we will limit the results to just one entry to get the card type code with the most cards."], "gold_sql": "SELECT card_type_code FROM Customers_cards GROUP BY card_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers_cards"], "pred_sql": "SELECT card_type_code FROM Customers_Cards GROUP BY card_type_code ORDER BY COUNT(card_id) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique card type codes from the 'Customers_Cards' table. The placeholder in the SELECT statement allows for the retrieval of distinct card types without any filtering conditions.\",\n        \"virtual_table\": \"SELECT DISTINCT card_type_code FROM Customers_Cards\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of customer cards from the 'Customers_Cards' table that match a specific card type. The placeholder in the WHERE clause represents the card type code being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Customers_cards WHERE card_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.735", "db_id": "customers_card_transactions", "question": "Show the number of transaction types.", "rationale": ["The user wants to know the number of transaction types.", "To achieve this, we need to count the occurrences of each transaction type in the Financial_Transactions table.", "We will use the COUNT() function to count the number of transactions for each type.", "We will group the results by transaction_type to get the count for each distinct type."], "gold_sql": "SELECT count(DISTINCT transaction_type) FROM Financial_Transactions", "source_tables": ["financial_transactions"], "pred_sql": "SELECT transaction_type, COUNT(*) as transaction_count FROM Financial_Transactions GROUP BY transaction_type;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of customer cards from the 'Customers_Cards' table that match a specific card type. The placeholder in the WHERE clause represents the card type code being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Customers_cards WHERE card_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.743", "db_id": "customers_card_transactions", "question": "What is the transaction type that has processed the greatest total amount in transactions?", "rationale": ["Identify the relevant table: Financial_Transactions contains the transaction details including transaction type and amount.", "We need to group the results by transaction type to calculate the total amount for each type.", "Use the SUM function to calculate the total amount for each transaction type.", "Order the results in descending order based on the total amount to find the highest one.", "Limit the results to 1 to get only the transaction type with the greatest total amount."], "gold_sql": "SELECT transaction_type FROM Financial_transactions GROUP BY transaction_type ORDER BY sum(transaction_amount) DESC LIMIT 1", "source_tables": ["financial_transactions"], "pred_sql": "SELECT transaction_type, SUM(transaction_amount) AS total_amount\nFROM Financial_Transactions\nGROUP BY transaction_type\nORDER BY total_amount DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.893", "db_id": "insurance_fnol", "question": "What are the customer phone numbers under the policy \"Life Insurance\"?", "rationale": ["Identify the relevant table: Available_Policies contains the customer phone numbers and policy types.", "Determine the specific policy type we are interested in: 'Life Insurance'.", "Construct the SQL query to select the Customer_Phone from Available_Policies where the policy_type_code matches 'Life Insurance'."], "gold_sql": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  'Life Insurance'", "source_tables": ["available_policies"], "pred_sql": "SELECT Customer_Phone FROM Available_Policies WHERE policy_type_code = 'Life Insurance'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the contact phone numbers of customers from the 'Available_Policies' table who have a specific type of insurance policy. The placeholder in the WHERE clause represents the policy type code.\",\n        \"virtual_table\": \"SELECT customer_phone FROM available_policies WHERE policy_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.895", "db_id": "insurance_fnol", "question": "Which policy type has the most records in the database?", "rationale": ["To find out which policy type has the most records, we need to count the number of records for each policy type in the Available_Policies table.", "We will use the COUNT() function to count the records and GROUP BY policy_type_code to group the results by each policy type.", "To get the policy type with the highest count, we will order the results in descending order using ORDER BY record_count DESC.", "Finally, we will limit the results to just one record using LIMIT 1 to get the policy type with the most records."], "gold_sql": "SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["available_policies"], "pred_sql": "SELECT policy_type_code, COUNT(*) as record_count \nFROM Available_Policies \nGROUP BY policy_type_code \nORDER BY record_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the contact phone numbers of customers from the 'Available_Policies' table who have a specific type of insurance policy. The placeholder in the WHERE clause represents the policy type code.\",\n        \"virtual_table\": \"SELECT customer_phone FROM available_policies WHERE policy_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.897", "db_id": "insurance_fnol", "question": "What are all the customer phone numbers under the most popular policy type?", "rationale": ["Identify the need to find customer phone numbers associated with the most popular policy type.", "Determine that the most popular policy type can be found by grouping the policies and counting their occurrences.", "Use a subquery to select the policy type code that has the highest count of occurrences in the Available_Policies table.", "Incorporate this subquery into the main query to filter customer phone numbers from the Available_Policies table based on the most popular policy type."], "gold_sql": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  (SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["available_policies"], "pred_sql": "SELECT Customer_Phone FROM Available_Policies WHERE policy_type_code = (SELECT policy_type_code FROM Available_Policies GROUP BY policy_type_code ORDER BY COUNT(*) DESC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the contact phone numbers of customers from the 'Available_Policies' table who have a specific type of insurance policy. The placeholder in the WHERE clause represents the policy type code.\",\n        \"virtual_table\": \"SELECT customer_phone FROM available_policies WHERE policy_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.898", "db_id": "insurance_fnol", "question": "Find the phone numbers of customers using the most common policy type among the available policies.", "rationale": ["Identify the most common policy type among the available policies by grouping the policies and counting their occurrences.", "Use a subquery to find the policy type code that has the highest count.", "Select the customer phone numbers from the Available_Policies table where the policy type code matches the most common one."], "gold_sql": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  (SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["available_policies"], "pred_sql": "SELECT Customer_Phone FROM Available_Policies WHERE policy_type_code = (SELECT policy_type_code FROM Available_Policies GROUP BY policy_type_code ORDER BY COUNT(*) DESC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the contact phone numbers of customers from the 'Available_Policies' table who have a specific type of insurance policy. The placeholder in the WHERE clause represents the policy type code.\",\n        \"virtual_table\": \"SELECT customer_phone FROM available_policies WHERE policy_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.1060", "db_id": "match_season", "question": "Show the players from college UCLA.", "rationale": ["Identify the relevant table: The 'match_season' table contains information about players and their colleges.", "Determine the filtering condition: We need to filter players who attended UCLA.", "Construct the SQL query: Use a SELECT statement to get the 'Player' column from the 'match_season' table where the 'College' is 'UCLA'.", "Include an ORDER BY clause to sort the results by college name, even though in this case we are filtering for a specific college."], "gold_sql": "SELECT Player FROM match_season WHERE College  =  'UCLA'", "source_tables": ["match_season"], "pred_sql": "SELECT Player FROM match_season WHERE College = 'UCLA' ORDER BY College ASC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of players from the 'match_season' table, ordered by their college names in ascending order. The placeholder in the ORDER BY clause represents the college names.\",\n        \"virtual_table\": \"SELECT player FROM match_season ORDER BY College ASC\"\n    }\n}\n"}
{"sample_id": "train.1082", "db_id": "match_season", "question": "Show the season, the player, and the name of the team that players belong to.", "rationale": ["Identify the required columns: Season, Player, and Team.", "These columns are available in the match_season table.", "Construct the SELECT statement to retrieve these columns from the match_season table."], "gold_sql": "SELECT T1.Season ,  T1.Player ,  T2.Name FROM match_season AS T1 JOIN team AS T2 ON T1.Team  =  T2.Team_id", "source_tables": ["team", "match_season"], "pred_sql": "SELECT match_season.Season, match_season.Player, match_season.Team FROM match_season", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of players from the 'match_season' table, ordered by their college names in ascending order. The placeholder in the ORDER BY clause represents the college names.\",\n        \"virtual_table\": \"SELECT player FROM match_season ORDER BY College ASC\"\n    }\n}\n"}
{"sample_id": "train.1092", "db_id": "match_season", "question": "Show the country names and the corresponding number of players.", "rationale": ["Identify the tables needed: We need the 'country' table for country names and the 'player' table to count the players.", "We will use a LEFT JOIN to connect the 'country' table with the 'match_season' table on the 'Country_id' and 'Country' columns, respectively, to get the players associated with each country.", "Next, we will join the 'match_season' table with the 'player' table to access player information.", "We will use COUNT() to count the number of players for each country.", "Finally, we will group the results by 'Country_name' to get the count of players for each country."], "gold_sql": "SELECT Country_name ,  COUNT(*) FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country GROUP BY T1.Country_name", "source_tables": ["country", "match_season"], "pred_sql": "SELECT c.Country_name, COUNT(p.Player_ID) AS Number_of_Players\nFROM country c\nLEFT JOIN match_season ms ON c.Country_id = ms.Country\nLEFT JOIN player p ON ms.Player = p.Player\nGROUP BY c.Country_name;", "hint": "\n"}
{"sample_id": "train.1098", "db_id": "match_season", "question": "Show the top 3 most common colleges of players in match seasons.", "rationale": ["We need to find the most common colleges of players in match seasons.", "To do this, we will select the 'College' column from the 'match_season' table.", "We will count the occurrences of each college using COUNT(*) and alias it as 'College_Count'.", "To get the most common colleges, we will group the results by 'College'.", "We will then order the results in descending order based on 'College_Count' to get the most common colleges at the top.", "Finally, we will limit the results to the top 3 colleges using LIMIT 3."], "gold_sql": "SELECT College FROM match_season GROUP BY College ORDER BY count(*) DESC LIMIT 3", "source_tables": ["match_season"], "pred_sql": "SELECT College, COUNT(*) as College_Count FROM match_season GROUP BY College ORDER BY College_Count DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of players from the 'match_season' table, ordered by their college names in ascending order. The placeholder in the ORDER BY clause represents the college names.\",\n        \"virtual_table\": \"SELECT player FROM match_season ORDER BY College ASC\"\n    }\n}\n"}
{"sample_id": "train.1099", "db_id": "match_season", "question": "What are the three colleges from which the most players are from?", "rationale": ["We need to find the colleges with the most players.", "To do this, we will count the number of players associated with each college in the 'match_season' table.", "We will use the COUNT function to count the players for each college.", "We will group the results by the 'College' column to aggregate the counts for each college.", "To get the top three colleges, we will order the results by the count of players in descending order.", "Finally, we will limit the results to the top three using the LIMIT clause."], "gold_sql": "SELECT College FROM match_season GROUP BY College ORDER BY count(*) DESC LIMIT 3", "source_tables": ["match_season"], "pred_sql": "SELECT College, COUNT(*) as Player_Count\nFROM match_season\nGROUP BY College\nORDER BY Player_Count DESC\nLIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of players from the 'match_season' table, ordered by their college names in ascending order. The placeholder in the ORDER BY clause represents the college names.\",\n        \"virtual_table\": \"SELECT player FROM match_season ORDER BY College ASC\"\n    }\n}\n"}
{"sample_id": "train.1107", "db_id": "match_season", "question": "Return the names of countries that have players that play the Forward position, as well as players who play the Defender position.", "rationale": ["Identify the relevant tables: We need to use the 'country' and 'match_season' tables to get the required information.", "Determine the relationship: The 'match_season' table has a foreign key 'Country' that links to 'Country_id' in the 'country' table.", "Select the necessary columns: We need the 'Country_name' from the 'country' table.", "Filter the results: We want countries that have players in either the 'Forward' or 'Defender' positions, so we will use a WHERE clause with an IN condition.", "Use DISTINCT to avoid duplicate country names in the result."], "gold_sql": "SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  'Forward' INTERSECT SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  'Defender'", "source_tables": ["country", "match_season"], "pred_sql": "SELECT DISTINCT c.Country_name \nFROM country c \nJOIN match_season ms ON c.Country_id = ms.Country \nWHERE ms.Position IN ('Forward', 'Defender');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of players from the 'match_season' table, ordered by their college names in ascending order. The placeholder in the ORDER BY clause represents the college names.\",\n        \"virtual_table\": \"SELECT player FROM match_season ORDER BY College ASC\"\n    }\n}\n"}
{"sample_id": "train.1109", "db_id": "match_season", "question": "Return the colleges that have players who play the Midfielder position, as well as players who play the Defender position.", "rationale": ["Identify the relevant table: The 'match_season' table contains information about players, their positions, and the colleges they attended.", "Determine the required positions: We need players who play as 'Midfielder' or 'Defender'.", "Use the WHERE clause to filter players based on their positions.", "Select the 'College' column to get the colleges of these players.", "Use DISTINCT to ensure that each college is listed only once in the result."], "gold_sql": "SELECT College FROM match_season WHERE POSITION  =  'Midfielder' INTERSECT SELECT College FROM match_season WHERE POSITION  =  'Defender'", "source_tables": ["match_season"], "pred_sql": "SELECT DISTINCT College FROM match_season WHERE Position IN ('Midfielder', 'Defender')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of players from the 'match_season' table, ordered by their college names in ascending order. The placeholder in the ORDER BY clause represents the college names.\",\n        \"virtual_table\": \"SELECT player FROM match_season ORDER BY College ASC\"\n    }\n}\n"}
{"sample_id": "train.1222", "db_id": "apartment_rentals", "question": "What are the booking start and end dates of the apartments with type code \"Duplex\"?", "rationale": ["Identify the relevant tables: Apartment_Bookings for booking dates and Apartments for apartment type.", "Join the Apartment_Bookings table with the Apartments table on the apt_id to link bookings to their respective apartments.", "Filter the results to only include apartments with the type code 'Duplex'.", "Select the booking_start_date and booking_end_date from the joined tables."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.apt_type_code  =  'Duplex'", "source_tables": ["apartment_bookings", "apartments"], "pred_sql": "SELECT T1.booking_start_date, T1.booking_end_date \nFROM Apartment_Bookings AS T1 \nJOIN Apartments AS T2 ON T1.apt_id = T2.apt_id \nWHERE T2.apt_type_code = 'Duplex'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the start dates of apartment bookings along with the corresponding booking end dates for guests filtered by a specific gender. The placeholders in the WHERE clause represent the gender code of the guests.\",\n        \"virtual_table\": \"SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id WHERE T2.gender_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the start dates of apartment bookings from the 'Apartment_Bookings' table for apartments of a specific type. The placeholder in the WHERE clause represents the apartment type code.\",\n        \"virtual_table\": \"SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.apt_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides information about apartment bookings, specifically the apartment number and the start date of the booking. The placeholders in the query allow for filtering or additional conditions to be applied as needed.\",\n        \"virtual_table\": \"SELECT T2.apt_number ,  T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id\"\n    }\n}\n"}
{"sample_id": "train.1224", "db_id": "apartment_rentals", "question": "What are the booking start and end dates of the apartments with more than 2 bedrooms?", "rationale": ["Identify the relevant tables: Apartment_Bookings for booking dates and Apartments for bedroom count.", "Join the Apartment_Bookings table with the Apartments table on the apt_id to access both booking dates and bedroom count.", "Filter the results to include only those apartments that have more than 2 bedrooms using the condition 'A.bedroom_count > 2'.", "Select the booking start and end dates from the joined tables."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  2", "source_tables": ["apartment_bookings", "apartments"], "pred_sql": "SELECT AB.booking_start_date, AB.booking_end_date \nFROM Apartment_Bookings AS AB \nJOIN Apartments AS A ON AB.apt_id = A.apt_id \nWHERE A.bedroom_count > 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the start dates of apartment bookings along with the corresponding booking end dates for guests filtered by a specific gender. The placeholders in the WHERE clause represent the gender code of the guests.\",\n        \"virtual_table\": \"SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id WHERE T2.gender_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides information about apartment bookings, specifically the apartment number and the start date of the booking. The placeholders in the query allow for filtering or additional conditions to be applied as needed.\",\n        \"virtual_table\": \"SELECT T2.apt_number ,  T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the start dates of apartment bookings from the 'Apartment_Bookings' table for apartments of a specific type. The placeholder in the WHERE clause represents the apartment type code.\",\n        \"virtual_table\": \"SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.apt_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.1225", "db_id": "apartment_rentals", "question": "Find the booking start date and end date for the apartments that have more than two bedrooms.", "rationale": ["Identify the tables needed: Apartment_Bookings for booking dates and Apartments for bedroom count.", "Join the Apartment_Bookings table with the Apartments table on the apt_id to link bookings to their respective apartments.", "Filter the results to include only those apartments that have more than two bedrooms by using a WHERE clause with the condition 'T2.bedroom_count > 2'.", "Select the booking start date and end date from the Apartment_Bookings table."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  2", "source_tables": ["apartment_bookings", "apartments"], "pred_sql": "SELECT T1.booking_start_date, T1.booking_end_date \nFROM Apartment_Bookings AS T1 \nJOIN Apartments AS T2 ON T1.apt_id = T2.apt_id \nWHERE T2.bedroom_count > 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the start dates of apartment bookings along with the corresponding booking end dates for guests filtered by a specific gender. The placeholders in the WHERE clause represent the gender code of the guests.\",\n        \"virtual_table\": \"SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id WHERE T2.gender_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides information about apartment bookings, specifically the apartment number and the start date of the booking. The placeholders in the query allow for filtering or additional conditions to be applied as needed.\",\n        \"virtual_table\": \"SELECT T2.apt_number ,  T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the start dates of apartment bookings from the 'Apartment_Bookings' table for apartments of a specific type. The placeholder in the WHERE clause represents the apartment type code.\",\n        \"virtual_table\": \"SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.apt_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.1229", "db_id": "apartment_rentals", "question": "Which apartments have bookings with status code \"Confirmed\"? Return their apartment numbers.", "rationale": ["Identify the relevant tables: Apartment_Bookings and Apartments are needed to get booking information and apartment numbers.", "Join the Apartment_Bookings table with the Apartments table on the apt_id to link bookings to their respective apartments.", "Filter the results to only include bookings with the status code 'Confirmed'.", "Select the apartment numbers from the joined tables."], "gold_sql": "SELECT DISTINCT T2.apt_number FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T1.booking_status_code  =  'Confirmed'", "source_tables": ["apartment_bookings", "apartments"], "pred_sql": "SELECT T2.apt_number \nFROM Apartment_Bookings AS T1 \nJOIN Apartments AS T2 ON T1.apt_id = T2.apt_id \nWHERE T1.booking_status_code = 'Confirmed';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides information about apartment bookings, specifically the apartment number and the start date of the booking. The placeholders in the query allow for filtering or additional conditions to be applied as needed.\",\n        \"virtual_table\": \"SELECT T2.apt_number ,  T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the facility codes of apartments that have a specified number of bedrooms. The placeholder in the WHERE clause represents the minimum number of bedrooms required for the apartments.\",\n        \"virtual_table\": \"SELECT T1.facility_code FROM Apartment_Facilities AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of apartment numbers along with their corresponding booking start dates from the 'Apartment_Bookings' and 'Apartments' tables. The placeholders in the query represent the identifiers linking the bookings to the apartments.\",\n        \"virtual_table\": \"SELECT T2.apt_number ,  T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id\"\n    }\n}\n"}
{"sample_id": "train.1232", "db_id": "apartment_rentals", "question": "Show the guest first names, start dates, and end dates of all the apartment bookings.", "rationale": ["Identify the tables needed: Apartment_Bookings for booking details and Guests for guest information.", "Select the required columns: guest_first_name from Guests and booking_start_date, booking_end_date from Apartment_Bookings.", "Join the two tables on the guest_id to link bookings with guests.", "Construct the SQL query using the SELECT statement with the appropriate JOIN condition."], "gold_sql": "SELECT T2.guest_first_name ,  T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id", "source_tables": ["apartment_bookings", "guests"], "pred_sql": "SELECT T2.guest_first_name, T1.booking_start_date, T1.booking_end_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id = T2.guest_id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first names of guests along with the start dates of their apartment bookings. The placeholders in the query allow for filtering or additional conditions to be applied as needed.\",\n        \"virtual_table\": \"SELECT T2.guest_first_name ,  T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the start dates of apartment bookings along with the corresponding booking end dates for guests filtered by a specific gender. The placeholders in the WHERE clause represent the gender code of the guests.\",\n        \"virtual_table\": \"SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id WHERE T2.gender_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides information about apartment bookings, specifically the apartment number and the start date of the booking. The placeholders in the query allow for filtering or additional conditions to be applied as needed.\",\n        \"virtual_table\": \"SELECT T2.apt_number ,  T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id\"\n    }\n}\n"}
{"sample_id": "train.1234", "db_id": "apartment_rentals", "question": "Show the start dates and end dates of all the apartment bookings made by guests with gender code \"Female\".", "rationale": ["Identify the tables needed: Apartment_Bookings for booking dates and Guests for gender information.", "Join the Apartment_Bookings table with the Guests table on guest_id to link bookings to guests.", "Select the booking_start_date and booking_end_date from the Apartment_Bookings table.", "Filter the results to include only those guests with a gender code of 'Female'."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id WHERE T2.gender_code  =  'Female'", "source_tables": ["apartment_bookings", "guests"], "pred_sql": "SELECT T1.booking_start_date, T1.booking_end_date \nFROM Apartment_Bookings AS T1 \nJOIN Guests AS T2 ON T1.guest_id = T2.guest_id \nWHERE T2.gender_code = 'Female'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the start dates of apartment bookings along with the corresponding booking end dates for guests filtered by a specific gender. The placeholders in the WHERE clause represent the gender code of the guests.\",\n        \"virtual_table\": \"SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id WHERE T2.gender_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first names of guests along with the start dates of their apartment bookings. The placeholders in the query allow for filtering or additional conditions to be applied as needed.\",\n        \"virtual_table\": \"SELECT T2.guest_first_name ,  T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides information about apartment bookings, specifically the apartment number and the start date of the booking. The placeholders in the query allow for filtering or additional conditions to be applied as needed.\",\n        \"virtual_table\": \"SELECT T2.apt_number ,  T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id\"\n    }\n}\n"}
{"sample_id": "train.1238", "db_id": "apartment_rentals", "question": "Show the facility codes of apartments with more than 4 bedrooms.", "rationale": ["Identify the relevant tables: Apartment_Facilities for facility codes and Apartments for bedroom counts.", "Establish the relationship between the two tables using the apt_id column.", "Filter the results to include only those apartments with more than 4 bedrooms by using a WHERE clause with the condition T2.bedroom_count > 4."], "gold_sql": "SELECT T1.facility_code FROM Apartment_Facilities AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  4", "source_tables": ["apartments", "apartment_facilities"], "pred_sql": "SELECT T1.facility_code FROM Apartment_Facilities AS T1 JOIN Apartments AS T2 ON T1.apt_id = T2.apt_id WHERE T2.bedroom_count > 4", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the facility codes of apartments that have a specified number of bedrooms. The placeholder in the WHERE clause represents the minimum number of bedrooms required for the apartments.\",\n        \"virtual_table\": \"SELECT T1.facility_code FROM Apartment_Facilities AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides information about apartment bookings, specifically the apartment number and the start date of the booking. The placeholders in the query allow for filtering or additional conditions to be applied as needed.\",\n        \"virtual_table\": \"SELECT T2.apt_number ,  T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the start dates of apartment bookings along with the corresponding booking end dates for guests filtered by a specific gender. The placeholders in the WHERE clause represent the gender code of the guests.\",\n        \"virtual_table\": \"SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id WHERE T2.gender_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.1256", "db_id": "apartment_rentals", "question": "Show the top 3 apartment type codes sorted by the average number of rooms in descending order.", "rationale": ["Identify the relevant table: The Apartments table contains the apt_type_code and room_count columns needed for the query.", "Calculate the average number of rooms for each apartment type: Use the AVG() function to compute the average of room_count, grouped by apt_type_code.", "Sort the results in descending order: Use ORDER BY to sort the average number of rooms from highest to lowest.", "Limit the results to the top 3: Use LIMIT 3 to restrict the output to the top 3 apartment type codes."], "gold_sql": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY avg(room_count) DESC LIMIT 3", "source_tables": ["apartments"], "pred_sql": "SELECT apt_type_code, AVG(room_count) AS average_rooms \nFROM Apartments \nGROUP BY apt_type_code \nORDER BY average_rooms DESC \nLIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the facility codes of apartments that have a specified number of bedrooms. The placeholder in the WHERE clause represents the minimum number of bedrooms required for the apartments.\",\n        \"virtual_table\": \"SELECT T1.facility_code FROM Apartment_Facilities AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides information about apartment bookings, specifically the apartment number and the start date of the booking. The placeholders in the query allow for filtering or additional conditions to be applied as needed.\",\n        \"virtual_table\": \"SELECT T2.apt_number ,  T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the start dates of apartment bookings from the 'Apartment_Bookings' table for apartments of a specific type. The placeholder in the WHERE clause represents the apartment type code.\",\n        \"virtual_table\": \"SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.apt_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.1258", "db_id": "apartment_rentals", "question": "Show the apartment type code that has the largest number of total rooms, together with the number of bathrooms and number of bedrooms.", "rationale": ["Identify the relevant columns needed: apt_type_code, bathroom_count, bedroom_count, and room_count.", "To find the apartment type code with the largest number of total rooms, we need to group the results by apt_type_code.", "Use the MAX function to get the maximum room_count for each apartment type.", "Select the bathroom_count and bedroom_count along with the apt_type_code.", "Order the results by the maximum number of rooms in descending order to get the top result.", "Limit the results to 1 to get only the apartment type with the largest number of total rooms."], "gold_sql": "SELECT apt_type_code ,  bathroom_count ,  bedroom_count FROM Apartments GROUP BY apt_type_code ORDER BY sum(room_count) DESC LIMIT 1", "source_tables": ["apartments"], "pred_sql": "SELECT apt_type_code, MAX(room_count) AS max_rooms, bathroom_count, bedroom_count \nFROM Apartments \nGROUP BY apt_type_code \nORDER BY max_rooms DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the facility codes of apartments that have a specified number of bedrooms. The placeholder in the WHERE clause represents the minimum number of bedrooms required for the apartments.\",\n        \"virtual_table\": \"SELECT T1.facility_code FROM Apartment_Facilities AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides information about apartment bookings, specifically the apartment number and the start date of the booking. The placeholders in the query allow for filtering or additional conditions to be applied as needed.\",\n        \"virtual_table\": \"SELECT T2.apt_number ,  T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the start dates of apartment bookings along with the corresponding booking end dates for guests filtered by a specific gender. The placeholders in the WHERE clause represent the gender code of the guests.\",\n        \"virtual_table\": \"SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id WHERE T2.gender_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.1261", "db_id": "apartment_rentals", "question": "Which apartment type code appears the most often?", "rationale": ["Identify the relevant table: The Apartments table contains the apt_type_code which we need to analyze.", "Count the occurrences of each apartment type code: We can use the COUNT function to count how many times each apt_type_code appears.", "Group the results by apt_type_code: This allows us to aggregate the counts for each type code.", "Order the results by count in descending order: This will help us find the most frequently occurring apartment type code.", "Limit the results to 1: Since we only want the apartment type code that appears the most often."], "gold_sql": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["apartments"], "pred_sql": "SELECT apt_type_code, COUNT(*) as count FROM Apartments GROUP BY apt_type_code ORDER BY count DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the facility codes of apartments that have a specified number of bedrooms. The placeholder in the WHERE clause represents the minimum number of bedrooms required for the apartments.\",\n        \"virtual_table\": \"SELECT T1.facility_code FROM Apartment_Facilities AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides information about apartment bookings, specifically the apartment number and the start date of the booking. The placeholders in the query allow for filtering or additional conditions to be applied as needed.\",\n        \"virtual_table\": \"SELECT T2.apt_number ,  T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the start dates of apartment bookings from the 'Apartment_Bookings' table for apartments of a specific type. The placeholder in the WHERE clause represents the apartment type code.\",\n        \"virtual_table\": \"SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.apt_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.1262", "db_id": "apartment_rentals", "question": "Show the most common apartment type code among apartments with more than 1 bathroom.", "rationale": ["Identify the relevant table: The Apartments table contains the apartment type codes and the number of bathrooms.", "Filter apartments: We need to filter apartments that have more than 1 bathroom, which is done using the WHERE clause.", "Group by apartment type: To find the most common apartment type, we will group the results by the apartment type code using GROUP BY.", "Count occurrences: We will count the number of occurrences of each apartment type code using COUNT(*) and alias it as type_count.", "Order by count: To find the most common type, we will order the results in descending order based on the count of apartments.", "Limit the results: Finally, we will limit the results to 1 to get the most common apartment type code."], "gold_sql": "SELECT apt_type_code FROM Apartments WHERE bathroom_count  >  1 GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["apartments"], "pred_sql": "SELECT apt_type_code, COUNT(*) as type_count \nFROM Apartments \nWHERE bathroom_count > 1 \nGROUP BY apt_type_code \nORDER BY type_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the facility codes of apartments that have a specified number of bedrooms. The placeholder in the WHERE clause represents the minimum number of bedrooms required for the apartments.\",\n        \"virtual_table\": \"SELECT T1.facility_code FROM Apartment_Facilities AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the start dates of apartment bookings along with the corresponding booking end dates for guests filtered by a specific gender. The placeholders in the WHERE clause represent the gender code of the guests.\",\n        \"virtual_table\": \"SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id WHERE T2.gender_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the start dates of apartment bookings from the 'Apartment_Bookings' table for apartments of a specific type. The placeholder in the WHERE clause represents the apartment type code.\",\n        \"virtual_table\": \"SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.apt_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.1272", "db_id": "apartment_rentals", "question": "Show the apartment numbers of apartments with unit status availability of both 0 and 1.", "rationale": ["Identify the relevant tables: Apartments and View_Unit_Status are needed to get apartment numbers and their availability status.", "Join the Apartments table with the View_Unit_Status table on the apt_id to link apartments with their availability status.", "Filter the results to include only those apartments where the availability status is either '0' or '1'.", "Select the apt_number from the filtered results.", "Group the results by apt_number to ensure unique apartment numbers are returned."], "gold_sql": "SELECT T1.apt_number FROM Apartments AS T1 JOIN View_Unit_Status AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.available_yn  =  0 INTERSECT SELECT T1.apt_number FROM Apartments AS T1 JOIN View_Unit_Status AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.available_yn  =  1", "source_tables": ["view_unit_status", "apartments"], "pred_sql": "SELECT A.apt_number \nFROM Apartments AS A \nJOIN View_Unit_Status AS VUS ON A.apt_id = VUS.apt_id \nWHERE VUS.available_yn IN ('0', '1') \nGROUP BY A.apt_number;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the facility codes of apartments that have a specified number of bedrooms. The placeholder in the WHERE clause represents the minimum number of bedrooms required for the apartments.\",\n        \"virtual_table\": \"SELECT T1.facility_code FROM Apartment_Facilities AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides information about apartment bookings, specifically the apartment number and the start date of the booking. The placeholders in the query allow for filtering or additional conditions to be applied as needed.\",\n        \"virtual_table\": \"SELECT T2.apt_number ,  T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of apartment numbers along with their corresponding booking start dates from the 'Apartment_Bookings' and 'Apartments' tables. The placeholders in the query represent the identifiers linking the bookings to the apartments.\",\n        \"virtual_table\": \"SELECT T2.apt_number ,  T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id\"\n    }\n}\n"}
{"sample_id": "train.1294", "db_id": "soccer_1", "question": "How many leagues are there in England?", "rationale": ["Identify the relevant table: The question pertains to leagues, so we will use the 'League' table.", "Determine the condition: We need to count the leagues specifically in England.", "Construct the SQL query: Use the COUNT function to count the number of records in the 'League' table where the name is 'England'."], "gold_sql": "SELECT count(*) FROM Country AS T1 JOIN League AS T2 ON T1.id  =  T2.country_id WHERE T1.name  =  'England'", "source_tables": ["country", "league"], "pred_sql": "SELECT COUNT(*) AS league_count FROM League WHERE name = 'England';", "hint": "\n"}
{"sample_id": "train.1303", "db_id": "soccer_1", "question": "List all of the player ids with a height of at least 180cm and an overall rating higher than 85.", "rationale": ["Identify the relevant tables: Player and Player_Attributes.", "We need to select player ids, so we will select the 'id' column from the Player table.", "We need to filter players based on height and overall rating, so we will use a JOIN between Player and Player_Attributes on the player_api_id.", "The height condition is that it should be at least 180 cm, which corresponds to the 'height' column in the Player table.", "The overall rating condition is that it should be higher than 85, which corresponds to the 'overall_rating' column in the Player_Attributes table.", "Combine these conditions in the WHERE clause of the SQL query."], "gold_sql": "SELECT player_api_id FROM Player WHERE height  >=  180 INTERSECT SELECT player_api_id FROM Player_Attributes WHERE overall_rating  >  85", "source_tables": ["player_attributes", "player"], "pred_sql": "SELECT P.id FROM Player AS P JOIN Player_Attributes AS PA ON P.player_api_id = PA.player_api_id WHERE P.height >= 180 AND PA.overall_rating > 85;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique player names from the 'Player' table, joined with their corresponding attributes from the 'Player_Attributes' table. The results are ordered by the players' overall skill ratings in descending order, and the number of results returned is limited by a specified placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id  =  T2.player_api_id ORDER BY overall_rating DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1304", "db_id": "soccer_1", "question": "List all of the ids for left-footed players with a height between 180cm and 190cm.", "rationale": ["Identify the relevant tables: Player and Player_Attributes.", "We need to select the 'id' from the Player table.", "We need to join Player with Player_Attributes on the common column 'player_api_id'.", "Filter the results to include only left-footed players by checking 'preferred_foot' in Player_Attributes.", "Filter the players based on height, ensuring it is between 180cm and 190cm."], "gold_sql": "SELECT player_api_id FROM Player WHERE height  >=  180 AND height  <=  190 INTERSECT SELECT player_api_id FROM Player_Attributes WHERE preferred_foot  =  'left'", "source_tables": ["player_attributes", "player"], "pred_sql": "SELECT Player.id FROM Player JOIN Player_Attributes ON Player.player_api_id = Player_Attributes.player_api_id WHERE Player.height BETWEEN 180 AND 190 AND Player_Attributes.preferred_foot = 'left';", "hint": "\n"}
{"sample_id": "train.1306", "db_id": "soccer_1", "question": "List the names and birthdays of the top five players in terms of potential.", "rationale": ["Identify the relevant tables: Player and Player_Attributes.", "We need to retrieve player names and birthdays, which are in the Player table.", "The potential attribute is in the Player_Attributes table, so we need to join these two tables on player_api_id.", "Use an ORDER BY clause to sort the results by potential in descending order to get the top players.", "Limit the results to the top five players using LIMIT 5."], "gold_sql": "SELECT DISTINCT T1.player_name ,  T1.birthday FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id  =  T2.player_api_id ORDER BY potential DESC LIMIT 5", "source_tables": ["player_attributes", "player"], "pred_sql": "SELECT player_name, birthday \nFROM Player \nJOIN Player_Attributes ON Player.player_api_id = Player_Attributes.player_api_id \nORDER BY potential DESC \nLIMIT 5;", "hint": "\n"}
{"sample_id": "train.1511", "db_id": "insurance_and_eClaims", "question": "Which type of policy is most frequently used? Give me the policy type code.", "rationale": ["Identify the relevant table: The question asks about policy types, so we will focus on the Policies table.", "Determine the required columns: We need the Policy_Type_Code and a count of how many times each type is used.", "Use the COUNT function: This will allow us to count the occurrences of each Policy_Type_Code.", "Group the results: We will group the results by Policy_Type_Code to get the frequency of each type.", "Order the results: We will order the results in descending order based on the frequency count to find the most frequently used policy type.", "Limit the results: Since we only want the most frequently used policy type, we will limit the results to 1."], "gold_sql": "SELECT policy_type_code FROM policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["policies"], "pred_sql": "SELECT Policy_Type_Code, COUNT(*) as Frequency\nFROM Policies\nGROUP BY Policy_Type_Code\nORDER BY Frequency DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.1513", "db_id": "insurance_and_eClaims", "question": "Find all the policy types that are used by more than 2 customers.", "rationale": ["We need to find policy types used by more than 2 customers.", "First, we will identify the customers who have policies. We can do this by selecting the Customer_ID from the Policies table and grouping by Customer_ID.", "Next, we will use the HAVING clause to filter those groups to only include customers that have more than 2 policies.", "After identifying the customers, we will select the Policy_Type_Code from the Policies table where the Customer_ID is in the list of customers identified in the previous step.", "Finally, we will group the results by Policy_Type_Code to get the distinct policy types used by more than 2 customers."], "gold_sql": "SELECT policy_type_code FROM policies GROUP BY policy_type_code HAVING count(*)  >  2", "source_tables": ["policies"], "pred_sql": "SELECT Policy_Type_Code\nFROM Policies\nWHERE Customer_ID IN (\n    SELECT Customer_ID\n    FROM Policies\n    GROUP BY Customer_ID\n    HAVING COUNT(DISTINCT Customer_ID) > 2\n)\nGROUP BY Policy_Type_Code;", "hint": "\n"}
{"sample_id": "train.1516", "db_id": "insurance_and_eClaims", "question": "What are the total amount and average amount paid in claim headers?", "rationale": ["Identify the relevant table: Claim_Headers contains the amount paid for claims.", "Determine the required calculations: We need to calculate the total and average of the 'Amount_Paid' column.", "Construct the SQL query: Use the SUM() function to get the total amount paid and the AVG() function to get the average amount paid from the 'Claim_Headers' table."], "gold_sql": "SELECT sum(amount_piad) ,  avg(amount_piad) FROM claim_headers", "source_tables": ["claim_headers"], "pred_sql": "SELECT sum(Amount_Piad) AS Total_Amount_Paid, avg(Amount_Piad) AS Average_Amount_Paid FROM Claim_Headers", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total and average amounts paid for claims from the 'Claim_Headers' table. The placeholders in the SELECT clause represent the total and average of the 'amount_paid' column.\",\n        \"virtual_table\": \"SELECT sum(amount_piad) ,  avg(amount_piad) FROM claim_headers\"\n    }\n}\n"}
{"sample_id": "train.1518", "db_id": "insurance_and_eClaims", "question": "How much amount in total were claimed in the most recently created document?", "rationale": ["Identify the relevant tables: Claim_Headers for claim amounts and Claims_Documents for document creation dates.", "We need to sum the 'Amount_Claimed' from the Claim_Headers table.", "Join Claim_Headers with Claims_Documents on the Claim_ID to link claims with their documents.", "Filter the results to only include claims associated with the most recently created document by using a subquery to find the maximum 'Created_Date' from Claims_Documents."], "gold_sql": "SELECT sum(t1.amount_claimed) FROM claim_headers AS t1 JOIN claims_documents AS t2 ON t1.claim_header_id  =  t2.claim_id WHERE t2.created_date  =  (SELECT created_date FROM claims_documents ORDER BY created_date LIMIT 1)", "source_tables": ["claims_documents", "claim_headers"], "pred_sql": "SELECT SUM(ch.Amount_Claimed) AS Total_Claimed\nFROM Claim_Headers ch\nJOIN Claims_Documents cd ON ch.Claim_Header_ID = cd.Claim_ID\nWHERE cd.Created_Date = (SELECT MAX(Created_Date) FROM Claims_Documents);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total and average amounts paid for claims from the 'Claim_Headers' table. The placeholders in the SELECT clause represent the total and average of the 'amount_paid' column.\",\n        \"virtual_table\": \"SELECT sum(amount_piad) ,  avg(amount_piad) FROM claim_headers\"\n    }\n}\n"}
{"sample_id": "train.1519", "db_id": "insurance_and_eClaims", "question": "What is the name of the customer who has made the largest amount of claim in a single claim?", "rationale": ["Identify the relevant tables: Customers, Policies, and Claim_Headers are needed to find the customer with the largest claim.", "Join the Customers table with the Policies table on Customer_ID to link customers to their policies.", "Join the resulting table with the Claim_Headers table on Policy_ID to access claim information related to each customer.", "Use a subquery to find the maximum amount claimed from the Claim_Headers table.", "Filter the results to only include the customer(s) who made a claim equal to this maximum amount."], "gold_sql": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_claimed  =  (SELECT max(amount_claimed) FROM claim_headers)", "source_tables": ["policies", "customers", "claim_headers"], "pred_sql": "SELECT c.Customer_Details \nFROM Customers c \nJOIN Policies p ON c.Customer_ID = p.Customer_ID \nJOIN Claim_Headers ch ON p.Policy_ID = ch.Policy_ID \nWHERE ch.Amount_Claimed = (SELECT MAX(Amount_Claimed) FROM Claim_Headers)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total and average amounts paid for claims from the 'Claim_Headers' table. The placeholders in the SELECT clause represent the total and average of the 'amount_paid' column.\",\n        \"virtual_table\": \"SELECT sum(amount_piad) ,  avg(amount_piad) FROM claim_headers\"\n    }\n}\n"}
{"sample_id": "train.1521", "db_id": "insurance_and_eClaims", "question": "What is the name of the customer who has made the minimum amount of payment in one claim?", "rationale": ["Identify the relevant tables: Customers, Policies, and Claim_Headers are needed to find the customer details and their claims.", "Join the Customers table with the Policies table on Customer_ID to link customers to their policies.", "Join the resulting table with the Claim_Headers table on Policy_ID to access claim information related to each customer.", "Use a subquery to find the minimum amount paid in claims from the Claim_Headers table.", "Filter the results to only include the customer(s) who have made a claim with the minimum amount paid."], "gold_sql": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)", "source_tables": ["policies", "customers", "claim_headers"], "pred_sql": "SELECT c.Customer_Details \nFROM Customers c \nJOIN Policies p ON c.Customer_ID = p.Customer_ID \nJOIN Claim_Headers ch ON p.Policy_ID = ch.Policy_ID \nWHERE ch.Amount_Piad = (SELECT MIN(Amount_Piad) FROM Claim_Headers)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total and average amounts paid for claims from the 'Claim_Headers' table. The placeholders in the SELECT clause represent the total and average of the 'amount_paid' column.\",\n        \"virtual_table\": \"SELECT sum(amount_piad) ,  avg(amount_piad) FROM claim_headers\"\n    }\n}\n"}
{"sample_id": "train.1531", "db_id": "insurance_and_eClaims", "question": "Find the names of the customers who have an deputy policy.", "rationale": ["Identify the relevant tables: Customers and Policies.", "Determine the relationship between the tables: Customers are linked to Policies through Customer_ID.", "Select the Customer_Details from the Customers table.", "Filter the results to include only those policies with a Policy_Type_Code of 'deputy'."], "gold_sql": "SELECT DISTINCT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.policy_type_code  =  'Deputy'", "source_tables": ["policies", "customers"], "pred_sql": "SELECT Customers.Customer_Details \nFROM Customers \nJOIN Policies ON Customers.Customer_ID = Policies.Customer_ID \nWHERE Policies.Policy_Type_Code = 'deputy';", "hint": "\n"}
{"sample_id": "train.1533", "db_id": "insurance_and_eClaims", "question": "Find the names of customers who either have an deputy policy or uniformed policy.", "rationale": ["Identify the relevant tables: Customers and Policies.", "Determine the relationship between the tables: Customers are linked to Policies through Customer_ID.", "Select the Customer_Details from the Customers table.", "Filter the results to include only those customers who have a Policy_Type_Code of either 'deputy' or 'uniformed'.", "Use DISTINCT to ensure that each customer's name appears only once in the results."], "gold_sql": "SELECT DISTINCT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.policy_type_code  =  'Deputy' OR t1.policy_type_code  =  'Uniform'", "source_tables": ["policies", "customers"], "pred_sql": "SELECT DISTINCT c.Customer_Details \nFROM Customers c \nJOIN Policies p ON c.Customer_ID = p.Customer_ID \nWHERE p.Policy_Type_Code IN ('deputy', 'uniformed');", "hint": "\n"}
{"sample_id": "train.1546", "db_id": "insurance_and_eClaims", "question": "Find the customer who started a policy most recently.", "rationale": ["Identify the relevant tables: Customers and Policies.", "We need to find the customer who started a policy most recently, so we will join the Customers table with the Policies table on the Customer_ID.", "We will order the results by the Start_Date of the policies in descending order to get the most recent policy first.", "Finally, we will limit the results to 1 to get only the most recent customer."], "gold_sql": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)", "source_tables": ["policies", "customers"], "pred_sql": "SELECT Customers.Customer_ID, Customers.Customer_Details \nFROM Customers \nJOIN Policies ON Customers.Customer_ID = Policies.Customer_ID \nORDER BY Policies.Start_Date DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.1553", "db_id": "customers_and_invoices", "question": "Show the id, the account name, and other account details for all accounts by the customer with first name 'Meaghan'.", "rationale": ["Identify the relevant tables: Accounts and Customers are needed to retrieve account information and filter by customer first name.", "Determine the columns to select: account_id, account_name, and other_account_details from the Accounts table.", "Establish the relationship between the tables: Use a JOIN to connect Accounts and Customers on customer_id.", "Apply the filter condition: Use a WHERE clause to filter for customers with the first name 'Meaghan'."], "gold_sql": "SELECT T1.account_id ,  T1.date_account_opened ,  T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  'Meaghan'", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT a.account_id, a.account_name, a.other_account_details \nFROM Accounts a \nJOIN Customers c ON a.customer_id = c.customer_id \nWHERE c.customer_first_name = 'Meaghan';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of unique customers who have opened accounts in the 'Accounts' table. The placeholder in the SELECT statement allows for potential filtering or additional conditions to be applied if needed.\",\n        \"virtual_table\": \"SELECT count(DISTINCT customer_id) FROM Accounts\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of financial transactions grouped by account ID from the 'Financial_Transactions' table. The placeholder in the SELECT clause represents the account ID for which the transaction count is being retrieved.\",\n        \"virtual_table\": \"SELECT count(*) ,  account_id FROM Financial_transactions\"\n    }\n}\n"}
{"sample_id": "train.1556", "db_id": "customers_and_invoices", "question": "What are the names and other details for accounts corresponding to the customer named Meaghan Keeling?", "rationale": ["Identify the relevant tables: Accounts and Customers are needed to get account details for a specific customer.", "Determine the relationship: The Accounts table has a foreign key (customer_id) that links to the Customers table.", "Select the required fields: We need account_id, date_account_opened, account_name, and other_account_details from the Accounts table.", "Filter the results: We need to filter the results based on the customer's first and last name, which are 'Meaghan' and 'Keeling' respectively.", "Construct the SQL query using JOIN to combine the Accounts and Customers tables based on the customer_id."], "gold_sql": "SELECT T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  'Meaghan' AND T2.customer_last_name  =  'Keeling'", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT a.account_id, a.date_account_opened, a.account_name, a.other_account_details \nFROM Accounts a \nJOIN Customers c ON a.customer_id = c.customer_id \nWHERE c.customer_first_name = 'Meaghan' AND c.customer_last_name = 'Keeling';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of unique customers who have opened accounts in the 'Accounts' table. The placeholder in the SELECT statement allows for potential filtering or additional conditions to be applied if needed.\",\n        \"virtual_table\": \"SELECT count(DISTINCT customer_id) FROM Accounts\"\n    }\n}\n"}
{"sample_id": "train.1558", "db_id": "customers_and_invoices", "question": "What are the full names of customers with the account name 900?", "rationale": ["Identify the relevant tables: Customers and Accounts.", "Determine the columns needed: full names (first and last) from Customers and account name from Accounts.", "Join the Customers table with the Accounts table on the customer_id field to link customers with their accounts.", "Filter the results to include only those accounts with the name '900'.", "Select the concatenated first and last names as the full name."], "gold_sql": "SELECT T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T1.account_name  =  '900'", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT customer_first_name || ' ' || customer_last_name AS full_name\nFROM Customers\nJOIN Accounts ON Customers.customer_id = Accounts.customer_id\nWHERE Accounts.account_name = '900';", "hint": "\n"}
{"sample_id": "train.1568", "db_id": "customers_and_invoices", "question": "Return the id and full name of the customer with the most accounts.", "rationale": ["Identify the relevant tables: Customers and Accounts.", "We need to join these tables on the customer_id to get customer details along with their accounts.", "Group the results by customer_id to count the number of accounts each customer has.", "Order the results by the count of accounts in descending order to find the customer with the most accounts.", "Limit the results to 1 to get only the top customer."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT c.customer_id, c.customer_first_name || ' ' || c.customer_last_name AS full_name\nFROM Customers c\nJOIN Accounts a ON c.customer_id = a.customer_id\nGROUP BY c.customer_id\nORDER BY COUNT(a.account_id) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of unique customers who have opened accounts in the 'Accounts' table. The placeholder in the SELECT statement allows for potential filtering or additional conditions to be applied if needed.\",\n        \"virtual_table\": \"SELECT count(DISTINCT customer_id) FROM Accounts\"\n    }\n}\n"}
{"sample_id": "train.1579", "db_id": "customers_and_invoices", "question": "How many transaction does each account have? Show the number and account id.", "rationale": ["The question asks for the number of transactions for each account, which indicates a need to count transactions grouped by account ID.", "The relevant table for transactions is 'Financial_Transactions', which contains the 'account_id' column.", "To get the count of transactions per account, we can use the COUNT() function and group the results by 'account_id'.", "The SQL query will select the count of transactions and the corresponding account ID, using GROUP BY to aggregate the results."], "gold_sql": "SELECT count(*) ,  account_id FROM Financial_transactions", "source_tables": ["financial_transactions"], "pred_sql": "SELECT COUNT(*) AS transaction_count, account_id FROM Financial_Transactions GROUP BY account_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of financial transactions grouped by account ID from the 'Financial_Transactions' table. The placeholder in the SELECT clause represents the account ID for which the transaction count is being retrieved.\",\n        \"virtual_table\": \"SELECT count(*) ,  account_id FROM Financial_transactions\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of unique customers who have opened accounts in the 'Accounts' table. The placeholder in the SELECT statement allows for potential filtering or additional conditions to be applied if needed.\",\n        \"virtual_table\": \"SELECT count(DISTINCT customer_id) FROM Accounts\"\n    }\n}\n"}
{"sample_id": "train.1589", "db_id": "customers_and_invoices", "question": "Show the account name, id and the number of transactions for each account.", "rationale": ["Identify the relevant tables: Accounts and Financial_Transactions.", "We need to retrieve the account name and account ID from the Accounts table.", "We also need to count the number of transactions associated with each account from the Financial_Transactions table.", "To get the count of transactions, we will use a LEFT JOIN to connect Accounts with Financial_Transactions on account_id.", "We will group the results by account_id and account_name to get the count of transactions for each account."], "gold_sql": "SELECT T2.account_name ,  T1.account_id ,  count(*) FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id GROUP BY T1.account_id", "source_tables": ["accounts", "financial_transactions"], "pred_sql": "SELECT a.account_name, a.account_id, COUNT(ft.transaction_id) AS number_of_transactions\nFROM Accounts a\nLEFT JOIN Financial_Transactions ft ON a.account_id = ft.account_id\nGROUP BY a.account_id, a.account_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of financial transactions grouped by account ID from the 'Financial_Transactions' table. The placeholder in the SELECT clause represents the account ID for which the transaction count is being retrieved.\",\n        \"virtual_table\": \"SELECT count(*) ,  account_id FROM Financial_transactions\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of unique customers who have opened accounts in the 'Accounts' table. The placeholder in the SELECT statement allows for potential filtering or additional conditions to be applied if needed.\",\n        \"virtual_table\": \"SELECT count(DISTINCT customer_id) FROM Accounts\"\n    }\n}\n"}
{"sample_id": "train.1599", "db_id": "customers_and_invoices", "question": "Show the invoice number and the number of transactions for each invoice.", "rationale": ["We need to show the invoice number and the number of transactions for each invoice.", "The relevant tables for this query are 'Financial_Transactions' and 'Invoices'.", "We will join these two tables on the invoice number, which is the common field between them.", "We will select the 'invoice_number' from the 'Invoices' table and count the 'transaction_id' from the 'Financial_Transactions' table to get the number of transactions for each invoice.", "Finally, we will group the results by 'invoice_number' to ensure we get a count for each unique invoice."], "gold_sql": "SELECT invoice_number ,  count(*) FROM Financial_transactions GROUP BY invoice_number", "source_tables": ["financial_transactions"], "pred_sql": "SELECT invoice_number, COUNT(transaction_id) AS number_of_transactions \nFROM Financial_Transactions \nJOIN Invoices ON Financial_Transactions.invoice_number = Invoices.invoice_number \nGROUP BY invoice_number;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of financial transactions grouped by account ID from the 'Financial_Transactions' table. The placeholder in the SELECT clause represents the account ID for which the transaction count is being retrieved.\",\n        \"virtual_table\": \"SELECT count(*) ,  account_id FROM Financial_transactions\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of unique customers who have opened accounts in the 'Accounts' table. The placeholder in the SELECT statement allows for potential filtering or additional conditions to be applied if needed.\",\n        \"virtual_table\": \"SELECT count(DISTINCT customer_id) FROM Accounts\"\n    }\n}\n"}
{"sample_id": "train.1602", "db_id": "customers_and_invoices", "question": "What is the invoice number and invoice date corresponding to the invoice with the greatest number of transactions?", "rationale": ["Identify the need to find the invoice number and date for the invoice with the greatest number of transactions.", "Understand that the number of transactions can be determined by counting the order items associated with each order.", "Use a subquery to group the order items by order_id and count them, ordering by the count in descending order to find the order with the most items.", "Limit the results of this subquery to 1 to get the order_id with the greatest number of transactions.", "Use this order_id to find the corresponding invoice number and date from the Invoices table."], "gold_sql": "SELECT T2.invoice_number ,  T2.invoice_date FROM Financial_transactions AS T1 JOIN Invoices AS T2 ON T1.invoice_number  =  T2.invoice_number GROUP BY T1.invoice_number ORDER BY count(*) DESC LIMIT 1", "source_tables": ["invoices", "financial_transactions"], "pred_sql": "SELECT invoice_number, invoice_date FROM Invoices WHERE order_id IN (SELECT order_id FROM Orders WHERE order_id IN (SELECT order_id FROM Order_Items GROUP BY order_id ORDER BY COUNT(*) DESC LIMIT 1))", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of financial transactions grouped by account ID from the 'Financial_Transactions' table. The placeholder in the SELECT clause represents the account ID for which the transaction count is being retrieved.\",\n        \"virtual_table\": \"SELECT count(*) ,  account_id FROM Financial_transactions\"\n    }\n}\n"}
{"sample_id": "train.1617", "db_id": "customers_and_invoices", "question": "Show the order ids and the number of items in each order.", "rationale": ["Identify the tables needed: We need data from the Orders table for order ids and the Order_Items table to count the number of items in each order.", "Use a LEFT JOIN to combine Orders and Order_Items on the order_id, ensuring we get all orders even if they have no items.", "Use COUNT() to count the number of items in each order, grouping the results by order_id to get the count for each specific order."], "gold_sql": "SELECT order_id ,  count(*) FROM Order_items GROUP BY order_id", "source_tables": ["order_items"], "pred_sql": "SELECT Orders.order_id, COUNT(Order_Items.order_item_id) AS number_of_items\nFROM Orders\nLEFT JOIN Order_Items ON Orders.order_id = Order_Items.order_id\nGROUP BY Orders.order_id;", "hint": "\n"}
{"sample_id": "train.2049", "db_id": "party_people", "question": "Show all ministers who do not belong to Progress Party.", "rationale": ["Identify the relevant table: The 'party' table contains information about political parties and their associated ministers.", "Determine the required information: We need to select the 'Minister' column from the 'party' table.", "Apply the condition: We want to exclude ministers who belong to the 'Progress Party'.", "Construct the SQL query: Use a SELECT statement to retrieve the 'Minister' from the 'party' table where the 'Party_name' is not 'Progress Party'."], "gold_sql": "SELECT minister FROM party WHERE party_name != 'Progress Party'", "source_tables": ["party"], "pred_sql": "SELECT minister FROM party WHERE Party_name != 'Progress Party'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the ministers associated with political parties from the 'party' table, excluding a specific party name. The placeholder in the WHERE clause represents the name of the party to be excluded.\",\n        \"virtual_table\": \"SELECT minister FROM party WHERE party_name != [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2058", "db_id": "party_people", "question": "How many members are in each party?", "rationale": ["We need to count the number of members in each party.", "To do this, we will select the party name from the 'party' table.", "We will join the 'member' table to the 'party' table using the Party_ID as the foreign key.", "We will use a LEFT JOIN to ensure we include parties even if they have no members.", "We will group the results by party name to get the count of members for each party.", "Finally, we will use COUNT() to count the number of members associated with each party."], "gold_sql": "SELECT T2.party_name ,  count(*) FROM Member AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id", "source_tables": ["party", "member"], "pred_sql": "SELECT party.Party_name, COUNT(member.Member_ID) AS Member_Count\nFROM party\nLEFT JOIN member ON party.Party_ID = member.Party_ID\nGROUP BY party.Party_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the ministers associated with political parties from the 'party' table, excluding a specific party name. The placeholder in the WHERE clause represents the name of the party to be excluded.\",\n        \"virtual_table\": \"SELECT minister FROM party WHERE party_name != [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2071", "db_id": "party_people", "question": "Show party names and the number of events for each party.", "rationale": ["Identify the tables needed: We need data from the 'party' table for party names and the 'party_events' table for counting events.", "Use a LEFT JOIN to combine the 'party' table with the 'party_events' table on the Party_ID, ensuring we include all parties even if they have no events.", "Select the Party_name from the 'party' table and count the Event_ID from the 'party_events' table to get the number of events for each party.", "Group the results by Party_name to aggregate the event counts for each party."], "gold_sql": "SELECT T2.party_name ,  count(*) FROM party_events AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id", "source_tables": ["party", "party_events"], "pred_sql": "SELECT p.Party_name, COUNT(pe.Event_ID) AS Number_of_Events\nFROM party p\nLEFT JOIN party_events pe ON p.Party_ID = pe.Party_ID\nGROUP BY p.Party_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the ministers associated with political parties from the 'party' table, excluding a specific party name. The placeholder in the WHERE clause represents the name of the party to be excluded.\",\n        \"virtual_table\": \"SELECT minister FROM party WHERE party_name != [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2081", "db_id": "party_people", "question": "How many Annual Meeting events happened in the United Kingdom region?", "rationale": ["Identify the relevant tables: party_events, party, and region.", "We need to count the number of events, so we will use the COUNT() function.", "Join the party_events table with the party table on Party_ID to link events to their respective parties.", "Join the party table with the region table on Region_ID to filter events by region.", "Add a WHERE clause to filter for events named 'Annual Meeting' and for the region named 'United Kingdom'.", "Select the count of these filtered events."], "gold_sql": "SELECT count(*) FROM region AS t1 JOIN party AS t2 ON t1.region_id  =  t2.region_id JOIN party_events AS t3 ON t2.party_id  =  t3.party_id WHERE t1.region_name  =  'United Kingdom' AND t3.Event_Name  =  'Annaual Meeting'", "source_tables": ["party", "party_events", "region"], "pred_sql": "SELECT COUNT(*) AS Annual_Meeting_Count\nFROM party_events pe\nJOIN party p ON pe.Party_ID = p.Party_ID\nJOIN region r ON p.Region_ID = r.Region_ID\nWHERE pe.Event_Name = 'Annual Meeting' AND r.Region_name = 'United Kingdom';", "hint": "\n"}
{"sample_id": "train.2176", "db_id": "formula_1", "question": "What are the names and years of all races that had a driver with the last name Lewis?", "rationale": ["Identify the relevant tables: races, results, and drivers are needed to answer the question.", "We need to retrieve the names and years of races, so we will select 'races.name' and 'races.year'.", "To find races that had a driver with the last name 'Lewis', we need to join the 'races' table with the 'results' table on 'raceId', and then join the 'results' table with the 'drivers' table on 'driverId'.", "The condition to filter the results is that the driver's surname must be 'Lewis'.", "Construct the SQL query using the selected columns and the necessary joins with the appropriate WHERE clause."], "gold_sql": "SELECT T2.name ,  T2.year FROM results AS T1 JOIN races AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T1.driverid = T3.driverid WHERE T3.forename = 'Lewis'", "source_tables": ["results", "drivers", "races"], "pred_sql": "SELECT races.name, races.year FROM races JOIN results ON races.raceId = results.raceId JOIN drivers ON results.driverId = drivers.driverId WHERE drivers.surname = 'Lewis';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of drivers along with their surnames from the 'drivers' table, ordered by their lap times recorded in the 'lapTimes' table. The results are limited to a specified number of entries, represented by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of drivers along with their surnames from the 'drivers' table, ordered by their lap times recorded in the 'lapTimes' table. The placeholder in the LIMIT clause allows the user to specify the number of top results to retrieve based on the fastest lap times.\",\n        \"virtual_table\": \"SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a distinct list of race names from the 'races' table, sorted in descending order. The placeholder in the ORDER BY clause indicates that the results will be organized based on the race names.\",\n        \"virtual_table\": \"SELECT DISTINCT name FROM races ORDER BY name DESC\"\n    }\n}\n"}
{"sample_id": "train.2182", "db_id": "formula_1", "question": "What are the first and last names of all drivers who participated in the Australian Grand Prix but not the Chinese Grand Prix?", "rationale": ["Identify the tables needed: We need the 'drivers' table to get driver names and the 'results' and 'races' tables to filter by race participation.", "Join the 'drivers' table with the 'results' table to link drivers to their race results.", "Join the 'results' table with the 'races' table to filter for the Australian Grand Prix.", "Use a subquery to find drivers who participated in the Chinese Grand Prix and exclude them from the main query results.", "Select the first and last names of drivers who participated in the Australian Grand Prix but not in the Chinese Grand Prix."], "gold_sql": "SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Australian Grand Prix' EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Chinese Grand Prix'", "source_tables": ["races", "drivers", "results"], "pred_sql": "SELECT d.forename, d.surname \nFROM drivers d \nJOIN results r1 ON d.driverId = r1.driverId \nJOIN races ra ON r1.raceId = ra.raceId \nWHERE ra.name = 'Australian Grand Prix' \nAND d.driverId NOT IN (\n    SELECT d2.driverId \n    FROM drivers d2 \n    JOIN results r2 ON d2.driverId = r2.driverId \n    JOIN races rb ON r2.raceId = rb.raceId \n    WHERE rb.name = 'Chinese Grand Prix'\n);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of drivers along with their surnames from the 'drivers' table, ordered by their lap times recorded in the 'lapTimes' table. The results are limited to a specified number of entries, represented by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of drivers along with their surnames from the 'drivers' table, ordered by their lap times recorded in the 'lapTimes' table. The placeholder in the LIMIT clause allows the user to specify the number of top results to retrieve based on the fastest lap times.\",\n        \"virtual_table\": \"SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2183", "db_id": "formula_1", "question": "Find all the forenames of distinct drivers who was in position 1 as standing and won?", "rationale": ["We need to find distinct drivers who were in position 1 as standing and also won races.", "To do this, we will use the 'drivers' table to get the forenames of the drivers.", "We will join the 'drivers' table with the 'driverStandings' table on the driverId to access the standings information.", "We will filter the results where the position is 1 (indicating they finished first in the standings) and also check that the wins are greater than 0 (indicating they have won races).", "Finally, we will select distinct forenames to ensure there are no duplicates."], "gold_sql": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = 1 AND T2.wins = 1", "source_tables": ["drivers", "driverstandings"], "pred_sql": "SELECT DISTINCT d.forename \nFROM drivers d \nJOIN driverStandings ds ON d.driverId = ds.driverId \nWHERE ds.position = 1 AND ds.wins > 0;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of drivers along with their surnames from the 'drivers' table, ordered by their lap times recorded in the 'lapTimes' table. The results are limited to a specified number of entries, represented by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of drivers along with their surnames from the 'drivers' table, ordered by their lap times recorded in the 'lapTimes' table. The placeholder in the LIMIT clause allows the user to specify the number of top results to retrieve based on the fastest lap times.\",\n        \"virtual_table\": \"SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2185", "db_id": "formula_1", "question": "Find all the forenames of distinct drivers who won in position 1 as driver standing and had more than 20 points?", "rationale": ["We need to find distinct drivers who won in position 1 as per driver standings and had more than 20 points.", "To achieve this, we will select the 'forename' from the 'drivers' table.", "We will join the 'drivers' table with the 'driverStandings' table on the 'driverId' to get the standings of each driver.", "We will filter the results where the 'position' in the standings is 1 and the 'points' are greater than 20.", "Using DISTINCT ensures that we only get unique forenames of the drivers."], "gold_sql": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = 1 AND T2.wins = 1 AND T2.points > 20", "source_tables": ["drivers", "driverstandings"], "pred_sql": "SELECT DISTINCT d.forename \nFROM drivers d \nJOIN driverStandings ds ON d.driverId = ds.driverId \nWHERE ds.position = 1 AND ds.points > 20;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of drivers along with their surnames from the 'drivers' table, ordered by their lap times recorded in the 'lapTimes' table. The results are limited to a specified number of entries, represented by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of drivers along with their surnames from the 'drivers' table, ordered by their lap times recorded in the 'lapTimes' table. The placeholder in the LIMIT clause allows the user to specify the number of top results to retrieve based on the fastest lap times.\",\n        \"virtual_table\": \"SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2186", "db_id": "formula_1", "question": "What are the first names of the different drivers who won in position 1 as driver standing and had more than 20 points?", "rationale": ["Identify the relevant tables: drivers and driverStandings.", "We need the first names of drivers, so we will select the 'forename' column from the drivers table.", "We need to join the drivers table with the driverStandings table to access the standings of the drivers.", "We filter the results to include only those drivers who have a finishing position of 1 (indicating they won) and have more than 20 points in the standings.", "Using DISTINCT ensures that we only get unique first names of the drivers."], "gold_sql": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = 1 AND T2.wins = 1 AND T2.points > 20", "source_tables": ["drivers", "driverstandings"], "pred_sql": "SELECT DISTINCT d.forename \nFROM drivers d \nJOIN driverStandings ds ON d.driverId = ds.driverId \nWHERE ds.position = 1 AND ds.points > 20;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of drivers along with their surnames from the 'drivers' table, ordered by their lap times recorded in the 'lapTimes' table. The results are limited to a specified number of entries, represented by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of drivers along with their surnames from the 'drivers' table, ordered by their lap times recorded in the 'lapTimes' table. The placeholder in the LIMIT clause allows the user to specify the number of top results to retrieve based on the fastest lap times.\",\n        \"virtual_table\": \"SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2189", "db_id": "formula_1", "question": "What are the numbers of races for each constructor id?", "rationale": ["To find the number of races for each constructor, we need to count the occurrences of each constructor's ID in the results of the races.", "The relevant table for this information is 'constructorResults', which links constructors to races.", "We will use the COUNT() function to count the number of races associated with each constructorId.", "We will group the results by constructorId to get the count for each constructor."], "gold_sql": "SELECT count(*) ,  constructorid FROM constructorStandings GROUP BY constructorid", "source_tables": ["constructorstandings"], "pred_sql": "SELECT constructorId, COUNT(raceId) AS number_of_races \nFROM constructorResults \nGROUP BY constructorId;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a distinct list of race names from the 'races' table, sorted in descending order. The placeholder in the ORDER BY clause indicates that the results will be organized based on the race names.\",\n        \"virtual_table\": \"SELECT DISTINCT name FROM races ORDER BY name DESC\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of drivers along with their surnames from the 'drivers' table, ordered by their lap times recorded in the 'lapTimes' table. The results are limited to a specified number of entries, represented by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2218", "db_id": "formula_1", "question": "What are the names of all the Japanese constructors that have earned more than 5 points?", "rationale": ["Identify the relevant table: We need to look at the 'constructors' table to find the names of constructors and their nationality.", "Filter by nationality: We want only those constructors that are Japanese, so we will add a WHERE clause to filter by 'nationality = 'Japanese'\".", "Determine points earned: We need to check the points earned by each constructor, which is found in the 'constructorResults' table.", "Group by constructorId: To find the total points for each constructor, we will group the results by 'constructorId'.", "Use HAVING clause: We will use a HAVING clause to filter those constructors who have earned more than 5 points.", "Combine results: We will use a subquery to combine the results from the 'constructors' table and the aggregated points from the 'constructorResults' table."], "gold_sql": "SELECT T1.name FROM constructors AS T1 JOIN constructorstandings AS T2 ON T1.constructorid = T2.constructorid WHERE T1.nationality = 'Japanese' AND T2.points > 5", "source_tables": ["constructorstandings", "constructors"], "pred_sql": "SELECT name FROM constructors WHERE nationality = 'Japanese' AND constructorId IN (SELECT constructorId FROM constructorResults GROUP BY constructorId HAVING SUM(points) > 5);", "hint": "\n"}
{"sample_id": "train.2220", "db_id": "formula_1", "question": "What is the average fastest lap speed for the Monaco Grand Prix in 2008?", "rationale": ["Identify the relevant tables: 'races' for race details and 'results' for fastest lap speeds.", "Join the 'races' table with the 'results' table on the raceId to correlate race details with results.", "Filter the results for the specific year (2008) and the specific race name ('Monaco Grand Prix').", "Use the AVG function to calculate the average of the fastest lap speeds from the results table."], "gold_sql": "SELECT avg(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "pred_sql": "SELECT avg(T2.fastestLapSpeed) FROM races AS T1 JOIN results AS T2 ON T1.raceId = T2.raceId WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average fastest lap speed from the 'results' table for races that occurred in a specific year and have a particular name. The placeholders in the WHERE clause represent the year of the race and the name of the race.\",\n        \"virtual_table\": \"SELECT avg(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of drivers along with their surnames from the 'drivers' table, ordered by their lap times recorded in the 'lapTimes' table. The placeholder in the LIMIT clause allows the user to specify the number of top results to retrieve based on the fastest lap times.\",\n        \"virtual_table\": \"SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of drivers along with their surnames from the 'drivers' table, ordered by their lap times recorded in the 'lapTimes' table. The results are limited to a specified number of entries, represented by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2221", "db_id": "formula_1", "question": "What is the maximum fastest lap speed in race named 'Monaco Grand Prix' in 2008 ?", "rationale": ["Identify the relevant tables: 'races' for race details and 'results' for fastest lap speeds.", "Join the 'races' table with the 'results' table on the raceId to correlate race details with results.", "Filter the results for the specific race name 'Monaco Grand Prix' and the year 2008.", "Use the MAX function to find the maximum fastest lap speed from the filtered results."], "gold_sql": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "pred_sql": "SELECT MAX(T2.fastestLapSpeed) FROM races AS T1 JOIN results AS T2 ON T1.raceId = T2.raceId WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average fastest lap speed from the 'results' table for races that occurred in a specific year and have a particular name. The placeholders in the WHERE clause represent the year of the race and the name of the race.\",\n        \"virtual_table\": \"SELECT avg(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of drivers along with their surnames from the 'drivers' table, ordered by their lap times recorded in the 'lapTimes' table. The placeholder in the LIMIT clause allows the user to specify the number of top results to retrieve based on the fastest lap times.\",\n        \"virtual_table\": \"SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of drivers along with their surnames from the 'drivers' table, ordered by their lap times recorded in the 'lapTimes' table. The results are limited to a specified number of entries, represented by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2222", "db_id": "formula_1", "question": "What is the maximum fastest lap speed in the Monaco Grand Prix in 2008?", "rationale": ["Identify the relevant tables: 'races' for race details and 'results' for fastest lap speeds.", "Join the 'races' table with the 'results' table on the raceId to correlate race details with results.", "Filter the results for the year 2008 and the race name 'Monaco Grand Prix'.", "Select the maximum fastest lap speed from the filtered results."], "gold_sql": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "pred_sql": "SELECT MAX(T2.fastestLapSpeed) FROM races AS T1 JOIN results AS T2 ON T1.raceId = T2.raceId WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average fastest lap speed from the 'results' table for races that occurred in a specific year and have a particular name. The placeholders in the WHERE clause represent the year of the race and the name of the race.\",\n        \"virtual_table\": \"SELECT avg(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of drivers along with their surnames from the 'drivers' table, ordered by their lap times recorded in the 'lapTimes' table. The placeholder in the LIMIT clause allows the user to specify the number of top results to retrieve based on the fastest lap times.\",\n        \"virtual_table\": \"SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of drivers along with their surnames from the 'drivers' table, ordered by their lap times recorded in the 'lapTimes' table. The results are limited to a specified number of entries, represented by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2224", "db_id": "formula_1", "question": "For each race name, What is the maximum fastest lap speed for races after 2004 ordered by year?", "rationale": ["Identify the relevant tables: 'races' for race names and years, and 'results' for fastest lap speeds.", "Join the 'races' table with the 'results' table on the raceId to access both race names and their corresponding fastest lap speeds.", "Filter the results to include only races that occurred after the year 2004.", "Group the results by race name to calculate the maximum fastest lap speed for each race.", "Select the race name and the maximum fastest lap speed, ordering the final results by year."], "gold_sql": "SELECT max(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "pred_sql": "SELECT T1.name, MAX(T2.fastestLapSpeed) AS max_fastest_lap_speed \nFROM races AS T1 \nJOIN results AS T2 ON T1.raceId = T2.raceId \nWHERE T1.year > 2004 \nGROUP BY T1.name \nORDER BY T1.year;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average fastest lap speed from the 'results' table for races that occurred in a specific year and have a particular name. The placeholders in the WHERE clause represent the year of the race and the name of the race.\",\n        \"virtual_table\": \"SELECT avg(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of drivers along with their surnames from the 'drivers' table, ordered by their lap times recorded in the 'lapTimes' table. The placeholder in the LIMIT clause allows the user to specify the number of top results to retrieve based on the fastest lap times.\",\n        \"virtual_table\": \"SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of drivers along with their surnames from the 'drivers' table, ordered by their lap times recorded in the 'lapTimes' table. The results are limited to a specified number of entries, represented by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2225", "db_id": "formula_1", "question": "What are the average fastest lap speed in races held after 2004 grouped by race name and ordered by year?", "rationale": ["Identify the relevant tables: 'races' for race details and 'results' for fastest lap speeds.", "Join the 'races' table with the 'results' table on the raceId to correlate races with their results.", "Filter the results to include only races that occurred after the year 2004 using the WHERE clause.", "Group the results by the race name to calculate the average fastest lap speed for each race.", "Use the AVG function to calculate the average fastest lap speed from the 'results' table.", "Order the final results by the year of the races."], "gold_sql": "SELECT avg(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "pred_sql": "SELECT T1.name, AVG(T2.fastestLapSpeed) AS average_fastest_lap_speed \nFROM races AS T1 \nJOIN results AS T2 ON T1.raceId = T2.raceId \nWHERE T1.year > 2004 \nGROUP BY T1.name \nORDER BY T1.year;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average fastest lap speed from the 'results' table for races that occurred in a specific year and have a particular name. The placeholders in the WHERE clause represent the year of the race and the name of the race.\",\n        \"virtual_table\": \"SELECT avg(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of drivers along with their surnames from the 'drivers' table, ordered by their lap times recorded in the 'lapTimes' table. The placeholder in the LIMIT clause allows the user to specify the number of top results to retrieve based on the fastest lap times.\",\n        \"virtual_table\": \"SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of drivers along with their surnames from the 'drivers' table, ordered by their lap times recorded in the 'lapTimes' table. The results are limited to a specified number of entries, represented by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2226", "db_id": "formula_1", "question": "What is the average fastest lap speed for races held after 2004, for each race, ordered by year?", "rationale": ["Identify the relevant tables: 'races' for race years and 'results' for fastest lap speeds.", "Join the 'races' table with the 'results' table on the raceId to correlate races with their results.", "Filter the results to include only races held after the year 2004 using the WHERE clause.", "Group the results by year to calculate the average fastest lap speed for each year.", "Use the AVG function to calculate the average fastest lap speed for each race year.", "Order the final results by year to present them in chronological order."], "gold_sql": "SELECT avg(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "pred_sql": "SELECT T1.year, avg(T2.fastestLapSpeed) AS average_fastest_lap_speed \nFROM races AS T1 \nJOIN results AS T2 ON T1.raceId = T2.raceId \nWHERE T1.year > 2004 \nGROUP BY T1.year \nORDER BY T1.year;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average fastest lap speed from the 'results' table for races that occurred in a specific year and have a particular name. The placeholders in the WHERE clause represent the year of the race and the name of the race.\",\n        \"virtual_table\": \"SELECT avg(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of drivers along with their surnames from the 'drivers' table, ordered by their lap times recorded in the 'lapTimes' table. The placeholder in the LIMIT clause allows the user to specify the number of top results to retrieve based on the fastest lap times.\",\n        \"virtual_table\": \"SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of drivers along with their surnames from the 'drivers' table, ordered by their lap times recorded in the 'lapTimes' table. The results are limited to a specified number of entries, represented by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2243", "db_id": "machine_repair", "question": "What is the starting year of the oldest technicians?", "rationale": ["Identify the relevant table: The question pertains to technicians, so we will use the 'technician' table.", "Determine the required information: We need the starting year of the oldest technician.", "To find the oldest technician, we should order the technicians by age in ascending order (oldest first).", "We will use the ORDER BY clause to sort by 'Age' and the LIMIT clause to return only the first record, which will be the oldest technician's starting year."], "gold_sql": "SELECT Starting_Year FROM technician ORDER BY Age DESC LIMIT 1", "source_tables": ["technician"], "pred_sql": "SELECT Starting_Year FROM technician ORDER BY Age ASC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the starting years of technicians from the 'technician' table, ordered by their age in descending order. The placeholder in the LIMIT clause represents the maximum number of records to return.\",\n        \"virtual_table\": \"SELECT Starting_Year FROM technician ORDER BY Age DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2248", "db_id": "machine_repair", "question": "What are the teams with the most technicians?", "rationale": ["Identify the relevant table: The 'technician' table contains information about technicians and their teams.", "Determine the required information: We need to count the number of technicians in each team.", "Use the COUNT() function to count technicians grouped by their team.", "Group the results by the 'Team' column to aggregate the counts.", "Order the results in descending order to find the teams with the most technicians."], "gold_sql": "SELECT Team FROM technician GROUP BY Team ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["technician"], "pred_sql": "SELECT Team, COUNT(technician_id) AS technician_count \nFROM technician \nGROUP BY Team \nORDER BY technician_count DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the starting years of technicians from the 'technician' table, ordered by their age in descending order. The placeholder in the LIMIT clause represents the maximum number of records to return.\",\n        \"virtual_table\": \"SELECT Starting_Year FROM technician ORDER BY Age DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2258", "db_id": "machine_repair", "question": "What are the names of the technicians  and how many machines are they assigned to repair?", "rationale": ["Identify the relevant tables: technician and repair_assignment.", "We need the names of technicians, which are in the technician table.", "We also need to count the number of machines assigned to each technician, which can be found in the repair_assignment table.", "To get the count of machines, we will use the COUNT() function and group the results by technician name.", "We will perform a LEFT JOIN between the technician table and the repair_assignment table on the technician_id to ensure we get all technicians, even those with no assigned machines.", "Finally, we will select the technician's name and the count of machines assigned to them."], "gold_sql": "SELECT T2.Name ,  COUNT(*) FROM repair_assignment AS T1 JOIN technician AS T2 ON T1.technician_ID  =  T2.technician_ID GROUP BY T2.Name", "source_tables": ["repair_assignment", "technician"], "pred_sql": "SELECT technician.Name, COUNT(repair_assignment.Machine_ID) AS machine_count\nFROM technician\nLEFT JOIN repair_assignment ON technician.technician_id = repair_assignment.technician_id\nGROUP BY technician.Name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the starting years of technicians from the 'technician' table, ordered by their age in descending order. The placeholder in the LIMIT clause represents the maximum number of records to return.\",\n        \"virtual_table\": \"SELECT Starting_Year FROM technician ORDER BY Age DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2328", "db_id": "csu_1", "question": "Find all the campuses opened in 1958.", "rationale": ["Identify the relevant table: The question asks about campuses, which are listed in the 'Campuses' table.", "Determine the filtering criteria: The question specifies campuses opened in the year 1958, which corresponds to the 'Year' column in the 'Campuses' table.", "Construct the SQL query: Use a SELECT statement to retrieve all columns from the 'Campuses' table where the 'Year' is '1958'."], "gold_sql": "SELECT campus FROM campuses WHERE YEAR  =  1958", "source_tables": ["campuses"], "pred_sql": "SELECT * FROM Campuses WHERE Year = '1958';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the campuses from the 'Campuses' table that are located in a specific geographical location. The placeholder in the WHERE clause represents the location of interest.\",\n        \"virtual_table\": \"SELECT campus FROM campuses WHERE LOCATION  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the campuses located in a specific county from the 'Campuses' table. The placeholder in the WHERE clause represents the name of the county.\",\n        \"virtual_table\": \"SELECT campus FROM campuses WHERE county  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of campuses from the 'Campuses' table that are located in a specific county. The placeholder in the WHERE clause represents the name of the county.\",\n        \"virtual_table\": \"SELECT campus FROM campuses WHERE county  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2334", "db_id": "csu_1", "question": "Find the name of the campuses that is in Northridge, Los Angeles or in San Francisco, San Francisco.", "rationale": ["Identify the relevant table: The 'Campuses' table contains the information about campus names and their locations.", "Determine the filtering criteria: The user is interested in campuses located in either 'Northridge, Los Angeles' or 'San Francisco, San Francisco'.", "Construct the SQL query: Use a SELECT statement to retrieve the 'Campus' column from the 'Campuses' table, applying a WHERE clause to filter for the specified locations using the OR operator."], "gold_sql": "SELECT campus FROM campuses WHERE LOCATION  =  'Northridge' AND county  =  'Los Angeles' UNION SELECT campus FROM campuses WHERE LOCATION  =  'San Francisco' AND county  =  'San Francisco'", "source_tables": ["campuses"], "pred_sql": "SELECT Campus FROM Campuses WHERE Location = 'Northridge, Los Angeles' OR Location = 'San Francisco, San Francisco';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the campuses from the 'Campuses' table that are located in a specific geographical location. The placeholder in the WHERE clause represents the location of interest.\",\n        \"virtual_table\": \"SELECT campus FROM campuses WHERE LOCATION  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of campuses from the 'Campuses' table that are located in a specific county. The placeholder in the WHERE clause represents the name of the county.\",\n        \"virtual_table\": \"SELECT campus FROM campuses WHERE county  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the campuses located in a specific county from the 'Campuses' table. The placeholder in the WHERE clause represents the name of the county.\",\n        \"virtual_table\": \"SELECT campus FROM campuses WHERE county  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2350", "db_id": "csu_1", "question": "Which campus has the most faculties in year 2003?", "rationale": ["Identify the relevant table: The 'faculty' table contains the number of faculty members associated with each campus for different years.", "Specify the year of interest: We are looking for data from the year 2003, so we will filter the results based on this year.", "Select the campus and faculty count: We need to retrieve the campus name and the number of faculty members.", "Order the results: To find the campus with the most faculty, we will order the results in descending order based on the faculty count.", "Limit the results: Since we only need the campus with the highest number of faculty, we will limit the results to 1."], "gold_sql": "SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  2003 ORDER BY T2.faculty DESC LIMIT 1", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT Campus, Faculty FROM faculty WHERE Year = 2003 ORDER BY Faculty DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the types of degrees awarded at a specific campus during a particular year. The placeholders in the WHERE clause represent the campus name and the year of the degrees awarded.\",\n        \"virtual_table\": \"SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  [PLACEHOLDER-TYPE:STRING] AND t2.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the campuses from the 'Campuses' table that are located in a specific geographical location. The placeholder in the WHERE clause represents the location of interest.\",\n        \"virtual_table\": \"SELECT campus FROM campuses WHERE LOCATION  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the campuses located in a specific county from the 'Campuses' table. The placeholder in the WHERE clause represents the name of the county.\",\n        \"virtual_table\": \"SELECT campus FROM campuses WHERE county  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2356", "db_id": "csu_1", "question": "report the total number of degrees granted between 1998 and 2002.", "rationale": ["Identify the relevant table: The 'degrees' table contains information about degrees awarded, including the year and the number of degrees.", "Determine the required data: We need to sum the total number of degrees awarded between the years 1998 and 2002.", "Construct the SQL query: Use the SUM function to calculate the total degrees and filter the results using a WHERE clause to specify the year range."], "gold_sql": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  1998 AND T2.year  <=  2002 GROUP BY T1.campus", "source_tables": ["degrees", "campuses"], "pred_sql": "SELECT SUM(Degrees) AS TotalDegrees\nFROM degrees\nWHERE Year BETWEEN '1998' AND '2002';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the years in which degrees were awarded, grouped by year and ordered by the total number of degrees awarded in descending order. The placeholder in the LIMIT clause represents the maximum number of years to return.\",\n        \"virtual_table\": \"SELECT YEAR FROM degrees GROUP BY YEAR ORDER BY sum(degrees) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the types of degrees awarded at a specific campus during a particular year. The placeholders in the WHERE clause represent the campus name and the year of the degrees awarded.\",\n        \"virtual_table\": \"SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  [PLACEHOLDER-TYPE:STRING] AND t2.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2359", "db_id": "csu_1", "question": "What is the total number of degrees granted after 2000 for each Orange county campus?", "rationale": ["Identify the relevant tables: Campuses and degrees.", "We need to count the total number of degrees granted after the year 2000, so we will use the degrees table for this.", "We need to filter the campuses to only those located in Orange County, which is done using the Campuses table.", "Join the Campuses table with the degrees table on the campus identifier to link campuses with their awarded degrees.", "Apply the condition to filter degrees awarded after the year 2000.", "Group the results by campus to get the total count of degrees for each campus."], "gold_sql": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  'Orange' AND T2.year  >=  2000 GROUP BY T1.campus", "source_tables": ["degrees", "campuses"], "pred_sql": "SELECT c.Campus, COUNT(d.Degrees) AS TotalDegrees\nFROM Campuses c\nJOIN degrees d ON c.Id = d.Campus\nWHERE c.County = 'Orange' AND d.Year > '2000'\nGROUP BY c.Campus;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the types of degrees awarded at a specific campus during a particular year. The placeholders in the WHERE clause represent the campus name and the year of the degrees awarded.\",\n        \"virtual_table\": \"SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  [PLACEHOLDER-TYPE:STRING] AND t2.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the years in which degrees were awarded, grouped by year and ordered by the total number of degrees awarded in descending order. The placeholder in the LIMIT clause represents the maximum number of years to return.\",\n        \"virtual_table\": \"SELECT YEAR FROM degrees GROUP BY YEAR ORDER BY sum(degrees) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the total count of campuses located in a specific county from the 'Campuses' table. The placeholder in the WHERE clause represents the name of the county.\",\n        \"virtual_table\": \"SELECT count(*) FROM campuses WHERE county  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2362", "db_id": "csu_1", "question": "What campus had more than 400 total enrollment but more than 200 full time enrollment in year 1956?", "rationale": ["Identify the relevant table for total enrollments, which is the 'enrollments' table.", "We need to filter the results based on the year 1956, so we will include a WHERE clause for Year = '1956'.", "Next, we need to apply the condition for total enrollment being greater than 400, which will be included in the WHERE clause as TotalEnrollment_AY > 400.", "We also need to check that the full-time equivalent enrollment is greater than 200, so we will add another condition in the WHERE clause as FTE_AY > 200.", "Finally, we will select the 'Campus' column from the 'enrollments' table that meets all these conditions."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN enrollments AS t2 ON t1.id  =  t2.campus WHERE t2.year  =  1956 AND totalenrollment_ay  >  400 AND FTE_AY  >  200", "source_tables": ["enrollments", "campuses"], "pred_sql": "SELECT Campus FROM enrollments WHERE Year = '1956' AND TotalEnrollment_AY > 400 AND FTE_AY > 200;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total number of graduate enrollments from the 'discipline_enrollments' table for a specific campus and year. The placeholders in the WHERE clause represent the year of enrollment and the name of the campus.\",\n        \"virtual_table\": \"SELECT sum(t1.graduate) FROM discipline_enrollments AS t1 JOIN campuses AS t2 ON t1.campus  =  t2.id WHERE t1.year  =  [PLACEHOLDER-TYPE:NUMBER] AND t2.campus  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the types of degrees awarded at a specific campus during a particular year. The placeholders in the WHERE clause represent the campus name and the year of the degrees awarded.\",\n        \"virtual_table\": \"SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  [PLACEHOLDER-TYPE:STRING] AND t2.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the campuses located in a specific county from the 'Campuses' table. The placeholder in the WHERE clause represents the name of the county.\",\n        \"virtual_table\": \"SELECT campus FROM campuses WHERE county  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2363", "db_id": "csu_1", "question": "What campus started in year 1956, has more than 200 full time students, and more than 400 students enrolled?", "rationale": ["Identify the relevant tables: Campuses and enrollments are needed to answer the question.", "We need to filter campuses based on the year they started, which is represented in the Campuses table under the 'Year' column.", "We also need to check for campuses with more than 200 full-time students, which corresponds to the 'FTE_AY' column in the enrollments table.", "Additionally, we need to ensure that the total enrollment is more than 400, which is represented by the 'TotalEnrollment_AY' column in the enrollments table.", "The SQL query will join the Campuses table with the enrollments table on the campus identifier, and apply the necessary filters for year, FTE, and total enrollment."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN enrollments AS t2 ON t1.id  =  t2.campus WHERE t2.year  =  1956 AND totalenrollment_ay  >  400 AND FTE_AY  >  200", "source_tables": ["enrollments", "campuses"], "pred_sql": "SELECT c.Campus \nFROM Campuses c \nJOIN enrollments e ON c.Id = e.Campus \nWHERE c.Year = '1956' \nAND e.FTE_AY > '200' \nAND e.TotalEnrollment_AY > '400';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the types of degrees awarded at a specific campus during a particular year. The placeholders in the WHERE clause represent the campus name and the year of the degrees awarded.\",\n        \"virtual_table\": \"SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  [PLACEHOLDER-TYPE:STRING] AND t2.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the total number of graduate enrollments from the 'discipline_enrollments' table for a specific campus and year. The placeholders in the WHERE clause represent the year of enrollment and the name of the campus.\",\n        \"virtual_table\": \"SELECT sum(t1.graduate) FROM discipline_enrollments AS t1 JOIN campuses AS t2 ON t1.campus  =  t2.id WHERE t1.year  =  [PLACEHOLDER-TYPE:NUMBER] AND t2.campus  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the campuses located in a specific county from the 'Campuses' table. The placeholder in the WHERE clause represents the name of the county.\",\n        \"virtual_table\": \"SELECT campus FROM campuses WHERE county  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2366", "db_id": "csu_1", "question": "List the campuses in Los Angeles county.", "rationale": ["Identify the relevant table: The 'Campuses' table contains information about campuses, including their location and county.", "Determine the specific requirement: The user wants to list campuses in Los Angeles county.", "Formulate the SQL query: Use a SELECT statement to retrieve the 'Campus' column from the 'Campuses' table where the 'County' column matches 'Los Angeles'."], "gold_sql": "SELECT campus FROM campuses WHERE county  =  'Los Angeles'", "source_tables": ["campuses"], "pred_sql": "SELECT Campus FROM Campuses WHERE County = 'Los Angeles'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the campuses located in a specific county from the 'Campuses' table. The placeholder in the WHERE clause represents the name of the county.\",\n        \"virtual_table\": \"SELECT campus FROM campuses WHERE county  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of campuses from the 'Campuses' table that are located in a specific county. The placeholder in the WHERE clause represents the name of the county.\",\n        \"virtual_table\": \"SELECT campus FROM campuses WHERE county  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the campuses from the 'Campuses' table that are located in a specific geographical location. The placeholder in the WHERE clause represents the location of interest.\",\n        \"virtual_table\": \"SELECT campus FROM campuses WHERE LOCATION  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2368", "db_id": "csu_1", "question": "How many degrees were conferred in \"San Jose State University\" in 2000?", "rationale": ["Identify the relevant tables: 'Campuses' and 'degrees'.", "We need to join these tables on the campus identifier (Id in Campuses and Campus in degrees).", "Filter the results to only include records for 'San Jose State University' and the year '2000'.", "Use the SUM function to calculate the total number of degrees conferred."], "gold_sql": "SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  'San Jose State University' AND t2.year  =  2000", "source_tables": ["degrees", "campuses"], "pred_sql": "SELECT SUM(Degrees) FROM Campuses AS T1 JOIN degrees AS T2 ON T1.Id = T2.Campus WHERE T1.Campus = 'San Jose State University' AND T2.Year = '2000'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the types of degrees awarded at a specific campus during a particular year. The placeholders in the WHERE clause represent the campus name and the year of the degrees awarded.\",\n        \"virtual_table\": \"SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  [PLACEHOLDER-TYPE:STRING] AND t2.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the years in which degrees were awarded, grouped by year and ordered by the total number of degrees awarded in descending order. The placeholder in the LIMIT clause represents the maximum number of years to return.\",\n        \"virtual_table\": \"SELECT YEAR FROM degrees GROUP BY YEAR ORDER BY sum(degrees) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the total number of graduate enrollments from the 'discipline_enrollments' table for a specific campus and year. The placeholders in the WHERE clause represent the year of enrollment and the name of the campus.\",\n        \"virtual_table\": \"SELECT sum(t1.graduate) FROM discipline_enrollments AS t1 JOIN campuses AS t2 ON t1.campus  =  t2.id WHERE t1.year  =  [PLACEHOLDER-TYPE:NUMBER] AND t2.campus  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2374", "db_id": "csu_1", "question": "What is the number of faculty lines in campus \"Long Beach State University\" in 2002?", "rationale": ["Identify the relevant tables: We need to find the number of faculty lines for a specific campus and year, which involves the 'faculty' and 'Campuses' tables.", "Determine the join condition: The 'faculty' table has a foreign key 'Campus' that relates to the 'Id' in the 'Campuses' table, so we will join these tables on this key.", "Specify the filters: We need to filter the results for the campus named 'Long Beach State University' and the year 2002.", "Construct the SQL query: Using the identified tables, join condition, and filters, we can construct the SQL query to retrieve the number of faculty lines."], "gold_sql": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  2002 AND T2.campus  =  'Long Beach State University'", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT Faculty FROM faculty AS T1 JOIN Campuses AS T2 ON T1.Campus = T2.Id WHERE T2.Campus = 'Long Beach State University' AND T1.Year = 2002;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the types of degrees awarded at a specific campus during a particular year. The placeholders in the WHERE clause represent the campus name and the year of the degrees awarded.\",\n        \"virtual_table\": \"SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  [PLACEHOLDER-TYPE:STRING] AND t2.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2376", "db_id": "csu_1", "question": "How many faculty lines are there in \"San Francisco State University\" in year 2004?", "rationale": ["Identify the relevant tables: 'faculty' for faculty data and 'Campuses' for campus names.", "We need to count the number of faculty lines, so we will use the COUNT() function.", "We need to filter the results to only include faculty from 'San Francisco State University' in the year 2004.", "To do this, we will join the 'faculty' table with the 'Campuses' table on the campus identifier.", "The WHERE clause will specify the campus name and the year to filter the results accordingly."], "gold_sql": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  2004 AND T2.campus  =  'San Francisco State University'", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT COUNT(*) AS FacultyCount \nFROM faculty \nJOIN Campuses ON faculty.Campus = Campuses.Id \nWHERE Campuses.Campus = 'San Francisco State University' AND faculty.Year = 2004;", "hint": "\n"}
{"sample_id": "train.2377", "db_id": "csu_1", "question": "How many faculty lines are there at San Francisco State University in 2004?", "rationale": ["Identify the relevant table: The 'faculty' table contains the number of faculty members.", "Determine the specific campus: We need to find the Id for 'San Francisco State University' from the 'Campuses' table.", "Filter by year: We are interested in the year 2004.", "Construct the SQL query to select the Faculty count for the specified campus and year."], "gold_sql": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  2004 AND T2.campus  =  'San Francisco State University'", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT Faculty FROM faculty WHERE Campus = (SELECT Id FROM Campuses WHERE Campus = 'San Francisco State University') AND Year = 2004;", "hint": "\n"}
{"sample_id": "train.2381", "db_id": "csu_1", "question": "How many faculty members did the university that conferred the most degrees in 2002 have?", "rationale": ["Identify the year of interest, which is 2002, to filter the degrees awarded.", "Use a subquery to calculate the total number of degrees awarded per campus in 2002, grouping by campus and ordering by the total degrees in descending order, limiting the result to the campus with the most degrees.", "Join the result of the subquery with the faculty table on the campus identifier to get the faculty count for the campus that awarded the most degrees in 2002."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2002 ORDER BY t3.degrees DESC LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "pred_sql": "SELECT faculty.Faculty FROM faculty JOIN (SELECT degrees.Campus, SUM(degrees.Degrees) AS TotalDegrees FROM degrees WHERE degrees.Year = '2002' GROUP BY degrees.Campus ORDER BY TotalDegrees DESC LIMIT 1) AS MostDegrees ON faculty.Campus = MostDegrees.Campus", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the types of degrees awarded at a specific campus during a particular year. The placeholders in the WHERE clause represent the campus name and the year of the degrees awarded.\",\n        \"virtual_table\": \"SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  [PLACEHOLDER-TYPE:STRING] AND t2.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the years in which degrees were awarded, grouped by year and ordered by the total number of degrees awarded in descending order. The placeholder in the LIMIT clause represents the maximum number of years to return.\",\n        \"virtual_table\": \"SELECT YEAR FROM degrees GROUP BY YEAR ORDER BY sum(degrees) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2382", "db_id": "csu_1", "question": "How many faculty lines are there in the university that conferred the least number of degrees in year 2001?", "rationale": ["Identify the year of interest, which is 2001.", "Determine which campus conferred the least number of degrees in 2001 by grouping the degrees by campus and counting them, ordering by the count in ascending order, and limiting the result to 1 campus.", "Use the identified campus from the previous step to count the number of faculty lines associated with that campus in the faculty table."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2001 ORDER BY t3.degrees LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "pred_sql": "SELECT COUNT(*) FROM faculty WHERE Campus = (SELECT Campus FROM degrees WHERE Year = '2001' GROUP BY Campus ORDER BY COUNT(Degrees) ASC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the years in which degrees were awarded, grouped by year and ordered by the total number of degrees awarded in descending order. The placeholder in the LIMIT clause represents the maximum number of years to return.\",\n        \"virtual_table\": \"SELECT YEAR FROM degrees GROUP BY YEAR ORDER BY sum(degrees) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the types of degrees awarded at a specific campus during a particular year. The placeholders in the WHERE clause represent the campus name and the year of the degrees awarded.\",\n        \"virtual_table\": \"SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  [PLACEHOLDER-TYPE:STRING] AND t2.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2383", "db_id": "csu_1", "question": "How many faculty members are at the university that gave the least number of degrees in 2001?", "rationale": ["Identify the year of interest, which is 2001.", "Determine the campus that awarded the least number of degrees in 2001 by counting the degrees awarded per campus and ordering them in ascending order.", "Join the 'faculty' table with the 'degrees' table on the campus identifier to get the faculty count for the campus with the least degrees awarded.", "Filter the results to only include records from the year 2001.", "Group the results by campus to aggregate the degree counts and faculty counts.", "Order the results by the count of degrees in ascending order to find the campus with the least degrees awarded.", "Limit the results to 1 to get only the campus with the least degrees awarded and select the faculty count for that campus."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2001 ORDER BY t3.degrees LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "pred_sql": "SELECT faculty.Faculty \nFROM faculty \nJOIN degrees ON faculty.Campus = degrees.Campus \nWHERE degrees.Year = '2001' \nGROUP BY faculty.Campus \nORDER BY COUNT(degrees.Degrees) ASC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the years in which degrees were awarded, grouped by year and ordered by the total number of degrees awarded in descending order. The placeholder in the LIMIT clause represents the maximum number of years to return.\",\n        \"virtual_table\": \"SELECT YEAR FROM degrees GROUP BY YEAR ORDER BY sum(degrees) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the types of degrees awarded at a specific campus during a particular year. The placeholders in the WHERE clause represent the campus name and the year of the degrees awarded.\",\n        \"virtual_table\": \"SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  [PLACEHOLDER-TYPE:STRING] AND t2.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2385", "db_id": "csu_1", "question": "How many undergraduates are there at San Jose State", "rationale": ["Identify the relevant table for undergraduate enrollments, which is 'discipline_enrollments'.", "Determine the need to sum the number of undergraduate enrollments for a specific campus, which is 'San Jose State'.", "Join the 'discipline_enrollments' table with the 'Campuses' table to filter by campus name.", "Construct the SQL query to select the sum of undergraduate enrollments where the campus matches 'San Jose State'."], "gold_sql": "SELECT sum(t1.undergraduate) FROM discipline_enrollments AS t1 JOIN campuses AS t2 ON t1.campus  =  t2.id WHERE t1.year  =  2004 AND t2.campus  =  'San Jose State University'", "source_tables": ["discipline_enrollments", "campuses"], "pred_sql": "SELECT sum(t1.undergraduate) FROM discipline_enrollments AS t1 JOIN Campuses AS t2 ON t1.Campus = t2.Id WHERE t2.Campus = 'San Jose State'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total number of graduate enrollments from the 'discipline_enrollments' table for a specific campus and year. The placeholders in the WHERE clause represent the year of enrollment and the name of the campus.\",\n        \"virtual_table\": \"SELECT sum(t1.graduate) FROM discipline_enrollments AS t1 JOIN campuses AS t2 ON t1.campus  =  t2.id WHERE t1.year  =  [PLACEHOLDER-TYPE:NUMBER] AND t2.campus  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the types of degrees awarded at a specific campus during a particular year. The placeholders in the WHERE clause represent the campus name and the year of the degrees awarded.\",\n        \"virtual_table\": \"SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  [PLACEHOLDER-TYPE:STRING] AND t2.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2397", "db_id": "candidate_poll", "question": "Return the poll resource associated with the most candidates.", "rationale": ["We need to find the poll resource associated with the most candidates.", "This requires counting the number of candidates for each Poll_Source.", "We can achieve this by using the COUNT function on Candidate_ID and grouping the results by Poll_Source.", "To get the Poll_Source with the highest count, we will order the results in descending order based on the count.", "Finally, we will limit the results to only the top entry to get the Poll_Source associated with the most candidates."], "gold_sql": "SELECT poll_source FROM candidate GROUP BY poll_source ORDER BY count(*) DESC LIMIT 1", "source_tables": ["candidate"], "pred_sql": "SELECT Poll_Source, COUNT(Candidate_ID) AS Candidate_Count \nFROM candidate \nGROUP BY Poll_Source \nORDER BY Candidate_Count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the support rates of candidates from the 'candidate' table, ordered from highest to lowest. The placeholder in the LIMIT clause indicates the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT support_rate FROM candidate ORDER BY support_rate DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2405", "db_id": "candidate_poll", "question": "Return the poll source corresponding to the candidate who has the oppose rate.", "rationale": ["Identify the relevant table: The 'candidate' table contains the 'Poll_Source' and 'Oppose_rate' columns.", "Determine the condition: We need to find the 'Poll_Source' for candidates who have an 'Oppose_rate'.", "Construct the SQL query: We will select 'Poll_Source' from the 'candidate' table where 'Oppose_rate' is not null."], "gold_sql": "SELECT poll_source FROM candidate ORDER BY oppose_rate DESC LIMIT 1", "source_tables": ["candidate"], "pred_sql": "SELECT Poll_Source FROM candidate WHERE Oppose_rate IS NOT NULL", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the support rates of candidates from the 'candidate' table, ordered from highest to lowest. The placeholder in the LIMIT clause indicates the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT support_rate FROM candidate ORDER BY support_rate DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2417", "db_id": "candidate_poll", "question": "For each sex, what is the name and sex of the candidate with the oppose rate for their sex?", "rationale": ["We need to find the candidate with the highest oppose rate for each sex.", "To do this, we will join the 'candidate' table with the 'people' table on the 'People_ID' column.", "We will select the 'Name' and 'Sex' from the 'people' table and the 'Oppose_rate' from the 'candidate' table.", "To find the candidate with the highest oppose rate for each sex, we will use a subquery that selects the maximum oppose rate for candidates of the same sex.", "The outer query will filter candidates based on the maximum oppose rate obtained from the subquery.", "Finally, we will order the results by sex to group them accordingly."], "gold_sql": "SELECT t1.name ,  t1.sex ,  min(oppose_rate) FROM people AS t1 JOIN candidate AS t2 ON t1.people_id  =  t2.people_id GROUP BY t1.sex", "source_tables": ["candidate", "people"], "pred_sql": "SELECT p.Name, p.Sex, c.Oppose_rate \nFROM candidate c \nJOIN people p ON c.People_ID = p.People_ID \nWHERE c.Oppose_rate = (SELECT MAX(Oppose_rate) \n                       FROM candidate c2 \n                       JOIN people p2 ON c2.People_ID = p2.People_ID \n                       WHERE p2.Sex = p.Sex) \nORDER BY p.Sex;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the support rates of candidates from the 'candidate' table, ordered from highest to lowest. The placeholder in the LIMIT clause indicates the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT support_rate FROM candidate ORDER BY support_rate DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2434", "db_id": "movie_1", "question": "Find the titles of all movies directed by steven spielberg.", "rationale": ["Identify the relevant table: The 'Movie' table contains the information about movie titles and directors.", "Determine the condition: We need to filter the movies directed by 'steven spielberg'.", "Construct the SQL query: Use a SELECT statement to retrieve the 'title' from the 'Movie' table where the 'director' matches 'steven spielberg'."], "gold_sql": "SELECT title FROM Movie WHERE director = 'Steven Spielberg'", "source_tables": ["movie"], "pred_sql": "SELECT title FROM Movie WHERE director = 'steven spielberg'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the titles of movies from the 'Movie' table that have received ratings within a specified range of stars. The placeholders in the WHERE clause represent the minimum and maximum star ratings.\",\n        \"virtual_table\": \"SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2461", "db_id": "movie_1", "question": "What are the different names of all reviewers whose ratings do not have a date field?", "rationale": ["Identify the goal: We need to find the names of reviewers whose ratings do not have a date field.", "Understand the schema: The Reviewer table contains reviewer names and the Rating table contains ratings along with their submission dates.", "To find reviewers without a date in their ratings, we can use a subquery to select rIDs from the Rating table where ratingDate is not null.", "We will then select distinct names from the Reviewer table where the rID is not in the list of rIDs obtained from the subquery.", "The final SQL query combines these elements to retrieve the desired information."], "gold_sql": "SELECT DISTINCT name FROM Reviewer AS T1 JOIN Rating AS T2 ON T1.rID  =  T2.rID WHERE ratingDate  =  'null'", "source_tables": ["rating", "reviewer"], "pred_sql": "SELECT DISTINCT name FROM Reviewer WHERE rID NOT IN (SELECT rID FROM Rating WHERE ratingDate IS NOT NULL)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the unique identifiers of reviewers from the 'Rating' table who have given a rating that is not equal to a specified number of stars. The placeholder in the WHERE clause represents the number of stars.\",\n        \"virtual_table\": \"SELECT rID FROM Rating WHERE stars != [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the distinct names of reviewers who submitted ratings on a specific date. The query joins the 'Reviewer' and 'Rating' tables based on the reviewer's ID, filtering the results by the date of the rating submission.\",\n        \"virtual_table\": \"SELECT DISTINCT name FROM Reviewer AS T1 JOIN Rating AS T2 ON T1.rID  =  T2.rID WHERE ratingDate  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the unique identifiers of reviewers from the 'Rating' table who have given a rating that is not equal to a specified number of stars. The placeholder in the WHERE clause represents the number of stars to filter out.\",\n        \"virtual_table\": \"SELECT rID FROM Rating WHERE stars != [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2476", "db_id": "movie_1", "question": "Find the names of all reviewers who rated Gone with the Wind.", "rationale": ["Identify the tables involved: Reviewer, Rating, and Movie.", "We need to find the names of reviewers, so we will select the 'name' column from the Reviewer table.", "To link reviewers to their ratings, we will join the Reviewer table with the Rating table on the rID column.", "Next, we need to link the ratings to the movies, so we will join the Rating table with the Movie table on the mID column.", "We need to filter the results to only include ratings for the movie titled 'Gone with the Wind'.", "The final SQL query will select distinct reviewer names who rated 'Gone with the Wind'."], "gold_sql": "SELECT DISTINCT T3.name FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID JOIN Reviewer AS T3 ON T1.rID  =  T3.rID WHERE T2.title  =  'Gone with the Wind'", "source_tables": ["rating", "movie", "reviewer"], "pred_sql": "SELECT DISTINCT Reviewer.name \nFROM Reviewer \nJOIN Rating ON Reviewer.rID = Rating.rID \nJOIN Movie ON Rating.mID = Movie.mID \nWHERE Movie.title = 'Gone with the Wind';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct names of reviewers who submitted ratings on a specific date. The query joins the 'Reviewer' and 'Rating' tables based on the reviewer's ID, filtering the results by the date of the rating submission.\",\n        \"virtual_table\": \"SELECT DISTINCT name FROM Reviewer AS T1 JOIN Rating AS T2 ON T1.rID  =  T2.rID WHERE ratingDate  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the unique identifiers of reviewers from the 'Rating' table who have given a rating that is not equal to a specified number of stars. The placeholder in the WHERE clause represents the number of stars.\",\n        \"virtual_table\": \"SELECT rID FROM Rating WHERE stars != [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the unique identifiers of reviewers from the 'Rating' table who have given a rating that is not equal to a specified number of stars. The placeholder in the WHERE clause represents the number of stars to filter out.\",\n        \"virtual_table\": \"SELECT rID FROM Rating WHERE stars != [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2483", "db_id": "movie_1", "question": "What are the names of all the reviewers and movie names?", "rationale": ["We need to retrieve the names of all reviewers and the titles of the movies they rated.", "To do this, we will join the 'Reviewer' table with the 'Rating' table on the reviewer ID (rID).", "Next, we will join the 'Rating' table with the 'Movie' table on the movie ID (mID).", "This will allow us to access both the reviewer's name and the movie's title in a single query.", "Finally, we will select the distinct names of reviewers and the corresponding movie titles from the joined tables."], "gold_sql": "SELECT name FROM Reviewer UNION SELECT title FROM Movie", "source_tables": ["movie", "reviewer"], "pred_sql": "SELECT Reviewer.name, Movie.title FROM Reviewer JOIN Rating ON Reviewer.rID = Rating.rID JOIN Movie ON Rating.mID = Movie.mID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct names of reviewers who submitted ratings on a specific date. The query joins the 'Reviewer' and 'Rating' tables based on the reviewer's ID, filtering the results by the date of the rating submission.\",\n        \"virtual_table\": \"SELECT DISTINCT name FROM Reviewer AS T1 JOIN Rating AS T2 ON T1.rID  =  T2.rID WHERE ratingDate  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the titles of movies from the 'Movie' table that have received ratings within a specified range of stars. The placeholders in the WHERE clause represent the minimum and maximum star ratings.\",\n        \"virtual_table\": \"SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the unique identifiers of reviewers from the 'Rating' table who have given a rating that is not equal to a specified number of stars. The placeholder in the WHERE clause represents the number of stars to filter out.\",\n        \"virtual_table\": \"SELECT rID FROM Rating WHERE stars != [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2495", "db_id": "movie_1", "question": "For each director, how many reviews have they received?", "rationale": ["We need to count the number of reviews each director has received.", "To do this, we will join the 'Movie' table with the 'Rating' table on the movie ID (mID).", "We will select the director's name and count the number of ratings (rID) associated with each director.", "Finally, we will group the results by the director to get the count of reviews for each one."], "gold_sql": "SELECT count(*) ,  T1.director FROM Movie AS T1 JOIN Rating AS T2 ON T1.mID  =  T2.mID GROUP BY T1.director", "source_tables": ["rating", "movie"], "pred_sql": "SELECT director, COUNT(rID) AS review_count \nFROM Movie \nJOIN Rating ON Movie.mID = Rating.mID \nGROUP BY director;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct names of reviewers who submitted ratings on a specific date. The query joins the 'Reviewer' and 'Rating' tables based on the reviewer's ID, filtering the results by the date of the rating submission.\",\n        \"virtual_table\": \"SELECT DISTINCT name FROM Reviewer AS T1 JOIN Rating AS T2 ON T1.rID  =  T2.rID WHERE ratingDate  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the unique identifiers of reviewers from the 'Rating' table who have given a rating that is not equal to a specified number of stars. The placeholder in the WHERE clause represents the number of stars.\",\n        \"virtual_table\": \"SELECT rID FROM Rating WHERE stars != [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the unique identifiers of reviewers from the 'Rating' table who have given a rating that is not equal to a specified number of stars. The placeholder in the WHERE clause represents the number of stars to filter out.\",\n        \"virtual_table\": \"SELECT rID FROM Rating WHERE stars != [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2500", "db_id": "movie_1", "question": "What are the names and years of the movies that has the top 3 highest rating star?", "rationale": ["Identify the main goal: to find the names and years of the movies with the top 3 highest ratings.", "The 'Movie' table contains the necessary columns: 'title' and 'year'.", "To find the top 3 highest ratings, we need to look at the 'Rating' table, specifically the 'stars' column.", "We can use a subquery to select the 'mID' of the top 3 movies based on the highest 'stars' ratings.", "The subquery will order the ratings in descending order and limit the results to 3.", "Finally, we will use the result of the subquery to filter the 'Movie' table to get the corresponding titles and years."], "gold_sql": "SELECT T2.title ,  T2.year FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID ORDER BY T1.stars DESC LIMIT 3", "source_tables": ["rating", "movie"], "pred_sql": "SELECT title, year FROM Movie WHERE mID IN (SELECT mID FROM Rating ORDER BY stars DESC LIMIT 3)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the titles of movies from the 'Movie' table that have received ratings within a specified range of stars. The placeholders in the WHERE clause represent the minimum and maximum star ratings.\",\n        \"virtual_table\": \"SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the distinct names of reviewers who submitted ratings on a specific date. The query joins the 'Reviewer' and 'Rating' tables based on the reviewer's ID, filtering the results by the date of the rating submission.\",\n        \"virtual_table\": \"SELECT DISTINCT name FROM Reviewer AS T1 JOIN Rating AS T2 ON T1.rID  =  T2.rID WHERE ratingDate  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the unique identifiers of reviewers from the 'Rating' table who have given a rating that is not equal to a specified number of stars. The placeholder in the WHERE clause represents the number of stars to filter out.\",\n        \"virtual_table\": \"SELECT rID FROM Rating WHERE stars != [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2502", "db_id": "movie_1", "question": "For each director, return the director's name together with the title of the movie they directed that received the highest rating among all of their movies, and the value of that rating. Ignore movies whose director is NULL.", "rationale": ["We need to find the highest-rated movie for each director.", "First, we will create a subquery that selects the movie ID (mID) and the maximum stars rating for each movie from the Rating table, grouping by mID. This will give us the highest rating for each movie.", "Next, we will join this subquery with the Movie table to get the director's name and the title of the movie.", "We will filter out any movies where the director is NULL to meet the requirement of the query."], "gold_sql": "SELECT T2.title ,  T1.stars ,  T2.director ,  max(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE director != 'null' GROUP BY director", "source_tables": ["rating", "movie"], "pred_sql": "SELECT M.director, M.title, R.highest_rating\nFROM Movie AS M\nJOIN (\n    SELECT mID, MAX(stars) AS highest_rating\n    FROM Rating\n    GROUP BY mID\n) AS R ON M.mID = R.mID\nWHERE M.director IS NOT NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the titles of movies from the 'Movie' table that have received ratings within a specified range of stars. The placeholders in the WHERE clause represent the minimum and maximum star ratings.\",\n        \"virtual_table\": \"SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the distinct names of reviewers who submitted ratings on a specific date. The query joins the 'Reviewer' and 'Rating' tables based on the reviewer's ID, filtering the results by the date of the rating submission.\",\n        \"virtual_table\": \"SELECT DISTINCT name FROM Reviewer AS T1 JOIN Rating AS T2 ON T1.rID  =  T2.rID WHERE ratingDate  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2503", "db_id": "movie_1", "question": "For each director, what are the titles and ratings for all the movies they reviewed?", "rationale": ["We need to retrieve the titles and ratings of movies for each director.", "To do this, we will join the 'Movie' table with the 'Rating' table using the movie ID (mID).", "Next, we will also join the 'Reviewer' table to get the reviewer's information using the reviewer ID (rID).", "The SELECT statement will include the director's name, movie title, and the rating stars.", "Finally, we will order the results by director and movie title for better readability."], "gold_sql": "SELECT T2.title ,  T1.stars ,  T2.director ,  max(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE director != 'null' GROUP BY director", "source_tables": ["rating", "movie"], "pred_sql": "SELECT M.director, M.title, R.stars \nFROM Movie AS M \nJOIN Rating AS R ON M.mID = R.mID \nJOIN Reviewer AS Rev ON R.rID = Rev.rID \nORDER BY M.director, M.title;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the titles of movies from the 'Movie' table that have received ratings within a specified range of stars. The placeholders in the WHERE clause represent the minimum and maximum star ratings.\",\n        \"virtual_table\": \"SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the distinct names of reviewers who submitted ratings on a specific date. The query joins the 'Reviewer' and 'Rating' tables based on the reviewer's ID, filtering the results by the date of the rating submission.\",\n        \"virtual_table\": \"SELECT DISTINCT name FROM Reviewer AS T1 JOIN Rating AS T2 ON T1.rID  =  T2.rID WHERE ratingDate  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the unique identifiers of reviewers from the 'Rating' table who have given a rating that is not equal to a specified number of stars. The placeholder in the WHERE clause represents the number of stars to filter out.\",\n        \"virtual_table\": \"SELECT rID FROM Rating WHERE stars != [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2505", "db_id": "movie_1", "question": "For each reviewer id, what is the title and rating for the movie with the smallest rating?", "rationale": ["We need to find the title and rating for the movie with the smallest rating for each reviewer id.", "To achieve this, we will join the Rating table with the Movie table to get the movie titles along with the ratings.", "We will use a subquery to find the minimum rating (stars) for each reviewer (rID).", "The subquery will select the minimum stars from the Rating table where the rID matches the current reviewer in the outer query.", "Finally, we will select the reviewer id (rID), movie title (M.title), and the corresponding stars (R.stars) from the joined tables."], "gold_sql": "SELECT T2.title ,  T1.rID ,  T1.stars ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.rID", "source_tables": ["rating", "movie"], "pred_sql": "SELECT R.rID, M.title, R.stars \nFROM Rating AS R \nJOIN Movie AS M ON R.mID = M.mID \nWHERE R.stars = (SELECT MIN(stars) FROM Rating WHERE rID = R.rID)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the titles of movies from the 'Movie' table that have received ratings within a specified range of stars. The placeholders in the WHERE clause represent the minimum and maximum star ratings.\",\n        \"virtual_table\": \"SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the unique identifiers of reviewers from the 'Rating' table who have given a rating that is not equal to a specified number of stars. The placeholder in the WHERE clause represents the number of stars to filter out.\",\n        \"virtual_table\": \"SELECT rID FROM Rating WHERE stars != [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the unique identifiers of reviewers from the 'Rating' table who have given a rating that is not equal to a specified number of stars. The placeholder in the WHERE clause represents the number of stars.\",\n        \"virtual_table\": \"SELECT rID FROM Rating WHERE stars != [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2507", "db_id": "movie_1", "question": "For each director, what is the title and score of their most poorly rated movie?", "rationale": ["We need to find the title and score of the most poorly rated movie for each director.", "To do this, we will join the Movie table with the Rating table on the movie ID (mID).", "We will group the results by director and movie title to aggregate the ratings.", "Using the MIN function, we can find the lowest rating for each movie.", "To ensure we only get the most poorly rated movie for each director, we will use a HAVING clause to filter the results to only include movies that have the minimum rating for that director."], "gold_sql": "SELECT T2.title ,  T1.stars ,  T2.director ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T2.director", "source_tables": ["rating", "movie"], "pred_sql": "SELECT M.director, M.title, MIN(R.stars) AS lowest_rating\nFROM Movie AS M\nJOIN Rating AS R ON M.mID = R.mID\nGROUP BY M.director, M.title\nHAVING MIN(R.stars) = (SELECT MIN(stars) FROM Rating WHERE mID = M.mID)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the titles of movies from the 'Movie' table that have received ratings within a specified range of stars. The placeholders in the WHERE clause represent the minimum and maximum star ratings.\",\n        \"virtual_table\": \"SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the unique identifiers of reviewers from the 'Rating' table who have given a rating that is not equal to a specified number of stars. The placeholder in the WHERE clause represents the number of stars.\",\n        \"virtual_table\": \"SELECT rID FROM Rating WHERE stars != [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the unique identifiers of reviewers from the 'Rating' table who have given a rating that is not equal to a specified number of stars. The placeholder in the WHERE clause represents the number of stars to filter out.\",\n        \"virtual_table\": \"SELECT rID FROM Rating WHERE stars != [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2508", "db_id": "movie_1", "question": "What is the name of the movie that is rated by most of times?", "rationale": ["We need to find the movie that has been rated the most times.", "To do this, we will count the number of ratings for each movie using the Rating table.", "We will group the results by movie ID (mID) to get the count of ratings for each movie.", "Next, we will order the results in descending order based on the count of ratings to get the movie with the highest count at the top.", "Finally, we will limit the results to just one movie to get the top-rated movie.", "We will then join this result with the Movie table to get the title of the movie."], "gold_sql": "SELECT T2.title ,  T1.mID FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY count(*) DESC LIMIT 1", "source_tables": ["rating", "movie"], "pred_sql": "SELECT title FROM Movie WHERE mID IN (SELECT mID FROM Rating GROUP BY mID ORDER BY COUNT(*) DESC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the titles of movies from the 'Movie' table that have received ratings within a specified range of stars. The placeholders in the WHERE clause represent the minimum and maximum star ratings.\",\n        \"virtual_table\": \"SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the distinct names of reviewers who submitted ratings on a specific date. The query joins the 'Reviewer' and 'Rating' tables based on the reviewer's ID, filtering the results by the date of the rating submission.\",\n        \"virtual_table\": \"SELECT DISTINCT name FROM Reviewer AS T1 JOIN Rating AS T2 ON T1.rID  =  T2.rID WHERE ratingDate  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2509", "db_id": "movie_1", "question": "What is the name of the movie that has been reviewed the most?", "rationale": ["To find the movie that has been reviewed the most, we need to count the number of reviews for each movie.", "We can achieve this by grouping the ratings by movie ID (mID) in the Rating table and counting the number of reviewer IDs (rID) for each movie.", "Next, we will order the results by the count of reviews in descending order to get the movie with the highest number of reviews at the top.", "Finally, we will limit the results to just one movie to get the top reviewed movie.", "We will then join this result with the Movie table to get the title of the movie corresponding to the mID that has the most reviews."], "gold_sql": "SELECT T2.title ,  T1.mID FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY count(*) DESC LIMIT 1", "source_tables": ["rating", "movie"], "pred_sql": "SELECT title FROM Movie WHERE mID IN (SELECT mID FROM Rating GROUP BY mID ORDER BY COUNT(rID) DESC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the titles of movies from the 'Movie' table that have received ratings within a specified range of stars. The placeholders in the WHERE clause represent the minimum and maximum star ratings.\",\n        \"virtual_table\": \"SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the distinct names of reviewers who submitted ratings on a specific date. The query joins the 'Reviewer' and 'Rating' tables based on the reviewer's ID, filtering the results by the date of the rating submission.\",\n        \"virtual_table\": \"SELECT DISTINCT name FROM Reviewer AS T1 JOIN Rating AS T2 ON T1.rID  =  T2.rID WHERE ratingDate  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2517", "db_id": "movie_1", "question": "What are the ids of all moviest hat have not been reviewed by Britanny Harris?", "rationale": ["Identify the movies that have not been reviewed by Britanny Harris.", "To find the movies not reviewed by a specific reviewer, we need to select the movie IDs from the Movie table where the movie ID is not in the list of movie IDs that have been rated by Britanny Harris.", "First, we need to find the rID of Britanny Harris from the Reviewer table.", "Next, we will find all the mID from the Rating table where the rID matches Britanny Harris's rID.", "Finally, we will select all mID from the Movie table that are not in the list of mID obtained from the Rating table for Britanny Harris."], "gold_sql": "SELECT mID FROM Rating EXCEPT SELECT T1.mID FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T2.name  =  'Brittany Harris'", "source_tables": ["rating", "reviewer"], "pred_sql": "SELECT mID FROM Movie WHERE mID NOT IN (SELECT mID FROM Rating WHERE rID = (SELECT rID FROM Reviewer WHERE name = 'Britanny Harris'));", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the unique identifiers of reviewers from the 'Rating' table who have given a rating that is not equal to a specified number of stars. The placeholder in the WHERE clause represents the number of stars.\",\n        \"virtual_table\": \"SELECT rID FROM Rating WHERE stars != [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the unique identifiers of reviewers from the 'Rating' table who have given a rating that is not equal to a specified number of stars. The placeholder in the WHERE clause represents the number of stars to filter out.\",\n        \"virtual_table\": \"SELECT rID FROM Rating WHERE stars != [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the titles of movies from the 'Movie' table that have received ratings within a specified range of stars. The placeholders in the WHERE clause represent the minimum and maximum star ratings.\",\n        \"virtual_table\": \"SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2518", "db_id": "movie_1", "question": "Find the average rating star for each movie that received at least 2 ratings.", "rationale": ["We need to find the average rating star for each movie that received at least 2 ratings.", "To do this, we will join the 'Movie' table with the 'Rating' table on the movie ID (mID).", "We will select the movie title and calculate the average of the stars given in the ratings.", "We will group the results by the movie ID to ensure we get the average rating for each movie.", "To filter the results to only include movies that have received at least 2 ratings, we will use the HAVING clause with COUNT(R.rID) >= 2."], "gold_sql": "SELECT mID ,  avg(stars) FROM Rating GROUP BY mID HAVING count(*)  >=  2", "source_tables": ["rating"], "pred_sql": "SELECT M.title, AVG(R.stars) AS average_rating\nFROM Movie AS M\nJOIN Rating AS R ON M.mID = R.mID\nGROUP BY M.mID\nHAVING COUNT(R.rID) >= 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the titles of movies from the 'Movie' table that have received ratings within a specified range of stars. The placeholders in the WHERE clause represent the minimum and maximum star ratings.\",\n        \"virtual_table\": \"SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the unique identifiers of reviewers from the 'Rating' table who have given a rating that is not equal to a specified number of stars. The placeholder in the WHERE clause represents the number of stars to filter out.\",\n        \"virtual_table\": \"SELECT rID FROM Rating WHERE stars != [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the unique identifiers of reviewers from the 'Rating' table who have given a rating that is not equal to a specified number of stars. The placeholder in the WHERE clause represents the number of stars.\",\n        \"virtual_table\": \"SELECT rID FROM Rating WHERE stars != [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2528", "db_id": "movie_1", "question": "What are the names of reviewers who had rated 3 star and 4 star?", "rationale": ["Identify the tables involved: We need to get reviewer names from the Reviewer table and their ratings from the Rating table.", "Determine the relationship: The Reviewer table is linked to the Rating table through the rID column.", "Filter the ratings: We are interested in reviewers who rated movies with 3 stars and 4 stars. This can be done using the WHERE clause with an IN condition.", "Select distinct names: Since we want unique reviewer names, we will use SELECT DISTINCT to avoid duplicates."], "gold_sql": "SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T1.stars  =  3 INTERSECT SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T1.stars  =  4", "source_tables": ["rating", "reviewer"], "pred_sql": "SELECT DISTINCT name FROM Reviewer AS T1 JOIN Rating AS T2 ON T1.rID = T2.rID WHERE stars IN ('3', '4')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the unique identifiers of reviewers from the 'Rating' table who have given a rating that is not equal to a specified number of stars. The placeholder in the WHERE clause represents the number of stars.\",\n        \"virtual_table\": \"SELECT rID FROM Rating WHERE stars != [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the unique identifiers of reviewers from the 'Rating' table who have given a rating that is not equal to a specified number of stars. The placeholder in the WHERE clause represents the number of stars to filter out.\",\n        \"virtual_table\": \"SELECT rID FROM Rating WHERE stars != [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the distinct names of reviewers who submitted ratings on a specific date. The query joins the 'Reviewer' and 'Rating' tables based on the reviewer's ID, filtering the results by the date of the rating submission.\",\n        \"virtual_table\": \"SELECT DISTINCT name FROM Reviewer AS T1 JOIN Rating AS T2 ON T1.rID  =  T2.rID WHERE ratingDate  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2530", "db_id": "movie_1", "question": "What are the names of movies that get 3 star and 4 star?", "rationale": ["The user wants to find the names of movies that received ratings of 3 stars and 4 stars.", "To achieve this, we need to join the 'Rating' table with the 'Movie' table on the movie ID (mID).", "We will select the movie titles from the 'Movie' table where the stars in the 'Rating' table are either 3 or 4.", "Using the IN clause allows us to specify multiple values (3 and 4) for the stars column."], "gold_sql": "SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  3 INTERSECT SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  4", "source_tables": ["rating", "movie"], "pred_sql": "SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID = T2.mID WHERE T1.stars IN ('3', '4')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the titles of movies from the 'Movie' table that have received ratings within a specified range of stars. The placeholders in the WHERE clause represent the minimum and maximum star ratings.\",\n        \"virtual_table\": \"SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the unique identifiers of reviewers from the 'Rating' table who have given a rating that is not equal to a specified number of stars. The placeholder in the WHERE clause represents the number of stars to filter out.\",\n        \"virtual_table\": \"SELECT rID FROM Rating WHERE stars != [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the unique identifiers of reviewers from the 'Rating' table who have given a rating that is not equal to a specified number of stars. The placeholder in the WHERE clause represents the number of stars.\",\n        \"virtual_table\": \"SELECT rID FROM Rating WHERE stars != [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2576", "db_id": "inn_1", "question": "Find the most popular room in the hotel. The most popular room is the room that had seen the largest number of reservations.", "rationale": ["To find the most popular room, we need to count the number of reservations for each room.", "We will join the 'Reservations' table with the 'Rooms' table using the room identifier.", "We will group the results by room ID and room name to get the count of reservations for each room.", "We will order the results by the count of reservations in descending order to get the most popular room at the top.", "Finally, we will limit the results to 1 to get only the most popular room."], "gold_sql": "SELECT T2.roomName FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT T2.RoomId, T2.roomName, COUNT(*) AS ReservationCount \nFROM Reservations AS T1 \nJOIN Rooms AS T2 ON T1.Room = T2.RoomId \nGROUP BY T2.RoomId, T2.roomName \nORDER BY ReservationCount DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of reservations where the total number of occupants (adults and kids) matches the maximum occupancy allowed for each room. It joins the 'Reservations' table with the 'Rooms' table based on the room identifier, ensuring that only those reservations that meet the occupancy criteria are counted.\",\n        \"virtual_table\": \"SELECT count(*) FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T2.maxOccupancy  =  T1.Adults + T1.Kids;\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of room identifiers and their names from the 'Rooms' table, sorted by the base price in descending order. The placeholder in the LIMIT clause represents the maximum number of rooms to be displayed.\",\n        \"virtual_table\": \"SELECT RoomId ,  roomName FROM Rooms ORDER BY basePrice DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the total number of beds available in rooms of a specific bed type from the 'Rooms' table. The placeholder in the WHERE clause represents the type of bed being queried.\",\n        \"virtual_table\": \"SELECT sum(beds) FROM Rooms WHERE bedtype  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.2577", "db_id": "inn_1", "question": "Which room has the largest number of reservations?", "rationale": ["Identify the tables involved: Reservations and Rooms.", "We need to count the number of reservations for each room, so we will join the Reservations table with the Rooms table on the Room identifier.", "Use COUNT(*) to count the number of reservations for each room.", "Group the results by RoomId and roomName to get the count per room.", "Order the results by the count of reservations in descending order to find the room with the largest number of reservations.", "Limit the results to 1 to get only the room with the highest count."], "gold_sql": "SELECT T2.roomName FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT T2.RoomId, T2.roomName, COUNT(*) AS ReservationCount \nFROM Reservations AS T1 \nJOIN Rooms AS T2 ON T1.Room = T2.RoomId \nGROUP BY T2.RoomId, T2.roomName \nORDER BY ReservationCount DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of reservations where the total number of occupants (adults and kids) matches the maximum occupancy allowed for each room. It joins the 'Reservations' table with the 'Rooms' table based on the room identifier, ensuring that only those reservations that meet the occupancy criteria are counted.\",\n        \"virtual_table\": \"SELECT count(*) FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T2.maxOccupancy  =  T1.Adults + T1.Kids;\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of room identifiers and their names from the 'Rooms' table, sorted by the base price in descending order. The placeholder in the LIMIT clause represents the maximum number of rooms to be displayed.\",\n        \"virtual_table\": \"SELECT RoomId ,  roomName FROM Rooms ORDER BY basePrice DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the total number of beds available in rooms of a specific bed type from the 'Rooms' table. The placeholder in the WHERE clause represents the type of bed being queried.\",\n        \"virtual_table\": \"SELECT sum(beds) FROM Rooms WHERE bedtype  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.2578", "db_id": "inn_1", "question": "How many kids stay in the rooms reserved by ROY SWEAZY?", "rationale": ["Identify the relevant tables: Reservations for guest information and number of kids.", "Filter the Reservations table for entries where the LastName is 'SWEAZY' and FirstName is 'ROY'.", "Use the SUM function to calculate the total number of kids from the filtered results."], "gold_sql": "SELECT kids FROM Reservations WHERE FirstName = 'ROY' AND LastName  =  'SWEAZY';", "source_tables": ["reservations"], "pred_sql": "SELECT SUM(Kids) AS TotalKids FROM Reservations WHERE LastName = 'SWEAZY' AND FirstName = 'ROY';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of reservations where the total number of occupants (adults and kids) matches the maximum occupancy allowed for each room. It joins the 'Reservations' table with the 'Rooms' table based on the room identifier, ensuring that only those reservations that meet the occupancy criteria are counted.\",\n        \"virtual_table\": \"SELECT count(*) FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T2.maxOccupancy  =  T1.Adults + T1.Kids;\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of rooms from the 'Rooms' table that have a specific type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Rooms WHERE bedType  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.2582", "db_id": "inn_1", "question": "Which room has the highest rate? List the room's full name, rate, check in and check out date.", "rationale": ["Identify the relevant tables: Rooms and Reservations.", "We need to find the room with the highest rate, which corresponds to the basePrice in the Rooms table.", "We will join the Rooms table with the Reservations table on the RoomId to get the necessary details.", "Select the room's name (roomName), base price (basePrice), check-in date (CheckIn), and check-out date (CheckOut).", "Order the results by basePrice in descending order to get the highest rate at the top.", "Limit the results to 1 to get only the room with the highest rate."], "gold_sql": "SELECT T2.roomName ,  T1.Rate ,  T1.CheckIn ,  T1.CheckOut FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY T1.Rate DESC LIMIT 1;", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT r.roomName, r.basePrice, res.CheckIn, res.CheckOut \nFROM Rooms AS r \nJOIN Reservations AS res ON r.RoomId = res.Room \nORDER BY r.basePrice DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of room identifiers and their names from the 'Rooms' table, sorted by the base price in descending order. The placeholder in the LIMIT clause represents the maximum number of rooms to be displayed.\",\n        \"virtual_table\": \"SELECT RoomId ,  roomName FROM Rooms ORDER BY basePrice DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of reservations where the total number of occupants (adults and kids) matches the maximum occupancy allowed for each room. It joins the 'Reservations' table with the 'Rooms' table based on the room identifier, ensuring that only those reservations that meet the occupancy criteria are counted.\",\n        \"virtual_table\": \"SELECT count(*) FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T2.maxOccupancy  =  T1.Adults + T1.Kids;\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of rooms from the 'Rooms' table that have a specific type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Rooms WHERE bedType  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.2583", "db_id": "inn_1", "question": "Return the name, rate, check in and check out date for the room with the highest rate.", "rationale": ["We need to retrieve the name, rate, check-in, and check-out date for the room with the highest rate.", "To do this, we will join the 'Reservations' table with the 'Rooms' table using the Room identifier.", "We will select the room name from the 'Rooms' table and the rate, check-in, and check-out dates from the 'Reservations' table.", "To find the room with the highest rate, we will order the results by the Rate column in descending order.", "Finally, we will limit the results to only one entry to get the room with the highest rate."], "gold_sql": "SELECT T2.roomName ,  T1.Rate ,  T1.CheckIn ,  T1.CheckOut FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY T1.Rate DESC LIMIT 1;", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT r.roomName, res.Rate, res.CheckIn, res.CheckOut \nFROM Reservations res \nJOIN Rooms r ON res.Room = r.RoomId \nORDER BY res.Rate DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of room identifiers and their names from the 'Rooms' table, sorted by the base price in descending order. The placeholder in the LIMIT clause represents the maximum number of rooms to be displayed.\",\n        \"virtual_table\": \"SELECT RoomId ,  roomName FROM Rooms ORDER BY basePrice DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of reservations where the total number of occupants (adults and kids) matches the maximum occupancy allowed for each room. It joins the 'Reservations' table with the 'Rooms' table based on the room identifier, ensuring that only those reservations that meet the occupancy criteria are counted.\",\n        \"virtual_table\": \"SELECT count(*) FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T2.maxOccupancy  =  T1.Adults + T1.Kids;\"\n    }\n}\n"}
{"sample_id": "train.2589", "db_id": "inn_1", "question": "Find the total number of king beds available.", "rationale": ["The user wants to find the total number of king beds available.", "We need to sum the 'beds' column from the 'Rooms' table where the 'bedType' is 'king'.", "Using the provided virtual table template, we replace the placeholder with 'king' to form the SQL query."], "gold_sql": "SELECT sum(beds) FROM Rooms WHERE bedtype  =  'King';", "source_tables": ["rooms"], "pred_sql": "SELECT sum(beds) FROM Rooms WHERE bedType = 'king';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total number of beds available in rooms of a specific bed type from the 'Rooms' table. The placeholder in the WHERE clause represents the type of bed being queried.\",\n        \"virtual_table\": \"SELECT sum(beds) FROM Rooms WHERE bedtype  =  [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of rooms from the 'Rooms' table that have a specific type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Rooms WHERE bedType  =  [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of reservations where the total number of occupants (adults and kids) matches the maximum occupancy allowed for each room. It joins the 'Reservations' table with the 'Rooms' table based on the room identifier, ensuring that only those reservations that meet the occupancy criteria are counted.\",\n        \"virtual_table\": \"SELECT count(*) FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T2.maxOccupancy  =  T1.Adults + T1.Kids;\"\n    }\n}\n"}
{"sample_id": "train.2590", "db_id": "inn_1", "question": "List the names and decor of rooms that have a king bed. Sort the list by their price.", "rationale": ["Identify the required columns: roomName and decor from the Rooms table.", "Determine the condition: we need rooms that have a king bed, which is specified by the bedType column.", "Sort the results by the base price of the rooms, which is specified by the basePrice column.", "Construct the SQL query using SELECT to retrieve the specified columns, WHERE to filter by bedType, and ORDER BY to sort by basePrice."], "gold_sql": "SELECT roomName ,  decor FROM Rooms WHERE bedtype  =  'King' ORDER BY basePrice;", "source_tables": ["rooms"], "pred_sql": "SELECT roomName, decor FROM Rooms WHERE bedType = 'king' ORDER BY basePrice;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of room identifiers and their names from the 'Rooms' table, sorted by the base price in descending order. The placeholder in the LIMIT clause represents the maximum number of rooms to be displayed.\",\n        \"virtual_table\": \"SELECT RoomId ,  roomName FROM Rooms ORDER BY basePrice DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of rooms from the 'Rooms' table that have a specific type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Rooms WHERE bedType  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.2594", "db_id": "inn_1", "question": "What is the decor of room Recluse and defiance?", "rationale": ["Identify the relevant table: The question pertains to the decor of specific rooms, which are stored in the 'Rooms' table.", "Determine the columns needed: We need the 'decor' column to answer the question.", "Filter the results: We need to filter the rooms by their names, which are 'Recluse' and 'defiance'.", "Construct the SQL query: Use a SELECT statement to retrieve the 'decor' from the 'Rooms' table where the 'roomName' matches either 'Recluse' or 'defiance'."], "gold_sql": "SELECT decor FROM Rooms WHERE roomName  =  'Recluse and defiance';", "source_tables": ["rooms"], "pred_sql": "SELECT decor FROM Rooms WHERE roomName IN ('Recluse', 'defiance');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of room identifiers and their names from the 'Rooms' table, sorted by the base price in descending order. The placeholder in the LIMIT clause represents the maximum number of rooms to be displayed.\",\n        \"virtual_table\": \"SELECT RoomId ,  roomName FROM Rooms ORDER BY basePrice DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of reservations where the total number of occupants (adults and kids) matches the maximum occupancy allowed for each room. It joins the 'Reservations' table with the 'Rooms' table based on the room identifier, ensuring that only those reservations that meet the occupancy criteria are counted.\",\n        \"virtual_table\": \"SELECT count(*) FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T2.maxOccupancy  =  T1.Adults + T1.Kids;\"\n    }\n}\n"}
{"sample_id": "train.2604", "db_id": "inn_1", "question": "Find the first and last names of people who payed more than the rooms' base prices.", "rationale": ["Identify the relevant tables: Reservations and Rooms.", "We need to find the first and last names of guests from the Reservations table.", "We need to compare the Rate from the Reservations table with the basePrice from the Rooms table.", "To do this, we will use a subquery to select the basePrice from the Rooms table where the RoomId matches the Room in the Reservations table.", "The final query will select FirstName and LastName from Reservations where the Rate is greater than the basePrice from the Rooms table."], "gold_sql": "SELECT T1.firstname ,  T1.lastname FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T1.Rate - T2.basePrice  >  0", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT FirstName, LastName \nFROM Reservations \nWHERE Rate > (SELECT basePrice FROM Rooms WHERE Rooms.RoomId = Reservations.Room);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of room identifiers and their names from the 'Rooms' table, sorted by the base price in descending order. The placeholder in the LIMIT clause represents the maximum number of rooms to be displayed.\",\n        \"virtual_table\": \"SELECT RoomId ,  roomName FROM Rooms ORDER BY basePrice DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.2609", "db_id": "inn_1", "question": "How many rooms have a king bed?", "rationale": ["The user wants to know how many rooms have a king bed.", "We need to count the number of rooms in the 'Rooms' table where the 'bedType' is 'king'.", "The provided hint suggests using a virtual table that counts rooms based on the bed type.", "We will use the SQL query format from the hint, replacing the placeholder with 'king'."], "gold_sql": "SELECT count(*) FROM Rooms WHERE bedType  =  'King';", "source_tables": ["rooms"], "pred_sql": "SELECT count(*) FROM Rooms WHERE bedType = 'king';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of rooms from the 'Rooms' table that have a specific type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Rooms WHERE bedType  =  [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of reservations where the total number of occupants (adults and kids) matches the maximum occupancy allowed for each room. It joins the 'Reservations' table with the 'Rooms' table based on the room identifier, ensuring that only those reservations that meet the occupancy criteria are counted.\",\n        \"virtual_table\": \"SELECT count(*) FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T2.maxOccupancy  =  T1.Adults + T1.Kids;\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the total number of beds available in rooms of a specific bed type from the 'Rooms' table. The placeholder in the WHERE clause represents the type of bed being queried.\",\n        \"virtual_table\": \"SELECT sum(beds) FROM Rooms WHERE bedtype  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.2612", "db_id": "inn_1", "question": "Find the name of the room with the maximum occupancy.", "rationale": ["Identify the relevant table: The Rooms table contains the information about room names and maximum occupancy.", "Determine the requirement: We need to find the room name with the maximum occupancy.", "Use a subquery to find the maximum occupancy: The subquery (SELECT MAX(maxOccupancy) FROM Rooms) retrieves the highest maximum occupancy value from the Rooms table.", "Filter the Rooms table: The main query selects the roomName from Rooms where the maxOccupancy matches the value obtained from the subquery."], "gold_sql": "SELECT roomName FROM Rooms ORDER BY maxOccupancy DESC LIMIT 1;", "source_tables": ["rooms"], "pred_sql": "SELECT roomName FROM Rooms WHERE maxOccupancy = (SELECT MAX(maxOccupancy) FROM Rooms);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of reservations where the total number of occupants (adults and kids) matches the maximum occupancy allowed for each room. It joins the 'Reservations' table with the 'Rooms' table based on the room identifier, ensuring that only those reservations that meet the occupancy criteria are counted.\",\n        \"virtual_table\": \"SELECT count(*) FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T2.maxOccupancy  =  T1.Adults + T1.Kids;\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of room identifiers and their names from the 'Rooms' table, sorted by the base price in descending order. The placeholder in the LIMIT clause represents the maximum number of rooms to be displayed.\",\n        \"virtual_table\": \"SELECT RoomId ,  roomName FROM Rooms ORDER BY basePrice DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the total number of beds available in rooms of a specific bed type from the 'Rooms' table. The placeholder in the WHERE clause represents the type of bed being queried.\",\n        \"virtual_table\": \"SELECT sum(beds) FROM Rooms WHERE bedtype  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.2621", "db_id": "inn_1", "question": "What is the average minimum and price of the rooms for each different decor.", "rationale": ["Identify the relevant table: The Rooms table contains the necessary information about room decor and prices.", "Determine the required calculations: We need to calculate the average price of rooms, which involves using the AVG() function.", "Group the results: Since we want the average price for each different decor, we will use GROUP BY on the decor column.", "Select the appropriate columns: We will select the decor column and the average price calculated from the basePrice column."], "gold_sql": "SELECT decor , avg(basePrice) ,  min(basePrice) FROM Rooms GROUP BY decor;", "source_tables": ["rooms"], "pred_sql": "SELECT decor, AVG(basePrice) AS average_price FROM Rooms GROUP BY decor;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of room identifiers and their names from the 'Rooms' table, sorted by the base price in descending order. The placeholder in the LIMIT clause represents the maximum number of rooms to be displayed.\",\n        \"virtual_table\": \"SELECT RoomId ,  roomName FROM Rooms ORDER BY basePrice DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.2628", "db_id": "inn_1", "question": "List the name of rooms with king or queen bed.", "rationale": ["The user wants to list the names of rooms with specific bed types: king or queen.", "To achieve this, we need to select the 'roomName' column from the 'Rooms' table.", "We will apply a filter using the WHERE clause to specify that the 'bedType' must be either 'king' or 'queen'.", "The SQL query will use the IN operator to check for both bed types in a single condition."], "gold_sql": "SELECT roomName FROM Rooms WHERE bedType  =  'King' OR bedType  =  'Queen';", "source_tables": ["rooms"], "pred_sql": "SELECT roomName FROM Rooms WHERE bedType IN ('king', 'queen');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of rooms from the 'Rooms' table that have a specific type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Rooms WHERE bedType  =  [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of room identifiers and their names from the 'Rooms' table, sorted by the base price in descending order. The placeholder in the LIMIT clause represents the maximum number of rooms to be displayed.\",\n        \"virtual_table\": \"SELECT RoomId ,  roomName FROM Rooms ORDER BY basePrice DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.2639", "db_id": "inn_1", "question": "For each room, find its name and the number of times reservations were made for it.", "rationale": ["We need to find the name of each room and the number of times reservations were made for it.", "To achieve this, we will select the room name from the Rooms table.", "We will also count the number of reservations associated with each room. This can be done using the COUNT function on the reservation code from the Reservations table.", "We will perform a LEFT JOIN between the Rooms table and the Reservations table on the RoomId and Room columns respectively to ensure we include rooms even if they have no reservations.", "Finally, we will group the results by the RoomId and roomName to get the count of reservations for each room."], "gold_sql": "SELECT T2.roomName ,  count(*) ,  T1.Room FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT Rooms.roomName, COUNT(Reservations.Code) AS reservationCount \nFROM Rooms \nLEFT JOIN Reservations ON Rooms.RoomId = Reservations.Room \nGROUP BY Rooms.RoomId, Rooms.roomName;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of reservations where the total number of occupants (adults and kids) matches the maximum occupancy allowed for each room. It joins the 'Reservations' table with the 'Rooms' table based on the room identifier, ensuring that only those reservations that meet the occupancy criteria are counted.\",\n        \"virtual_table\": \"SELECT count(*) FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T2.maxOccupancy  =  T1.Adults + T1.Kids;\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of room identifiers and their names from the 'Rooms' table, sorted by the base price in descending order. The placeholder in the LIMIT clause represents the maximum number of rooms to be displayed.\",\n        \"virtual_table\": \"SELECT RoomId ,  roomName FROM Rooms ORDER BY basePrice DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of rooms from the 'Rooms' table that have a specific type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Rooms WHERE bedType  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.2846", "db_id": "customer_deliveries", "question": "Show the details of all trucks in the order of their license number.", "rationale": ["Identify the table needed: The question asks for details of trucks, so we will use the 'Trucks' table.", "Select all columns: We need all details, so we will use '*' to select all columns from the 'Trucks' table.", "Order by license number: The question specifies to order the results by the truck license number, which corresponds to the 'truck_licence_number' column.", "Construct the SQL query: Combine the SELECT statement with the ORDER BY clause to form the complete SQL query."], "gold_sql": "SELECT truck_details FROM trucks ORDER BY truck_licence_number", "source_tables": ["trucks"], "pred_sql": "SELECT * FROM Trucks ORDER BY truck_licence_number;", "hint": "\n"}
{"sample_id": "train.2848", "db_id": "customer_deliveries", "question": "Find the names of customers who are not living in the state of California.", "rationale": ["Identify the relevant tables: Customers, Customer_Addresses, and Addresses.", "We need to find customer names, so we will select 'customer_name' from the Customers table.", "To filter customers based on their address, we will join the Customers table with Customer_Addresses on 'customer_id'.", "Next, we will join Customer_Addresses with Addresses on 'address_id' to access the state information.", "We will apply a WHERE clause to filter out customers whose state is 'California'."], "gold_sql": "SELECT customer_name FROM customers EXCEPT SELECT t1.customer_name FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id WHERE t3.state_province_county  =  'California'", "source_tables": ["addresses", "customers", "customer_addresses"], "pred_sql": "SELECT customer_name FROM Customers c\nJOIN Customer_Addresses ca ON c.customer_id = ca.customer_id\nJOIN Addresses a ON ca.address_id = a.address_id\nWHERE a.state_province_county != 'California';", "hint": "\n"}
{"sample_id": "train.2856", "db_id": "customer_deliveries", "question": "Find the name of route that has the highest number of deliveries.", "rationale": ["Identify the table that contains the route information, which is the Delivery_Routes table.", "Identify the table that contains the delivery information, which is the Order_Deliveries table.", "To find the route with the highest number of deliveries, we need to count the number of deliveries for each route. We can do this by grouping the Order_Deliveries by route_id and counting the number of entries for each route.", "We will order the results of this count in descending order to get the route with the highest number of deliveries at the top.", "Finally, we will select the route_name from the Delivery_Routes table where the route_id matches the one with the highest count from the previous step."], "gold_sql": "SELECT t1.route_name FROM Delivery_Routes AS t1 JOIN Delivery_Route_Locations AS t2 ON t1.route_id  =  t2.route_id GROUP BY t1.route_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["delivery_route_locations", "delivery_routes"], "pred_sql": "SELECT route_name FROM Delivery_Routes WHERE route_id = (SELECT route_id FROM Order_Deliveries GROUP BY route_id ORDER BY COUNT(*) DESC LIMIT 1);", "hint": "\n"}
{"sample_id": "train.3175", "db_id": "college_1", "question": "How many professors are teaching class with code ACCT-211?", "rationale": ["Identify the relevant tables: CLASS and EMPLOYEE.", "We need to count the number of professors teaching a specific class, so we will use the COUNT() function.", "Join the CLASS table with the EMPLOYEE table on the professor's identifier (PROF_NUM) to get the professors associated with the class.", "Filter the results to only include the class with the code 'ACCT-211'.", "Select the count of professors from the filtered results."], "gold_sql": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["class"], "pred_sql": "SELECT COUNT(*) AS professor_count \nFROM CLASS AS T1 \nJOIN EMPLOYEE AS T2 ON T1.PROF_NUM = T2.EMP_NUM \nWHERE T1.CLASS_CODE = 'ACCT-211';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of professors and the course codes they teach from the 'CLASS' and 'EMPLOYEE' tables. The join condition links the professor's identifier in the 'CLASS' table to the corresponding identifier in the 'EMPLOYEE' table.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T1.crs_code FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num\"\n    }\n}\n"}
{"sample_id": "train.3176", "db_id": "college_1", "question": "How many professors teach a class with the code ACCT-211?", "rationale": ["Identify the tables involved: CLASS and EMPLOYEE.", "We need to count the number of distinct professors teaching a specific class, so we will use COUNT(DISTINCT) to avoid counting the same professor multiple times.", "Join the CLASS table with the EMPLOYEE table on the professor's identifier (PROF_NUM).", "Filter the results to only include the class with the code 'ACCT-211'.", "Select the count of distinct professors from the result."], "gold_sql": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["class"], "pred_sql": "SELECT COUNT(DISTINCT T2.emp_fname) AS professor_count \nFROM CLASS AS T1 \nJOIN EMPLOYEE AS T2 ON T1.PROF_NUM = T2.EMP_NUM \nWHERE T1.CLASS_CODE = 'ACCT-211';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of professors and the course codes they teach from the 'CLASS' and 'EMPLOYEE' tables. The join condition links the professor's identifier in the 'CLASS' table to the corresponding identifier in the 'EMPLOYEE' table.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T1.crs_code FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num\"\n    }\n}\n"}
{"sample_id": "train.3179", "db_id": "college_1", "question": "What are the first names and date of birth of professors teaching course ACCT-211?", "rationale": ["Identify the tables involved: CLASS, EMPLOYEE, and COURSE.", "We need the first names and date of birth of professors, which are in the EMPLOYEE table.", "The CLASS table contains the course codes and professor identifiers.", "Join the CLASS table with the EMPLOYEE table on the professor's identifier (PROF_NUM).", "Join the CLASS table with the COURSE table to filter by the specific course code 'ACCT-211'.", "Select the first names and date of birth from the EMPLOYEE table where the course code matches 'ACCT-211'."], "gold_sql": "SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["employee", "class"], "pred_sql": "SELECT T2.emp_fname, T2.emp_dob \nFROM CLASS AS T1 \nJOIN EMPLOYEE AS T2 ON T1.PROF_NUM = T2.EMP_NUM \nJOIN COURSE AS T3 ON T1.CRS_CODE = T3.CRS_CODE \nWHERE T3.CRS_CODE = 'ACCT-211';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of professors and the course codes they teach from the 'CLASS' and 'EMPLOYEE' tables. The join condition links the professor's identifier in the 'CLASS' table to the corresponding identifier in the 'EMPLOYEE' table.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T1.crs_code FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first names of employees, the office locations of professors, and descriptions of courses from the respective tables. The data is retrieved by joining the 'CLASS' table with the 'EMPLOYEE', 'COURSE', and 'PROFESSOR' tables based on their relationships, specifically linking professors to their classes and courses.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num\"\n    }\n}\n"}
{"sample_id": "train.3188", "db_id": "college_1", "question": "Where is the history department?", "rationale": ["Identify the relevant table: The 'DEPARTMENT' table contains information about department names.", "Determine the specific department: The user is asking for the 'history department'.", "Construct the SQL query: Use a SELECT statement to retrieve the 'dept_name' from the 'DEPARTMENT' table where 'dept_name' matches 'History'."], "gold_sql": "SELECT dept_address FROM department WHERE dept_name  =  'History'", "source_tables": ["department"], "pred_sql": "SELECT dept_name FROM department WHERE dept_name = 'History'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department names associated with students, ordered by their GPA. The placeholder in the LIMIT clause allows for specifying the maximum number of department names to retrieve.\",\n        \"virtual_table\": \"SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of department names associated with students, ordered by their GPA. The placeholder in the LIMIT clause allows for specifying the maximum number of department names to retrieve.\",\n        \"virtual_table\": \"SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of courses offered by a specific department from the 'DEPARTMENT' and 'COURSE' tables. The placeholder in the WHERE clause represents the name of the department for which the course count is being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM department AS T1 JOIN course AS T2 ON T1.dept_code  =  T2.dept_code WHERE dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3190", "db_id": "college_1", "question": "What are the different locations of the school with the code BUS?", "rationale": ["Identify the table that contains school locations, which is the DEPARTMENT table.", "Determine the relevant column for locations, which is DEPT_ADDRESS.", "Identify the condition needed to filter the results, which is the SCHOOL_CODE being 'BUS'.", "Construct the SQL query to select distinct addresses from the DEPARTMENT table where the SCHOOL_CODE matches 'BUS'."], "gold_sql": "SELECT count(DISTINCT dept_address) FROM department WHERE school_code  =  'BUS'", "source_tables": ["department"], "pred_sql": "SELECT DISTINCT DEPT_ADDRESS FROM DEPARTMENT WHERE SCHOOL_CODE = 'BUS';", "hint": "\n"}
{"sample_id": "train.3201", "db_id": "college_1", "question": "What is the total credit does each department offer?", "rationale": ["We need to find the total credit hours offered by each department.", "To do this, we will join the DEPARTMENT table with the COURSE table using the DEPT_CODE.", "We will then sum the CRS_CREDIT from the COURSE table for each department.", "Finally, we will group the results by DEPT_NAME to get the total credit hours for each department."], "gold_sql": "SELECT sum(crs_credit) ,  dept_code FROM course GROUP BY dept_code", "source_tables": ["course"], "pred_sql": "SELECT D.DEPT_NAME, SUM(C.CRS_CREDIT) AS TOTAL_CREDIT\nFROM DEPARTMENT D\nJOIN COURSE C ON D.DEPT_CODE = C.DEPT_CODE\nGROUP BY D.DEPT_NAME;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department names associated with students, ordered by their GPA. The placeholder in the LIMIT clause allows for specifying the maximum number of department names to retrieve.\",\n        \"virtual_table\": \"SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of department names associated with students, ordered by their GPA. The placeholder in the LIMIT clause allows for specifying the maximum number of department names to retrieve.\",\n        \"virtual_table\": \"SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of courses offered by a specific department from the 'DEPARTMENT' and 'COURSE' tables. The placeholder in the WHERE clause represents the name of the department for which the course count is being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM department AS T1 JOIN course AS T2 ON T1.dept_code  =  T2.dept_code WHERE dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3202", "db_id": "college_1", "question": "How many credits does the department offer?", "rationale": ["The question asks for the total credits offered by the department.", "To find this, we need to sum the credits from the COURSE table.", "The COURSE table contains the CRS_CREDIT column which represents the number of credit hours for each course.", "We need to join the COURSE table with the DEPARTMENT table to ensure we are considering the courses offered by the department.", "The join is done on the DEPT_CODE column present in both tables.", "Finally, we use the SUM function to calculate the total credits offered by the department."], "gold_sql": "SELECT sum(crs_credit) ,  dept_code FROM course GROUP BY dept_code", "source_tables": ["course"], "pred_sql": "SELECT SUM(CRS_CREDIT) FROM COURSE AS T1 JOIN DEPARTMENT AS T2 ON T1.DEPT_CODE = T2.DEPT_CODE;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of courses offered by a specific department from the 'DEPARTMENT' and 'COURSE' tables. The placeholder in the WHERE clause represents the name of the department for which the course count is being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM department AS T1 JOIN course AS T2 ON T1.dept_code  =  T2.dept_code WHERE dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of department names associated with students, ordered by their GPA. The placeholder in the LIMIT clause allows for specifying the maximum number of department names to retrieve.\",\n        \"virtual_table\": \"SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of department names associated with students, ordered by their GPA. The placeholder in the LIMIT clause allows for specifying the maximum number of department names to retrieve.\",\n        \"virtual_table\": \"SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3213", "db_id": "college_1", "question": "Which school has the smallest amount of professors?", "rationale": ["Identify the relevant table: The PROFESSOR table contains information about professors and their associated school codes.", "Count the number of professors per school: Use COUNT(PROF_NUM) to count the number of professors for each SCHOOL_CODE.", "Group the results by school: Use GROUP BY SCHOOL_CODE to aggregate the counts by school.", "Order the results to find the smallest count: Use ORDER BY professor_count ASC to sort the counts in ascending order.", "Limit the results to the smallest count: Use LIMIT 1 to return only the school with the smallest number of professors."], "gold_sql": "SELECT T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code ORDER BY count(*) LIMIT 1", "source_tables": ["department", "professor"], "pred_sql": "SELECT SCHOOL_CODE, COUNT(PROF_NUM) AS professor_count\nFROM PROFESSOR\nGROUP BY SCHOOL_CODE\nORDER BY professor_count ASC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3215", "db_id": "college_1", "question": "Find the number of professors with a Ph.D. degree in each department.", "rationale": ["We need to find the number of professors with a Ph.D. degree in each department.", "The relevant tables are PROFESSOR (which contains information about professors including their highest degree) and DEPARTMENT (which contains information about departments).", "We will join the PROFESSOR table with the DEPARTMENT table on the DEPT_CODE to associate professors with their respective departments.", "We will filter the results to include only those professors whose PROF_HIGH_DEGREE is 'Ph.D.' using a WHERE clause.", "Finally, we will group the results by DEPARTMENT.DEPT_NAME and count the number of professors in each department using COUNT()."], "gold_sql": "SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  'Ph.D.' GROUP BY dept_code", "source_tables": ["professor"], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME, COUNT(PROFESSOR.EMP_NUM) AS NumberOfProfessors\nFROM PROFESSOR\nJOIN DEPARTMENT ON PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE\nWHERE PROFESSOR.PROF_HIGH_DEGREE = 'Ph.D.'\nGROUP BY DEPARTMENT.DEPT_NAME;", "hint": "\n"}
{"sample_id": "train.3217", "db_id": "college_1", "question": "Find the number of students for each department.", "rationale": ["We need to find the number of students for each department.", "To do this, we will join the DEPARTMENT table with the STUDENT table on the DEPT_CODE column, which is the foreign key in the STUDENT table that references the DEPARTMENT table.", "We will select the department name from the DEPARTMENT table and count the number of students from the STUDENT table.", "We will group the results by the department name to get the count of students for each department."], "gold_sql": "SELECT count(*) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT D.DEPT_NAME, COUNT(S.STU_NUM) AS NUM_STUDENTS \nFROM DEPARTMENT AS D \nJOIN STUDENT AS S ON D.DEPT_CODE = S.DEPT_CODE \nGROUP BY D.DEPT_NAME;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of courses offered by a specific department from the 'DEPARTMENT' and 'COURSE' tables. The placeholder in the WHERE clause represents the name of the department for which the course count is being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM department AS T1 JOIN course AS T2 ON T1.dept_code  =  T2.dept_code WHERE dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of department names associated with students, ordered by their GPA. The placeholder in the LIMIT clause allows for specifying the maximum number of department names to retrieve.\",\n        \"virtual_table\": \"SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of department names associated with students, ordered by their GPA. The placeholder in the LIMIT clause allows for specifying the maximum number of department names to retrieve.\",\n        \"virtual_table\": \"SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3219", "db_id": "college_1", "question": "Find the total number of hours have done for all students in each department.", "rationale": ["Identify the tables needed: STUDENT for student hours and DEPARTMENT for department names.", "Join the STUDENT table with the DEPARTMENT table on DEPT_CODE to associate students with their respective departments.", "Use the SUM function to calculate the total hours (STU_HRS) for each department.", "Group the results by department name (DEPT_NAME) to get the total hours per department."], "gold_sql": "SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT D.DEPT_NAME, SUM(S.STU_HRS) AS TOTAL_HOURS\nFROM STUDENT S\nJOIN DEPARTMENT D ON S.DEPT_CODE = D.DEPT_CODE\nGROUP BY D.DEPT_NAME;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department names associated with students, ordered by their GPA. The placeholder in the LIMIT clause allows for specifying the maximum number of department names to retrieve.\",\n        \"virtual_table\": \"SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3240", "db_id": "college_1", "question": "Which department offers the most credits all together?", "rationale": ["We need to find out which department offers the most credits in total.", "To do this, we will join the DEPARTMENT table with the COURSE table on the DEPT_CODE column.", "We will then sum the CRS_CREDIT from the COURSE table for each department.", "We will group the results by department name to get the total credits per department.", "Finally, we will order the results in descending order based on the total credits and limit the output to 1 to get the department with the highest total credits."], "gold_sql": "SELECT T3.dept_name FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code JOIN department AS T3 ON T1.dept_code  =  T3.dept_code GROUP BY T1.dept_code ORDER BY sum(T1.crs_credit) DESC LIMIT 1", "source_tables": ["course", "department", "class"], "pred_sql": "SELECT D.DEPT_NAME, SUM(C.CRS_CREDIT) AS TOTAL_CREDITS\nFROM DEPARTMENT D\nJOIN COURSE C ON D.DEPT_CODE = C.DEPT_CODE\nGROUP BY D.DEPT_NAME\nORDER BY TOTAL_CREDITS DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of courses offered by a specific department from the 'DEPARTMENT' and 'COURSE' tables. The placeholder in the WHERE clause represents the name of the department for which the course count is being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM department AS T1 JOIN course AS T2 ON T1.dept_code  =  T2.dept_code WHERE dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of department names associated with students, ordered by their GPA. The placeholder in the LIMIT clause allows for specifying the maximum number of department names to retrieve.\",\n        \"virtual_table\": \"SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of department names associated with students, ordered by their GPA. The placeholder in the LIMIT clause allows for specifying the maximum number of department names to retrieve.\",\n        \"virtual_table\": \"SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3243", "db_id": "college_1", "question": "What is the first name of each student enrolled in class ACCT-211?", "rationale": ["Identify the tables involved: STUDENT, ENROLL, and CLASS.", "We need to find the first names of students, so we will select STUDENT.STU_FNAME.", "Students are enrolled in classes, so we will join the ENROLL table with the STUDENT table on STU_NUM.", "Next, we need to join the CLASS table to filter by the specific class code 'ACCT-211'.", "The final SQL query will select the first names of students who are enrolled in the specified class."], "gold_sql": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  'ACCT-211'", "source_tables": ["student", "class", "enroll"], "pred_sql": "SELECT STUDENT.STU_FNAME\nFROM STUDENT\nJOIN ENROLL ON STUDENT.STU_NUM = ENROLL.STU_NUM\nJOIN CLASS ON ENROLL.CLASS_CODE = CLASS.CLASS_CODE\nWHERE CLASS.CLASS_CODE = 'ACCT-211';", "hint": "\n"}
{"sample_id": "train.3245", "db_id": "college_1", "question": "What is the first name of students enrolled in class ACCT-211 and got grade C?", "rationale": ["Identify the tables needed: STUDENT, ENROLL, CLASS.", "We need to find the first names of students, so we will select the 'STU_FNAME' column from the STUDENT table.", "Students are enrolled in classes, so we will join the ENROLL table to link students with their classes using 'STU_NUM'.", "We also need to join the CLASS table to filter by the specific class code 'ACCT-211'.", "Finally, we need to filter the results to only include students who received a grade of 'C' in that class."], "gold_sql": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  'ACCT-211' AND T2.enroll_grade  =  'C'", "source_tables": ["student", "class", "enroll"], "pred_sql": "SELECT S.STU_FNAME \nFROM STUDENT AS S \nJOIN ENROLL AS E ON S.STU_NUM = E.STU_NUM \nJOIN CLASS AS C ON E.CLASS_CODE = C.CLASS_CODE \nWHERE C.CLASS_CODE = 'ACCT-211' AND E.ENROLL_GRADE = 'C';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department names associated with students, ordered by their GPA. The placeholder in the LIMIT clause allows for specifying the maximum number of department names to retrieve.\",\n        \"virtual_table\": \"SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of department names associated with students, ordered by their GPA. The placeholder in the LIMIT clause allows for specifying the maximum number of department names to retrieve.\",\n        \"virtual_table\": \"SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3254", "db_id": "college_1", "question": "What is the name of the department with the most students enrolled?", "rationale": ["Identify the relevant tables: We need to find the department with the most students enrolled, which involves the STUDENT and DEPARTMENT tables.", "Count the number of students in each department: We can use the ENROLL table to count how many students are enrolled in each department by grouping by DEPT_CODE.", "Order the departments by the count of students: We will order the results in descending order to get the department with the highest count first.", "Limit the results to the top department: We will use LIMIT 1 to get only the department with the most students.", "Join the DEPARTMENT table to get the department name: Finally, we will join the DEPARTMENT table to get the name of the department corresponding to the DEPT_CODE with the highest student count."], "gold_sql": "SELECT T4.dept_name FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code GROUP BY T3.dept_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["course", "department", "class", "enroll"], "pred_sql": "SELECT dept_name FROM department WHERE dept_code IN (SELECT dept_code FROM student GROUP BY dept_code ORDER BY COUNT(stu_num) DESC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department names associated with students, ordered by their GPA. The placeholder in the LIMIT clause allows for specifying the maximum number of department names to retrieve.\",\n        \"virtual_table\": \"SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of department names associated with students, ordered by their GPA. The placeholder in the LIMIT clause allows for specifying the maximum number of department names to retrieve.\",\n        \"virtual_table\": \"SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3257", "db_id": "college_1", "question": "List the codes of all courses that take place in room KLR209.", "rationale": ["Identify the relevant table: The CLASS table contains information about classes, including the room where they are held.", "Determine the required columns: We need the CRS_CODE of the courses, which is in the CLASS table.", "Specify the condition: We want to filter the results to only include classes that take place in room 'KLR209'.", "Construct the SQL query: Use SELECT to get the distinct CRS_CODE from the CLASS table where the CLASS_ROOM is 'KLR209'."], "gold_sql": "SELECT class_code FROM CLASS WHERE class_room  =  'KLR209'", "source_tables": ["class"], "pred_sql": "SELECT DISTINCT CRS_CODE FROM CLASS WHERE CLASS_ROOM = 'KLR209';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of students enrolled in classes associated with a specific course code from the 'CLASS' and 'ENROLL' tables. The placeholder in the WHERE clause represents the course code for which the enrollment count is being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code WHERE T1.crs_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3258", "db_id": "college_1", "question": "What are the codes of all the courses that are located in room KLR209?", "rationale": ["Identify the relevant table: The question is about courses and their locations, so we will focus on the CLASS table, which contains the CLASS_ROOM and CRS_CODE.", "Formulate the SQL query: We need to select the CRS_CODE from the CLASS table where the CLASS_ROOM matches 'KLR209'.", "Construct the final SQL query: The SQL query is constructed as 'SELECT CRS_CODE FROM CLASS WHERE CLASS_ROOM = 'KLR209';'."], "gold_sql": "SELECT class_code FROM CLASS WHERE class_room  =  'KLR209'", "source_tables": ["class"], "pred_sql": "SELECT CRS_CODE FROM CLASS WHERE CLASS_ROOM = 'KLR209';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of students enrolled in classes associated with a specific course code from the 'CLASS' and 'ENROLL' tables. The placeholder in the WHERE clause represents the course code for which the enrollment count is being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code WHERE T1.crs_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first names of professors and the course codes they teach from the 'CLASS' and 'EMPLOYEE' tables. The join condition links the professor's identifier in the 'CLASS' table to the corresponding identifier in the 'EMPLOYEE' table.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T1.crs_code FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num\"\n    }\n}\n"}
{"sample_id": "train.3267", "db_id": "college_1", "question": "What is the first name of students who got grade C in any class?", "rationale": ["Identify the relevant tables: STUDENT and ENROLL are needed since we want student names and their grades.", "We need to join the STUDENT and ENROLL tables on the student identifier (STU_NUM) to link students with their grades.", "We are interested in students who received a grade of 'C', so we will filter the results using a WHERE clause on ENROLL_GRADE.", "To avoid duplicate names, we will use DISTINCT to ensure each student's first name appears only once in the results."], "gold_sql": "SELECT DISTINCT stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE enroll_grade  =  'C'", "source_tables": ["enroll", "student"], "pred_sql": "SELECT DISTINCT STUDENT.STU_FNAME \nFROM STUDENT \nJOIN ENROLL ON STUDENT.STU_NUM = ENROLL.STU_NUM \nWHERE ENROLL.ENROLL_GRADE = 'C';", "hint": "\n"}
{"sample_id": "train.3273", "db_id": "college_1", "question": "What are the first names of the professors who do not teach a class.", "rationale": ["Identify the relevant tables: We need to find professors from the EMPLOYEE table who do not teach any classes, which are represented in the CLASS table.", "Determine the relationship: The CLASS table has a foreign key 'prof_num' that links to the 'EMP_NUM' in the EMPLOYEE table, indicating which professor teaches which class.", "Create a subquery: We can create a subquery that selects 'prof_num' from the CLASS table to find all professors who teach classes.", "Use NOT IN: We will use the NOT IN clause to filter out professors who are present in the subquery from the EMPLOYEE table, thus getting only those professors who do not teach any classes.", "Select the first names: Finally, we will select the 'emp_fname' from the EMPLOYEE table for those professors who do not teach any classes."], "gold_sql": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  'PROF' EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num", "source_tables": ["employee", "class"], "pred_sql": "SELECT emp_fname FROM EMPLOYEE WHERE emp_num NOT IN (SELECT prof_num FROM CLASS)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of professors and the course codes they teach from the 'CLASS' and 'EMPLOYEE' tables. The join condition links the professor's identifier in the 'CLASS' table to the corresponding identifier in the 'EMPLOYEE' table.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T1.crs_code FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first names of employees, the office locations of professors, and descriptions of courses from the respective tables. The data is retrieved by joining the 'CLASS' table with the 'EMPLOYEE', 'COURSE', and 'PROFESSOR' tables based on their relationships, specifically linking professors to their classes and courses.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num\"\n    }\n}\n"}
{"sample_id": "train.3274", "db_id": "college_1", "question": "What are the first names of all professors not teaching any classes?", "rationale": ["Identify the relevant tables: We need the 'EMPLOYEE' table to get the first names of professors and the 'CLASS' table to determine which professors are teaching classes.", "Determine the relationship: We need to find professors who are not present in the 'CLASS' table. This means we will look for professors whose identifiers (prof_num) do not appear in the CLASS table.", "Construct the subquery: The subquery will select all professor identifiers (prof_num) from the 'CLASS' table.", "Construct the main query: The main query will select the first names (emp_fname) from the 'EMPLOYEE' table where the employee number (emp_num) is not in the list of identifiers returned by the subquery."], "gold_sql": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  'PROF' EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num", "source_tables": ["employee", "class"], "pred_sql": "SELECT emp_fname FROM EMPLOYEE WHERE emp_num NOT IN (SELECT prof_num FROM CLASS)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of professors and the course codes they teach from the 'CLASS' and 'EMPLOYEE' tables. The join condition links the professor's identifier in the 'CLASS' table to the corresponding identifier in the 'EMPLOYEE' table.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T1.crs_code FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first names of employees, the office locations of professors, and descriptions of courses from the respective tables. The data is retrieved by joining the 'CLASS' table with the 'EMPLOYEE', 'COURSE', and 'PROFESSOR' tables based on their relationships, specifically linking professors to their classes and courses.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num\"\n    }\n}\n"}
{"sample_id": "train.3288", "db_id": "college_1", "question": "How many professors attained either Ph.D. or Masters degrees?", "rationale": ["Identify the table that contains information about professors, which is the PROFESSOR table.", "Determine the column that indicates the highest degree obtained by the professors, which is the PROF_HIGH_DEGREE column.", "We need to count the number of professors who have either a Ph.D. or a Masters degree.", "Use the COUNT function to count the number of rows that meet the criteria.", "Construct the SQL query to select the count from the PROFESSOR table where the PROF_HIGH_DEGREE is either 'Ph.D.' or 'Masters'."], "gold_sql": "SELECT count(*) FROM professor WHERE prof_high_degree  =  'Ph.D.' OR prof_high_degree  =  'MA'", "source_tables": ["professor"], "pred_sql": "SELECT COUNT(*) AS NumberOfProfessors\nFROM PROFESSOR\nWHERE PROFESSOR.PROF_HIGH_DEGREE IN ('Ph.D.', 'Masters');", "hint": "\n"}
{"sample_id": "train.3292", "db_id": "college_1", "question": "What is the first name of the professor who is teaching CIS-220 and QM-261?", "rationale": ["Identify the relevant tables: CLASS and EMPLOYEE.", "We need to find the first names of professors, which are in the EMPLOYEE table.", "The CLASS table contains the course codes that link to the professors through the PROF_NUM.", "We will join the CLASS table with the EMPLOYEE table on the PROF_NUM and EMP_NUM columns.", "We need to filter the results to only include the courses CIS-220 and QM-261.", "Use the IN clause to specify the course codes we are interested in."], "gold_sql": "SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  'CIS-220' INTERSECT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  'QM-261'", "source_tables": ["employee", "class"], "pred_sql": "SELECT T2.emp_fname FROM CLASS AS T1 JOIN EMPLOYEE AS T2 ON T1.prof_num = T2.emp_num WHERE T1.crs_code IN ('CIS-220', 'QM-261')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of professors and the course codes they teach from the 'CLASS' and 'EMPLOYEE' tables. The join condition links the professor's identifier in the 'CLASS' table to the corresponding identifier in the 'EMPLOYEE' table.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T1.crs_code FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first names of employees, the office locations of professors, and descriptions of courses from the respective tables. The data is retrieved by joining the 'CLASS' table with the 'EMPLOYEE', 'COURSE', and 'PROFESSOR' tables based on their relationships, specifically linking professors to their classes and courses.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num\"\n    }\n}\n"}
{"sample_id": "train.3293", "db_id": "college_1", "question": "Find the first name of student who is taking classes from accounting and Computer Info. Systems departments", "rationale": ["We need to find the first names of students enrolled in classes from specific departments: Accounting and Computer Info. Systems.", "To achieve this, we will join the STUDENT table with the ENROLL table to get the classes each student is enrolled in.", "Next, we will join the CLASS table to link the classes to their respective courses.", "Then, we will join the COURSE table to access the department codes associated with each course.", "Finally, we will join the DEPARTMENT table to filter the results based on the department names 'Accounting' and 'Computer Info. Systems'.", "We will use DISTINCT to ensure that we only get unique first names of students."], "gold_sql": "SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Accounting' INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Computer Info. Systems'", "source_tables": ["course", "enroll", "department", "class", "student"], "pred_sql": "SELECT DISTINCT S.STU_FNAME \nFROM STUDENT AS S \nJOIN ENROLL AS E ON S.STU_NUM = E.STU_NUM \nJOIN CLASS AS C ON E.CLASS_CODE = C.CLASS_CODE \nJOIN COURSE AS CRS ON C.CRS_CODE = CRS.CRS_CODE \nJOIN DEPARTMENT AS D ON CRS.DEPT_CODE = D.DEPT_CODE \nWHERE D.DEPT_NAME IN ('Accounting', 'Computer Info. Systems');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first names of employees, the office locations of professors, and descriptions of courses from the respective tables. The data is retrieved by joining the 'CLASS' table with the 'EMPLOYEE', 'COURSE', and 'PROFESSOR' tables based on their relationships, specifically linking professors to their classes and courses.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first names of professors and the course codes they teach from the 'CLASS' and 'EMPLOYEE' tables. The join condition links the professor's identifier in the 'CLASS' table to the corresponding identifier in the 'EMPLOYEE' table.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T1.crs_code FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num\"\n    }\n}\n"}
{"sample_id": "train.3308", "db_id": "college_1", "question": "What are the first names and office of the professors who are in the history department and have a Ph.D?", "rationale": ["Identify the tables needed: PROFESSOR and DEPARTMENT.", "We need to get the first names and office locations of professors, so we will select 'emp_fname' and 'prof_office' from the PROFESSOR table.", "To filter for professors in the History department, we need to join the PROFESSOR table with the DEPARTMENT table on 'dept_code'.", "We will add a WHERE clause to filter for the department name 'History' and for professors who have a Ph.D. by checking 'prof_high_degree'.", "Construct the SQL query using the selected columns and the join condition."], "gold_sql": "SELECT T1.emp_fname ,  T2.prof_office FROM employee AS T1 JOIN professor AS T2 ON T1.emp_num  =  T2.emp_num JOIN department AS T3 ON T3.dept_code  =  T2.dept_code WHERE T3.dept_name  =  'History' AND T2.prof_high_degree  =  'Ph.D.'", "source_tables": ["employee", "professor", "department"], "pred_sql": "SELECT T2.emp_fname, T2.prof_office FROM PROFESSOR AS T2 JOIN DEPARTMENT AS T3 ON T2.dept_code = T3.dept_code WHERE T3.dept_name = 'History' AND T2.prof_high_degree = 'Ph.D.'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of professors and the course codes they teach from the 'CLASS' and 'EMPLOYEE' tables. The join condition links the professor's identifier in the 'CLASS' table to the corresponding identifier in the 'EMPLOYEE' table.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T1.crs_code FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num\"\n    }\n}\n"}
{"sample_id": "train.3319", "db_id": "college_1", "question": "Find names of all students who took some course and got A or C.", "rationale": ["Identify the tables involved: STUDENT and ENROLL are the relevant tables since we need student names and their grades.", "We need to join the STUDENT table with the ENROLL table on the student identifier (STU_NUM) to get the grades associated with each student.", "We are interested in students who received either an 'A' or a 'C'. Therefore, we will filter the results using a WHERE clause that checks for these grades.", "To avoid duplicate names, we will use DISTINCT to ensure each student is listed only once in the final result."], "gold_sql": "SELECT T1.stu_fname ,  T1.stu_lname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE T2.enroll_grade  =  'C' OR T2.enroll_grade  =  'A'", "source_tables": ["enroll", "student"], "pred_sql": "SELECT DISTINCT S.STU_FNAME, S.STU_LNAME \nFROM STUDENT S \nJOIN ENROLL E ON S.STU_NUM = E.STU_NUM \nWHERE E.ENROLL_GRADE IN ('A', 'C');", "hint": "\n"}
{"sample_id": "train.3324", "db_id": "college_1", "question": "What are the different first names and highest degree attained for professors teaching in the Computer Information Systems department?", "rationale": ["Identify the tables needed: CLASS, EMPLOYEE, COURSE, PROFESSOR, and DEPARTMENT.", "We need to retrieve the first names of professors and their highest degrees, so we will select T2.emp_fname and T4.prof_high_degree.", "Join the CLASS table with EMPLOYEE to get professor names using the professor number.", "Join the CLASS table with COURSE to ensure we are looking at the correct courses.", "Join the PROFESSOR table to get the highest degree of the professors.", "Join the DEPARTMENT table to filter for the Computer Information Systems department.", "Use a WHERE clause to specify that we only want professors from the Computer Information Systems department.", "Group the results by professor's first name and highest degree to ensure distinct results."], "gold_sql": "SELECT DISTINCT T2.emp_fname ,  T3.prof_high_degree FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN professor AS T3 ON T2.emp_num  =  T3.emp_num JOIN department AS T4 ON T4.dept_code  =  T3.dept_code WHERE T4.dept_name  =  'Computer Info. Systems'", "source_tables": ["employee", "professor", "class", "department"], "pred_sql": "SELECT T2.emp_fname, T4.prof_high_degree \nFROM CLASS AS T1 \nJOIN EMPLOYEE AS T2 ON T1.prof_num = T2.emp_num \nJOIN COURSE AS T3 ON T1.crs_code = T3.crs_code \nJOIN PROFESSOR AS T4 ON T2.emp_num = T4.emp_num \nJOIN DEPARTMENT AS T5 ON T4.dept_code = T5.dept_code \nWHERE T5.dept_name = 'Computer Information Systems' \nGROUP BY T2.emp_fname, T4.prof_high_degree;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first names of employees, the office locations of professors, and descriptions of courses from the respective tables. The data is retrieved by joining the 'CLASS' table with the 'EMPLOYEE', 'COURSE', and 'PROFESSOR' tables based on their relationships, specifically linking professors to their classes and courses.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first names of professors and the course codes they teach from the 'CLASS' and 'EMPLOYEE' tables. The join condition links the professor's identifier in the 'CLASS' table to the corresponding identifier in the 'EMPLOYEE' table.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T1.crs_code FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num\"\n    }\n}\n"}
{"sample_id": "train.3333", "db_id": "college_1", "question": "Find the name of department that offers the class whose description has the word \"Statistics\".", "rationale": ["Identify the tables needed: DEPARTMENT and COURSE.", "We need to find the department name, so we will select DEPT_NAME from the DEPARTMENT table.", "We need to filter courses based on their description containing the word 'Statistics', so we will use the COURSE table and apply a WHERE clause with a LIKE condition.", "Join the DEPARTMENT table with the COURSE table on the DEPT_CODE to link departments with their courses.", "Construct the final SQL query to select the department name where the course description contains 'Statistics'."], "gold_sql": "SELECT T2.dept_name FROM course AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.crs_description LIKE '%Statistics%'", "source_tables": ["course", "department"], "pred_sql": "SELECT D.DEPT_NAME \nFROM DEPARTMENT D \nJOIN COURSE C ON D.DEPT_CODE = C.DEPT_CODE \nWHERE C.CRS_DESCRIPTION LIKE '%Statistics%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of courses offered by a specific department from the 'DEPARTMENT' and 'COURSE' tables. The placeholder in the WHERE clause represents the name of the department for which the course count is being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM department AS T1 JOIN course AS T2 ON T1.dept_code  =  T2.dept_code WHERE dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of department names associated with students, ordered by their GPA. The placeholder in the LIMIT clause allows for specifying the maximum number of department names to retrieve.\",\n        \"virtual_table\": \"SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of department names associated with students, ordered by their GPA. The placeholder in the LIMIT clause allows for specifying the maximum number of department names to retrieve.\",\n        \"virtual_table\": \"SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3343", "db_id": "sports_competition", "question": "What are the types and countries of competitions?", "rationale": ["Identify the relevant table: The question asks about competition types and countries, which are found in the 'competition' table.", "Select the necessary columns: We need to retrieve 'Competition_type' and 'Country' from the 'competition' table.", "Construct the SQL query: Using the identified table and columns, the SQL query is formed as 'SELECT Competition_type, Country FROM competition'."], "gold_sql": "SELECT Competition_type ,  Country FROM competition", "source_tables": ["competition"], "pred_sql": "SELECT Competition_type, Country FROM competition", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides information about the types of competitions and the countries where they are held from the 'competition' table. The placeholders represent the specific competition type and country details.\",\n        \"virtual_table\": \"SELECT Competition_type ,  Country FROM competition\"\n    }\n}\n"}
{"sample_id": "train.3355", "db_id": "sports_competition", "question": "Please show the names and the players of clubs.", "rationale": ["Identify the tables needed: 'club' for club names and 'player' for player names.", "Determine the relationship between the tables: 'club' and 'player' are linked by 'Club_ID'.", "Use a JOIN operation to combine the data from both tables based on 'Club_ID'.", "Select the desired columns: club names from the 'club' table and player names from the 'player' table."], "gold_sql": "SELECT T1.name ,  T2.Player_id FROM club AS T1 JOIN player AS T2 ON T1.Club_ID  =  T2.Club_ID", "source_tables": ["club", "player"], "pred_sql": "SELECT T1.name, T2.name FROM club AS T1 JOIN player AS T2 ON T1.Club_ID = T2.Club_ID", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of clubs along with the unique identifiers of players associated with those clubs. The join operation links the 'club' table and the 'player' table based on the common 'Club_ID' field, allowing for the retrieval of player information for each club.\",\n        \"virtual_table\": \"SELECT T1.name ,  T2.Player_id FROM club AS T1 JOIN player AS T2 ON T1.Club_ID  =  T2.Club_ID\"\n    }\n}\n"}
{"sample_id": "train.3364", "db_id": "sports_competition", "question": "What are the positions of players whose average number of points scored by that position is larger than 20?", "rationale": ["We need to find the positions of players whose average points scored is greater than 20.", "To do this, we will select the 'Position' column from the 'player' table.", "We will group the results by 'Position' to calculate the average points for each position.", "We will use the HAVING clause to filter the groups where the average points (calculated using AVG(Points)) is greater than 20."], "gold_sql": "SELECT POSITION FROM player GROUP BY name HAVING avg(Points)  >=  20", "source_tables": ["player"], "pred_sql": "SELECT Position\nFROM player\nGROUP BY Position\nHAVING AVG(Points) > 20;", "hint": "\n"}
{"sample_id": "train.3374", "db_id": "sports_competition", "question": "What are the positions of both players that have more than 20 20 points and less than 10 points?", "rationale": ["Identify the table that contains player information, which is the 'player' table.", "Determine the relevant column for player positions, which is 'Position'.", "Identify the column that contains the points scored by players, which is 'Points'.", "Formulate the condition to filter players based on their points: greater than 20 or less than 10.", "Construct the SQL query to select the 'Position' from the 'player' table where the specified conditions are met."], "gold_sql": "SELECT POSITION FROM player WHERE Points  >  20 INTERSECT SELECT POSITION FROM player WHERE Points  <  10", "source_tables": ["player"], "pred_sql": "SELECT Position FROM player WHERE Points > 20 OR Points < 10;", "hint": "\n"}
{"sample_id": "train.3383", "db_id": "sports_competition", "question": "which country did participated in the most number of Tournament competitions?", "rationale": ["Identify the relevant table: The 'competition' table contains information about competition types and countries.", "Filter for tournament competitions: We need to focus on rows where Competition_type is 'tournament'.", "Count the number of tournaments per country: Use COUNT(*) to count the number of tournaments for each country.", "Group the results by country: Use GROUP BY Country to aggregate the counts by country.", "Order the results to find the country with the most tournaments: Use ORDER BY Tournament_Count DESC to sort the results in descending order.", "Limit the results to the top country: Use LIMIT 1 to get only the country with the highest count."], "gold_sql": "SELECT country FROM competition WHERE competition_type  =  'Tournament' GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["competition"], "pred_sql": "SELECT Country, COUNT(*) as Tournament_Count \nFROM competition \nWHERE Competition_type = 'tournament' \nGROUP BY Country \nORDER BY Tournament_Count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides information about the types of competitions and the countries where they are held from the 'competition' table. The placeholders represent the specific competition type and country details.\",\n        \"virtual_table\": \"SELECT Competition_type ,  Country FROM competition\"\n    }\n}\n"}
{"sample_id": "train.3384", "db_id": "sports_competition", "question": "what is the name of the country that participated in the most tournament competitions?", "rationale": ["Identify the relevant table: The 'competition' table contains information about competition types and countries.", "Filter for tournament competitions: We need to focus on competitions that are of type 'tournament'.", "Count the occurrences: We will count how many tournaments each country has participated in using COUNT().", "Group by country: To get the count per country, we will use GROUP BY Country.", "Order the results: We will order the results in descending order to find the country with the most tournaments.", "Limit the results: We will limit the results to 1 to get only the top country."], "gold_sql": "SELECT country FROM competition WHERE competition_type  =  'Tournament' GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["competition"], "pred_sql": "SELECT Country, COUNT(*) AS Tournament_Count\nFROM competition\nWHERE Competition_type = 'tournament'\nGROUP BY Country\nORDER BY Tournament_Count DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides information about the types of competitions and the countries where they are held from the 'competition' table. The placeholders represent the specific competition type and country details.\",\n        \"virtual_table\": \"SELECT Competition_type ,  Country FROM competition\"\n    }\n}\n"}
{"sample_id": "train.3388", "db_id": "sports_competition", "question": "What are the countries that have never participated in any friendly-type competitions?", "rationale": ["Identify the relevant table: The 'competition' table contains information about competition types and countries.", "Determine the competition type: We are interested in 'friendly' type competitions.", "Select countries that have participated in friendly competitions: Use a SELECT statement to get distinct countries where the competition type is 'friendly'.", "Select countries that have participated in any competition: Use a SELECT statement to get distinct countries from the competition table.", "Use EXCEPT to find countries that have never participated in friendly competitions: Subtract the list of countries that have participated in friendly competitions from the list of all countries that have participated in any competition."], "gold_sql": "SELECT country FROM competition EXCEPT SELECT country FROM competition WHERE competition_type  =  'Friendly'", "source_tables": ["competition"], "pred_sql": "SELECT DISTINCT Country \nFROM competition \nWHERE Competition_type = 'friendly' \nEXCEPT \nSELECT DISTINCT Country \nFROM competition \nWHERE Competition_type != 'friendly';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides information about the types of competitions and the countries where they are held from the 'competition' table. The placeholders represent the specific competition type and country details.\",\n        \"virtual_table\": \"SELECT Competition_type ,  Country FROM competition\"\n    }\n}\n"}
{"sample_id": "train.3407", "db_id": "hr_1", "question": "List the full name (first and last name), and salary for those employees who earn below 6000.", "rationale": ["Identify the relevant table: The 'employees' table contains the necessary information about employees, including their first name, last name, and salary.", "Determine the required columns: We need to select the 'FIRST_NAME', 'LAST_NAME', and 'SALARY' columns from the 'employees' table.", "Set the condition for filtering: We want to filter employees whose salary is below 6000, which translates to a WHERE clause in SQL.", "Construct the SQL query: Combine the SELECT statement with the WHERE clause to form the complete SQL query."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees WHERE salary  <  6000", "source_tables": ["employees"], "pred_sql": "SELECT FIRST_NAME, LAST_NAME, SALARY FROM employees WHERE SALARY < 6000", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary to filter the results.\",\n        \"virtual_table\": \"SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3418", "db_id": "hr_1", "question": "What are the full name, hire date, salary, and department id for employees without the letter M in their first name?", "rationale": ["Identify the required fields: full name (first and last), hire date, salary, and department id.", "To get the full name, concatenate the first name and last name using '||'.", "Select the hire date, salary, and department id directly from the employees table.", "Filter the employees whose first name does not contain the letter 'M' using the NOT LIKE operator."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%'", "source_tables": ["employees"], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, HIRE_DATE, SALARY, DEPARTMENT_ID FROM employees WHERE FIRST_NAME NOT LIKE '%M%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3419", "db_id": "hr_1", "question": "display the full name (first and last), hire date, salary, and department number for those employees whose first name does not containing the letter M and make the result set in ascending order by department number.", "rationale": ["Identify the columns needed: full name (first and last), hire date, salary, and department number.", "To get the full name, concatenate first_name and last_name with a space in between.", "Filter employees whose first name does not contain the letter 'M'. This can be done using the NOT LIKE operator with a wildcard.", "Sort the results in ascending order by department number, which corresponds to the department_id column.", "Construct the SQL query using the SELECT statement with the identified columns and conditions."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT first_name || ' ' || last_name AS full_name, hire_date, salary, department_id \nFROM employees \nWHERE first_name NOT LIKE '%M%' \nORDER BY department_id ASC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves all employee records from the 'employees' table where the department ID does not fall within a specified range of manager IDs. The placeholders in the query represent numeric values for the range of manager IDs to filter out departments managed by those IDs.\",\n        \"virtual_table\": \"SELECT * FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves all employee records from the 'employees' table where the department ID does not fall within a specified range of manager IDs. The placeholders in the query represent numeric values for the range of manager IDs to filter out departments managed by those IDs.\",\n        \"virtual_table\": \"SELECT * FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3420", "db_id": "hr_1", "question": "What are the full name, hire data, salary and department id for employees without the letter M in their first name, ordered by ascending department id?", "rationale": ["Identify the required fields: full name (concatenation of first and last name), hire date, salary, and department ID.", "Use the employees table to retrieve the necessary information.", "Filter the employees whose first name does not contain the letter 'M' using the NOT LIKE operator.", "Order the results by department ID in ascending order."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, HIRE_DATE, SALARY, DEPARTMENT_ID \nFROM employees \nWHERE FIRST_NAME NOT LIKE '%M%' \nORDER BY DEPARTMENT_ID ASC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves all employee records from the 'employees' table where the department ID does not fall within a specified range of manager IDs. The placeholders in the query represent numeric values for the range of manager IDs to filter out departments managed by those IDs.\",\n        \"virtual_table\": \"SELECT * FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table retrieves all employee records from the 'employees' table where the department ID does not fall within a specified range of manager IDs. The placeholders in the query represent numeric values for the range of manager IDs to filter out departments managed by those IDs.\",\n        \"virtual_table\": \"SELECT * FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.3442", "db_id": "hr_1", "question": "Which job titles correspond to jobs with salaries over 9000?", "rationale": ["Identify the relevant table: The 'jobs' table contains information about job titles and their corresponding salary ranges.", "Determine the condition: We need to find jobs with salaries over 9000, which means we should check both the 'MIN_SALARY' and 'MAX_SALARY' columns in the 'jobs' table.", "Construct the SQL query: We will select distinct job titles from the 'jobs' table where either the minimum or maximum salary exceeds 9000."], "gold_sql": "SELECT job_title FROM jobs WHERE min_salary  >  9000", "source_tables": ["jobs"], "pred_sql": "SELECT DISTINCT jobs.JOB_TITLE FROM jobs WHERE jobs.MIN_SALARY > 9000 OR jobs.MAX_SALARY > 9000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary to filter the results.\",\n        \"virtual_table\": \"SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3444", "db_id": "hr_1", "question": "What are the job titles, and range of salaries for jobs with maximum salary between 12000 and 18000?", "rationale": ["Identify the relevant table: The question asks for job titles and salary ranges, which are found in the 'jobs' table.", "Select the required columns: We need to select 'JOB_TITLE', 'MIN_SALARY', and 'MAX_SALARY'.", "Apply the filter: The question specifies that we want jobs with a maximum salary between 12000 and 18000, so we will use a WHERE clause to filter on 'MAX_SALARY'.", "Construct the SQL query: Combine the selected columns and the filter into a complete SQL query."], "gold_sql": "SELECT job_title ,  max_salary - min_salary FROM jobs WHERE max_salary BETWEEN 12000 AND 18000", "source_tables": ["jobs"], "pred_sql": "SELECT JOB_TITLE, MIN_SALARY, MAX_SALARY \nFROM jobs \nWHERE MAX_SALARY BETWEEN 12000 AND 18000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary to filter the results.\",\n        \"virtual_table\": \"SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3448", "db_id": "hr_1", "question": "What are the employee ids for each employee and final dates of employment at their last job?", "rationale": ["The query needs to retrieve employee IDs and their final dates of employment at their last job.", "To get the final dates of employment, we need to look at the 'job_history' table which records the start and end dates of jobs held by employees.", "We will join the 'employees' table with the 'job_history' table on the EMPLOYEE_ID to get the relevant information.", "To find the last job's end date for each employee, we can use a subquery that selects the maximum END_DATE for each EMPLOYEE_ID from the job_history table."], "gold_sql": "SELECT employee_id ,  MAX(end_date) FROM job_history GROUP BY employee_id", "source_tables": ["job_history"], "pred_sql": "SELECT e.EMPLOYEE_ID, j.END_DATE\nFROM employees e\nJOIN job_history j ON e.EMPLOYEE_ID = j.EMPLOYEE_ID\nWHERE j.END_DATE = (SELECT MAX(END_DATE) FROM job_history WHERE EMPLOYEE_ID = e.EMPLOYEE_ID)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3453", "db_id": "hr_1", "question": "display the average salary of employees for each department who gets a commission percentage.", "rationale": ["Identify the tables needed: We need the 'employees' table for salary and commission percentage, and the 'departments' table for department names.", "Join the 'employees' table with the 'departments' table on the DEPARTMENT_ID to associate employees with their respective departments.", "Filter the employees to include only those who have a commission percentage (i.e., COMMISSION_PCT IS NOT NULL).", "Use the AVG() function to calculate the average salary of the filtered employees for each department.", "Group the results by department name to get the average salary for each department."], "gold_sql": "SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != 'null' GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT d.DEPARTMENT_NAME, AVG(e.SALARY) AS AVERAGE_SALARY\nFROM employees e\nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID\nWHERE e.COMMISSION_PCT IS NOT NULL\nGROUP BY d.DEPARTMENT_NAME;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary to filter the results.\",\n        \"virtual_table\": \"SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3454", "db_id": "hr_1", "question": "What is the average salary of employees who have a commission percentage that is not null?", "rationale": ["Identify the table that contains salary information, which is the 'employees' table.", "Determine the condition for filtering employees, which is that the 'COMMISSION_PCT' should not be null.", "Use the AVG() function to calculate the average salary of the filtered employees.", "Construct the SQL query to select the average salary from the 'employees' table where the commission percentage is not null."], "gold_sql": "SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != 'null' GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT AVG(SALARY) AS average_salary FROM employees WHERE COMMISSION_PCT IS NOT NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary to filter the results.\",\n        \"virtual_table\": \"SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3455", "db_id": "hr_1", "question": "display the country ID and number of cities for each country.", "rationale": ["Identify the required columns: COUNTRY_ID from countries and the count of cities from locations.", "To count the number of cities for each country, we need to join the countries table with the locations table on the COUNTRY_ID.", "Use the COUNT function to count the number of cities for each country.", "Group the results by COUNTRY_ID to ensure we get a count for each country."], "gold_sql": "SELECT country_id ,  COUNT(*) FROM locations GROUP BY country_id", "source_tables": ["locations"], "pred_sql": "SELECT countries.COUNTRY_ID, COUNT(locations.CITY) AS number_of_cities\nFROM countries\nJOIN locations ON countries.COUNTRY_ID = locations.COUNTRY_ID\nGROUP BY countries.COUNTRY_ID;", "hint": "\n"}
{"sample_id": "train.3456", "db_id": "hr_1", "question": "Give the country id and corresponding count of cities in each country.", "rationale": ["Identify the tables needed: We need data from the 'countries' table for country IDs and from the 'locations' table for cities.", "Determine the relationship: The 'locations' table has a foreign key 'COUNTRY_ID' that links to the 'countries' table.", "Use a JOIN to combine these tables based on the 'COUNTRY_ID'.", "Count the number of cities for each country using COUNT() function.", "Group the results by 'COUNTRY_ID' to get the count of cities per country."], "gold_sql": "SELECT country_id ,  COUNT(*) FROM locations GROUP BY country_id", "source_tables": ["locations"], "pred_sql": "SELECT c.COUNTRY_ID, COUNT(l.CITY) AS CITY_COUNT\nFROM countries c\nJOIN locations l ON c.COUNTRY_ID = l.COUNTRY_ID\nGROUP BY c.COUNTRY_ID;", "hint": "\n"}
{"sample_id": "train.3465", "db_id": "hr_1", "question": "Can you return all detailed info of jobs which was done by any of the employees who is presently earning a salary on and above 12000?", "rationale": ["The user wants detailed information about jobs done by employees earning a salary of 12000 or more.", "We need to join the 'jobs' table with a virtual table that combines 'job_history' and 'employees' to filter employees based on their salary.", "The hint provides a virtual table that joins 'job_history' and 'employees' on 'EMPLOYEE_ID' and filters by salary.", "We will use this virtual table to get the job history of employees earning 12000 or more, and then join this result with the 'jobs' table on 'JOB_ID' to get the job details."], "gold_sql": "SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  12000", "source_tables": ["job_history", "employees"], "pred_sql": "SELECT * FROM jobs AS J JOIN (SELECT * FROM job_history AS T1 JOIN employees AS T2 ON T1.EMPLOYEE_ID = T2.EMPLOYEE_ID WHERE T2.SALARY >= 12000) AS JobDetails ON J.JOB_ID = JobDetails.JOB_ID", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary to filter the results.\",\n        \"virtual_table\": \"SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3482", "db_id": "hr_1", "question": "What is all the information regarding employees who are managers?", "rationale": ["Identify employees who are managers by checking if their employee_id matches the manager_id in the departments table.", "Use a JOIN between the employees table and the departments table on the department_id to get relevant information about the departments they manage.", "Use DISTINCT to ensure that we only get unique records of employees who are managers."], "gold_sql": "SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T1.employee_id  =  T2.manager_id", "source_tables": ["employees", "departments"], "pred_sql": "SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id = T2.department_id WHERE T1.employee_id = T2.manager_id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of employees who are also managers in their respective departments. It combines data from the 'employees' and 'departments' tables, ensuring that only those employees whose 'employee_id' matches the 'manager_id' of their department are included. The use of DISTINCT ensures that duplicate records are eliminated, providing a unique list of such employees.\",\n        \"virtual_table\": \"SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T1.employee_id  =  T2.manager_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table retrieves all employee records from the 'employees' table where the department ID does not fall within a specified range of manager IDs. The placeholders in the query represent numeric values for the range of manager IDs to filter out departments managed by those IDs.\",\n        \"virtual_table\": \"SELECT * FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.3487", "db_id": "hr_1", "question": "What are the unique ids of those departments where any manager is managing 4 or more employees.", "rationale": ["Identify managers by grouping employees based on their manager_id.", "Count the number of employees for each manager using COUNT(employee_id).", "Filter the managers who manage 4 or more employees using HAVING COUNT(employee_id) >= 4.", "Select the department_id from employees where the manager_id is in the list of managers identified in the previous step."], "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"], "pred_sql": "SELECT department_id FROM employees WHERE manager_id IN (SELECT manager_id FROM employees GROUP BY manager_id HAVING COUNT(employee_id) >= 4)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of employees who are also managers in their respective departments. It combines data from the 'employees' and 'departments' tables, ensuring that only those employees whose 'employee_id' matches the 'manager_id' of their department are included. The use of DISTINCT ensures that duplicate records are eliminated, providing a unique list of such employees.\",\n        \"virtual_table\": \"SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T1.employee_id  =  T2.manager_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table retrieves all employee records from the 'employees' table where the department ID does not fall within a specified range of manager IDs. The placeholders in the query represent numeric values for the range of manager IDs to filter out departments managed by those IDs.\",\n        \"virtual_table\": \"SELECT * FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.3488", "db_id": "hr_1", "question": "Give the distinct department ids of departments in which a manager is in charge of 4 or more employees?", "rationale": ["We need to find departments where a manager is in charge of 4 or more employees.", "To do this, we can first identify managers who have 4 or more employees reporting to them. We can achieve this by grouping the employees by their MANAGER_ID and counting the number of EMPLOYEE_IDs for each manager.", "Using the HAVING clause, we can filter these groups to only include those with a count of 4 or more employees.", "Next, we can select the DEPARTMENT_IDs from the employees table where the MANAGER_ID matches those identified in the previous step.", "Finally, we group the results by DEPARTMENT_ID to ensure distinct values are returned."], "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"], "pred_sql": "SELECT DEPARTMENT_ID FROM employees WHERE MANAGER_ID IN (SELECT MANAGER_ID FROM employees GROUP BY MANAGER_ID HAVING COUNT(EMPLOYEE_ID) >= 4) GROUP BY DEPARTMENT_ID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of employees who are also managers in their respective departments. It combines data from the 'employees' and 'departments' tables, ensuring that only those employees whose 'employee_id' matches the 'manager_id' of their department are included. The use of DISTINCT ensures that duplicate records are eliminated, providing a unique list of such employees.\",\n        \"virtual_table\": \"SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T1.employee_id  =  T2.manager_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves all employee records from the 'employees' table where the department ID does not fall within a specified range of manager IDs. The placeholders in the query represent numeric values for the range of manager IDs to filter out departments managed by those IDs.\",\n        \"virtual_table\": \"SELECT * FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table retrieves all employee records from the 'employees' table where the department ID does not fall within a specified range of manager IDs. The placeholders in the query represent numeric values for the range of manager IDs to filter out departments managed by those IDs.\",\n        \"virtual_table\": \"SELECT * FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.3496", "db_id": "hr_1", "question": "What is all the information regarding employees with salaries above the minimum and under 2500?", "rationale": ["Identify the relevant tables: 'employees' for employee details and 'job_history' for job history.", "Join the 'job_history' table with the 'employees' table on the employee ID to get comprehensive information.", "Use a WHERE clause to filter employees whose salary is greater than the minimum salary from the 'jobs' table and less than 2500.", "The subquery (SELECT MIN(MIN_SALARY) FROM jobs) retrieves the minimum salary from the jobs table to use as a threshold for filtering."], "gold_sql": "SELECT * FROM employees WHERE salary BETWEEN (SELECT MIN(salary) FROM employees) AND 2500", "source_tables": ["employees"], "pred_sql": "SELECT * FROM job_history AS T1 JOIN employees AS T2 ON T1.EMPLOYEE_ID = T2.EMPLOYEE_ID WHERE T2.SALARY > (SELECT MIN(MIN_SALARY) FROM jobs) AND T2.SALARY < 2500", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary to filter the results.\",\n        \"virtual_table\": \"SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3500", "db_id": "hr_1", "question": "What are the full names and hire dates for employees in the same department as someone with the first name Clara?", "rationale": ["Identify the relevant tables: employees and departments.", "We need to find employees in the same department as Clara, so we will join the employees table with the departments table.", "Use a subquery to find the department ID of the employee named Clara.", "Select the first name, last name, and hire date of employees who belong to the same department as Clara."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  (SELECT department_id FROM employees WHERE first_name  =  'Clara')", "source_tables": ["employees"], "pred_sql": "SELECT e.FIRST_NAME, e.LAST_NAME, e.HIRE_DATE \nFROM employees e \nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nWHERE d.DEPARTMENT_ID = (SELECT d2.DEPARTMENT_ID \n                         FROM employees e2 \n                         JOIN departments d2 ON e2.DEPARTMENT_ID = d2.DEPARTMENT_ID \n                         WHERE e2.FIRST_NAME = 'Clara')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3502", "db_id": "hr_1", "question": "What are the full names and hire dates for employees in the same department as someone with the first name Clara, not including Clara?", "rationale": ["Identify the required information: full names and hire dates of employees in the same department as Clara, excluding Clara herself.", "To get the full names, we need to concatenate the first and last names of the employees.", "We need to join the employees table with the departments table to filter employees by department.", "We need a subquery to find the department ID of the employee named Clara.", "The subquery selects the department ID of Clara by joining the employees table with the departments table where the first name is Clara.", "The main query selects the full names and hire dates of employees from the employees table who belong to the same department as Clara, ensuring that Clara is excluded from the results."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  ( SELECT department_id FROM employees WHERE first_name  =  'Clara') AND first_name != 'Clara'", "source_tables": ["employees"], "pred_sql": "SELECT CONCAT(e.FIRST_NAME, ' ', e.LAST_NAME) AS full_name, e.HIRE_DATE \nFROM employees e \nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nWHERE d.DEPARTMENT_ID = (SELECT d2.DEPARTMENT_ID \n                         FROM employees e2 \n                         JOIN departments d2 ON e2.DEPARTMENT_ID = d2.DEPARTMENT_ID \n                         WHERE e2.FIRST_NAME = 'Clara') \nAND e.FIRST_NAME != 'Clara';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3503", "db_id": "hr_1", "question": "display the employee number and name( first name and last name ) for all employees who work in a department with any employee whose name contains a \u2019T\u2019.", "rationale": ["We need to find employees who work in the same department as any employee whose name contains 'T'.", "First, we will create a subquery to find the department IDs of employees whose first or last name contains 'T'.", "In the subquery, we select the department_id from the employees table where the first_name or last_name contains 'T'.", "Next, we will use this subquery to filter the main query that selects employee_id, first_name, and last_name from the employees table.", "We will join the employees table with the departments table to ensure we can filter by department.", "Finally, we will use DISTINCT to avoid duplicate entries in case multiple employees share the same department."], "gold_sql": "SELECT employee_id ,  first_name ,  last_name FROM employees WHERE department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE '%T%' )", "source_tables": ["employees"], "pred_sql": "SELECT DISTINCT T1.employee_id, T1.first_name, T1.last_name \nFROM employees AS T1 \nJOIN departments AS T2 ON T1.department_id = T2.department_id \nWHERE T2.department_id IN (\n    SELECT DISTINCT T3.department_id \n    FROM employees AS T3 \n    WHERE T3.first_name LIKE '%T%' OR T3.last_name LIKE '%T%'\n);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3507", "db_id": "hr_1", "question": "display the employee number and job id for all employees whose salary is smaller than any salary of those employees whose job title is MK_MAN.", "rationale": ["Identify the relevant tables: We need to retrieve data from the 'employees' table for employee numbers and job IDs.", "Determine the condition: We want employees whose salary is smaller than any salary of those employees whose job title is 'MK_MAN'.", "To achieve this, we need to find the minimum salary of employees with the job title 'MK_MAN'.", "This requires a subquery to first get the JOB_ID for 'MK_MAN' from the 'jobs' table, and then use that JOB_ID to find the minimum salary from the 'employees' table.", "Finally, we construct the main query to select EMPLOYEE_ID and JOB_ID from the 'employees' table where their salary is less than the minimum salary found in the subquery."], "gold_sql": "SELECT employee_id ,  job_id FROM employees WHERE salary  <  ( SELECT min(salary) FROM employees WHERE job_id  =  'MK_MAN' )", "source_tables": ["employees"], "pred_sql": "SELECT EMPLOYEE_ID, JOB_ID FROM employees WHERE SALARY < (SELECT MIN(SALARY) FROM employees WHERE JOB_ID = (SELECT JOB_ID FROM jobs WHERE JOB_TITLE = 'MK_MAN'))", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary to filter the results.\",\n        \"virtual_table\": \"SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves all employee records from the 'employees' table where the department ID does not fall within a specified range of manager IDs. The placeholders in the query represent numeric values for the range of manager IDs to filter out departments managed by those IDs.\",\n        \"virtual_table\": \"SELECT * FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table retrieves all employee records from the 'employees' table where the department ID does not fall within a specified range of manager IDs. The placeholders in the query represent numeric values for the range of manager IDs to filter out departments managed by those IDs.\",\n        \"virtual_table\": \"SELECT * FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.3512", "db_id": "hr_1", "question": "What are total salaries and department id for each department that has more than 2 employees?", "rationale": ["We need to find the total salaries and department IDs for departments with more than 2 employees.", "To do this, we will join the 'employees' table with the 'departments' table using the DEPARTMENT_ID.", "We will use the SUM function to calculate the total salaries for each department.", "We will group the results by DEPARTMENT_ID to aggregate the salaries per department.", "To filter departments with more than 2 employees, we will use the HAVING clause with COUNT to count the number of employees in each department."], "gold_sql": "SELECT department_id ,  SUM(salary) FROM employees GROUP BY department_id HAVING count(*)  >=  2", "source_tables": ["employees"], "pred_sql": "SELECT d.DEPARTMENT_ID, SUM(e.SALARY) AS total_salaries \nFROM employees AS e \nJOIN departments AS d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nGROUP BY d.DEPARTMENT_ID \nHAVING COUNT(e.EMPLOYEE_ID) > 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3515", "db_id": "hr_1", "question": "display the department ID, full name (first and last name), salary for those employees who is highest salary in every department.", "rationale": ["We need to display the department ID, full name (first and last name), and salary of employees with the highest salary in each department.", "To get the full name, we will concatenate the first name and last name of the employees.", "We will join the 'employees' table with the 'departments' table to get the department ID.", "To find the highest salary in each department, we will use a subquery that selects the maximum salary from the 'employees' table, grouped by department ID.", "The main query will filter employees whose salary matches the maximum salary for their respective department."], "gold_sql": "SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT T2.department_id, T1.first_name || ' ' || T1.last_name AS full_name, T1.salary \nFROM employees AS T1 \nJOIN departments AS T2 ON T1.department_id = T2.department_id \nWHERE T1.salary = (SELECT MAX(salary) \n                   FROM employees \n                   WHERE department_id = T2.department_id)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3520", "db_id": "hr_1", "question": "What are the full names and cities of employees who have the letter Z in their first names?", "rationale": ["Identify the relevant tables: employees, departments, and locations.", "We need the first names and last names from the employees table, and the city from the locations table.", "Join the employees table with the departments table on department_id to link employees to their departments.", "Join the departments table with the locations table on location_id to link departments to their locations.", "Filter the results to include only those employees whose first names contain the letter 'Z' using the LIKE operator."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T3.city FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id WHERE T1.first_name LIKE '%z%'", "source_tables": ["employees", "departments", "locations"], "pred_sql": "SELECT T1.first_name, T1.last_name, T3.city \nFROM employees AS T1 \nJOIN departments AS T2 ON T1.department_id = T2.department_id \nJOIN locations AS T3 ON T2.location_id = T3.location_id \nWHERE T1.first_name LIKE '%Z%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3523", "db_id": "hr_1", "question": "display the full name (first and last name ) of employee with ID and name of the country presently where (s)he is working.", "rationale": ["Identify the tables needed to get the employee's full name and the country they are working in.", "The 'employees' table contains the employee's first and last names.", "The 'departments' table links employees to their respective departments.", "The 'locations' table provides the location details of the departments, including the country.", "The 'countries' table contains the names of the countries.", "Join the 'employees', 'departments', 'locations', and 'countries' tables on their respective IDs to get the required information.", "Use a WHERE clause to filter the results for the specific employee ID provided."], "gold_sql": "SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id", "source_tables": ["countries", "employees", "departments", "locations"], "pred_sql": "SELECT T1.first_name, T1.last_name, T4.country_name \nFROM employees AS T1 \nJOIN departments AS T2 ON T1.department_id = T2.department_id \nJOIN locations AS T3 ON T2.location_id = T3.location_id \nJOIN countries AS T4 ON T3.country_id = T4.country_id \nWHERE T1.employee_id = ?", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3525", "db_id": "hr_1", "question": "display the department name and number of employees in each of the department.", "rationale": ["We need to display the department name and the number of employees in each department.", "The relevant tables are 'departments' for department names and 'employees' for employee counts.", "We will use a LEFT JOIN to include all departments even if they have no employees.", "We will group the results by department name to count the number of employees in each department."], "gold_sql": "SELECT department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY department_name", "source_tables": ["employees", "departments"], "pred_sql": "SELECT d.DEPARTMENT_NAME, COUNT(e.EMPLOYEE_ID) AS NUMBER_OF_EMPLOYEES \nFROM departments AS d \nLEFT JOIN employees AS e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID \nGROUP BY d.DEPARTMENT_NAME;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3526", "db_id": "hr_1", "question": "What are the department names and how many employees work in each of them?", "rationale": ["Identify the tables involved: We need to get department names from the 'departments' table and count the employees from the 'employees' table.", "Determine the relationship: The 'departments' table has a foreign key 'DEPARTMENT_ID' that links to the 'employees' table's 'DEPARTMENT_ID'.", "Use a LEFT JOIN: This will allow us to include departments even if they have no employees.", "Select the required fields: We need 'DEPARTMENT_NAME' from the 'departments' table and a count of 'EMPLOYEE_ID' from the 'employees' table.", "Group by department name: To get the count of employees per department, we need to group the results by 'DEPARTMENT_NAME'."], "gold_sql": "SELECT department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY department_name", "source_tables": ["employees", "departments"], "pred_sql": "SELECT d.DEPARTMENT_NAME, COUNT(e.EMPLOYEE_ID) AS EMPLOYEE_COUNT \nFROM departments AS d \nLEFT JOIN employees AS e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID \nGROUP BY d.DEPARTMENT_NAME;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3527", "db_id": "hr_1", "question": "display the full name (first and last name), and salary of those employees who working in any department located in London.", "rationale": ["Identify the tables needed: employees, departments, and locations.", "We need to retrieve the first name and last name of employees, which are in the employees table.", "We also need the salary of the employees, which is also in the employees table.", "To find the departments located in London, we need to join the departments table with the locations table.", "The join condition will be based on the department's location ID matching the location's ID.", "Finally, we filter the results to only include those locations where the city is 'London'.", "Construct the SQL query using the identified tables and conditions."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  'London'", "source_tables": ["employees", "departments", "locations"], "pred_sql": "SELECT T1.first_name, T1.last_name, T2.salary \nFROM employees AS T1 \nJOIN departments AS T2 ON T1.department_id = T2.department_id \nJOIN locations AS T3 ON T2.location_id = T3.location_id \nWHERE T3.city = 'London';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary to filter the results.\",\n        \"virtual_table\": \"SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3528", "db_id": "hr_1", "question": "What are full names and salaries of employees working in the city of London?", "rationale": ["Identify the tables needed: employees, departments, locations, and countries.", "We need to retrieve the first name, last name, and salary of employees.", "Join the employees table with the departments table on department_id.", "Join the departments table with the locations table on location_id.", "Join the locations table with the countries table on country_id.", "Filter the results to include only those employees whose department is located in the city of London."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  'London'", "source_tables": ["employees", "departments", "locations"], "pred_sql": "SELECT T1.first_name, T1.last_name, T1.salary \nFROM employees AS T1 \nJOIN departments AS T2 ON T1.department_id = T2.department_id \nJOIN locations AS T3 ON T2.location_id = T3.location_id \nJOIN countries AS T4 ON T3.country_id = T4.country_id \nWHERE T3.city = 'London';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3532", "db_id": "music_1", "question": "Find the id of the song that lasts the longest.", "rationale": ["Identify the tables involved: We need to find the song with the longest duration, which involves the 'song' and 'files' tables.", "Join the tables: We will join the 'song' table with the 'files' table on the 'f_id' column to access the duration of the songs.", "Order by duration: To find the longest song, we will order the results by the 'duration' column in descending order.", "Limit the results: Since we only want the longest song, we will limit the results to 1."], "gold_sql": "SELECT f_id FROM files ORDER BY duration DESC LIMIT 1", "source_tables": ["files"], "pred_sql": "SELECT T1.f_id FROM song AS T1 JOIN files AS T2 ON T1.f_id = T2.f_id ORDER BY T2.duration DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of artists from the 'song' table, joined with the 'files' table to access the duration of their songs. The results are ordered by the duration of the audio files, and a placeholder is used to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T1.artist_name FROM song AS T1 JOIN files AS T2 ON T1.f_id  =  T2.f_id ORDER BY T2.duration LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the maximum and minimum audio resolutions of songs from the 'song' table, filtered by the duration of the associated files in the 'files' table. The placeholder in the WHERE clause represents the specific duration pattern to match.\",\n        \"virtual_table\": \"SELECT max(T2.resolution) ,  min(T2.resolution) FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.duration LIKE [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of song titles along with their release dates from the 'song' table, sorted by the most recent release date. The placeholder in the LIMIT clause indicates the maximum number of records to return.\",\n        \"virtual_table\": \"SELECT song_name ,  releasedate FROM song ORDER BY releasedate DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3542", "db_id": "music_1", "question": "What are the names of the artists who sang the shortest song?", "rationale": ["Identify the relevant tables: 'song' for artist names and 'files' for song durations.", "Join the 'song' table with the 'files' table on the file ID ('f_id') to access the duration of each song.", "Select the artist names from the 'song' table.", "Order the results by the duration of the songs in ascending order to get the shortest song first.", "Limit the results to 1 to get only the shortest song's artist."], "gold_sql": "SELECT T1.artist_name FROM song AS T1 JOIN files AS T2 ON T1.f_id  =  T2.f_id ORDER BY T2.duration LIMIT 1", "source_tables": ["files", "song"], "pred_sql": "SELECT T1.artist_name FROM song AS T1 JOIN files AS T2 ON T1.f_id = T2.f_id ORDER BY T2.duration LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of artists from the 'song' table, joined with the 'files' table to access the duration of their songs. The results are ordered by the duration of the audio files, and a placeholder is used to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T1.artist_name FROM song AS T1 JOIN files AS T2 ON T1.f_id  =  T2.f_id ORDER BY T2.duration LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of artist names and their corresponding countries from the 'artist' table, joined with the 'song' table to include only those artists who have songs. The results are ordered by the rating of the songs in descending order, and the number of results is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.artist_name ,  T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.rating DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the gender and name of artists from the 'artist' table who have songs listed in the 'song' table. The results are ordered by the audio resolution of the songs, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.gender ,  T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.resolution LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3545", "db_id": "music_1", "question": "How many songs have 4 minute duration?", "rationale": ["The user wants to know how many songs have a duration of 4 minutes.", "In the 'files' table, the 'duration' column contains the duration of the audio files.", "To find the count of songs with a specific duration, we can use a COUNT aggregate function.", "We will filter the results in the WHERE clause to match the duration '4:00', which represents 4 minutes."], "gold_sql": "SELECT count(*) FROM files WHERE duration LIKE '4:%'", "source_tables": ["files"], "pred_sql": "SELECT count(*) FROM files WHERE duration = '4:00'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of artists from the 'song' table, joined with the 'files' table to access the duration of their songs. The results are ordered by the duration of the audio files, and a placeholder is used to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T1.artist_name FROM song AS T1 JOIN files AS T2 ON T1.f_id  =  T2.f_id ORDER BY T2.duration LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the maximum and minimum audio resolutions of songs from the 'song' table, filtered by the duration of the associated files in the 'files' table. The placeholder in the WHERE clause represents the specific duration pattern to match.\",\n        \"virtual_table\": \"SELECT max(T2.resolution) ,  min(T2.resolution) FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.duration LIKE [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of audio files from the 'files' table that match a specific duration pattern. The placeholder in the WHERE clause represents the duration criteria to filter the files.\",\n        \"virtual_table\": \"SELECT count(*) FROM files WHERE duration LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3549", "db_id": "music_1", "question": "What is the average rating of songs produced by female artists?", "rationale": ["Identify the tables involved: 'artist' and 'song'.", "Determine the relationship between the tables: 'artist_name' is the common field.", "Focus on the requirement: average rating of songs produced by female artists.", "Use the AVG() function to calculate the average rating from the 'song' table.", "Filter the results by the gender of the artist, specifically 'female'.", "Construct the SQL query using the identified elements."], "gold_sql": "SELECT avg(T2.rating) FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  'Female'", "source_tables": ["artist", "song"], "pred_sql": "SELECT avg(T2.rating) FROM artist AS T1 JOIN song AS T2 ON T1.artist_name = T2.artist_name WHERE T1.gender = 'female'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average rating of songs performed by artists of a specific gender. The placeholder in the WHERE clause represents the gender of the artists being queried.\",\n        \"virtual_table\": \"SELECT avg(T2.rating) FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the gender and name of artists from the 'artist' table who have songs listed in the 'song' table. The results are ordered by the audio resolution of the songs, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.gender ,  T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.resolution LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of artist names and their corresponding countries from the 'artist' table, joined with the 'song' table to include only those artists who have songs. The results are ordered by the rating of the songs in descending order, and the number of results is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.artist_name ,  T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.rating DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3552", "db_id": "music_1", "question": "Find the file format that is used by the most files.", "rationale": ["Identify the goal: Find the file format that is used by the most files.", "Refer to the hint provided, which describes a virtual table that groups formats from the 'files' table and orders them by the count of files in each format.", "Construct the SQL query using the provided virtual table structure: SELECT formats FROM files GROUP BY formats ORDER BY COUNT(*) DESC.", "Add a LIMIT clause to return only the top result, which is the most common format."], "gold_sql": "SELECT formats FROM files GROUP BY formats ORDER BY COUNT (*) DESC LIMIT 1", "source_tables": ["files"], "pred_sql": "SELECT formats FROM files GROUP BY formats ORDER BY COUNT(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of audio file formats from the 'files' table, grouped by format type. The results are ordered by the count of files in each format, allowing users to see the most common formats used. The placeholder in the LIMIT clause represents the maximum number of formats to return.\",\n        \"virtual_table\": \"SELECT formats FROM files GROUP BY formats ORDER BY COUNT (*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of file identifiers from the 'files' table, sorted by the duration of the audio files in descending order. The placeholder in the LIMIT clause indicates the maximum number of file identifiers to return.\",\n        \"virtual_table\": \"SELECT f_id FROM files ORDER BY duration DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of audio files from the 'files' table that match a specific duration pattern. The placeholder in the WHERE clause represents the duration criteria to filter the files.\",\n        \"virtual_table\": \"SELECT count(*) FROM files WHERE duration LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3556", "db_id": "music_1", "question": "What is the id of the files that are available in the format of mp4 and a resolution smaller than 1000?", "rationale": ["Identify the relevant table: The 'files' table contains the 'f_id', 'formats', and 'resolution' columns needed for the query.", "Filter the results: We need to filter the files based on the format being 'mp4' and the resolution being smaller than 1000.", "Construct the SQL query: Use a SELECT statement to retrieve 'f_id' from the 'files' table, applying the necessary WHERE conditions for 'formats' and 'resolution'.", "Ensure proper type casting: Since 'resolution' is stored as text, we need to cast it to an integer for the comparison to work correctly."], "gold_sql": "SELECT f_id FROM files WHERE formats  =  'mp4' INTERSECT SELECT f_id FROM song WHERE resolution  <  1000", "source_tables": ["files", "song"], "pred_sql": "SELECT f_id FROM files WHERE formats LIKE '%mp4%' AND CAST(resolution AS INTEGER) < 1000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of file identifiers from the 'files' table, sorted by the duration of the audio files in descending order. The placeholder in the LIMIT clause indicates the maximum number of file identifiers to return.\",\n        \"virtual_table\": \"SELECT f_id FROM files ORDER BY duration DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the maximum and minimum audio resolutions of songs from the 'song' table, filtered by the duration of the associated files in the 'files' table. The placeholder in the WHERE clause represents the specific duration pattern to match.\",\n        \"virtual_table\": \"SELECT max(T2.resolution) ,  min(T2.resolution) FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.duration LIKE [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of audio file formats from the 'files' table, grouped by format type. The results are ordered by the count of files in each format, allowing users to see the most common formats used. The placeholder in the LIMIT clause represents the maximum number of formats to return.\",\n        \"virtual_table\": \"SELECT formats FROM files GROUP BY formats ORDER BY COUNT (*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3557", "db_id": "music_1", "question": "What is the country of origin of the artist who is female and produced a song in Bangla?", "rationale": ["Identify the relevant tables: 'artist' and 'song'.", "We need to find the country of origin of female artists who produced songs in Bangla.", "Join the 'artist' table with the 'song' table on the artist's name to correlate artists with their songs.", "Filter the results to include only female artists and songs that are in Bangla.", "Select the 'country' column from the 'artist' table as the final output."], "gold_sql": "SELECT T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  'Female' AND T2.languages  =  'bangla'", "source_tables": ["artist", "song"], "pred_sql": "SELECT artist.country FROM artist JOIN song ON artist.artist_name = song.artist_name WHERE artist.gender = 'female' AND song.languages = 'Bangla';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of artist names and their corresponding countries from the 'artist' table, joined with the 'song' table to include only those artists who have songs. The results are ordered by the rating of the songs in descending order, and the number of results is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.artist_name ,  T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.rating DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the titles of songs from the 'song' table that belong to a specific genre or are available in a specific language. The placeholders in the WHERE clause represent the genre and language criteria.\",\n        \"virtual_table\": \"SELECT song_name FROM song WHERE genre_is  =  [PLACEHOLDER-TYPE:STRING] OR languages  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the gender and name of artists from the 'artist' table who have songs listed in the 'song' table. The results are ordered by the audio resolution of the songs, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.gender ,  T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.resolution LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3558", "db_id": "music_1", "question": "What countries are the female artists who sung in the language Bangla from?", "rationale": ["Identify the relevant tables: We need information from the 'artist' table for artist names and countries, and from the 'song' table to filter artists based on the language of their songs.", "Filter for female artists: We will add a condition to select only female artists from the 'artist' table.", "Filter for songs in Bangla: We will use a subquery to select artist names from the 'song' table where the language is 'Bangla'.", "Combine the conditions: We will combine the conditions to get the artist names and countries of female artists who have sung songs in Bangla."], "gold_sql": "SELECT T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  'Female' AND T2.languages  =  'bangla'", "source_tables": ["artist", "song"], "pred_sql": "SELECT artist_name, country FROM artist WHERE gender = 'female' AND artist_name IN (SELECT artist_name FROM song WHERE languages = 'Bangla')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of artist names and their corresponding countries from the 'artist' table, joined with the 'song' table to include only those artists who have songs. The results are ordered by the rating of the songs in descending order, and the number of results is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.artist_name ,  T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.rating DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of languages in which songs are available, grouped by language and ordered by the number of songs in each language. The placeholder in the LIMIT clause allows the user to specify the maximum number of languages to retrieve.\",\n        \"virtual_table\": \"SELECT languages FROM song GROUP BY languages ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the titles of songs from the 'song' table that belong to a specific genre or are available in a specific language. The placeholders in the WHERE clause represent the genre and language criteria.\",\n        \"virtual_table\": \"SELECT song_name FROM song WHERE genre_is  =  [PLACEHOLDER-TYPE:STRING] OR languages  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3566", "db_id": "music_1", "question": "What is the gender and name of the artist who sang the song with the smallest resolution?", "rationale": ["Identify the tables involved: 'artist' and 'song'.", "We need to retrieve the gender and name of the artist, which are in the 'artist' table.", "We need to find the song with the smallest resolution, which is in the 'song' table.", "Join the 'artist' table with the 'song' table on the artist's name.", "Order the results by the resolution of the songs in ascending order to get the smallest resolution first.", "Limit the results to 1 to get only the artist associated with the song of the smallest resolution."], "gold_sql": "SELECT T1.gender ,  T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.resolution LIMIT 1", "source_tables": ["artist", "song"], "pred_sql": "SELECT T1.gender, T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name = T2.artist_name ORDER BY T2.resolution LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the gender and name of artists from the 'artist' table who have songs listed in the 'song' table. The results are ordered by the audio resolution of the songs, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.gender ,  T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.resolution LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the maximum and minimum audio resolutions of songs from the 'song' table, filtered by the duration of the associated files in the 'files' table. The placeholder in the WHERE clause represents the specific duration pattern to match.\",\n        \"virtual_table\": \"SELECT max(T2.resolution) ,  min(T2.resolution) FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.duration LIKE [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average rating of songs performed by artists of a specific gender. The placeholder in the WHERE clause represents the gender of the artists being queried.\",\n        \"virtual_table\": \"SELECT avg(T2.rating) FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3567", "db_id": "music_1", "question": "For each file format, return the number of artists who released songs in that format.", "rationale": ["Identify the relevant tables: We need to use the 'files' table to get the formats and the 'song' table to associate those formats with artists.", "Join the 'files' and 'song' tables on the 'f_id' column to link songs to their respective file formats.", "Group the results by the 'formats' column to count the number of distinct artists for each format.", "Use COUNT(DISTINCT artist_name) to ensure we count each artist only once per format.", "Select the 'formats' and the count of distinct artists as 'artist_count' to get the desired output."], "gold_sql": "SELECT count(*) ,  formats FROM files GROUP BY formats", "source_tables": ["files"], "pred_sql": "SELECT formats, COUNT(DISTINCT artist_name) AS artist_count FROM files JOIN song ON files.f_id = song.f_id GROUP BY formats", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of audio file formats from the 'files' table, grouped by format type. The results are ordered by the count of files in each format, allowing users to see the most common formats used. The placeholder in the LIMIT clause represents the maximum number of formats to return.\",\n        \"virtual_table\": \"SELECT formats FROM files GROUP BY formats ORDER BY COUNT (*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of artists from the 'song' table, joined with the 'files' table to access the duration of their songs. The results are ordered by the duration of the audio files, and a placeholder is used to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T1.artist_name FROM song AS T1 JOIN files AS T2 ON T1.f_id  =  T2.f_id ORDER BY T2.duration LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the gender and name of artists from the 'artist' table who have songs listed in the 'song' table. The results are ordered by the audio resolution of the songs, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.gender ,  T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.resolution LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3576", "db_id": "music_1", "question": "What are the names and genders of all artists who released songs in the month of March?", "rationale": ["Identify the tables involved: We need information from the 'artist' and 'song' tables.", "Determine the columns needed: We need the 'artist_name' and 'gender' from the 'artist' table.", "Establish the relationship: We join the 'artist' table with the 'song' table on 'artist_name'.", "Filter the results: We need to find songs released in March, which can be done using the strftime function to extract the month from the 'releasedate' column. We check if it equals '03'.", "Construct the SQL query: Combine all the elements into a complete SQL query."], "gold_sql": "SELECT T1.artist_name ,  T1.gender FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.releasedate LIKE '%Mar%'", "source_tables": ["artist", "song"], "pred_sql": "SELECT artist.artist_name, artist.gender \nFROM artist \nJOIN song ON artist.artist_name = song.artist_name \nWHERE strftime('%m', song.releasedate) = '03';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the gender and name of artists from the 'artist' table who have songs listed in the 'song' table. The results are ordered by the audio resolution of the songs, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.gender ,  T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.resolution LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average rating of songs performed by artists of a specific gender. The placeholder in the WHERE clause represents the gender of the artists being queried.\",\n        \"virtual_table\": \"SELECT avg(T2.rating) FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of artist names and their corresponding countries from the 'artist' table, joined with the 'song' table to include only those artists who have songs. The results are ordered by the rating of the songs in descending order, and the number of results is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.artist_name ,  T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.rating DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3586", "db_id": "music_1", "question": "What are the languages that are used most often in songs?", "rationale": ["The user wants to know the languages used most often in songs.", "To find this, we can select the 'languages' column from the 'song' table.", "We need to group the results by 'languages' to count how many songs are available in each language.", "Ordering the results by the count of songs in descending order will show the most common languages first."], "gold_sql": "SELECT languages FROM song GROUP BY languages ORDER BY count(*) DESC LIMIT 1", "source_tables": ["song"], "pred_sql": "SELECT languages FROM song GROUP BY languages ORDER BY count(*) DESC", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of languages in which songs are available, grouped by language and ordered by the number of songs in each language. The placeholder in the LIMIT clause allows the user to specify the maximum number of languages to retrieve.\",\n        \"virtual_table\": \"SELECT languages FROM song GROUP BY languages ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the titles of songs from the 'song' table that belong to a specific genre or are available in a specific language. The placeholders in the WHERE clause represent the genre and language criteria.\",\n        \"virtual_table\": \"SELECT song_name FROM song WHERE genre_is  =  [PLACEHOLDER-TYPE:STRING] OR languages  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3590", "db_id": "music_1", "question": "What are the names of all male British artists?", "rationale": ["Identify the relevant table: We need to query the 'artist' table to find male British artists.", "Specify the conditions: We need to filter artists based on their country (Britain) and gender (male).", "Construct the SQL query: Use a SELECT statement to retrieve the 'artist_name' from the 'artist' table where the conditions are met."], "gold_sql": "SELECT artist_name FROM artist WHERE country  =  'UK' AND gender  =  'Male'", "source_tables": ["artist"], "pred_sql": "SELECT artist_name FROM artist WHERE country = 'Britain' AND gender = 'male'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the gender and name of artists from the 'artist' table who have songs listed in the 'song' table. The results are ordered by the audio resolution of the songs, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.gender ,  T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.resolution LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of artist names and their corresponding countries from the 'artist' table, joined with the 'song' table to include only those artists who have songs. The results are ordered by the rating of the songs in descending order, and the number of results is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.artist_name ,  T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.rating DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average rating of songs performed by artists of a specific gender. The placeholder in the WHERE clause represents the gender of the artists being queried.\",\n        \"virtual_table\": \"SELECT avg(T2.rating) FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3598", "db_id": "music_1", "question": "What is the average rating and resolution of all bangla songs?", "rationale": ["Identify the tables needed: We need data from the 'song' table for the average rating and the 'files' table for the resolution.", "Determine the relevant columns: We need the 'rating' from the 'song' table and 'resolution' from the 'files' table.", "Join the tables: We will join the 'song' table and the 'files' table on the 'f_id' column to relate songs to their file details.", "Filter the results: We need to filter the songs to only include those that belong to the 'bangla' genre.", "Calculate the average rating: Use the AVG function to calculate the average rating of the filtered songs."], "gold_sql": "SELECT avg(rating) ,  avg(resolution) FROM song WHERE languages  =  'bangla'", "source_tables": ["song"], "pred_sql": "SELECT avg(rating) AS average_rating, resolution FROM song AS T1 JOIN files AS T2 ON T1.f_id = T2.f_id WHERE T1.genre_is = 'bangla'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average rating of songs performed by artists of a specific gender. The placeholder in the WHERE clause represents the gender of the artists being queried.\",\n        \"virtual_table\": \"SELECT avg(T2.rating) FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the maximum and minimum audio resolutions of songs from the 'song' table, filtered by the duration of the associated files in the 'files' table. The placeholder in the WHERE clause represents the specific duration pattern to match.\",\n        \"virtual_table\": \"SELECT max(T2.resolution) ,  min(T2.resolution) FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.duration LIKE [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the gender and name of artists from the 'artist' table who have songs listed in the 'song' table. The results are ordered by the audio resolution of the songs, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.gender ,  T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.resolution LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3599", "db_id": "music_1", "question": "What are the maximum and minimum resolution of songs whose duration is 3 minutes?", "rationale": ["Identify the tables involved: We need data from the 'song' and 'files' tables to get the resolution and filter by duration.", "Determine the relationship: The 'song' table is linked to the 'files' table through the 'f_id' column.", "Define the condition: We want to filter songs based on their duration, specifically those that are 3 minutes long.", "Use the appropriate SQL functions: We will use the MAX and MIN functions to get the maximum and minimum resolution of the filtered songs.", "Construct the SQL query: Combine all the elements into a single SQL query that selects the max and min resolution from the joined tables with the specified duration condition."], "gold_sql": "SELECT max(T2.resolution) ,  min(T2.resolution) FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.duration LIKE '3:%'", "source_tables": ["files", "song"], "pred_sql": "SELECT max(T2.resolution), min(T2.resolution) FROM files AS T1 JOIN song AS T2 ON T1.f_id = T2.f_id WHERE T1.duration LIKE '3:00'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the maximum and minimum audio resolutions of songs from the 'song' table, filtered by the duration of the associated files in the 'files' table. The placeholder in the WHERE clause represents the specific duration pattern to match.\",\n        \"virtual_table\": \"SELECT max(T2.resolution) ,  min(T2.resolution) FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.duration LIKE [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of artists from the 'song' table, joined with the 'files' table to access the duration of their songs. The results are ordered by the duration of the audio files, and a placeholder is used to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T1.artist_name FROM song AS T1 JOIN files AS T2 ON T1.f_id  =  T2.f_id ORDER BY T2.duration LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of audio files from the 'files' table that match a specific duration pattern. The placeholder in the WHERE clause represents the duration criteria to filter the files.\",\n        \"virtual_table\": \"SELECT count(*) FROM files WHERE duration LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3601", "db_id": "music_1", "question": "What are the maximum duration and resolution of songs grouped and ordered by languages?", "rationale": ["We need to find the maximum duration and resolution of songs grouped by languages.", "To achieve this, we will select the maximum duration from the 'song' table and the maximum resolution from the 'files' table.", "We will join the 'song' table with the 'files' table on the file ID (f_id) to access both duration and resolution.", "We will group the results by the 'languages' column from the 'song' table to get the maximum values for each language.", "Finally, we will order the results by the maximum duration in descending order to see the longest songs first."], "gold_sql": "SELECT max(T1.duration) ,  max(T2.resolution) ,  T2.languages FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.languages ORDER BY T2.languages", "source_tables": ["files", "song"], "pred_sql": "SELECT max(T1.duration) AS max_duration, max(T2.resolution) AS max_resolution \nFROM song AS T1 \nJOIN files AS T2 ON T1.f_id = T2.f_id \nGROUP BY T1.languages \nORDER BY max_duration DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of languages in which songs are available, grouped by language and ordered by the number of songs in each language. The placeholder in the LIMIT clause allows the user to specify the maximum number of languages to retrieve.\",\n        \"virtual_table\": \"SELECT languages FROM song GROUP BY languages ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the maximum and minimum audio resolutions of songs from the 'song' table, filtered by the duration of the associated files in the 'files' table. The placeholder in the WHERE clause represents the specific duration pattern to match.\",\n        \"virtual_table\": \"SELECT max(T2.resolution) ,  min(T2.resolution) FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.duration LIKE [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of artists from the 'song' table, joined with the 'files' table to access the duration of their songs. The results are ordered by the duration of the audio files, and a placeholder is used to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T1.artist_name FROM song AS T1 JOIN files AS T2 ON T1.f_id  =  T2.f_id ORDER BY T2.duration LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3603", "db_id": "music_1", "question": "What are the shortest duration and lowest rating of songs grouped by genre and ordered by genre?", "rationale": ["Identify the columns needed: genre, shortest duration, and lowest rating.", "Use the MIN() function to find the shortest duration and lowest rating for each genre.", "Group the results by genre using GROUP BY clause.", "Order the results by genre using ORDER BY clause."], "gold_sql": "SELECT min(T1.duration) ,  min(T2.rating) ,  T2.genre_is FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.genre_is ORDER BY T2.genre_is", "source_tables": ["files", "song"], "pred_sql": "SELECT genre_is, MIN(duration) AS shortest_duration, MIN(rating) AS lowest_rating \nFROM song \nGROUP BY genre_is \nORDER BY genre_is;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the titles of songs from the 'song' table that belong to a specific genre or are available in a specific language. The placeholders in the WHERE clause represent the genre and language criteria.\",\n        \"virtual_table\": \"SELECT song_name FROM song WHERE genre_is  =  [PLACEHOLDER-TYPE:STRING] OR languages  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of artists from the 'song' table, joined with the 'files' table to access the duration of their songs. The results are ordered by the duration of the audio files, and a placeholder is used to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T1.artist_name FROM song AS T1 JOIN files AS T2 ON T1.f_id  =  T2.f_id ORDER BY T2.duration LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average rating of songs performed by artists of a specific gender. The placeholder in the WHERE clause represents the gender of the artists being queried.\",\n        \"virtual_table\": \"SELECT avg(T2.rating) FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3607", "db_id": "music_1", "question": "Find the name and country of origin for all artists who have release at least one song of resolution above 900.", "rationale": ["Identify the tables involved: artist, song, and files.", "We need to find artists who have released songs with a resolution above 900, so we will join the artist table with the song table on artist_name and then join the song table with the files table on f_id.", "Select the artist's name and country from the artist table.", "Apply the condition to filter songs with resolution greater than 900 using the files table.", "Construct the SQL query with the appropriate SELECT, JOIN, and WHERE clauses."], "gold_sql": "SELECT T1.artist_name ,  T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.resolution  >  900 GROUP BY T2.artist_name HAVING count(*)  >=  1", "source_tables": ["artist", "song"], "pred_sql": "SELECT artist.artist_name, artist.country FROM artist JOIN song ON artist.artist_name = song.artist_name JOIN files ON song.f_id = files.f_id WHERE files.resolution > 900;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of artist names and their corresponding countries from the 'artist' table, joined with the 'song' table to include only those artists who have songs. The results are ordered by the rating of the songs in descending order, and the number of results is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.artist_name ,  T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.rating DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the gender and name of artists from the 'artist' table who have songs listed in the 'song' table. The results are ordered by the audio resolution of the songs, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.gender ,  T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.resolution LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of artists from the 'song' table, joined with the 'files' table to access the duration of their songs. The results are ordered by the duration of the audio files, and a placeholder is used to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T1.artist_name FROM song AS T1 JOIN files AS T2 ON T1.f_id  =  T2.f_id ORDER BY T2.duration LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3619", "db_id": "music_1", "question": "Find the top 3 artists who have the largest number of songs works whose language is Bangla.", "rationale": ["Identify the relevant table: The 'song' table contains information about songs, including their languages and the artist associated with each song.", "Filter songs by language: We need to filter the songs to include only those that are in 'Bangla'. This is done using a WHERE clause.", "Count the number of songs per artist: We will group the results by 'artist_name' and count the number of songs for each artist using COUNT(song_name).", "Order the results: We want to order the artists by the number of songs in descending order to find the top artists.", "Limit the results: Finally, we will limit the results to the top 3 artists using the LIMIT clause."], "gold_sql": "SELECT T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.languages  =  'bangla' GROUP BY T2.artist_name ORDER BY count(*) DESC LIMIT 3", "source_tables": ["artist", "song"], "pred_sql": "SELECT artist_name, COUNT(song_name) AS song_count \nFROM song \nWHERE languages = 'Bangla' \nGROUP BY artist_name \nORDER BY song_count DESC \nLIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of languages in which songs are available, grouped by language and ordered by the number of songs in each language. The placeholder in the LIMIT clause allows the user to specify the maximum number of languages to retrieve.\",\n        \"virtual_table\": \"SELECT languages FROM song GROUP BY languages ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of artist names and their corresponding countries from the 'artist' table, joined with the 'song' table to include only those artists who have songs. The results are ordered by the rating of the songs in descending order, and the number of results is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.artist_name ,  T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.rating DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the titles of songs from the 'song' table that belong to a specific genre or are available in a specific language. The placeholders in the WHERE clause represent the genre and language criteria.\",\n        \"virtual_table\": \"SELECT song_name FROM song WHERE genre_is  =  [PLACEHOLDER-TYPE:STRING] OR languages  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3623", "db_id": "music_1", "question": "List the duration, file size and format of songs whose genre is pop, ordered by title?", "rationale": ["Identify the tables needed: 'files' for file details and 'song' for song details.", "Determine the columns to select: duration from 'song', file_size and formats from 'files'.", "Establish the join condition: 'files' and 'song' are linked by the f_id column.", "Add a WHERE clause to filter songs by genre, specifically 'pop'.", "Order the results by the song title (song_name) as specified in the query."], "gold_sql": "SELECT T1.duration ,  T1.file_size ,  T1.formats FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T2.genre_is  =  'pop' ORDER BY T2.song_name", "source_tables": ["files", "song"], "pred_sql": "SELECT T2.duration, T1.file_size, T1.formats \nFROM files AS T1 \nJOIN song AS T2 ON T1.f_id = T2.f_id \nWHERE T2.genre_is = 'pop' \nORDER BY T2.song_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of artists from the 'song' table, joined with the 'files' table to access the duration of their songs. The results are ordered by the duration of the audio files, and a placeholder is used to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T1.artist_name FROM song AS T1 JOIN files AS T2 ON T1.f_id  =  T2.f_id ORDER BY T2.duration LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the titles of songs from the 'song' table that belong to a specific genre or are available in a specific language. The placeholders in the WHERE clause represent the genre and language criteria.\",\n        \"virtual_table\": \"SELECT song_name FROM song WHERE genre_is  =  [PLACEHOLDER-TYPE:STRING] OR languages  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the maximum and minimum audio resolutions of songs from the 'song' table, filtered by the duration of the associated files in the 'files' table. The placeholder in the WHERE clause represents the specific duration pattern to match.\",\n        \"virtual_table\": \"SELECT max(T2.resolution) ,  min(T2.resolution) FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.duration LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3624", "db_id": "music_1", "question": "What is the duration, file size, and song format for every pop song, ordered by title alphabetically?", "rationale": ["Identify the relevant tables: 'song' for song details and 'files' for file details.", "Determine the columns needed: duration from 'song', file_size and formats from 'files'.", "Establish the relationship between the tables using the foreign key: 'song.f_id' corresponds to 'files.f_id'.", "Filter the results to include only pop songs by using the WHERE clause: 'T1.genre_is = 'pop''.", "Order the results alphabetically by song title using ORDER BY clause: 'ORDER BY T1.song_name ASC'.", "Construct the SQL query by combining all the elements identified."], "gold_sql": "SELECT T1.duration ,  T1.file_size ,  T1.formats FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T2.genre_is  =  'pop' ORDER BY T2.song_name", "source_tables": ["files", "song"], "pred_sql": "SELECT T1.duration, T2.file_size, T2.formats \nFROM song AS T1 \nJOIN files AS T2 ON T1.f_id = T2.f_id \nWHERE T1.genre_is = 'pop' \nORDER BY T1.song_name ASC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of artists from the 'song' table, joined with the 'files' table to access the duration of their songs. The results are ordered by the duration of the audio files, and a placeholder is used to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T1.artist_name FROM song AS T1 JOIN files AS T2 ON T1.f_id  =  T2.f_id ORDER BY T2.duration LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the maximum and minimum audio resolutions of songs from the 'song' table, filtered by the duration of the associated files in the 'files' table. The placeholder in the WHERE clause represents the specific duration pattern to match.\",\n        \"virtual_table\": \"SELECT max(T2.resolution) ,  min(T2.resolution) FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.duration LIKE [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of audio file formats from the 'files' table, grouped by format type. The results are ordered by the count of files in each format, allowing users to see the most common formats used. The placeholder in the LIMIT clause represents the maximum number of formats to return.\",\n        \"virtual_table\": \"SELECT formats FROM files GROUP BY formats ORDER BY COUNT (*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3631", "db_id": "baseball_1", "question": "What is average salary of the players in the team named 'Boston Red Stockings' ?", "rationale": ["Identify the tables needed: 'salary' for salary information and 'team' for team names.", "Join the 'salary' table with the 'team' table on the team_id to relate salaries to team names.", "Use the AVG function to calculate the average salary from the 'salary' table for players in the specified team.", "Filter the results using a WHERE clause to specify the team name 'Boston Red Stockings'."], "gold_sql": "SELECT avg(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings'", "source_tables": ["team", "salary"], "pred_sql": "SELECT avg(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = 'Boston Red Stockings'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average salary of players from a specific team in the 'salary' table. The placeholder in the WHERE clause represents the name of the team for which the average salary is being calculated.\",\n        \"virtual_table\": \"SELECT avg(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the total salary of players from a specific team for a given year. The placeholders represent the team's name and the year for which the salary data is being queried.\",\n        \"virtual_table\": \"SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the total count of salary records for a specific team in a given year. The placeholders represent the team's name and the year for which the salary records are being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3650", "db_id": "baseball_1", "question": "What are the three countries that the least players are from?", "rationale": ["Identify the relevant table: The 'player' table contains information about players, including their birth countries.", "Select the 'birth_country' column and count the number of players from each country using COUNT(player_id).", "Group the results by 'birth_country' to aggregate the player counts for each country.", "Order the results in ascending order based on the player count to find the countries with the least players.", "Limit the results to the top 3 countries with the least players."], "gold_sql": "SELECT birth_country FROM player GROUP BY birth_country ORDER BY count(*) ASC LIMIT 3;", "source_tables": ["player"], "pred_sql": "SELECT birth_country, COUNT(player_id) AS player_count\nFROM player\nGROUP BY birth_country\nORDER BY player_count ASC\nLIMIT 3;", "hint": "\n"}
{"sample_id": "train.3657", "db_id": "baseball_1", "question": "What is the highest salary among each team? List the team name, id and maximum salary.", "rationale": ["We need to find the highest salary for each team, which requires aggregating salary data by team.", "To achieve this, we will use the MAX function to get the maximum salary.", "We will join the salary table with the team table to get the team names and IDs associated with each salary record.", "The GROUP BY clause will be used to group the results by team ID and name, allowing us to calculate the maximum salary for each team."], "gold_sql": "SELECT T1.name ,  T1.team_id ,  max(T2.salary) FROM team AS T1 JOIN salary AS T2 ON T1.team_id  =  T2.team_id GROUP BY T1.team_id;", "source_tables": ["team", "salary"], "pred_sql": "SELECT T2.name, T2.team_id, MAX(T1.salary) AS max_salary \nFROM salary AS T1 \nJOIN team AS T2 ON T1.team_id = T2.team_id \nGROUP BY T2.team_id, T2.name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total salary of players from a specific team for a given year. The placeholders represent the team's name and the year for which the salary data is being queried.\",\n        \"virtual_table\": \"SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the total count of salary records for a specific team in a given year. The placeholders represent the team's name and the year for which the salary records are being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the total count of salary records for a specific team in a given year. The placeholders represent the team's name and the year for which the salary records are being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3658", "db_id": "baseball_1", "question": "For each team, return the team name, id and the maximum salary among the team.", "rationale": ["We need to retrieve the team name, team id, and the maximum salary for each team.", "To do this, we will select the team name and team id from the 'team' table and the maximum salary from the 'salary' table.", "We will join the 'salary' table with the 'team' table using the team_id as the common key.", "We will group the results by team_id and team name to ensure we get the maximum salary for each team."], "gold_sql": "SELECT T1.name ,  T1.team_id ,  max(T2.salary) FROM team AS T1 JOIN salary AS T2 ON T1.team_id  =  T2.team_id GROUP BY T1.team_id;", "source_tables": ["team", "salary"], "pred_sql": "SELECT T2.name, T2.team_id, MAX(T1.salary) AS max_salary \nFROM salary AS T1 \nJOIN team AS T2 ON T1.team_id = T2.team_id \nGROUP BY T2.team_id, T2.name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total salary of players from a specific team for a given year. The placeholders represent the team's name and the year for which the salary data is being queried.\",\n        \"virtual_table\": \"SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the total count of salary records for a specific team in a given year. The placeholders represent the team's name and the year for which the salary records are being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the total count of salary records for a specific team in a given year. The placeholders represent the team's name and the year for which the salary records are being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3659", "db_id": "baseball_1", "question": "What are the name and id of the team offering the lowest average salary?", "rationale": ["We need to find the team with the lowest average salary.", "To do this, we will first calculate the average salary for each team using the 'salary' table.", "We will join the 'salary' table with the 'team' table to get the team names along with their salaries.", "We will group the results by team_id to calculate the average salary for each team.", "Next, we will order the results by average salary in ascending order to find the lowest one.", "Finally, we will limit the results to only one entry to get the team with the lowest average salary."], "gold_sql": "SELECT T1.name ,  T1.team_id FROM team AS T1 JOIN salary AS T2 ON T1.team_id = T2.team_id GROUP BY T1.team_id ORDER BY avg(T2.salary) ASC LIMIT 1;", "source_tables": ["team", "salary"], "pred_sql": "SELECT T2.name, T2.team_id\nFROM team AS T2\nJOIN (\n    SELECT T1.team_id, AVG(T1.salary) AS avg_salary\n    FROM salary AS T1\n    GROUP BY T1.team_id\n) AS avg_salaries ON T2.team_id = avg_salaries.team_id\nORDER BY avg_salary ASC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average salary of players from a specific team in the 'salary' table. The placeholder in the WHERE clause represents the name of the team for which the average salary is being calculated.\",\n        \"virtual_table\": \"SELECT avg(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the total salary of players from a specific team for a given year. The placeholders represent the team's name and the year for which the salary data is being queried.\",\n        \"virtual_table\": \"SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the total count of salary records for a specific team in a given year. The placeholders represent the team's name and the year for which the salary records are being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3661", "db_id": "baseball_1", "question": "Find the players' first name and last name who won award both in 1960 and in 1961.", "rationale": ["Identify the tables needed: We need the 'player_award' table to find players who won awards in specific years and the 'player' table to get the first and last names of those players.", "Join the 'player_award' table with itself to find players who have entries for both 1960 and 1961.", "Use a JOIN condition on the player_id to ensure we are looking at the same player in both instances.", "Filter the results using a WHERE clause to specify the years 1960 and 1961 for the respective awards.", "Select the first name and last name from the 'player' table."], "gold_sql": "SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1960 INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1961", "source_tables": ["player_award", "player"], "pred_sql": "SELECT p.name_first, p.name_last\nFROM player_award pa1\nJOIN player_award pa2 ON pa1.player_id = pa2.player_id\nJOIN player p ON pa1.player_id = p.player_id\nWHERE pa1.year = 1960 AND pa2.year = 1961;", "hint": "\n"}
{"sample_id": "train.3663", "db_id": "baseball_1", "question": "List players' first name and last name who have weight greater than 220 or height shorter than 75.", "rationale": ["Identify the columns needed: 'name_first' and 'name_last' from the 'player' table.", "Determine the conditions for filtering: weight greater than 220 or height shorter than 75.", "Construct the SQL SELECT statement to retrieve the specified columns from the 'player' table.", "Add the WHERE clause to filter results based on the specified conditions."], "gold_sql": "SELECT name_first ,  name_last FROM player WHERE weight  >  220 OR height  <  75", "source_tables": ["player"], "pred_sql": "SELECT name_first, name_last FROM player WHERE weight > 220 OR height < 75;", "hint": "\n"}
{"sample_id": "train.3664", "db_id": "baseball_1", "question": "What are the first name and last name of the players who have weight above 220 or height below 75?", "rationale": ["Identify the relevant table: The 'player' table contains the information about players including their names, weight, and height.", "Select the columns needed: We need the first name (name_given) and last name (name_last) of the players.", "Apply the conditions: We need to filter players based on their weight being greater than 220 or their height being less than 75.", "Construct the SQL query: Use SELECT to choose the columns, FROM to specify the table, and WHERE to apply the conditions."], "gold_sql": "SELECT name_first ,  name_last FROM player WHERE weight  >  220 OR height  <  75", "source_tables": ["player"], "pred_sql": "SELECT name_given AS first_name, name_last AS last_name\nFROM player\nWHERE weight > 220 OR height < 75;", "hint": "\n"}
{"sample_id": "train.3665", "db_id": "baseball_1", "question": "List the maximum scores of the team Boston Red Stockings when the team won in postseason?", "rationale": ["Identify the relevant tables: postseason and team.", "We need to find the maximum scores (wins) of the Boston Red Stockings when they won in postseason.", "Join the postseason table with the team table on the winning team ID.", "Filter the results to only include the Boston Red Stockings.", "Use the MAX function to get the highest score from the filtered results."], "gold_sql": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings';", "source_tables": ["postseason", "team"], "pred_sql": "SELECT MAX(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner = T2.team_id_br WHERE T2.name = 'Boston Red Stockings';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the total number of postseason appearances for a specific team, including both wins and losses. It combines data from the 'postseason' table and the 'team' table, filtering by the team's name provided as a placeholder.\",\n        \"virtual_table\": \"SELECT count(*) FROM ( SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] );\"\n    }\n}\n"}
{"sample_id": "train.3666", "db_id": "baseball_1", "question": "What are the maximum scores the team Boston Red Stockings got when the team won in postseason?", "rationale": ["Identify the relevant tables: 'postseason' for postseason results and 'team' for team identification.", "We need to find the maximum scores (wins) for the team 'Boston Red Stockings' when they won in postseason.", "Join the 'postseason' table with the 'team' table on the winning team ID.", "Filter the results to only include rows where the team name is 'Boston Red Stockings'.", "Use the MAX function to get the maximum wins from the filtered results."], "gold_sql": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings';", "source_tables": ["postseason", "team"], "pred_sql": "SELECT MAX(wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner = T2.team_id_br WHERE T2.name = 'Boston Red Stockings';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the total number of postseason appearances for a specific team, including both wins and losses. It combines data from the 'postseason' table and the 'team' table, filtering by the team's name provided as a placeholder.\",\n        \"virtual_table\": \"SELECT count(*) FROM ( SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] );\"\n    }\n}\n"}
{"sample_id": "train.3672", "db_id": "baseball_1", "question": "For each year, return the year and the number of times the team Boston Red Stockings won in the postseasons.", "rationale": ["Identify the relevant tables: We need to use the 'postseason' table to find the wins and the 'team' table to filter by the team name.", "Join the 'postseason' table with the 'team' table on the winning team ID to get the team names associated with the wins.", "Filter the results to only include wins by the 'Boston Red Stockings'.", "Group the results by year to count the number of wins for each year.", "Select the year and the count of wins as the final output."], "gold_sql": "SELECT count(*) ,  T1.year FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' GROUP BY T1.year", "source_tables": ["postseason", "team"], "pred_sql": "SELECT T1.year, COUNT(*) AS wins\nFROM postseason AS T1\nJOIN team AS T2 ON T1.team_id_winner = T2.team_id_br\nWHERE T2.name = 'Boston Red Stockings'\nGROUP BY T1.year;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the total number of postseason appearances for a specific team, including both wins and losses. It combines data from the 'postseason' table and the 'team' table, filtering by the team's name provided as a placeholder.\",\n        \"virtual_table\": \"SELECT count(*) FROM ( SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] );\"\n    }\n}\n"}
{"sample_id": "train.3677", "db_id": "baseball_1", "question": "What is the total salary paid by team Boston Red Stockings in 2010?", "rationale": ["Identify the tables involved: salary and team.", "Determine the relationship between the tables: salary table has team_id which relates to team table's team_id_br.", "Use the sum function to calculate the total salary from the salary table.", "Filter the results by the team name 'Boston Red Stockings' and the year 2010."], "gold_sql": "SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings' AND T1.year  =  2010", "source_tables": ["team", "salary"], "pred_sql": "SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = 'Boston Red Stockings' AND T1.year = 2010", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total salary of players from a specific team for a given year. The placeholders represent the team's name and the year for which the salary data is being queried.\",\n        \"virtual_table\": \"SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the total count of salary records for a specific team in a given year. The placeholders represent the team's name and the year for which the salary records are being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the total count of salary records for a specific team in a given year. The placeholders represent the team's name and the year for which the salary records are being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3681", "db_id": "baseball_1", "question": "List the 3 highest salaries of the players in 2001?", "rationale": ["Identify the relevant table for salary information, which is the 'salary' table.", "We need to filter the results for the year 2001, so we will use a WHERE clause to specify 'year = 2001'.", "To get the highest salaries, we will order the results by 'salary' in descending order using ORDER BY salary DESC.", "Finally, we limit the results to the top 3 highest salaries using LIMIT 3."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2001 ORDER BY salary DESC LIMIT 3;", "source_tables": ["salary"], "pred_sql": "SELECT player_id, salary FROM salary WHERE year = 2001 ORDER BY salary DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total salary of players from a specific team for a given year. The placeholders represent the team's name and the year for which the salary data is being queried.\",\n        \"virtual_table\": \"SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average salary of players from a specific team in the 'salary' table. The placeholder in the WHERE clause represents the name of the team for which the average salary is being calculated.\",\n        \"virtual_table\": \"SELECT avg(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3682", "db_id": "baseball_1", "question": "How much salary did the top 3 well-paid players get in 2001?", "rationale": ["Identify the relevant table for salary data, which is the 'salary' table.", "We need to filter the records for the year 2001, so we will use a WHERE clause to specify 'year = 2001'.", "To find the top 3 well-paid players, we will order the results by 'salary' in descending order.", "Finally, we will limit the results to the top 3 players using 'LIMIT 3'.", "The final SQL query will select the 'player_id' and 'salary' from the 'salary' table with the specified conditions."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2001 ORDER BY salary DESC LIMIT 3;", "source_tables": ["salary"], "pred_sql": "SELECT player_id, salary FROM salary WHERE year = 2001 ORDER BY salary DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total salary of players from a specific team for a given year. The placeholders represent the team's name and the year for which the salary data is being queried.\",\n        \"virtual_table\": \"SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average salary of players from a specific team in the 'salary' table. The placeholder in the WHERE clause represents the name of the team for which the average salary is being calculated.\",\n        \"virtual_table\": \"SELECT avg(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the total count of salary records for a specific team in a given year. The placeholders represent the team's name and the year for which the salary records are being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3683", "db_id": "baseball_1", "question": "What were all the salary values of players in 2010 and 2001?", "rationale": ["Identify the relevant table for salary data, which is the 'salary' table.", "Determine the years of interest, which are 2010 and 2001.", "Construct a SQL query to select the 'salary' column from the 'salary' table where the 'year' is either 2010 or 2001."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2010 UNION SELECT salary FROM salary WHERE YEAR  =  2001", "source_tables": ["salary"], "pred_sql": "SELECT salary FROM salary WHERE year IN (2010, 2001);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total salary of players from a specific team for a given year. The placeholders represent the team's name and the year for which the salary data is being queried.\",\n        \"virtual_table\": \"SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average salary of players from a specific team in the 'salary' table. The placeholder in the WHERE clause represents the name of the team for which the average salary is being calculated.\",\n        \"virtual_table\": \"SELECT avg(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the total count of salary records for a specific team in a given year. The placeholders represent the team's name and the year for which the salary records are being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3685", "db_id": "baseball_1", "question": "In which year did the least people enter hall of fame?", "rationale": ["Identify the relevant table: The 'hall_of_fame' table contains information about Hall of Fame inductions, including the year of induction.", "Count the number of inductions per year: Use COUNT(*) to count the number of entries for each year in the 'hall_of_fame' table.", "Group the results by year: Use GROUP BY yearid to aggregate the counts for each year.", "Order the results: Use ORDER BY num_inductions ASC to sort the years by the number of inductions in ascending order.", "Limit the results to the first entry: Use LIMIT 1 to get only the year with the least number of inductions."], "gold_sql": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT 1;", "source_tables": ["hall_of_fame"], "pred_sql": "SELECT yearid, COUNT(*) AS num_inductions FROM hall_of_fame GROUP BY yearid ORDER BY num_inductions ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3686", "db_id": "baseball_1", "question": "Find the year in which the least people enter hall of fame.", "rationale": ["We need to find the year with the least number of players inducted into the Hall of Fame.", "To do this, we will count the number of inductions for each year using the COUNT() function.", "We will group the results by year using GROUP BY yearid.", "To find the year with the least inductions, we will order the results in ascending order using ORDER BY num_inductions ASC.", "Finally, we will limit the results to only one record using LIMIT 1 to get the year with the least inductions."], "gold_sql": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT 1;", "source_tables": ["hall_of_fame"], "pred_sql": "SELECT yearid, COUNT(*) AS num_inductions FROM hall_of_fame GROUP BY yearid ORDER BY num_inductions ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3689", "db_id": "baseball_1", "question": "How many games were played in park \"Columbia Park\" in 1907?", "rationale": ["Identify the relevant tables: 'home_game' for games played and 'park' for park details.", "Join the 'home_game' table with the 'park' table on the park_id to link games to their respective parks.", "Filter the results to only include games played in 'Columbia Park' and in the year 1907.", "Use the SUM function to calculate the total number of games played in that park for the specified year."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 1907 AND T2.park_name = 'Columbia Park';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(games) FROM home_game AS H JOIN park AS P ON H.park_id = P.park_id WHERE P.park_name = 'Columbia Park' AND H.year = 1907;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the total number of postseason appearances for a specific team, including both wins and losses. It combines data from the 'postseason' table and the 'team' table, filtering by the team's name provided as a placeholder.\",\n        \"virtual_table\": \"SELECT count(*) FROM ( SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] );\"\n    }\n}\n"}
{"sample_id": "train.3690", "db_id": "baseball_1", "question": "Count the number of games taken place in park \"Columbia Park\" in 1907.", "rationale": ["Identify the relevant tables: We need to count the number of games, which are recorded in the 'home_game' table, and we need to filter by the park name, which is in the 'park' table.", "Join the 'home_game' table with the 'park' table on the park_id to access park names.", "Filter the results to only include games that took place in 'Columbia Park' and in the year 1907.", "Use the COUNT function to count the total number of games that meet these criteria."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 1907 AND T2.park_name = 'Columbia Park';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id = T2.park_id WHERE T2.park_name = 'Columbia Park' AND T1.year = 1907;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the total number of postseason appearances for a specific team, including both wins and losses. It combines data from the 'postseason' table and the 'team' table, filtering by the team's name provided as a placeholder.\",\n        \"virtual_table\": \"SELECT count(*) FROM ( SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] );\"\n    }\n}\n"}
{"sample_id": "train.3691", "db_id": "baseball_1", "question": "How many games were played in city Atlanta in 2000?", "rationale": ["Identify the relevant table: The 'home_game' table contains information about games played, including the year and city.", "Determine the columns needed: We need to sum the 'games' column for the specified city and year.", "Construct the SQL query: Use the SUM function to aggregate the total number of games played in Atlanta in 2000, filtering by the specified conditions."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year  =  2000 AND T2.city  =  'Atlanta';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(games) FROM home_game WHERE city = 'Atlanta' AND year = 2000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the total number of postseason appearances for a specific team, including both wins and losses. It combines data from the 'postseason' table and the 'team' table, filtering by the team's name provided as a placeholder.\",\n        \"virtual_table\": \"SELECT count(*) FROM ( SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] );\"\n    }\n}\n"}
{"sample_id": "train.3692", "db_id": "baseball_1", "question": "Find the number of games taken place in city Atlanta in 2000.", "rationale": ["Identify the relevant tables: 'home_game' for game data and 'park' for location data.", "Join the 'home_game' table with the 'park' table on the park_id to access city information.", "Filter the results to only include games that took place in Atlanta in the year 2000.", "Use the SUM function to count the total number of games played in that city and year."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year  =  2000 AND T2.city  =  'Atlanta';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(games) FROM home_game AS H JOIN park AS P ON H.park_id = P.park_id WHERE P.city = 'Atlanta' AND H.year = 2000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the total number of postseason appearances for a specific team, including both wins and losses. It combines data from the 'postseason' table and the 'team' table, filtering by the team's name provided as a placeholder.\",\n        \"virtual_table\": \"SELECT count(*) FROM ( SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] );\"\n    }\n}\n"}
{"sample_id": "train.3693", "db_id": "baseball_1", "question": "What is the total home game attendance of team Boston Red Stockings from 2000 to 2010?", "rationale": ["Identify the relevant tables: 'home_game' for attendance data and 'team' for team identification.", "Join the 'home_game' table with the 'team' table on 'team_id' to filter by team name.", "Filter the results to include only the 'Boston Red Stockings' team.", "Add a condition to sum the attendance for the years between 2000 and 2010."], "gold_sql": "SELECT sum(T1.attendance) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' AND T1.year BETWEEN 2000 AND 2010;", "source_tables": ["team", "home_game"], "pred_sql": "SELECT SUM(attendance) FROM home_game AS H JOIN team AS T ON H.team_id = T.team_id WHERE T.name = 'Boston Red Stockings' AND H.year BETWEEN 2000 AND 2010;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the total number of postseason appearances for a specific team, including both wins and losses. It combines data from the 'postseason' table and the 'team' table, filtering by the team's name provided as a placeholder.\",\n        \"virtual_table\": \"SELECT count(*) FROM ( SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] );\"\n    }\n}\n"}
{"sample_id": "train.3698", "db_id": "baseball_1", "question": "What are the first name and last name of the players who were paid salary by team Washington Nationals in both 2005 and 2007?", "rationale": ["Identify the relevant tables: player, salary, and team.", "Join the player table with the salary table on player_id to get player names and their salaries.", "Join the salary table with the team table on team_id to filter for the Washington Nationals.", "Use a WHERE clause to filter for the years 2005 and 2007.", "Group the results by player_id to ensure we get unique players.", "Use HAVING to ensure that only players who have salaries in both years (count of distinct years = 2) are included."], "gold_sql": "SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2005 AND T3.name = 'Washington Nationals' INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2007 AND T3.name = 'Washington Nationals'", "source_tables": ["team", "player", "salary"], "pred_sql": "SELECT p.name_first, p.name_last \nFROM player AS p \nJOIN salary AS s ON p.player_id = s.player_id \nJOIN team AS t ON s.team_id = t.team_id \nWHERE t.name = 'Washington Nationals' \nAND s.year IN (2005, 2007) \nGROUP BY p.player_id \nHAVING COUNT(DISTINCT s.year) = 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total salary of players from a specific team for a given year. The placeholders represent the team's name and the year for which the salary data is being queried.\",\n        \"virtual_table\": \"SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3702", "db_id": "baseball_1", "question": "Find the team that attended the least number of home games in 1980.", "rationale": ["Identify the relevant table: The 'home_game' table contains information about home games played by teams.", "Determine the year of interest: The query specifies the year 1980.", "Count the total number of home games for each team in 1980: Use the COUNT function to aggregate the number of games per team.", "Group the results by team_id to get the total home games for each team.", "Order the results by the total number of home games in ascending order to find the team with the least number of home games.", "Limit the results to 1 to get only the team with the least number of home games."], "gold_sql": "SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = 1980 ORDER BY T1.attendance ASC LIMIT 1;", "source_tables": ["team", "home_game"], "pred_sql": "SELECT team_id, MIN(games) AS min_home_games FROM home_game WHERE year = 1980 GROUP BY team_id ORDER BY min_home_games ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the total number of postseason appearances for a specific team, including both wins and losses. It combines data from the 'postseason' table and the 'team' table, filtering by the team's name provided as a placeholder.\",\n        \"virtual_table\": \"SELECT count(*) FROM ( SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] );\"\n    }\n}\n"}
{"sample_id": "train.3709", "db_id": "baseball_1", "question": "Which park had most attendances in 2008?", "rationale": ["Identify the relevant tables: home_game (for attendance data) and park (for park names).", "Join the home_game table with the park table on the park_id to get the park names along with their attendance.", "Filter the results for the year 2008 using a WHERE clause.", "Order the results by attendance in descending order to get the park with the highest attendance at the top.", "Limit the results to 1 to get only the park with the most attendance."], "gold_sql": "SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 2008 ORDER BY T1.attendance DESC LIMIT 1;", "source_tables": ["park", "home_game"], "pred_sql": "SELECT park_name, attendance FROM home_game JOIN park ON home_game.park_id = park.park_id WHERE year = 2008 ORDER BY attendance DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3857", "db_id": "insurance_policies", "question": "Find the settlement amount of the claim with the largest claim amount. Show both the settlement amount and claim amount.", "rationale": ["Identify the tables involved: Claims and Settlements.", "We need to find the claim with the largest claim amount, so we will use a subquery to get the maximum Amount_Claimed from the Claims table.", "Join the Claims table with the Settlements table on Claim_ID to access the corresponding settlement amounts.", "Select the Amount_Settled from the Settlements table and Amount_Claimed from the Claims table where the Amount_Claimed matches the maximum value found in the subquery."], "gold_sql": "SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Claimed DESC LIMIT 1", "source_tables": ["claims"], "pred_sql": "SELECT s.Amount_Settled, c.Amount_Claimed \nFROM Claims c \nJOIN Settlements s ON c.Claim_ID = s.Claim_ID \nWHERE c.Amount_Claimed = (SELECT MAX(Amount_Claimed) FROM Claims);", "hint": "\n"}
{"sample_id": "train.3862", "db_id": "insurance_policies", "question": "Among all the claims, which settlements have a claimed amount that is no more than the average? List the claim start date.", "rationale": ["Identify the relevant tables: Settlements and Claims.", "We need to find settlements where the claimed amount is no more than the average claimed amount.", "To do this, we will calculate the average claimed amount from the Settlements table using a subquery.", "We will join the Settlements table with the Claims table to access the claim start date.", "Select the Date_Claim_Made from the Claims table and Amount_Claimed from the Settlements table where the Amount_Claimed is less than or equal to the average."], "gold_sql": "SELECT Date_Claim_Made FROM Claims WHERE Amount_Settled  <=  ( SELECT avg(Amount_Settled) FROM Claims )", "source_tables": ["claims"], "pred_sql": "SELECT s.Date_Claim_Made, s.Amount_Claimed \nFROM Settlements s \nJOIN Claims c ON s.Claim_ID = c.Claim_ID \nWHERE s.Amount_Claimed <= (SELECT AVG(Amount_Claimed) FROM Settlements);", "hint": "\n"}
{"sample_id": "train.3863", "db_id": "insurance_policies", "question": "Return the claim start date for the claims whose claimed amount is no more than the average", "rationale": ["Identify the relevant table: Claims, since we need information about claims.", "We need to select the 'Date_Claim_Made' from the Claims table.", "We need to filter the results based on the condition that 'Amount_Claimed' is no more than the average claimed amount.", "To find the average claimed amount, we will use a subquery that calculates the average of 'Amount_Claimed' from the Claims table.", "Combine the selection of 'Date_Claim_Made' with the filtering condition using a WHERE clause."], "gold_sql": "SELECT Date_Claim_Made FROM Claims WHERE Amount_Settled  <=  ( SELECT avg(Amount_Settled) FROM Claims )", "source_tables": ["claims"], "pred_sql": "SELECT Claims.Date_Claim_Made\nFROM Claims\nWHERE Claims.Amount_Claimed <= (SELECT AVG(Amount_Claimed) FROM Claims);", "hint": "\n"}
{"sample_id": "train.3868", "db_id": "insurance_policies", "question": "How many settlements were made on the claim with the most recent claim settlement date? List the number and the claim id.", "rationale": ["Identify the table that contains the information about settlements, which is the 'Settlements' table.", "We need to count the number of settlements, so we will use the COUNT() function on 'Settlement_ID'.", "We also need to retrieve the 'Claim_ID' associated with these settlements.", "To find the claim with the most recent settlement date, we will need to look at the 'Claims' table and order by 'Date_Claim_Settled' in descending order, limiting the result to the most recent one.", "We will use a subquery to get the 'Claim_ID' of the most recent claim settlement date.", "Finally, we will group the results by 'Claim_ID' to ensure we get the count of settlements for that specific claim."], "gold_sql": "SELECT count(*) ,  T1.claim_id FROM Claims AS T1 JOIN Settlements AS T2 ON T1.claim_id  =  T2.claim_id GROUP BY T1.claim_id ORDER BY T1.Date_Claim_Settled DESC LIMIT 1", "source_tables": ["claims", "settlements"], "pred_sql": "SELECT COUNT(Settlement_ID) AS Number_of_Settlements, Claim_ID \nFROM Settlements \nWHERE Claim_ID = (\n    SELECT Claim_ID \n    FROM Claims \n    ORDER BY Date_Claim_Settled DESC \n    LIMIT 1\n) \nGROUP BY Claim_ID;", "hint": "\n"}
{"sample_id": "train.3869", "db_id": "insurance_policies", "question": "Find the claim id and the number of settlements made for the claim with the most recent settlement date.", "rationale": ["Identify the relevant tables: Claims and Settlements.", "We need to find the claim ID and the number of settlements for the claim with the most recent settlement date.", "Join the Claims table with the Settlements table on Claim_ID to link claims with their settlements.", "Use a subquery to find the maximum Date_Claim_Settled from the Settlements table, which gives us the most recent settlement date.", "Filter the results to only include settlements that match this most recent date.", "Group the results by Claim_ID to count the number of settlements for each claim."], "gold_sql": "SELECT count(*) ,  T1.claim_id FROM Claims AS T1 JOIN Settlements AS T2 ON T1.claim_id  =  T2.claim_id GROUP BY T1.claim_id ORDER BY T1.Date_Claim_Settled DESC LIMIT 1", "source_tables": ["claims", "settlements"], "pred_sql": "SELECT Claims.Claim_ID, COUNT(Settlements.Settlement_ID) AS Number_of_Settlements\nFROM Claims\nJOIN Settlements ON Claims.Claim_ID = Settlements.Claim_ID\nWHERE Settlements.Date_Claim_Settled = (\n    SELECT MAX(Date_Claim_Settled)\n    FROM Settlements\n)\nGROUP BY Claims.Claim_ID;", "hint": "\n"}
{"sample_id": "train.3878", "db_id": "insurance_policies", "question": "What is the most popular payment method?", "rationale": ["Identify the relevant table: The Payments table contains information about payment transactions, including the payment method.", "Determine the required information: We need to find the most popular payment method, which implies counting the occurrences of each payment method.", "Use the COUNT function: To find out how many times each payment method was used, we will use the COUNT function on the Payment_Method_Code column.", "Group the results: We will group the results by Payment_Method_Code to aggregate the counts for each method.", "Order the results: To find the most popular method, we will order the results in descending order based on the count of payments.", "Limit the results: Since we only want the most popular payment method, we will limit the results to 1."], "gold_sql": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["payments"], "pred_sql": "SELECT Payment_Method_Code, COUNT(*) AS Payment_Count\nFROM Payments\nGROUP BY Payment_Method_Code\nORDER BY Payment_Count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3879", "db_id": "insurance_policies", "question": "Which payment method is used the most often?", "rationale": ["Identify the relevant table: The question is about payment methods, so we will focus on the Payments table.", "Determine the required information: We need to find out which payment method is used the most often, which implies counting occurrences of each payment method.", "Use the COUNT function: We will count the number of times each Payment_Method_Code appears in the Payments table.", "Group the results: To get the count for each payment method, we will use GROUP BY on Payment_Method_Code.", "Order the results: To find the most used payment method, we will order the results in descending order based on the count.", "Limit the results: Since we only want the most frequently used payment method, we will limit the results to 1."], "gold_sql": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["payments"], "pred_sql": "SELECT Payment_Method_Code, COUNT(*) AS Method_Count\nFROM Payments\nGROUP BY Payment_Method_Code\nORDER BY Method_Count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3880", "db_id": "insurance_policies", "question": "With which kind of payment method were the least number of payments processed?", "rationale": ["Identify the relevant table: The Payments table contains information about payment transactions, including the payment method and the number of payments.", "Group the data: We need to group the results by Payment_Method_Code to count the number of payments for each method.", "Count the payments: Use COUNT(Payment_ID) to get the total number of payments for each payment method.", "Order the results: We will order the results in ascending order based on the count of payments to find the method with the least number of payments.", "Limit the results: Finally, we will limit the output to 1 to get only the payment method with the least number of payments."], "gold_sql": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) ASC LIMIT 1", "source_tables": ["payments"], "pred_sql": "SELECT Payment_Method_Code, COUNT(Payment_ID) AS Number_of_Payments\nFROM Payments\nGROUP BY Payment_Method_Code\nORDER BY Number_of_Payments ASC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3886", "db_id": "insurance_policies", "question": "Which kind of policy type was chosen by the most customers?", "rationale": ["Identify the relevant tables: We need to look at the 'Customer_Policies' table to find the policy types and the associated customers.", "Count the number of customers for each policy type: We can use the COUNT function to count how many customers are linked to each policy type.", "Group the results by policy type: We will use GROUP BY on 'Policy_Type_Code' to aggregate the counts for each type of policy.", "Order the results to find the most chosen policy type: We will order the results in descending order based on the count of customers.", "Limit the results to get only the top result: We will use LIMIT 1 to get the policy type chosen by the most customers."], "gold_sql": "SELECT Policy_Type_Code FROM Customer_Policies GROUP BY Policy_Type_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customer_policies"], "pred_sql": "SELECT Policy_Type_Code, COUNT(Customer_ID) AS Customer_Count\nFROM Customer_Policies\nGROUP BY Policy_Type_Code\nORDER BY Customer_Count DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of customer details from the 'Customers' table, excluding those customers who have associated insurance policies. The query uses an EXCEPT clause to filter out customers that are linked to any policies in the 'Customer_Policies' table.\",\n        \"virtual_table\": \"SELECT customer_details FROM Customers EXCEPT SELECT T1.customer_details FROM Customers AS T1 JOIN Customer_Policies AS T2 ON T1.customer_id  =  T2.customer_id\"\n    }\n}\n"}
{"sample_id": "train.3893", "db_id": "insurance_policies", "question": "Which customers do not have any policies? Find the details of these customers.", "rationale": ["Identify the main table to retrieve customer details, which is the 'Customers' table.", "Determine the need to exclude customers who have policies, which are listed in the 'Customer_Policies' table.", "Use a subquery to select customer details from 'Customers' that are linked to 'Customer_Policies'.", "Utilize the EXCEPT clause to filter out these customers from the main selection of customer details."], "gold_sql": "SELECT customer_details FROM Customers EXCEPT SELECT T1.customer_details FROM Customers AS T1 JOIN Customer_Policies AS T2 ON T1.customer_id  =  T2.customer_id", "source_tables": ["customer_policies", "customers"], "pred_sql": "SELECT customer_details FROM Customers EXCEPT SELECT T1.Customer_Details FROM Customers AS T1 JOIN Customer_Policies AS T2 ON T1.Customer_ID = T2.Customer_ID", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of customer details from the 'Customers' table, excluding those customers who have associated insurance policies. The query uses an EXCEPT clause to filter out customers that are linked to any policies in the 'Customer_Policies' table.\",\n        \"virtual_table\": \"SELECT customer_details FROM Customers EXCEPT SELECT T1.customer_details FROM Customers AS T1 JOIN Customer_Policies AS T2 ON T1.customer_id  =  T2.customer_id\"\n    }\n}\n"}
{"sample_id": "train.3895", "db_id": "insurance_policies", "question": "Which claims had exactly one settlement? For each, tell me the the date the claim was made, the date it was settled and the amount settled.", "rationale": ["Identify the relevant tables: Claims and Settlements.", "We need to find claims that have exactly one settlement, so we will join the Claims table with the Settlements table on the Claim_ID.", "We will select the required fields: Date_Claim_Made, Date_Claim_Settled, and Amount_Settled.", "To ensure we only get claims with exactly one settlement, we will group the results by Claim_ID and use the HAVING clause to filter groups with a count of settlements equal to 1."], "gold_sql": "SELECT T1.claim_id ,  T1.date_claim_made ,  T1.Date_Claim_Settled FROM Claims AS T1 JOIN Settlements AS T2 ON T1.Claim_id  =  T2.Claim_id GROUP BY T1.claim_id HAVING count(*)  =  1", "source_tables": ["claims", "settlements"], "pred_sql": "SELECT Claims.Date_Claim_Made, Claims.Date_Claim_Settled, Settlements.Amount_Settled\nFROM Claims\nJOIN Settlements ON Claims.Claim_ID = Settlements.Claim_ID\nGROUP BY Claims.Claim_ID\nHAVING COUNT(Settlements.Settlement_ID) = 1;", "hint": "\n"}
{"sample_id": "train.3898", "db_id": "hospital_1", "question": "Which department has the largest number of employees?", "rationale": ["Identify the relevant tables: Department and Physician.", "We need to count the number of employees in each department, which requires joining the Department table with the Physician table.", "Use a LEFT JOIN to include all departments even if they have no physicians.", "Group the results by department name to count the number of employees in each department.", "Order the results by the count of employees in descending order to find the department with the largest number of employees.", "Limit the results to 1 to get only the department with the largest number of employees."], "gold_sql": "SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT 1;", "source_tables": ["department"], "pred_sql": "SELECT d.Name, COUNT(p.EmployeeID) AS EmployeeCount\nFROM Department d\nLEFT JOIN Physician p ON d.Head = p.EmployeeID\nGROUP BY d.Name\nORDER BY EmployeeCount DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3899", "db_id": "hospital_1", "question": "Find the department with the most employees.", "rationale": ["To find the department with the most employees, we need to count the number of physicians affiliated with each department.", "We will join the 'Department' table with the 'Affiliated_With' table on the department ID.", "We will group the results by department name to count the number of physicians in each department.", "We will use the COUNT function to count the number of physicians for each department.", "To get the department with the most employees, we will order the results by the count of employees in descending order.", "Finally, we will limit the results to 1 to get only the department with the highest count."], "gold_sql": "SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT 1;", "source_tables": ["department"], "pred_sql": "SELECT Department.Name, COUNT(Affiliated_With.Physician) AS EmployeeCount\nFROM Department\nJOIN Affiliated_With ON Department.DepartmentID = Affiliated_With.Department\nGROUP BY Department.Name\nORDER BY EmployeeCount DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3901", "db_id": "hospital_1", "question": "Tell me the employee id of the head of the department with the least employees.", "rationale": ["Identify the department with the least employees by counting the number of physicians affiliated with each department.", "Use a JOIN between the Department and Affiliated_With tables to link departments with their physicians.", "Group the results by DepartmentID to count the number of physicians in each department.", "Order the results in ascending order based on the count of physicians to get the department with the least employees at the top.", "Limit the results to 1 to get only the head of that department."], "gold_sql": "SELECT head FROM department GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["department"], "pred_sql": "SELECT Department.Head\nFROM Department\nJOIN Affiliated_With ON Department.DepartmentID = Affiliated_With.Department\nGROUP BY Department.DepartmentID\nORDER BY COUNT(Affiliated_With.Physician) ASC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3902", "db_id": "hospital_1", "question": "what is the name and position of the head whose department has least number of employees?", "rationale": ["We need to find the name and position of the head of the department with the least number of employees.", "The head of a department is identified by the 'Head' column in the Department table, which corresponds to the 'EmployeeID' in the Physician table.", "To find the department with the least number of employees, we can use the Affiliated_With table to count how many physicians are affiliated with each department.", "We will group by the department and order by the count of physicians in ascending order, limiting the result to 1 to get the department with the least number of employees.", "Finally, we will join the Physician and Department tables to get the name and position of the head of that department."], "gold_sql": "SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["physician", "department"], "pred_sql": "SELECT Physician.Name, Physician.Position \nFROM Physician \nJOIN Department ON Physician.EmployeeID = Department.Head \nWHERE Department.DepartmentID = \n  (SELECT Affiliated_With.Department \n   FROM Affiliated_With \n   GROUP BY Affiliated_With.Department \n   ORDER BY COUNT(Affiliated_With.Physician) ASC \n   LIMIT 1);", "hint": "\n"}
{"sample_id": "train.3903", "db_id": "hospital_1", "question": "Find the name and position of the head of the department with the least employees.", "rationale": ["Identify the department with the least employees by counting the number of physicians affiliated with each department.", "Use a subquery to select the DepartmentID that has the minimum count of physicians.", "Join the Department table with the Physician table to get the head of that department.", "Select the Name and Position of the physician who is the head of the department identified in the previous step."], "gold_sql": "SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["physician", "department"], "pred_sql": "SELECT Physician.Name, Physician.Position \nFROM Department \nJOIN Physician ON Department.Head = Physician.EmployeeID \nWHERE Department.DepartmentID = \n    (SELECT DepartmentID \n     FROM Affiliated_With \n     GROUP BY DepartmentID \n     ORDER BY COUNT(Physician) ASC \n     LIMIT 1);", "hint": "\n"}
{"sample_id": "train.3904", "db_id": "hospital_1", "question": "What are names of patients who made an appointment?", "rationale": ["Identify the relevant tables: Appointment and Patient.", "Determine the relationship between the tables: The Appointment table has a Patient identifier that corresponds to the SSN in the Patient table.", "Construct the SQL query to select the names of patients by joining the Appointment table with the Patient table on the appropriate identifiers."], "gold_sql": "SELECT name FROM appointment AS T1 JOIN patient AS T2 ON T1.patient  =  T2.ssn", "source_tables": ["patient", "appointment"], "pred_sql": "SELECT T2.Name FROM Appointment AS T1 JOIN Patient AS T2 ON T1.Patient = T2.SSN", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of physicians who are conducting appointments. The query joins the 'Appointment' table with the 'Physician' table based on the physician's unique identifier, allowing for the retrieval of physician names associated with each appointment.\",\n        \"virtual_table\": \"SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names of patients associated with their appointments from the 'Appointment' and 'Patient' tables. The join condition links the patient identifier in the 'Appointment' table to the Social Security Number in the 'Patient' table.\",\n        \"virtual_table\": \"SELECT name FROM appointment AS T1 JOIN patient AS T2 ON T1.patient  =  T2.ssn\"\n    },\n    \"2\": {\n        \"description\": \"The virtual table describes the names of physicians who are conducting appointments. It retrieves the physician's name from the 'Physician' table by joining it with the 'Appointment' table based on the physician's unique identifier. This allows for a clear association between appointments and the physicians responsible for them.\",\n        \"virtual_table\": \"SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID\"\n    }\n}\n"}
{"sample_id": "train.3914", "db_id": "hospital_1", "question": "Find the names of all physicians and their primary affiliated departments' names.", "rationale": ["Identify the tables needed: Physician, Affiliated_With, and Department.", "We need to retrieve the names of physicians and their affiliated departments.", "Join the Physician table with the Affiliated_With table on the EmployeeID and Physician columns respectively.", "Then, join the result with the Department table on the Department column from Affiliated_With and DepartmentID from Department.", "Select the names of physicians and their corresponding department names.", "Filter the results to include only primary affiliations by checking the PrimaryAffiliation column."], "gold_sql": "SELECT T1.name ,  T3.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T2.PrimaryAffiliation  =  1", "source_tables": ["physician", "department", "affiliated_with"], "pred_sql": "SELECT P.Name AS PhysicianName, D.Name AS DepartmentName\nFROM Physician P\nJOIN Affiliated_With AW ON P.EmployeeID = AW.Physician\nJOIN Department D ON AW.Department = D.DepartmentID\nWHERE AW.PrimaryAffiliation = 'Yes';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of physicians who are conducting appointments. The query joins the 'Appointment' table with the 'Physician' table based on the physician's unique identifier, allowing for the retrieval of physician names associated with each appointment.\",\n        \"virtual_table\": \"SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of physicians from the 'Physician' table who have prescribed medications, ordered by the dosage of the medications in descending order. The placeholder in the LIMIT clause represents the maximum number of physician names to be returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"The virtual table describes the names of physicians who are conducting appointments. It retrieves the physician's name from the 'Physician' table by joining it with the 'Appointment' table based on the physician's unique identifier. This allows for a clear association between appointments and the physicians responsible for them.\",\n        \"virtual_table\": \"SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID\"\n    }\n}\n"}
{"sample_id": "train.3928", "db_id": "hospital_1", "question": "How many patients do each physician take care of? List their names and number of patients they take care of.", "rationale": ["Identify the relevant tables: Physician and Appointment.", "We need to count the number of patients each physician takes care of, which implies a relationship between physicians and patients through appointments.", "Join the Physician table with the Appointment table on the physician's unique identifier (EmployeeID).", "Use COUNT(DISTINCT A.Patient) to count unique patients for each physician.", "Group the results by physician name to get the count for each physician."], "gold_sql": "SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid", "source_tables": ["physician", "patient"], "pred_sql": "SELECT P.Name, COUNT(DISTINCT A.Patient) AS NumberOfPatients\nFROM Physician P\nJOIN Appointment A ON P.EmployeeID = A.Physician\nGROUP BY P.Name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of physicians from the 'Physician' table who have prescribed medications, ordered by the dosage of the medications in descending order. The placeholder in the LIMIT clause represents the maximum number of physician names to be returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of physicians who are conducting appointments. The query joins the 'Appointment' table with the 'Physician' table based on the physician's unique identifier, allowing for the retrieval of physician names associated with each appointment.\",\n        \"virtual_table\": \"SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of physicians who are trained in specific procedures that have a cost exceeding a certain amount. The placeholders in the WHERE clause represent the cost threshold for the procedures.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3930", "db_id": "hospital_1", "question": "Find the name of physicians who are in charge of more than one patient.", "rationale": ["We need to find physicians who are in charge of more than one patient.", "To do this, we will use the Appointment table, which links physicians to patients through appointments.", "We will join the Appointment table with the Physician table to get the names of the physicians.", "Next, we will group the results by physician name to count how many patients each physician is in charge of.", "Finally, we will use the HAVING clause to filter out those physicians who are in charge of more than one patient."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  1", "source_tables": ["physician", "patient"], "pred_sql": "SELECT T2.Name\nFROM Appointment AS T1\nJOIN Physician AS T2 ON T1.Physician = T2.EmployeeID\nGROUP BY T2.Name\nHAVING COUNT(T1.Patient) > 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of physicians who are trained in specific procedures that have a cost exceeding a certain amount. The placeholders in the WHERE clause represent the cost threshold for the procedures.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of physicians who are conducting appointments. The query joins the 'Appointment' table with the 'Physician' table based on the physician's unique identifier, allowing for the retrieval of physician names associated with each appointment.\",\n        \"virtual_table\": \"SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of physicians from the 'Physician' table who have prescribed medications, ordered by the dosage of the medications in descending order. The placeholder in the LIMIT clause represents the maximum number of physician names to be returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3940", "db_id": "hospital_1", "question": "What is the names of the physicians who prescribe medication Thesisin?", "rationale": ["Identify the relevant tables: Physician, Prescribes, and Medication.", "Join the Physician table with the Prescribes table on the EmployeeID and Physician columns to get the physicians who have prescribed medications.", "Join the resulting table with the Medication table on the Medication column to filter for the specific medication 'Thesisin'.", "Select the Name of the physicians from the final joined table where the medication name matches 'Thesisin'."], "gold_sql": "SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  'Thesisin'", "source_tables": ["physician", "prescribes", "medication"], "pred_sql": "SELECT T1.Name FROM Physician AS T1 JOIN Prescribes AS T2 ON T1.EmployeeID = T2.Physician JOIN Medication AS T3 ON T2.Medication = T3.Code WHERE T3.Name = 'Thesisin';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of physicians from the 'Physician' table who have prescribed medications, ordered by the dosage of the medications in descending order. The placeholder in the LIMIT clause represents the maximum number of physician names to be returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of physicians who are conducting appointments. The query joins the 'Appointment' table with the 'Physician' table based on the physician's unique identifier, allowing for the retrieval of physician names associated with each appointment.\",\n        \"virtual_table\": \"SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of physicians who are trained in specific procedures that have a cost exceeding a certain amount. The placeholders in the WHERE clause represent the cost threshold for the procedures.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3941", "db_id": "hospital_1", "question": "List the names of all the physicians who prescribe Thesisin as medication.", "rationale": ["Identify the relevant tables: Physician, Prescribes, and Medication.", "We need to find the names of physicians who have prescribed a specific medication, 'Thesisin'.", "Join the Physician table (T1) with the Prescribes table (T2) on the physician's identifier (EmployeeID).", "Next, join the Prescribes table (T2) with the Medication table (T3) on the medication code.", "Filter the results to include only those records where the medication name is 'Thesisin'.", "Select the names of the physicians from the resulting joined tables."], "gold_sql": "SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  'Thesisin'", "source_tables": ["physician", "prescribes", "medication"], "pred_sql": "SELECT T1.Name FROM Physician AS T1 JOIN Prescribes AS T2 ON T1.EmployeeID = T2.Physician JOIN Medication AS T3 ON T2.Medication = T3.Code WHERE T3.Name = 'Thesisin';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of physicians from the 'Physician' table who have prescribed medications, ordered by the dosage of the medications in descending order. The placeholder in the LIMIT clause represents the maximum number of physician names to be returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of physicians who are conducting appointments. The query joins the 'Appointment' table with the 'Physician' table based on the physician's unique identifier, allowing for the retrieval of physician names associated with each appointment.\",\n        \"virtual_table\": \"SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of physicians who are trained in specific procedures that have a cost exceeding a certain amount. The placeholders in the WHERE clause represent the cost threshold for the procedures.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3944", "db_id": "hospital_1", "question": "Find the number of medications prescribed for each brand.", "rationale": ["To find the number of medications prescribed for each brand, we need to join the 'Medication' table with the 'Prescribes' table.", "The 'Medication' table contains the 'Brand' column which we want to group by.", "The 'Prescribes' table contains the medication codes that link to the 'Medication' table.", "We will use a JOIN operation on the 'Code' from 'Medication' and 'Medication' from 'Prescribes'.", "After joining, we will use the COUNT function to count the number of prescriptions for each brand.", "Finally, we will group the results by the 'Brand' column to get the count for each brand."], "gold_sql": "SELECT count(*) ,  T1.name FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand", "source_tables": ["prescribes", "medication"], "pred_sql": "SELECT Brand, COUNT(*) AS NumberOfMedications\nFROM Medication\nJOIN Prescribes ON Medication.Code = Prescribes.Medication\nGROUP BY Brand;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of physicians from the 'Physician' table who have prescribed medications, ordered by the dosage of the medications in descending order. The placeholder in the LIMIT clause represents the maximum number of physician names to be returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of physicians who are conducting appointments. The query joins the 'Appointment' table with the 'Physician' table based on the physician's unique identifier, allowing for the retrieval of physician names associated with each appointment.\",\n        \"virtual_table\": \"SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of medical procedures from the 'Procedures' table, ordered by their associated costs. The placeholder in the LIMIT clause allows the user to specify the maximum number of procedure names to retrieve.\",\n        \"virtual_table\": \"SELECT name FROM procedures ORDER BY cost LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3948", "db_id": "hospital_1", "question": "Find the patient who has the most recent undergoing treatment?", "rationale": ["We need to find the patient who has undergone treatment most recently.", "The relevant tables for this query are 'Undergoes' (which records the procedures patients have undergone) and 'Patient' (which contains patient details).", "We will join the 'Undergoes' table with the 'Patient' table on the patient identifier, which is the SSN in the 'Patient' table.", "To find the most recent undergoing treatment, we will order the results by the 'DateUndergoes' column in descending order.", "Finally, we will limit the results to 1 to get only the most recent patient."], "gold_sql": "SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT 1", "source_tables": ["undergoes"], "pred_sql": "SELECT T2.Name FROM Undergoes AS T1 JOIN Patient AS T2 ON T1.Patient = T2.SSN ORDER BY T1.DateUndergoes DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of physicians from the 'Physician' table who have prescribed medications, ordered by the dosage of the medications in descending order. The placeholder in the LIMIT clause represents the maximum number of physician names to be returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names of patients associated with their appointments from the 'Appointment' and 'Patient' tables. The join condition links the patient identifier in the 'Appointment' table to the Social Security Number in the 'Patient' table.\",\n        \"virtual_table\": \"SELECT name FROM appointment AS T1 JOIN patient AS T2 ON T1.patient  =  T2.ssn\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of physicians who are conducting appointments. The query joins the 'Appointment' table with the 'Physician' table based on the physician's unique identifier, allowing for the retrieval of physician names associated with each appointment.\",\n        \"virtual_table\": \"SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID\"\n    }\n}\n"}
{"sample_id": "train.3949", "db_id": "hospital_1", "question": "Which patient is undergoing the most recent treatment?", "rationale": ["Identify the relevant tables: We need to find patients undergoing treatments, which involves the 'Undergoes' and 'Patient' tables.", "Join the 'Undergoes' table with the 'Patient' table on the patient identifier (SSN) to get patient names.", "Order the results by the date of the procedures (DateUndergoes) in descending order to get the most recent treatment first.", "Limit the results to 1 to get only the most recent patient undergoing treatment."], "gold_sql": "SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT 1", "source_tables": ["undergoes"], "pred_sql": "SELECT T2.Name FROM Undergoes AS T1 JOIN Patient AS T2 ON T1.Patient = T2.SSN ORDER BY T1.DateUndergoes DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of physicians from the 'Physician' table who have prescribed medications, ordered by the dosage of the medications in descending order. The placeholder in the LIMIT clause represents the maximum number of physician names to be returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names of patients associated with their appointments from the 'Appointment' and 'Patient' tables. The join condition links the patient identifier in the 'Appointment' table to the Social Security Number in the 'Patient' table.\",\n        \"virtual_table\": \"SELECT name FROM appointment AS T1 JOIN patient AS T2 ON T1.patient  =  T2.ssn\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of physicians who are trained in specific procedures that have a cost exceeding a certain amount. The placeholders in the WHERE clause represent the cost threshold for the procedures.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3959", "db_id": "hospital_1", "question": "Find the physician who prescribed the highest dose. What is his or her name?", "rationale": ["Identify the relevant tables: 'Physician' for physician names and 'Prescribes' for dosage information.", "Join the 'Physician' table with the 'Prescribes' table on the physician's unique identifier (EmployeeID).", "Select the name of the physician from the 'Physician' table.", "Order the results by the dosage in descending order to get the highest dose first.", "Limit the results to 1 to get only the physician who prescribed the highest dose."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT 1", "source_tables": ["physician", "prescribes"], "pred_sql": "SELECT T1.Name FROM Physician AS T1 JOIN Prescribes AS T2 ON T1.EmployeeID = T2.Physician ORDER BY T2.Dose DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of physicians from the 'Physician' table who have prescribed medications, ordered by the dosage of the medications in descending order. The placeholder in the LIMIT clause represents the maximum number of physician names to be returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of physicians who are conducting appointments. The query joins the 'Appointment' table with the 'Physician' table based on the physician's unique identifier, allowing for the retrieval of physician names associated with each appointment.\",\n        \"virtual_table\": \"SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of physicians who are trained in specific procedures that have a cost exceeding a certain amount. The placeholders in the WHERE clause represent the cost threshold for the procedures.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3960", "db_id": "hospital_1", "question": "List the physicians' employee ids together with their primary affiliation departments' ids.", "rationale": ["Identify the relevant tables: Physician and Affiliated_With.", "We need to retrieve the EmployeeID from the Physician table and the Department from the Affiliated_With table.", "Join the Physician table with the Affiliated_With table on the EmployeeID and Physician identifiers respectively.", "Filter the results to include only those records where the affiliation is marked as primary (assuming a value like 'Yes' indicates primary affiliation)."], "gold_sql": "SELECT physician ,  department FROM affiliated_with WHERE primaryaffiliation  =  1", "source_tables": ["affiliated_with"], "pred_sql": "SELECT P.EmployeeID, A.Department FROM Physician AS P JOIN Affiliated_With AS A ON P.EmployeeID = A.Physician WHERE A.PrimaryAffiliation = 'Yes';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of physicians who are conducting appointments. The query joins the 'Appointment' table with the 'Physician' table based on the physician's unique identifier, allowing for the retrieval of physician names associated with each appointment.\",\n        \"virtual_table\": \"SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table describes the names of physicians who are conducting appointments. It retrieves the physician's name from the 'Physician' table by joining it with the 'Appointment' table based on the physician's unique identifier. This allows for a clear association between appointments and the physicians responsible for them.\",\n        \"virtual_table\": \"SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of physicians from the 'Physician' table who have prescribed medications, ordered by the dosage of the medications in descending order. The placeholder in the LIMIT clause represents the maximum number of physician names to be returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3971", "db_id": "hospital_1", "question": "What are the three most costly procedures?", "rationale": ["The task is to find the three most costly procedures.", "To achieve this, we need to select the 'Name' column from the 'Procedures' table.", "We will order the results by the 'Cost' column in descending order to get the most expensive procedures first.", "Finally, we will limit the results to 3 to get only the top three procedures."], "gold_sql": "SELECT name FROM procedures ORDER BY cost LIMIT 3", "source_tables": ["procedures"], "pred_sql": "SELECT Name FROM Procedures ORDER BY Cost DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of medical procedures from the 'Procedures' table, ordered by their associated costs. The placeholder in the LIMIT clause allows the user to specify the maximum number of procedure names to retrieve.\",\n        \"virtual_table\": \"SELECT name FROM procedures ORDER BY cost LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of physicians who are trained in specific procedures that have a cost exceeding a certain amount. The placeholders in the WHERE clause represent the cost threshold for the procedures.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of physicians who are conducting appointments. The query joins the 'Appointment' table with the 'Physician' table based on the physician's unique identifier, allowing for the retrieval of physician names associated with each appointment.\",\n        \"virtual_table\": \"SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID\"\n    }\n}\n"}
{"sample_id": "train.3972", "db_id": "hospital_1", "question": "Find the physicians who are trained in a procedure that costs more than 5000.", "rationale": ["Identify the relevant tables: Physician, Trained_In, and Procedures.", "Join the Physician table with the Trained_In table on the EmployeeID and Physician columns to get the physicians and their trained procedures.", "Join the resulting table with the Procedures table on the Treatment and Code columns to access the cost of each procedure.", "Filter the results to include only those procedures where the cost is greater than 5000."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  5000", "source_tables": ["physician", "procedures", "trained_in"], "pred_sql": "SELECT T1.Name FROM Physician AS T1 JOIN Trained_In AS T2 ON T1.EmployeeID = T2.Physician JOIN Procedures AS T3 ON T3.Code = T2.Treatment WHERE T3.Cost > 5000", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of physicians who are trained in specific procedures that have a cost exceeding a certain amount. The placeholders in the WHERE clause represent the cost threshold for the procedures.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of medical procedures from the 'Procedures' table, ordered by their associated costs. The placeholder in the LIMIT clause allows the user to specify the maximum number of procedure names to retrieve.\",\n        \"virtual_table\": \"SELECT name FROM procedures ORDER BY cost LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of physicians from the 'Physician' table who have prescribed medications, ordered by the dosage of the medications in descending order. The placeholder in the LIMIT clause represents the maximum number of physician names to be returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3974", "db_id": "hospital_1", "question": "Find the physician who was trained in the most expensive procedure?", "rationale": ["Identify the tables involved: Physician, Trained_In, and Procedures.", "We need to find physicians trained in procedures, so we will join Physician and Trained_In on EmployeeID and Physician respectively.", "Next, we join the Procedures table to get the cost of each procedure.", "To find the most expensive procedure, we will use a subquery to get the maximum cost from the Procedures table.", "Finally, we will filter the results to only include physicians trained in the procedure that has the maximum cost."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment ORDER BY T3.cost DESC LIMIT 1", "source_tables": ["physician", "procedures", "trained_in"], "pred_sql": "SELECT T1.Name FROM Physician AS T1 JOIN Trained_In AS T2 ON T1.EmployeeID = T2.Physician JOIN Procedures AS T3 ON T3.Code = T2.Treatment WHERE T3.Cost = (SELECT MAX(Cost) FROM Procedures)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of physicians who are trained in specific procedures that have a cost exceeding a certain amount. The placeholders in the WHERE clause represent the cost threshold for the procedures.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of medical procedures from the 'Procedures' table, ordered by their associated costs. The placeholder in the LIMIT clause allows the user to specify the maximum number of procedure names to retrieve.\",\n        \"virtual_table\": \"SELECT name FROM procedures ORDER BY cost LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of physicians from the 'Physician' table who have prescribed medications, ordered by the dosage of the medications in descending order. The placeholder in the LIMIT clause represents the maximum number of physician names to be returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3980", "db_id": "hospital_1", "question": "Find all procedures which cost more than 1000 or which physician John Wen was trained in.", "rationale": ["Identify the procedures that cost more than 1000 by querying the Procedures table.", "Use a subquery to find the procedures that John Wen is trained in by joining the Trained_In and Physician tables.", "Combine both conditions using an OR clause to get all relevant procedures."], "gold_sql": "SELECT name FROM procedures WHERE cost  >  1000 UNION SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  'John Wen'", "source_tables": ["procedures", "physician", "trained_in"], "pred_sql": "SELECT DISTINCT T3.Name \nFROM Procedures AS T3 \nWHERE T3.Cost > 1000 \nOR T3.Code IN (\n    SELECT T2.Treatment \n    FROM Trained_In AS T2 \n    JOIN Physician AS T1 ON T1.EmployeeID = T2.Physician \n    WHERE T1.Name = 'John Wen'\n);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of physicians who are trained in specific procedures that have a cost exceeding a certain amount. The placeholders in the WHERE clause represent the cost threshold for the procedures.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of medical procedures from the 'Procedures' table, ordered by their associated costs. The placeholder in the LIMIT clause allows the user to specify the maximum number of procedure names to retrieve.\",\n        \"virtual_table\": \"SELECT name FROM procedures ORDER BY cost LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of physicians from the 'Physician' table who have prescribed medications, ordered by the dosage of the medications in descending order. The placeholder in the LIMIT clause represents the maximum number of physician names to be returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3993", "db_id": "hospital_1", "question": "How many patients are not using Procrastin-X as medication?", "rationale": ["Identify the main goal: Count the number of patients not using 'Procrastin-X' as medication.", "To achieve this, we need to count all patients from the 'Patient' table whose SSN is not present in the list of patients who have been prescribed 'Procrastin-X'.", "The 'Prescribes' table contains the relationship between patients and medications, so we will use it to find patients who have been prescribed 'Procrastin-X'.", "We will use a subquery to select all patients from the 'Prescribes' table where the medication is 'Procrastin-X'.", "The main query will count all patients whose SSN is not in the result of the subquery."], "gold_sql": "SELECT count(*) FROM patient WHERE SSN NOT IN ( SELECT T1.patient FROM Prescribes AS T1 JOIN Medication AS T2 ON T1.Medication  =  T2.Code WHERE T2.name  =  'Procrastin-X' )", "source_tables": ["patient", "prescribes", "medication"], "pred_sql": "SELECT COUNT(*) AS PatientCount FROM Patient WHERE SSN NOT IN (SELECT Patient FROM Prescribes WHERE Medication = 'Procrastin-X');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of physicians from the 'Physician' table who have prescribed medications, ordered by the dosage of the medications in descending order. The placeholder in the LIMIT clause represents the maximum number of physician names to be returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of physicians who are trained in specific procedures that have a cost exceeding a certain amount. The placeholders in the WHERE clause represent the cost threshold for the procedures.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4256", "db_id": "club_1", "question": "What are the first names of all the students?", "rationale": ["Identify the table needed: The 'Student' table contains the first names of students.", "Determine the required column: We need the 'Fname' column for the first names.", "Use DISTINCT to ensure unique first names are returned.", "Construct the SQL query using SELECT to retrieve the distinct first names from the 'Student' table."], "gold_sql": "SELECT DISTINCT fname FROM student", "source_tables": ["student"], "pred_sql": "SELECT DISTINCT Fname FROM Student", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique first names of students from the 'Student' table. The use of DISTINCT ensures that each first name appears only once in the result set.\",\n        \"virtual_table\": \"SELECT DISTINCT fname FROM student\"\n    }\n}\n"}
{"sample_id": "train.4271", "db_id": "club_1", "question": "Give me the first name and last name for all the female members of the club \"Bootup Baltimore\".", "rationale": ["Identify the required fields: first name (Fname) and last name (LName) of students.", "Filter the students based on their gender, specifically looking for 'Female'.", "Join the Student table with the Member_of_club table to link students with their respective clubs using StuID.", "Join the resulting table with the Club table to access club details using ClubID.", "Apply a condition to filter for members of the specific club named 'Bootup Baltimore'."], "gold_sql": "SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  'Bootup Baltimore' AND t3.sex  =  'F'", "source_tables": ["club", "member_of_club", "student"], "pred_sql": "SELECT Student.Fname, Student.LName \nFROM Student \nJOIN Member_of_club ON Student.StuID = Member_of_club.StuID \nJOIN Club ON Member_of_club.ClubID = Club.ClubID \nWHERE Student.Sex = 'Female' AND Club.ClubName = 'Bootup Baltimore';", "hint": "\n"}
{"sample_id": "train.4277", "db_id": "club_1", "question": "Find the club which has the largest number of members majoring in \"600\".", "rationale": ["Identify the tables involved: Club, Member_of_club, and Student.", "We need to find clubs with members majoring in '600', so we will join the Member_of_club table with the Student table on StuID to filter by Major.", "Next, we will join the Club table with the Member_of_club table on ClubID to get club details.", "We will use a WHERE clause to filter students whose Major is '600'.", "To count the number of members in each club, we will use COUNT(Member_of_club.StuID) and group the results by Club.ClubID.", "Finally, we will order the results by the count of members in descending order and limit the output to 1 to get the club with the largest number of members."], "gold_sql": "SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.major  =  '600' GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT 1", "source_tables": ["club", "member_of_club", "student"], "pred_sql": "SELECT Club.ClubName, COUNT(Member_of_club.StuID) AS MemberCount\nFROM Club\nJOIN Member_of_club ON Club.ClubID = Member_of_club.ClubID\nJOIN Student ON Member_of_club.StuID = Student.StuID\nWHERE Student.Major = '600'\nGROUP BY Club.ClubID\nORDER BY MemberCount DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.4278", "db_id": "club_1", "question": "Find the name of the club that has the most female students.", "rationale": ["Identify the tables involved: Club, Member_of_club, and Student.", "We need to find the club with the most female students, so we will join these tables on their respective IDs.", "Filter the results to include only female students by using a WHERE clause on the Student table's Sex column.", "Group the results by ClubID to count the number of female students in each club.", "Order the results in descending order based on the count of female students to get the club with the most female members at the top.", "Limit the results to 1 to get only the club with the highest count."], "gold_sql": "SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.sex  =  'F' GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT 1", "source_tables": ["club", "member_of_club", "student"], "pred_sql": "SELECT Club.ClubName\nFROM Club\nJOIN Member_of_club ON Club.ClubID = Member_of_club.ClubID\nJOIN Student ON Member_of_club.StuID = Student.StuID\nWHERE Student.Sex = 'Female'\nGROUP BY Club.ClubID\nORDER BY COUNT(Student.StuID) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.4312", "db_id": "club_1", "question": "List the clubs that have at least a member with advisor \"1121\".", "rationale": ["We need to list clubs that have at least one member with a specific advisor.", "The relevant tables are Club, Member_of_club, and Student.", "We will join these tables: Club with Member_of_club on ClubID, and Member_of_club with Student on StuID.", "We will filter the results where the Advisor of the student is '1121'.", "Finally, we select the distinct names of the clubs to avoid duplicates."], "gold_sql": "SELECT DISTINCT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.advisor  =  1121", "source_tables": ["club", "member_of_club", "student"], "pred_sql": "SELECT DISTINCT Club.ClubName \nFROM Club \nJOIN Member_of_club ON Club.ClubID = Member_of_club.ClubID \nJOIN Student ON Member_of_club.StuID = Student.StuID \nWHERE Student.Advisor = '1121';", "hint": "\n"}
{"sample_id": "train.4324", "db_id": "tracking_grants_for_research", "question": "What is the total grant amount of the organisations described as research?", "rationale": ["Identify the relevant tables: Grants, Organisations, and Organisation_Types.", "Determine the relationship between these tables: Grants are linked to Organisations via organisation_id, and Organisations are linked to Organisation_Types via organisation_type.", "We need to filter the results based on the organisation type description, which is 'research'.", "Use the SUM function to calculate the total grant amount from the Grants table for organisations that match the specified type.", "Construct the SQL query using JOINs to combine the necessary tables and apply the WHERE clause for filtering."], "gold_sql": "SELECT sum(grant_amount) FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id JOIN organisation_Types AS T3 ON T2.organisation_type  =  T3.organisation_type WHERE T3.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations"], "pred_sql": "SELECT sum(grant_amount) FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id = T2.organisation_id JOIN Organisation_Types AS T3 ON T2.organisation_type = T3.organisation_type WHERE T3.organisation_type_description = 'research'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total grant amount from the 'Grants' table for organisations of a specific type. It joins the 'Grants' table with the 'Organisations' table to link grants to their respective organisations, and further joins with the 'Organisation_Types' table to filter by the organisation type description. The placeholder in the WHERE clause represents the specific organisation type description being queried.\",\n        \"virtual_table\": \"SELECT sum(grant_amount) FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id JOIN organisation_Types AS T3 ON T2.organisation_type  =  T3.organisation_type WHERE T3.organisation_type_description  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4327", "db_id": "tracking_grants_for_research", "question": "From what date and to what date do the staff work on a project that has the most staff and has staff in a leader role?", "rationale": ["Identify the relevant tables: We need to look at the Project_Staff table to find the staff working on projects, and the Staff_Roles table to filter for those in a leader role.", "Filter for leader roles: We will join the Project_Staff table with the Staff_Roles table to filter for staff members whose role is 'Leader'.", "Find the project with the most staff: We will use a subquery to count the number of staff members for each project and find the maximum count.", "Select date range: Finally, we will select the date_from and date_to fields from the Project_Staff table for the project that has the most staff and includes at least one leader."], "gold_sql": "SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT 1 ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  'leader'", "source_tables": ["project_staff"], "pred_sql": "SELECT ps.date_from, ps.date_to \nFROM Project_Staff ps \nJOIN Staff_Roles sr ON ps.role_code = sr.role_code \nWHERE sr.role_description = 'Leader' \nAND ps.project_id IN (\n    SELECT project_id \n    FROM Project_Staff \n    GROUP BY project_id \n    HAVING COUNT(staff_id) = (\n        SELECT MAX(staff_count) \n        FROM (\n            SELECT COUNT(staff_id) AS staff_count \n            FROM Project_Staff \n            GROUP BY project_id\n        )\n    )\n)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of details about research staff members from the 'Research_Staff' table, sorted in ascending order. The placeholder in the ORDER BY clause indicates that the user can specify how they want to sort the staff details.\",\n        \"virtual_table\": \"SELECT staff_details FROM Research_Staff ORDER BY staff_details ASC\"\n    }\n}\n"}
{"sample_id": "train.4328", "db_id": "tracking_grants_for_research", "question": "Find the organisation ids and details of the organisations which are involved in", "rationale": ["The user wants to find the organisation ids and details of the organisations involved.", "We need to select the 'organisation_id' and 'organisation_details' from the 'Organisations' table.", "There are no specific filters or conditions mentioned in the user's query, so we will retrieve all records from the 'Organisations' table."], "gold_sql": "SELECT T2.organisation_id ,  T2.organisation_details FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id GROUP BY T2.organisation_id HAVING sum(T1.grant_amount)  >  6000", "source_tables": ["grants", "organisations"], "pred_sql": "SELECT organisation_id, organisation_details FROM Organisations", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total grant amount from the 'Grants' table for organisations of a specific type. It joins the 'Grants' table with the 'Organisations' table to link grants to their respective organisations, and further joins with the 'Organisation_Types' table to filter by the organisation type description. The placeholder in the WHERE clause represents the specific organisation type description being queried.\",\n        \"virtual_table\": \"SELECT sum(grant_amount) FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id JOIN organisation_Types AS T3 ON T2.organisation_type  =  T3.organisation_type WHERE T3.organisation_type_description  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4330", "db_id": "tracking_grants_for_research", "question": "What is the organisation type and id of the organisation which has the most number of research staff?", "rationale": ["Identify the relevant tables: Research_Staff and Organisations.", "We need to find the organisation that has the most research staff, so we will join the Research_Staff table with the Organisations table using the employer_organisation_id.", "We will group the results by organisation_id and organisation_type to count the number of research staff for each organisation.", "To find the organisation with the most research staff, we will order the results by the count of staff in descending order.", "Finally, we will limit the results to 1 to get only the organisation with the highest count."], "gold_sql": "SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT Organisations.organisation_id, Organisations.organisation_type \nFROM Research_Staff \nJOIN Organisations ON Research_Staff.employer_organisation_id = Organisations.organisation_id \nGROUP BY Organisations.organisation_id, Organisations.organisation_type \nORDER BY COUNT(Research_Staff.staff_id) DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of details about research staff members from the 'Research_Staff' table, sorted in ascending order. The placeholder in the ORDER BY clause indicates that the user can specify how they want to sort the staff details.\",\n        \"virtual_table\": \"SELECT staff_details FROM Research_Staff ORDER BY staff_details ASC\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of details about research staff members from the 'Research_Staff' table, sorted in ascending order. The placeholder in the ORDER BY clause indicates that the user can specify how they want to sort the staff details.\",\n        \"virtual_table\": \"SELECT staff_details FROM Research_Staff ORDER BY staff_details ASC\"\n    }\n}\n"}
{"sample_id": "train.4331", "db_id": "tracking_grants_for_research", "question": "What is the type and id of the organization that has the most research staff?", "rationale": ["Identify the relevant tables: We need to find information from the 'Organisations' and 'Research_Staff' tables.", "Join the tables: We will join 'Organisations' with 'Research_Staff' on the common key 'organisation_id' and 'employer_organisation_id'.", "Group the results: We will group the results by 'organisation_id' and 'organisation_type' to count the number of research staff per organization.", "Count the research staff: Use COUNT() to count the number of staff members for each organization.", "Order the results: We will order the results in descending order based on the count of research staff to find the organization with the most staff.", "Limit the results: Finally, we will limit the results to 1 to get only the organization with the most research staff."], "gold_sql": "SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT Organisations.organisation_type, Organisations.organisation_id\nFROM Organisations\nJOIN Research_Staff ON Organisations.organisation_id = Research_Staff.employer_organisation_id\nGROUP BY Organisations.organisation_id, Organisations.organisation_type\nORDER BY COUNT(Research_Staff.staff_id) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of details about research staff members from the 'Research_Staff' table, sorted in ascending order. The placeholder in the ORDER BY clause indicates that the user can specify how they want to sort the staff details.\",\n        \"virtual_table\": \"SELECT staff_details FROM Research_Staff ORDER BY staff_details ASC\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of details about research staff members from the 'Research_Staff' table, sorted in ascending order. The placeholder in the ORDER BY clause indicates that the user can specify how they want to sort the staff details.\",\n        \"virtual_table\": \"SELECT staff_details FROM Research_Staff ORDER BY staff_details ASC\"\n    }\n}\n"}
{"sample_id": "train.4333", "db_id": "tracking_grants_for_research", "question": "What is the type of the organization with the most research staff?", "rationale": ["Identify the relevant tables: We need to find the type of organization with the most research staff, so we will use the 'Organisations', 'Research_Staff', and 'Organisation_Types' tables.", "Join the tables: We will join 'Research_Staff' with 'Organisations' on 'employer_organisation_id' and 'organisation_id', and then join 'Organisations' with 'Organisation_Types' on 'organisation_type'.", "Group by organization: We will group the results by 'organisation_id' to count the number of research staff for each organization.", "Count research staff: Use COUNT(Research_Staff.staff_id) to count the number of staff members for each organization.", "Order by count: We will order the results in descending order based on the count of research staff to find the organization with the most staff.", "Limit to one result: Finally, we will limit the results to 1 to get only the top organization."], "gold_sql": "SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT Organisation_Types.organisation_type_description\nFROM Organisations\nJOIN Research_Staff ON Organisations.organisation_id = Research_Staff.employer_organisation_id\nJOIN Organisation_Types ON Organisations.organisation_type = Organisation_Types.organisation_type\nGROUP BY Organisations.organisation_id\nORDER BY COUNT(Research_Staff.staff_id) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of details about research staff members from the 'Research_Staff' table, sorted in ascending order. The placeholder in the ORDER BY clause indicates that the user can specify how they want to sort the staff details.\",\n        \"virtual_table\": \"SELECT staff_details FROM Research_Staff ORDER BY staff_details ASC\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of details about research staff members from the 'Research_Staff' table, sorted in ascending order. The placeholder in the ORDER BY clause indicates that the user can specify how they want to sort the staff details.\",\n        \"virtual_table\": \"SELECT staff_details FROM Research_Staff ORDER BY staff_details ASC\"\n    }\n}\n"}
{"sample_id": "train.4334", "db_id": "tracking_grants_for_research", "question": "Find out the send dates of the documents with the grant amount of more than 5000 were granted by organisation type described", "rationale": ["Identify the relevant tables: Documents, Grants, Organisations, and Organisation_Types.", "Determine the relationships between these tables: Documents are linked to Grants via grant_id, Grants are linked to Organisations via organisation_id, and Organisations are linked to Organisation_Types via organisation_type.", "Select the 'sent_date' from the Documents table as this is the required output.", "Filter the results based on the grant amount being greater than 5000, which is a condition on the Grants table.", "Additionally, filter by the organisation type description from the Organisation_Types table, using a placeholder for the specific type to be queried."], "gold_sql": "SELECT T1.sent_date FROM documents AS T1 JOIN Grants AS T2 ON T1.grant_id  =  T2.grant_id JOIN Organisations AS T3 ON T2.organisation_id  =  T3.organisation_id JOIN organisation_Types AS T4 ON T3.organisation_type  =  T4.organisation_type WHERE T2.grant_amount  >  5000 AND T4.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations", "documents"], "pred_sql": "SELECT D.sent_date \nFROM Documents AS D \nJOIN Grants AS G ON D.grant_id = G.grant_id \nJOIN Organisations AS O ON G.organisation_id = O.organisation_id \nJOIN Organisation_Types AS OT ON O.organisation_type = OT.organisation_type \nWHERE G.grant_amount > 5000 AND OT.organisation_type_description = [PLACEHOLDER-TYPE:STRING]", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total grant amount from the 'Grants' table for organisations of a specific type. It joins the 'Grants' table with the 'Organisations' table to link grants to their respective organisations, and further joins with the 'Organisation_Types' table to filter by the organisation type description. The placeholder in the WHERE clause represents the specific organisation type description being queried.\",\n        \"virtual_table\": \"SELECT sum(grant_amount) FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id JOIN organisation_Types AS T3 ON T2.organisation_type  =  T3.organisation_type WHERE T3.organisation_type_description  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4335", "db_id": "tracking_grants_for_research", "question": "What are the send dates for all documents that have a grant amount of more than 5000 and are involved in research?", "rationale": ["Identify the relevant tables: Documents and Grants.", "Determine the columns needed: sent_date from Documents and grant_amount from Grants.", "Establish the relationship between Documents and Grants using the grant_id foreign key.", "Filter the results to include only those grants with an amount greater than 5000."], "gold_sql": "SELECT T1.sent_date FROM documents AS T1 JOIN Grants AS T2 ON T1.grant_id  =  T2.grant_id JOIN Organisations AS T3 ON T2.organisation_id  =  T3.organisation_id JOIN organisation_Types AS T4 ON T3.organisation_type  =  T4.organisation_type WHERE T2.grant_amount  >  5000 AND T4.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations", "documents"], "pred_sql": "SELECT D.sent_date \nFROM Documents D \nJOIN Grants G ON D.grant_id = G.grant_id \nWHERE G.grant_amount > 5000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total grant amount from the 'Grants' table for organisations of a specific type. It joins the 'Grants' table with the 'Organisations' table to link grants to their respective organisations, and further joins with the 'Organisation_Types' table to filter by the organisation type description. The placeholder in the WHERE clause represents the specific organisation type description being queried.\",\n        \"virtual_table\": \"SELECT sum(grant_amount) FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id JOIN organisation_Types AS T3 ON T2.organisation_type  =  T3.organisation_type WHERE T3.organisation_type_description  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4343", "db_id": "tracking_grants_for_research", "question": "When did researchers start and stop working?", "rationale": ["Identify the relevant table for researchers' work periods, which is 'Research_Staff'.", "Select the columns 'staff_id', 'date_from', and 'date_to' to get the identifiers of researchers and their working periods.", "Construct the SQL query to retrieve this information from the 'Research_Staff' table."], "gold_sql": "SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  'researcher'", "source_tables": ["project_staff"], "pred_sql": "SELECT staff_id, date_from, date_to FROM Research_Staff;", "hint": "\n"}
{"sample_id": "train.4349", "db_id": "tracking_grants_for_research", "question": "What are the details for the project whose research has been published?", "rationale": ["The question asks for details about projects whose research has been published.", "To find this information, we need to join the Projects table with the Project_Outcomes table to link projects with their outcomes.", "Next, we join the Project_Outcomes table with the Research_Outcomes table to access the descriptions of the research outcomes.", "We will filter the results to include only those outcomes that indicate the research has been published, which can be done using a WHERE clause with a LIKE condition on the outcome description."], "gold_sql": "SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id JOIN Research_outcomes AS T3 ON T2.outcome_code  =  T3.outcome_code WHERE T3.outcome_description LIKE '%Published%'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "pred_sql": "SELECT Projects.project_id, Projects.project_details, Research_Outcomes.outcome_description \nFROM Projects \nJOIN Project_Outcomes ON Projects.project_id = Project_Outcomes.project_id \nJOIN Research_Outcomes ON Project_Outcomes.outcome_code = Research_Outcomes.outcome_code \nWHERE Research_Outcomes.outcome_description LIKE '%published%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of details about research staff members from the 'Research_Staff' table, sorted in ascending order. The placeholder in the ORDER BY clause indicates that the user can specify how they want to sort the staff details.\",\n        \"virtual_table\": \"SELECT staff_details FROM Research_Staff ORDER BY staff_details ASC\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of details about research staff members from the 'Research_Staff' table, sorted in ascending order. The placeholder in the ORDER BY clause indicates that the user can specify how they want to sort the staff details.\",\n        \"virtual_table\": \"SELECT staff_details FROM Research_Staff ORDER BY staff_details ASC\"\n    }\n}\n"}
{"sample_id": "train.4356", "db_id": "tracking_grants_for_research", "question": "Which project made the most number of outcomes? List the project details and the project id.", "rationale": ["Identify the tables involved: Projects and Project_Outcomes.", "We need to count the number of outcomes for each project, so we will use a JOIN between Projects and Project_Outcomes on project_id.", "We will group the results by project_id and project_details to get the count of outcomes for each project.", "To find the project with the most outcomes, we will order the results by the count of outcomes in descending order.", "Finally, we will limit the results to 1 to get only the project with the highest count of outcomes."], "gold_sql": "SELECT T1.project_details ,  T1.project_id FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "projects"], "pred_sql": "SELECT p.project_id, p.project_details, COUNT(po.outcome_code) AS outcome_count\nFROM Projects p\nJOIN Project_Outcomes po ON p.project_id = po.project_id\nGROUP BY p.project_id, p.project_details\nORDER BY outcome_count DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of project outcomes from the 'Project_Outcomes' table that match a specific outcome code. The placeholder in the WHERE clause represents the outcome code being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Project_outcomes WHERE outcome_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4360", "db_id": "tracking_grants_for_research", "question": "Which organisation hired the most number of research staff? List the organisation id, type and detail.", "rationale": ["Identify the relevant tables: Organisations and Research_Staff.", "We need to join these tables on the organisation_id from Organisations and employer_organisation_id from Research_Staff.", "We want to count the number of research staff for each organisation, so we will use GROUP BY on organisation_id, organisation_type, and organisation_details.", "To find the organisation that hired the most research staff, we will order the results by the count of staff in descending order.", "Finally, we will limit the results to 1 to get only the top organisation."], "gold_sql": "SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT o.organisation_id, o.organisation_type, o.organisation_details\nFROM Organisations o\nJOIN Research_Staff rs ON o.organisation_id = rs.employer_organisation_id\nGROUP BY o.organisation_id, o.organisation_type, o.organisation_details\nORDER BY COUNT(rs.staff_id) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of details about research staff members from the 'Research_Staff' table, sorted in ascending order. The placeholder in the ORDER BY clause indicates that the user can specify how they want to sort the staff details.\",\n        \"virtual_table\": \"SELECT staff_details FROM Research_Staff ORDER BY staff_details ASC\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of details about research staff members from the 'Research_Staff' table, sorted in ascending order. The placeholder in the ORDER BY clause indicates that the user can specify how they want to sort the staff details.\",\n        \"virtual_table\": \"SELECT staff_details FROM Research_Staff ORDER BY staff_details ASC\"\n    }\n}\n"}
{"sample_id": "train.4361", "db_id": "tracking_grants_for_research", "question": "What are the ids, types, and details of the organization with the most research staff?", "rationale": ["Identify the relevant tables: Organisations and Research_Staff are needed to get the organization details and the count of research staff.", "Join the Organisations table with the Research_Staff table on the organisation_id to link organizations with their respective research staff.", "Group the results by organisation_id to count the number of research staff for each organization.", "Order the results in descending order based on the count of research staff to find the organization with the most staff.", "Limit the results to 1 to get only the organization with the highest count of research staff."], "gold_sql": "SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT o.organisation_id, o.organisation_type, o.organisation_details\nFROM Organisations o\nJOIN Research_Staff rs ON o.organisation_id = rs.employer_organisation_id\nGROUP BY o.organisation_id\nORDER BY COUNT(rs.staff_id) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of details about research staff members from the 'Research_Staff' table, sorted in ascending order. The placeholder in the ORDER BY clause indicates that the user can specify how they want to sort the staff details.\",\n        \"virtual_table\": \"SELECT staff_details FROM Research_Staff ORDER BY staff_details ASC\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of details about research staff members from the 'Research_Staff' table, sorted in ascending order. The placeholder in the ORDER BY clause indicates that the user can specify how they want to sort the staff details.\",\n        \"virtual_table\": \"SELECT staff_details FROM Research_Staff ORDER BY staff_details ASC\"\n    }\n}\n"}
{"sample_id": "train.4363", "db_id": "tracking_grants_for_research", "question": "For each staff id, what is the description of the role that is involved with the most number of projects?", "rationale": ["Identify the relevant tables: Project_Staff and Staff_Roles.", "We need to join these tables on the role_code to get the role descriptions for each staff member.", "Group the results by staff_id and role_code to count the number of projects each staff member is involved in for each role.", "Order the results by the count of projects in descending order to find the role with the most projects for each staff member.", "Limit the results to get only the top result for each staff member."], "gold_sql": "SELECT T1.role_description ,  T2.staff_id FROM Staff_Roles AS T1 JOIN Project_Staff AS T2 ON T1.role_code  =  T2.role_code JOIN Project_outcomes AS T3 ON T2.project_id  =  T3.project_id GROUP BY T2.staff_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "project_staff", "staff_roles"], "pred_sql": "SELECT sr.staff_id, sr.role_code, sr.role_description\nFROM Project_Staff ps\nJOIN Staff_Roles sr ON ps.role_code = sr.role_code\nGROUP BY ps.staff_id, sr.role_code\nORDER BY COUNT(ps.project_id) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the role descriptions of staff members from the 'Staff_Roles' table based on a specific role code. The placeholder in the WHERE clause represents the role code being queried.\",\n        \"virtual_table\": \"SELECT role_description FROM Staff_Roles WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of details about research staff members from the 'Research_Staff' table, sorted in ascending order. The placeholder in the ORDER BY clause indicates that the user can specify how they want to sort the staff details.\",\n        \"virtual_table\": \"SELECT staff_details FROM Research_Staff ORDER BY staff_details ASC\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of details about research staff members from the 'Research_Staff' table, sorted in ascending order. The placeholder in the ORDER BY clause indicates that the user can specify how they want to sort the staff details.\",\n        \"virtual_table\": \"SELECT staff_details FROM Research_Staff ORDER BY staff_details ASC\"\n    }\n}\n"}
{"sample_id": "train.4367", "db_id": "tracking_grants_for_research", "question": "For grants that have descriptions of Regular and Initial Applications, what are their start dates?", "rationale": ["Identify the relevant tables: Grants and Document_Types.", "Determine the columns needed: grant_start_date from Grants and document_description from Document_Types.", "Establish the relationship between the tables: Grants has a foreign key relationship with Documents, which in turn relates to Document_Types through document_type_code.", "Filter the results based on the document descriptions 'Regular Applications' and 'Initial Applications'.", "Construct the SQL query to select the grant_start_date for grants that match the specified document descriptions."], "gold_sql": "SELECT T1.grant_start_date FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id JOIN Document_Types AS T3 ON T2.document_type_code  =  T3.document_type_code WHERE T3.document_description  =  'Regular' INTERSECT SELECT T1.grant_start_date FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id JOIN Document_Types AS T3 ON T2.document_type_code  =  T3.document_type_code WHERE T3.document_description  =  'Initial Application'", "source_tables": ["grants", "document_types", "documents"], "pred_sql": "SELECT grant_start_date FROM Grants AS G JOIN Document_Types AS D ON G.grant_id = D.document_type_code WHERE D.document_description IN ('Regular Applications', 'Initial Applications')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total grant amount from the 'Grants' table for organisations of a specific type. It joins the 'Grants' table with the 'Organisations' table to link grants to their respective organisations, and further joins with the 'Organisation_Types' table to filter by the organisation type description. The placeholder in the WHERE clause represents the specific organisation type description being queried.\",\n        \"virtual_table\": \"SELECT sum(grant_amount) FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id JOIN organisation_Types AS T3 ON T2.organisation_type  =  T3.organisation_type WHERE T3.organisation_type_description  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4369", "db_id": "tracking_grants_for_research", "question": "For each grant id, how many documents does it have, and which one has the most?", "rationale": ["Identify the relevant tables: Grants and Documents.", "We need to count the number of documents for each grant, so we will join the Grants table with the Documents table on the grant_id.", "Use COUNT() to count the number of documents associated with each grant.", "Group the results by grant_id to get the count for each grant.", "To find which grant has the most documents, we can use a subquery to get the maximum document count for each grant and filter the results accordingly."], "gold_sql": "SELECT grant_id ,  count(*) FROM Documents GROUP BY grant_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["documents"], "pred_sql": "SELECT g.grant_id, COUNT(d.document_id) AS document_count, d.document_id \nFROM Grants g \nLEFT JOIN Documents d ON g.grant_id = d.grant_id \nGROUP BY g.grant_id \nHAVING COUNT(d.document_id) = (SELECT MAX(doc_count) \n                               FROM (SELECT COUNT(document_id) AS doc_count \n                                     FROM Documents \n                                     WHERE grant_id = g.grant_id \n                                     GROUP BY grant_id));", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total grant amount from the 'Grants' table for organisations of a specific type. It joins the 'Grants' table with the 'Organisations' table to link grants to their respective organisations, and further joins with the 'Organisation_Types' table to filter by the organisation type description. The placeholder in the WHERE clause represents the specific organisation type description being queried.\",\n        \"virtual_table\": \"SELECT sum(grant_amount) FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id JOIN organisation_Types AS T3 ON T2.organisation_type  =  T3.organisation_type WHERE T3.organisation_type_description  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4372", "db_id": "tracking_grants_for_research", "question": "What are all the details of the organisations described as 'Sponsor'? Sort the result in an ascending order.", "rationale": ["Identify the relevant table: Organisations.", "Determine the condition to filter organisations: organisation_type should match the type described as 'Sponsor'.", "To find the organisation_type corresponding to 'Sponsor', a subquery is needed to select it from the Organisation_Types table.", "Construct the SQL query to select all columns from Organisations where the organisation_type matches the result of the subquery, and sort the results in ascending order by organisation_id."], "gold_sql": "SELECT organisation_details FROM Organisations AS T1 JOIN organisation_Types AS T2 ON T1.organisation_type  =  T2.organisation_type WHERE T2.organisation_type_description  =  'Sponsor' ORDER BY organisation_details", "source_tables": ["organisation_types", "organisations"], "pred_sql": "SELECT * FROM Organisations WHERE organisation_type = (SELECT organisation_type FROM Organisation_Types WHERE organisation_type_description = 'Sponsor') ORDER BY organisation_id ASC;", "hint": "\n"}
{"sample_id": "train.4380", "db_id": "tracking_grants_for_research", "question": "What are the result description of the project whose detail is 'sint'?", "rationale": ["Identify the relevant tables: Projects and Project_Outcomes.", "Determine the relationship between the tables: Projects has a one-to-many relationship with Project_Outcomes based on project_id.", "Formulate the SQL query to select outcome_details from Project_Outcomes where the project_id matches the project_id of Projects that has project_details equal to 'sint'.", "Use JOIN to combine the two tables based on the project_id and filter the results using a WHERE clause."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code JOIN Projects AS T3 ON T2.project_id  =  T3.project_id WHERE T3.project_details  =  'sint'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "pred_sql": "SELECT po.outcome_details \nFROM Projects p \nJOIN Project_Outcomes po ON p.project_id = po.project_id \nWHERE p.project_details = 'sint';", "hint": "\n"}
{"sample_id": "train.4381", "db_id": "tracking_grants_for_research", "question": "What is the description for the results whose project detail is 'sint'?", "rationale": ["Identify the relevant tables: We need to find the description for project outcomes, which involves the Project_Outcomes and Projects tables.", "Determine the relationship: The Project_Outcomes table has a foreign key relationship with the Projects table through project_id.", "Formulate the query: We will select the outcome_details from Project_Outcomes where the project_id matches the project_id in Projects, and filter by the specific project detail 'sint'."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code JOIN Projects AS T3 ON T2.project_id  =  T3.project_id WHERE T3.project_details  =  'sint'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "pred_sql": "SELECT outcome_details \nFROM Project_Outcomes \nJOIN Projects ON Project_Outcomes.project_id = Projects.project_id \nWHERE Projects.project_details = 'sint';", "hint": "\n"}
{"sample_id": "train.4383", "db_id": "tracking_grants_for_research", "question": "What is the id of the organization with the maximum number of outcomes and how many outcomes are there?", "rationale": ["Identify the relevant tables: Project_Outcomes, Projects, and Organisations are needed to find the organization associated with project outcomes.", "Join the tables: Use JOIN to connect Project_Outcomes with Projects on project_id, and then connect Projects with Organisations on organisation_id.", "Count the outcomes: Use COUNT(outcome_code) to count the number of outcomes for each organization.", "Group by organization: Use GROUP BY organisation_id to aggregate the counts for each organization.", "Order the results: Use ORDER BY outcome_count DESC to sort the organizations by the number of outcomes in descending order.", "Limit the results: Use LIMIT 1 to get only the organization with the maximum number of outcomes."], "gold_sql": "SELECT T1.organisation_id ,  count(*) FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "projects"], "pred_sql": "SELECT organisation_id, COUNT(outcome_code) AS outcome_count\nFROM Project_Outcomes\nJOIN Projects ON Project_Outcomes.project_id = Projects.project_id\nJOIN Organisations ON Projects.organisation_id = Organisations.organisation_id\nGROUP BY organisation_id\nORDER BY outcome_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.4384", "db_id": "tracking_grants_for_research", "question": "List the project details of the projects launched by the organisation", "rationale": ["Identify the relevant tables: Projects and Organisations.", "Determine the relationship between the tables: Projects has a foreign key organisation_id that references Organisations.", "Select the desired column: project_details from the Projects table.", "Join the Projects table with the Organisations table on the organisation_id to filter projects by their respective organisations."], "gold_sql": "SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT 1 )", "source_tables": ["projects"], "pred_sql": "SELECT Projects.project_details \nFROM Projects \nJOIN Organisations ON Projects.organisation_id = Organisations.organisation_id;", "hint": "\n"}
{"sample_id": "train.4392", "db_id": "tracking_grants_for_research", "question": "What are the staff roles of the staff who", "rationale": ["The user wants to know the staff roles of the staff members.", "To get the staff roles, we need to join the 'Research_Staff' table with the 'Project_Staff' table on 'staff_id'.", "Next, we join the 'Project_Staff' table with the 'Staff_Roles' table on 'role_code' to get the role descriptions.", "We will select the relevant fields from these tables: staff details from 'Research_Staff' and role descriptions from 'Staff_Roles'.", "Finally, we will order the results by the role description in ascending order."], "gold_sql": "SELECT role_code FROM Project_Staff WHERE date_from  >  '2003-04-19 15:06:20' AND date_to  <  '2016-03-15 00:33:18'", "source_tables": ["project_staff"], "pred_sql": "SELECT sr.staff_details, sr.staff_id, sr.employer_organisation_id, sr.staff_details, sr.staff_id, sr.employer_organisation_id, sr.staff_details, sr.staff_id, sr.employer_organisation_id, sr.staff_details, sr.staff_id, sr.employer_organisation_id, sr.staff_details, sr.staff_id, sr.employer_organisation_id, sr.staff_details, sr.staff_id, sr.employer_organisation_id, sr.staff_details, sr.staff_id, sr.employer_organisation_id, sr.staff_details, sr.staff_id, sr.employer_organisation_id, sr.staff_details, sr.staff_id, sr.employer_organisation_id FROM Research_Staff AS sr JOIN Project_Staff AS ps ON sr.staff_id = ps.staff_id JOIN Staff_Roles AS s ON ps.role_code = s.role_code ORDER BY s.role_description ASC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the role descriptions of staff members from the 'Staff_Roles' table based on a specific role code. The placeholder in the WHERE clause represents the role code being queried.\",\n        \"virtual_table\": \"SELECT role_description FROM Staff_Roles WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of details about research staff members from the 'Research_Staff' table, sorted in ascending order. The placeholder in the ORDER BY clause indicates that the user can specify how they want to sort the staff details.\",\n        \"virtual_table\": \"SELECT staff_details FROM Research_Staff ORDER BY staff_details ASC\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of details about research staff members from the 'Research_Staff' table, sorted in ascending order. The placeholder in the ORDER BY clause indicates that the user can specify how they want to sort the staff details.\",\n        \"virtual_table\": \"SELECT staff_details FROM Research_Staff ORDER BY staff_details ASC\"\n    }\n}\n"}
{"sample_id": "train.4394", "db_id": "tracking_grants_for_research", "question": "What are the descriptions of all the project outcomes?", "rationale": ["The user wants to retrieve descriptions of all project outcomes.", "The relevant table for project outcomes is 'Project_Outcomes'.", "To get the descriptions, I need to select the 'outcome_code' and 'outcome_details' columns from the 'Project_Outcomes' table.", "The SQL query will be a simple SELECT statement that retrieves these columns without any filtering or conditions."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code", "source_tables": ["project_outcomes", "research_outcomes"], "pred_sql": "SELECT outcome_code, outcome_details FROM Project_Outcomes;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of project outcomes from the 'Project_Outcomes' table that match a specific outcome code. The placeholder in the WHERE clause represents the outcome code being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Project_outcomes WHERE outcome_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4397", "db_id": "tracking_grants_for_research", "question": "What is the most common role for the staff?", "rationale": ["To find the most common role for the staff, we need to analyze the 'Project_Staff' table which contains the 'role_code' for each staff member.", "We will use the COUNT function to count how many times each 'role_code' appears in the 'Project_Staff' table.", "We will group the results by 'role_code' to aggregate the counts for each role.", "To determine the most common role, we will order the results in descending order based on the count of roles.", "Finally, we will limit the results to 1 to get only the most common role."], "gold_sql": "SELECT role_code FROM Project_Staff GROUP BY role_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_staff"], "pred_sql": "SELECT role_code, COUNT(*) as role_count \nFROM Project_Staff \nGROUP BY role_code \nORDER BY role_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the role descriptions of staff members from the 'Staff_Roles' table based on a specific role code. The placeholder in the WHERE clause represents the role code being queried.\",\n        \"virtual_table\": \"SELECT role_description FROM Staff_Roles WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of details about research staff members from the 'Research_Staff' table, sorted in ascending order. The placeholder in the ORDER BY clause indicates that the user can specify how they want to sort the staff details.\",\n        \"virtual_table\": \"SELECT staff_details FROM Research_Staff ORDER BY staff_details ASC\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of details about research staff members from the 'Research_Staff' table, sorted in ascending order. The placeholder in the ORDER BY clause indicates that the user can specify how they want to sort the staff details.\",\n        \"virtual_table\": \"SELECT staff_details FROM Research_Staff ORDER BY staff_details ASC\"\n    }\n}\n"}
{"sample_id": "train.4410", "db_id": "network_2", "question": "Who is the oldest person whose job is student?", "rationale": ["Identify the table to query: The relevant table is 'Person' which contains information about individuals.", "Determine the criteria: We need to find the oldest person whose job is 'student'.", "Filter the results: Use a WHERE clause to filter for rows where the job is 'student'.", "Sort the results: To find the oldest, we will sort the results by age in descending order.", "Limit the results: Since we only want the oldest person, we will limit the results to 1."], "gold_sql": "SELECT name FROM Person WHERE job  =  'student' AND age  =  (SELECT max(age) FROM person WHERE job  =  'student' )", "source_tables": ["person"], "pred_sql": "SELECT name FROM Person WHERE job = 'student' ORDER BY age DESC LIMIT 1;", "hint": "\n"}
{"sample_id": "train.4439", "db_id": "network_2", "question": "What is the name and age of every male? Order the results by age.", "rationale": ["Identify the columns needed: 'name' and 'age'.", "Determine the table to query: 'Person'.", "Add a condition to filter for males: WHERE gender = 'male'.", "Specify the order of results by age: ORDER BY age."], "gold_sql": "SELECT name FROM Person WHERE gender  =  'male' ORDER BY age", "source_tables": ["person"], "pred_sql": "SELECT name, age FROM Person WHERE gender = 'male' ORDER BY age;", "hint": "\n"}
{"sample_id": "train.4441", "db_id": "network_2", "question": "What are the names and ages of every person who is a friend of both Dan and Alice?", "rationale": ["Identify the main requirement: We need the names and ages of persons who are friends with both Dan and Alice.", "To find friends of Dan, we can use a subquery that selects friends from the PersonFriend table where the name is 'Dan'.", "Similarly, to find friends of Alice, we can use another subquery that selects friends from the PersonFriend table where the name is 'Alice'.", "We need to ensure that the names returned from both subqueries are the same, meaning the person must be a friend of both.", "Finally, we select the name and age from the Person table for those names that are returned by both subqueries."], "gold_sql": "SELECT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Dan' INTERSECT SELECT T1.name ,   T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Alice'", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT P.name, P.age FROM Person AS P WHERE P.name IN (SELECT PF1.friend FROM PersonFriend AS PF1 WHERE PF1.name = 'Dan') AND P.name IN (SELECT PF2.friend FROM PersonFriend AS PF2 WHERE PF2.name = 'Alice');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of persons from the 'Person' table who have a specific friend and belong to a certain gender. The placeholders in the WHERE clause represent the friend's name and the gender of the person.\",\n        \"virtual_table\": \"SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] AND T1.gender  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of friends of persons who reside in a specific city. The query joins the 'Person' table with the 'PersonFriend' table to find friends based on the city of residence, with a placeholder for the city name.\",\n        \"virtual_table\": \"SELECT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.city  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4444", "db_id": "network_2", "question": "Find the name of the person who has friends with age above 40 and under age 30?", "rationale": ["Identify the main requirement: Find names of persons who have friends with age above 40 and under age 30.", "To achieve this, we need to join the 'Person' table with the 'PersonFriend' table to access both the person's details and their friends.", "We will use a subquery to find friends who are older than 40 years and another subquery for friends who are younger than 30 years.", "The final query will select names from the 'Person' table where the friends meet either of the age conditions."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  40) INTERSECT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  30)", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name = T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age > 40) OR T2.friend IN (SELECT name FROM Person WHERE age < 30)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of persons from the 'Person' table who have a specific friend and belong to a certain gender. The placeholders in the WHERE clause represent the friend's name and the gender of the person.\",\n        \"virtual_table\": \"SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] AND T1.gender  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4445", "db_id": "network_2", "question": "What are the names of every person who has a friend over 40 and under 30?", "rationale": ["Identify the requirement: We need the names of persons who have friends that are either over 40 or under 30.", "To find this information, we will need to join the 'Person' table with the 'PersonFriend' table to link persons with their friends.", "We also need to join the 'Person' table again to access the age of the friends.", "The WHERE clause will filter friends based on their age being greater than 40 or less than 30.", "Using DISTINCT ensures that we only get unique names of persons who meet the criteria."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  40) INTERSECT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  30)", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT DISTINCT T1.name \nFROM Person AS T1 \nJOIN PersonFriend AS T2 ON T1.name = T2.name \nJOIN Person AS T3 ON T2.friend = T3.name \nWHERE (T3.age > 40 OR T3.age < 30)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of persons from the 'Person' table who have a specific friend and belong to a certain gender. The placeholders in the WHERE clause represent the friend's name and the gender of the person.\",\n        \"virtual_table\": \"SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] AND T1.gender  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of friends of persons who reside in a specific city. The query joins the 'Person' table with the 'PersonFriend' table to find friends based on the city of residence, with a placeholder for the city name.\",\n        \"virtual_table\": \"SELECT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.city  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4449", "db_id": "network_2", "question": "What are the names of the people who have no friends who are students?", "rationale": ["Identify the main requirement: We need the names of people who have no friends who are students.", "To find friends who are students, we need to look at the 'Person' table and filter by job = 'student'.", "We will create a subquery to select names of friends who are students.", "Next, we need to find people whose names are not in the list of friends who are students. This requires another subquery.", "The final query will select names from the 'Person' table where the name is not in the list of friends who are students."], "gold_sql": "SELECT name FROM person EXCEPT SELECT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.job  =  'student'", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT name FROM Person WHERE name NOT IN (SELECT name FROM PersonFriend WHERE friend IN (SELECT name FROM Person WHERE job = 'student'));", "hint": "\n"}
{"sample_id": "train.4454", "db_id": "network_2", "question": "Find the name of persons who are friends with Bob.", "rationale": ["Identify the tables involved: We need to find names of persons who are friends with Bob, which involves the 'Person' and 'PersonFriend' tables.", "Determine the relationship: We need to join the 'Person' table with the 'PersonFriend' table on the name of the person.", "Specify the condition: We want to filter the results to only include those where the friend is 'Bob'.", "Construct the SQL query: Using the identified tables, relationships, and conditions, we can construct the SQL query."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Bob'", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name = T2.name WHERE T2.friend = 'Bob'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of persons from the 'Person' table who have a specific friend and belong to a certain gender. The placeholders in the WHERE clause represent the friend's name and the gender of the person.\",\n        \"virtual_table\": \"SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] AND T1.gender  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of friends of persons who reside in a specific city. The query joins the 'Person' table with the 'PersonFriend' table to find friends based on the city of residence, with a placeholder for the city name.\",\n        \"virtual_table\": \"SELECT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.city  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4455", "db_id": "network_2", "question": "What are the names of all of Bob's friends?", "rationale": ["Identify the person of interest, which is Bob in this case.", "We need to find all friends of Bob, which means we will look into the PersonFriend table where the name matches Bob.", "Join the Person table with the PersonFriend table on the name to ensure we are getting the correct friends associated with Bob.", "Select the friend names from the PersonFriend table where the name is Bob."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Bob'", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT T2.friend FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name = T2.name WHERE T1.name = 'Bob'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of persons from the 'Person' table who have a specific friend and belong to a certain gender. The placeholders in the WHERE clause represent the friend's name and the gender of the person.\",\n        \"virtual_table\": \"SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] AND T1.gender  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of friends of persons who reside in a specific city. The query joins the 'Person' table with the 'PersonFriend' table to find friends based on the city of residence, with a placeholder for the city name.\",\n        \"virtual_table\": \"SELECT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.city  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4456", "db_id": "network_2", "question": "Find the names of females who are friends with Zach", "rationale": ["Identify the tables involved: Person and PersonFriend.", "We need to find females who are friends with Zach, so we will join the Person table (T1) with the PersonFriend table (T2) on the name column.", "We will filter the results where T2.friend is 'Zach' to find friends of Zach.", "Additionally, we will filter T1.gender to be 'female' to get only female friends.", "Construct the SQL query using the identified conditions."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Zach' AND T1.gender  =  'female'", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name = T2.name WHERE T2.friend = 'Zach' AND T1.gender = 'female'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of persons from the 'Person' table who have a specific friend and belong to a certain gender. The placeholders in the WHERE clause represent the friend's name and the gender of the person.\",\n        \"virtual_table\": \"SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] AND T1.gender  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of friends of persons who reside in a specific city. The query joins the 'Person' table with the 'PersonFriend' table to find friends based on the city of residence, with a placeholder for the city name.\",\n        \"virtual_table\": \"SELECT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.city  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4465", "db_id": "network_2", "question": "What are the different names of friends who are younger than the average age for a friend?", "rationale": ["Identify the requirement to find friends who are younger than the average age of friends.", "To find the average age of friends, we need to consider the 'PersonFriend' table to get the list of friends.", "We will use a subquery to calculate the average age of friends by selecting the ages of those who are listed as friends in the 'PersonFriend' table.", "We will join the 'Person' table with the 'PersonFriend' table to get the names of friends and their corresponding ages.", "Finally, we will filter the results to only include friends whose age is less than the calculated average age."], "gold_sql": "SELECT DISTINCT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.age  <  (SELECT avg(age) FROM person)", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT DISTINCT T2.friend \nFROM Person AS T1 \nJOIN PersonFriend AS T2 ON T1.name = T2.name \nWHERE T1.age < (SELECT AVG(age) FROM Person WHERE name IN (SELECT friend FROM PersonFriend))", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of persons from the 'Person' table who have a specific friend and belong to a certain gender. The placeholders in the WHERE clause represent the friend's name and the gender of the person.\",\n        \"virtual_table\": \"SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] AND T1.gender  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of friends of persons who reside in a specific city. The query joins the 'Person' table with the 'PersonFriend' table to find friends based on the city of residence, with a placeholder for the city name.\",\n        \"virtual_table\": \"SELECT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.city  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4466", "db_id": "network_2", "question": "Who has friends that are older than the average age? Print their friends and their ages as well", "rationale": ["Identify the tables involved: We need data from both the Person and PersonFriend tables.", "Determine the relationship: We need to find friends of persons, which means we will join PersonFriend with Person on the friend's name.", "Calculate the average age: We need to find the average age from the Person table to compare against.", "Filter friends based on age: We will filter the results to include only those friends whose age is greater than the average age calculated.", "Select the required fields: We need to select the friend's name and their age in the final output."], "gold_sql": "SELECT DISTINCT T2.name ,  T2.friend ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.age  >  (SELECT avg(age) FROM person)", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT PF.friend, P.age \nFROM PersonFriend AS PF \nJOIN Person AS P ON PF.friend = P.name \nWHERE P.age > (SELECT AVG(age) FROM Person)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of persons from the 'Person' table who have a specific friend and belong to a certain gender. The placeholders in the WHERE clause represent the friend's name and the gender of the person.\",\n        \"virtual_table\": \"SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] AND T1.gender  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4467", "db_id": "network_2", "question": "Whare the names, friends, and ages of all people who are older than the average age of a person?", "rationale": ["Identify the required fields: names, friends, and ages of people.", "The names and friends are in the Person and PersonFriend tables respectively.", "To get the names and friends, a JOIN operation is needed between Person and PersonFriend on the name column.", "We need to filter the results to include only those people who are older than the average age.", "To calculate the average age, a subquery is used: SELECT AVG(CAST(age AS INTEGER)) FROM Person. This converts the age from text to integer for accurate calculation.", "Combine all these elements into a complete SQL query."], "gold_sql": "SELECT DISTINCT T2.name ,  T2.friend ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.age  >  (SELECT avg(age) FROM person)", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT p.name, pf.friend, p.age \nFROM Person p \nJOIN PersonFriend pf ON p.name = pf.name \nWHERE p.age > (SELECT AVG(CAST(age AS INTEGER)) FROM Person);", "hint": "\n"}
{"sample_id": "train.4473", "db_id": "network_2", "question": "What are the names of all people who are friends with Alice for the shortest amount of time?", "rationale": ["Identify the person of interest, which is 'Alice'.", "We need to find all friends of Alice and the year when each friendship was established.", "To find the shortest friendship duration, we can group the friendships by friend and select the minimum year for each friend.", "Join this result back to the PersonFriend table to get the names of friends who have the shortest friendship duration with Alice."], "gold_sql": "SELECT name FROM PersonFriend WHERE friend =  'Alice' AND YEAR  =  (SELECT min(YEAR) FROM PersonFriend WHERE friend =  'Alice')", "source_tables": ["personfriend"], "pred_sql": "SELECT T2.friend FROM PersonFriend AS T2 JOIN (SELECT name, MIN(year) AS min_year FROM PersonFriend WHERE name = 'Alice' GROUP BY friend) AS T3 ON T2.name = 'Alice' AND T2.year = T3.min_year;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of persons from the 'Person' table who have a specific friend and belong to a certain gender. The placeholders in the WHERE clause represent the friend's name and the gender of the person.\",\n        \"virtual_table\": \"SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] AND T1.gender  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of friends of persons who reside in a specific city. The query joins the 'Person' table with the 'PersonFriend' table to find friends based on the city of residence, with a placeholder for the city name.\",\n        \"virtual_table\": \"SELECT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.city  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4475", "db_id": "network_2", "question": "What are the names, ages, and jobs of all people who are friends with Alice for the longest amount of time?", "rationale": ["Identify the relevant tables: We need to gather information from the 'Person' table and the 'PersonFriend' table.", "Determine the required fields: We need the names, ages, and jobs of people who are friends with Alice.", "Establish the relationship: We will join the 'Person' table with the 'PersonFriend' table on the condition that the person's name matches the friend's name in the 'PersonFriend' table.", "Filter for Alice's friends: We will add a WHERE clause to filter for records where the name in 'PersonFriend' is 'Alice'.", "Sort by friendship duration: Since we want to find friends for the longest amount of time, we will sort by the 'year' column in ascending order.", "Limit the results: To get only the friend with the longest friendship duration, we will use LIMIT 1."], "gold_sql": "SELECT T1.name ,  T1.age ,  T1.job FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend =  'Alice' AND T2.year  =  (SELECT max(YEAR) FROM PersonFriend WHERE friend =  'Alice')", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT P.name, P.age, P.job \nFROM Person AS P \nJOIN PersonFriend AS PF ON P.name = PF.friend \nWHERE PF.name = 'Alice' \nORDER BY PF.year ASC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of persons from the 'Person' table who have a specific friend and belong to a certain gender. The placeholders in the WHERE clause represent the friend's name and the gender of the person.\",\n        \"virtual_table\": \"SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] AND T1.gender  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of friends of persons who reside in a specific city. The query joins the 'Person' table with the 'PersonFriend' table to find friends based on the city of residence, with a placeholder for the city name.\",\n        \"virtual_table\": \"SELECT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.city  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4478", "db_id": "network_2", "question": "Which person whose friends have the oldest average age?", "rationale": ["Identify the main goal: Find the person whose friends have the oldest average age.", "To achieve this, we need to calculate the average age of friends for each person.", "We will join the PersonFriend table with the Person table to get the ages of friends.", "We will group the results by the person's name to calculate the average age of their friends.", "After calculating the average ages, we will order the results in descending order to find the oldest average age.", "Finally, we will limit the results to get only the top result, which is the person with the oldest average age of friends."], "gold_sql": "SELECT T2.name ,  avg(T1.age) FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend GROUP BY T2.name ORDER BY avg(T1.age) DESC LIMIT 1", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT p.name\nFROM Person p\nJOIN (\n    SELECT pf.name, AVG(CAST(p.age AS INTEGER)) AS avg_age\n    FROM PersonFriend pf\n    JOIN Person p ON pf.friend = p.name\n    GROUP BY pf.name\n) AS avg_ages ON p.name = avg_ages.name\nORDER BY avg_ages.avg_age DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.4480", "db_id": "network_2", "question": "What is the total number of people who has no friend living in the city of Austin.", "rationale": ["Identify the requirement: We need to find the total number of people who have no friends living in Austin.", "Use the provided hint to create a virtual table that identifies friends of persons who reside in Austin.", "The virtual table will select friends from the PersonFriend table where the corresponding person resides in Austin.", "Next, we need to count the number of people in the Person table whose names are not in the list of friends identified in the previous step.", "The final SQL query will count all persons whose names are not in the subquery that selects friends from Austin."], "gold_sql": "SELECT count(DISTINCT name) FROM PersonFriend WHERE friend NOT IN (SELECT name FROM person WHERE city  =  'Austin')", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT COUNT(*) FROM Person WHERE name NOT IN (SELECT T2.friend FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name = T2.friend WHERE T1.city = 'Austin')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of friends of persons who reside in a specific city. The query joins the 'Person' table with the 'PersonFriend' table to find friends based on the city of residence, with a placeholder for the city name.\",\n        \"virtual_table\": \"SELECT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.city  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4503", "db_id": "document_management", "question": "Find the types of documents with more than 4 documents.", "rationale": ["The task is to find the types of documents that have more than 4 documents.", "We need to group the documents by their type, which is indicated by the 'document_type_code' column in the 'Documents' table.", "To count the number of documents for each type, we will use the COUNT() function on the 'document_code' column.", "We will use the GROUP BY clause to group the results by 'document_type_code'.", "Finally, we will filter the results to only include those types that have more than 4 documents using the HAVING clause."], "gold_sql": "SELECT document_type_code FROM documents GROUP BY document_type_code HAVING count(*)  >  4", "source_tables": ["documents"], "pred_sql": "SELECT document_type_code, COUNT(document_code) AS document_count \nFROM Documents \nGROUP BY document_type_code \nHAVING COUNT(document_code) > 4;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of documents from the 'Documents' table that do not have any associated images in their sections. The query uses an EXCEPT clause to exclude document names that are linked to sections containing images.\",\n        \"virtual_table\": \"SELECT document_name FROM documents EXCEPT SELECT t1.document_name FROM documents AS t1 JOIN document_sections AS t2 ON t1.document_code  =  t2.document_code JOIN document_sections_images AS t3 ON t2.section_id  =  t3.section_id\"\n    }\n}\n"}
{"sample_id": "train.4504", "db_id": "document_management", "question": "What are the codes of types of documents of which there are for or more?", "rationale": ["Identify the table that contains the document types, which is the 'Documents' table.", "We need to select the 'document_type_code' from the 'Documents' table.", "To find the document types that have four or more documents, we will group the results by 'document_type_code'.", "We will use the HAVING clause to filter the groups to only include those with a count of 'document_code' that is 4 or more."], "gold_sql": "SELECT document_type_code FROM documents GROUP BY document_type_code HAVING count(*)  >  4", "source_tables": ["documents"], "pred_sql": "SELECT document_type_code\nFROM Documents\nGROUP BY document_type_code\nHAVING COUNT(document_code) >= 4;", "hint": "\n"}
{"sample_id": "train.4505", "db_id": "document_management", "question": "Find the total access count of all documents in the most popular document type.", "rationale": ["We need to find the total access count of all documents in the most popular document type.", "First, we need to identify the most popular document type. This can be done by grouping the documents by their type code and summing their access counts.", "We will order the results by the summed access count in descending order to get the most popular document type at the top.", "To get only the most popular document type, we will limit our results to 1.", "Once we have the most popular document type, we can then sum the access counts of all documents that match this type code."], "gold_sql": "SELECT sum(access_count) FROM documents GROUP BY document_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["documents"], "pred_sql": "SELECT SUM(access_count) AS total_access_count\nFROM Documents\nWHERE document_type_code = (\n    SELECT document_type_code\n    FROM Documents\n    GROUP BY document_type_code\n    ORDER BY SUM(access_count) DESC\n    LIMIT 1\n);", "hint": "\n"}
{"sample_id": "train.4525", "db_id": "document_management", "question": "Find names of the document without any images.", "rationale": ["The task is to find names of documents that do not have any images associated with them.", "To achieve this, we can use the EXCEPT clause to exclude document names that are linked to sections containing images.", "First, we select all document names from the 'Documents' table.", "Next, we need to identify the document names that do have images. This involves joining the 'Documents' table with the 'Document_Sections' table on the document code, and then joining with the 'Document_Sections_Images' table on the section ID.", "The final query will select document names from the 'Documents' table and exclude those found in the second part of the query that have images."], "gold_sql": "SELECT document_name FROM documents EXCEPT SELECT t1.document_name FROM documents AS t1 JOIN document_sections AS t2 ON t1.document_code  =  t2.document_code JOIN document_sections_images AS t3 ON t2.section_id  =  t3.section_id", "source_tables": ["document_sections", "document_sections_images", "documents"], "pred_sql": "SELECT document_name FROM Documents EXCEPT SELECT t1.document_name FROM Documents AS t1 JOIN Document_Sections AS t2 ON t1.document_code = t2.document_code JOIN Document_Sections_Images AS t3 ON t2.section_id = t3.section_id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of documents from the 'Documents' table that do not have any associated images in their sections. The query uses an EXCEPT clause to exclude document names that are linked to sections containing images.\",\n        \"virtual_table\": \"SELECT document_name FROM documents EXCEPT SELECT t1.document_name FROM documents AS t1 JOIN document_sections AS t2 ON t1.document_code  =  t2.document_code JOIN document_sections_images AS t3 ON t2.section_id  =  t3.section_id\"\n    }\n}\n"}
{"sample_id": "train.4532", "db_id": "document_management", "question": "Count the number of users that are logged in.", "rationale": ["Identify the table that contains user information, which is the 'Users' table.", "To count the number of users, we will use the COUNT function in SQL.", "The query will select the count of all entries in the 'Users' table without any specific conditions, as we want the total number of users."], "gold_sql": "SELECT count(*) FROM users WHERE user_login  =  1", "source_tables": ["users"], "pred_sql": "SELECT count(*) FROM Users", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of users from the 'Users' table based on a specific login username. The placeholder in the WHERE clause represents the user's login name.\",\n        \"virtual_table\": \"SELECT count(*) FROM users WHERE user_login  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4733", "db_id": "department_store", "question": "Return the distinct name of customers whose order status is Pending, in the order of customer id.", "rationale": ["Identify the relevant tables: Customers and Customer_Orders.", "We need to retrieve customer names, so we will select from the Customers table.", "To filter customers based on their order status, we need to join the Customers table with the Customer_Orders table using the customer_id.", "The condition for filtering is that the order_status_code must be 'Pending'.", "We want distinct customer names, so we will use the DISTINCT keyword.", "Finally, we will order the results by customer_id to meet the requirement."], "gold_sql": "SELECT DISTINCT T1.customer_name FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  'Pending' ORDER BY T2.customer_id", "source_tables": ["customer_orders", "customers"], "pred_sql": "SELECT DISTINCT c.customer_name \nFROM Customers c \nJOIN Customer_Orders co ON c.customer_id = co.customer_id \nWHERE co.order_status_code = 'Pending' \nORDER BY c.customer_id;", "hint": "\n"}
{"sample_id": "train.4736", "db_id": "department_store", "question": "What are the names and addressed of customers who have both New and Pending orders?", "rationale": ["Identify the tables needed: Customers, Customer_Orders, and Customer_Addresses.", "Join Customers with Customer_Orders to filter customers based on their order status.", "Join Customer_Addresses to get the addresses of the customers.", "Filter the orders to include only those with status 'New' and 'Pending'.", "Group the results by customer to ensure we only get unique customers.", "Use HAVING to ensure that only customers with both order statuses are included."], "gold_sql": "SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  'New' INTERSECT SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  'Pending'", "source_tables": ["customer_orders", "customers"], "pred_sql": "SELECT DISTINCT c.customer_name, ca.address_id \nFROM Customers c \nJOIN Customer_Orders co ON c.customer_id = co.customer_id \nJOIN Customer_Addresses ca ON c.customer_id = ca.customer_id \nWHERE co.order_status_code IN ('New', 'Pending') \nGROUP BY c.customer_id \nHAVING COUNT(DISTINCT co.order_status_code) = 2;", "hint": "\n"}
{"sample_id": "train.4749", "db_id": "department_store", "question": "Find the id and name of the staff who has been assigned for the shortest period.", "rationale": ["Identify the relevant tables: Staff and Staff_Department_Assignments.", "Join the Staff table with the Staff_Department_Assignments table on staff_id to get staff details along with their assignment dates.", "Calculate the duration of each assignment by subtracting date_assigned_from from date_assigned_to.", "Order the results by the calculated duration in ascending order to find the shortest assignment period.", "Limit the results to 1 to get only the staff member with the shortest assignment period."], "gold_sql": "SELECT T1.staff_id ,  T1.staff_name FROM staff AS T1 JOIN Staff_Department_Assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY date_assigned_to - date_assigned_from LIMIT 1", "source_tables": ["staff_department_assignments", "staff"], "pred_sql": "SELECT staff_id, staff_name FROM Staff_Department_Assignments AS T1 JOIN Staff AS T2 ON T1.staff_id = T2.staff_id ORDER BY (date_assigned_to - date_assigned_from) ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of staff members along with their job titles from the 'Staff' and 'Staff_Department_Assignments' tables. The results are ordered by the end date of their assignments, allowing users to see the most recently assigned staff members first. The placeholder in the LIMIT clause represents the maximum number of records to return.\",\n        \"virtual_table\": \"SELECT T1.staff_name ,  T2.job_title_code FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY T2.date_assigned_to DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of staff members along with their job titles from the 'Staff' and 'Staff_Department_Assignments' tables. The results are ordered by the end date of their assignments, allowing users to see the most recently assigned staff members first. The placeholder in the LIMIT clause represents the maximum number of records to return.\",\n        \"virtual_table\": \"SELECT T1.staff_name ,  T2.job_title_code FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY T2.date_assigned_to DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4750", "db_id": "department_store", "question": "What is the id and name of the staff who has been assigned for the least amount of time?", "rationale": ["Identify the relevant tables: Staff and Staff_Department_Assignments are needed to get staff details and their assignment dates.", "Join the Staff table with the Staff_Department_Assignments table on staff_id to link staff members with their assignments.", "Order the results by the date_assigned_from in ascending order to find the staff member who has been assigned for the least amount of time.", "Limit the results to 1 to get only the staff member with the least assignment duration."], "gold_sql": "SELECT T1.staff_id ,  T1.staff_name FROM staff AS T1 JOIN Staff_Department_Assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY date_assigned_to - date_assigned_from LIMIT 1", "source_tables": ["staff_department_assignments", "staff"], "pred_sql": "SELECT T1.staff_id, T1.staff_name FROM Staff AS T1 JOIN Staff_Department_Assignments AS T2 ON T1.staff_id = T2.staff_id ORDER BY T2.date_assigned_from ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of staff members along with their job titles from the 'Staff' and 'Staff_Department_Assignments' tables. The results are ordered by the end date of their assignments, allowing users to see the most recently assigned staff members first. The placeholder in the LIMIT clause represents the maximum number of records to return.\",\n        \"virtual_table\": \"SELECT T1.staff_name ,  T2.job_title_code FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY T2.date_assigned_to DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of staff members along with their job titles from the 'Staff' and 'Staff_Department_Assignments' tables. The results are ordered by the end date of their assignments, allowing users to see the most recently assigned staff members first. The placeholder in the LIMIT clause represents the maximum number of records to return.\",\n        \"virtual_table\": \"SELECT T1.staff_name ,  T2.job_title_code FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY T2.date_assigned_to DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4753", "db_id": "department_store", "question": "Find the ids of all distinct customers who made order after some orders that were Cancelled.", "rationale": ["Identify the main table to query: Customer_Orders, as we need customer ids related to orders.", "We need to find distinct customer ids, so we will use SELECT DISTINCT on customer_id.", "We need to filter customers who made orders after some orders that were cancelled. This requires a subquery.", "The subquery will select order_ids from Customer_Orders where the order_status_code is 'Cancelled' and the order_date is before the order_date of the outer query.", "The outer query will then check if the order_id is in the result of the subquery, ensuring we only get customers who made orders after a cancelled order."], "gold_sql": "SELECT DISTINCT customer_id FROM Customer_Orders WHERE order_date  >  (SELECT min(order_date) FROM Customer_Orders WHERE order_status_code  =  'Cancelled')", "source_tables": ["customer_orders"], "pred_sql": "SELECT DISTINCT co.customer_id\nFROM Customer_Orders co\nWHERE co.order_id IN (\n    SELECT co2.order_id\n    FROM Customer_Orders co2\n    WHERE co2.order_status_code = 'Cancelled'\n    AND co2.order_date < co.order_date\n)", "hint": "\n"}
{"sample_id": "train.4755", "db_id": "department_store", "question": "What is id of the staff who had a Staff Department Assignment earlier than any Clerical Staff?", "rationale": ["Identify the relevant tables: We need to look at the Staff and Staff_Department_Assignments tables to find staff members and their assignments.", "Determine the condition: We want to find staff who had an assignment earlier than any Clerical Staff. This means we need to find the earliest assignment date of Clerical Staff.", "Use a subquery: We will use a subquery to find the minimum assignment date for Clerical Staff by joining Staff_Department_Assignments with Staff on staff_id and filtering by job_title_code.", "Select staff_id: Finally, we will select the staff_id from Staff_Department_Assignments where the date_assigned_from is less than the result of the subquery."], "gold_sql": "SELECT staff_id FROM Staff_Department_Assignments WHERE date_assigned_to  <  (SELECT max(date_assigned_to) FROM Staff_Department_Assignments WHERE job_title_code  =  'Clerical Staff')", "source_tables": ["staff_department_assignments"], "pred_sql": "SELECT staff_id FROM Staff_Department_Assignments AS T1 WHERE date_assigned_from < (SELECT MIN(date_assigned_from) FROM Staff_Department_Assignments AS T2 JOIN Staff AS T3 ON T2.staff_id = T3.staff_id WHERE T3.job_title_code = 'Clerical')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of staff members along with their job titles from the 'Staff' and 'Staff_Department_Assignments' tables. The results are ordered by the end date of their assignments, allowing users to see the most recently assigned staff members first. The placeholder in the LIMIT clause represents the maximum number of records to return.\",\n        \"virtual_table\": \"SELECT T1.staff_name ,  T2.job_title_code FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY T2.date_assigned_to DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of staff members along with their job titles from the 'Staff' and 'Staff_Department_Assignments' tables. The results are ordered by the end date of their assignments, allowing users to see the most recently assigned staff members first. The placeholder in the LIMIT clause represents the maximum number of records to return.\",\n        \"virtual_table\": \"SELECT T1.staff_name ,  T2.job_title_code FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY T2.date_assigned_to DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4758", "db_id": "department_store", "question": "Return the names and ids of customers who have TN in their address.", "rationale": ["Identify the relevant tables: Customers, Customer_Addresses, and Addresses.", "We need to retrieve customer names and IDs, so we will select 'customer_name' and 'customer_id' from the Customers table.", "To find customers with 'TN' in their address, we need to join the Customers table with the Customer_Addresses table on 'customer_id'.", "Next, we join the Customer_Addresses table with the Addresses table on 'address_id' to access the address details.", "Finally, we filter the results using a WHERE clause to check if 'address_details' contains 'TN' using the LIKE operator."], "gold_sql": "SELECT customer_name ,  customer_id FROM customers WHERE customer_address LIKE '%TN%'", "source_tables": ["customers"], "pred_sql": "SELECT Customers.customer_name, Customers.customer_id \nFROM Customers \nJOIN Customer_Addresses ON Customers.customer_id = Customer_Addresses.customer_id \nJOIN Addresses ON Customer_Addresses.address_id = Addresses.address_id \nWHERE Addresses.address_details LIKE '%TN%';", "hint": "\n"}
{"sample_id": "train.4760", "db_id": "department_store", "question": "What are the names and genders of staff who were assigned in 2016?", "rationale": ["Identify the relevant tables: Staff and Staff_Department_Assignments.", "We need to retrieve staff names and genders, so we will select 'staff_name' and 'staff_gender' from the Staff table.", "To find out which staff were assigned in 2016, we will join the Staff table with the Staff_Department_Assignments table on 'staff_id'.", "We will filter the results using a WHERE clause to check if the year of 'date_assigned_from' is 2016 using the strftime function.", "Construct the SQL query with the selected fields, join condition, and the date filter."], "gold_sql": "SELECT T1.staff_name ,  T1.staff_gender FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.date_assigned_from LIKE '2016%'", "source_tables": ["staff_department_assignments", "staff"], "pred_sql": "SELECT S.staff_name, S.staff_gender \nFROM Staff AS S \nJOIN Staff_Department_Assignments AS A ON S.staff_id = A.staff_id \nWHERE strftime('%Y', A.date_assigned_from) = '2016';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of staff members along with their job titles from the 'Staff' and 'Staff_Department_Assignments' tables. The results are ordered by the end date of their assignments, allowing users to see the most recently assigned staff members first. The placeholder in the LIMIT clause represents the maximum number of records to return.\",\n        \"virtual_table\": \"SELECT T1.staff_name ,  T2.job_title_code FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY T2.date_assigned_to DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of staff members along with their job titles from the 'Staff' and 'Staff_Department_Assignments' tables. The results are ordered by the end date of their assignments, allowing users to see the most recently assigned staff members first. The placeholder in the LIMIT clause represents the maximum number of records to return.\",\n        \"virtual_table\": \"SELECT T1.staff_name ,  T2.job_title_code FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY T2.date_assigned_to DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4762", "db_id": "department_store", "question": "What are the names of staff who have been assigned multiple jobs?", "rationale": ["We need to find the names of staff members who have been assigned multiple jobs.", "To do this, we will use the Staff table to get the staff names.", "We will also use the Staff_Department_Assignments table to count the number of distinct job titles assigned to each staff member.", "We will group the results by staff_id and use the HAVING clause to filter those who have more than one distinct job title.", "Finally, we will select the staff_name from the Staff table where the staff_id matches those who have multiple job assignments."], "gold_sql": "SELECT T1.staff_name FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id GROUP BY T2.staff_id HAVING COUNT (*)  >  1", "source_tables": ["staff_department_assignments", "staff"], "pred_sql": "SELECT staff_name FROM Staff WHERE staff_id IN (SELECT staff_id FROM Staff_Department_Assignments GROUP BY staff_id HAVING COUNT(DISTINCT job_title_code) > 1);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of staff members along with their job titles from the 'Staff' and 'Staff_Department_Assignments' tables. The results are ordered by the end date of their assignments, allowing users to see the most recently assigned staff members first. The placeholder in the LIMIT clause represents the maximum number of records to return.\",\n        \"virtual_table\": \"SELECT T1.staff_name ,  T2.job_title_code FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY T2.date_assigned_to DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of staff members along with their job titles from the 'Staff' and 'Staff_Department_Assignments' tables. The results are ordered by the end date of their assignments, allowing users to see the most recently assigned staff members first. The placeholder in the LIMIT clause represents the maximum number of records to return.\",\n        \"virtual_table\": \"SELECT T1.staff_name ,  T2.job_title_code FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY T2.date_assigned_to DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4792", "db_id": "department_store", "question": "What are the ids and names of customers with addressed that contain WY and who do not use a credit card for payment?", "rationale": ["Identify the relevant table: Customers, which contains customer_id, customer_name, customer_address, and payment_method_code.", "Filter customers based on their address containing 'WY'. This can be done using the LIKE operator with wildcards.", "Exclude customers who use a credit card for payment by checking that payment_method_code is not equal to 'CREDIT_CARD'.", "Combine these conditions in the WHERE clause of the SQL query to retrieve the desired information."], "gold_sql": "SELECT customer_id ,  customer_name FROM customers WHERE customer_address LIKE '%WY%' AND payment_method_code != 'Credit Card'", "source_tables": ["customers"], "pred_sql": "SELECT customer_id, customer_name \nFROM Customers \nWHERE customer_address LIKE '%WY%' \nAND payment_method_code != 'CREDIT_CARD';", "hint": "\n"}
{"sample_id": "train.4793", "db_id": "department_store", "question": "Find the average price of all product clothes.", "rationale": ["Identify the table needed: Products table contains product information including price and type.", "Determine the required calculation: We need to calculate the average price of products.", "Use the provided hint to form the SQL query: The hint suggests using the avg function on product_price with a WHERE clause for product_type_code.", "Replace the placeholder in the hint with 'clothes' to specify the type of product we are interested in."], "gold_sql": "SELECT avg(product_price) FROM products WHERE product_type_code  =  'Clothes'", "source_tables": ["products"], "pred_sql": "SELECT avg(product_price) FROM Products WHERE product_type_code = 'clothes'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average price of products from the 'Products' table that belong to a specific product type. The placeholder in the WHERE clause represents the product type code.\",\n        \"virtual_table\": \"SELECT avg(product_price) FROM products WHERE product_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4795", "db_id": "department_store", "question": "Find the name of the most expensive hardware product.", "rationale": ["Identify the relevant table: Products, which contains product details including name and price.", "Filter the products to only include those of type 'hardware' using the product_type_code column.", "Sort the filtered products by price in descending order to get the most expensive one at the top.", "Limit the results to 1 to get only the most expensive hardware product."], "gold_sql": "SELECT product_name FROM products WHERE product_type_code  =  'Hardware' ORDER BY product_price DESC LIMIT 1", "source_tables": ["products"], "pred_sql": "SELECT product_name FROM Products WHERE product_type_code = 'hardware' ORDER BY product_price DESC LIMIT 1;", "hint": "\n"}
{"sample_id": "train.4902", "db_id": "store_product", "question": "Find the list of page size which have more than 3 product listed", "rationale": ["We need to find the list of page sizes that have more than 3 products listed.", "To do this, we will join the 'store_product' table with the 'product' table using the product_id.", "We will select the 'max_page_size' from the 'product' table.", "We will group the results by 'max_page_size' to aggregate the products that share the same page size.", "Finally, we will use the HAVING clause to filter those groups where the count of products is greater than 3."], "gold_sql": "SELECT max_page_size FROM product GROUP BY max_page_size HAVING count(*)  >  3", "source_tables": ["product"], "pred_sql": "SELECT max_page_size FROM store_product AS sp JOIN product AS p ON sp.Product_ID = p.product_id GROUP BY max_page_size HAVING COUNT(sp.Product_ID) > 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the products from the 'product' table that match a specific search criterion. The placeholder in the WHERE clause represents a pattern for the product name or description.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE product LIKE [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the products available in a specific store. The placeholder in the WHERE clause represents the name of the store for which the products are being queried.\",\n        \"virtual_table\": \"SELECT t1.product FROM product AS t1 JOIN store_product AS t2 ON t1.product_id  =  t2.product_id JOIN store AS t3 ON t2.store_id  =  t3.store_id WHERE t3.store_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4903", "db_id": "store_product", "question": "What is the maximum page size for everything that has more than 3 products listed?", "rationale": ["Identify the relevant tables: product, store_product, and store are needed to get the maximum page size for products in stores.", "Join the product table with the store_product table to link products to their respective stores.", "Join the resulting table with the store table to access store information.", "Group the results by store to aggregate data for each store.", "Use the COUNT function to count the number of products per store and filter those with more than 3 products using HAVING clause.", "Select the maximum page size from the product table for those stores that meet the criteria."], "gold_sql": "SELECT max_page_size FROM product GROUP BY max_page_size HAVING count(*)  >  3", "source_tables": ["product"], "pred_sql": "SELECT MAX(p.max_page_size) \nFROM product AS p \nJOIN store_product AS sp ON p.product_id = sp.product_id \nJOIN store AS s ON sp.store_id = s.store_id \nGROUP BY s.store_id \nHAVING COUNT(sp.product_id) > 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the products available in a specific store. The placeholder in the WHERE clause represents the name of the store for which the products are being queried.\",\n        \"virtual_table\": \"SELECT t1.product FROM product AS t1 JOIN store_product AS t2 ON t1.product_id  =  t2.product_id JOIN store AS t3 ON t2.store_id  =  t3.store_id WHERE t3.store_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the products from the 'product' table that match a specific search criterion. The placeholder in the WHERE clause represents a pattern for the product name or description.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE product LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4913", "db_id": "store_product", "question": "What is the total number of residents for the districts with the 3 largest areas?", "rationale": ["Identify the relevant table: The question pertains to districts and their populations, so we will use the 'district' table.", "Determine the required information: We need to find the total number of residents, which corresponds to the 'City_Population' column.", "Find the districts with the largest areas: We will order the districts by 'City_Area' in descending order and limit the results to the top 3 districts.", "Use a subquery to get the District_IDs of the top 3 largest areas and then sum their populations in the main query."], "gold_sql": "SELECT sum(city_population) FROM district ORDER BY city_area DESC LIMIT 3", "source_tables": ["district"], "pred_sql": "SELECT SUM(City_Population) AS Total_Residents\nFROM district\nWHERE District_ID IN (\n    SELECT District_ID\n    FROM district\n    ORDER BY City_Area DESC\n    LIMIT 3\n);", "hint": "\n"}
{"sample_id": "train.4917", "db_id": "store_product", "question": "What are the names of all the stores located in Khanewal District?", "rationale": ["Identify the tables involved: store, store_district, and district.", "Determine the relationship between these tables: store is linked to store_district via Store_ID, and store_district is linked to district via District_ID.", "Select the Store_Name from the store table (aliased as t1).", "Join the store table with store_district (aliased as t2) on Store_ID.", "Join the result with the district table (aliased as t3) on District_ID.", "Filter the results where the District_name in the district table equals 'Khanewal'."], "gold_sql": "SELECT t1.store_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t3.district_name  =  'Khanewal District'", "source_tables": ["store_district", "store", "district"], "pred_sql": "SELECT t1.Store_Name FROM store AS t1 JOIN store_district AS t2 ON t1.Store_ID = t2.Store_ID JOIN district AS t3 ON t2.District_ID = t3.District_ID WHERE t3.District_name = 'Khanewal'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of stores located in a specific district. The query joins the 'store', 'store_district', and 'district' tables to filter stores based on the district's name provided as a placeholder.\",\n        \"virtual_table\": \"SELECT t1.store_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t3.district_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the products available in a specific store. The placeholder in the WHERE clause represents the name of the store for which the products are being queried.\",\n        \"virtual_table\": \"SELECT t1.product FROM product AS t1 JOIN store_product AS t2 ON t1.product_id  =  t2.product_id JOIN store AS t3 ON t2.store_id  =  t3.store_id WHERE t3.store_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4924", "db_id": "store_product", "question": "Find the city with the most number of stores.", "rationale": ["To find the city with the most number of stores, we need to count the number of stores in each city.", "We will join the 'store' table with the 'store_district' table to associate each store with its district.", "Next, we will join the 'district' table to get the city information for each district.", "We will use the COUNT function to count the number of stores for each city and group the results by the city name.", "Finally, we will order the results in descending order based on the count of stores and limit the result to 1 to get the city with the most stores."], "gold_sql": "SELECT t3.headquartered_city FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id GROUP BY t3.headquartered_city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["store_district", "store", "district"], "pred_sql": "SELECT d.Headquartered_City, COUNT(s.Store_ID) AS Number_of_Stores\nFROM store AS s\nJOIN store_district AS sd ON s.Store_ID = sd.Store_ID\nJOIN district AS d ON sd.District_ID = d.District_ID\nGROUP BY d.Headquartered_City\nORDER BY Number_of_Stores DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of stores located in a specific district. The query joins the 'store', 'store_district', and 'district' tables to filter stores based on the district's name provided as a placeholder.\",\n        \"virtual_table\": \"SELECT t1.store_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t3.district_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the products available in a specific store. The placeholder in the WHERE clause represents the name of the store for which the products are being queried.\",\n        \"virtual_table\": \"SELECT t1.product FROM product AS t1 JOIN store_product AS t2 ON t1.product_id  =  t2.product_id JOIN store AS t3 ON t2.store_id  =  t3.store_id WHERE t3.store_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4930", "db_id": "store_product", "question": "Find products with max page size as \"A4\" and pages per minute color smaller than 5.", "rationale": ["Identify the relevant table: The 'product' table contains the columns we need for the query.", "Determine the conditions: We need to filter products based on 'max_page_size' being 'A4' and 'pages_per_minute_color' being less than 5.", "Construct the SQL query: Use a SELECT statement to retrieve all columns from the 'product' table where the specified conditions are met."], "gold_sql": "SELECT product FROM product WHERE max_page_size  =  'A4' AND pages_per_minute_color  <  5", "source_tables": ["product"], "pred_sql": "SELECT * FROM product WHERE max_page_size = 'A4' AND pages_per_minute_color < '5';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the products from the 'product' table that match a specific search criterion. The placeholder in the WHERE clause represents a pattern for the product name or description.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE product LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4932", "db_id": "store_product", "question": "Find products with max page size as \"A4\" or pages per minute color smaller than 5.", "rationale": ["Identify the relevant table: The 'product' table contains the columns we need to filter by, specifically 'max_page_size' and 'pages_per_minute_color'.", "Determine the filtering criteria: We need to find products where the 'max_page_size' is 'A4' or the 'pages_per_minute_color' is less than 5.", "Construct the SQL query: Use a SELECT statement to retrieve all columns from the 'product' table, applying the WHERE clause to filter based on the specified conditions."], "gold_sql": "SELECT product FROM product WHERE max_page_size  =  'A4' OR pages_per_minute_color  <  5", "source_tables": ["product"], "pred_sql": "SELECT * FROM product WHERE max_page_size = 'A4' OR pages_per_minute_color < '5';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the products from the 'product' table that match a specific search criterion. The placeholder in the WHERE clause represents a pattern for the product name or description.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE product LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4935", "db_id": "store_product", "question": "What are all of the products whose name includes the substring \"Scanner\"?", "rationale": ["Identify the relevant table: The 'product' table contains the product names.", "Determine the search criterion: We need to find products whose names include the substring 'Scanner'.", "Use the SQL LIKE operator with wildcards: The pattern '%Scanner%' will match any product name that contains 'Scanner' anywhere in it.", "Construct the SQL query: Combine the SELECT statement with the WHERE clause to filter the products accordingly."], "gold_sql": "SELECT product FROM product WHERE product LIKE '%Scanner%'", "source_tables": ["product"], "pred_sql": "SELECT product FROM product WHERE product LIKE '%Scanner%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the products from the 'product' table that match a specific search criterion. The placeholder in the WHERE clause represents a pattern for the product name or description.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE product LIKE [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the products available in a specific store. The placeholder in the WHERE clause represents the name of the store for which the products are being queried.\",\n        \"virtual_table\": \"SELECT t1.product FROM product AS t1 JOIN store_product AS t2 ON t1.product_id  =  t2.product_id JOIN store AS t3 ON t2.store_id  =  t3.store_id WHERE t3.store_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4937", "db_id": "store_product", "question": "What is the most common maximum page size?", "rationale": ["Identify the relevant table: The question pertains to the maximum page size of products, which is found in the 'product' table.", "Determine the required information: We need to find the most common maximum page size, which implies counting occurrences of each maximum page size.", "Construct the SQL query: Use a SELECT statement to retrieve the 'max_page_size' and count how many times each appears in the 'product' table.", "Group the results by 'max_page_size' to aggregate counts for each unique size.", "Order the results by the count in descending order to get the most common size at the top.", "Limit the results to 1 to get only the most common maximum page size."], "gold_sql": "SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT 1", "source_tables": ["product"], "pred_sql": "SELECT max_page_size, COUNT(*) as count\nFROM product\nGROUP BY max_page_size\nORDER BY count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.4938", "db_id": "store_product", "question": "Find the name of the products that are not using the most frequently-used max page size.", "rationale": ["Identify the column of interest: 'max_page_size' from the 'product' table.", "Determine the most frequently used 'max_page_size' by grouping the products by 'max_page_size' and counting occurrences.", "Order the results by count in descending order to find the most common 'max_page_size'.", "Use a subquery to get the most frequently used 'max_page_size'.", "Select product names from the 'product' table where the 'max_page_size' is not equal to the most frequently used one."], "gold_sql": "SELECT product FROM product WHERE product != (SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["product"], "pred_sql": "SELECT product.product \nFROM product \nWHERE product.max_page_size != (SELECT max_page_size \n                                 FROM product \n                                 GROUP BY max_page_size \n                                 ORDER BY COUNT(*) DESC \n                                 LIMIT 1);", "hint": "\n"}
{"sample_id": "train.4947", "db_id": "soccer_2", "question": "How many students, on average, does each college have enrolled?", "rationale": ["Identify the goal: Calculate the average enrollment number of students at each college.", "Determine the relevant table: The 'College' table contains the 'enr' column which represents enrollment numbers.", "Use the AVG() function to compute the average of the 'enr' column.", "Construct the SQL query to select the average enrollment from the 'College' table."], "gold_sql": "SELECT avg(enr) FROM College", "source_tables": ["college"], "pred_sql": "SELECT AVG(enr) AS average_enrollment FROM College;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average enrollment number of colleges located in a specific state. The placeholder in the WHERE clause represents the name of the state.\",\n        \"virtual_table\": \"SELECT avg(enr) FROM College WHERE state  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the number of players from the 'Player' table who attended high schools with an enrollment number greater than a specified value. The placeholder in the WHERE clause represents the enrollment number of students at the high school.\",\n        \"virtual_table\": \"SELECT count(*) FROM Player WHERE HS  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4955", "db_id": "soccer_2", "question": "How many hours do the players train on average?", "rationale": ["The question asks for the average hours players train, which implies we need to calculate an average from a relevant column.", "Since the schema provided does not include a direct column for training hours, we assume there is a column named 'training_hours' in the Player table (or it could be a derived value).", "To find the average, we use the AVG() function in SQL, which calculates the average of a numeric column.", "The final SQL query selects the average of the 'training_hours' column from the Player table."], "gold_sql": "SELECT avg(HS) FROM Player", "source_tables": ["player"], "pred_sql": "SELECT AVG(training_hours) FROM Player", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average high school attended by players from the 'Player' table. The placeholder in the SELECT clause represents the high school data that will be averaged.\",\n        \"virtual_table\": \"SELECT avg(HS) FROM Player\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average high school identifier of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT avg(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4956", "db_id": "soccer_2", "question": "Find the name and training hours of players whose hours are below 1500.", "rationale": ["The query needs to find players whose training hours are below 1500.", "We need to join the 'Player' table with the 'Tryout' table to access player names and their training hours.", "The 'Player' table contains player names and IDs, while the 'Tryout' table contains the training hours and player IDs.", "We will use a JOIN operation on the 'pID' column to combine these tables.", "We will filter the results using a WHERE clause to only include players with hours less than 1500.", "Finally, we will order the results alphabetically by player name."], "gold_sql": "SELECT pName ,  HS FROM Player WHERE HS  <  1500", "source_tables": ["player"], "pred_sql": "SELECT T1.pName FROM Player AS T1 JOIN Tryout AS T2 ON T1.pID = T2.pID WHERE T2.hours < 1500 ORDER BY T1.pName", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n        \"virtual_table\": \"SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n        \"virtual_table\": \"SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.4961", "db_id": "soccer_2", "question": "What are the different types of player positions?", "rationale": ["The question asks for the different types of player positions.", "To find the distinct player positions, we need to select from the 'Tryout' table.", "Using the DISTINCT keyword will ensure that we only get unique positions.", "The final SQL query will be 'SELECT DISTINCT pPos FROM Tryout'."], "gold_sql": "SELECT count(DISTINCT pPos) FROM tryout", "source_tables": ["tryout"], "pred_sql": "SELECT DISTINCT pPos FROM Tryout", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of distinct positions that players are trying out for in the 'Tryout' table. The result will give an overview of the variety of positions available for players during tryouts.\",\n        \"virtual_table\": \"SELECT count(DISTINCT pPos) FROM tryout\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n        \"virtual_table\": \"SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName\"\n    }\n}\n"}
{"sample_id": "train.4962", "db_id": "soccer_2", "question": "How many students got accepted after the tryout?", "rationale": ["Identify the relevant table: The 'Tryout' table contains the information about players and their decisions after tryouts.", "Determine the condition for acceptance: We need to count the number of players whose decision is 'accepted'.", "Construct the SQL query: Use the COUNT function to count the number of rows in the 'Tryout' table where the decision is 'accepted'."], "gold_sql": "SELECT count(*) FROM tryout WHERE decision  =  'yes'", "source_tables": ["tryout"], "pred_sql": "SELECT COUNT(*) FROM tryout WHERE decision = 'accepted'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n        \"virtual_table\": \"SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n        \"virtual_table\": \"SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName\"\n    }\n}\n"}
{"sample_id": "train.4966", "db_id": "soccer_2", "question": "Find the max, average and min training hours of all players.", "rationale": ["The task is to find the maximum, average, and minimum training hours of all players.", "We need to select the maximum, average, and minimum values from a column that represents training hours.", "Since the schema does not explicitly mention a column for training hours, we assume it is a part of the Player table or needs to be calculated based on other data.", "The SQL query will use aggregate functions MAX(), AVG(), and MIN() to compute the required values from the appropriate column."], "gold_sql": "SELECT avg(HS) ,  max(HS) ,  min(HS) FROM Player", "source_tables": ["player"], "pred_sql": "SELECT MAX(training_hours) AS max_hours, AVG(training_hours) AS avg_hours, MIN(training_hours) AS min_hours FROM Player", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average high school attended by players from the 'Player' table. The placeholder in the SELECT clause represents the high school data that will be averaged.\",\n        \"virtual_table\": \"SELECT avg(HS) FROM Player\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average high school identifier of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT avg(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of distinct positions that players are trying out for in the 'Tryout' table. The result will give an overview of the variety of positions available for players during tryouts.\",\n        \"virtual_table\": \"SELECT count(DISTINCT pPos) FROM tryout\"\n    }\n}\n"}
{"sample_id": "train.4967", "db_id": "soccer_2", "question": "What is the average, maximum, and minimum for the number of hours spent training?", "rationale": ["The question asks for the average, maximum, and minimum number of hours spent training.", "To calculate these statistics, we need to use aggregate functions: AVG() for average, MAX() for maximum, and MIN() for minimum.", "Assuming there is a table named 'Training' that contains a column 'training_hours' which records the hours spent training by players.", "The SQL query will select the average, maximum, and minimum values from the 'training_hours' column in the 'Training' table."], "gold_sql": "SELECT avg(HS) ,  max(HS) ,  min(HS) FROM Player", "source_tables": ["player"], "pred_sql": "SELECT AVG(training_hours) AS average_hours, MAX(training_hours) AS max_hours, MIN(training_hours) AS min_hours FROM Training;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average high school attended by players from the 'Player' table. The placeholder in the SELECT clause represents the high school data that will be averaged.\",\n        \"virtual_table\": \"SELECT avg(HS) FROM Player\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of distinct positions that players are trying out for in the 'Tryout' table. The result will give an overview of the variety of positions available for players during tryouts.\",\n        \"virtual_table\": \"SELECT count(DISTINCT pPos) FROM tryout\"\n    }\n}\n"}
{"sample_id": "train.4970", "db_id": "soccer_2", "question": "What are the names of players whose training hours is between 500 and 1500?", "rationale": ["Identify the relevant tables: We need to find player names, which are in the 'Player' table.", "Determine the condition: We are looking for players whose training hours are between 500 and 1500.", "Since the hint does not provide information about a 'training_hours' column, we assume it exists in the 'Player' table or is derived from the context of the question.", "Construct the SQL query to select player names from the 'Player' table where their training hours fall within the specified range."], "gold_sql": "SELECT pName FROM Player WHERE HS BETWEEN 500 AND 1500", "source_tables": ["player"], "pred_sql": "SELECT pName FROM Player WHERE pID IN (SELECT pID FROM Tryout) AND training_hours BETWEEN 500 AND 1500;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n        \"virtual_table\": \"SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n        \"virtual_table\": \"SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.4971", "db_id": "soccer_2", "question": "What are the names of players who train between 500 and 1500 hours?", "rationale": ["Identify the relevant tables: Player and Tryout.", "Join the Player table with the Tryout table on the player ID (pID).", "Filter the results to include only those players who have trained between 500 and 1500 hours.", "Select the names of the players (pName) from the Player table.", "Order the results alphabetically by player name."], "gold_sql": "SELECT pName FROM Player WHERE HS BETWEEN 500 AND 1500", "source_tables": ["player"], "pred_sql": "SELECT T1.pName FROM Player AS T1 JOIN Tryout AS T2 ON T1.pID = T2.pID WHERE T2.hours BETWEEN 500 AND 1500 ORDER BY T1.pName", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n        \"virtual_table\": \"SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n        \"virtual_table\": \"SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.4975", "db_id": "soccer_2", "question": "What are the names and enrollment numbers for colleges that have more than 10000 enrolled and are located in Louisiana?", "rationale": ["Identify the relevant table: The question pertains to colleges, so we will use the 'College' table.", "Determine the columns needed: We need the names of the colleges ('cName') and their enrollment numbers ('enr').", "Set the conditions for the query: We need colleges with an enrollment number greater than 10000 and located in Louisiana.", "Construct the SQL query: Using the SELECT statement to retrieve 'cName' and 'enr' from the 'College' table with the specified conditions."], "gold_sql": "SELECT cName ,  enr FROM College WHERE enr  >  10000 AND state = 'LA'", "source_tables": ["college"], "pred_sql": "SELECT cName, enr FROM College WHERE enr > 10000 AND state = 'Louisiana';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average enrollment number of colleges located in a specific state. The placeholder in the WHERE clause represents the name of the state.\",\n        \"virtual_table\": \"SELECT avg(enr) FROM College WHERE state  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the number of players from the 'Player' table who attended high schools with an enrollment number greater than a specified value. The placeholder in the WHERE clause represents the enrollment number of students at the high school.\",\n        \"virtual_table\": \"SELECT count(*) FROM Player WHERE HS  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of players from the 'Player' table who attended high schools with an enrollment number greater than a specified value. The placeholder in the WHERE clause represents the minimum enrollment number of students at the high school.\",\n        \"virtual_table\": \"SELECT count(*) FROM Player WHERE HS  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4981", "db_id": "soccer_2", "question": "What are the name of the players who received a card in descending order of the hours of training?", "rationale": ["The question asks for the names of players who received a card, which implies we need to look at the Player table for player names.", "We need to join the Player table with the Tryout table to get the relevant information about the players' tryouts.", "The ordering is specified as descending, but it is unclear what specific column to order by since 'hours of training' is not a column in the provided schema.", "However, since 'decision' is mentioned in the hint, we can assume it might relate to the outcome of their tryouts, so we will order by 'decision' in descending order."], "gold_sql": "SELECT pName FROM Player WHERE yCard  =  'yes' ORDER BY HS DESC", "source_tables": ["player"], "pred_sql": "SELECT T1.pName FROM Player AS T1 JOIN Tryout AS T2 ON T1.pID = T2.pID ORDER BY T2.decision DESC", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n        \"virtual_table\": \"SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n        \"virtual_table\": \"SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.4984", "db_id": "soccer_2", "question": "Which position is most popular among players in the tryout?", "rationale": ["To find the most popular position among players in the tryout, we need to count how many players are trying out for each position.", "We will use the 'Tryout' table, which contains the 'pPos' column representing the position players are trying out for.", "We will group the results by 'pPos' to get the count of players for each position.", "Next, we will order the results in descending order based on the count of players for each position.", "Finally, we will limit the results to 1 to get only the most popular position."], "gold_sql": "SELECT pPos FROM tryout GROUP BY pPos ORDER BY count(*) DESC LIMIT 1", "source_tables": ["tryout"], "pred_sql": "SELECT pPos, COUNT(*) as position_count \nFROM Tryout \nGROUP BY pPos \nORDER BY position_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of distinct positions that players are trying out for in the 'Tryout' table. The result will give an overview of the variety of positions available for players during tryouts.\",\n        \"virtual_table\": \"SELECT count(DISTINCT pPos) FROM tryout\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n        \"virtual_table\": \"SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName\"\n    }\n}\n"}
{"sample_id": "train.4985", "db_id": "soccer_2", "question": "What was the most popular position at tryouts?", "rationale": ["To find the most popular position at tryouts, we need to count how many players are trying out for each position.", "We can achieve this by selecting the position (pPos) from the Tryout table and counting the occurrences of each position.", "We will group the results by the position to get the count for each one.", "To determine which position is the most popular, we will order the results in descending order based on the count.", "Finally, we will limit the results to just one entry to get the most popular position."], "gold_sql": "SELECT pPos FROM tryout GROUP BY pPos ORDER BY count(*) DESC LIMIT 1", "source_tables": ["tryout"], "pred_sql": "SELECT pPos, COUNT(*) as position_count \nFROM Tryout \nGROUP BY pPos \nORDER BY position_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of distinct positions that players are trying out for in the 'Tryout' table. The result will give an overview of the variety of positions available for players during tryouts.\",\n        \"virtual_table\": \"SELECT count(DISTINCT pPos) FROM tryout\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n        \"virtual_table\": \"SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName\"\n    }\n}\n"}
{"sample_id": "train.4988", "db_id": "soccer_2", "question": "What is minimum hours of the students playing in different position?", "rationale": ["Identify the relevant table: The 'Tryout' table contains the information about players and their positions.", "Determine the required information: We need to find the minimum hours of students playing in different positions, which implies counting the number of players for each position.", "Use the COUNT function to count the number of players for each position in the 'Tryout' table.", "Group the results by position using GROUP BY to get the count for each position."], "gold_sql": "SELECT min(T2.HS) ,   T1.pPos FROM tryout AS T1 JOIN player AS T2 ON T1.pID  =  T2.pID GROUP BY T1.pPos", "source_tables": ["player", "tryout"], "pred_sql": "SELECT pPos, COUNT(*) AS min_hours FROM Tryout GROUP BY pPos", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of distinct positions that players are trying out for in the 'Tryout' table. The result will give an overview of the variety of positions available for players during tryouts.\",\n        \"virtual_table\": \"SELECT count(DISTINCT pPos) FROM tryout\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the total number of players who are trying out for a specific position from the 'Tryout' table. The placeholder in the WHERE clause represents the position for which the count is being calculated.\",\n        \"virtual_table\": \"SELECT count(*) FROM tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4989", "db_id": "soccer_2", "question": "For each position, what is the minimum time students spent practicing?", "rationale": ["Identify the relevant tables: We need to find the minimum time students spent practicing for each position, which suggests we need a table that records practice sessions and their durations.", "Assume there is a table named 'practice_sessions' that records practice times for players, including columns for 'pID', 'pPos', and 'practice_time'.", "We need to group the results by 'pPos' to get the minimum practice time for each position.", "Use the MIN() function to find the minimum practice time for each position.", "Construct the SQL query to select the position and the minimum practice time, grouping by position."], "gold_sql": "SELECT min(T2.HS) ,   T1.pPos FROM tryout AS T1 JOIN player AS T2 ON T1.pID  =  T2.pID GROUP BY T1.pPos", "source_tables": ["player", "tryout"], "pred_sql": "SELECT pPos, MIN(practice_time) AS min_practice_time\nFROM practice_sessions\nGROUP BY pPos;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of distinct positions that players are trying out for in the 'Tryout' table. The result will give an overview of the variety of positions available for players during tryouts.\",\n        \"virtual_table\": \"SELECT count(DISTINCT pPos) FROM tryout\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the total number of players who are trying out for a specific position from the 'Tryout' table. The placeholder in the WHERE clause represents the position for which the count is being calculated.\",\n        \"virtual_table\": \"SELECT count(*) FROM tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5003", "db_id": "soccer_2", "question": "What are the names and hours spent practicing of every student who received a yes at tryouts?", "rationale": ["Identify the relevant tables: Player and Tryout.", "We need the names of players, which are in the Player table under the column pName.", "We also need to know the hours spent practicing, which is assumed to be a column in the Tryout table (though not explicitly mentioned in the schema).", "We need to join the Player table with the Tryout table on the pID column to link players with their tryout decisions.", "We filter the results to include only those players whose decision was 'yes'.", "Finally, we select the player's name and their hours spent practicing."], "gold_sql": "SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes'", "source_tables": ["player", "tryout"], "pred_sql": "SELECT P.pName, T.hours_spent_practicing FROM Player AS P JOIN Tryout AS T ON P.pID = T.pID WHERE T.decision = 'yes'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n        \"virtual_table\": \"SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n        \"virtual_table\": \"SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.5007", "db_id": "soccer_2", "question": "What are the names of all students who successfully tried out for the position of striker?", "rationale": ["Identify the relevant tables: Player and Tryout.", "We need to find players who tried out for the position of 'striker'.", "We will join the Player table with the Tryout table on the player ID (pID).", "We need to filter the results to include only those players whose tryout decision was 'successful'.", "Select the names of these players and order the results alphabetically by player name."], "gold_sql": "SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes' AND T2.pPos  =  'striker'", "source_tables": ["player", "tryout"], "pred_sql": "SELECT T1.pName \nFROM Player AS T1 \nJOIN Tryout AS T2 ON T1.pID = T2.pID \nWHERE T2.pPos = 'striker' AND T2.decision = 'successful' \nORDER BY T1.pName;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n        \"virtual_table\": \"SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n        \"virtual_table\": \"SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.5013", "db_id": "soccer_2", "question": "What is the average number of hours spent practicing for students who got rejected?", "rationale": ["Identify the relevant tables: Player and Tryout.", "We need to find players who got rejected, so we will filter the Tryout table based on the decision column.", "Join the Player table with the Tryout table on the player ID (pID) to access player information for those who tried out.", "Calculate the average of the high school identifier (HS) for players who were rejected by using the AVG function in SQL.", "Construct the SQL query using the identified conditions and calculations."], "gold_sql": "SELECT avg(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'no'", "source_tables": ["player", "tryout"], "pred_sql": "SELECT avg(T1.HS) FROM Player AS T1 JOIN Tryout AS T2 ON T1.pID = T2.pID WHERE T2.decision = 'rejected'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average high school identifier of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT avg(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average high school attended by players from the 'Player' table. The placeholder in the SELECT clause represents the high school data that will be averaged.\",\n        \"virtual_table\": \"SELECT avg(HS) FROM Player\"\n    }\n}\n"}
{"sample_id": "train.5018", "db_id": "soccer_2", "question": "Which college has any student who is a goalie and succeeded in the tryout.", "rationale": ["Identify the relevant tables: College, Player, and Tryout.", "We need to find colleges that have students who are goalies and succeeded in their tryouts.", "Join the College table with the Tryout table on the college name (cName).", "Join the resulting table with the Player table on the player ID (pID).", "Filter the results where the position (pPos) is 'goalie' and the decision is 'succeeded'.", "Select distinct college names (cName) to avoid duplicates."], "gold_sql": "SELECT cName FROM  tryout WHERE decision  =  'yes' AND pPos  =  'goalie'", "source_tables": ["tryout"], "pred_sql": "SELECT DISTINCT C.cName \nFROM College AS C \nJOIN Tryout AS T ON C.cName = T.cName \nJOIN Player AS P ON T.pID = P.pID \nWHERE T.pPos = 'goalie' AND T.decision = 'succeeded';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the states of colleges where a specific player has participated in tryouts. The placeholder in the WHERE clause represents the player's name.\",\n        \"virtual_table\": \"SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName JOIN player AS T3 ON T2.pID  =  T3.pID WHERE T3.pName  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n        \"virtual_table\": \"SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName\"\n    }\n}\n"}
{"sample_id": "train.5022", "db_id": "soccer_2", "question": "What is the state and enrollment of the colleges where have any students who got accepted in the tryout decision.", "rationale": ["Identify the relevant tables: College and Tryout.", "We need to find the state and enrollment of colleges where students got accepted in the tryout decision.", "Join the College table with the Tryout table on the college name (cName).", "Filter the results to include only those records where the decision in the Tryout table is 'accepted'.", "Select the state and enrollment number from the resulting joined table."], "gold_sql": "SELECT DISTINCT T1.state ,  T1.enr FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  'yes'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT C.state, C.enr FROM College AS C JOIN Tryout AS T ON C.cName = T.cName WHERE T.decision = 'accepted';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the states of colleges where a specific player has participated in tryouts. The placeholder in the WHERE clause represents the player's name.\",\n        \"virtual_table\": \"SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName JOIN player AS T3 ON T2.pID  =  T3.pID WHERE T3.pName  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average enrollment number of colleges located in a specific state. The placeholder in the WHERE clause represents the name of the state.\",\n        \"virtual_table\": \"SELECT avg(enr) FROM College WHERE state  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5023", "db_id": "soccer_2", "question": "How many students are enrolled in colleges that have student accepted during tryouts, and in which states are those colleges?", "rationale": ["Identify the colleges that have accepted students during tryouts by filtering the Tryout table for accepted decisions.", "Join the College table to get the enrollment numbers and states of these colleges.", "Use the IN clause to filter the College table based on the names of colleges from the Tryout table that have accepted players.", "Sum the enrollment numbers of these colleges to get the total number of students enrolled.", "Use GROUP_CONCAT to list the distinct states of these colleges."], "gold_sql": "SELECT DISTINCT T1.state ,  T1.enr FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  'yes'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT SUM(CAST(enr AS INTEGER)) AS total_enrollment, GROUP_CONCAT(DISTINCT state) AS states FROM College WHERE cName IN (SELECT DISTINCT cName FROM Tryout WHERE decision = 'accepted')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the states of colleges where a specific player has participated in tryouts. The placeholder in the WHERE clause represents the player's name.\",\n        \"virtual_table\": \"SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName JOIN player AS T3 ON T2.pID  =  T3.pID WHERE T3.pName  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n        \"virtual_table\": \"SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName\"\n    }\n}\n"}
{"sample_id": "train.5026", "db_id": "soccer_2", "question": "Find the names of schools that have some students playing in goalie and mid positions.", "rationale": ["Identify the relevant table: The Tryout table contains information about player positions and the colleges where they are trying out.", "We need to find colleges (cName) where players are trying out for both 'goalie' and 'mid' positions.", "Use the IN clause to filter for the two positions: 'goalie' and 'mid'.", "To ensure that we only get colleges with players in both positions, we can group by cName and use HAVING to count distinct positions.", "The HAVING clause checks that the count of distinct positions is equal to 2, meaning both positions are represented."], "gold_sql": "SELECT cName FROM  tryout WHERE pPos  =  'goalie' INTERSECT SELECT cName FROM  tryout WHERE pPos  =  'mid'", "source_tables": ["tryout"], "pred_sql": "SELECT DISTINCT cName FROM Tryout WHERE pPos IN ('goalie', 'mid') GROUP BY cName HAVING COUNT(DISTINCT pPos) = 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the states of colleges where a specific player has participated in tryouts. The placeholder in the WHERE clause represents the player's name.\",\n        \"virtual_table\": \"SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName JOIN player AS T3 ON T2.pID  =  T3.pID WHERE T3.pName  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n        \"virtual_table\": \"SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName\"\n    }\n}\n"}
{"sample_id": "train.5028", "db_id": "soccer_2", "question": "Find the names of states that have some college students playing in goalie and mid positions.", "rationale": ["Identify the relevant tables: College, Player, and Tryout.", "We need to find states of colleges where players are trying out for specific positions (goalie and mid).", "Join the College table with the Tryout table on the college name (cName).", "Filter the results to include only those tryouts where the position (pPos) is either 'goalie' or 'mid'.", "Select distinct states from the resulting dataset to avoid duplicates."], "gold_sql": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'goalie' INTERSECT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'mid'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT DISTINCT C.state \nFROM College AS C \nJOIN Tryout AS T ON C.cName = T.cName \nWHERE T.pPos IN ('goalie', 'mid')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the states of colleges where a specific player has participated in tryouts. The placeholder in the WHERE clause represents the player's name.\",\n        \"virtual_table\": \"SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName JOIN player AS T3 ON T2.pID  =  T3.pID WHERE T3.pName  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.5029", "db_id": "soccer_2", "question": "What are the names of the states that have some college students playing in the positions of goalie and mid-field?", "rationale": ["Identify the states of colleges where players are trying out for specific positions.", "Use the Tryout table to find colleges where players are trying out for the positions 'goalie' and 'mid-field'.", "Use a subquery to get the list of college names (cName) from the Tryout table for the specified positions.", "Select distinct states from the College table where the college names match those found in the subquery."], "gold_sql": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'goalie' INTERSECT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'mid'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT DISTINCT state FROM College WHERE cName IN (SELECT cName FROM Tryout WHERE pPos IN ('goalie', 'mid-field'))", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the states of colleges where a specific player has participated in tryouts. The placeholder in the WHERE clause represents the player's name.\",\n        \"virtual_table\": \"SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName JOIN player AS T3 ON T2.pID  =  T3.pID WHERE T3.pName  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n        \"virtual_table\": \"SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName\"\n    }\n}\n"}
{"sample_id": "train.5030", "db_id": "soccer_2", "question": "How many schools have some students playing in goalie and mid positions.", "rationale": ["Identify the positions of interest: goalie and mid.", "Use the INTERSECT operator to find colleges where players are trying out for both positions.", "Count the number of distinct colleges that meet this criterion using COUNT(*) in the outer query."], "gold_sql": "SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  'goalie' INTERSECT SELECT cName FROM  tryout WHERE pPos  =  'mid')", "source_tables": ["tryout"], "pred_sql": "SELECT COUNT(*) FROM (SELECT cName FROM tryout WHERE pPos = 'goalie' INTERSECT SELECT cName FROM tryout WHERE pPos = 'mid')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of distinct positions that players are trying out for in the 'Tryout' table. The result will give an overview of the variety of positions available for players during tryouts.\",\n        \"virtual_table\": \"SELECT count(DISTINCT pPos) FROM tryout\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the states of colleges where a specific player has participated in tryouts. The placeholder in the WHERE clause represents the player's name.\",\n        \"virtual_table\": \"SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName JOIN player AS T3 ON T2.pID  =  T3.pID WHERE T3.pName  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5037", "db_id": "soccer_2", "question": "What is the count of states with college students playing in the mid position but not as goalies?", "rationale": ["Identify the states of colleges where players are trying out for the 'mid' position.", "Exclude players who are trying out for the 'goalie' position.", "Use a subquery to find colleges where players are trying out for 'mid' but not 'goalie'.", "Count the distinct states from the colleges identified in the previous step."], "gold_sql": "SELECT COUNT(*) FROM (SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'mid' EXCEPT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'goalie')", "source_tables": ["tryout", "college"], "pred_sql": "SELECT COUNT(DISTINCT state) FROM College WHERE cName IN (SELECT cName FROM Tryout WHERE pPos = 'mid' AND pID NOT IN (SELECT pID FROM Tryout WHERE pPos = 'goalie'))", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the states of colleges where a specific player has participated in tryouts. The placeholder in the WHERE clause represents the player's name.\",\n        \"virtual_table\": \"SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName JOIN player AS T3 ON T2.pID  =  T3.pID WHERE T3.pName  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of distinct positions that players are trying out for in the 'Tryout' table. The result will give an overview of the variety of positions available for players during tryouts.\",\n        \"virtual_table\": \"SELECT count(DISTINCT pPos) FROM tryout\"\n    }\n}\n"}
{"sample_id": "train.5039", "db_id": "soccer_2", "question": "What are the states with colleges that have enrollments less than the some other college?", "rationale": ["Identify the requirement to find states with colleges that have enrollments less than some other college.", "To achieve this, we need to compare the enrollment numbers of colleges in different states.", "We can use a subquery to find the maximum enrollment number from the College table, which represents the enrollment of the college we are comparing against.", "The main query will select distinct states from the College table where the enrollment number is less than the maximum enrollment found in the subquery."], "gold_sql": "SELECT DISTINCT state FROM college WHERE enr  <  (SELECT max(enr) FROM college)", "source_tables": ["college"], "pred_sql": "SELECT DISTINCT state FROM College WHERE enr < (SELECT MAX(enr) FROM College)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average enrollment number of colleges located in a specific state. The placeholder in the WHERE clause represents the name of the state.\",\n        \"virtual_table\": \"SELECT avg(enr) FROM College WHERE state  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the states of colleges where a specific player has participated in tryouts. The placeholder in the WHERE clause represents the player's name.\",\n        \"virtual_table\": \"SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName JOIN player AS T3 ON T2.pID  =  T3.pID WHERE T3.pName  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5102", "db_id": "cre_Drama_Workshop_Groups", "question": "Show the minimum, average, maximum order quantity of all invoices.", "rationale": ["The task requires calculating the minimum, average, and maximum order quantities from the 'Invoices' table.", "The hint provides a virtual table that summarizes these values using the SQL aggregate functions min(), avg(), and max().", "The virtual table is structured as 'SELECT min(Order_Quantity), avg(Order_Quantity), max(Order_Quantity) FROM Invoices', which directly addresses the requirement of the query.", "Thus, the final SQL query is constructed based on the provided virtual table."], "gold_sql": "SELECT min(Order_Quantity) ,  avg(Order_Quantity) ,  max(Order_Quantity) FROM INVOICES", "source_tables": ["invoices"], "pred_sql": "SELECT min(Order_Quantity), avg(Order_Quantity), max(Order_Quantity) FROM Invoices", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the minimum, average, and maximum quantities of products ordered as recorded in the 'Invoices' table. The placeholders in the SELECT statement represent the aggregated values of the order quantities.\",\n        \"virtual_table\": \"SELECT min(Order_Quantity) ,  avg(Order_Quantity) ,  max(Order_Quantity) FROM INVOICES\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average quantity of products ordered from the 'Invoices' table for a specific payment method. The placeholder in the WHERE clause represents the payment method code used for filtering the results.\",\n        \"virtual_table\": \"SELECT avg(Order_Quantity) FROM Invoices WHERE payment_method_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average quantity of products ordered from the 'Invoices' table for a specific payment method. The placeholder in the WHERE clause represents the payment method code used for filtering the results.\",\n        \"virtual_table\": \"SELECT avg(Order_Quantity) FROM Invoices WHERE payment_method_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5118", "db_id": "cre_Drama_Workshop_Groups", "question": "What is the payment method code used by the most orders?", "rationale": ["To find the payment method code used by the most orders, we need to count the number of orders associated with each payment method code in the Invoices table.", "We will use the COUNT function to count the number of occurrences of each payment_method_code.", "We will group the results by payment_method_code to aggregate the counts for each method.", "To get the payment method with the highest count, we will order the results in descending order based on the count.", "Finally, we will limit the results to just one record to get the payment method code used by the most orders."], "gold_sql": "SELECT payment_method_code FROM INVOICES GROUP BY payment_method_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["invoices"], "pred_sql": "SELECT payment_method_code, COUNT(*) as order_count \nFROM Invoices \nGROUP BY payment_method_code \nORDER BY order_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average quantity of products ordered from the 'Invoices' table for a specific payment method. The placeholder in the WHERE clause represents the payment method code used for filtering the results.\",\n        \"virtual_table\": \"SELECT avg(Order_Quantity) FROM Invoices WHERE payment_method_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average quantity of products ordered from the 'Invoices' table for a specific payment method. The placeholder in the WHERE clause represents the payment method code used for filtering the results.\",\n        \"virtual_table\": \"SELECT avg(Order_Quantity) FROM Invoices WHERE payment_method_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the minimum, average, and maximum quantities of products ordered as recorded in the 'Invoices' table. The placeholders in the SELECT statement represent the aggregated values of the order quantities.\",\n        \"virtual_table\": \"SELECT min(Order_Quantity) ,  avg(Order_Quantity) ,  max(Order_Quantity) FROM INVOICES\"\n    }\n}\n"}
{"sample_id": "train.5127", "db_id": "cre_Drama_Workshop_Groups", "question": "Give me the descriptions of the service types that cost more than 100.", "rationale": ["Identify the relevant tables: Ref_Service_Types for service type descriptions and Services for product prices.", "Join the Ref_Service_Types table with the Services table on the Service_Type_Code to link service descriptions with their corresponding prices.", "Filter the results to include only those services where the Product_Price is greater than 100.", "Construct the SQL query using the identified tables, join condition, and filter condition."], "gold_sql": "SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Price  >  100", "source_tables": ["services", "ref_service_types"], "pred_sql": "SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code = T2.Service_Type_Code WHERE T2.Product_Price > 100", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of service type descriptions from the 'Ref_Service_Types' table that are associated with services having a product price greater than a specified amount. The placeholder in the WHERE clause represents the minimum product price to filter the results.\",\n        \"virtual_table\": \"SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Price  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5134", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the names of workshop groups in which services with product name \"film\" are performed?", "rationale": ["Identify the relevant tables: 'Drama_Workshop_Groups' for workshop group names and 'Services' for product names.", "Determine the relationship between the tables: 'Drama_Workshop_Groups' is linked to 'Services' through 'Workshop_Group_ID'.", "Formulate the SQL query to select the 'Store_Name' from 'Drama_Workshop_Groups'.", "Add a JOIN clause to connect 'Drama_Workshop_Groups' with 'Services' on 'Workshop_Group_ID'.", "Include a WHERE clause to filter services where the 'Product_Name' is 'film'."], "gold_sql": "SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T2.Product_Name  =  'film'", "source_tables": ["services", "drama_workshop_groups"], "pred_sql": "SELECT DWG.Store_Name \nFROM Drama_Workshop_Groups AS DWG \nJOIN Services AS S ON DWG.Workshop_Group_ID = S.Workshop_Group_ID \nWHERE S.Product_Name = 'film';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the phone numbers and email addresses of stores associated with specific drama workshop groups. The data is retrieved by joining the 'Drama_Workshop_Groups' table with the 'Services' table based on the workshop group identifier, allowing for the extraction of relevant contact information for each store linked to the workshop groups.\",\n        \"virtual_table\": \"SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the phone numbers and email addresses of stores associated with specific drama workshop groups. The data is retrieved by joining the 'Drama_Workshop_Groups' table with the 'Services' table based on the workshop group identifier, allowing for the extraction of relevant contact information for each store linked to the workshop groups.\",\n        \"virtual_table\": \"SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID\"\n    }\n}\n"}
{"sample_id": "train.5142", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the order details of the products with price higher than 2000?", "rationale": ["Identify the relevant table for order details, which is the 'Invoices' table.", "Determine the necessary columns to retrieve: Order_ID, Order_Quantity, and Product_ID from the 'Invoices' table.", "Filter the products based on the price condition (greater than 2000) by using a subquery on the 'Products' table.", "The subquery selects Product_IDs from the 'Products' table where Product_Price is greater than 2000.", "Combine the main query and subquery to get the order details for products that meet the price condition."], "gold_sql": "SELECT T1.Other_Item_Details FROM ORDER_ITEMS AS T1 JOIN Products AS T2 ON T1.Product_ID  =  T2.Product_ID WHERE T2.Product_price  >  2000", "source_tables": ["products", "order_items"], "pred_sql": "SELECT Order_ID, Order_Quantity, Product_ID FROM Invoices WHERE Product_ID IN (SELECT Product_ID FROM Products WHERE Product_Price > 2000)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of service type descriptions from the 'Ref_Service_Types' table that are associated with services having a product price greater than a specified amount. The placeholder in the WHERE clause represents the minimum product price to filter the results.\",\n        \"virtual_table\": \"SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Price  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the minimum, average, and maximum quantities of products ordered as recorded in the 'Invoices' table. The placeholders in the SELECT statement represent the aggregated values of the order quantities.\",\n        \"virtual_table\": \"SELECT min(Order_Quantity) ,  avg(Order_Quantity) ,  max(Order_Quantity) FROM INVOICES\"\n    }\n}\n"}
{"sample_id": "train.5143", "db_id": "cre_Drama_Workshop_Groups", "question": "Find the order detail for the products with price above 2000.", "rationale": ["Identify the relevant tables: We need to retrieve order details and product information, so we will use the 'Order_Items' and 'Products' tables.", "Determine the columns to select: We want to include order item ID, order ID, product ID, order quantity, product name, and product price.", "Establish the join condition: We need to join 'Order_Items' with 'Products' on the 'Product_ID' column to get product details for each order item.", "Add the filtering condition: We need to filter the results to include only those products with a price greater than 2000."], "gold_sql": "SELECT T1.Other_Item_Details FROM ORDER_ITEMS AS T1 JOIN Products AS T2 ON T1.Product_ID  =  T2.Product_ID WHERE T2.Product_price  >  2000", "source_tables": ["products", "order_items"], "pred_sql": "SELECT Order_Items.Order_Item_ID, Order_Items.Order_ID, Order_Items.Product_ID, Order_Items.Order_Quantity, Products.Product_Name, Products.Product_Price \nFROM Order_Items \nJOIN Products ON Order_Items.Product_ID = Products.Product_ID \nWHERE Products.Product_Price > 2000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of service type descriptions from the 'Ref_Service_Types' table that are associated with services having a product price greater than a specified amount. The placeholder in the WHERE clause represents the minimum product price to filter the results.\",\n        \"virtual_table\": \"SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Price  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5160", "db_id": "cre_Drama_Workshop_Groups", "question": "What is the most frequent status of bookings?", "rationale": ["Identify the relevant table: The question pertains to bookings, so we will use the 'Bookings' table.", "Determine the required information: We need to find the most frequent status of bookings, which means we need to count occurrences of each status code.", "Use the COUNT function: We will count how many times each 'Status_Code' appears in the 'Bookings' table.", "Group the results: We will group the results by 'Status_Code' to aggregate the counts for each status.", "Order the results: To find the most frequent status, we will order the results in descending order based on the count.", "Limit the results: Since we only want the most frequent status, we will limit the results to 1."], "gold_sql": "SELECT Status_Code FROM BOOKINGS GROUP BY Status_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["bookings"], "pred_sql": "SELECT Status_Code, COUNT(*) as Frequency\nFROM Bookings\nGROUP BY Status_Code\nORDER BY Frequency DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5161", "db_id": "cre_Drama_Workshop_Groups", "question": "Which status code is the most common of all the bookings?", "rationale": ["Identify the relevant table: The question pertains to bookings, so we will use the 'Bookings' table.", "Determine the required information: We need to find the most common status code, which implies counting occurrences of each status code.", "Use the COUNT function: We will count how many times each status code appears in the 'Bookings' table.", "Group the results: We will group the results by 'Status_Code' to aggregate the counts for each unique status code.", "Order the results: To find the most common status code, we will order the results in descending order based on the count.", "Limit the results: Since we only want the most common status code, we will limit the results to 1."], "gold_sql": "SELECT Status_Code FROM BOOKINGS GROUP BY Status_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["bookings"], "pred_sql": "SELECT Status_Code, COUNT(*) as Count\nFROM Bookings\nGROUP BY Status_Code\nORDER BY Count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5162", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the names of the workshop groups that have bookings with status code \"stop\"?", "rationale": ["Identify the relevant tables: 'Drama_Workshop_Groups' for workshop group names and 'Bookings' for booking status.", "Join the 'Drama_Workshop_Groups' table with the 'Bookings' table on the 'Workshop_Group_ID' to link workshop groups with their bookings.", "Filter the results to include only those bookings where the status code is 'stop'.", "Select the 'Store_Name' from the 'Drama_Workshop_Groups' table as the final output."], "gold_sql": "SELECT T2.Store_Name FROM Bookings AS T1 JOIN Drama_Workshop_Groups AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T1.Status_Code  =  'stop'", "source_tables": ["drama_workshop_groups", "bookings"], "pred_sql": "SELECT DWG.Store_Name \nFROM Drama_Workshop_Groups AS DWG \nJOIN Bookings AS B ON DWG.Workshop_Group_ID = B.Workshop_Group_ID \nWHERE B.Status_Code = 'stop';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the phone numbers and email addresses of stores associated with specific drama workshop groups. The data is retrieved by joining the 'Drama_Workshop_Groups' table with the 'Services' table based on the workshop group identifier, allowing for the extraction of relevant contact information for each store linked to the workshop groups.\",\n        \"virtual_table\": \"SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the phone numbers and email addresses of stores associated with specific drama workshop groups. The data is retrieved by joining the 'Drama_Workshop_Groups' table with the 'Services' table based on the workshop group identifier, allowing for the extraction of relevant contact information for each store linked to the workshop groups.\",\n        \"virtual_table\": \"SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID\"\n    }\n}\n"}
{"sample_id": "train.5171", "db_id": "cre_Drama_Workshop_Groups", "question": "Give me the description of the service type that offers not only the photo product but also the film product.", "rationale": ["Identify the relevant tables: Ref_Service_Types for service descriptions, Services for linking services to products, and Products for product names.", "Join Ref_Service_Types with Services to get the service type descriptions associated with each service.", "Join Services with Order_Items to link services to their respective products.", "Use a subquery to filter products that are both 'photo' and 'film'. This subquery counts distinct product names and ensures both are present.", "Select distinct service type descriptions that meet the criteria."], "gold_sql": "SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  'photo' INTERSECT SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  'film'", "source_tables": ["services", "ref_service_types"], "pred_sql": "SELECT DISTINCT T1.Service_Type_Description \nFROM Ref_Service_Types AS T1 \nJOIN Services AS T2 ON T1.Service_Type_Code = T2.Service_Type_Code \nJOIN Order_Items AS T3 ON T2.Product_ID = T3.Product_ID \nWHERE T3.Product_ID IN (\n    SELECT Product_ID FROM Products WHERE Product_Name IN ('photo', 'film')\n    GROUP BY Product_ID\n    HAVING COUNT(DISTINCT Product_Name) = 2\n);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of service type descriptions from the 'Ref_Service_Types' table that are associated with services having a product price greater than a specified amount. The placeholder in the WHERE clause represents the minimum product price to filter the results.\",\n        \"virtual_table\": \"SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Price  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the phone numbers and email addresses of stores associated with specific drama workshop groups. The data is retrieved by joining the 'Drama_Workshop_Groups' table with the 'Services' table based on the workshop group identifier, allowing for the extraction of relevant contact information for each store linked to the workshop groups.\",\n        \"virtual_table\": \"SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the phone numbers and email addresses of stores associated with specific drama workshop groups. The data is retrieved by joining the 'Drama_Workshop_Groups' table with the 'Services' table based on the workshop group identifier, allowing for the extraction of relevant contact information for each store linked to the workshop groups.\",\n        \"virtual_table\": \"SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID\"\n    }\n}\n"}
{"sample_id": "train.5459", "db_id": "voter_2", "question": "Find the average age of female students.", "rationale": ["Identify the table that contains the relevant data: the 'Student' table has the 'Age' and 'Sex' columns.", "To find the average age of female students, we need to filter the records where 'Sex' is 'Female'.", "Use the AVG() function to calculate the average of the 'Age' column for the filtered records.", "Construct the SQL query using SELECT to retrieve the average age, applying the WHERE clause for filtering."], "gold_sql": "SELECT avg(Age) FROM STUDENT WHERE Sex  =  'F'", "source_tables": ["student"], "pred_sql": "SELECT AVG(Age) AS Average_Age FROM Student WHERE Sex = 'Female';", "hint": "\n"}
{"sample_id": "train.5466", "db_id": "voter_2", "question": "What are the distinct president votes on 08/30/2015?", "rationale": ["Identify the relevant table for the query, which is 'Voting_record' since we are interested in president votes.", "We need to select distinct values of the 'President_Vote' column.", "We need to filter the records based on the 'Registration_Date' to only include those from '08/30/2015'.", "The date format in SQL should be 'YYYY-MM-DD', so '08/30/2015' will be converted to '2015-08-30'.", "Construct the SQL query using SELECT DISTINCT, specifying the column and the WHERE clause for the date."], "gold_sql": "SELECT DISTINCT PRESIDENT_Vote FROM VOTING_RECORD WHERE Registration_Date  =  '08/30/2015'", "source_tables": ["voting_record"], "pred_sql": "SELECT DISTINCT President_Vote FROM Voting_record WHERE Registration_Date = '2015-08-30'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the distinct first names of students who have voted for the class senator. The query joins the 'Student' table with the 'Voting_record' table based on the student identifier, ensuring that only those students who participated in the voting for class senator are included.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.CLASS_Senator_VOTE\"\n    }\n}\n"}
{"sample_id": "train.5467", "db_id": "voter_2", "question": "Show all the distinct president votes made on 08/30/2015.", "rationale": ["Identify the relevant table: We need to look at the Voting_record table since we are interested in the president votes.", "Select distinct values: We want to show all distinct president votes, so we will use the DISTINCT keyword.", "Filter by date: We need to filter the records to only include those registered on '08/30/2015'.", "Construct the SQL query: Combine all the elements into a complete SQL query."], "gold_sql": "SELECT DISTINCT PRESIDENT_Vote FROM VOTING_RECORD WHERE Registration_Date  =  '08/30/2015'", "source_tables": ["voting_record"], "pred_sql": "SELECT DISTINCT President_Vote FROM Voting_record WHERE Registration_Date = '08/30/2015'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the distinct first names of students who have voted for the class senator. The query joins the 'Student' table with the 'Voting_record' table based on the student identifier, ensuring that only those students who participated in the voting for class senator are included.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.CLASS_Senator_VOTE\"\n    }\n}\n"}
{"sample_id": "train.5476", "db_id": "voter_2", "question": "Find the distinct ages of students who have secretary votes in the fall election cycle.", "rationale": ["Identify the relevant tables: 'Student' and 'Voting_record'.", "We need to find distinct ages of students, so we will select the 'Age' column from the 'Student' table.", "To find students who have voted for secretary, we will join the 'Student' table with the 'Voting_record' table on the 'StuID'.", "We need to filter the results to include only those records where the 'Election_Cycle' is 'fall' and where there is a vote recorded for the secretary (i.e., 'Secretary_Vote' is not null).", "Use DISTINCT to ensure that we only get unique ages."], "gold_sql": "SELECT DISTINCT T1.Age FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Secretary_Vote WHERE T2.Election_Cycle  =  'Fall'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT S.Age \nFROM Student AS S \nJOIN Voting_record AS V ON S.StuID = V.StuID \nWHERE V.Election_Cycle = 'fall' AND V.Secretary_Vote IS NOT NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the distinct first names of students who have voted for the class senator. The query joins the 'Student' table with the 'Voting_record' table based on the student identifier, ensuring that only those students who participated in the voting for class senator are included.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.CLASS_Senator_VOTE\"\n    }\n}\n"}
{"sample_id": "train.5479", "db_id": "voter_2", "question": "Who served as an advisor for students who have treasurer votes in the spring election cycle?", "rationale": ["Identify the relevant tables: 'Student' and 'Voting_record'.", "We need to find advisors for students who have voted for treasurer, so we will join these two tables on the StuID.", "We will filter the results to include only those records where the Treasurer_Vote is not null, indicating that the student voted.", "Additionally, we will filter for the specific election cycle, which is 'spring'.", "Finally, we will select distinct advisors to avoid duplicates in the results."], "gold_sql": "SELECT DISTINCT T1.Advisor FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Treasurer_Vote WHERE T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT S.Advisor \nFROM Student AS S \nJOIN Voting_record AS V ON S.StuID = V.StuID \nWHERE V.Treasurer_Vote IS NOT NULL \nAND V.Election_Cycle = 'spring';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the distinct first names of students who have voted for the class senator. The query joins the 'Student' table with the 'Voting_record' table based on the student identifier, ensuring that only those students who participated in the voting for class senator are included.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.CLASS_Senator_VOTE\"\n    }\n}\n"}
{"sample_id": "train.5486", "db_id": "voter_2", "question": "How many male (sex is M) students have class senator votes in the fall election cycle?", "rationale": ["Identify the tables involved: We need to use the 'Student' table and the 'Voting_record' table.", "Determine the relationship: We will join the 'Student' table with the 'Voting_record' table on the StuID, which is common in both tables.", "Filter for male students: We need to add a condition to filter students where Sex is 'M'.", "Focus on class senator votes: We will specifically look for records in the Voting_record where Class_Senator_Vote corresponds to the students.", "Specify the election cycle: We need to ensure that we are only counting votes from the fall election cycle.", "Count the results: Finally, we will count the number of records that meet all these criteria."], "gold_sql": "SELECT count(*) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  Class_Senator_Vote WHERE T1.Sex  =  'M' AND T2.Election_Cycle  =  'Fall'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT COUNT(*) FROM Student AS S JOIN Voting_record AS V ON S.StuID = V.Class_Senator_Vote WHERE S.Sex = 'M' AND V.Election_Cycle = 'fall';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the distinct first names of students who have voted for the class senator. The query joins the 'Student' table with the 'Voting_record' table based on the student identifier, ensuring that only those students who participated in the voting for class senator are included.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.CLASS_Senator_VOTE\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the field of study (Major) of students from the 'Student' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the students.\",\n        \"virtual_table\": \"SELECT Major FROM STUDENT WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5491", "db_id": "voter_2", "question": "What is the average age of students who have city code \"NYC\" and have secretary votes for the spring election cycle?", "rationale": ["Identify the tables involved: We need data from the 'Student' table for student details and the 'Voting_record' table for voting details.", "Determine the conditions: We are looking for students with a city code of 'NYC' and who have cast a vote for the secretary in the spring election cycle.", "Join the tables: We will join the 'Student' table and the 'Voting_record' table on the StuID to correlate students with their voting records.", "Select the average age: We will use the AVG function to calculate the average age of the filtered students."], "gold_sql": "SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.city_code  =  'NYC' AND T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT AVG(Age) FROM Student AS S JOIN Voting_record AS V ON S.StuID = V.StuID WHERE S.city_code = 'NYC' AND V.Secretary_Vote IS NOT NULL AND V.Election_Cycle = 'spring';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the distinct first names of students who have voted for the class senator. The query joins the 'Student' table with the 'Voting_record' table based on the student identifier, ensuring that only those students who participated in the voting for class senator are included.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.CLASS_Senator_VOTE\"\n    }\n}\n"}
{"sample_id": "train.5492", "db_id": "voter_2", "question": "Find the average age of female (sex is F) students who have secretary votes in the spring election cycle.", "rationale": ["Identify the tables involved: We need to use the 'Student' table to get the age and sex of students, and the 'Voting_record' table to check for secretary votes and the election cycle.", "Determine the conditions: We are looking for female students (Sex = 'F') who have voted in the spring election cycle and have a non-null value for Secretary_Vote.", "Join the tables: We will join the 'Student' table with the 'Voting_record' table on the StuID to correlate students with their voting records.", "Calculate the average age: We will use the AVG function on the Age column, ensuring to cast it to an integer since it is stored as text."], "gold_sql": "SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.Sex  =  'F' AND T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT AVG(CAST(Age AS INTEGER)) AS Average_Age \nFROM Student AS S \nJOIN Voting_record AS V ON S.StuID = V.StuID \nWHERE S.Sex = 'F' \nAND V.Election_Cycle = 'spring' \nAND V.Secretary_Vote IS NOT NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the distinct first names of students who have voted for the class senator. The query joins the 'Student' table with the 'Voting_record' table based on the student identifier, ensuring that only those students who participated in the voting for class senator are included.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.CLASS_Senator_VOTE\"\n    }\n}\n"}
{"sample_id": "train.5494", "db_id": "voter_2", "question": "Find the distinct first names of all the students who have vice president votes and whose city code is not PIT.", "rationale": ["Identify the tables involved: 'Student' and 'Voting_record'.", "We need to find distinct first names of students, so we will use SELECT DISTINCT on the 'Fname' column from the 'Student' table.", "We need to join the 'Student' table with the 'Voting_record' table on the 'StuID' column to link students with their voting records.", "We need to filter for students who have cast a vote for vice president, which means we check if 'Vice_President_Vote' is not null.", "Additionally, we need to ensure that the city code of the student is not 'PIT', so we add a condition for 'city_code'.", "Combine all these elements into a complete SQL query."], "gold_sql": "SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_PRESIDENT_Vote EXCEPT SELECT DISTINCT Fname FROM STUDENT WHERE city_code  =  'PIT'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT S.Fname \nFROM Student AS S \nJOIN Voting_record AS V ON S.StuID = V.StuID \nWHERE V.Vice_President_Vote IS NOT NULL \nAND S.city_code != 'PIT';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the distinct first names of students who have voted for the class senator. The query joins the 'Student' table with the 'Voting_record' table based on the student identifier, ensuring that only those students who participated in the voting for class senator are included.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.CLASS_Senator_VOTE\"\n    }\n}\n"}
{"sample_id": "train.5495", "db_id": "voter_2", "question": "What are the distinct first names of the students who have vice president votes and reside in a city whose city code is not PIT?", "rationale": ["Identify the relevant tables: 'Student' and 'Voting_record'.", "We need to find distinct first names of students, so we will use SELECT DISTINCT on the 'Fname' column from the 'Student' table.", "We need to join the 'Student' table with the 'Voting_record' table based on the student identifier (StuID).", "The condition specifies that we are interested in students who have voted for the vice president, which corresponds to the 'Vice_President_Vote' column in the 'Voting_record' table.", "Additionally, we need to filter out students whose city code is 'PIT', so we will add a WHERE clause for that condition."], "gold_sql": "SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_PRESIDENT_Vote EXCEPT SELECT DISTINCT Fname FROM STUDENT WHERE city_code  =  'PIT'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT S.Fname FROM Student AS S JOIN Voting_record AS V ON S.StuID = V.Vice_President_Vote WHERE S.city_code != 'PIT'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the distinct first names of students who have voted for the class senator. The query joins the 'Student' table with the 'Voting_record' table based on the student identifier, ensuring that only those students who participated in the voting for class senator are included.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.CLASS_Senator_VOTE\"\n    }\n}\n"}
{"sample_id": "train.5496", "db_id": "voter_2", "question": "Find the distinct last names of all the students who have president votes and whose advisor is not 2192.", "rationale": ["Identify the tables involved: 'Student' and 'Voting_record'.", "We need to find distinct last names, so we will use SELECT DISTINCT on the 'LName' column from the 'Student' table.", "We need to join the 'Student' table with the 'Voting_record' table based on the student identifier, which is 'StuID'.", "We are interested in students who have cast a vote for president, so we will filter on the 'President_Vote' column in the 'Voting_record' table.", "Additionally, we need to ensure that the advisor is not equal to '2192', so we will add a WHERE clause for that condition."], "gold_sql": "SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote EXCEPT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  '2192'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT LName FROM Student JOIN Voting_record ON Student.StuID = Voting_record.President_Vote WHERE Advisor != '2192';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the distinct first names of students who have voted for the class senator. The query joins the 'Student' table with the 'Voting_record' table based on the student identifier, ensuring that only those students who participated in the voting for class senator are included.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.CLASS_Senator_VOTE\"\n    }\n}\n"}
{"sample_id": "train.5499", "db_id": "voter_2", "question": "What are the distinct last names of the students who have president votes and have 8741 as the advisor?", "rationale": ["Identify the relevant tables: We need to look at the 'Student' table for last names and the 'Voting_record' table for president votes.", "Determine the condition for president votes: We need to find students who have cast a vote for president, which means we will check for non-null values in the 'President_Vote' column.", "Filter by advisor: We need to include only those students whose advisor is '8741'.", "Combine the conditions: We will use a subquery to find the student IDs from the 'Voting_record' table where there are president votes and then filter the 'Student' table based on these IDs and the advisor condition.", "Select distinct last names: Finally, we will select distinct last names from the filtered results."], "gold_sql": "SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote INTERSECT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  '8741'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT LName FROM Student WHERE StuID IN (SELECT StuID FROM Voting_record WHERE President_Vote IS NOT NULL) AND Advisor = '8741';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the distinct first names of students who have voted for the class senator. The query joins the 'Student' table with the 'Voting_record' table based on the student identifier, ensuring that only those students who participated in the voting for class senator are included.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.CLASS_Senator_VOTE\"\n    }\n}\n"}
{"sample_id": "train.5510", "db_id": "voter_2", "question": "What is the most common major among female (sex is F) students?", "rationale": ["Identify the relevant table: The 'Student' table contains information about students, including their major and gender.", "Filter for female students: We need to filter the records where the 'Sex' column is 'F'.", "Group by major: To find the most common major, we will group the results by the 'Major' column.", "Count occurrences: We will count the number of students in each major using COUNT(*).", "Order by count: To find the most common major, we will order the results in descending order based on the count of students in each major.", "Limit the results: Since we only want the most common major, we will limit the results to 1."], "gold_sql": "SELECT Major FROM STUDENT WHERE Sex  =  'F' GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Major, COUNT(*) as MajorCount \nFROM Student \nWHERE Sex = 'F' \nGROUP BY Major \nORDER BY MajorCount DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the field of study (Major) of students from the 'Student' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the students.\",\n        \"virtual_table\": \"SELECT Major FROM STUDENT WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5511", "db_id": "voter_2", "question": "Find the major that is studied by the most female students.", "rationale": ["We need to find the major studied by the most female students.", "To do this, we will select the 'Major' from the 'Student' table where the 'Sex' is 'Female'.", "We will count the number of female students for each major using COUNT(*) and alias it as 'Female_Count'.", "To get the major with the most female students, we will group the results by 'Major'.", "Finally, we will order the results in descending order based on 'Female_Count' and limit the output to 1 to get the major with the highest count."], "gold_sql": "SELECT Major FROM STUDENT WHERE Sex  =  'F' GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Major, COUNT(*) as Female_Count \nFROM Student \nWHERE Sex = 'Female' \nGROUP BY Major \nORDER BY Female_Count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the field of study (Major) of students from the 'Student' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the students.\",\n        \"virtual_table\": \"SELECT Major FROM STUDENT WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5534", "db_id": "products_gen_characteristics", "question": "Find the number of products with category \"Spices\" and typically sold above 1000.", "rationale": ["Identify the relevant tables: Products and Ref_Product_Categories.", "Determine the relationship between the tables: Products has a foreign key product_category_code that links to Ref_Product_Categories.", "We need to filter products based on the category description 'Spices' and a selling price greater than 1000.", "Use COUNT(*) to get the number of products that meet these criteria.", "Construct the SQL query using JOIN to combine the two tables and apply the WHERE clause for filtering."], "gold_sql": "SELECT count(*) FROM products WHERE product_category_code  =  'Spices' AND typical_buying_price  >  1000", "source_tables": ["products"], "pred_sql": "SELECT COUNT(*) AS product_count\nFROM Products p\nJOIN Ref_Product_Categories c ON p.product_category_code = c.product_category_code\nWHERE c.product_category_description = 'Spices' AND p.typical_selling_price > 1000;", "hint": "\n"}
{"sample_id": "train.5543", "db_id": "products_gen_characteristics", "question": "What are the descriptions of the categories that products with product descriptions that contain the letter t are in?", "rationale": ["Identify the tables involved: We need to get product category descriptions from the Ref_Product_Categories table and filter products based on their descriptions from the Products table.", "Determine the relationship: The Products table is linked to the Ref_Product_Categories table through the product_category_code.", "Formulate the SQL query: We will select the product_category_description from Ref_Product_Categories and join it with Products on product_category_code.", "Add the filtering condition: We need to filter products where the product_description contains the letter 't', which can be done using the LIKE operator with '%t%'."], "gold_sql": "SELECT T1.product_category_description FROM ref_product_categories AS T1 JOIN products AS T2 ON T1.product_category_code  =  T2.product_category_code WHERE T2.product_description LIKE '%t%'", "source_tables": ["products", "ref_product_categories"], "pred_sql": "SELECT T1.product_category_description FROM Ref_Product_Categories AS T1 JOIN Products AS T2 ON T1.product_category_code = T2.product_category_code WHERE T2.product_description LIKE '%t%'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the descriptions of product categories from the 'Ref_Product_Categories' table for products that have a specific description. The placeholder in the WHERE clause allows for filtering products based on their description.\",\n        \"virtual_table\": \"SELECT T1.product_category_description FROM ref_product_categories AS T1 JOIN products AS T2 ON T1.product_category_code  =  T2.product_category_code WHERE T2.product_description LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5556", "db_id": "products_gen_characteristics", "question": "How many distinct characteristic names does the product \"cumin\" have?", "rationale": ["Identify the product 'cumin' in the Products table.", "Join the Products table with the Product_Characteristics table to link products with their characteristics.", "Join the resulting table with the Characteristics table to access characteristic names.", "Use COUNT(DISTINCT characteristic_name) to count unique characteristic names for the product 'cumin'.", "Filter the results to only include the product where product_name is 'cumin'."], "gold_sql": "SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  'sesame'", "source_tables": ["products", "characteristics", "product_characteristics"], "pred_sql": "SELECT COUNT(DISTINCT c.characteristic_name) \nFROM Products p \nJOIN Product_Characteristics pc ON p.product_id = pc.product_id \nJOIN Characteristics c ON pc.characteristic_id = c.characteristic_id \nWHERE p.product_name = 'cumin';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the distinct names of characteristics from the 'Characteristics' table. This allows users to retrieve unique characteristic names without duplicates.\",\n        \"virtual_table\": \"SELECT DISTINCT characteristic_name FROM CHARACTERISTICS\"\n    }\n}\n"}
{"sample_id": "train.5577", "db_id": "products_gen_characteristics", "question": "How many products have their color described as 'white' or have a characteristic with the name 'hot'?", "rationale": ["Identify the tables involved: Products, Ref_Colors, Product_Characteristics, and Characteristics.", "We need to count the number of products that either have a color described as 'white' or have a characteristic with the name 'hot'.", "Join the Products table with the Ref_Colors table to filter by color description.", "Join the Products table with the Product_Characteristics table to access the characteristics of each product.", "Join the Product_Characteristics table with the Characteristics table to filter by characteristic name.", "Use a WHERE clause to specify the conditions for color description and characteristic name.", "Use COUNT(DISTINCT p.product_id) to ensure we count each product only once, regardless of how many characteristics it has."], "gold_sql": "SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  'white' OR t3.characteristic_name  =  'hot'", "source_tables": ["products", "ref_colors", "characteristics", "product_characteristics"], "pred_sql": "SELECT COUNT(DISTINCT p.product_id) \nFROM Products p \nLEFT JOIN Ref_Colors c ON p.color_code = c.color_code \nLEFT JOIN Product_Characteristics pc ON p.product_id = pc.product_id \nLEFT JOIN Characteristics ch ON pc.characteristic_id = ch.characteristic_id \nWHERE c.color_description = 'white' OR ch.characteristic_name = 'hot';", "hint": "\n"}
{"sample_id": "train.5579", "db_id": "products_gen_characteristics", "question": "Return the unit of measure for 'Herb' products.", "rationale": ["Identify the relevant tables: We need to get the unit of measure for 'Herb' products, which involves the Products and Ref_Product_Categories tables.", "Determine the relationship: The Products table has a foreign key that links to the Ref_Product_Categories table through the product_category_code.", "Formulate the query: We will select the unit_of_measure from Ref_Product_Categories, joining it with Products on product_category_code.", "Add the condition: We need to filter the products to only those whose name contains 'Herb', using a LIKE clause."], "gold_sql": "SELECT unit_of_measure FROM ref_product_categories WHERE product_category_code  =  'Herbs'", "source_tables": ["ref_product_categories"], "pred_sql": "SELECT Ref_Product_Categories.unit_of_measure \nFROM Products \nJOIN Ref_Product_Categories ON Products.product_category_code = Ref_Product_Categories.product_category_code \nWHERE Products.product_name LIKE '%Herb%';", "hint": "\n"}
{"sample_id": "train.5586", "db_id": "products_gen_characteristics", "question": "Find the unit of measurement and product category code of product named \"chervil\".", "rationale": ["Identify the tables involved: We need to get the unit of measurement and product category code, which are in the 'Ref_Product_Categories' table, and we need to filter based on the product name from the 'Products' table.", "Determine the relationship between tables: The 'Ref_Product_Categories' table is linked to the 'Products' table through the 'product_category_code'.", "Use the provided hint: The hint gives a template for selecting product category descriptions based on product descriptions. We will modify this to select the unit of measure and product category code instead.", "Construct the SQL query: We will select 'unit_of_measure' and 'product_category_code' from 'Ref_Product_Categories', joining it with 'Products' on 'product_category_code', and filter where 'product_name' is 'chervil'."], "gold_sql": "SELECT t2.unit_of_measure ,  t2.product_category_code FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code WHERE t1.product_name  =  'chervil'", "source_tables": ["products", "ref_product_categories"], "pred_sql": "SELECT T1.unit_of_measure, T1.product_category_code FROM ref_product_categories AS T1 JOIN products AS T2 ON T1.product_category_code = T2.product_category_code WHERE T2.product_name = 'chervil'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the descriptions of product categories from the 'Ref_Product_Categories' table for products that have a specific description. The placeholder in the WHERE clause allows for filtering products based on their description.\",\n        \"virtual_table\": \"SELECT T1.product_category_description FROM ref_product_categories AS T1 JOIN products AS T2 ON T1.product_category_code  =  T2.product_category_code WHERE T2.product_description LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5590", "db_id": "products_gen_characteristics", "question": "What is the description of the color for most products?", "rationale": ["We need to find the description of the color for most products.", "To do this, we will join the 'Ref_Colors' table with the 'Products' table on the 'color_code'.", "We will count the number of products for each color description using COUNT(P.product_id).", "We will group the results by color description to aggregate the counts.", "To find the color with the most products, we will order the results in descending order by the count of products.", "Finally, we will limit the results to 1 to get only the top color description."], "gold_sql": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) DESC LIMIT 1", "source_tables": ["products", "ref_colors"], "pred_sql": "SELECT R.color_description, COUNT(P.product_id) AS product_count \nFROM Ref_Colors AS R \nJOIN Products AS P ON R.color_code = P.color_code \nGROUP BY R.color_description \nORDER BY product_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the descriptions of product categories from the 'Ref_Product_Categories' table for products that have a specific description. The placeholder in the WHERE clause allows for filtering products based on their description.\",\n        \"virtual_table\": \"SELECT T1.product_category_description FROM ref_product_categories AS T1 JOIN products AS T2 ON T1.product_category_code  =  T2.product_category_code WHERE T2.product_description LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5592", "db_id": "products_gen_characteristics", "question": "What is the description of the color used by least products?", "rationale": ["We need to find the color description used by the least number of products.", "To do this, we will join the Ref_Colors table with the Products table on the color_code.", "We will group the results by color_code to count how many products are associated with each color.", "Next, we will order the results by the count of products in ascending order to get the color with the least products first.", "Finally, we will limit the results to 1 to get only the top result, which is the color used by the least products."], "gold_sql": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) ASC LIMIT 1", "source_tables": ["products", "ref_colors"], "pred_sql": "SELECT R.color_description FROM Ref_Colors AS R JOIN Products AS P ON R.color_code = P.color_code GROUP BY R.color_code ORDER BY COUNT(P.product_id) ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the descriptions of product categories from the 'Ref_Product_Categories' table for products that have a specific description. The placeholder in the WHERE clause allows for filtering products based on their description.\",\n        \"virtual_table\": \"SELECT T1.product_category_description FROM ref_product_categories AS T1 JOIN products AS T2 ON T1.product_category_code  =  T2.product_category_code WHERE T2.product_description LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5599", "db_id": "products_gen_characteristics", "question": "Give the names of characteristics that are in two or more products?", "rationale": ["We need to find the names of characteristics that are associated with two or more products.", "To do this, we will first identify the characteristic IDs that are linked to two or more products. This can be achieved by grouping the 'Product_Characteristics' table by 'characteristic_id' and counting the distinct 'product_id'.", "We will use the HAVING clause to filter these groups to only include those with a count of 2 or more.", "Once we have the relevant characteristic IDs, we can then select the corresponding characteristic names from the 'Characteristics' table using these IDs."], "gold_sql": "SELECT t3.characteristic_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id GROUP BY t3.characteristic_name HAVING count(*)  >= 2", "source_tables": ["products", "characteristics", "product_characteristics"], "pred_sql": "SELECT characteristic_name FROM Characteristics WHERE characteristic_id IN (SELECT characteristic_id FROM Product_Characteristics GROUP BY characteristic_id HAVING COUNT(DISTINCT product_id) >= 2)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the distinct names of characteristics from the 'Characteristics' table. This allows users to retrieve unique characteristic names without duplicates.\",\n        \"virtual_table\": \"SELECT DISTINCT characteristic_name FROM CHARACTERISTICS\"\n    }\n}\n"}
{"sample_id": "train.5633", "db_id": "railway", "question": "List the builders of railways in ascending alphabetical order.", "rationale": ["Identify the relevant table: The 'railway' table contains the 'Builder' column which we need to query.", "Select the 'Builder' column: We want to list the builders, so we will select this column.", "Use DISTINCT to avoid duplicate entries: Since multiple railways can have the same builder, we will use DISTINCT to ensure each builder is listed only once.", "Order the results: We need the results in ascending alphabetical order, so we will use ORDER BY Builder ASC.", "Construct the SQL query: Combine all these elements into a complete SQL query."], "gold_sql": "SELECT Builder FROM railway ORDER BY Builder ASC", "source_tables": ["railway"], "pred_sql": "SELECT DISTINCT Builder FROM railway ORDER BY Builder ASC;", "hint": "\n"}
{"sample_id": "train.5643", "db_id": "railway", "question": "Show the id and builder of the railway that are associated with the most trains.", "rationale": ["Identify the relevant tables: 'railway' and 'train'.", "We need to find the railway associated with the most trains, so we will join the 'railway' table with the 'train' table on 'Railway_ID'.", "We will group the results by 'Railway_ID' and 'Builder' to count the number of trains associated with each railway.", "Use COUNT(train.Train_ID) to count the number of trains for each railway.", "Order the results in descending order based on the count of trains to get the railway with the most trains at the top.", "Limit the results to 1 to get only the railway associated with the most trains."], "gold_sql": "SELECT T2.Railway_ID ,  T1.Builder FROM railway AS T1 JOIN train AS T2 ON T1.Railway_ID  =  T2.Railway_ID GROUP BY T2.Railway_ID ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["train", "railway"], "pred_sql": "SELECT railway.Railway_ID, railway.Builder \nFROM railway \nJOIN train ON railway.Railway_ID = train.Railway_ID \nGROUP BY railway.Railway_ID, railway.Builder \nORDER BY COUNT(train.Train_ID) DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5645", "db_id": "railway", "question": "Show the most common builder of railways.", "rationale": ["Identify the relevant table: The 'railway' table contains the 'Builder' column which we need to analyze.", "Count the occurrences of each builder: We will use the COUNT() function to count how many railways each builder has constructed.", "Group the results by builder: We will use GROUP BY to aggregate the results based on the 'Builder' column.", "Order the results: To find the most common builder, we will order the results in descending order based on the count of railways.", "Limit the results to one: Since we only want the most common builder, we will use LIMIT 1 to get the top result."], "gold_sql": "SELECT Builder FROM railway GROUP BY Builder ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["railway"], "pred_sql": "SELECT Builder, COUNT(*) as Count FROM railway GROUP BY Builder ORDER BY Count DESC LIMIT 1;", "hint": "\n"}
{"sample_id": "train.5707", "db_id": "dorm_1", "question": "What is the last name of every student who is either female or living in a city with the code BAL or male and under 20?", "rationale": ["Identify the columns needed: We need the last names of students, so we will select 'LName' from the 'Student' table.", "Determine the conditions: We need students who are either female, live in a city with the code 'BAL', or are male and under 20 years old.", "Construct the WHERE clause: The conditions can be combined using OR. The first condition checks if the student is female, the second checks if the city code is 'BAL', and the third checks if the student is male and under 20.", "Combine the SELECT statement with the WHERE clause to form the complete SQL query."], "gold_sql": "SELECT lname FROM student WHERE sex  =  'F' AND city_code  =  'BAL' UNION SELECT lname FROM student WHERE sex  =  'M' AND age  <  20", "source_tables": ["student"], "pred_sql": "SELECT LName FROM Student WHERE (Sex = 'Female') OR (city_code = 'BAL') OR (Sex = 'Male' AND Age < '20');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of dormitories from the 'Dorm' table that are designated for a specific gender. The placeholder in the WHERE clause represents the gender designation for the dormitory.\",\n        \"virtual_table\": \"SELECT dorm_name FROM dorm WHERE gender  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5738", "db_id": "dorm_1", "question": "Find the number of amenities for each of the dorms that can accommodate more than 100 students.", "rationale": ["Identify the relevant tables: We need to use the Dorm table to filter dorms based on their capacity and the Has_amenity table to count the amenities.", "Join the Dorm and Has_amenity tables: We will join these tables on the dormid to link each dorm with its amenities.", "Filter dorms with a capacity greater than 100: We will add a WHERE clause to only include dorms that can accommodate more than 100 students.", "Count the amenities: We will use COUNT() to count the number of amenities associated with each dorm.", "Group the results: We will group the results by dormid and dorm_name to get the count of amenities for each dorm."], "gold_sql": "SELECT count(*) ,  T1.dormid FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid WHERE T1.student_capacity  >  100 GROUP BY T1.dormid", "source_tables": ["has_amenity", "dorm"], "pred_sql": "SELECT d.dorm_name, COUNT(ha.amenid) AS number_of_amenities\nFROM Dorm d\nJOIN Has_amenity ha ON d.dormid = ha.dormid\nWHERE d.student_capacity > 100\nGROUP BY d.dormid, d.dorm_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the average and total student capacity of dormitories filtered by a specific gender designation. The placeholder in the WHERE clause represents the gender of the dormitory.\",\n        \"virtual_table\": \"SELECT avg(student_capacity) ,  sum(student_capacity) FROM dorm WHERE gender  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of dormitories from the 'Dorm' table that are designated for a specific gender. The placeholder in the WHERE clause represents the gender designation for the dormitory.\",\n        \"virtual_table\": \"SELECT dorm_name FROM dorm WHERE gender  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5747", "db_id": "dorm_1", "question": "What are the total number of students who are living in a male dorm?", "rationale": ["The question asks for the total number of students living in a male dormitory.", "To find this, we need to count the number of students in the 'Lives_in' table.", "We will join the 'Lives_in' table with the 'Dorm' table on the dormid to access the gender information of the dorms.", "We will filter the results to only include dorms where the gender is 'male'.", "Finally, we will use COUNT to get the total number of students in these male dorms."], "gold_sql": "SELECT count(*) FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T3.gender  =  'M'", "source_tables": ["student", "lives_in", "dorm"], "pred_sql": "SELECT COUNT(Lives_in.stuid) AS total_students\nFROM Lives_in\nJOIN Dorm ON Lives_in.dormid = Dorm.dormid\nWHERE Dorm.gender = 'male';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the average and total student capacity of dormitories filtered by a specific gender designation. The placeholder in the WHERE clause represents the gender of the dormitory.\",\n        \"virtual_table\": \"SELECT avg(student_capacity) ,  sum(student_capacity) FROM dorm WHERE gender  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of dormitories from the 'Dorm' table that are designated for a specific gender. The placeholder in the WHERE clause represents the gender designation for the dormitory.\",\n        \"virtual_table\": \"SELECT dorm_name FROM dorm WHERE gender  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5756", "db_id": "dorm_1", "question": "Find the first name of students who are living in the dorm that has most number of amenities.", "rationale": ["Identify the dormitory with the most amenities by counting the number of amenities for each dormitory using the Has_amenity table.", "Use a subquery to select the dormid from the Has_amenity table, grouping by dormid and ordering by the count of amenid in descending order, limiting the result to the top one.", "Next, find the students who live in that dormitory by using the Lives_in table to match the dormid from the previous step.", "Finally, select the first names of those students from the Student table using their StuID."], "gold_sql": "SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["has_amenity", "lives_in", "student", "dorm_amenity", "dorm"], "pred_sql": "SELECT Fname FROM Student WHERE StuID IN (SELECT stuid FROM Lives_in WHERE dormid IN (SELECT dormid FROM Has_amenity GROUP BY dormid ORDER BY COUNT(amenid) DESC LIMIT 1));", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the average and total student capacity of dormitories filtered by a specific gender designation. The placeholder in the WHERE clause represents the gender of the dormitory.\",\n        \"virtual_table\": \"SELECT avg(student_capacity) ,  sum(student_capacity) FROM dorm WHERE gender  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of dormitories from the 'Dorm' table that are designated for a specific gender. The placeholder in the WHERE clause represents the gender designation for the dormitory.\",\n        \"virtual_table\": \"SELECT dorm_name FROM dorm WHERE gender  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5765", "db_id": "dorm_1", "question": "What is the first name and age of every student who lives in a dorm with a TV Lounge?", "rationale": ["Identify the required fields: first name (Fname) and age (Age) of students.", "Determine the relationships between tables: Students live in dorms, and dorms have amenities.", "Use JOIN clauses to connect the Student table with Lives_in, Dorm, Has_amenity, and Dorm_amenity tables based on their relationships.", "Filter the results to include only those dorms that have a 'TV Lounge' amenity by using a WHERE clause."], "gold_sql": "SELECT T1.fname ,  T1.age FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid NOT IN (SELECT T3.dormid FROM has_amenity AS T3 JOIN dorm_amenity AS T4 ON T3.amenid  =  T4.amenid WHERE T4.amenity_name  =  'TV Lounge')", "source_tables": ["has_amenity", "student", "lives_in", "dorm_amenity"], "pred_sql": "SELECT Fname, Age \nFROM Student \nJOIN Lives_in ON Student.StuID = Lives_in.stuid \nJOIN Dorm ON Lives_in.dormid = Dorm.dormid \nJOIN Has_amenity ON Dorm.dormid = Has_amenity.dormid \nJOIN Dorm_amenity ON Has_amenity.amenid = Dorm_amenity.amenid \nWHERE Dorm_amenity.amenity_name = 'TV Lounge';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of dormitories from the 'Dorm' table that are designated for a specific gender. The placeholder in the WHERE clause represents the gender designation for the dormitory.\",\n        \"virtual_table\": \"SELECT dorm_name FROM dorm WHERE gender  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the average and total student capacity of dormitories filtered by a specific gender designation. The placeholder in the WHERE clause represents the gender of the dormitory.\",\n        \"virtual_table\": \"SELECT avg(student_capacity) ,  sum(student_capacity) FROM dorm WHERE gender  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5777", "db_id": "customer_complaints", "question": "What are the emails of customers who have filed complaints on the product which has had the greatest number of complaints?", "rationale": ["Identify the main goal: Retrieve the emails of customers who filed complaints on the product with the greatest number of complaints.", "To find the product with the greatest number of complaints, we need to group the complaints by product_id and count them, ordering by this count in descending order.", "We will use a subquery to get the product_id that has the highest count of complaints.", "Next, we will join the Customers table with the Complaints table to get the email addresses of customers who filed complaints for that specific product.", "Finally, we will select the email_address from the Customers table where the customer_id matches those in the Complaints table for the identified product."], "gold_sql": "SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "customers"], "pred_sql": "SELECT c.email_address \nFROM Customers AS c \nJOIN Complaints AS comp ON c.customer_id = comp.customer_id \nWHERE comp.product_id = (\n    SELECT product_id \n    FROM Complaints \n    GROUP BY product_id \n    ORDER BY COUNT(*) DESC \n    LIMIT 1\n)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of last names of staff members who are handling complaints related to products, ordered by the price of those products. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the last names of staff members who are handling complaints, ordered by the date the complaints were raised. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id ORDER BY t2.date_complaint_raised LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5778", "db_id": "customer_complaints", "question": "Which products has been complained by the customer who has filed least amount of complaints?", "rationale": ["Identify the products that have been complained about by customers.", "To find the customer who has filed the least amount of complaints, we need to group the complaints by customer_id and count them.", "We will order the results by the count of complaints in ascending order and limit the results to 1 to get the customer with the least complaints.", "Using the customer_id from the previous step, we will join the Complaints table with the Products table to get the product names that correspond to the complaints made by that customer."], "gold_sql": "SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "products", "customers"], "pred_sql": "SELECT p.product_name \nFROM Products p \nJOIN Complaints c ON p.product_id = c.product_id \nWHERE c.customer_id = (\n    SELECT customer_id \n    FROM Complaints \n    GROUP BY customer_id \n    ORDER BY COUNT(complaint_id) ASC \n    LIMIT 1\n)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of last names of staff members who are handling complaints related to products, ordered by the price of those products. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the last names of staff members who are handling complaints, ordered by the date the complaints were raised. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id ORDER BY t2.date_complaint_raised LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5795", "db_id": "customer_complaints", "question": "What is the last name of the staff member in charge of the complaint on the product with the lowest price?", "rationale": ["Identify the relevant tables: Staff, Complaints, and Products.", "We need to find the last name of the staff member handling a complaint related to the product with the lowest price.", "Join the Staff table with the Complaints table on staff_id to link staff members to their complaints.", "Join the Complaints table with the Products table on product_id to link complaints to the products.", "Order the results by product price in ascending order to get the product with the lowest price at the top.", "Limit the results to 1 to get only the last name of the staff member handling that complaint."], "gold_sql": "SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT 1", "source_tables": ["complaints", "products", "staff"], "pred_sql": "SELECT t1.last_name FROM Staff AS t1 JOIN Complaints AS t2 ON t1.staff_id = t2.staff_id JOIN Products AS t3 ON t2.product_id = t3.product_id ORDER BY t3.product_price LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of last names of staff members who are handling complaints related to products, ordered by the price of those products. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the last names of staff members who are handling complaints, ordered by the date the complaints were raised. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id ORDER BY t2.date_complaint_raised LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5796", "db_id": "customer_complaints", "question": "Which complaint status has more than 3 records on file?", "rationale": ["Identify the table that contains the complaint status, which is the 'Complaints' table.", "We need to count the number of records for each complaint status, so we will use the COUNT() function.", "To group the results by complaint status, we will use the GROUP BY clause on 'complaint_status_code'.", "To filter the results to only include statuses with more than 3 records, we will use the HAVING clause with COUNT(*) > 3."], "gold_sql": "SELECT complaint_status_code FROM complaints GROUP BY complaint_status_code HAVING count(*)  >  3", "source_tables": ["complaints"], "pred_sql": "SELECT complaint_status_code, COUNT(*) as record_count \nFROM Complaints \nGROUP BY complaint_status_code \nHAVING COUNT(*) > 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the last names of staff members who are handling complaints, ordered by the date the complaints were raised. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id ORDER BY t2.date_complaint_raised LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of last names of staff members who are handling complaints related to products, ordered by the price of those products. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5801", "db_id": "customer_complaints", "question": "Count the number of customers that have the customer type that is most common.", "rationale": ["Identify the table that contains customer information, which is the 'Customers' table.", "To find the most common customer type, we need to group the customers by 'customer_type_code' and count how many customers belong to each type.", "We will order the results by the count in descending order to get the most common type at the top.", "We will limit the results to 1 to get only the most common customer type code.", "Finally, we will count the number of customers that have this most common customer type code."], "gold_sql": "SELECT count(*) FROM customers GROUP BY customer_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers"], "pred_sql": "SELECT COUNT(*) AS customer_count\nFROM Customers\nWHERE customer_type_code = (\n    SELECT customer_type_code\n    FROM Customers\n    GROUP BY customer_type_code\n    ORDER BY COUNT(*) DESC\n    LIMIT 1\n);", "hint": "\n"}
{"sample_id": "train.5810", "db_id": "customer_complaints", "question": "What is first names of the top 5 staff who have handled the greatest number of complaints?", "rationale": ["Identify the relevant tables: Staff and Complaints.", "We need to find the first names of staff members, so we will select 'first_name' from the Staff table.", "To determine how many complaints each staff member has handled, we will join the Staff table with the Complaints table on 'staff_id'.", "We will group the results by 'staff_id' to aggregate the number of complaints handled by each staff member.", "We will use COUNT() to count the number of complaints for each staff member.", "To get the top 5 staff members who handled the most complaints, we will order the results in descending order based on the count of complaints and limit the results to 5."], "gold_sql": "SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT 5", "source_tables": ["complaints", "staff"], "pred_sql": "SELECT first_name FROM Staff AS t1 JOIN Complaints AS t2 ON t1.staff_id = t2.staff_id GROUP BY t1.staff_id ORDER BY COUNT(t2.complaint_id) DESC LIMIT 5;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the last names of staff members who are handling complaints, ordered by the date the complaints were raised. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id ORDER BY t2.date_complaint_raised LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of last names of staff members who are handling complaints related to products, ordered by the price of those products. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5811", "db_id": "customer_complaints", "question": "Return the first names of the 5 staff members who have handled the most complaints.", "rationale": ["We need to return the first names of staff members who have handled the most complaints.", "To achieve this, we will join the Staff table with the Complaints table on the staff_id column.", "We will group the results by staff_id to aggregate the number of complaints handled by each staff member.", "Next, we will order the results in descending order based on the count of complaints (using COUNT(t2.complaint_id)).", "Finally, we will limit the results to the top 5 staff members with the most complaints."], "gold_sql": "SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT 5", "source_tables": ["complaints", "staff"], "pred_sql": "SELECT t1.first_name FROM Staff AS t1 JOIN Complaints AS t2 ON t1.staff_id = t2.staff_id GROUP BY t1.staff_id ORDER BY COUNT(t2.complaint_id) DESC LIMIT 5;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the last names of staff members who are handling complaints, ordered by the date the complaints were raised. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id ORDER BY t2.date_complaint_raised LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of last names of staff members who are handling complaints related to products, ordered by the price of those products. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5845", "db_id": "tracking_share_transactions", "question": "Show all investor details.", "rationale": ["The user wants to see all investor details.", "To retrieve all details from the Investors table, we use the SELECT statement.", "Using '*' allows us to select all columns from the Investors table."], "gold_sql": "SELECT Investor_details FROM INVESTORS", "source_tables": ["investors"], "pred_sql": "SELECT * FROM Investors;", "hint": "\n"}
{"sample_id": "train.5858", "db_id": "tracking_share_transactions", "question": "Show details of all investors if they make any transaction with share count greater than 100.", "rationale": ["Identify the tables involved: Investors and Transactions.", "We need to show details of all investors, so we will select columns from the Investors table.", "We need to filter investors based on their transactions, specifically those with a share count greater than 100.", "To link the Investors table with the Transactions table, we will use a JOIN on the investor_id column.", "The WHERE clause will be used to filter transactions where share_count is greater than 100."], "gold_sql": "SELECT T1.Investor_details FROM  INVESTORS AS T1 JOIN TRANSACTIONS AS T2 ON T1.investor_id  =  T2.investor_id WHERE T2.share_count  >  100", "source_tables": ["transactions", "investors"], "pred_sql": "SELECT Investors.investor_id, Investors.Investor_details \nFROM Investors \nJOIN Transactions ON Investors.investor_id = Transactions.investor_id \nWHERE Transactions.share_count > 100;", "hint": "\n"}
{"sample_id": "train.5864", "db_id": "tracking_share_transactions", "question": "What are the lot details of lots associated with transactions with share count smaller than 50?", "rationale": ["We need to retrieve lot details from the Lots table.", "We will join the Lots table with the Transactions_Lots table to link lots with their corresponding transactions.", "Next, we will join the Transactions table to access the share count of each transaction.", "Finally, we will filter the results to include only those transactions where the share count is smaller than 50."], "gold_sql": "SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  <  50", "source_tables": ["lots", "transactions_lots", "transactions"], "pred_sql": "SELECT L.lot_details \nFROM Lots AS L \nJOIN Transactions_Lots AS TL ON L.lot_id = TL.lot_id \nJOIN Transactions AS T ON TL.transaction_id = T.transaction_id \nWHERE T.share_count < 50;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the details of lots from the 'Lots' table that are not associated with any transactions. The query uses an EXCEPT clause to filter out lot details that are linked to transactions through the 'Transactions_Lots' table.\",\n        \"virtual_table\": \"SELECT lot_details FROM Lots EXCEPT SELECT T1.lot_details FROM Lots AS T1 JOIN transactions_lots AS T2 ON T1.lot_id  =  T2.lot_id\"\n    }\n}\n"}
{"sample_id": "train.5866", "db_id": "tracking_share_transactions", "question": "Show the average transaction amount for different transaction types.", "rationale": ["Identify the tables involved: We need data from the Transactions table for transaction amounts and the Ref_Transaction_Types table for transaction descriptions.", "Determine the relationship between the tables: The Transactions table has a foreign key that links to the Ref_Transaction_Types table via transaction_type_code.", "Select the necessary columns: We need the transaction type description and the average of the transaction amounts.", "Use the AVG() function to calculate the average transaction amount for each transaction type.", "Group the results by transaction type description to get the average for each type."], "gold_sql": "SELECT transaction_type_code ,  avg(amount_of_transaction) FROM TRANSACTIONS GROUP BY transaction_type_code", "source_tables": ["transactions"], "pred_sql": "SELECT rt.transaction_type_description, AVG(t.amount_of_transaction) AS average_transaction_amount\nFROM Transactions t\nJOIN Ref_Transaction_Types rt ON t.transaction_type_code = rt.transaction_type_code\nGROUP BY rt.transaction_type_description;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates of transactions from the 'Transactions' table that correspond to a specific type of transaction. The placeholder in the WHERE clause represents the transaction type code.\",\n        \"virtual_table\": \"SELECT date_of_transaction FROM TRANSACTIONS WHERE transaction_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5867", "db_id": "tracking_share_transactions", "question": "Show the maximum and minimum share count of different transaction types.", "rationale": ["Identify the relevant tables: We need to use the Transactions table for share counts and the Ref_Transaction_Types table for transaction type descriptions.", "Join the Transactions table with the Ref_Transaction_Types table on the transaction_type_code to get descriptions of each transaction type.", "Use aggregate functions MAX() and MIN() to find the maximum and minimum share counts for each transaction type.", "Group the results by transaction type description to get the desired output for each type."], "gold_sql": "SELECT transaction_type_code ,  max(share_count) ,  min(share_count) FROM TRANSACTIONS GROUP BY transaction_type_code", "source_tables": ["transactions"], "pred_sql": "SELECT rt.transaction_type_description, MAX(t.share_count) AS max_share_count, MIN(t.share_count) AS min_share_count\nFROM Transactions t\nJOIN Ref_Transaction_Types rt ON t.transaction_type_code = rt.transaction_type_code\nGROUP BY rt.transaction_type_description;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates of transactions from the 'Transactions' table that correspond to a specific type of transaction. The placeholder in the WHERE clause represents the transaction type code.\",\n        \"virtual_table\": \"SELECT date_of_transaction FROM TRANSACTIONS WHERE transaction_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5883", "db_id": "tracking_share_transactions", "question": "What are the details of all sales and purchases?", "rationale": ["Identify the tables needed: Sales and Purchases.", "Determine the columns to select: sales_details from Sales and purchase_details from Purchases.", "Since we want details from both tables, a FULL OUTER JOIN is appropriate to include all records from both tables, even if there are no matches.", "Construct the SQL query using the selected columns and the join condition."], "gold_sql": "SELECT sales_details FROM sales UNION SELECT purchase_details FROM purchases", "source_tables": ["sales", "purchases"], "pred_sql": "SELECT Sales.sales_details, Purchases.purchase_details \nFROM Sales \nFULL OUTER JOIN Purchases ON Sales.sales_transaction_id = Purchases.purchase_transaction_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the details of lots from the 'Lots' table that are not associated with any transactions. The query uses an EXCEPT clause to filter out lot details that are linked to transactions through the 'Transactions_Lots' table.\",\n        \"virtual_table\": \"SELECT lot_details FROM Lots EXCEPT SELECT T1.lot_details FROM Lots AS T1 JOIN transactions_lots AS T2 ON T1.lot_id  =  T2.lot_id\"\n    }\n}\n"}
{"sample_id": "train.5898", "db_id": "cre_Theme_park", "question": "What is the average price range of five star hotels that allow pets?", "rationale": ["Identify the relevant table: The Hotels table contains information about hotel star ratings, price ranges, and pet policies.", "Determine the criteria for filtering: We need to filter for five-star hotels (star_rating_code = '5') and those that allow pets (pets_allowed_yn = 'Yes').", "Use the AVG function to calculate the average price range of the filtered hotels.", "Construct the SQL query using the SELECT statement to retrieve the average price range from the Hotels table with the specified conditions."], "gold_sql": "SELECT avg(price_range) FROM HOTELS WHERE star_rating_code  =  '5' AND pets_allowed_yn  =  1", "source_tables": ["hotels"], "pred_sql": "SELECT AVG(price_range) AS average_price_range \nFROM Hotels \nWHERE star_rating_code = '5' AND pets_allowed_yn = 'Yes';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the descriptions of star ratings for hotels that fall within a specified price range. The placeholder in the WHERE clause represents the price range threshold for filtering the hotels.\",\n        \"virtual_table\": \"SELECT T2.star_rating_description FROM HOTELS AS T1 JOIN Ref_Hotel_Star_Ratings AS T2 ON T1.star_rating_code  =  T2.star_rating_code WHERE T1.price_range  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table provides the price range of hotels from the 'Hotels' table. The placeholder in the SELECT statement allows for filtering based on specific criteria if needed.\",\n        \"virtual_table\": \"SELECT price_range FROM HOTELS\"\n    },\n    \"2\": {\n        \"description\": \"The virtual table provides the price range of hotels from the 'Hotels' table. The placeholder in the SELECT statement allows for the specification of different hotel records based on the user's needs.\",\n        \"virtual_table\": \"SELECT price_range FROM HOTELS\"\n    }\n}\n"}
{"sample_id": "train.5904", "db_id": "cre_Theme_park", "question": "Find all the locations whose names contain the word \"film\".", "rationale": ["Identify the table that contains location names, which is the 'Locations' table.", "Determine the column that holds the names of the locations, which is 'Location_Name'.", "Use the SQL LIKE operator to filter for names containing the word 'film'.", "Construct the SQL query to select the relevant columns from the 'Locations' table where 'Location_Name' matches the criteria."], "gold_sql": "SELECT Location_Name FROM LOCATIONS WHERE Location_Name LIKE '%film%'", "source_tables": ["locations"], "pred_sql": "SELECT Location_Name, Address, Other_Details FROM Locations WHERE Location_Name LIKE '%film%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the details of shops associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.\",\n        \"virtual_table\": \"SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5915", "db_id": "cre_Theme_park", "question": "What are the details and opening hours of the museums?", "rationale": ["Identify the relevant tables: Museums and Tourist_Attractions.", "Determine the columns needed: Museum_Details from Museums and Opening_Hours from Tourist_Attractions.", "Establish the relationship between the tables: Museums are linked to Tourist_Attractions via Museum_ID and Tourist_Attraction_ID.", "Construct the SQL query to select the required details from both tables using a JOIN."], "gold_sql": "SELECT T1.Museum_Details ,  T2.Opening_Hours FROM MUSEUMS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Museum_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["tourist_attractions", "museums"], "pred_sql": "SELECT M.Museum_Details, T.Opening_Hours FROM Museums AS M JOIN Tourist_Attractions AS T ON M.Museum_ID = T.Tourist_Attraction_ID", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the details of shops associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.\",\n        \"virtual_table\": \"SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides details about royal families and the instructions on how to reach the associated tourist attractions. The data is retrieved by joining the 'Royal_Family' table with the 'Tourist_Attractions' table based on the unique identifier for the royal family that corresponds to the tourist attraction.\",\n        \"virtual_table\": \"SELECT T1.Royal_Family_Details ,  T2.How_to_Get_There FROM ROYAL_FAMILY AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Royal_Family_ID  =  T2.Tourist_Attraction_ID\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides details about tourists from the 'Visitors' table. The placeholder in the SELECT clause represents the specific details related to each tourist.\",\n        \"virtual_table\": \"SELECT Tourist_Details FROM VISITORS\"\n    }\n}\n"}
{"sample_id": "train.5916", "db_id": "cre_Theme_park", "question": "Give me the detail and opening hour for each museum.", "rationale": ["Identify the relevant tables: Museums and Tourist_Attractions.", "Determine the required fields: Museum_Details from Museums and Opening_Hours from Tourist_Attractions.", "Establish the relationship between the tables: Museums are linked to Tourist_Attractions through the Museum_ID and Tourist_Attraction_ID.", "Construct the SQL query to select the desired fields from the joined tables."], "gold_sql": "SELECT T1.Museum_Details ,  T2.Opening_Hours FROM MUSEUMS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Museum_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["tourist_attractions", "museums"], "pred_sql": "SELECT M.Museum_Details, T.Opening_Hours \nFROM Museums AS M \nJOIN Tourist_Attractions AS T ON M.Museum_ID = T.Tourist_Attraction_ID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the details of shops associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.\",\n        \"virtual_table\": \"SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides details about tourists from the 'Visitors' table. The placeholder in the SELECT clause represents the specific details related to each tourist.\",\n        \"virtual_table\": \"SELECT Tourist_Details FROM VISITORS\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides details about tourists from the 'Visitors' table. The placeholder in the SELECT clause represents the specific details related to each tourist.\",\n        \"virtual_table\": \"SELECT Tourist_Details FROM VISITORS\"\n    }\n}\n"}
{"sample_id": "train.5922", "db_id": "cre_Theme_park", "question": "Which tourist attractions are related to royal family? Tell me their details and how we can get there.", "rationale": ["Identify the relevant tables: Royal_Family and Tourist_Attractions.", "Determine the relationship between the tables: Royal_Family_ID in Royal_Family corresponds to Tourist_Attraction_ID in Tourist_Attractions.", "Select the desired columns: Royal_Family_Details from Royal_Family and How_to_Get_There from Tourist_Attractions.", "Construct the SQL query using a JOIN to combine the two tables based on their relationship."], "gold_sql": "SELECT T1.Royal_Family_Details ,  T2.How_to_Get_There FROM ROYAL_FAMILY AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Royal_Family_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["royal_family", "tourist_attractions"], "pred_sql": "SELECT T1.Royal_Family_Details, T2.How_to_Get_There FROM Royal_Family AS T1 JOIN Tourist_Attractions AS T2 ON T1.Royal_Family_ID = T2.Tourist_Attraction_ID", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides details about royal families and the instructions on how to reach the associated tourist attractions. The data is retrieved by joining the 'Royal_Family' table with the 'Tourist_Attractions' table based on the unique identifier for the royal family that corresponds to the tourist attraction.\",\n        \"virtual_table\": \"SELECT T1.Royal_Family_Details ,  T2.How_to_Get_There FROM ROYAL_FAMILY AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Royal_Family_ID  =  T2.Tourist_Attraction_ID\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the details of shops associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.\",\n        \"virtual_table\": \"SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides details about tourists from the 'Visitors' table. The placeholder in the SELECT clause represents the specific details related to each tourist.\",\n        \"virtual_table\": \"SELECT Tourist_Details FROM VISITORS\"\n    }\n}\n"}
{"sample_id": "train.5923", "db_id": "cre_Theme_park", "question": "What are the details of the shops that can be accessed by walk?", "rationale": ["Identify the relevant tables: Shops and Tourist_Attractions.", "Determine the relationship between the tables: Shops are linked to Tourist Attractions via the Shop_ID and Tourist_Attraction_ID.", "Use a JOIN clause to combine the Shops and Tourist_Attractions tables based on the Shop_ID and Tourist_Attraction_ID.", "Filter the results based on the condition that the How_to_Get_There field in the Tourist_Attractions table equals 'walk'.", "Construct the SQL query using the identified fields and conditions."], "gold_sql": "SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  'walk'", "source_tables": ["shops", "tourist_attractions"], "pred_sql": "SELECT T1.Shop_Details FROM Shops AS T1 JOIN Tourist_Attractions AS T2 ON T1.Shop_ID = T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There = 'walk'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the details of shops associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.\",\n        \"virtual_table\": \"SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5931", "db_id": "cre_Theme_park", "question": "Which tourist attractions does the visitor with detail 'Vincent' visit?", "rationale": ["Identify the relevant tables: We need to find tourist attractions visited by a specific visitor, so we will use the Visits, Visitors, and Tourist_Attractions tables.", "Join the Visits table with the Visitors table to filter visits by the tourist with details 'Vincent'.", "Join the resulting table with the Tourist_Attractions table to get the names of the attractions visited by this tourist.", "Use a WHERE clause to specify that we are only interested in records where the Tourist_Details in the Visitors table matches 'Vincent'.", "Select the Name of the tourist attractions from the final joined result."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID JOIN VISITORS AS T3 ON T2.Tourist_ID  =  T3.Tourist_ID WHERE T3.Tourist_Details  =  'Vincent'", "source_tables": ["visits", "visitors", "tourist_attractions"], "pred_sql": "SELECT T2.Name FROM Visits AS T1 JOIN Visitors AS T3 ON T1.Tourist_ID = T3.Tourist_ID JOIN Tourist_Attractions AS T2 ON T1.Tourist_Attraction_ID = T2.Tourist_Attraction_ID WHERE T3.Tourist_Details = 'Vincent'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the details of shops associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.\",\n        \"virtual_table\": \"SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides details about tourists from the 'Visitors' table. The placeholder in the SELECT clause represents the specific details related to each tourist.\",\n        \"virtual_table\": \"SELECT Tourist_Details FROM VISITORS\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides details about tourists from the 'Visitors' table. The placeholder in the SELECT clause represents the specific details related to each tourist.\",\n        \"virtual_table\": \"SELECT Tourist_Details FROM VISITORS\"\n    }\n}\n"}
{"sample_id": "train.5932", "db_id": "cre_Theme_park", "question": "Show the tourist attractions visited by the tourist whose detail is 'Vincent'.", "rationale": ["Identify the relevant tables: Tourist_Attractions, Visits, and Visitors.", "We need to join these tables to get the tourist attractions visited by a specific tourist.", "The Visitors table contains the tourist details, which we will filter by 'Vincent'.", "The Visits table links tourists to the attractions they visited.", "We will select the Name, Description, and Opening Hours of the tourist attractions that match the specified tourist detail."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID JOIN VISITORS AS T3 ON T2.Tourist_ID  =  T3.Tourist_ID WHERE T3.Tourist_Details  =  'Vincent'", "source_tables": ["visits", "visitors", "tourist_attractions"], "pred_sql": "SELECT TA.Name, TA.Description, TA.Opening_Hours \nFROM Tourist_Attractions AS TA \nJOIN Visits AS V ON TA.Tourist_Attraction_ID = V.Tourist_Attraction_ID \nJOIN Visitors AS T ON V.Tourist_ID = T.Tourist_ID \nWHERE T.Tourist_Details = 'Vincent';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides details about tourists from the 'Visitors' table. The placeholder in the SELECT clause represents the specific details related to each tourist.\",\n        \"virtual_table\": \"SELECT Tourist_Details FROM VISITORS\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides details about tourists from the 'Visitors' table. The placeholder in the SELECT clause represents the specific details related to each tourist.\",\n        \"virtual_table\": \"SELECT Tourist_Details FROM VISITORS\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the details of shops associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.\",\n        \"virtual_table\": \"SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5941", "db_id": "cre_Theme_park", "question": "Show the details of the top 3 most expensive hotels.", "rationale": ["Identify the Hotels table as it contains the details of hotels including their price range.", "To find the most expensive hotels, we need to sort the hotels by their price range in descending order.", "We will limit the results to the top 3 hotels to get only the most expensive ones."], "gold_sql": "SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT 3", "source_tables": ["hotels"], "pred_sql": "SELECT * FROM Hotels ORDER BY price_range DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the descriptions of star ratings for hotels that fall within a specified price range. The placeholder in the WHERE clause represents the price range threshold for filtering the hotels.\",\n        \"virtual_table\": \"SELECT T2.star_rating_description FROM HOTELS AS T1 JOIN Ref_Hotel_Star_Ratings AS T2 ON T1.star_rating_code  =  T2.star_rating_code WHERE T1.price_range  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table provides the price range of hotels from the 'Hotels' table. The placeholder in the SELECT statement allows for filtering based on specific criteria if needed.\",\n        \"virtual_table\": \"SELECT price_range FROM HOTELS\"\n    },\n    \"2\": {\n        \"description\": \"The virtual table provides the price range of hotels from the 'Hotels' table. The placeholder in the SELECT statement allows for the specification of different hotel records based on the user's needs.\",\n        \"virtual_table\": \"SELECT price_range FROM HOTELS\"\n    }\n}\n"}
{"sample_id": "train.5942", "db_id": "cre_Theme_park", "question": "What are the details of the three most expensive hotels?", "rationale": ["Identify the table that contains hotel details, which is the 'Hotels' table.", "To find the most expensive hotels, we need to order the hotels by their price range in descending order.", "We will limit the results to the top three entries to get the three most expensive hotels."], "gold_sql": "SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT 3", "source_tables": ["hotels"], "pred_sql": "SELECT * FROM Hotels ORDER BY price_range DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the descriptions of star ratings for hotels that fall within a specified price range. The placeholder in the WHERE clause represents the price range threshold for filtering the hotels.\",\n        \"virtual_table\": \"SELECT T2.star_rating_description FROM HOTELS AS T1 JOIN Ref_Hotel_Star_Ratings AS T2 ON T1.star_rating_code  =  T2.star_rating_code WHERE T1.price_range  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table provides the price range of hotels from the 'Hotels' table. The placeholder in the SELECT statement allows for filtering based on specific criteria if needed.\",\n        \"virtual_table\": \"SELECT price_range FROM HOTELS\"\n    },\n    \"2\": {\n        \"description\": \"The virtual table provides the price range of hotels from the 'Hotels' table. The placeholder in the SELECT statement allows for the specification of different hotel records based on the user's needs.\",\n        \"virtual_table\": \"SELECT price_range FROM HOTELS\"\n    }\n}\n"}
{"sample_id": "train.5944", "db_id": "cre_Theme_park", "question": "What are the details and star ratings of the three hotels with the lowest price ranges?", "rationale": ["The user wants details and star ratings of hotels with the lowest price ranges.", "To get the details of the hotels, we need to select from the 'Hotels' table.", "We also need to join the 'Ref_Hotel_Star_Ratings' table to get the star rating descriptions for each hotel.", "We will order the results by the 'price_range' in ascending order to get the lowest price ranges first.", "Finally, we will limit the results to 3 to get only the three hotels with the lowest price ranges."], "gold_sql": "SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT 3", "source_tables": ["hotels"], "pred_sql": "SELECT H.hotel_id, H.other_hotel_details, R.star_rating_description \nFROM Hotels AS H \nJOIN Ref_Hotel_Star_Ratings AS R ON H.star_rating_code = R.star_rating_code \nORDER BY H.price_range ASC \nLIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the descriptions of star ratings for hotels that fall within a specified price range. The placeholder in the WHERE clause represents the price range threshold for filtering the hotels.\",\n        \"virtual_table\": \"SELECT T2.star_rating_description FROM HOTELS AS T1 JOIN Ref_Hotel_Star_Ratings AS T2 ON T1.star_rating_code  =  T2.star_rating_code WHERE T1.price_range  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table provides the price range of hotels from the 'Hotels' table. The placeholder in the SELECT statement allows for filtering based on specific criteria if needed.\",\n        \"virtual_table\": \"SELECT price_range FROM HOTELS\"\n    },\n    \"2\": {\n        \"description\": \"The virtual table provides the price range of hotels from the 'Hotels' table. The placeholder in the SELECT statement allows for the specification of different hotel records based on the user's needs.\",\n        \"virtual_table\": \"SELECT price_range FROM HOTELS\"\n    }\n}\n"}
{"sample_id": "train.5945", "db_id": "cre_Theme_park", "question": "Show the transportation method most people choose to get to tourist attractions.", "rationale": ["The question asks for the most popular transportation method to tourist attractions.", "To find this, we need to count the number of visits for each transportation method.", "We will join the 'Visits' table with the 'Tourist_Attractions' table to access the 'How_to_Get_There' column.", "We will group the results by 'How_to_Get_There' to count the number of visitors for each method.", "Finally, we will order the results in descending order and limit the output to 1 to get the most chosen method."], "gold_sql": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["tourist_attractions"], "pred_sql": "SELECT T2.How_to_Get_There, COUNT(*) AS Number_of_Visitors \nFROM Visits AS V \nJOIN Tourist_Attractions AS T2 ON V.Tourist_Attraction_ID = T2.Tourist_Attraction_ID \nGROUP BY T2.How_to_Get_There \nORDER BY Number_of_Visitors DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the details of shops associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.\",\n        \"virtual_table\": \"SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides details about tourists from the 'Visitors' table. The placeholder in the SELECT clause represents the specific details related to each tourist.\",\n        \"virtual_table\": \"SELECT Tourist_Details FROM VISITORS\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides details about tourists from the 'Visitors' table. The placeholder in the SELECT clause represents the specific details related to each tourist.\",\n        \"virtual_table\": \"SELECT Tourist_Details FROM VISITORS\"\n    }\n}\n"}
{"sample_id": "train.5946", "db_id": "cre_Theme_park", "question": "Which transportation method is used the most often to get to tourist attractions?", "rationale": ["Identify the relevant table: The question pertains to transportation methods used to reach tourist attractions, which is indicated by the 'How_to_Get_There' column in the 'Tourist_Attractions' table.", "Count the occurrences: We need to count how many times each transportation method appears, which can be done using the COUNT() function.", "Group by transportation method: To get the count for each method, we will use GROUP BY on the 'How_to_Get_There' column.", "Order by usage: To find the most frequently used method, we will order the results in descending order based on the count.", "Limit the results: Since we only want the most used method, we will limit the results to 1."], "gold_sql": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["tourist_attractions"], "pred_sql": "SELECT How_to_Get_There, COUNT(*) as usage_count \nFROM Tourist_Attractions \nGROUP BY How_to_Get_There \nORDER BY usage_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the details of shops associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.\",\n        \"virtual_table\": \"SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides details about tourists from the 'Visitors' table. The placeholder in the SELECT clause represents the specific details related to each tourist.\",\n        \"virtual_table\": \"SELECT Tourist_Details FROM VISITORS\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides details about tourists from the 'Visitors' table. The placeholder in the SELECT clause represents the specific details related to each tourist.\",\n        \"virtual_table\": \"SELECT Tourist_Details FROM VISITORS\"\n    }\n}\n"}
{"sample_id": "train.5955", "db_id": "cre_Theme_park", "question": "Show the names and ids of tourist attractions that are visited at most once.", "rationale": ["Identify the relevant table: We need to work with the Tourist_Attractions and Visits tables to find attractions that are visited at most once.", "Determine the criteria: We want to find attractions that have been visited at most once, which means we need to count the number of visits for each attraction.", "Use a subquery: We can use a subquery to count the number of visits for each Tourist_Attraction_ID in the Visits table and filter those that have a count greater than 1.", "Select the required fields: From the Tourist_Attractions table, we will select the Tourist_Attraction_ID and Name for those attractions that meet our criteria."], "gold_sql": "SELECT T1.Name ,  T1.Tourist_Attraction_ID FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID HAVING count(*)  <=  1", "source_tables": ["visits", "tourist_attractions"], "pred_sql": "SELECT Tourist_Attraction_ID, Name FROM Tourist_Attractions WHERE Tourist_Attraction_ID NOT IN (SELECT Tourist_Attraction_ID FROM Visits GROUP BY Tourist_Attraction_ID HAVING COUNT(Tourist_ID) > 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the details of shops associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.\",\n        \"virtual_table\": \"SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides details about tourists from the 'Visitors' table. The placeholder in the SELECT clause represents the specific details related to each tourist.\",\n        \"virtual_table\": \"SELECT Tourist_Details FROM VISITORS\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides details about tourists from the 'Visitors' table. The placeholder in the SELECT clause represents the specific details related to each tourist.\",\n        \"virtual_table\": \"SELECT Tourist_Details FROM VISITORS\"\n    }\n}\n"}
{"sample_id": "train.5956", "db_id": "cre_Theme_park", "question": "What are the names and ids of the tourist attractions that are visited at most once?", "rationale": ["Identify the relevant tables: Tourist_Attractions and Visits.", "We need to find tourist attractions that have been visited at most once, which means we need to count the number of visits for each attraction.", "Use a subquery to count the number of visits for each Tourist_Attraction_ID in the Visits table, grouping by Tourist_Attraction_ID.", "Filter the results in the main query to include only those Tourist_Attraction_IDs that do not appear in the subquery results (i.e., those that have been visited once or not at all).", "Select the Tourist_Attraction_ID and Name from the Tourist_Attractions table for the final output."], "gold_sql": "SELECT T1.Name ,  T1.Tourist_Attraction_ID FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID HAVING count(*)  <=  1", "source_tables": ["visits", "tourist_attractions"], "pred_sql": "SELECT Tourist_Attraction_ID, Name FROM Tourist_Attractions WHERE Tourist_Attraction_ID NOT IN (SELECT Tourist_Attraction_ID FROM Visits GROUP BY Tourist_Attraction_ID HAVING COUNT(Tourist_ID) > 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the details of shops associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.\",\n        \"virtual_table\": \"SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides details about royal families and the instructions on how to reach the associated tourist attractions. The data is retrieved by joining the 'Royal_Family' table with the 'Tourist_Attractions' table based on the unique identifier for the royal family that corresponds to the tourist attraction.\",\n        \"virtual_table\": \"SELECT T1.Royal_Family_Details ,  T2.How_to_Get_There FROM ROYAL_FAMILY AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Royal_Family_ID  =  T2.Tourist_Attraction_ID\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides details about tourists from the 'Visitors' table. The placeholder in the SELECT clause represents the specific details related to each tourist.\",\n        \"virtual_table\": \"SELECT Tourist_Details FROM VISITORS\"\n    }\n}\n"}
{"sample_id": "train.5959", "db_id": "cre_Theme_park", "question": "What are the names of the tourist attractions that have parking or shopping as their feature details?", "rationale": ["Identify the relevant tables: Tourist_Attractions, Tourist_Attraction_Features, and Features.", "We need to find the names of tourist attractions that have specific features (parking or shopping).", "Join the Tourist_Attractions table with the Tourist_Attraction_Features table to link attractions with their features.", "Then, join the resulting table with the Features table to access the feature details.", "Use a WHERE clause to filter the results for features that are either 'parking' or 'shopping'.", "Select the Name of the tourist attractions that meet these criteria."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'park' UNION SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'shopping'", "source_tables": ["features", "tourist_attractions", "tourist_attraction_features"], "pred_sql": "SELECT T.Name \nFROM Tourist_Attractions AS T \nJOIN Tourist_Attraction_Features AS F ON T.Tourist_Attraction_ID = F.Tourist_Attraction_ID \nJOIN Features AS D ON F.Feature_ID = D.Feature_ID \nWHERE D.Feature_Details IN ('parking', 'shopping');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the details of shops associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.\",\n        \"virtual_table\": \"SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides details about tourists from the 'Visitors' table. The placeholder in the SELECT clause represents the specific details related to each tourist.\",\n        \"virtual_table\": \"SELECT Tourist_Details FROM VISITORS\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides details about tourists from the 'Visitors' table. The placeholder in the SELECT clause represents the specific details related to each tourist.\",\n        \"virtual_table\": \"SELECT Tourist_Details FROM VISITORS\"\n    }\n}\n"}
{"sample_id": "train.5960", "db_id": "cre_Theme_park", "question": "Find the tourist attractions that have parking or shopping as their feature details. What are the names of the attractions?", "rationale": ["Identify the relevant tables: Tourist_Attractions, Tourist_Attraction_Features, and Features.", "We need to find the names of tourist attractions that have specific features (parking or shopping).", "Join the Tourist_Attractions table with the Tourist_Attraction_Features table on the Tourist_Attraction_ID.", "Then join the resulting table with the Features table on Feature_ID to access feature details.", "Use a WHERE clause to filter for features that are either 'parking' or 'shopping'.", "Select the Name of the tourist attractions that meet these criteria."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'park' UNION SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'shopping'", "source_tables": ["features", "tourist_attractions", "tourist_attraction_features"], "pred_sql": "SELECT T.Name \nFROM Tourist_Attractions AS T \nJOIN Tourist_Attraction_Features AS F ON T.Tourist_Attraction_ID = F.Tourist_Attraction_ID \nJOIN Features AS D ON F.Feature_ID = D.Feature_ID \nWHERE D.Feature_Details IN ('parking', 'shopping');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the details of shops associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.\",\n        \"virtual_table\": \"SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides details about tourists from the 'Visitors' table. The placeholder in the SELECT clause represents the specific details related to each tourist.\",\n        \"virtual_table\": \"SELECT Tourist_Details FROM VISITORS\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides details about tourists from the 'Visitors' table. The placeholder in the SELECT clause represents the specific details related to each tourist.\",\n        \"virtual_table\": \"SELECT Tourist_Details FROM VISITORS\"\n    }\n}\n"}
{"sample_id": "train.5963", "db_id": "cre_Theme_park", "question": "What are the names of the tourist attractions Vincent and Marcelle visit?", "rationale": ["Identify the relevant tables: We need to find tourist attractions visited by specific tourists, so we will use the 'Visits', 'Visitors', and 'Tourist_Attractions' tables.", "Join the 'Visits' table with the 'Visitors' table to filter visits by the names of the tourists (Vincent and Marcelle).", "Join the resulting table with the 'Tourist_Attractions' table to get the names of the attractions they visited.", "Use a WHERE clause to specify that we are only interested in visits made by Vincent and Marcelle."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  'Vincent' INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  'Marcelle'", "source_tables": ["visits", "visitors", "tourist_attractions"], "pred_sql": "SELECT T2.Name \nFROM Visits AS T1 \nJOIN Visitors AS T3 ON T1.Tourist_ID = T3.Tourist_ID \nJOIN Tourist_Attractions AS T2 ON T1.Tourist_Attraction_ID = T2.Tourist_Attraction_ID \nWHERE T3.Tourist_Details IN ('Vincent', 'Marcelle')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the details of shops associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.\",\n        \"virtual_table\": \"SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides details about royal families and the instructions on how to reach the associated tourist attractions. The data is retrieved by joining the 'Royal_Family' table with the 'Tourist_Attractions' table based on the unique identifier for the royal family that corresponds to the tourist attraction.\",\n        \"virtual_table\": \"SELECT T1.Royal_Family_Details ,  T2.How_to_Get_There FROM ROYAL_FAMILY AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Royal_Family_ID  =  T2.Tourist_Attraction_ID\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides details about tourists from the 'Visitors' table. The placeholder in the SELECT clause represents the specific details related to each tourist.\",\n        \"virtual_table\": \"SELECT Tourist_Details FROM VISITORS\"\n    }\n}\n"}
{"sample_id": "train.5985", "db_id": "game_1", "question": "Which game type has most number of games?", "rationale": ["The question asks for the game type with the most number of games.", "To find this, we need to count the number of games for each game type in the 'Video_Games' table.", "We can use the COUNT() function to count the number of games and GROUP BY to group the results by game type.", "We will then order the results in descending order based on the count of games.", "Finally, we will limit the results to 1 to get the game type with the highest count."], "gold_sql": "SELECT gtype FROM Video_games GROUP BY gtype ORDER BY count(*) DESC LIMIT 1", "source_tables": ["video_games"], "pred_sql": "SELECT GType, COUNT(*) as GameCount FROM Video_Games GROUP BY GType ORDER BY GameCount DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of video games from the 'Video_Games' table that belong to a specific genre. The placeholder in the WHERE clause represents the type of the video game.\",\n        \"virtual_table\": \"SELECT count(*) FROM Video_games WHERE gtype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of video games from the 'Video_Games' table that belong to a specific genre. The placeholder in the WHERE clause represents the type of the video game.\",\n        \"virtual_table\": \"SELECT gname FROM Video_games WHERE gtype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of video games from the 'Video_Games' table that belong to a specific genre. The placeholder in the WHERE clause represents the type of the video game.\",\n        \"virtual_table\": \"SELECT gname FROM Video_games WHERE gtype  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5988", "db_id": "game_1", "question": "What is the type with the fewest games?", "rationale": ["Identify the need to find the type of video game with the fewest games.", "Use the 'Video_Games' table which contains the 'GType' and 'GameID'.", "Group the results by 'GType' to count the number of games in each type.", "Order the grouped results in ascending order based on the count of games.", "Limit the results to 1 to get the type with the fewest games."], "gold_sql": "SELECT gtype FROM Video_games GROUP BY gtype ORDER BY count(*) LIMIT 1", "source_tables": ["video_games"], "pred_sql": "SELECT GType FROM Video_Games GROUP BY GType ORDER BY COUNT(*) ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of video games from the 'Video_Games' table that belong to a specific genre. The placeholder in the WHERE clause represents the type of the video game.\",\n        \"virtual_table\": \"SELECT count(*) FROM Video_games WHERE gtype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of video games from the 'Video_Games' table that belong to a specific genre. The placeholder in the WHERE clause represents the type of the video game.\",\n        \"virtual_table\": \"SELECT gname FROM Video_games WHERE gtype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of video games from the 'Video_Games' table that belong to a specific genre. The placeholder in the WHERE clause represents the type of the video game.\",\n        \"virtual_table\": \"SELECT gname FROM Video_games WHERE gtype  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6001", "db_id": "game_1", "question": "How many students play sports?", "rationale": ["The question asks for the number of students who play sports.", "To find this, we need to count the entries in the SportsInfo table, as it contains records of students participating in sports.", "We can use the COUNT() function to get the total number of rows in the SportsInfo table, which corresponds to the number of students playing sports."], "gold_sql": "SELECT count(DISTINCT StuID) FROM Sportsinfo", "source_tables": ["sportsinfo"], "pred_sql": "SELECT COUNT(*) FROM SportsInfo;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the last names of students from the 'Student' table who are participating in sports and are on a sports scholarship. The placeholder in the WHERE clause represents the scholarship status.\",\n        \"virtual_table\": \"SELECT T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T1.onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6003", "db_id": "game_1", "question": "List ids for all student who are on scholarship.", "rationale": ["Identify the relevant tables: SportsInfo and Student.", "We need to find students who are on a sports scholarship, which is indicated in the SportsInfo table under the column 'OnScholarship'.", "Join the SportsInfo table with the Student table on the StuID column to get the student details.", "Select the StuID from the joined tables where OnScholarship is 'Yes'."], "gold_sql": "SELECT StuID FROM Sportsinfo WHERE onscholarship  =  'Y'", "source_tables": ["sportsinfo"], "pred_sql": "SELECT T2.StuID FROM SportsInfo AS T1 JOIN Student AS T2 ON T1.StuID = T2.StuID WHERE T1.OnScholarship = 'Yes'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the last names of students from the 'Student' table who are participating in sports and are on a sports scholarship. The placeholder in the WHERE clause represents the scholarship status.\",\n        \"virtual_table\": \"SELECT T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T1.onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6004", "db_id": "game_1", "question": "What are the ids for all sporty students who are on scholarship?", "rationale": ["Identify the relevant tables: SportsInfo for sports participation and Student for student details.", "We need to find students who are on a sports scholarship, so we will filter the SportsInfo table where OnScholarship is 'yes'.", "We will join the SportsInfo table with the Student table on the StuID to get the student IDs of those who are on scholarship.", "Select the StuID from the joined tables where the scholarship condition is met."], "gold_sql": "SELECT StuID FROM Sportsinfo WHERE onscholarship  =  'Y'", "source_tables": ["sportsinfo"], "pred_sql": "SELECT T1.StuID FROM SportsInfo AS T1 JOIN Student AS T2 ON T1.StuID = T2.StuID WHERE T1.OnScholarship = 'yes'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the last names of students from the 'Student' table who are participating in sports and are on a sports scholarship. The placeholder in the WHERE clause represents the scholarship status.\",\n        \"virtual_table\": \"SELECT T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T1.onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6006", "db_id": "game_1", "question": "What are the last names for all scholarship students?", "rationale": ["Identify the relevant tables: We need to find students who are on a sports scholarship, which involves the 'SportsInfo' and 'Student' tables.", "Determine the join condition: We will join 'SportsInfo' with 'Student' on the 'StuID' column, as it is the common identifier for both tables.", "Select the required field: We need the last names of the students, which is in the 'Student' table under the column 'LName'.", "Apply the filter for scholarship status: We will filter the results to include only those students who are on a scholarship, indicated by 'OnScholarship = 'Yes''."], "gold_sql": "SELECT T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T1.onscholarship  =  'Y'", "source_tables": ["sportsinfo", "student"], "pred_sql": "SELECT T2.LName FROM SportsInfo AS T1 JOIN Student AS T2 ON T1.StuID = T2.StuID WHERE T1.OnScholarship = 'Yes'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the last names of students from the 'Student' table who are participating in sports and are on a sports scholarship. The placeholder in the WHERE clause represents the scholarship status.\",\n        \"virtual_table\": \"SELECT T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T1.onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6010", "db_id": "game_1", "question": "What is the total number of all football games played by scholarship students?", "rationale": ["Identify the relevant tables: SportsInfo for sports participation and scholarship status.", "We need to count the total number of football games played by students on a sports scholarship.", "Filter the SportsInfo table for entries where SportName is 'Football' and OnScholarship is 'Yes'.", "Use the COUNT() function to get the total number of games played by these students."], "gold_sql": "SELECT sum(gamesplayed) FROM Sportsinfo WHERE sportname  =  'Football' AND onscholarship  =  'Y'", "source_tables": ["sportsinfo"], "pred_sql": "SELECT COUNT(*) AS TotalGamesPlayed \nFROM SportsInfo AS S \nWHERE S.SportName = 'Football' AND S.OnScholarship = 'Yes';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the last names of students from the 'Student' table who are participating in sports and are on a sports scholarship. The placeholder in the WHERE clause represents the scholarship status.\",\n        \"virtual_table\": \"SELECT T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T1.onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6014", "db_id": "game_1", "question": "What are the ids of all students along with how many sports and games did they play?", "rationale": ["We need to retrieve the IDs of all students along with the count of sports and games they play.", "To get the student IDs, we will select from the 'Student' table.", "We will use LEFT JOIN to connect the 'Student' table with 'SportsInfo' to count the number of sports each student is involved in.", "We will also use LEFT JOIN to connect the 'Student' table with 'Plays_Games' to count the number of games each student plays.", "We will use COUNT(DISTINCT ...) to ensure we count unique sports and games for each student.", "Finally, we will group the results by student ID to get the counts for each student."], "gold_sql": "SELECT StuID ,  count(*) ,  sum(gamesplayed) FROM Sportsinfo GROUP BY StuID", "source_tables": ["sportsinfo"], "pred_sql": "SELECT S.StuID, COUNT(DISTINCT SG.SportName) AS SportsCount, COUNT(DISTINCT PG.GameID) AS GamesCount\nFROM Student S\nLEFT JOIN SportsInfo SG ON S.StuID = SG.StuID\nLEFT JOIN Plays_Games PG ON S.StuID = PG.StuID\nGROUP BY S.StuID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the last names of students from the 'Student' table who are participating in sports and are on a sports scholarship. The placeholder in the WHERE clause represents the scholarship status.\",\n        \"virtual_table\": \"SELECT T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T1.onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6019", "db_id": "game_1", "question": "Which sport has most number of students on scholarship?", "rationale": ["Identify the relevant table: SportsInfo contains information about students participating in sports and their scholarship status.", "Filter the records to include only those students who are on a sports scholarship by using the condition 'OnScholarship = 'Yes'.", "Group the results by 'SportName' to count the number of students in each sport.", "Use COUNT(*) to count the number of students for each sport.", "Order the results in descending order based on the count of students to find the sport with the most students on scholarship.", "Limit the results to 1 to get only the sport with the highest count."], "gold_sql": "SELECT sportname FROM Sportsinfo WHERE onscholarship  =  'Y' GROUP BY sportname ORDER BY count(*) DESC LIMIT 1", "source_tables": ["sportsinfo"], "pred_sql": "SELECT SportName, COUNT(*) AS StudentCount \nFROM SportsInfo \nWHERE OnScholarship = 'Yes' \nGROUP BY SportName \nORDER BY StudentCount DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the last names of students from the 'Student' table who are participating in sports and are on a sports scholarship. The placeholder in the WHERE clause represents the scholarship status.\",\n        \"virtual_table\": \"SELECT T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T1.onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6020", "db_id": "game_1", "question": "What is the sport with the most scholarship students?", "rationale": ["Identify the relevant table: SportsInfo contains information about students participating in sports and their scholarship status.", "Filter for students on a sports scholarship by using the condition 'OnScholarship = 'Yes' in the WHERE clause.", "Group the results by SportName to count how many scholarship students are in each sport using COUNT(*) and GROUP BY.", "Order the results in descending order based on the count of scholarship students to find the sport with the most scholarship students.", "Limit the results to 1 to get only the sport with the highest count."], "gold_sql": "SELECT sportname FROM Sportsinfo WHERE onscholarship  =  'Y' GROUP BY sportname ORDER BY count(*) DESC LIMIT 1", "source_tables": ["sportsinfo"], "pred_sql": "SELECT SportName, COUNT(*) AS ScholarshipCount \nFROM SportsInfo \nWHERE OnScholarship = 'Yes' \nGROUP BY SportName \nORDER BY ScholarshipCount DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the last names of students from the 'Student' table who are participating in sports and are on a sports scholarship. The placeholder in the WHERE clause represents the scholarship status.\",\n        \"virtual_table\": \"SELECT T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T1.onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6024", "db_id": "game_1", "question": "What are the student ids for those on scholarship in major number 600?", "rationale": ["Identify the relevant tables: SportsInfo for scholarship status and Student for major.", "We need to find students who are on a sports scholarship, so we will filter the SportsInfo table for 'OnScholarship' status.", "We also need to filter students based on their major, which is found in the Student table.", "Join the SportsInfo table with the Student table on the StuID to combine the information from both tables.", "Select the StuID from the joined tables where the conditions for scholarship and major are met."], "gold_sql": "SELECT StuID FROM Student WHERE major  =  600 INTERSECT SELECT StuID FROM Sportsinfo WHERE onscholarship  =  'Y'", "source_tables": ["sportsinfo", "student"], "pred_sql": "SELECT T1.StuID FROM SportsInfo AS T1 JOIN Student AS T2 ON T1.StuID = T2.StuID WHERE T1.OnScholarship = 'Yes' AND T2.Major = '600'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the last names of students from the 'Student' table who are participating in sports and are on a sports scholarship. The placeholder in the WHERE clause represents the scholarship status.\",\n        \"virtual_table\": \"SELECT T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T1.onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6025", "db_id": "game_1", "question": "Show student ids who are female and play football.", "rationale": ["Identify the relevant tables: We need to use the 'Student' table to filter by gender and the 'SportsInfo' table to filter by sport.", "Join the 'Student' table with the 'SportsInfo' table on the StuID column to combine student information with their sports participation.", "Filter the results to include only female students by checking the 'Sex' column in the 'Student' table.", "Further filter the results to include only those students who play football by checking the 'SportName' column in the 'SportsInfo' table."], "gold_sql": "SELECT StuID FROM Student WHERE sex  =  'F' INTERSECT SELECT StuID FROM Sportsinfo WHERE sportname  =  'Football'", "source_tables": ["sportsinfo", "student"], "pred_sql": "SELECT S.StuID \nFROM Student AS S \nJOIN SportsInfo AS SI ON S.StuID = SI.StuID \nWHERE S.Sex = 'Female' AND SI.SportName = 'Football';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the last names of students from the 'Student' table who are participating in sports and are on a sports scholarship. The placeholder in the WHERE clause represents the scholarship status.\",\n        \"virtual_table\": \"SELECT T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T1.onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6026", "db_id": "game_1", "question": "What are the ids of all female students who play football?", "rationale": ["Identify the relevant tables: We need to look at the 'Student' table for student details and the 'SportsInfo' table for sports participation.", "We are interested in female students, so we will filter the 'Student' table by the 'Sex' column where it equals 'Female'.", "We also need to find students who play football, which means we will filter the 'SportsInfo' table by the 'SportName' column where it equals 'Football'.", "To get the ids of these students, we will select the 'StuID' from the 'Student' table.", "We will join the 'Student' table with the 'SportsInfo' table on the 'StuID' to combine the information from both tables based on the student identifier."], "gold_sql": "SELECT StuID FROM Student WHERE sex  =  'F' INTERSECT SELECT StuID FROM Sportsinfo WHERE sportname  =  'Football'", "source_tables": ["sportsinfo", "student"], "pred_sql": "SELECT Student.StuID FROM Student JOIN SportsInfo ON Student.StuID = SportsInfo.StuID WHERE Student.Sex = 'Female' AND SportsInfo.SportName = 'Football';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the last names of students from the 'Student' table who are participating in sports and are on a sports scholarship. The placeholder in the WHERE clause represents the scholarship status.\",\n        \"virtual_table\": \"SELECT T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T1.onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6028", "db_id": "game_1", "question": "What are the ids of all male students who do not play football?", "rationale": ["Identify the requirement: We need the IDs of all male students who do not play football.", "Filter the 'Student' table to get male students by using the condition 'Sex = 'Male' '.", "To find students who do not play football, we need to exclude those who are in the 'SportsInfo' table with 'SportName' as 'Football'.", "We can achieve this by using a subquery that selects 'StuID' from 'SportsInfo' where 'SportName' is 'Football'.", "The main query will select 'StuID' from 'Student' where the 'Sex' is 'Male' and the 'StuID' is not in the result of the subquery."], "gold_sql": "SELECT StuID FROM Student WHERE sex  =  'M' EXCEPT SELECT StuID FROM Sportsinfo WHERE sportname  =  'Football'", "source_tables": ["sportsinfo", "student"], "pred_sql": "SELECT StuID FROM Student WHERE Sex = 'Male' AND StuID NOT IN (SELECT StuID FROM SportsInfo WHERE SportName = 'Football')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the last names of students from the 'Student' table who are participating in sports and are on a sports scholarship. The placeholder in the WHERE clause represents the scholarship status.\",\n        \"virtual_table\": \"SELECT T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T1.onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6060", "db_id": "customers_and_addresses", "question": "Find the average order quantity per order.", "rationale": ["The task is to find the average order quantity per order.", "To calculate the average, we will use the AVG() function in SQL.", "The relevant table for order quantities is 'Order_Items'.", "We will select the average of the 'order_quantity' column from the 'Order_Items' table."], "gold_sql": "SELECT avg(order_quantity) FROM order_items", "source_tables": ["order_items"], "pred_sql": "SELECT avg(order_quantity) AS average_order_quantity FROM Order_Items;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average quantity of products ordered from the 'Order_Items' table. The result provides insights into the typical order size for products.\",\n        \"virtual_table\": \"SELECT avg(order_quantity) FROM order_items\"\n    }\n}\n"}
{"sample_id": "train.6071", "db_id": "customers_and_addresses", "question": "What are the details of all products?", "rationale": ["The user wants to retrieve details of all products.", "To get all details, we need to select all columns from the Products table.", "The SQL query to achieve this is 'SELECT * FROM Products;'"], "gold_sql": "SELECT DISTINCT product_details FROM products", "source_tables": ["products"], "pred_sql": "SELECT * FROM Products;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a unique list of product specifications from the 'Products' table. The placeholder in the SELECT clause represents the product details that can be filtered or modified as needed.\",\n        \"virtual_table\": \"SELECT DISTINCT product_details FROM products\"\n    }\n}\n"}
{"sample_id": "train.6075", "db_id": "customers_and_addresses", "question": "Find the detail of products whose detail contains the word \"Latte\" or the word \"Americano\"", "rationale": ["The user wants to find product details that contain either 'Latte' or 'Americano'.", "We will select the 'product_details' column from the 'Products' table.", "To filter the results, we will use the WHERE clause with LIKE operator to check for the presence of 'Latte' or 'Americano' in the 'product_details'.", "The '%' wildcard is used to match any sequence of characters before or after the specified words."], "gold_sql": "SELECT product_details FROM products WHERE product_details LIKE '%Latte%' OR product_details LIKE '%Americano%'", "source_tables": ["products"], "pred_sql": "SELECT DISTINCT product_details FROM Products WHERE product_details LIKE '%Latte%' OR product_details LIKE '%Americano%'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a unique list of product specifications from the 'Products' table. The placeholder in the SELECT clause represents the product details that can be filtered or modified as needed.\",\n        \"virtual_table\": \"SELECT DISTINCT product_details FROM products\"\n    }\n}\n"}
{"sample_id": "train.6085", "db_id": "customers_and_addresses", "question": "Which city has the most customers living in?", "rationale": ["Identify the relevant tables: We need to find the city with the most customers, so we will use the Customer_Addresses and Addresses tables.", "Join the tables: We will join Customer_Addresses with Addresses on the address_id to get the city associated with each customer.", "Count distinct customers: We will count the distinct customer_id for each city to avoid counting the same customer multiple times if they have multiple addresses.", "Group by city: We will group the results by city to aggregate the customer counts for each city.", "Order by customer count: We will order the results in descending order based on the customer count to find the city with the most customers.", "Limit the results: We will limit the results to 1 to get only the city with the highest count."], "gold_sql": "SELECT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id GROUP BY t3.city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "customers", "customer_addresses"], "pred_sql": "SELECT city, COUNT(DISTINCT customer_id) AS customer_count\nFROM Customer_Addresses\nJOIN Addresses ON Customer_Addresses.address_id = Addresses.address_id\nGROUP BY city\nORDER BY customer_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6086", "db_id": "customers_and_addresses", "question": "Find the city where the most customers live.", "rationale": ["To find the city where the most customers live, we need to count the number of customers associated with each city.", "The relevant tables are 'Customer_Addresses' which links customers to their addresses, and 'Addresses' which contains the city information.", "We will perform a JOIN between 'Customer_Addresses' and 'Addresses' on the address_id to get the city for each customer.", "Next, we will use GROUP BY to group the results by city and COUNT to count the number of customers in each city.", "To find the city with the most customers, we will order the results in descending order based on the customer count.", "Finally, we will limit the results to 1 to get only the city with the highest count."], "gold_sql": "SELECT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id GROUP BY t3.city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "customers", "customer_addresses"], "pred_sql": "SELECT city, COUNT(customer_id) AS customer_count\nFROM Customer_Addresses\nJOIN Addresses ON Customer_Addresses.address_id = Addresses.address_id\nGROUP BY city\nORDER BY customer_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6097", "db_id": "customers_and_addresses", "question": "Which contact channel has been used by the customer with name \"Tillman Ernser\"?", "rationale": ["Identify the relevant tables: Customers and Customer_Contact_Channels.", "Join the Customers table with the Customer_Contact_Channels table on customer_id to link customers with their contact channels.", "Filter the results to find the specific customer by name, 'Tillman Ernser'.", "Select the channel_code from the Customer_Contact_Channels table to determine which contact channel has been used by this customer."], "gold_sql": "SELECT DISTINCT channel_code FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  'Tillman Ernser'", "source_tables": ["customer_contact_channels", "customers"], "pred_sql": "SELECT t2.channel_code FROM Customers AS t1 JOIN Customer_Contact_Channels AS t2 ON t1.customer_id = t2.customer_id WHERE t1.customer_name = 'Tillman Ernser'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the most recent deactivation date of a contact channel for a specific customer from the 'Customers' and 'Customer_Contact_Channels' tables. The placeholder in the WHERE clause represents the customer's name.\",\n        \"virtual_table\": \"SELECT max(t2.active_to_date) FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average duration that contact channels remain active for customers in the 'Customer_Contact_Channels' table. The placeholder in the SELECT clause represents the calculation of the difference between the active dates.\",\n        \"virtual_table\": \"SELECT avg(active_to_date - active_from_date) FROM customer_contact_channels\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of customer names from the 'Customers' table who have placed orders, sorted by the most recent order date. The placeholder in the LIMIT clause allows for specifying the maximum number of customer names to retrieve.\",\n        \"virtual_table\": \"SELECT t1.customer_name FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id ORDER BY t2.order_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6100", "db_id": "customers_and_addresses", "question": "Return the the \"active to date\" of the latest contact channel used by the customer named \"Tillman Ernser\".", "rationale": ["Identify the relevant tables: Customers and Customer_Contact_Channels.", "Determine the relationship between the tables: Customers is linked to Customer_Contact_Channels via customer_id.", "We need to find the latest 'active_to_date' for the contact channels associated with the customer named 'Tillman Ernser'.", "Use the MAX function to get the most recent 'active_to_date'.", "Construct the SQL query using a JOIN to connect the two tables and filter by the customer's name."], "gold_sql": "SELECT max(t2.active_to_date) FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  'Tillman Ernser'", "source_tables": ["customer_contact_channels", "customers"], "pred_sql": "SELECT max(t2.active_to_date) FROM Customers AS t1 JOIN Customer_Contact_Channels AS t2 ON t1.customer_id = t2.customer_id WHERE t1.customer_name = 'Tillman Ernser'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the most recent deactivation date of a contact channel for a specific customer from the 'Customers' and 'Customer_Contact_Channels' tables. The placeholder in the WHERE clause represents the customer's name.\",\n        \"virtual_table\": \"SELECT max(t2.active_to_date) FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average duration that contact channels remain active for customers in the 'Customer_Contact_Channels' table. The placeholder in the SELECT clause represents the calculation of the difference between the active dates.\",\n        \"virtual_table\": \"SELECT avg(active_to_date - active_from_date) FROM customer_contact_channels\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of customer names from the 'Customers' table who have placed orders, sorted by the most recent order date. The placeholder in the LIMIT clause allows for specifying the maximum number of customer names to retrieve.\",\n        \"virtual_table\": \"SELECT t1.customer_name FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id ORDER BY t2.order_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6101", "db_id": "customers_and_addresses", "question": "What is the average time span of contact channels in the database?", "rationale": ["The question asks for the average time span of contact channels in the database.", "To calculate the average duration that contact channels remain active, we need to find the difference between the 'active_to_date' and 'active_from_date'.", "In SQLite, we can use the 'julianday' function to convert date strings into Julian day numbers, which allows us to perform arithmetic on dates.", "We will use the 'avg' function to calculate the average of these durations.", "The final SQL query will select the average duration from the 'Customer_Contact_Channels' table."], "gold_sql": "SELECT avg(active_to_date - active_from_date) FROM customer_contact_channels", "source_tables": ["customer_contact_channels"], "pred_sql": "SELECT avg(julianday(active_to_date) - julianday(active_from_date)) AS average_contact_duration FROM Customer_Contact_Channels;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average duration that contact channels remain active for customers in the 'Customer_Contact_Channels' table. The placeholder in the SELECT clause represents the calculation of the difference between the active dates.\",\n        \"virtual_table\": \"SELECT avg(active_to_date - active_from_date) FROM customer_contact_channels\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves the most recent deactivation date of a contact channel for a specific customer from the 'Customers' and 'Customer_Contact_Channels' tables. The placeholder in the WHERE clause represents the customer's name.\",\n        \"virtual_table\": \"SELECT max(t2.active_to_date) FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average quantity of products ordered from the 'Order_Items' table. The result provides insights into the typical order size for products.\",\n        \"virtual_table\": \"SELECT avg(order_quantity) FROM order_items\"\n    }\n}\n"}
{"sample_id": "train.6103", "db_id": "customers_and_addresses", "question": "What is the channel code and contact number of the customer contact channel that was active for the longest time?", "rationale": ["Identify the relevant table: Customer_Contact_Channels contains the channel code and contact number.", "Determine the criteria for the longest active duration: This can be calculated as the difference between active_to_date and active_from_date.", "Use a subquery to find the maximum duration of activity by calculating the difference for all records in Customer_Contact_Channels.", "Select the channel_code and contact_number where the duration matches the maximum found in the subquery."], "gold_sql": "SELECT channel_code ,  contact_number FROM customer_contact_channels WHERE active_to_date - active_from_date  =  (SELECT active_to_date - active_from_date FROM customer_contact_channels ORDER BY (active_to_date - active_from_date) DESC LIMIT 1)", "source_tables": ["customer_contact_channels"], "pred_sql": "SELECT channel_code, contact_number FROM Customer_Contact_Channels WHERE (active_to_date - active_from_date) = (SELECT MAX(active_to_date - active_from_date) FROM Customer_Contact_Channels)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average duration that contact channels remain active for customers in the 'Customer_Contact_Channels' table. The placeholder in the SELECT clause represents the calculation of the difference between the active dates.\",\n        \"virtual_table\": \"SELECT avg(active_to_date - active_from_date) FROM customer_contact_channels\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves the most recent deactivation date of a contact channel for a specific customer from the 'Customers' and 'Customer_Contact_Channels' tables. The placeholder in the WHERE clause represents the customer's name.\",\n        \"virtual_table\": \"SELECT max(t2.active_to_date) FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6108", "db_id": "customers_and_addresses", "question": "Find the name of the customer who made the order of the largest amount of goods.", "rationale": ["Identify the relevant tables: Customers, Customer_Orders, and Order_Items are needed to find the customer who made the largest order.", "Join the Customers table with Customer_Orders to link customers to their orders using customer_id.", "Join the resulting table with Order_Items to access the quantities of products ordered.", "Group the results by customer_id to aggregate the total quantity of products ordered by each customer.", "Order the results in descending order based on the total quantity ordered to find the customer with the largest order.", "Limit the results to 1 to get only the top customer."], "gold_sql": "SELECT t1.customer_name FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id JOIN order_items AS t3 ON t2.order_id  =  t3.order_id WHERE t3.order_quantity  =  ( SELECT max(order_quantity) FROM order_items)", "source_tables": ["customer_orders", "customers", "order_items"], "pred_sql": "SELECT c.customer_name \nFROM Customers AS c \nJOIN Customer_Orders AS o ON c.customer_id = o.customer_id \nJOIN Order_Items AS oi ON o.order_id = oi.order_id \nGROUP BY c.customer_id \nORDER BY SUM(oi.order_quantity) DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of customer names from the 'Customers' table who have placed orders, sorted by the most recent order date. The placeholder in the LIMIT clause allows for specifying the maximum number of customer names to retrieve.\",\n        \"virtual_table\": \"SELECT t1.customer_name FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id ORDER BY t2.order_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average quantity of products ordered from the 'Order_Items' table. The result provides insights into the typical order size for products.\",\n        \"virtual_table\": \"SELECT avg(order_quantity) FROM order_items\"\n    }\n}\n"}
{"sample_id": "train.6123", "db_id": "customers_and_addresses", "question": "What is the total number of products that are in orders with status \"Cancelled\"?", "rationale": ["Identify the relevant tables: We need to look at the 'Order_Items' table for product quantities and the 'Customer_Orders' table for order statuses.", "Join the 'Order_Items' table with the 'Customer_Orders' table on the 'order_id' to link products with their respective orders.", "Filter the results to include only those orders that have a status of 'Cancelled'.", "Use the SUM function to calculate the total quantity of products from the filtered results."], "gold_sql": "SELECT sum(t2.order_quantity) FROM customer_orders AS t1 JOIN order_items AS t2 ON t1.order_id  =  t2.order_id WHERE t1.order_status  =  'Cancelled'", "source_tables": ["customer_orders", "order_items"], "pred_sql": "SELECT SUM(order_items.order_quantity) \nFROM Order_Items \nJOIN Customer_Orders ON Order_Items.order_id = Customer_Orders.order_id \nWHERE Customer_Orders.order_status = 'Cancelled';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average quantity of products ordered from the 'Order_Items' table. The result provides insights into the typical order size for products.\",\n        \"virtual_table\": \"SELECT avg(order_quantity) FROM order_items\"\n    }\n}\n"}
{"sample_id": "train.6130", "db_id": "customers_and_addresses", "question": "What is the most frequently ordered product? Tell me the detail of the product", "rationale": ["To find the most frequently ordered product, we need to count the number of times each product appears in the 'Order_Items' table.", "We will join the 'Order_Items' table with the 'Products' table to get the product details along with the order count.", "We will group the results by product ID and product details to aggregate the order counts for each product.", "We will order the results in descending order based on the count of orders to get the most frequently ordered product at the top.", "Finally, we will limit the results to just one record to get the most frequently ordered product."], "gold_sql": "SELECT t2.product_details FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["products", "order_items"], "pred_sql": "SELECT p.product_id, p.product_details, COUNT(oi.order_id) AS order_count \nFROM Order_Items AS oi \nJOIN Products AS p ON oi.product_id = p.product_id \nGROUP BY p.product_id, p.product_details \nORDER BY order_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average quantity of products ordered from the 'Order_Items' table. The result provides insights into the typical order size for products.\",\n        \"virtual_table\": \"SELECT avg(order_quantity) FROM order_items\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of customer names from the 'Customers' table who have placed orders, sorted by the most recent order date. The placeholder in the LIMIT clause allows for specifying the maximum number of customer names to retrieve.\",\n        \"virtual_table\": \"SELECT t1.customer_name FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id ORDER BY t2.order_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a unique list of product specifications from the 'Products' table. The placeholder in the SELECT clause represents the product details that can be filtered or modified as needed.\",\n        \"virtual_table\": \"SELECT DISTINCT product_details FROM products\"\n    }\n}\n"}
{"sample_id": "train.6131", "db_id": "customers_and_addresses", "question": "Find the name and ID of the product whose total order quantity is the largest.", "rationale": ["To find the product with the largest total order quantity, we need to sum the order quantities for each product.", "We will use the 'Order_Items' table, which contains the 'product_id' and 'order_quantity'.", "We will group the results by 'product_id' to get the total quantity for each product.", "Next, we will order the results in descending order based on the total quantity to get the product with the highest quantity at the top.", "Finally, we will limit the results to 1 to get only the product with the largest total order quantity."], "gold_sql": "SELECT t2.product_details ,  t2.product_id FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY sum(t1.order_quantity) LIMIT 1", "source_tables": ["products", "order_items"], "pred_sql": "SELECT oi.product_id, SUM(oi.order_quantity) AS total_quantity\nFROM Order_Items AS oi\nGROUP BY oi.product_id\nORDER BY total_quantity DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average quantity of products ordered from the 'Order_Items' table. The result provides insights into the typical order size for products.\",\n        \"virtual_table\": \"SELECT avg(order_quantity) FROM order_items\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of customer names from the 'Customers' table who have placed orders, sorted by the most recent order date. The placeholder in the LIMIT clause allows for specifying the maximum number of customer names to retrieve.\",\n        \"virtual_table\": \"SELECT t1.customer_name FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id ORDER BY t2.order_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6132", "db_id": "customers_and_addresses", "question": "What are the name and ID of the product bought the most.", "rationale": ["Identify the relevant table: The 'Order_Items' table contains the product IDs and the quantities ordered.", "Count the total quantity of each product ordered: Use COUNT() to aggregate the order quantities for each product ID.", "Group the results by product ID: This allows us to get the total quantity for each product.", "Order the results in descending order: This will place the product with the highest total quantity at the top.", "Limit the results to 1: We only want the product that was bought the most."], "gold_sql": "SELECT t2.product_details ,  t2.product_id FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY sum(t1.order_quantity) LIMIT 1", "source_tables": ["products", "order_items"], "pred_sql": "SELECT oi.product_id, COUNT(oi.order_quantity) AS total_quantity\nFROM Order_Items oi\nGROUP BY oi.product_id\nORDER BY total_quantity DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average quantity of products ordered from the 'Order_Items' table. The result provides insights into the typical order size for products.\",\n        \"virtual_table\": \"SELECT avg(order_quantity) FROM order_items\"\n    }\n}\n"}
{"sample_id": "train.6133", "db_id": "customers_and_addresses", "question": "Find all the addresses in East Julianaside, Texas or in Gleasonmouth, Arizona.", "rationale": ["Identify the relevant table: The question asks for addresses, so we will use the 'Addresses' table.", "Determine the filtering criteria: We need to find addresses in two specific cities and states: East Julianaside, Texas and Gleasonmouth, Arizona.", "Construct the WHERE clause: We will use an OR condition to combine the two sets of criteria for the cities and states.", "Formulate the SQL query: We will select all columns from the Addresses table where the conditions are met."], "gold_sql": "SELECT address_content FROM addresses WHERE city  =  'East Julianaside' AND state_province_county  =  'Texas' UNION SELECT address_content FROM addresses WHERE city  =  'Gleasonmouth' AND state_province_county  =  'Arizona'", "source_tables": ["addresses"], "pred_sql": "SELECT * FROM Addresses WHERE (city = 'East Julianaside' AND state_province_county = 'Texas') OR (city = 'Gleasonmouth' AND state_province_county = 'Arizona');", "hint": "\n"}
{"sample_id": "train.6155", "db_id": "music_4", "question": "What are the category of music festivals with result \"Awarded\"?", "rationale": ["Identify the relevant table: The question pertains to music festivals, so we will focus on the 'music_festival' table.", "Determine the required columns: We need the 'Category' of the music festivals that have a result of 'Awarded'.", "Construct the SQL query: We will select the 'Category' from the 'music_festival' table where the 'Result' is equal to 'Awarded'."], "gold_sql": "SELECT Category FROM music_festival WHERE RESULT  =  'Awarded'", "source_tables": ["music_festival"], "pred_sql": "SELECT Category FROM music_festival WHERE Result = 'Awarded'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the results of music festivals, showing the outcomes grouped by their result type. The placeholder in the LIMIT clause allows the user to specify the maximum number of results to return, enabling them to control how many of the most frequent results they wish to see.\",\n        \"virtual_table\": \"SELECT RESULT FROM music_festival GROUP BY RESULT ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6167", "db_id": "music_4", "question": "Please show the songs that have result \"nominated\" at music festivals.", "rationale": ["Identify the relevant tables: 'music_festival' for festival results and 'volume' for song details.", "We need to find songs that have a result of 'nominated' in the music festivals.", "Join the 'music_festival' table with the 'volume' table using the foreign key relationship (music_festival.Volume = volume.Volume_ID).", "Filter the results to only include those where music_festival.Result is 'nominated'.", "Select the Song identifier from the volume table."], "gold_sql": "SELECT T2.Song FROM music_festival AS T1 JOIN volume AS T2 ON T1.Volume  =  T2.Volume_ID WHERE T1.Result  =  'Nominated'", "source_tables": ["music_festival", "volume"], "pred_sql": "SELECT volume.Song \nFROM music_festival \nJOIN volume ON music_festival.Volume = volume.Volume_ID \nWHERE music_festival.Result = 'nominated';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the results of music festivals, showing the outcomes grouped by their result type. The placeholder in the LIMIT clause allows the user to specify the maximum number of results to return, enabling them to control how many of the most frequent results they wish to see.\",\n        \"virtual_table\": \"SELECT RESULT FROM music_festival GROUP BY RESULT ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the songs from the 'volume' table, ordered by the number of weeks they stayed at the top, with a limit on the number of results returned. The placeholder in the LIMIT clause represents the maximum number of songs to display.\",\n        \"virtual_table\": \"SELECT Song FROM volume ORDER BY Weeks_on_Top DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6180", "db_id": "music_4", "question": "Return the famous release date for the oldest artist.", "rationale": ["Identify the table that contains the information about artists, which is the 'artist' table.", "We need to find the oldest artist, so we will sort the artists by their age in ascending order.", "To get the oldest artist, we will limit the results to 1 after sorting.", "The column we are interested in is 'Famous_Release_date', so we will select that column in our query."], "gold_sql": "SELECT Famous_Release_date FROM artist ORDER BY Age DESC LIMIT 1", "source_tables": ["artist"], "pred_sql": "SELECT Famous_Release_date FROM artist ORDER BY Age ASC LIMIT 1;", "hint": "\n"}
{"sample_id": "train.6185", "db_id": "music_4", "question": "Please show the categories of the music festivals with count more than 1.", "rationale": ["Identify the table of interest: music_festival, which contains the categories of music festivals.", "We need to group the results by the 'Category' column to count how many times each category appears.", "Use the HAVING clause to filter the groups, keeping only those with a count greater than 1.", "Construct the SQL query to select the 'Category' from the music_festival table, applying the GROUP BY and HAVING clauses."], "gold_sql": "SELECT Category FROM music_festival GROUP BY Category HAVING COUNT(*)  >  1", "source_tables": ["music_festival"], "pred_sql": "SELECT Category FROM music_festival GROUP BY Category HAVING COUNT(*) > 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the results of music festivals, showing the outcomes grouped by their result type. The placeholder in the LIMIT clause allows the user to specify the maximum number of results to return, enabling them to control how many of the most frequent results they wish to see.\",\n        \"virtual_table\": \"SELECT RESULT FROM music_festival GROUP BY RESULT ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6187", "db_id": "music_4", "question": "What is the song in the volume with the maximum weeks on top?", "rationale": ["Identify the relevant table: The 'volume' table contains the information about songs and their weeks on top.", "Determine the requirement: We need to find the song in the volume with the maximum weeks on top.", "Use the ORDER BY clause: To get the song with the maximum weeks on top, we will order the results by 'Weeks_on_Top' in descending order.", "Limit the results: Since we only want the song with the maximum weeks on top, we will use LIMIT 1 to return only the top result."], "gold_sql": "SELECT Song FROM volume ORDER BY Weeks_on_Top DESC LIMIT 1", "source_tables": ["volume"], "pred_sql": "SELECT Song FROM volume ORDER BY Weeks_on_Top DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the songs from the 'volume' table, ordered by the number of weeks they stayed at the top, with a limit on the number of results returned. The placeholder in the LIMIT clause represents the maximum number of songs to display.\",\n        \"virtual_table\": \"SELECT Song FROM volume ORDER BY Weeks_on_Top DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the identifiers of songs from the 'volume' table, ordered by the song identifier. The placeholder in the ORDER BY clause allows for dynamic sorting based on the song identifier.\",\n        \"virtual_table\": \"SELECT Song FROM volume ORDER BY Song\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the results of music festivals, showing the outcomes grouped by their result type. The placeholder in the LIMIT clause allows the user to specify the maximum number of results to return, enabling them to control how many of the most frequent results they wish to see.\",\n        \"virtual_table\": \"SELECT RESULT FROM music_festival GROUP BY RESULT ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6195", "db_id": "music_4", "question": "What is the issue date of the volume with the minimum weeks on top?", "rationale": ["Identify the table to query: The question asks for information from the 'volume' table.", "Determine the specific information needed: We need the 'Issue_Date' of the volume with the minimum 'Weeks_on_Top'.", "To find the minimum 'Weeks_on_Top', a subquery is required: SELECT MIN(Weeks_on_Top) FROM volume.", "Use this minimum value to filter the main query: SELECT Issue_Date FROM volume WHERE Weeks_on_Top equals the minimum value found in the subquery."], "gold_sql": "SELECT Issue_Date FROM volume ORDER BY Weeks_on_Top ASC LIMIT 1", "source_tables": ["volume"], "pred_sql": "SELECT Issue_Date FROM volume WHERE Weeks_on_Top = (SELECT MIN(Weeks_on_Top) FROM volume)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the songs from the 'volume' table, ordered by the number of weeks they stayed at the top, with a limit on the number of results returned. The placeholder in the LIMIT clause represents the maximum number of songs to display.\",\n        \"virtual_table\": \"SELECT Song FROM volume ORDER BY Weeks_on_Top DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6271", "db_id": "city_record", "question": "What is the match id of the competition called \"1994 FIFA World Cup qualification\"?", "rationale": ["Identify the table that contains the competition information, which is the 'match' table.", "Determine the column that holds the competition name, which is 'Competition'.", "Formulate a subquery to find the Competition ID for '1994 FIFA World Cup qualification'.", "Use the result of the subquery to select the Match_ID from the 'match' table."], "gold_sql": "SELECT match_id FROM MATCH WHERE competition = '1994 FIFA World Cup qualification'", "source_tables": ["match"], "pred_sql": "SELECT Match_ID FROM match WHERE Competition = (SELECT Competition FROM match WHERE Competition = '1994 FIFA World Cup qualification');", "hint": "\n"}
{"sample_id": "train.6274", "db_id": "city_record", "question": "Which city has hosted the most events?", "rationale": ["Identify the table that contains information about hosting cities, which is the 'hosting_city' table.", "To find out which city has hosted the most events, we need to count the number of matches hosted by each city.", "We will use the COUNT function to count the occurrences of each Host_City in the hosting_city table.", "We will group the results by Host_City to aggregate the counts for each city.", "Finally, we will order the results in descending order based on the count of events and limit the output to 1 to get the city with the most events."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["hosting_city", "city"], "pred_sql": "SELECT Host_City, COUNT(*) as Event_Count \nFROM hosting_city \nGROUP BY Host_City \nORDER BY Event_Count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table, ordered by their regional population in descending order. The placeholder in the LIMIT clause represents the maximum number of cities to be displayed.\",\n        \"virtual_table\": \"SELECT city FROM city ORDER BY regional_population DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table, ordered by their regional population in descending order. The placeholder in the LIMIT clause represents the maximum number of cities to be displayed.\",\n        \"virtual_table\": \"SELECT city FROM city ORDER BY regional_population DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6286", "db_id": "city_record", "question": "Which city has the highest temperature in February?", "rationale": ["Identify the relevant tables: We need data from the 'city' table for city names and the 'temperature' table for February temperatures.", "Join the 'city' table with the 'temperature' table on the City_ID to combine city names with their corresponding February temperatures.", "Order the results by the February temperature in descending order to get the city with the highest temperature at the top.", "Limit the results to 1 to get only the city with the highest temperature."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id ORDER BY T2.Feb DESC LIMIT 1", "source_tables": ["city", "temperature"], "pred_sql": "SELECT c.City FROM city c JOIN temperature t ON c.City_ID = t.City_ID ORDER BY t.Feb DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table, ordered by their regional population in descending order. The placeholder in the LIMIT clause represents the maximum number of cities to be displayed.\",\n        \"virtual_table\": \"SELECT city FROM city ORDER BY regional_population DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table, ordered by their regional population in descending order. The placeholder in the LIMIT clause represents the maximum number of cities to be displayed.\",\n        \"virtual_table\": \"SELECT city FROM city ORDER BY regional_population DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6287", "db_id": "city_record", "question": "In February, which city marks the highest temperature?", "rationale": ["Identify the relevant tables: We need data from the 'city' table for city names and the 'temperature' table for February temperatures.", "Join the 'city' table with the 'temperature' table on the City_ID to get the temperature data associated with each city.", "Select the city name and the February temperature from the joined tables.", "Order the results by February temperature in descending order to get the highest temperature at the top.", "Limit the results to 1 to get only the city with the highest temperature in February."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id ORDER BY T2.Feb DESC LIMIT 1", "source_tables": ["city", "temperature"], "pred_sql": "SELECT c.City, t.Feb\nFROM city c\nJOIN temperature t ON c.City_ID = t.City_ID\nORDER BY t.Feb DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table, ordered by their regional population in descending order. The placeholder in the LIMIT clause represents the maximum number of cities to be displayed.\",\n        \"virtual_table\": \"SELECT city FROM city ORDER BY regional_population DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table, ordered by their regional population in descending order. The placeholder in the LIMIT clause represents the maximum number of cities to be displayed.\",\n        \"virtual_table\": \"SELECT city FROM city ORDER BY regional_population DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6288", "db_id": "city_record", "question": "Give me a list of cities whose temperature in March is lower than that in July or higher than that in Oct?", "rationale": ["Identify the relevant tables: We need data from the 'city' and 'temperature' tables.", "Join the 'city' table with the 'temperature' table on the City_ID to access city names along with their temperature data.", "Formulate the condition: We want cities where the temperature in March is lower than in July or higher than in October.", "Construct the SQL query using SELECT to get the city names that meet the specified temperature conditions."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul OR T2.Mar  >  T2.Oct", "source_tables": ["city", "temperature"], "pred_sql": "SELECT c.City \nFROM city c \nJOIN temperature t ON c.City_ID = t.City_ID \nWHERE t.Mar < t.Jul OR t.Mar > t.Oct;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table, ordered by their regional population in descending order. The placeholder in the LIMIT clause represents the maximum number of cities to be displayed.\",\n        \"virtual_table\": \"SELECT city FROM city ORDER BY regional_population DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table, ordered by their regional population in descending order. The placeholder in the LIMIT clause represents the maximum number of cities to be displayed.\",\n        \"virtual_table\": \"SELECT city FROM city ORDER BY regional_population DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6289", "db_id": "city_record", "question": "Which cities' temperature in March is lower than that in July or higher than that in Oct?", "rationale": ["Identify the relevant tables: We need data from the 'city' table for city names and the 'temperature' table for temperature data.", "Join the 'city' table with the 'temperature' table on the City_ID to access both city names and their corresponding temperatures.", "Formulate the WHERE clause to filter cities based on the temperature conditions: March temperature should be lower than July or higher than October.", "Select the city names that meet these conditions."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul OR T2.Mar  >  T2.Oct", "source_tables": ["city", "temperature"], "pred_sql": "SELECT c.City \nFROM city c \nJOIN temperature t ON c.City_ID = t.City_ID \nWHERE t.Mar < t.Jul OR t.Mar > t.Oct;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table, ordered by their regional population in descending order. The placeholder in the LIMIT clause represents the maximum number of cities to be displayed.\",\n        \"virtual_table\": \"SELECT city FROM city ORDER BY regional_population DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table, ordered by their regional population in descending order. The placeholder in the LIMIT clause represents the maximum number of cities to be displayed.\",\n        \"virtual_table\": \"SELECT city FROM city ORDER BY regional_population DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6292", "db_id": "city_record", "question": "Give me a list of cities whose temperature in Mar is lower than that in Dec and which have never been host cities.", "rationale": ["Identify the relevant tables: 'city', 'temperature', and 'hosting_city'.", "We need to find cities where the average temperature in March is lower than in December.", "Join the 'city' table with the 'hosting_city' table to filter out cities that have hosted matches.", "Use a LEFT JOIN to include all cities and check if they are in the 'hosting_city' table.", "Use a subquery to ensure that we only select cities that are not present in the 'hosting_city' table.", "Use subqueries to compare the average temperatures for March and December for each city."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "pred_sql": "SELECT c.City \nFROM city c \nLEFT JOIN hosting_city h ON c.City_ID = h.Host_City \nWHERE c.City_ID NOT IN (SELECT Host_City FROM hosting_city) \nAND (SELECT Mar FROM temperature t WHERE t.City_ID = c.City_ID) < (SELECT Dec FROM temperature t WHERE t.City_ID = c.City_ID);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table, ordered by their regional population in descending order. The placeholder in the LIMIT clause represents the maximum number of cities to be displayed.\",\n        \"virtual_table\": \"SELECT city FROM city ORDER BY regional_population DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table, ordered by their regional population in descending order. The placeholder in the LIMIT clause represents the maximum number of cities to be displayed.\",\n        \"virtual_table\": \"SELECT city FROM city ORDER BY regional_population DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6293", "db_id": "city_record", "question": "Which cities have lower temperature in March than in Dec and have never served as host cities?", "rationale": ["Identify the relevant tables: 'city' for city names and 'temperature' for temperature data.", "Join the 'city' table with the 'temperature' table on 'City_ID' to access temperature data for each city.", "Filter the results to find cities where the average temperature in March (t.Mar) is less than the average temperature in December (t.Dec).", "Ensure that the cities have never served as host cities by excluding any city that appears in the 'hosting_city' table's 'Host_City' column using a NOT IN clause."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "pred_sql": "SELECT c.City \nFROM city c \nJOIN temperature t ON c.City_ID = t.City_ID \nWHERE t.Mar < t.Dec \nAND c.City_ID NOT IN (SELECT Host_City FROM hosting_city)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table, ordered by their regional population in descending order. The placeholder in the LIMIT clause represents the maximum number of cities to be displayed.\",\n        \"virtual_table\": \"SELECT city FROM city ORDER BY regional_population DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table, ordered by their regional population in descending order. The placeholder in the LIMIT clause represents the maximum number of cities to be displayed.\",\n        \"virtual_table\": \"SELECT city FROM city ORDER BY regional_population DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6298", "db_id": "city_record", "question": "Please give me a list of cities whose regional population is over 8000000 or under 5000000.", "rationale": ["Identify the table to query: The 'city' table contains the relevant data about cities and their populations.", "Determine the conditions for filtering: We need cities with a regional population greater than 8,000,000 or less than 5,000,000.", "Construct the SQL query: Use a SELECT statement to retrieve the 'City' column from the 'city' table, applying the specified conditions in the WHERE clause."], "gold_sql": "SELECT city FROM city WHERE regional_population  >  10000000 UNION SELECT city FROM city WHERE regional_population  <  5000000", "source_tables": ["city"], "pred_sql": "SELECT City FROM city WHERE Regional_Population > 8000000 OR Regional_Population < 5000000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table, ordered by their regional population in descending order. The placeholder in the LIMIT clause represents the maximum number of cities to be displayed.\",\n        \"virtual_table\": \"SELECT city FROM city ORDER BY regional_population DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table, ordered by their regional population in descending order. The placeholder in the LIMIT clause represents the maximum number of cities to be displayed.\",\n        \"virtual_table\": \"SELECT city FROM city ORDER BY regional_population DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6313", "db_id": "e_government", "question": "What is the name of the party form that is most common?", "rationale": ["Identify the relevant tables: Party_Forms and Forms are needed to get the form names.", "Join the Party_Forms table with the Forms table on the form_id to access the form names.", "Group the results by form_name to count how many times each form appears in Party_Forms.", "Use COUNT(*) to count the occurrences of each form name.", "Order the results in descending order based on the count to find the most common form.", "Limit the results to 1 to get only the most common party form."], "gold_sql": "SELECT t1.form_name FROM forms AS t1 JOIN party_forms AS t2 ON t1.form_id  =  t2.form_id GROUP BY t2.form_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["forms", "party_forms"], "pred_sql": "SELECT form_name, COUNT(*) as form_count \nFROM Party_Forms \nJOIN Forms ON Party_Forms.form_id = Forms.form_id \nGROUP BY form_name \nORDER BY form_count DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6329", "db_id": "e_government", "question": "What are the names of the services that have never been used?", "rationale": ["Identify the main table of interest, which is the 'Services' table, to get the names of services.", "Use the 'Party_Services' table to find out which services have been booked.", "To find services that have never been used, we can use the EXCEPT clause to exclude those services that appear in the 'Party_Services' table from the list of all services in the 'Services' table."], "gold_sql": "SELECT service_name FROM services EXCEPT SELECT t1.service_name FROM services AS t1 JOIN party_services AS t2 ON t1.service_id  =  t2.service_id", "source_tables": ["services", "party_services"], "pred_sql": "SELECT service_name FROM Services EXCEPT SELECT t1.service_name FROM Services AS t1 JOIN Party_Services AS t2 ON t1.service_id = t2.service_id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of services from the 'Services' table that have not been booked by any party. The query uses an EXCEPT clause to exclude service names that are present in the 'Party_Services' table, indicating that those services have been booked. The placeholder in the query allows for future modifications to filter or adjust the selection criteria as needed.\",\n        \"virtual_table\": \"SELECT service_name FROM services EXCEPT SELECT t1.service_name FROM services AS t1 JOIN party_services AS t2 ON t1.service_id  =  t2.service_id\"\n    }\n}\n"}
{"sample_id": "train.6330", "db_id": "e_government", "question": "Find the name of all the cities and states.", "rationale": ["Identify the relevant table: The question asks for cities and states, which are found in the Addresses table.", "Select the appropriate columns: We need to select 'town_city' for cities and 'state_province_county' for states.", "Use DISTINCT to avoid duplicate entries: Since we want the names of all cities and states, using DISTINCT ensures that we only get unique combinations.", "Construct the SQL query: Combine the selected columns and table into a SQL SELECT statement."], "gold_sql": "SELECT town_city FROM addresses UNION SELECT state_province_county FROM addresses", "source_tables": ["addresses"], "pred_sql": "SELECT DISTINCT town_city, state_province_county FROM Addresses;", "hint": "\n"}
{"sample_id": "train.6342", "db_id": "e_government", "question": "Which state can address \"6862 Kaitlyn Knolls\" possibly be in?", "rationale": ["Identify the relevant table: The question pertains to addresses, so we will use the 'Addresses' table.", "Determine the required column: We need to find the state, province, or county, which is stored in the 'state_province_county' column.", "Formulate the query: We will use a SELECT statement to retrieve the 'state_province_county' from the 'Addresses' table.", "Use a WHERE clause to filter results: We need to match the address line with a pattern that includes '6862 Kaitlyn Knolls'.", "Utilize the LIKE operator: To allow for flexible matching, we will use the LIKE operator with wildcards around the address."], "gold_sql": "SELECT state_province_county FROM addresses WHERE line_1_number_building LIKE '%6862 Kaitlyn Knolls%'", "source_tables": ["addresses"], "pred_sql": "SELECT state_province_county FROM Addresses WHERE line_1_number_building LIKE '%6862 Kaitlyn Knolls%'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the state, province, or county information from the 'Addresses' table based on a specific address line that matches a given pattern. The placeholder in the LIKE clause allows for flexible searching of address lines.\",\n        \"virtual_table\": \"SELECT state_province_county FROM addresses WHERE line_1_number_building LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6346", "db_id": "e_government", "question": "Find the last name of the individuals that have been contact individuals of an organization.", "rationale": ["Identify the relevant tables: We need to find individuals who are contact individuals for organizations, so we will use the Organization_Contact_Individuals and Individuals tables.", "Determine the relationship: The Organization_Contact_Individuals table has a foreign key 'individual_id' that links to the Individuals table.", "Select the required field: We need the last names of these individuals, which is found in the Individuals table under 'individual_last_name'.", "Construct the SQL query: We will use a JOIN to combine the Organization_Contact_Individuals and Individuals tables on the 'individual_id' field and select the 'individual_last_name' from the Individuals table."], "gold_sql": "SELECT DISTINCT t1.individual_last_name FROM individuals AS t1 JOIN organization_contact_individuals AS t2 ON t1.individual_id  =  t2.individual_id", "source_tables": ["organization_contact_individuals", "individuals"], "pred_sql": "SELECT Individuals.individual_last_name \nFROM Organization_Contact_Individuals \nJOIN Individuals ON Organization_Contact_Individuals.individual_id = Individuals.individual_id;", "hint": "\n"}
{"sample_id": "train.6371", "db_id": "flight_company", "question": "What are the names and types of the companies that have ever operated a flight?", "rationale": ["Identify the relevant tables: We need information from the 'operate_company' table for company names and types, and the 'flight' table to find which companies have operated flights.", "Determine the relationship: The 'flight' table has a foreign key 'company_id' that links to the 'id' in the 'operate_company' table. This means we can join these two tables on this key.", "Select the required columns: We need to select the 'name' and 'Type' columns from the 'operate_company' table.", "Use DISTINCT to avoid duplicate entries: Since a company may operate multiple flights, we use DISTINCT to ensure each company is listed only once."], "gold_sql": "SELECT T1.name ,  T1.type FROM operate_company AS T1 JOIN flight AS t2 ON T1.id  =  T2.company_id", "source_tables": ["flight", "operate_company"], "pred_sql": "SELECT DISTINCT operate_company.name, operate_company.Type \nFROM operate_company \nJOIN flight ON operate_company.id = flight.company_id;", "hint": "\n"}
{"sample_id": "train.6375", "db_id": "flight_company", "question": "What is the id, name and IATA code of the airport that had most number of flights?", "rationale": ["Identify the relevant tables: 'airport' and 'flight'.", "We need to find the airport with the most flights, so we will join the 'airport' table with the 'flight' table using the foreign key relationship (airport.id = flight.airport_id).", "Select the required columns: 'id', 'name', and 'IATA' from the 'airport' table.", "Group the results by the airport's id, name, and IATA code to aggregate the flight counts.", "Count the number of flights for each airport using COUNT(flight.id).", "Order the results in descending order based on the count of flights to get the airport with the most flights at the top.", "Limit the results to 1 to get only the airport with the highest number of flights."], "gold_sql": "SELECT T1.id ,  T1.name ,  T1.IATA FROM airport AS T1 JOIN flight AS T2 ON T1.id  =  T2.airport_id GROUP BY T2.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airport", "flight"], "pred_sql": "SELECT airport.id, airport.name, airport.IATA\nFROM airport\nJOIN flight ON airport.id = flight.airport_id\nGROUP BY airport.id, airport.name, airport.IATA\nORDER BY COUNT(flight.id) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6381", "db_id": "flight_company", "question": "How many companies operates airlines in each airport?", "rationale": ["Identify the relevant tables: airport, operate_company, and flight.", "We need to count the number of companies that operate airlines at each airport.", "Join the airport table with the flight table on airport.id and flight.airport_id.", "Join the resulting table with the operate_company table on flight.company_id and operate_company.id.", "Filter the results to include only those companies that are of type 'airline'.", "Group the results by the airport name to get the count of airlines per airport."], "gold_sql": "SELECT T3.id ,  count(*) FROM operate_company AS T1 JOIN flight AS t2 ON T1.id  =  T2.company_id JOIN airport AS T3 ON T2.airport_id  =  T3.id GROUP BY T3.id", "source_tables": ["airport", "flight", "operate_company"], "pred_sql": "SELECT airport.name AS Airport_Name, COUNT(operate_company.id) AS Number_of_Airlines\nFROM airport\nJOIN flight ON airport.id = flight.airport_id\nJOIN operate_company ON flight.company_id = operate_company.id\nWHERE operate_company.Type = 'airline'\nGROUP BY airport.name;", "hint": "\n"}
{"sample_id": "train.6517", "db_id": "wine_1", "question": "What is the name of the highest rated wine?", "rationale": ["Identify the table that contains wine information, which is the 'wine' table.", "To find the highest rated wine, we need to order the wines by their score in descending order.", "Using 'ORDER BY Score DESC' will sort the wines from highest to lowest score.", "To get only the highest rated wine, we can limit the results to 1 using 'LIMIT 1'.", "Combine these elements to form the final SQL query: 'SELECT Name FROM wine ORDER BY Score DESC LIMIT 1'."], "gold_sql": "SELECT Name FROM WINE ORDER BY Score LIMIT 1", "source_tables": ["wine"], "pred_sql": "SELECT Name FROM wine ORDER BY Score DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of wines from the 'wine' table that have a score higher than a specified value. The placeholder in the WHERE clause represents the minimum score threshold for filtering the wines.\",\n        \"virtual_table\": \"SELECT Name FROM WINE WHERE score  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of wineries from the 'wine' table, ordered by their rating scores. The placeholder in the LIMIT clause represents the maximum number of wineries to be displayed.\",\n        \"virtual_table\": \"SELECT Winery FROM WINE ORDER BY SCORE LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the distinct names of wines from the 'wine' table, ordered by their retail price. The placeholder in the ORDER BY clause represents the price of the wines.\",\n        \"virtual_table\": \"SELECT DISTINCT Name FROM WINE ORDER BY price\"\n    }\n}\n"}
{"sample_id": "train.6518", "db_id": "wine_1", "question": "Give the name of the wine with the highest score.", "rationale": ["Identify the table that contains the wine information, which is the 'wine' table.", "To find the wine with the highest score, we need to order the wines by their score in descending order.", "Using 'ORDER BY Score DESC' will sort the wines from highest to lowest score.", "To get only the top wine, we will use 'LIMIT 1' to restrict the result to just one entry.", "The final SQL query selects the 'Name' of the wine from the 'wine' table, orders it by score in descending order, and limits the result to the top entry."], "gold_sql": "SELECT Name FROM WINE ORDER BY Score LIMIT 1", "source_tables": ["wine"], "pred_sql": "SELECT Name FROM wine ORDER BY Score DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of wines from the 'wine' table that have a score higher than a specified value. The placeholder in the WHERE clause represents the minimum score threshold for filtering the wines.\",\n        \"virtual_table\": \"SELECT Name FROM WINE WHERE score  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of wineries from the 'wine' table, ordered by their rating scores. The placeholder in the LIMIT clause represents the maximum number of wineries to be displayed.\",\n        \"virtual_table\": \"SELECT Winery FROM WINE ORDER BY SCORE LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the distinct names of wines from the 'wine' table, ordered by their retail price. The placeholder in the ORDER BY clause represents the price of the wines.\",\n        \"virtual_table\": \"SELECT DISTINCT Name FROM WINE ORDER BY price\"\n    }\n}\n"}
{"sample_id": "train.6520", "db_id": "wine_1", "question": "What is the winery at which the wine with the highest score was made?", "rationale": ["Identify the goal: Find the winery that produced the wine with the highest score.", "To find the highest score, a subquery is needed to select the maximum score from the 'wine' table.", "The main query will select the winery from the 'wine' table where the score matches the maximum score found in the subquery."], "gold_sql": "SELECT Winery FROM WINE ORDER BY SCORE LIMIT 1", "source_tables": ["wine"], "pred_sql": "SELECT Winery FROM wine WHERE Score = (SELECT MAX(Score) FROM wine)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of wines from the 'wine' table that have a score higher than a specified value. The placeholder in the WHERE clause represents the minimum score threshold for filtering the wines.\",\n        \"virtual_table\": \"SELECT Name FROM WINE WHERE score  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of wineries from the 'wine' table, ordered by their rating scores. The placeholder in the LIMIT clause represents the maximum number of wineries to be displayed.\",\n        \"virtual_table\": \"SELECT Winery FROM WINE ORDER BY SCORE LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the distinct names of wines from the 'wine' table, ordered by their retail price. The placeholder in the ORDER BY clause represents the price of the wines.\",\n        \"virtual_table\": \"SELECT DISTINCT Name FROM WINE ORDER BY price\"\n    }\n}\n"}
{"sample_id": "train.6533", "db_id": "wine_1", "question": "List the names of all distinct wines that are made of red color grape.", "rationale": ["We need to list the names of all distinct wines made from red color grapes.", "To achieve this, we will select the distinct names from the 'wine' table.", "We need to join the 'wine' table with the 'grapes' table to filter the wines based on the color of the grapes.", "The join condition will be on the grape variety, which is represented by the 'Grape' column in both tables.", "We will apply a WHERE clause to filter only those grapes that are red in color.", "Finally, we will order the results by the name of the wine."], "gold_sql": "SELECT DISTINCT T2.Name FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'Red'", "source_tables": ["wine", "grapes"], "pred_sql": "SELECT DISTINCT w.Name \nFROM wine w \nJOIN grapes g ON w.Grape = g.Grape \nWHERE g.Color = 'red' \nORDER BY w.Name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct names of wines from the 'wine' table, sorted in alphabetical order. The query uses the DISTINCT keyword to ensure that each wine name appears only once in the result set, and the ORDER BY clause organizes the names in ascending order.\",\n        \"virtual_table\": \"SELECT DISTINCT Name FROM WINE ORDER BY Name\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the distinct names of wines from the 'wine' table, ordered by their retail price. The placeholder in the ORDER BY clause represents the price of the wines.\",\n        \"virtual_table\": \"SELECT DISTINCT Name FROM WINE ORDER BY price\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of wineries from the 'wine' table, ordered by their rating scores. The placeholder in the LIMIT clause represents the maximum number of wineries to be displayed.\",\n        \"virtual_table\": \"SELECT Winery FROM WINE ORDER BY SCORE LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6544", "db_id": "wine_1", "question": "Give the names and scores of wines made from white grapes.", "rationale": ["Identify the tables needed: 'wine' for wine details and 'grapes' for grape color.", "We need to join the 'wine' table with the 'grapes' table on the Grape column to filter wines based on grape color.", "The condition specifies that we want wines made from white grapes, so we will filter where grapes.Color = 'white'.", "Select the Name and Score columns from the resulting joined table."], "gold_sql": "SELECT T2.Name ,   T2.Score FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'White'", "source_tables": ["wine", "grapes"], "pred_sql": "SELECT wine.Name, wine.Score \nFROM wine \nJOIN grapes ON wine.Grape = grapes.Grape \nWHERE grapes.Color = 'white';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of wines from the 'wine' table that have a score higher than a specified value. The placeholder in the WHERE clause represents the minimum score threshold for filtering the wines.\",\n        \"virtual_table\": \"SELECT Name FROM WINE WHERE score  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of wineries from the 'wine' table, ordered by their rating scores. The placeholder in the LIMIT clause represents the maximum number of wineries to be displayed.\",\n        \"virtual_table\": \"SELECT Winery FROM WINE ORDER BY SCORE LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the distinct names of wines from the 'wine' table, ordered by their retail price. The placeholder in the ORDER BY clause represents the price of the wines.\",\n        \"virtual_table\": \"SELECT DISTINCT Name FROM WINE ORDER BY price\"\n    }\n}\n"}
{"sample_id": "train.6547", "db_id": "wine_1", "question": "Find the the grape whose white color grapes are used to produce wines with scores higher than 90.", "rationale": ["Identify the grape varieties that are white in color.", "Join the 'grapes' table with the 'wine' table on the grape variety.", "Filter the results to include only those wines that have a score greater than 90.", "Select distinct grape names to avoid duplicates."], "gold_sql": "SELECT DISTINCT T1.Grape FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'White' AND T2.score  >  90", "source_tables": ["wine", "grapes"], "pred_sql": "SELECT DISTINCT grapes.Grape \nFROM grapes \nJOIN wine ON grapes.Grape = wine.Grape \nWHERE grapes.Color = 'white' \nAND wine.Score > 90;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of wines from the 'wine' table that have a score higher than a specified value. The placeholder in the WHERE clause represents the minimum score threshold for filtering the wines.\",\n        \"virtual_table\": \"SELECT Name FROM WINE WHERE score  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of wineries from the 'wine' table, ordered by their rating scores. The placeholder in the LIMIT clause represents the maximum number of wineries to be displayed.\",\n        \"virtual_table\": \"SELECT Winery FROM WINE ORDER BY SCORE LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the distinct names of wines from the 'wine' table, ordered by their retail price. The placeholder in the ORDER BY clause represents the price of the wines.\",\n        \"virtual_table\": \"SELECT DISTINCT Name FROM WINE ORDER BY price\"\n    }\n}\n"}
{"sample_id": "train.6550", "db_id": "wine_1", "question": "What are the names of wines made from red grapes and with prices above 50?", "rationale": ["Identify the relevant tables: 'wine' and 'grapes'.", "We need to filter wines based on grape color and price, so we will use a JOIN between 'wine' and 'grapes' on the Grape column.", "The condition for red grapes is specified as grapes.Color = 'red'.", "The condition for price is specified as wine.Price > 50.", "We need to select distinct names of wines that meet both conditions, so we will use SELECT DISTINCT wine.Name."], "gold_sql": "SELECT T2.Name FROM Grapes AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'Red' AND T2.price  >  50", "source_tables": ["wine", "grapes"], "pred_sql": "SELECT DISTINCT wine.Name \nFROM wine \nJOIN grapes ON wine.Grape = grapes.Grape \nWHERE grapes.Color = 'red' AND wine.Price > 50;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct names of wines from the 'wine' table, ordered by their retail price. The placeholder in the ORDER BY clause represents the price of the wines.\",\n        \"virtual_table\": \"SELECT DISTINCT Name FROM WINE ORDER BY price\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of wines from the 'wine' table that have a score higher than a specified value. The placeholder in the WHERE clause represents the minimum score threshold for filtering the wines.\",\n        \"virtual_table\": \"SELECT Name FROM WINE WHERE score  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of wineries from the 'wine' table, ordered by their rating scores. The placeholder in the LIMIT clause represents the maximum number of wineries to be displayed.\",\n        \"virtual_table\": \"SELECT Winery FROM WINE ORDER BY SCORE LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6558", "db_id": "wine_1", "question": "What are the distinct names of wines with prices higher than any wine from John Anthony winery.", "rationale": ["Identify the requirement to find distinct names of wines with prices higher than those from John Anthony winery.", "Use a subquery to find the maximum price of wines from John Anthony winery.", "The main query will select distinct names from the wine table where the price is greater than the maximum price obtained from the subquery."], "gold_sql": "SELECT DISTINCT Name FROM WINE WHERE Price  >  (SELECT min(Price) FROM wine WHERE Winery  =  'John Anthony')", "source_tables": ["wine"], "pred_sql": "SELECT DISTINCT Name FROM wine WHERE Price > (SELECT MAX(Price) FROM wine WHERE Winery = 'John Anthony')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct names of wines from the 'wine' table, ordered by their retail price. The placeholder in the ORDER BY clause represents the price of the wines.\",\n        \"virtual_table\": \"SELECT DISTINCT Name FROM WINE ORDER BY price\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the distinct names of wines from the 'wine' table, sorted in alphabetical order. The query uses the DISTINCT keyword to ensure that each wine name appears only once in the result set, and the ORDER BY clause organizes the names in ascending order.\",\n        \"virtual_table\": \"SELECT DISTINCT Name FROM WINE ORDER BY Name\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of wines from the 'wine' table that have a score higher than a specified value. The placeholder in the WHERE clause represents the minimum score threshold for filtering the wines.\",\n        \"virtual_table\": \"SELECT Name FROM WINE WHERE score  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6566", "db_id": "wine_1", "question": "Give the color of the grape whose wine products have the highest average price?", "rationale": ["Identify the relevant tables: 'grapes' for grape color and 'wine' for wine prices.", "Join the 'grapes' table with the 'wine' table on the grape variety to access both grape color and wine price.", "Group the results by grape color to calculate the average price of wines for each grape color.", "Order the results by the average price in descending order to find the highest average price.", "Limit the results to 1 to get only the color of the grape with the highest average price."], "gold_sql": "SELECT T1.Color FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape GROUP BY T2.Grape ORDER BY AVG(Price) DESC LIMIT 1", "source_tables": ["wine", "grapes"], "pred_sql": "SELECT g.Color \nFROM grapes g \nJOIN wine w ON g.Grape = w.Grape \nGROUP BY g.Color \nORDER BY AVG(w.Price) DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct names of wines from the 'wine' table, ordered by their retail price. The placeholder in the ORDER BY clause represents the price of the wines.\",\n        \"virtual_table\": \"SELECT DISTINCT Name FROM WINE ORDER BY price\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of wines from the 'wine' table that have a score higher than a specified value. The placeholder in the WHERE clause represents the minimum score threshold for filtering the wines.\",\n        \"virtual_table\": \"SELECT Name FROM WINE WHERE score  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the distinct names of wines from the 'wine' table, sorted in alphabetical order. The query uses the DISTINCT keyword to ensure that each wine name appears only once in the result set, and the ORDER BY clause organizes the names in ascending order.\",\n        \"virtual_table\": \"SELECT DISTINCT Name FROM WINE ORDER BY Name\"\n    }\n}\n"}
{"sample_id": "train.6588", "db_id": "wine_1", "question": "Which 3 wineries produce the most wines made from white grapes?", "rationale": ["Identify the relevant tables: 'wine' and 'grapes'.", "We need to filter wines made from white grapes, so we will join the 'wine' table with the 'grapes' table on the Grape column.", "Use a WHERE clause to filter for white grapes by checking the Color column in the 'grapes' table.", "Group the results by Winery to count how many wines each winery produces.", "Order the results by the count of wines in descending order to find the top producers.", "Limit the results to 3 to get only the top 3 wineries."], "gold_sql": "SELECT T2.Winery FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.GRAPE  =  T2.GRAPE WHERE T1.Color  =  'White' GROUP BY T2.Winery ORDER BY count(*) DESC LIMIT 3", "source_tables": ["wine", "grapes"], "pred_sql": "SELECT Winery, COUNT(*) as WineCount \nFROM wine \nJOIN grapes ON wine.Grape = grapes.Grape \nWHERE grapes.Color = 'white' \nGROUP BY Winery \nORDER BY WineCount DESC \nLIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of wineries from the 'wine' table, ordered by their rating scores. The placeholder in the LIMIT clause represents the maximum number of wineries to be displayed.\",\n        \"virtual_table\": \"SELECT Winery FROM WINE ORDER BY SCORE LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the distinct names of wines from the 'wine' table, ordered by their retail price. The placeholder in the ORDER BY clause represents the price of the wines.\",\n        \"virtual_table\": \"SELECT DISTINCT Name FROM WINE ORDER BY price\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the distinct names of wines from the 'wine' table, sorted in alphabetical order. The query uses the DISTINCT keyword to ensure that each wine name appears only once in the result set, and the ORDER BY clause organizes the names in ascending order.\",\n        \"virtual_table\": \"SELECT DISTINCT Name FROM WINE ORDER BY Name\"\n    }\n}\n"}
{"sample_id": "train.6597", "db_id": "wine_1", "question": "Find the county where produces the most number of wines with score higher than 90.", "rationale": ["We need to find the county that produces the most wines with a score higher than 90.", "To do this, we will join the 'wine' table with the 'appellations' table on the Appelation column to access the county information.", "We will filter the wines to only include those with a score greater than 90 using a WHERE clause.", "Next, we will group the results by County to count the number of wines in each county using COUNT(*).", "Finally, we will order the results by the count of wines in descending order and limit the results to 1 to get the county with the most wines."], "gold_sql": "SELECT T1.County FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T2.Score  >  90 GROUP BY T1.County ORDER BY count(*) DESC LIMIT 1", "source_tables": ["wine", "appellations"], "pred_sql": "SELECT County, COUNT(*) as WineCount \nFROM wine \nJOIN appellations ON wine.Appelation = appellations.Appelation \nWHERE wine.Score > 90 \nGROUP BY County \nORDER BY WineCount DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of wines from the 'wine' table that have a score higher than a specified value. The placeholder in the WHERE clause represents the minimum score threshold for filtering the wines.\",\n        \"virtual_table\": \"SELECT Name FROM WINE WHERE score  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of wineries from the 'wine' table, ordered by their rating scores. The placeholder in the LIMIT clause represents the maximum number of wineries to be displayed.\",\n        \"virtual_table\": \"SELECT Winery FROM WINE ORDER BY SCORE LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the distinct names of wines from the 'wine' table, ordered by their retail price. The placeholder in the ORDER BY clause represents the price of the wines.\",\n        \"virtual_table\": \"SELECT DISTINCT Name FROM WINE ORDER BY price\"\n    }\n}\n"}
{"sample_id": "train.6626", "db_id": "driving_school", "question": "Show the detail of vehicle with id 1.", "rationale": ["The user wants to see the details of a specific vehicle identified by its ID, which is '1'.", "To retrieve this information, we need to select the 'vehicle_details' column from the 'Vehicles' table.", "We will filter the results using a WHERE clause to specify that we only want the vehicle with 'vehicle_id' equal to '1'.", "The final SQL query will be constructed accordingly."], "gold_sql": "SELECT vehicle_details FROM Vehicles WHERE vehicle_id = 1;", "source_tables": ["vehicles"], "pred_sql": "SELECT vehicle_details FROM Vehicles WHERE vehicle_id = '1';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the details of a specific vehicle from the 'Vehicles' table based on its unique identifier. The placeholder in the WHERE clause represents the vehicle's ID.\",\n        \"virtual_table\": \"SELECT vehicle_details FROM Vehicles WHERE vehicle_id = [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.6650", "db_id": "driving_school", "question": "How many staff live in state Georgia?", "rationale": ["Identify the relevant tables: Staff and Addresses.", "Determine the relationship between Staff and Addresses using the foreign key (staff_address_id).", "Count the number of staff members who live in Georgia by filtering the Addresses table on the state_province_county column.", "Construct the SQL query to count the staff based on the specified condition."], "gold_sql": "SELECT count(*) FROM Addresses WHERE state_province_county = 'Georgia';", "source_tables": ["addresses"], "pred_sql": "SELECT COUNT(*) AS staff_count \nFROM Staff \nJOIN Addresses ON Staff.staff_address_id = Addresses.address_id \nWHERE Addresses.state_province_county = 'Georgia';", "hint": "\n"}
{"sample_id": "train.6665", "db_id": "driving_school", "question": "What is the status code, phone number, and email address of the customer whose last name is Kohler or whose first name is Marina?", "rationale": ["Identify the relevant table: The question pertains to customer information, so we will use the Customers table.", "Determine the required columns: The question asks for the status code, phone number, and email address of the customer.", "Formulate the WHERE clause: We need to filter customers based on their last name being 'Kohler' or their first name being 'Marina'.", "Construct the SQL SELECT statement: We will select the specified columns from the Customers table with the appropriate conditions."], "gold_sql": "SELECT customer_status_code ,  cell_mobile_phone_number ,  email_address FROM Customers WHERE first_name = 'Marina' OR last_name  =  'Kohler'", "source_tables": ["customers"], "pred_sql": "SELECT customer_status_code, phone_number, email_address FROM Customers WHERE last_name = 'Kohler' OR first_name = 'Marina';", "hint": "\n"}
{"sample_id": "train.6676", "db_id": "driving_school", "question": "How many lessons taken by customer with first name as Rylan and last name as Goodwin were completed?", "rationale": ["Identify the relevant tables: Lessons and Customers.", "We need to count the number of lessons, so we will use the COUNT() function.", "We need to filter lessons based on the customer's first name and last name, which are in the Customers table.", "We will join the Lessons table with the Customers table on the customer_id field to access customer details.", "We will also filter the lessons to only include those that have a status of 'completed'.", "Construct the SQL query using SELECT, JOIN, WHERE, and COUNT functions."], "gold_sql": "SELECT count(*) FROM Lessons AS T1 JOIN Customers AS T2 ON T1.customer_id  = T2.customer_id WHERE T2.first_name = 'Rylan' AND T2.last_name = 'Goodwin' AND T1.lesson_status_code = 'Completed';", "source_tables": ["lessons", "customers"], "pred_sql": "SELECT COUNT(*) AS completed_lessons_count\nFROM Lessons\nJOIN Customers ON Lessons.customer_id = Customers.customer_id\nWHERE Customers.first_name = 'Rylan' AND Customers.last_name = 'Goodwin' AND Lessons.lesson_status_code = 'completed';", "hint": "\n"}
{"sample_id": "train.6688", "db_id": "driving_school", "question": "Which city does has most number of customers?", "rationale": ["Identify the relevant tables: We need to find the city with the most customers, so we will use the Addresses and Customers tables.", "Join the tables: We will join the Addresses table with the Customers table on the address_id to link customers to their respective addresses.", "Group by city: We will group the results by city to count the number of customers in each city.", "Count customers: Use COUNT(customer_id) to count the number of customers in each city.", "Order by count: We will order the results in descending order based on the customer count to get the city with the most customers at the top.", "Limit results: Finally, we will limit the results to 1 to get only the city with the highest count."], "gold_sql": "SELECT T2.city FROM Customers AS T1 JOIN Addresses AS T2 ON T1.customer_address_id = T2.address_id GROUP BY T2.city ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["addresses", "customers"], "pred_sql": "SELECT city, COUNT(customer_id) AS customer_count\nFROM Addresses\nJOIN Customers ON Addresses.address_id = Customers.customer_address_id\nGROUP BY city\nORDER BY customer_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6711", "db_id": "driving_school", "question": "What are the last names that are used by customers and staff?", "rationale": ["Identify the tables that contain last names: Customers and Staff.", "Select the last_name column from the Customers table.", "Select the last_name column from the Staff table.", "Use UNION to combine the results from both tables, ensuring distinct last names are returned."], "gold_sql": "SELECT last_name FROM Customers INTERSECT SELECT last_name FROM Staff", "source_tables": ["staff", "customers"], "pred_sql": "SELECT DISTINCT last_name FROM Customers UNION SELECT DISTINCT last_name FROM Staff;", "hint": "\n"}
{"sample_id": "train.6714", "db_id": "driving_school", "question": "What is the id and detail of the vehicle used in lessons for most of the times?", "rationale": ["Identify the relevant tables: Vehicles and Lessons.", "Determine the relationship between vehicles and lessons: Each lesson is associated with a vehicle through vehicle_id.", "To find the vehicle used in lessons the most times, we need to count the occurrences of each vehicle_id in the Lessons table.", "Use a subquery to group by vehicle_id in the Lessons table and count the number of lessons for each vehicle.", "Order the results by the count in descending order to get the most used vehicle at the top.", "Limit the results to 1 to get only the vehicle used the most times.", "Select the vehicle_id and vehicle_details from the Vehicles table where the vehicle_id matches the one found in the subquery."], "gold_sql": "SELECT T1.vehicle_id ,  T1.vehicle_details FROM Vehicles AS T1 JOIN Lessons AS T2 ON T1.vehicle_id  =  T2.vehicle_id GROUP BY T1.vehicle_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["lessons", "vehicles"], "pred_sql": "SELECT vehicle_id, vehicle_details FROM Vehicles WHERE vehicle_id IN (SELECT vehicle_id FROM Lessons GROUP BY vehicle_id ORDER BY COUNT(*) DESC LIMIT 1);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the details of a specific vehicle from the 'Vehicles' table based on its unique identifier. The placeholder in the WHERE clause represents the vehicle's ID.\",\n        \"virtual_table\": \"SELECT vehicle_details FROM Vehicles WHERE vehicle_id = [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.6725", "db_id": "activity_1", "question": "Show ids for all the male faculty.", "rationale": ["Identify the relevant table: The 'Faculty' table contains information about faculty members, including their gender.", "Determine the required data: The query asks for the IDs of all male faculty members, which corresponds to the 'FacID' column in the 'Faculty' table.", "Construct the SQL query: Use a SELECT statement to retrieve 'FacID' from the 'Faculty' table where the 'Sex' column equals 'Male'."], "gold_sql": "SELECT FacID FROM Faculty WHERE Sex  =  'M'", "source_tables": ["faculty"], "pred_sql": "SELECT FacID FROM Faculty WHERE Sex = 'Male'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the unique identifiers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.\",\n        \"virtual_table\": \"SELECT FacID FROM Faculty WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of faculty members who participate in activities, filtered by the first and last names of the faculty member. The placeholders in the WHERE clause represent the first and last names of the faculty member being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6734", "db_id": "activity_1", "question": "What are the first name and last name of all the instructors?", "rationale": ["Identify the table that contains instructor information, which is the Faculty table.", "Determine the columns needed for the output, which are the first name (Fname) and last name (Lname) of the instructors.", "Construct the SQL SELECT statement to retrieve Fname and Lname from the Faculty table."], "gold_sql": "SELECT fname ,  lname FROM Faculty WHERE Rank  =  'Instructor'", "source_tables": ["faculty"], "pred_sql": "SELECT Fname, Lname FROM Faculty;", "hint": "\n"}
{"sample_id": "train.6737", "db_id": "activity_1", "question": "Which building has most faculty members?", "rationale": ["We need to find out which building has the most faculty members.", "To do this, we will count the number of faculty members in each building.", "We will use the COUNT() function to count the number of faculty members grouped by the 'Building' column.", "We will group the results by 'Building' to get the count for each building.", "To find the building with the most faculty members, we will order the results in descending order based on the count.", "Finally, we will limit the results to only one record to get the building with the highest count."], "gold_sql": "SELECT building FROM Faculty GROUP BY building ORDER BY count(*) DESC LIMIT 1", "source_tables": ["faculty"], "pred_sql": "SELECT Building, COUNT(*) AS FacultyCount \nFROM Faculty \nGROUP BY Building \nORDER BY FacultyCount DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of faculty members who participate in activities, filtered by the first and last names of the faculty member. The placeholders in the WHERE clause represent the first and last names of the faculty member being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6747", "db_id": "activity_1", "question": "Show the number of male and female assistant professors.", "rationale": ["Identify the relevant table: Faculty, which contains information about faculty members including their rank and gender.", "Filter the faculty members to only include those with the rank of 'Assistant Professor'.", "Group the results by the 'Sex' column to count the number of male and female assistant professors separately.", "Use the COUNT function to get the number of faculty members for each gender."], "gold_sql": "SELECT sex ,  count(*) FROM Faculty WHERE rank  =  'AsstProf' GROUP BY sex", "source_tables": ["faculty"], "pred_sql": "SELECT Sex, COUNT(*) as count \nFROM Faculty \nWHERE Rank = 'Assistant Professor' \nGROUP BY Sex;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the unique identifiers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.\",\n        \"virtual_table\": \"SELECT FacID FROM Faculty WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of faculty members who participate in activities, filtered by the first and last names of the faculty member. The placeholders in the WHERE clause represent the first and last names of the faculty member being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6748", "db_id": "activity_1", "question": "How many male and female assistant professors do we have?", "rationale": ["Identify the relevant table: Faculty.", "Determine the criteria for filtering: Rank should be 'Assistant Professor'.", "Group the results by gender (Sex) to count the number of male and female assistant professors.", "Use the COUNT function to get the number of faculty members for each gender."], "gold_sql": "SELECT sex ,  count(*) FROM Faculty WHERE rank  =  'AsstProf' GROUP BY sex", "source_tables": ["faculty"], "pred_sql": "SELECT Sex, COUNT(*) as Count \nFROM Faculty \nWHERE Rank = 'Assistant Professor' \nGROUP BY Sex;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the unique identifiers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.\",\n        \"virtual_table\": \"SELECT FacID FROM Faculty WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6750", "db_id": "activity_1", "question": "Who is the advisor of Linda Smith? Give me the first name and last name.", "rationale": ["Identify the tables involved: We need to find the advisor of a student named Linda Smith, which involves the Student and Faculty tables.", "Determine the relationship: The Student table has a column 'Advisor' that references the 'FacID' in the Faculty table, indicating which faculty member is the advisor for each student.", "Construct the SQL query: We will select the first name and last name of the faculty member from the Faculty table where the Faculty's ID matches the Advisor ID of Linda Smith in the Student table.", "Add conditions: We need to filter the results to only include the student with the first name 'Linda' and last name 'Smith'."], "gold_sql": "SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T2.fname  =  'Linda' AND T2.lname  =  'Smith'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT Faculty.Fname, Faculty.Lname \nFROM Faculty \nJOIN Student ON Faculty.FacID = Student.Advisor \nWHERE Student.Fname = 'Linda' AND Student.LName = 'Smith';", "hint": "\n"}
{"sample_id": "train.6751", "db_id": "activity_1", "question": "Show the ids of students whose advisors are professors.", "rationale": ["Identify the relevant tables: We need to find students and their advisors, so we will use the Student and Faculty tables.", "Determine the relationship: The Student table has a column 'Advisor' that references 'FacID' in the Faculty table, indicating which faculty member is the advisor for each student.", "Construct the SQL query: We will select the distinct student IDs (StuID) from the Student table where there is a matching faculty member in the Faculty table based on the Advisor relationship."], "gold_sql": "SELECT T2.StuID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.rank  =  'Professor'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT DISTINCT Student.StuID \nFROM Student \nJOIN Faculty ON Student.Advisor = Faculty.FacID;", "hint": "\n"}
{"sample_id": "train.6752", "db_id": "activity_1", "question": "Which students have professors as their advisors? Find their student ids.", "rationale": ["Identify the relevant tables: We need to find students and their advisors, so we will use the Student and Faculty tables.", "Determine the relationship: The Student table has a column 'Advisor' that corresponds to 'FacID' in the Faculty table, indicating which faculty member is the advisor for each student.", "Construct the SQL query: We will select the student IDs from the Student table and join it with the Faculty table on the Advisor and FacID columns."], "gold_sql": "SELECT T2.StuID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.rank  =  'Professor'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT Student.StuID \nFROM Student \nJOIN Faculty ON Student.Advisor = Faculty.FacID;", "hint": "\n"}
{"sample_id": "train.6753", "db_id": "activity_1", "question": "Show first name and last name for all the students advised by Michael Goodrich.", "rationale": ["Identify the information needed: first name and last name of students advised by Michael Goodrich.", "Determine the relationship between students and their advisors: the Student table has an 'Advisor' column that links to the Faculty table.", "Find the Faculty ID of Michael Goodrich: use a subquery to select the FacID from the Faculty table where Fname is 'Michael' and Lname is 'Goodrich'.", "Use the Advisor column in the Student table to filter students who have Michael Goodrich as their advisor.", "Construct the SQL query to select Fname and LName from the Student table where Advisor matches the FacID of Michael Goodrich."], "gold_sql": "SELECT T2.fname ,  T2.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.fname  =  'Michael' AND T1.lname  =  'Goodrich'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT Fname, LName \nFROM Student \nWHERE Advisor = (SELECT StuID FROM Faculty WHERE Fname = 'Michael' AND Lname = 'Goodrich');", "hint": "\n"}
{"sample_id": "train.6756", "db_id": "activity_1", "question": "What are the faculty id and the number of students each faculty has?", "rationale": ["We need to find the faculty ID and the number of students each faculty has.", "To do this, we will join the Faculty table with the Faculty_Participates_in table to get the activities each faculty member participates in.", "Next, we will join the result with the Participates_in table to count how many students are participating in those activities.", "Finally, we will group the results by faculty ID to get the count of students for each faculty member."], "gold_sql": "SELECT T1.FacID ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID", "source_tables": ["faculty", "student"], "pred_sql": "SELECT F.FacID, COUNT(P.stuid) AS student_count \nFROM Faculty AS F \nJOIN Faculty_Participates_in AS FP ON F.FacID = FP.FacID \nJOIN Participates_in AS P ON FP.actid = P.actid \nGROUP BY F.FacID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the unique identifiers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.\",\n        \"virtual_table\": \"SELECT FacID FROM Faculty WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of faculty members who participate in activities, filtered by the first and last names of the faculty member. The placeholders in the WHERE clause represent the first and last names of the faculty member being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6758", "db_id": "activity_1", "question": "How many students are advised by each rank of faculty? List the rank and the number of students.", "rationale": ["Identify the tables needed: Faculty and Student.", "We need to count the number of students advised by each faculty member, which requires joining the Faculty table with the Student table on the Advisor field.", "Select the Rank from the Faculty table and count the unique student IDs from the Student table.", "Group the results by the Rank of the faculty to get the count of students for each rank."], "gold_sql": "SELECT T1.rank ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.rank", "source_tables": ["faculty", "student"], "pred_sql": "SELECT F.Rank, COUNT(S.StuID) AS NumberOfStudents \nFROM Faculty AS F \nJOIN Student AS S ON S.Advisor = F.FacID \nGROUP BY F.Rank;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of faculty members who participate in activities, filtered by the first and last names of the faculty member. The placeholders in the WHERE clause represent the first and last names of the faculty member being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6761", "db_id": "activity_1", "question": "Show the ids for all the faculty members who have at least 2 students.", "rationale": ["We need to find faculty members who have at least 2 students.", "To do this, we will use the Faculty_Participates_in table, which links faculty members to activities and indirectly to students.", "We will group the results by FacID and count the distinct student IDs (stuid) for each faculty member.", "Using the HAVING clause, we will filter the groups to only include those with a count of 2 or more students.", "Finally, we will select the FacID from the Faculty table where the FacID is in the filtered results."], "gold_sql": "SELECT T1.FacID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID HAVING count(*)  >=  2", "source_tables": ["faculty", "student"], "pred_sql": "SELECT FacID FROM Faculty WHERE FacID IN (SELECT FacID FROM Faculty_Participates_in GROUP BY FacID HAVING COUNT(DISTINCT stuid) >= 2)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of faculty members who participate in activities, filtered by the first and last names of the faculty member. The placeholders in the WHERE clause represent the first and last names of the faculty member being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the unique identifiers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.\",\n        \"virtual_table\": \"SELECT FacID FROM Faculty WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6777", "db_id": "activity_1", "question": "Show the names of all the activities Mark Giuliano participates in.", "rationale": ["Identify the tables involved: Activity, Participates_in, and Student.", "We need to retrieve the activity names, so we will select 'activity_name' from the Activity table.", "To find out which activities Mark Giuliano participates in, we need to join the Activity table with the Participates_in table on 'actid'.", "Next, we need to join the Participates_in table with the Student table on 'stuid' to filter by student name.", "In the WHERE clause, we will specify the first name as 'Mark' and the last name as 'Giuliano' to get the specific student's activities."], "gold_sql": "SELECT T3.activity_name FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN Activity AS T3 ON T3.actid  =  T2.actid WHERE T1.fname  =  'Mark' AND T1.lname  =  'Giuliano'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT activity_name \nFROM Activity AS A \nJOIN Participates_in AS P ON A.actid = P.actid \nJOIN Student AS S ON P.stuid = S.StuID \nWHERE S.Fname = 'Mark' AND S.LName = 'Giuliano';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of activities from the 'Activity' table. The placeholder can be used to filter or join with other tables if needed.\",\n        \"virtual_table\": \"SELECT activity_name FROM Activity\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of activities from the 'Activity' table. The placeholder can be used to filter or join with other tables if needed.\",\n        \"virtual_table\": \"SELECT activity_name FROM Activity\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of faculty members who participate in activities, filtered by the first and last names of the faculty member. The placeholders in the WHERE clause represent the first and last names of the faculty member being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6779", "db_id": "activity_1", "question": "Show the first and last name of all the faculty members who participated in some activity, together with the number of activities they participated in.", "rationale": ["Identify the tables needed: Faculty and Faculty_Participates_in.", "We need to select the first name (Fname) and last name (Lname) of faculty members from the Faculty table.", "We also need to count the number of activities each faculty member participated in, which requires joining the Faculty table with the Faculty_Participates_in table on the FacID.", "Use a JOIN clause to combine the Faculty table with the Faculty_Participates_in table based on the FacID.", "Group the results by faculty member's ID, first name, and last name to get the count of activities for each faculty member.", "Select the first name, last name, and the count of activities in the final output."], "gold_sql": "SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID", "source_tables": ["faculty", "faculty_participates_in"], "pred_sql": "SELECT F.Fname, F.Lname, COUNT(FPI.actid) AS activity_count\nFROM Faculty AS F\nJOIN Faculty_Participates_in AS FPI ON F.FacID = FPI.FacID\nGROUP BY F.FacID, F.Fname, F.Lname;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of faculty members who participate in activities, filtered by the first and last names of the faculty member. The placeholders in the WHERE clause represent the first and last names of the faculty member being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6789", "db_id": "activity_1", "question": "Show the ids for all the students who participate in an activity and are under 20.", "rationale": ["Identify the relevant tables: We need to find students who participate in activities, so we will use the 'Participates_in' and 'Student' tables.", "Determine the criteria: We are looking for students under the age of 20.", "Construct a subquery to filter students: We will create a subquery that selects 'StuID' from the 'Student' table where 'Age' is less than 20.", "Use the subquery in the main query: The main query will select 'stuid' from 'Participates_in' where 'stuid' is in the results of the subquery."], "gold_sql": "SELECT StuID FROM Participates_in INTERSECT SELECT StuID FROM Student WHERE age  <  20", "source_tables": ["student", "participates_in"], "pred_sql": "SELECT stuid FROM Participates_in WHERE stuid IN (SELECT StuID FROM Student WHERE Age < 20);", "hint": "\n"}
{"sample_id": "train.6797", "db_id": "activity_1", "question": "Find the first names of professors who are not playing Canoeing or Kayaking.", "rationale": ["We need to find the first names of professors who are not participating in the activities 'Canoeing' or 'Kayaking'.", "To achieve this, we will select the first names from the Faculty table.", "We will perform a LEFT JOIN with the Faculty_Participates_in table to get the activities that each faculty member participates in.", "Next, we will perform another LEFT JOIN with the Activity table to get the names of those activities.", "In the WHERE clause, we will filter out the activities that are either 'Canoeing' or 'Kayaking'.", "We also include a condition to allow for faculty members who do not participate in any activities (i.e., where the activity name is NULL)."], "gold_sql": "SELECT lname FROM faculty WHERE rank  =  'Professor' EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT F.Fname \nFROM Faculty AS F \nLEFT JOIN Faculty_Participates_in AS FP ON F.FacID = FP.FacID \nLEFT JOIN Activity AS A ON FP.actid = A.actid \nWHERE A.activity_name NOT IN ('Canoeing', 'Kayaking') OR A.activity_name IS NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of faculty members who participate in activities, filtered by the first and last names of the faculty member. The placeholders in the WHERE clause represent the first and last names of the faculty member being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6798", "db_id": "activity_1", "question": "What are the first names of the professors who do not play Canoeing or Kayaking as activities?", "rationale": ["Identify the main entities involved: Faculty and Activities.", "We need to find faculty members who do not participate in specific activities (Canoeing and Kayaking).", "To achieve this, we will use a subquery to find all faculty IDs that participate in Canoeing or Kayaking.", "The subquery will join the Faculty_Participates_in table with the Activity table to filter by activity names.", "The main query will select the first names of faculty members whose IDs are not in the result of the subquery."], "gold_sql": "SELECT lname FROM faculty WHERE rank  =  'Professor' EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT F.Fname \nFROM Faculty F \nWHERE F.FacID NOT IN (\n    SELECT FP.FacID \n    FROM Faculty_Participates_in FP \n    JOIN Activity A ON FP.actid = A.actid \n    WHERE A.activity_name IN ('Canoeing', 'Kayaking')\n);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of faculty members who participate in activities, filtered by the first and last names of the faculty member. The placeholders in the WHERE clause represent the first and last names of the faculty member being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6799", "db_id": "activity_1", "question": "Find the first names of the faculty members who participate in Canoeing and Kayaking.", "rationale": ["Identify the tables needed: Faculty, Faculty_Participates_in, and Activity.", "We need to find faculty members who participate in specific activities (Canoeing and Kayaking).", "Join the Faculty table with the Faculty_Participates_in table on FacID to get the activities they participate in.", "Join the result with the Activity table on actid to filter by activity names.", "Use a WHERE clause to specify that we are interested in activities named 'Canoeing' or 'Kayaking'.", "Select the first names of the faculty members from the resulting joined table."], "gold_sql": "SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' INTERSECT SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT F.Fname \nFROM Faculty AS F \nJOIN Faculty_Participates_in AS FP ON F.FacID = FP.FacID \nJOIN Activity AS A ON FP.actid = A.actid \nWHERE A.activity_name IN ('Canoeing', 'Kayaking');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of faculty members who participate in activities, filtered by the first and last names of the faculty member. The placeholders in the WHERE clause represent the first and last names of the faculty member being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6801", "db_id": "activity_1", "question": "Find the ids of the students who participate in Canoeing and Kayaking.", "rationale": ["Identify the tables involved: We need to find student IDs from the Participates_in table and match them with activities in the Activity table.", "Determine the relationship: The Participates_in table has a foreign key actid that links to the Activity table's actid, allowing us to join these tables.", "Specify the activities of interest: We are looking for students who participate in 'Canoeing' and 'Kayaking'.", "Construct the SQL query: Use a SELECT statement to retrieve student IDs from Participates_in, join it with Activity on actid, and filter results where activity_name is either 'Canoeing' or 'Kayaking'."], "gold_sql": "SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  'Canoeing' INTERSECT SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  'Kayaking'", "source_tables": ["activity", "participates_in"], "pred_sql": "SELECT p.stuid \nFROM Participates_in p \nJOIN Activity a ON p.actid = a.actid \nWHERE a.activity_name IN ('Canoeing', 'Kayaking');", "hint": "\n"}
{"sample_id": "train.6825", "db_id": "flight_4", "question": "Find the number of routes operated by American Airlines.", "rationale": ["Identify the relevant tables: 'routes' for routes and 'airlines' for airline information.", "We need to count the number of routes operated by a specific airline, which is 'American Airlines'.", "Join the 'routes' table with the 'airlines' table on the airline ID (alid).", "Filter the results to only include routes operated by 'American Airlines'.", "Use the COUNT function to get the total number of routes that meet these criteria."], "gold_sql": "SELECT count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid WHERE T1.name  =  'American Airlines'", "source_tables": ["routes", "airlines"], "pred_sql": "SELECT count(*) FROM routes AS T1 JOIN airlines AS T2 ON T1.alid = T2.alid WHERE T2.name = 'American Airlines'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of routes that lead to airports located in a specific country and are operated by a particular airline. The placeholders in the WHERE clause represent the country and airline name respectively.\",\n        \"virtual_table\": \"SELECT count(*) FROM routes AS T1 JOIN airports AS T2 ON T1.dst_apid  =  T2.apid JOIN airlines AS T3 ON T1.alid  =  T3.alid WHERE T2.country  =  [PLACEHOLDER-TYPE:STRING] AND T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of routes that lead to a specific destination airport from the 'airports' and 'routes' tables. The placeholder in the WHERE clause represents the name of the destination airport.\",\n        \"virtual_table\": \"SELECT count(*) FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6826", "db_id": "flight_4", "question": "How many routes does American Airlines operate?", "rationale": ["Identify the relevant tables: 'routes' for routes and 'airlines' for airline information.", "Determine the relationship between the tables: 'routes' has a foreign key 'alid' that links to 'airlines'.", "We need to count the number of routes operated by 'American Airlines'.", "Use the COUNT function to get the total number of routes.", "Construct the SQL query to join 'routes' and 'airlines' on the airline ID and filter by the airline name 'American Airlines'."], "gold_sql": "SELECT count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid WHERE T1.name  =  'American Airlines'", "source_tables": ["routes", "airlines"], "pred_sql": "SELECT count(*) FROM routes AS T1 JOIN airlines AS T2 ON T1.alid = T2.alid WHERE T2.name = 'American Airlines'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of routes that lead to airports located in a specific country and are operated by a particular airline. The placeholders in the WHERE clause represent the country and airline name respectively.\",\n        \"virtual_table\": \"SELECT count(*) FROM routes AS T1 JOIN airports AS T2 ON T1.dst_apid  =  T2.apid JOIN airlines AS T3 ON T1.alid  =  T3.alid WHERE T2.country  =  [PLACEHOLDER-TYPE:STRING] AND T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of routes that lead to a specific destination airport from the 'airports' and 'routes' tables. The placeholder in the WHERE clause represents the name of the destination airport.\",\n        \"virtual_table\": \"SELECT count(*) FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6831", "db_id": "flight_4", "question": "Find the name, city, and country of the airport that has the highest latitude.", "rationale": ["Identify the relevant table: The question asks for information about airports, so we will focus on the 'airports' table.", "Determine the required fields: We need to select the 'name', 'city', and 'country' of the airport.", "Find the airport with the highest latitude: In the 'airports' table, the latitude is represented by the 'y' coordinate. To find the highest latitude, we will order the results by 'y' in descending order.", "Limit the results to one: Since we only want the airport with the highest latitude, we will use 'LIMIT 1' to get just that record."], "gold_sql": "SELECT name ,  city ,  country FROM airports ORDER BY elevation DESC LIMIT 1", "source_tables": ["airports"], "pred_sql": "SELECT name, city, country FROM airports ORDER BY y DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of routes that lead to airports located in a specific country and are operated by a particular airline. The placeholders in the WHERE clause represent the country and airline name respectively.\",\n        \"virtual_table\": \"SELECT count(*) FROM routes AS T1 JOIN airports AS T2 ON T1.dst_apid  =  T2.apid JOIN airlines AS T3 ON T1.alid  =  T3.alid WHERE T2.country  =  [PLACEHOLDER-TYPE:STRING] AND T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the country of airlines from the 'airlines' table that match a specific name pattern. The placeholder in the WHERE clause allows for flexible searching of airline names.\",\n        \"virtual_table\": \"SELECT country FROM airlines WHERE name LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6834", "db_id": "flight_4", "question": "What is the name and city of the airport that the most routes end at?", "rationale": ["We need to find the airport that has the most routes ending at it.", "To do this, we will join the 'airports' table with the 'routes' table on the destination airport ID ('dst_apid').", "We will group the results by the airport ID ('apid') to count the number of routes for each airport.", "We will order the results in descending order based on the count of routes to get the airport with the most routes at the top.", "Finally, we will limit the results to just one record to get the airport with the most routes. We will select the airport's name and city in the final output."], "gold_sql": "SELECT T1.name ,  T1.city ,  T2.dst_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid GROUP BY T2.dst_apid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "pred_sql": "SELECT airports.name, airports.city FROM airports JOIN routes ON airports.apid = routes.dst_apid GROUP BY airports.apid ORDER BY COUNT(routes.rid) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of routes that lead to airports located in a specific country and are operated by a particular airline. The placeholders in the WHERE clause represent the country and airline name respectively.\",\n        \"virtual_table\": \"SELECT count(*) FROM routes AS T1 JOIN airports AS T2 ON T1.dst_apid  =  T2.apid JOIN airlines AS T3 ON T1.alid  =  T3.alid WHERE T2.country  =  [PLACEHOLDER-TYPE:STRING] AND T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of routes that lead to a specific destination airport from the 'airports' and 'routes' tables. The placeholder in the WHERE clause represents the name of the destination airport.\",\n        \"virtual_table\": \"SELECT count(*) FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of airports from the 'airports' table that match a specific name pattern. The placeholder in the WHERE clause allows for dynamic input of the airport name to filter the results accordingly.\",\n        \"virtual_table\": \"SELECT count(*) FROM airports WHERE name LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6838", "db_id": "flight_4", "question": "What is the name and city of the airport from most of the routes start?", "rationale": ["Identify the relevant tables: We need to get information about airports and the routes they serve, specifically focusing on the source airports.", "Determine the columns needed: We need the name and city of the airport, which are found in the airports table.", "Join the routes and airports tables: We will join these tables on the source airport ID (src_apid) to link routes to their respective source airports.", "Group by source airport: To find out which airport is the starting point for most routes, we will group the results by src_apid.", "Count the number of routes per airport: We will use COUNT() to count how many routes start from each airport.", "Order by the count of routes: We will order the results in descending order to get the airport with the most routes at the top.", "Limit the results to one: Since we only want the airport that starts the most routes, we will limit our results to 1."], "gold_sql": "SELECT T1.name ,  T1.city ,  T2.src_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T2.src_apid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "pred_sql": "SELECT airports.name, airports.city\nFROM routes\nJOIN airports ON routes.src_apid = airports.apid\nGROUP BY routes.src_apid\nORDER BY COUNT(routes.rid) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of routes that lead to airports located in a specific country and are operated by a particular airline. The placeholders in the WHERE clause represent the country and airline name respectively.\",\n        \"virtual_table\": \"SELECT count(*) FROM routes AS T1 JOIN airports AS T2 ON T1.dst_apid  =  T2.apid JOIN airlines AS T3 ON T1.alid  =  T3.alid WHERE T2.country  =  [PLACEHOLDER-TYPE:STRING] AND T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of routes that lead to a specific destination airport from the 'airports' and 'routes' tables. The placeholder in the WHERE clause represents the name of the destination airport.\",\n        \"virtual_table\": \"SELECT count(*) FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6841", "db_id": "flight_4", "question": "Which countries has the most number of airlines?", "rationale": ["We need to find out which countries have the most number of airlines.", "To do this, we will query the 'airlines' table, which contains information about each airline and its country.", "We will count the number of airlines for each country using the COUNT() function.", "We will group the results by country using GROUP BY clause to aggregate the counts per country.", "Finally, we will order the results in descending order based on the count of airlines using ORDER BY clause."], "gold_sql": "SELECT country FROM airlines GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airlines"], "pred_sql": "SELECT country, COUNT(*) AS airline_count \nFROM airlines \nWHERE active = 1 \nGROUP BY country \nORDER BY airline_count DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of routes that lead to airports located in a specific country and are operated by a particular airline. The placeholders in the WHERE clause represent the country and airline name respectively.\",\n        \"virtual_table\": \"SELECT count(*) FROM routes AS T1 JOIN airports AS T2 ON T1.dst_apid  =  T2.apid JOIN airlines AS T3 ON T1.alid  =  T3.alid WHERE T2.country  =  [PLACEHOLDER-TYPE:STRING] AND T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the country of airlines from the 'airlines' table that match a specific name pattern. The placeholder in the WHERE clause allows for flexible searching of airline names.\",\n        \"virtual_table\": \"SELECT country FROM airlines WHERE name LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6842", "db_id": "flight_4", "question": "What is the name of the country with the most number of home airlines?", "rationale": ["We need to find the country with the most number of home airlines.", "To do this, we can count the number of unique airlines (alid) grouped by country from the airlines table.", "We will use the COUNT function to count the number of airlines in each country.", "We will group the results by country using GROUP BY clause.", "To get the country with the maximum number of airlines, we will order the results in descending order using ORDER BY COUNT(alid) DESC.", "Finally, we will limit the results to just one entry using LIMIT 1."], "gold_sql": "SELECT country FROM airlines GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airlines"], "pred_sql": "SELECT country FROM airlines GROUP BY country ORDER BY COUNT(alid) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of routes that lead to airports located in a specific country and are operated by a particular airline. The placeholders in the WHERE clause represent the country and airline name respectively.\",\n        \"virtual_table\": \"SELECT count(*) FROM routes AS T1 JOIN airports AS T2 ON T1.dst_apid  =  T2.apid JOIN airlines AS T3 ON T1.alid  =  T3.alid WHERE T2.country  =  [PLACEHOLDER-TYPE:STRING] AND T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the country of airlines from the 'airlines' table that match a specific name pattern. The placeholder in the WHERE clause allows for flexible searching of airline names.\",\n        \"virtual_table\": \"SELECT country FROM airlines WHERE name LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6858", "db_id": "flight_4", "question": "What are the cities that have more than 2 airports sorted by number of airports?", "rationale": ["Identify the relevant table: The 'airports' table contains information about cities and airports.", "Count the number of airports in each city: Use the COUNT() function and GROUP BY city to aggregate the data.", "Filter cities with more than 2 airports: Use the HAVING clause to restrict results to cities with a count greater than 2.", "Sort the results: Use ORDER BY to sort the cities by the number of airports in descending order."], "gold_sql": "SELECT city FROM airports GROUP BY city HAVING count(*)  >  2 ORDER BY count(*)", "source_tables": ["airports"], "pred_sql": "SELECT city, COUNT(*) as airport_count \nFROM airports \nGROUP BY city \nHAVING COUNT(*) > 2 \nORDER BY airport_count DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of routes that lead to airports located in a specific country and are operated by a particular airline. The placeholders in the WHERE clause represent the country and airline name respectively.\",\n        \"virtual_table\": \"SELECT count(*) FROM routes AS T1 JOIN airports AS T2 ON T1.dst_apid  =  T2.apid JOIN airlines AS T3 ON T1.alid  =  T3.alid WHERE T2.country  =  [PLACEHOLDER-TYPE:STRING] AND T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of airports from the 'airports' table that match a specific name pattern. The placeholder in the WHERE clause allows for dynamic input of the airport name to filter the results accordingly.\",\n        \"virtual_table\": \"SELECT count(*) FROM airports WHERE name LIKE [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of routes that lead to a specific destination airport from the 'airports' and 'routes' tables. The placeholder in the WHERE clause represents the name of the destination airport.\",\n        \"virtual_table\": \"SELECT count(*) FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6862", "db_id": "flight_4", "question": "For each  airport name, how many routes start at that airport, ordered from most to least?", "rationale": ["We need to count the number of routes starting at each airport.", "The relevant table for this information is 'routes', which contains the source airport information in the 'src_ap' column.", "We will use the COUNT() function to count the number of routes for each source airport.", "To group the results by each airport, we will use the GROUP BY clause on 'src_ap'.", "Finally, we will order the results in descending order based on the count of routes using the ORDER BY clause."], "gold_sql": "SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name ORDER BY count(*) DESC", "source_tables": ["airports", "routes"], "pred_sql": "SELECT src_ap, COUNT(*) as route_count FROM routes GROUP BY src_ap ORDER BY route_count DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of routes that lead to airports located in a specific country and are operated by a particular airline. The placeholders in the WHERE clause represent the country and airline name respectively.\",\n        \"virtual_table\": \"SELECT count(*) FROM routes AS T1 JOIN airports AS T2 ON T1.dst_apid  =  T2.apid JOIN airlines AS T3 ON T1.alid  =  T3.alid WHERE T2.country  =  [PLACEHOLDER-TYPE:STRING] AND T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of routes that lead to a specific destination airport from the 'airports' and 'routes' tables. The placeholder in the WHERE clause represents the name of the destination airport.\",\n        \"virtual_table\": \"SELECT count(*) FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of airports from the 'airports' table that match a specific name pattern. The placeholder in the WHERE clause allows for dynamic input of the airport name to filter the results accordingly.\",\n        \"virtual_table\": \"SELECT count(*) FROM airports WHERE name LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6867", "db_id": "flight_4", "question": "For each country and airline name, how many routes are there?", "rationale": ["We need to count the number of routes for each country and airline name.", "To achieve this, we will join the 'routes' table with the 'airports' table to get the country information and with the 'airlines' table to get the airline names.", "The join condition will be based on the foreign keys: routes.dst_apid with airports.apid and routes.alid with airlines.alid.", "After joining the tables, we will group the results by country and airline name to get the count of routes for each combination.", "Finally, we will select the country, airline name, and the count of routes as route_count."], "gold_sql": "SELECT T1.country ,  T1.name ,  count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.country ,  T1.name", "source_tables": ["routes", "airlines"], "pred_sql": "SELECT T2.country, T3.name, count(*) as route_count \nFROM routes AS T1 \nJOIN airports AS T2 ON T1.dst_apid = T2.apid \nJOIN airlines AS T3 ON T1.alid = T3.alid \nGROUP BY T2.country, T3.name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of routes that lead to airports located in a specific country and are operated by a particular airline. The placeholders in the WHERE clause represent the country and airline name respectively.\",\n        \"virtual_table\": \"SELECT count(*) FROM routes AS T1 JOIN airports AS T2 ON T1.dst_apid  =  T2.apid JOIN airlines AS T3 ON T1.alid  =  T3.alid WHERE T2.country  =  [PLACEHOLDER-TYPE:STRING] AND T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of routes that lead to a specific destination airport from the 'airports' and 'routes' tables. The placeholder in the WHERE clause represents the name of the destination airport.\",\n        \"virtual_table\": \"SELECT count(*) FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the country of airlines from the 'airlines' table that match a specific name pattern. The placeholder in the WHERE clause allows for flexible searching of airline names.\",\n        \"virtual_table\": \"SELECT country FROM airlines WHERE name LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6868", "db_id": "flight_4", "question": "What is the total number of routes for each country and airline in that country?", "rationale": ["We need to count the total number of routes for each country and airline.", "To achieve this, we will join the 'routes' table with the 'airports' table to get the destination airport information and with the 'airlines' table to get the airline information.", "We will group the results by country and airline name to get the count of routes for each combination.", "The final SQL query will select the country, airline name, and the count of routes, using COUNT(*) to aggregate the number of routes for each group."], "gold_sql": "SELECT T1.country ,  T1.name ,  count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.country ,  T1.name", "source_tables": ["routes", "airlines"], "pred_sql": "SELECT T3.country, T3.name AS airline, COUNT(*) AS total_routes \nFROM routes AS T1 \nJOIN airports AS T2 ON T1.dst_apid = T2.apid \nJOIN airlines AS T3 ON T1.alid = T3.alid \nGROUP BY T3.country, T3.name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of routes that lead to airports located in a specific country and are operated by a particular airline. The placeholders in the WHERE clause represent the country and airline name respectively.\",\n        \"virtual_table\": \"SELECT count(*) FROM routes AS T1 JOIN airports AS T2 ON T1.dst_apid  =  T2.apid JOIN airlines AS T3 ON T1.alid  =  T3.alid WHERE T2.country  =  [PLACEHOLDER-TYPE:STRING] AND T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of routes that lead to a specific destination airport from the 'airports' and 'routes' tables. The placeholder in the WHERE clause represents the name of the destination airport.\",\n        \"virtual_table\": \"SELECT count(*) FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the country of airlines from the 'airlines' table that match a specific name pattern. The placeholder in the WHERE clause allows for flexible searching of airline names.\",\n        \"virtual_table\": \"SELECT country FROM airlines WHERE name LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6873", "db_id": "flight_4", "question": "Find the number of routes that have destination John F Kennedy International Airport.", "rationale": ["The user wants to find the number of routes to a specific destination airport, which is John F Kennedy International Airport.", "We need to count the number of routes, so we will use the COUNT function in SQL.", "To find the routes that lead to John F Kennedy International Airport, we will join the 'airports' table with the 'routes' table on the destination airport ID.", "We will filter the results by specifying the name of the destination airport in the WHERE clause."], "gold_sql": "SELECT count(*) FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.name  =  'John F Kennedy International Airport'", "source_tables": ["airports", "routes"], "pred_sql": "SELECT count(*) FROM airports AS T1 JOIN routes AS T2 ON T1.apid = T2.dst_apid WHERE T1.name = 'John F Kennedy International Airport'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of routes that lead to airports located in a specific country and are operated by a particular airline. The placeholders in the WHERE clause represent the country and airline name respectively.\",\n        \"virtual_table\": \"SELECT count(*) FROM routes AS T1 JOIN airports AS T2 ON T1.dst_apid  =  T2.apid JOIN airlines AS T3 ON T1.alid  =  T3.alid WHERE T2.country  =  [PLACEHOLDER-TYPE:STRING] AND T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of routes that lead to a specific destination airport from the 'airports' and 'routes' tables. The placeholder in the WHERE clause represents the name of the destination airport.\",\n        \"virtual_table\": \"SELECT count(*) FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of airports from the 'airports' table that match a specific name pattern. The placeholder in the WHERE clause allows for dynamic input of the airport name to filter the results accordingly.\",\n        \"virtual_table\": \"SELECT count(*) FROM airports WHERE name LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6880", "db_id": "flight_4", "question": "What is the name of the airline with the most routes?", "rationale": ["To find the airline with the most routes, we need to count the number of routes associated with each airline.", "We can achieve this by selecting the airline name and counting the number of routes from the 'routes' table.", "We will group the results by airline to get the count for each one.", "Finally, we will order the results in descending order based on the count of routes and limit the output to 1 to get the airline with the most routes."], "gold_sql": "SELECT T1.name FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["routes", "airlines"], "pred_sql": "SELECT airline, COUNT(*) as route_count FROM routes GROUP BY airline ORDER BY route_count DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of routes that lead to airports located in a specific country and are operated by a particular airline. The placeholders in the WHERE clause represent the country and airline name respectively.\",\n        \"virtual_table\": \"SELECT count(*) FROM routes AS T1 JOIN airports AS T2 ON T1.dst_apid  =  T2.apid JOIN airlines AS T3 ON T1.alid  =  T3.alid WHERE T2.country  =  [PLACEHOLDER-TYPE:STRING] AND T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the country of airlines from the 'airlines' table that match a specific name pattern. The placeholder in the WHERE clause allows for flexible searching of airline names.\",\n        \"virtual_table\": \"SELECT country FROM airlines WHERE name LIKE [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of routes that lead to a specific destination airport from the 'airports' and 'routes' tables. The placeholder in the WHERE clause represents the name of the destination airport.\",\n        \"virtual_table\": \"SELECT count(*) FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6883", "db_id": "flight_4", "question": "Find the busiest destination airport that runs most number of routes in China.", "rationale": ["We need to find the busiest destination airport in China based on the number of routes.", "To do this, we will join the 'routes' table with the 'airports' table to access the destination airport information.", "We will filter the results to only include airports located in China by using a WHERE clause on the 'country' column of the 'airports' table.", "Next, we will group the results by the destination airport name to count the number of routes leading to each airport.", "We will use COUNT(*) to count the number of routes for each destination airport.", "Finally, we will order the results in descending order based on the route count and limit the output to 1 to get the busiest destination airport."], "gold_sql": "SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.country  =  'China' GROUP BY T1.name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "pred_sql": "SELECT T2.dst_ap, COUNT(*) AS route_count \nFROM routes AS T1 \nJOIN airports AS T2 ON T1.dst_apid = T2.apid \nWHERE T2.country = 'China' \nGROUP BY T2.dst_ap \nORDER BY route_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of routes that lead to airports located in a specific country and are operated by a particular airline. The placeholders in the WHERE clause represent the country and airline name respectively.\",\n        \"virtual_table\": \"SELECT count(*) FROM routes AS T1 JOIN airports AS T2 ON T1.dst_apid  =  T2.apid JOIN airlines AS T3 ON T1.alid  =  T3.alid WHERE T2.country  =  [PLACEHOLDER-TYPE:STRING] AND T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of routes that lead to a specific destination airport from the 'airports' and 'routes' tables. The placeholder in the WHERE clause represents the name of the destination airport.\",\n        \"virtual_table\": \"SELECT count(*) FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of airports from the 'airports' table that match a specific name pattern. The placeholder in the WHERE clause allows for dynamic input of the airport name to filter the results accordingly.\",\n        \"virtual_table\": \"SELECT count(*) FROM airports WHERE name LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6884", "db_id": "flight_4", "question": "What is the name of the airport that is the destination of the most number of routes that start in China?", "rationale": ["Identify the relevant tables: We need to use the 'routes' table to find the destination airports and the 'airports' table to get the names of those airports.", "Filter for routes that start in China: We will join the 'routes' table with the 'airports' table to filter for routes where the source airport is in China.", "Count the number of routes to each destination airport: We will group the results by the destination airport name and count the number of routes for each.", "Order the results by the count of routes in descending order: This will allow us to find the airport with the most routes.", "Limit the results to 1: We only need the name of the airport with the most routes."], "gold_sql": "SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.country  =  'China' GROUP BY T1.name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "pred_sql": "SELECT airports.name FROM airports JOIN routes ON airports.apid = routes.dst_apid JOIN airlines ON routes.alid = airlines.alid WHERE airports.country = 'China' GROUP BY airports.name ORDER BY COUNT(routes.rid) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of routes that lead to airports located in a specific country and are operated by a particular airline. The placeholders in the WHERE clause represent the country and airline name respectively.\",\n        \"virtual_table\": \"SELECT count(*) FROM routes AS T1 JOIN airports AS T2 ON T1.dst_apid  =  T2.apid JOIN airlines AS T3 ON T1.alid  =  T3.alid WHERE T2.country  =  [PLACEHOLDER-TYPE:STRING] AND T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of routes that lead to a specific destination airport from the 'airports' and 'routes' tables. The placeholder in the WHERE clause represents the name of the destination airport.\",\n        \"virtual_table\": \"SELECT count(*) FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the country of airlines from the 'airlines' table that match a specific name pattern. The placeholder in the WHERE clause allows for flexible searching of airline names.\",\n        \"virtual_table\": \"SELECT country FROM airlines WHERE name LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6980", "db_id": "culture_company", "question": "Show all publishers which do not have a book in 1989.", "rationale": ["Identify the main goal: to find all publishers that do not have a book published in 1989.", "To achieve this, we need to select distinct publishers from the 'book_club' table.", "We will filter out any publishers that have books published in 1989.", "This can be done using a subquery that selects distinct publishers from the 'book_club' table where the year is 1989.", "The final query will select publishers that are not in the list of publishers returned by the subquery."], "gold_sql": "SELECT publisher FROM book_club EXCEPT SELECT publisher FROM book_club WHERE YEAR  =  1989", "source_tables": ["book_club"], "pred_sql": "SELECT DISTINCT Publisher FROM book_club WHERE Year != '1989' AND Publisher NOT IN (SELECT DISTINCT Publisher FROM book_club WHERE Year = '1989');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of cultural companies associated with book clubs that have a specific publisher. The placeholder in the WHERE clause represents the name of the publisher.\",\n        \"virtual_table\": \"SELECT T1.company_name FROM culture_company AS T1 JOIN book_club AS T2 ON T1.book_club_id  =  T2.book_club_id WHERE T2.publisher  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of cultural companies associated with book club entries from the 'book_club' table, filtered by a specific publisher. The placeholder in the WHERE clause represents the publisher's name.\",\n        \"virtual_table\": \"SELECT T1.company_name FROM culture_company AS T1 JOIN book_club AS T2 ON T1.book_club_id  =  T2.book_club_id WHERE T2.publisher  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6990", "db_id": "culture_company", "question": "Show all director names who have a movie in the year 1999 or 2000.", "rationale": ["Identify the table that contains the information about movies, which is the 'movie' table.", "Determine the relevant column that contains the director's names, which is 'Director'.", "Identify the column that contains the year of release, which is 'Year'.", "Use a WHERE clause to filter the results for the years 1999 and 2000.", "Use DISTINCT to ensure that each director's name is listed only once, even if they directed multiple movies in those years."], "gold_sql": "SELECT director FROM movie WHERE YEAR  =  1999 OR YEAR  =  2000", "source_tables": ["movie"], "pred_sql": "SELECT DISTINCT Director FROM movie WHERE Year IN (1999, 2000);", "hint": "\n"}
{"sample_id": "train.6991", "db_id": "culture_company", "question": "Which directors had a movie in either 1999 or 2000?", "rationale": ["Identify the relevant table: The question pertains to directors and movies, so we will use the 'movie' table.", "Determine the columns needed: We need the 'Director' column to answer the question.", "Filter the results: We need to filter the movies based on the years 1999 and 2000.", "Use the DISTINCT keyword: Since we want to know which directors had movies in those years, we should use DISTINCT to avoid duplicate entries for directors who may have multiple movies in those years."], "gold_sql": "SELECT director FROM movie WHERE YEAR  =  1999 OR YEAR  =  2000", "source_tables": ["movie"], "pred_sql": "SELECT DISTINCT Director FROM movie WHERE Year IN (1999, 2000);", "hint": "\n"}
{"sample_id": "train.6996", "db_id": "culture_company", "question": "Show the movie titles and book titles for all companies in China.", "rationale": ["Identify the tables needed: We need data from the 'movie', 'book_club', and 'culture_company' tables.", "Determine the relationships: The 'culture_company' table links to both 'movie' and 'book_club' through their respective IDs.", "Select the required fields: We need the movie titles from the 'movie' table and book titles from the 'book_club' table.", "Filter the results: We want to show results specifically for companies in China, so we will add a WHERE clause to filter by 'Company_name'.", "Construct the SQL query using JOINs to combine the necessary tables and apply the filter."], "gold_sql": "SELECT T1.title ,  T3.book_title FROM movie AS T1 JOIN culture_company AS T2 ON T1.movie_id  =  T2.movie_id JOIN book_club AS T3 ON T3.book_club_id  =  T2.book_club_id WHERE T2.incorporated_in  =  'China'", "source_tables": ["culture_company", "movie", "book_club"], "pred_sql": "SELECT movie.Title, book_club.Book_Title \nFROM culture_company \nJOIN movie ON culture_company.movie_id = movie.movie_id \nJOIN book_club ON culture_company.book_club_id = book_club.book_club_id \nWHERE culture_company.Company_name = 'China';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of cultural companies associated with book clubs that have a specific publisher. The placeholder in the WHERE clause represents the name of the publisher.\",\n        \"virtual_table\": \"SELECT T1.company_name FROM culture_company AS T1 JOIN book_club AS T2 ON T1.book_club_id  =  T2.book_club_id WHERE T2.publisher  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of cultural companies associated with book club entries from the 'book_club' table, filtered by a specific publisher. The placeholder in the WHERE clause represents the publisher's name.\",\n        \"virtual_table\": \"SELECT T1.company_name FROM culture_company AS T1 JOIN book_club AS T2 ON T1.book_club_id  =  T2.book_club_id WHERE T2.publisher  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.95", "db_id": "car_1", "question": "Which model of the car has the minimum horsepower?", "rationale": ["Identify the relevant tables: 'car_names' for car models and 'cars_data' for horsepower.", "Join the 'car_names' table with the 'cars_data' table on the MakeId and Id columns respectively to access horsepower data for each model.", "Order the results by horsepower in ascending order to find the model with the minimum horsepower.", "Limit the results to 1 to get only the model with the minimum horsepower."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT T1.Model FROM car_names AS T1 JOIN cars_data AS T2 ON T1.MakeId = T2.Id ORDER BY T2.Horsepower ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the car models from the 'car_names' table, ordered by their horsepower in ascending order. The placeholder in the LIMIT clause represents the maximum number of car models to be returned.\",\n        \"virtual_table\": \"SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists car models from the 'car_names' table, ordered by their miles per gallon (MPG) fuel efficiency from the 'cars_data' table. The placeholder in the LIMIT clause represents the maximum number of car models to display.\",\n        \"virtual_table\": \"select t1.model from car_names as t1 join cars_data as t2 on t1.makeid  =  t2.id order by t2.mpg desc limit [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the relationship between car makers and their respective car models from the 'model_list' table. The placeholders represent the identifiers for the car makers and models.\",\n        \"virtual_table\": \"SELECT Maker ,  Model FROM MODEL_LIST;\"\n    }\n}\n"}
{"sample_id": "dev.103", "db_id": "car_1", "question": "Which distinct car models are the produced after 1980?", "rationale": ["The question asks for distinct car models produced after 1980, which means we need to select unique model names from the database.", "We will use the 'car_names' table to get the car models and the 'cars_data' table to filter by the year of production.", "To get the distinct models, we will use the DISTINCT keyword in our SELECT statement.", "We will join the 'car_names' table with the 'cars_data' table on the MakeId and Id columns respectively to access the year of production for each model.", "Finally, we will apply a WHERE clause to filter out models produced after 1980."], "gold_sql": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  1980;", "source_tables": ["model_list", "car_names", "cars_data"], "pred_sql": "SELECT DISTINCT t1.Model \nFROM car_names AS t1 \nJOIN cars_data AS t2 ON t1.MakeId = t2.Id \nWHERE t2.Year > 1980;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists car models from the 'car_names' table, ordered by their miles per gallon (MPG) fuel efficiency from the 'cars_data' table. The placeholder in the LIMIT clause represents the maximum number of car models to display.\",\n        \"virtual_table\": \"select t1.model from car_names as t1 join cars_data as t2 on t1.makeid  =  t2.id order by t2.mpg desc limit [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the relationship between car makers and their respective car models from the 'model_list' table. The placeholders represent the identifiers for the car makers and models.\",\n        \"virtual_table\": \"SELECT Maker ,  Model FROM MODEL_LIST;\"\n    },\n    \"2\": {\n        \"description\": \"The virtual table describes the relationship between car makers and their respective car models from the 'model_list' table. The placeholders represent the identifiers for the car makers and models.\",\n        \"virtual_table\": \"SELECT Maker ,  Model FROM MODEL_LIST;\"\n    }\n}\n"}
{"sample_id": "dev.106", "db_id": "car_1", "question": "What is the name of each continent and how many car makers are there in each one?", "rationale": ["Identify the tables needed: continents, countries, and car_makers.", "We need to count the number of car makers for each continent, so we will join the continents table with the countries table using the ContId and Continent columns.", "Next, we will join the countries table with the car_makers table using the CountryId and Country columns.", "We will use COUNT() to count the number of car makers for each continent.", "Finally, we will group the results by continent to get the count for each one."], "gold_sql": "SELECT T1.Continent ,  count(*) FROM CONTINENTS AS T1 JOIN COUNTRIES AS T2 ON T1.ContId  =  T2.continent JOIN car_makers AS T3 ON T2.CountryId  =  T3.Country GROUP BY T1.Continent;", "source_tables": ["countries", "car_makers", "continents"], "pred_sql": "SELECT c.Continent, COUNT(cm.Id) AS CarMakerCount \nFROM continents c \nJOIN countries co ON c.ContId = co.Continent \nJOIN car_makers cm ON co.CountryId = cm.Country \nGROUP BY c.Continent;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the relationship between car makers and their respective car models from the 'model_list' table. The placeholders represent the identifiers for the car makers and models.\",\n        \"virtual_table\": \"SELECT Maker ,  Model FROM MODEL_LIST;\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of car models from the 'model_list' table that are associated with car makers from a specific country. The placeholders in the WHERE clause represent the name of the country being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists car models from the 'car_names' table, ordered by their miles per gallon (MPG) fuel efficiency from the 'cars_data' table. The placeholder in the LIMIT clause represents the maximum number of car models to display.\",\n        \"virtual_table\": \"select t1.model from car_names as t1 join cars_data as t2 on t1.makeid  =  t2.id order by t2.mpg desc limit [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.111", "db_id": "car_1", "question": "What is the accelerate of the car make amc hornet sportabout (sw)?", "rationale": ["Identify the relevant tables: 'cars_data' for acceleration data and 'car_names' for car make names.", "Join the 'cars_data' table with the 'car_names' table on the condition that the Id in 'cars_data' matches the MakeId in 'car_names'.", "Filter the results to only include rows where the Make in 'car_names' is 'amc hornet sportabout (sw)'.", "Select the 'Accelerate' column from the resulting joined table."], "gold_sql": "SELECT T1.Accelerate FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Make  =  'amc hornet sportabout (sw)';", "source_tables": ["cars_data", "car_names"], "pred_sql": "SELECT T1.Accelerate FROM cars_data AS T1 JOIN car_names AS T2 ON T1.Id = T2.MakeId WHERE T2.Make = 'amc hornet sportabout (sw)';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the acceleration times of cars from the 'cars_data' table, filtered by a specific car make from the 'car_names' table. The placeholder in the WHERE clause represents the name of the car make.\",\n        \"virtual_table\": \"SELECT T1.Accelerate FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Make  =  [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists car models from the 'car_names' table, ordered by their miles per gallon (MPG) fuel efficiency from the 'cars_data' table. The placeholder in the LIMIT clause represents the maximum number of car models to display.\",\n        \"virtual_table\": \"select t1.model from car_names as t1 join cars_data as t2 on t1.makeid  =  t2.id order by t2.mpg desc limit [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"The virtual table describes the car models from the 'car_names' table, ordered by their horsepower in ascending order. The placeholder in the LIMIT clause represents the maximum number of car models to be returned.\",\n        \"virtual_table\": \"SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.113", "db_id": "car_1", "question": "How many car makers are there in france?", "rationale": ["Identify the tables involved: We need to find car makers in France, which involves the 'car_makers' and 'countries' tables.", "Use the provided virtual table that counts car models associated with car makers from a specific country.", "Join the 'model_list' table with 'car_makers' on the Maker ID, and then join 'car_makers' with 'countries' on the Country ID.", "Filter the results where the country name is 'France'.", "Count the number of car makers that meet this criteria."], "gold_sql": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  'france';", "source_tables": ["car_makers", "countries"], "pred_sql": "SELECT count(*) FROM model_list AS T1 JOIN car_makers AS T2 ON T1.Maker = T2.Id JOIN countries AS T3 ON T2.Country = T3.CountryId WHERE T3.CountryName = 'France';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of car models from the 'model_list' table that are associated with car makers from a specific country. The placeholders in the WHERE clause represent the name of the country being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the relationship between car makers and their respective car models from the 'model_list' table. The placeholders represent the identifiers for the car makers and models.\",\n        \"virtual_table\": \"SELECT Maker ,  Model FROM MODEL_LIST;\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists car models from the 'car_names' table, ordered by their miles per gallon (MPG) fuel efficiency from the 'cars_data' table. The placeholder in the LIMIT clause represents the maximum number of car models to display.\",\n        \"virtual_table\": \"select t1.model from car_names as t1 join cars_data as t2 on t1.makeid  =  t2.id order by t2.mpg desc limit [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.114", "db_id": "car_1", "question": "What is the number of makers of care in France?", "rationale": ["Identify the tables involved: model_list, car_makers, and countries.", "We need to count the number of car makers in France, so we will use the count function.", "Join the model_list table with the car_makers table on the Maker column.", "Join the car_makers table with the countries table on the Country column.", "Filter the results to only include those where the CountryName is 'France'.", "Construct the SQL query using the above steps."], "gold_sql": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  'france';", "source_tables": ["car_makers", "countries"], "pred_sql": "SELECT count(*) FROM model_list AS T1 JOIN car_makers AS T2 ON T1.Maker = T2.Id JOIN countries AS T3 ON T2.Country = T3.CountryId WHERE T3.CountryName = 'France';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of car models from the 'model_list' table that are associated with car makers from a specific country. The placeholders in the WHERE clause represent the name of the country being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "dev.115", "db_id": "car_1", "question": "How many car models are produced in the usa?", "rationale": ["Identify the relevant tables: model_list, car_makers, and countries.", "We need to count the number of car models produced in the USA, which means we need to filter by the country name 'usa'.", "Join the model_list table with the car_makers table on the Maker ID.", "Join the car_makers table with the countries table on the Country ID.", "Filter the results where the CountryName is 'usa'.", "Use the COUNT function to get the total number of car models that meet these criteria."], "gold_sql": "SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  'usa';", "source_tables": ["car_makers", "model_list", "countries"], "pred_sql": "SELECT count(*) FROM model_list AS T1 JOIN car_makers AS T2 ON T1.Maker = T2.Id JOIN countries AS T3 ON T2.Country = T3.CountryId WHERE T3.CountryName = 'usa';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of car models from the 'model_list' table that are associated with car makers from a specific country. The placeholders in the WHERE clause represent the name of the country being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists car models from the 'car_names' table, ordered by their miles per gallon (MPG) fuel efficiency from the 'cars_data' table. The placeholder in the LIMIT clause represents the maximum number of car models to display.\",\n        \"virtual_table\": \"select t1.model from car_names as t1 join cars_data as t2 on t1.makeid  =  t2.id order by t2.mpg desc limit [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the relationship between car makers and their respective car models from the 'model_list' table. The placeholders represent the identifiers for the car makers and models.\",\n        \"virtual_table\": \"SELECT Maker ,  Model FROM MODEL_LIST;\"\n    }\n}\n"}
{"sample_id": "dev.129", "db_id": "car_1", "question": "Which countries in europe have at least 3 car manufacturers?", "rationale": ["Identify the countries in Europe by joining the 'countries' table with the 'continents' table to filter for the continent 'Europe'.", "Join the 'car_makers' table to the 'countries' table to associate car manufacturers with their respective countries.", "Group the results by country name to count the number of car manufacturers per country.", "Use the HAVING clause to filter for countries that have at least 3 car manufacturers."], "gold_sql": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  'europe' GROUP BY T1.CountryName HAVING count(*)  >=  3;", "source_tables": ["continents", "car_makers", "countries"], "pred_sql": "SELECT c.CountryName\nFROM countries AS c\nJOIN car_makers AS cm ON c.CountryId = cm.Country\nWHERE c.Continent = (SELECT ContId FROM continents WHERE Continent = 'Europe')\nGROUP BY c.CountryName\nHAVING COUNT(cm.Id) >= 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of car models from the 'model_list' table that are associated with car makers from a specific country. The placeholders in the WHERE clause represent the name of the country being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the relationship between car makers and their respective car models from the 'model_list' table. The placeholders represent the identifiers for the car makers and models.\",\n        \"virtual_table\": \"SELECT Maker ,  Model FROM MODEL_LIST;\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists car models from the 'car_names' table, ordered by their miles per gallon (MPG) fuel efficiency from the 'cars_data' table. The placeholder in the LIMIT clause represents the maximum number of car models to display.\",\n        \"virtual_table\": \"select t1.model from car_names as t1 join cars_data as t2 on t1.makeid  =  t2.id order by t2.mpg desc limit [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.131", "db_id": "car_1", "question": "What is the maximum horsepower and the make of the car models with 3 cylinders?", "rationale": ["Identify the tables involved: We need data from 'car_names', 'model_list', and 'cars_data'.", "We want to find the maximum horsepower, so we will use the MAX() function on the 'Horsepower' column from the 'cars_data' table.", "We need to filter the results to only include car models with 3 cylinders, which is done using a WHERE clause on the 'Cylinders' column.", "We will join the 'car_names' table with the 'model_list' table to get the make of the car, and then join with 'cars_data' to access horsepower and cylinder information.", "The final query selects the maximum horsepower and the corresponding make of the car models with 3 cylinders."], "gold_sql": "SELECT T2.horsepower ,  T1.Make FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.cylinders  =  3 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT MAX(T2.Horsepower) AS MaxHorsepower, T1.Make \nFROM car_names AS T1 \nJOIN model_list AS T3 ON T1.Model = T3.Model \nJOIN cars_data AS T2 ON T1.MakeId = T2.Id \nWHERE T2.Cylinders = 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the car models from the 'car_names' table, ordered by their horsepower in ascending order. The placeholder in the LIMIT clause represents the maximum number of car models to be returned.\",\n        \"virtual_table\": \"SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists car models from the 'car_names' table, ordered by their miles per gallon (MPG) fuel efficiency from the 'cars_data' table. The placeholder in the LIMIT clause represents the maximum number of car models to display.\",\n        \"virtual_table\": \"select t1.model from car_names as t1 join cars_data as t2 on t1.makeid  =  t2.id order by t2.mpg desc limit [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the relationship between car makers and their respective car models from the 'model_list' table. The placeholders represent the identifiers for the car makers and models.\",\n        \"virtual_table\": \"SELECT Maker ,  Model FROM MODEL_LIST;\"\n    }\n}\n"}
{"sample_id": "dev.133", "db_id": "car_1", "question": "Which model saves the most gasoline? That is to say, have the maximum miles per gallon.", "rationale": ["The question asks for the car model that saves the most gasoline, which is indicated by the maximum miles per gallon (MPG).", "To find this, we need to join the 'car_names' table with the 'cars_data' table on the 'MakeId' and 'Id' columns respectively.", "We will select the 'Model' from the 'car_names' table and order the results by 'MPG' in descending order to get the highest value at the top.", "Finally, we will limit the results to 1 to get only the top model that has the maximum MPG."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.mpg DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT t1.Model FROM car_names AS t1 JOIN cars_data AS t2 ON t1.MakeId = t2.Id ORDER BY t2.MPG DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists car models from the 'car_names' table, ordered by their miles per gallon (MPG) fuel efficiency from the 'cars_data' table. The placeholder in the LIMIT clause represents the maximum number of car models to display.\",\n        \"virtual_table\": \"select t1.model from car_names as t1 join cars_data as t2 on t1.makeid  =  t2.id order by t2.mpg desc limit [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table describes the car models from the 'car_names' table, ordered by their horsepower in ascending order. The placeholder in the LIMIT clause represents the maximum number of car models to be returned.\",\n        \"virtual_table\": \"SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the relationship between car makers and their respective car models from the 'model_list' table. The placeholders represent the identifiers for the car makers and models.\",\n        \"virtual_table\": \"SELECT Maker ,  Model FROM MODEL_LIST;\"\n    }\n}\n"}
{"sample_id": "dev.150", "db_id": "car_1", "question": "What are the names and ids of all makers with more than 3 models?", "rationale": ["Identify the relevant tables: We need to find car makers and their models, so we will use the 'car_makers' and 'model_list' tables.", "Join the tables: We will join 'car_makers' with 'model_list' on the car maker's ID to associate each maker with their models.", "Group the results: We will group the results by the car maker's ID and name to aggregate the number of models for each maker.", "Filter the results: We will use the HAVING clause to filter out car makers that have more than 3 models."], "gold_sql": "SELECT T1.FullName ,  T1.Id FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >  3;", "source_tables": ["car_makers", "model_list"], "pred_sql": "SELECT cm.Id, cm.Maker\nFROM car_makers cm\nJOIN model_list ml ON cm.Id = ml.Maker\nGROUP BY cm.Id, cm.Maker\nHAVING COUNT(ml.Model) > 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the relationship between car makers and their respective car models from the 'model_list' table. The placeholders represent the identifiers for the car makers and models.\",\n        \"virtual_table\": \"SELECT Maker ,  Model FROM MODEL_LIST;\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table describes the relationship between car makers and their respective car models from the 'model_list' table. The placeholders represent the identifiers for the car makers and models.\",\n        \"virtual_table\": \"SELECT Maker ,  Model FROM MODEL_LIST;\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists car models from the 'car_names' table, ordered by their miles per gallon (MPG) fuel efficiency from the 'cars_data' table. The placeholder in the LIMIT clause represents the maximum number of car models to display.\",\n        \"virtual_table\": \"select t1.model from car_names as t1 join cars_data as t2 on t1.makeid  =  t2.id order by t2.mpg desc limit [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.158", "db_id": "car_1", "question": "For a volvo model, how many cylinders does the version with least accelerate have?", "rationale": ["Identify the relevant tables: 'car_names' for car makes and 'cars_data' for car specifications.", "We need to filter the results for the make 'Volvo'.", "We want to find the version of the Volvo model with the least acceleration time, so we will order by the 'Accelerate' column in ascending order.", "To get the number of cylinders for that specific model, we will select the 'Cylinders' column from the 'cars_data' table.", "Finally, we will limit the results to 1 to get only the model with the least acceleration."], "gold_sql": "SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  'volvo' ORDER BY T1.accelerate ASC LIMIT 1;", "source_tables": ["cars_data", "car_names"], "pred_sql": "SELECT T1.Cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id = T2.MakeId WHERE T2.Make = 'Volvo' ORDER BY T1.Accelerate ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists car models from the 'car_names' table, ordered by their miles per gallon (MPG) fuel efficiency from the 'cars_data' table. The placeholder in the LIMIT clause represents the maximum number of car models to display.\",\n        \"virtual_table\": \"select t1.model from car_names as t1 join cars_data as t2 on t1.makeid  =  t2.id order by t2.mpg desc limit [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table describes the car models from the 'car_names' table, ordered by their horsepower in ascending order. The placeholder in the LIMIT clause represents the maximum number of car models to be returned.\",\n        \"virtual_table\": \"SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"The virtual table describes the acceleration times of cars from the 'cars_data' table, filtered by a specific car make from the 'car_names' table. The placeholder in the WHERE clause represents the name of the car make.\",\n        \"virtual_table\": \"SELECT T1.Accelerate FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Make  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "dev.160", "db_id": "car_1", "question": "What is the number of cars with a greater accelerate than the one with the most horsepower?", "rationale": ["Identify the requirement: We need to count the number of cars with an acceleration time greater than the maximum horsepower.", "To find the maximum horsepower, we can use a subquery that selects the maximum value from the 'Horsepower' column in the 'cars_data' table.", "We then need to count the number of entries in the 'cars_data' table where the 'Accelerate' value is greater than this maximum horsepower value.", "The final SQL query combines these elements: a COUNT function to count the qualifying cars and a subquery to determine the maximum horsepower."], "gold_sql": "SELECT COUNT(*) FROM CARS_DATA WHERE Accelerate  >  ( SELECT Accelerate FROM CARS_DATA ORDER BY Horsepower DESC LIMIT 1 );", "source_tables": ["cars_data"], "pred_sql": "SELECT COUNT(*) FROM cars_data WHERE Accelerate > (SELECT MAX(Horsepower) FROM cars_data);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the car models from the 'car_names' table, ordered by their horsepower in ascending order. The placeholder in the LIMIT clause represents the maximum number of car models to be returned.\",\n        \"virtual_table\": \"SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists car models from the 'car_names' table, ordered by their miles per gallon (MPG) fuel efficiency from the 'cars_data' table. The placeholder in the LIMIT clause represents the maximum number of car models to display.\",\n        \"virtual_table\": \"select t1.model from car_names as t1 join cars_data as t2 on t1.makeid  =  t2.id order by t2.mpg desc limit [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"The virtual table describes the acceleration times of cars from the 'cars_data' table, filtered by a specific car make from the 'car_names' table. The placeholder in the WHERE clause represents the name of the car make.\",\n        \"virtual_table\": \"SELECT T1.Accelerate FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Make  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "dev.165", "db_id": "car_1", "question": "For the cars with 4 cylinders, which model has the largest horsepower?", "rationale": ["Identify the relevant tables: 'car_names' for car models and 'cars_data' for car specifications including horsepower and cylinder count.", "Join the 'car_names' table with the 'cars_data' table on the MakeId to access both model names and their corresponding specifications.", "Filter the results to include only cars with 4 cylinders using a WHERE clause.", "Order the results by horsepower in descending order to get the model with the largest horsepower at the top.", "Limit the results to 1 to retrieve only the top model with the highest horsepower."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  4 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT T1.Model FROM car_names AS T1 JOIN cars_data AS T2 ON T1.MakeId = T2.Id WHERE T2.Cylinders = 4 ORDER BY T2.Horsepower DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the car models from the 'car_names' table, ordered by their horsepower in ascending order. The placeholder in the LIMIT clause represents the maximum number of car models to be returned.\",\n        \"virtual_table\": \"SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists car models from the 'car_names' table, ordered by their miles per gallon (MPG) fuel efficiency from the 'cars_data' table. The placeholder in the LIMIT clause represents the maximum number of car models to display.\",\n        \"virtual_table\": \"select t1.model from car_names as t1 join cars_data as t2 on t1.makeid  =  t2.id order by t2.mpg desc limit [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of car models from the 'model_list' table that are associated with car makers from a specific country. The placeholders in the WHERE clause represent the name of the country being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "dev.166", "db_id": "car_1", "question": "For all of the 4 cylinder cars, which model has the most horsepower?", "rationale": ["Identify the relevant tables: car_names and cars_data are needed to get the car models and their horsepower.", "Join the car_names table with the cars_data table on the MakeId to access horsepower and cylinder information.", "Filter the results to include only cars with 4 cylinders using a WHERE clause.", "Order the results by horsepower in descending order to get the model with the highest horsepower at the top.", "Limit the results to 1 to get only the model with the most horsepower."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  4 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT T1.Model FROM car_names AS T1 JOIN cars_data AS T2 ON T1.MakeId = T2.Id WHERE T2.Cylinders = 4 ORDER BY T2.Horsepower DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the car models from the 'car_names' table, ordered by their horsepower in ascending order. The placeholder in the LIMIT clause represents the maximum number of car models to be returned.\",\n        \"virtual_table\": \"SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists car models from the 'car_names' table, ordered by their miles per gallon (MPG) fuel efficiency from the 'cars_data' table. The placeholder in the LIMIT clause represents the maximum number of car models to display.\",\n        \"virtual_table\": \"select t1.model from car_names as t1 join cars_data as t2 on t1.makeid  =  t2.id order by t2.mpg desc limit [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of car models from the 'model_list' table that are associated with car makers from a specific country. The placeholders in the WHERE clause represent the name of the country being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "dev.168", "db_id": "car_1", "question": "Among the cars that do not have the minimum horsepower , what are the make ids and names of all those with less than 4 cylinders ?", "rationale": ["Identify the requirement: We need to find make ids and names of cars with less than 4 cylinders that do not have the minimum horsepower.", "To find the minimum horsepower, we can use a subquery: SELECT MIN(Horsepower) FROM cars_data.", "Next, we need to filter out the cars that have horsepower greater than this minimum value.", "We will join the 'car_names' table with 'cars_data' to get the make ids and names along with their horsepower and cylinder count.", "Finally, we will apply the condition to select only those cars with less than 4 cylinders."], "gold_sql": "select t2.makeid ,  t2.make from cars_data as t1 join car_names as t2 on t1.id  =  t2.makeid where t1.horsepower  >  (select min(horsepower) from cars_data) and t1.cylinders  <  4;", "source_tables": ["cars_data", "car_names"], "pred_sql": "SELECT MakeId, Model FROM car_names WHERE MakeId IN (SELECT MakeId FROM car_names JOIN cars_data ON car_names.MakeId = cars_data.Id WHERE cars_data.Horsepower > (SELECT MIN(Horsepower) FROM cars_data)) AND cars_data.Cylinders < 4;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the car models from the 'car_names' table, ordered by their horsepower in ascending order. The placeholder in the LIMIT clause represents the maximum number of car models to be returned.\",\n        \"virtual_table\": \"SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists car models from the 'car_names' table, ordered by their miles per gallon (MPG) fuel efficiency from the 'cars_data' table. The placeholder in the LIMIT clause represents the maximum number of car models to display.\",\n        \"virtual_table\": \"select t1.model from car_names as t1 join cars_data as t2 on t1.makeid  =  t2.id order by t2.mpg desc limit [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the relationship between car makers and their respective car models from the 'model_list' table. The placeholders represent the identifiers for the car makers and models.\",\n        \"virtual_table\": \"SELECT Maker ,  Model FROM MODEL_LIST;\"\n    }\n}\n"}
{"sample_id": "dev.176", "db_id": "car_1", "question": "What are the ids and makers of all car makers that produce at least 2 models and make more than 3 cars?", "rationale": ["Identify the relevant tables: car_makers, model_list, car_names, and cars_data.", "We need to join these tables to get the car makers and their models.", "Join car_makers (cm) with model_list (ml) on the Maker ID.", "Join model_list (ml) with car_names (cn) on the Model.", "Join car_names (cn) with cars_data (cd) on the MakeId.", "Group the results by car maker ID and name to aggregate the models and cars produced.", "Use HAVING clause to filter for car makers that produce at least 2 distinct models and have more than 3 cars."], "gold_sql": "SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >=  2 INTERSECT SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker JOIN CAR_NAMES AS T3 ON T2.model  =  T3.model GROUP BY T1.Id HAVING count(*)  >  3;", "source_tables": ["car_makers", "car_names", "model_list"], "pred_sql": "SELECT cm.Id, cm.Maker\nFROM car_makers cm\nJOIN model_list ml ON cm.Id = ml.Maker\nJOIN car_names cn ON ml.Model = cn.Model\nJOIN cars_data cd ON cn.MakeId = cd.Id\nGROUP BY cm.Id, cm.Maker\nHAVING COUNT(DISTINCT ml.Model) >= 2 AND COUNT(cd.Id) > 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the relationship between car makers and their respective car models from the 'model_list' table. The placeholders represent the identifiers for the car makers and models.\",\n        \"virtual_table\": \"SELECT Maker ,  Model FROM MODEL_LIST;\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table describes the relationship between car makers and their respective car models from the 'model_list' table. The placeholders represent the identifiers for the car makers and models.\",\n        \"virtual_table\": \"SELECT Maker ,  Model FROM MODEL_LIST;\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists car models from the 'car_names' table, ordered by their miles per gallon (MPG) fuel efficiency from the 'cars_data' table. The placeholder in the LIMIT clause represents the maximum number of car models to display.\",\n        \"virtual_table\": \"select t1.model from car_names as t1 join cars_data as t2 on t1.makeid  =  t2.id order by t2.mpg desc limit [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.180", "db_id": "flight_2", "question": "What country is Jetblue Airways affiliated with?", "rationale": ["Identify the relevant table: The question pertains to the airline 'Jetblue Airways', so we will refer to the 'airlines' table.", "Determine the required column: We need to find out the country associated with 'Jetblue Airways', which is stored in the 'Country' column of the 'airlines' table.", "Construct the SQL query: Using the information from the 'airlines' table, we will select the 'Country' where the 'Airline' matches 'Jetblue Airways'."], "gold_sql": "SELECT Country FROM AIRLINES WHERE Airline  =  'JetBlue Airways'", "source_tables": ["airlines"], "pred_sql": "SELECT Country FROM airlines WHERE Airline = 'Jetblue Airways'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the abbreviation of a specific airline from the 'airlines' table based on the airline's name. The placeholder in the WHERE clause represents the name of the airline.\",\n        \"virtual_table\": \"SELECT Abbreviation FROM AIRLINES WHERE Airline  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.194", "db_id": "flight_2", "question": "Give the airline with abbreviation 'UAL'.", "rationale": ["Identify the table needed: The question asks for the abbreviation of an airline, which is found in the 'airlines' table.", "Determine the specific column: The abbreviation is stored in the 'Abbreviation' column of the 'airlines' table.", "Formulate the SQL query: Use a SELECT statement to retrieve the 'Abbreviation' where the 'Airline' matches 'UAL'."], "gold_sql": "SELECT Airline FROM AIRLINES WHERE Abbreviation  =  'UAL'", "source_tables": ["airlines"], "pred_sql": "SELECT Abbreviation FROM airlines WHERE Airline = 'UAL'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the abbreviation of a specific airline from the 'airlines' table based on the airline's name. The placeholder in the WHERE clause represents the name of the airline.\",\n        \"virtual_table\": \"SELECT Abbreviation FROM AIRLINES WHERE Airline  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the unique flight numbers from the 'flights' table for a specific airline. The placeholder in the WHERE clause represents the name of the airline being queried.\",\n        \"virtual_table\": \"SELECT T1.FlightNo FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T2.uid  =  T1.Airline WHERE T2.Airline  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the unique flight numbers from the 'flights' table for a specific airline. The placeholder in the WHERE clause represents the name of the airline being queried.\",\n        \"virtual_table\": \"SELECT T1.FlightNo FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T2.uid  =  T1.Airline WHERE T2.Airline  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.214", "db_id": "flight_2", "question": "Give the number of Jetblue Airways flights.", "rationale": ["Identify the relevant tables: 'flights' and 'airlines'.", "Determine the relationship between the tables: 'flights' references 'airlines' through the 'Airline' and 'uid' columns.", "Use the provided hint to construct a query that counts the number of flights for 'Jetblue Airways'.", "Replace the placeholder in the virtual table with 'Jetblue Airways'.", "The final SQL query counts the number of flights operated by Jetblue Airways."], "gold_sql": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T1.Airline  =  T2.uid WHERE T2.Airline = 'JetBlue Airways'", "source_tables": ["flights", "airlines"], "pred_sql": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T1.Airline  =  T2.uid WHERE T2.Airline = 'Jetblue Airways'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the unique flight numbers from the 'flights' table for a specific airline. The placeholder in the WHERE clause represents the name of the airline being queried.\",\n        \"virtual_table\": \"SELECT T1.FlightNo FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T2.uid  =  T1.Airline WHERE T2.Airline  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the unique flight numbers from the 'flights' table for a specific airline. The placeholder in the WHERE clause represents the name of the airline being queried.\",\n        \"virtual_table\": \"SELECT T1.FlightNo FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T2.uid  =  T1.Airline WHERE T2.Airline  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of flights operated by a specific airline from the 'flights' table. It joins the 'flights' table with the 'airlines' table to filter the results based on the airline's name. The placeholder in the WHERE clause represents the name of the airline.\",\n        \"virtual_table\": \"SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T1.Airline  =  T2.uid WHERE T2.Airline = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.225", "db_id": "flight_2", "question": "What is the code of airport that has the highest number of flights?", "rationale": ["Identify the relevant table: The 'flights' table contains the information about flights, including the source and destination airports.", "Count the number of flights for each airport: Use COUNT(*) to count the number of flights grouped by the SourceAirport.", "Group the results by SourceAirport: This allows us to aggregate the flight counts for each airport.", "Order the results by the flight count in descending order: This will put the airport with the highest number of flights at the top.", "Limit the results to 1: We only want the airport with the highest number of flights."], "gold_sql": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "flights"], "pred_sql": "SELECT SourceAirport, COUNT(*) as FlightCount \nFROM flights \nGROUP BY SourceAirport \nORDER BY FlightCount DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the unique flight numbers from the 'flights' table for a specific airline. The placeholder in the WHERE clause represents the name of the airline being queried.\",\n        \"virtual_table\": \"SELECT T1.FlightNo FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T2.uid  =  T1.Airline WHERE T2.Airline  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the unique flight numbers from the 'flights' table for a specific airline. The placeholder in the WHERE clause represents the name of the airline being queried.\",\n        \"virtual_table\": \"SELECT T1.FlightNo FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T2.uid  =  T1.Airline WHERE T2.Airline  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.227", "db_id": "flight_2", "question": "What is the code of airport that has fewest number of flights?", "rationale": ["Identify the relevant table: The 'flights' table contains information about flights, including the source airport.", "Count the number of flights for each airport: Use COUNT(*) to count the number of flights grouped by the SourceAirport.", "Group the results by SourceAirport: This will allow us to count the flights for each airport.", "Order the results by the count of flights in ascending order: This will help us find the airport with the fewest flights.", "Limit the results to 1: We only need the airport with the fewest number of flights."], "gold_sql": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) LIMIT 1", "source_tables": ["airports", "flights"], "pred_sql": "SELECT SourceAirport AS AirportCode, COUNT(*) AS FlightCount\nFROM flights\nGROUP BY SourceAirport\nORDER BY FlightCount ASC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "dev.229", "db_id": "flight_2", "question": "Which airline has most number of flights?", "rationale": ["Identify the tables involved: 'flights' for flight information and 'airlines' for airline details.", "To find the airline with the most flights, we need to count the number of flights for each airline.", "Join the 'flights' table with the 'airlines' table on the airline identifier (uid).", "Group the results by airline name to aggregate the flight counts.", "Order the results by the count of flights in descending order to get the airline with the most flights at the top.", "Limit the results to 1 to get only the top airline."], "gold_sql": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) DESC LIMIT 1", "source_tables": ["flights", "airlines"], "pred_sql": "SELECT T2.Airline, COUNT(T1.FlightNo) AS FlightCount \nFROM flights AS T1 \nJOIN airlines AS T2 ON T1.Airline = T2.uid \nGROUP BY T2.Airline \nORDER BY FlightCount DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the unique flight numbers from the 'flights' table for a specific airline. The placeholder in the WHERE clause represents the name of the airline being queried.\",\n        \"virtual_table\": \"SELECT T1.FlightNo FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T2.uid  =  T1.Airline WHERE T2.Airline  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the unique flight numbers from the 'flights' table for a specific airline. The placeholder in the WHERE clause represents the name of the airline being queried.\",\n        \"virtual_table\": \"SELECT T1.FlightNo FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T2.uid  =  T1.Airline WHERE T2.Airline  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of flights operated by a specific airline from the 'flights' table. It joins the 'flights' table with the 'airlines' table to filter the results based on the airline's name. The placeholder in the WHERE clause represents the name of the airline.\",\n        \"virtual_table\": \"SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T1.Airline  =  T2.uid WHERE T2.Airline = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.232", "db_id": "flight_2", "question": "What is the abbreviation of the airilne has the fewest flights and what country is it in?", "rationale": ["Identify the airline with the fewest flights by counting the number of flights for each airline in the 'flights' table.", "Use a subquery to group the flights by airline and order them by the count of flights in ascending order, limiting the result to the first entry (the airline with the fewest flights).", "Select the abbreviation and country of the airline identified in the subquery from the 'airlines' table."], "gold_sql": "SELECT T1.Abbreviation ,  T1.Country FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) LIMIT 1", "source_tables": ["flights", "airlines"], "pred_sql": "SELECT Abbreviation, Country FROM airlines WHERE uid = (SELECT Airline FROM flights GROUP BY Airline ORDER BY COUNT(FlightNo) ASC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the abbreviation of a specific airline from the 'airlines' table based on the airline's name. The placeholder in the WHERE clause represents the name of the airline.\",\n        \"virtual_table\": \"SELECT Abbreviation FROM AIRLINES WHERE Airline  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the unique flight numbers from the 'flights' table for a specific airline. The placeholder in the WHERE clause represents the name of the airline being queried.\",\n        \"virtual_table\": \"SELECT T1.FlightNo FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T2.uid  =  T1.Airline WHERE T2.Airline  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.244", "db_id": "flight_2", "question": "Which airlines have less than 200 flights?", "rationale": ["We need to find airlines with less than 200 flights.", "To do this, we can count the number of flights for each airline in the 'flights' table.", "We will use a GROUP BY clause to group the results by airline name and a HAVING clause to filter those groups to only include airlines with a count of flights less than 200.", "Next, we will join this result with the 'airlines' table to get the full airline names.", "The final query will select the airline names from the joined result."], "gold_sql": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  <  200", "source_tables": ["flights", "airlines"], "pred_sql": "SELECT T2.Airline FROM (SELECT Airline, COUNT(*) AS FlightCount FROM flights GROUP BY Airline HAVING COUNT(*) < 200) AS T1 JOIN airlines AS T2 ON T1.Airline = T2.uid;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of flights operated by a specific airline from the 'flights' table. It joins the 'flights' table with the 'airlines' table to filter the results based on the airline's name. The placeholder in the WHERE clause represents the name of the airline.\",\n        \"virtual_table\": \"SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T1.Airline  =  T2.uid WHERE T2.Airline = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the unique flight numbers from the 'flights' table for a specific airline. The placeholder in the WHERE clause represents the name of the airline being queried.\",\n        \"virtual_table\": \"SELECT T1.FlightNo FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T2.uid  =  T1.Airline WHERE T2.Airline  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the unique flight numbers from the 'flights' table for a specific airline. The placeholder in the WHERE clause represents the name of the airline being queried.\",\n        \"virtual_table\": \"SELECT T1.FlightNo FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T2.uid  =  T1.Airline WHERE T2.Airline  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.258", "db_id": "flight_2", "question": "Which airports do not have departing or arriving flights?", "rationale": ["Identify the airports from the 'airports' table.", "Use LEFT JOIN to connect the 'airports' table with the 'flights' table twice: once for departing flights (SourceAirport) and once for arriving flights (DestAirport).", "In the WHERE clause, check for NULL values in both joined tables' FlightNo columns to find airports without any flights.", "Select the AirportCode and AirportName from the airports table for the final output."], "gold_sql": "SELECT AirportName FROM Airports WHERE AirportCode NOT IN (SELECT SourceAirport FROM Flights UNION SELECT DestAirport FROM Flights)", "source_tables": ["airports", "flights"], "pred_sql": "SELECT a.AirportCode, a.AirportName \nFROM airports a \nLEFT JOIN flights f1 ON a.AirportCode = f1.SourceAirport \nLEFT JOIN flights f2 ON a.AirportCode = f2.DestAirport \nWHERE f1.FlightNo IS NULL AND f2.FlightNo IS NULL;", "hint": "\n"}
{"sample_id": "dev.308", "db_id": "cre_Doc_Template_Mgt", "question": "Count the number of documents that use the PPT template type.", "rationale": ["Identify the relevant tables: We need to count documents, so we will use the 'Documents' table.", "Join the 'Documents' table with the 'Templates' table to access the template type code associated with each document.", "Filter the results to only include documents that are associated with the 'PPT' template type by using a WHERE clause on the 'Template_Type_Code'.", "Use COUNT(DISTINCT D.Document_ID) to count the unique documents that match the criteria."], "gold_sql": "SELECT count(*) FROM Documents AS T1 JOIN Templates AS T2 ON T1.Template_ID  =  T2.Template_ID WHERE T2.Template_Type_Code  =  'PPT'", "source_tables": ["templates", "documents"], "pred_sql": "SELECT COUNT(DISTINCT D.Document_ID) \nFROM Documents D \nJOIN Templates T ON D.Template_ID = T.Template_ID \nWHERE T.Template_Type_Code = 'PPT';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the unique template type codes from the 'Templates' table that are not associated with any documents in the 'Documents' table. The query uses an EXCEPT clause to filter out template types that have been linked to documents, ensuring that only those template types without any corresponding documents are returned.\",\n        \"virtual_table\": \"SELECT template_type_code FROM Templates EXCEPT SELECT template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the minimum version number of templates grouped by their type code from the 'Templates' table. The placeholder in the SELECT clause represents the version number, while the template type code is used to categorize the templates.\",\n        \"virtual_table\": \"SELECT min(Version_Number) ,  template_type_code FROM Templates\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the minimum version number of templates grouped by their type code from the 'Templates' table. The placeholder in the SELECT clause represents the version number, while the template type code is used to categorize the templates.\",\n        \"virtual_table\": \"SELECT min(Version_Number) ,  template_type_code FROM Templates\"\n    }\n}\n"}
{"sample_id": "dev.311", "db_id": "cre_Doc_Template_Mgt", "question": "What is the id and type code for the template used by the most documents?", "rationale": ["Identify the relevant tables: We need to use the 'Templates' and 'Documents' tables to find the template used by the most documents.", "Join the 'Templates' table with the 'Documents' table on 'Template_ID' to associate templates with their corresponding documents.", "Group the results by 'Template_ID' and 'Template_Type_Code' to count how many documents are associated with each template.", "Use COUNT(Documents.Document_ID) to count the number of documents for each template.", "Order the results in descending order based on the count of documents to get the template used by the most documents at the top.", "Limit the results to 1 to get only the top template used by the most documents."], "gold_sql": "SELECT T1.template_id ,  T2.Template_Type_Code FROM Documents AS T1 JOIN Templates AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["templates", "documents"], "pred_sql": "SELECT Templates.Template_ID, Templates.Template_Type_Code \nFROM Templates \nJOIN Documents ON Templates.Template_ID = Documents.Template_ID \nGROUP BY Templates.Template_ID, Templates.Template_Type_Code \nORDER BY COUNT(Documents.Document_ID) DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the unique template type codes from the 'Templates' table that are not associated with any documents in the 'Documents' table. The query uses an EXCEPT clause to filter out template types that have been linked to documents, ensuring that only those template types without any corresponding documents are returned.\",\n        \"virtual_table\": \"SELECT template_type_code FROM Templates EXCEPT SELECT template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the minimum version number of templates grouped by their type code from the 'Templates' table. The placeholder in the SELECT clause represents the version number, while the template type code is used to categorize the templates.\",\n        \"virtual_table\": \"SELECT min(Version_Number) ,  template_type_code FROM Templates\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the minimum version number of templates grouped by their type code from the 'Templates' table. The placeholder in the SELECT clause represents the version number, while the template type code is used to categorize the templates.\",\n        \"virtual_table\": \"SELECT min(Version_Number) ,  template_type_code FROM Templates\"\n    }\n}\n"}
{"sample_id": "dev.312", "db_id": "cre_Doc_Template_Mgt", "question": "Return the id and type code of the template that is used for the greatest number of documents.", "rationale": ["We need to find the template that is used for the greatest number of documents.", "To do this, we will join the 'Templates' table with the 'Documents' table on the 'Template_ID'.", "Next, we will group the results by 'Template_ID' and 'Template_Type_Code' to count how many documents are associated with each template.", "We will use the COUNT function to count the number of documents for each template.", "Finally, we will order the results in descending order based on the count of documents and limit the result to 1 to get the template with the greatest number of documents."], "gold_sql": "SELECT T1.template_id ,  T2.Template_Type_Code FROM Documents AS T1 JOIN Templates AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["templates", "documents"], "pred_sql": "SELECT Templates.Template_ID, Templates.Template_Type_Code \nFROM Templates \nJOIN Documents ON Templates.Template_ID = Documents.Template_ID \nGROUP BY Templates.Template_ID, Templates.Template_Type_Code \nORDER BY COUNT(Documents.Document_ID) DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the minimum version number of templates grouped by their type code from the 'Templates' table. The placeholder in the SELECT clause represents the version number, while the template type code is used to categorize the templates.\",\n        \"virtual_table\": \"SELECT min(Version_Number) ,  template_type_code FROM Templates\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the minimum version number of templates grouped by their type code from the 'Templates' table. The placeholder in the SELECT clause represents the version number, while the template type code is used to categorize the templates.\",\n        \"virtual_table\": \"SELECT min(Version_Number) ,  template_type_code FROM Templates\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies the unique template type codes from the 'Templates' table that are not associated with any documents in the 'Documents' table. The query uses an EXCEPT clause to filter out template types that have been linked to documents, ensuring that only those template types without any corresponding documents are returned.\",\n        \"virtual_table\": \"SELECT template_type_code FROM Templates EXCEPT SELECT template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id\"\n    }\n}\n"}
{"sample_id": "dev.341", "db_id": "cre_Doc_Template_Mgt", "question": "Show all template type codes and the number of documents using each type.", "rationale": ["Identify the tables involved: Ref_Template_Types, Templates, and Documents.", "We need to show all template type codes, which are in the Ref_Template_Types table.", "We need to count the number of documents associated with each template type code, which requires joining the Templates and Documents tables.", "Use LEFT JOIN to ensure we include all template types even if they have no associated documents.", "Group the results by Template_Type_Code to get the count of documents for each type."], "gold_sql": "SELECT T1.template_type_code ,  count(*) FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_type_code", "source_tables": ["templates", "documents"], "pred_sql": "SELECT T.Template_Type_Code, COUNT(D.Document_ID) AS Document_Count \nFROM Ref_Template_Types AS T \nLEFT JOIN Templates AS Temp ON T.Template_Type_Code = Temp.Template_Type_Code \nLEFT JOIN Documents AS D ON Temp.Template_ID = D.Template_ID \nGROUP BY T.Template_Type_Code;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the unique template type codes from the 'Templates' table that are not associated with any documents in the 'Documents' table. The query uses an EXCEPT clause to filter out template types that have been linked to documents, ensuring that only those template types without any corresponding documents are returned.\",\n        \"virtual_table\": \"SELECT template_type_code FROM Templates EXCEPT SELECT template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the minimum version number of templates grouped by their type code from the 'Templates' table. The placeholder in the SELECT clause represents the version number, while the template type code is used to categorize the templates.\",\n        \"virtual_table\": \"SELECT min(Version_Number) ,  template_type_code FROM Templates\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the minimum version number of templates grouped by their type code from the 'Templates' table. The placeholder in the SELECT clause represents the version number, while the template type code is used to categorize the templates.\",\n        \"virtual_table\": \"SELECT min(Version_Number) ,  template_type_code FROM Templates\"\n    }\n}\n"}
{"sample_id": "dev.346", "db_id": "cre_Doc_Template_Mgt", "question": "What are the codes of template types that are not used for any document?", "rationale": ["Identify the table that contains template types: Ref_Template_Types.", "Identify the table that contains templates and their associated documents: Templates and Documents.", "Use an EXCEPT clause to find template types that are not associated with any documents.", "The first part of the EXCEPT clause selects all Template_Type_Code from the Ref_Template_Types table.", "The second part of the EXCEPT clause selects Template_Type_Code from Templates that have a corresponding entry in Documents, using a JOIN on Template_ID.", "Combine these two parts to get the final SQL query."], "gold_sql": "SELECT template_type_code FROM Templates EXCEPT SELECT template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id", "source_tables": ["templates", "documents"], "pred_sql": "SELECT Template_Type_Code FROM Ref_Template_Types EXCEPT SELECT T1.Template_Type_Code FROM Templates AS T1 JOIN Documents AS T2 ON T1.Template_ID = T2.Template_ID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the unique template type codes from the 'Templates' table that are not associated with any documents in the 'Documents' table. The query uses an EXCEPT clause to filter out template types that have been linked to documents, ensuring that only those template types without any corresponding documents are returned.\",\n        \"virtual_table\": \"SELECT template_type_code FROM Templates EXCEPT SELECT template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the minimum version number of templates grouped by their type code from the 'Templates' table. The placeholder in the SELECT clause represents the version number, while the template type code is used to categorize the templates.\",\n        \"virtual_table\": \"SELECT min(Version_Number) ,  template_type_code FROM Templates\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the minimum version number of templates grouped by their type code from the 'Templates' table. The placeholder in the SELECT clause represents the version number, while the template type code is used to categorize the templates.\",\n        \"virtual_table\": \"SELECT min(Version_Number) ,  template_type_code FROM Templates\"\n    }\n}\n"}
{"sample_id": "dev.361", "db_id": "cre_Doc_Template_Mgt", "question": "Show paragraph details for paragraph with text 'Korea ' .", "rationale": ["Identify the table to query: The question asks for paragraph details, which are stored in the 'Paragraphs' table.", "Determine the condition: We need to find paragraphs that contain the text 'Korea'.", "Use the LIKE operator: To search for a substring within the 'Paragraph_Text', we will use the LIKE operator with wildcards.", "Construct the SQL query: Combine the table name, selected columns (all columns in this case), and the WHERE clause to filter based on the specified text."], "gold_sql": "select other_details from paragraphs where paragraph_text like 'korea'", "source_tables": ["paragraphs"], "pred_sql": "select * from Paragraphs where Paragraph_Text like '%Korea%'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves additional details from the 'Paragraphs' table for paragraphs that contain specific text. The placeholder in the WHERE clause represents the text pattern to search for within the paragraph content.\",\n        \"virtual_table\": \"select other_details from paragraphs where paragraph_text like [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.367", "db_id": "cre_Doc_Template_Mgt", "question": "Show all document ids and the number of paragraphs in each document. Order by document id.", "rationale": ["Identify the tables needed: We need to retrieve data from the 'Documents' and 'Paragraphs' tables.", "Determine the required fields: We need 'Document_ID' from the 'Documents' table and a count of 'Paragraph_ID' from the 'Paragraphs' table.", "Establish the relationship: Use a LEFT JOIN to connect 'Documents' and 'Paragraphs' on 'Document_ID'. This allows us to count paragraphs even if there are none for a document.", "Group the results by 'Document_ID' to get the count of paragraphs for each document.", "Order the results by 'Document_ID' as specified in the query."], "gold_sql": "SELECT document_id ,  count(*) FROM Paragraphs GROUP BY document_id ORDER BY document_id", "source_tables": ["paragraphs"], "pred_sql": "SELECT Documents.Document_ID, COUNT(Paragraphs.Paragraph_ID) AS Number_of_Paragraphs\nFROM Documents\nLEFT JOIN Paragraphs ON Documents.Document_ID = Paragraphs.Document_ID\nGROUP BY Documents.Document_ID\nORDER BY Documents.Document_ID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves additional details from the 'Paragraphs' table for paragraphs that contain specific text. The placeholder in the WHERE clause represents the text pattern to search for within the paragraph content.\",\n        \"virtual_table\": \"select other_details from paragraphs where paragraph_text like [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.439", "db_id": "wta_1", "question": "Find the highest rank of losers in all matches.", "rationale": ["Identify the relevant table: The 'matches' table contains information about the matches, including the rank of the losing players.", "Determine the required information: We need to find the highest rank among all losers, which is represented by the 'loser_rank' column in the 'matches' table.", "Use the MAX() function: To find the highest rank, we can use the SQL aggregate function MAX() on the 'loser_rank' column.", "Construct the SQL query: The query selects the maximum value of 'loser_rank' from the 'matches' table."], "gold_sql": "SELECT min(loser_rank) FROM matches", "source_tables": ["matches"], "pred_sql": "SELECT MAX(loser_rank) AS highest_rank_of_losers\nFROM matches;", "hint": "\n"}
{"sample_id": "dev.458", "db_id": "wta_1", "question": "What are the full names of all left handed players, in order of birth date?", "rationale": ["Identify the relevant table: The 'players' table contains the information about players, including their names and handedness.", "Filter for left-handed players: We need to select only those players whose 'hand' column is 'left'.", "Select full names: To get the full names, we concatenate 'first_name' and 'last_name' using the '||' operator.", "Order by birth date: We need to sort the results by the 'birth_date' column in ascending order."], "gold_sql": "SELECT first_name ,  last_name FROM players WHERE hand  =  'L' ORDER BY birth_date", "source_tables": ["players"], "pred_sql": "SELECT first_name || ' ' || last_name AS full_name FROM players WHERE hand = 'left' ORDER BY birth_date;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of players' first names along with their country codes from the 'players' table, ordered by the number of tours they have participated in as recorded in the 'rankings' table. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT T1.country_code ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id ORDER BY T2.tours DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.464", "db_id": "wta_1", "question": "What is the name of the winner who has won the most matches, and how many rank points does this player have?", "rationale": ["Identify the relevant tables: 'matches' for match results and 'players' for player details.", "We need to find the winner who has won the most matches, so we will group the results by 'winner_id'.", "Count the number of matches won by each player using COUNT(*) and order the results in descending order to get the player with the most wins.", "We also need the winner's name and their rank points, which are available in the 'players' table.", "Join the 'matches' table with the 'players' table on 'winner_id' to get the winner's name and rank points.", "Limit the results to 1 to get only the top player."], "gold_sql": "SELECT winner_name ,  winner_rank_points FROM matches GROUP BY winner_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["matches"], "pred_sql": "SELECT winner_name, winner_rank_points FROM matches JOIN players ON matches.winner_id = players.player_id GROUP BY winner_id ORDER BY COUNT(*) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of players' first names along with their country codes from the 'players' table, ordered by the number of tours they have participated in as recorded in the 'rankings' table. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT T1.country_code ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id ORDER BY T2.tours DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.471", "db_id": "wta_1", "question": "Find the total ranking points for each player and their first name.", "rationale": ["We need to find the total ranking points for each player along with their first name.", "The relevant tables are 'players' for player information and 'rankings' for ranking points.", "We will join the 'players' table with the 'rankings' table on the player_id column to combine player names with their ranking points.", "To get the total ranking points for each player, we will use the SUM function on the ranking_points column from the 'rankings' table.", "We will group the results by the first_name column from the 'players' table to ensure we get a total for each player."], "gold_sql": "SELECT sum(ranking_points) ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.first_name", "source_tables": ["rankings", "players"], "pred_sql": "SELECT T1.first_name, SUM(T2.ranking_points) AS total_ranking_points FROM players AS T1 JOIN rankings AS T2 ON T1.player_id = T2.player_id GROUP BY T1.first_name", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of players' first names along with their country codes from the 'players' table, ordered by the number of tours they have participated in as recorded in the 'rankings' table. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT T1.country_code ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id ORDER BY T2.tours DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.479", "db_id": "wta_1", "question": "Find the total number of tours for each ranking date.", "rationale": ["We need to find the total number of tours for each ranking date.", "The relevant table for this information is the 'rankings' table, which contains the 'ranking_date' and 'tours' columns.", "To get the total number of tours for each ranking date, we can use the COUNT function on the 'tours' column.", "We will group the results by 'ranking_date' to get the count for each date."], "gold_sql": "SELECT sum(tours) ,  ranking_date FROM rankings GROUP BY ranking_date", "source_tables": ["rankings"], "pred_sql": "SELECT ranking_date, COUNT(tours) AS total_tours FROM rankings GROUP BY ranking_date", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of players' first names along with their country codes from the 'players' table, ordered by the number of tours they have participated in as recorded in the 'rankings' table. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT T1.country_code ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id ORDER BY T2.tours DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.480", "db_id": "wta_1", "question": "How many total tours were there for each ranking date?", "rationale": ["Identify the relevant table: The 'rankings' table contains the 'ranking_date' and 'tours' columns needed for the query.", "Use the COUNT function to calculate the total number of tours for each ranking date.", "Group the results by 'ranking_date' to get the total tours for each unique date."], "gold_sql": "SELECT sum(tours) ,  ranking_date FROM rankings GROUP BY ranking_date", "source_tables": ["rankings"], "pred_sql": "SELECT ranking_date, COUNT(tours) AS total_tours FROM rankings GROUP BY ranking_date;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of players' first names along with their country codes from the 'players' table, ordered by the number of tours they have participated in as recorded in the 'rankings' table. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT T1.country_code ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id ORDER BY T2.tours DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.533", "db_id": "student_transcripts_tracking", "question": "Who are enrolled in 2 degree programs in one semester? List the first name, middle name and last name and the id.", "rationale": ["Identify the relevant tables: Students and Student_Enrolment.", "We need to find students who are enrolled in two different degree programs during the same semester.", "Join the Students table with the Student_Enrolment table to get student details along with their enrolment records.", "To find students enrolled in two degree programs, we can join the Student_Enrolment table with itself (self-join) on the student_id.", "Ensure that the degree_program_id is different for the two enrolments but the semester_id is the same.", "Select the required fields: first_name, middle_name, last_name, and student_id."], "gold_sql": "SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  2", "source_tables": ["student_enrolment", "students"], "pred_sql": "SELECT s.first_name, s.middle_name, s.last_name, s.student_id\nFROM Students s\nJOIN Student_Enrolment se ON s.student_id = se.student_id\nJOIN Student_Enrolment se2 ON s.student_id = se2.student_id\nWHERE se.degree_program_id != se2.degree_program_id\nAND se.semester_id = se2.semester_id;", "hint": "\n"}
{"sample_id": "dev.536", "db_id": "student_transcripts_tracking", "question": "What are the first, middle, and last names for everybody enrolled in a Bachelors program?", "rationale": ["Identify the relevant tables: Students, Student_Enrolment, and Degree_Programs.", "We need to select the first, middle, and last names of students, which are in the Students table.", "To find out which students are enrolled in a Bachelors program, we need to join the Students table with the Student_Enrolment table on student_id.", "Next, we join the Student_Enrolment table with the Degree_Programs table on degree_program_id to filter for Bachelors programs.", "Use a WHERE clause to filter Degree_Programs for those that contain 'Bachelors' in their name.", "Construct the SELECT statement to retrieve the desired name fields from the Students table."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  'Bachelor'", "source_tables": ["student_enrolment", "degree_programs", "students"], "pred_sql": "SELECT s.first_name, s.middle_name, s.last_name \nFROM Students s \nJOIN Student_Enrolment se ON s.student_id = se.student_id \nJOIN Degree_Programs dp ON se.degree_program_id = dp.degree_program_id \nWHERE dp.degree_summary_name LIKE '%Bachelors%';", "hint": "\n"}
{"sample_id": "dev.537", "db_id": "student_transcripts_tracking", "question": "Find the kind of program which most number of students are enrolled in?", "rationale": ["Identify the relevant tables: We need to find the degree programs and the number of students enrolled in each program, so we will use the Student_Enrolment and Degree_Programs tables.", "Join the tables: We will join the Student_Enrolment table with the Degree_Programs table on the degree_program_id to associate each enrolment with its corresponding program.", "Count the number of students: We will use COUNT() to count the number of student enrolments for each degree program.", "Group by degree program: We will group the results by the degree_summary_name from the Degree_Programs table to get the count for each program.", "Order by count: We will order the results in descending order based on the student count to find out which program has the most students enrolled.", "Limit the results: Finally, we will limit the results to 1 to get only the program with the highest number of students."], "gold_sql": "SELECT T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_summary_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "degree_programs"], "pred_sql": "SELECT dp.degree_summary_name, COUNT(se.student_enrolment_id) AS student_count\nFROM Student_Enrolment se\nJOIN Degree_Programs dp ON se.degree_program_id = dp.degree_program_id\nGROUP BY dp.degree_summary_name\nORDER BY student_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "dev.539", "db_id": "student_transcripts_tracking", "question": "Find the program which most number of students are enrolled in. List both the id and the summary.", "rationale": ["Identify the relevant tables: Degree_Programs and Student_Enrolment.", "We need to find the degree program with the most students enrolled, so we will join these two tables on the degree_program_id.", "Group the results by degree_program_id and degree_summary_name to count the number of students enrolled in each program.", "Use COUNT(se.student_id) to count the number of students for each program.", "Order the results in descending order based on the count of students to get the program with the most enrollments at the top.", "Limit the results to 1 to get only the program with the highest enrollment."], "gold_sql": "SELECT T1.degree_program_id ,  T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_program_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "degree_programs"], "pred_sql": "SELECT dp.degree_program_id, dp.degree_summary_name\nFROM Degree_Programs dp\nJOIN Student_Enrolment se ON dp.degree_program_id = se.degree_program_id\nGROUP BY dp.degree_program_id, dp.degree_summary_name\nORDER BY COUNT(se.student_id) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "dev.541", "db_id": "student_transcripts_tracking", "question": "Which student has enrolled for the most times in any program? List the id, first name, middle name, last name, the number of enrollments and student id.", "rationale": ["Identify the relevant tables: Students and Student_Enrolment.", "We need to count the number of enrollments for each student, so we will join the Students table with the Student_Enrolment table on the student_id.", "Use COUNT() function to count the number of enrollments for each student.", "Group the results by student_id to aggregate the counts for each student.", "Order the results by the count of enrollments in descending order to find the student with the most enrollments.", "Limit the results to 1 to get only the top student."], "gold_sql": "SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "students"], "pred_sql": "SELECT s.student_id, s.first_name, s.middle_name, s.last_name, COUNT(se.student_enrolment_id) AS number_of_enrollments\nFROM Students s\nJOIN Student_Enrolment se ON s.student_id = se.student_id\nGROUP BY s.student_id\nORDER BY number_of_enrollments DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "dev.547", "db_id": "student_transcripts_tracking", "question": "What's the name of the course with most number of enrollments?", "rationale": ["Identify the table that contains course information, which is the 'Courses' table.", "Identify the table that tracks student enrollments in courses, which is the 'Student_Enrolment_Courses' table.", "Join the 'Courses' table with the 'Student_Enrolment_Courses' table on the course_id to link courses with their enrollments.", "Group the results by course_id to aggregate the number of enrollments for each course.", "Count the number of enrollments for each course using COUNT(SEC.student_course_id).", "Order the results in descending order based on the count of enrollments to find the course with the most enrollments.", "Limit the results to 1 to get only the top course."], "gold_sql": "SELECT  T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["courses", "student_enrolment_courses"], "pred_sql": "SELECT C.course_name\nFROM Courses C\nJOIN Student_Enrolment_Courses SEC ON C.course_id = SEC.course_id\nGROUP BY C.course_id\nORDER BY COUNT(SEC.student_course_id) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "dev.550", "db_id": "student_transcripts_tracking", "question": "What are the last name of the students who live in North Carolina but have not registered in any degree programs?", "rationale": ["Identify the relevant table: We need to look at the Students table to get the last names of students.", "Filter students based on their address: We need to find students who live in North Carolina. This requires a subquery to the Addresses table to get the address IDs for North Carolina.", "Check for degree program registration: We need to ensure that these students have not registered for any degree programs. This requires another subquery to the Student_Enrolment table to find students who are enrolled in any degree program.", "Combine the conditions: Use the results from the two subqueries to filter the main query on the Students table, selecting only those students who meet both criteria."], "gold_sql": "SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  'NorthCarolina' EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id", "source_tables": ["addresses", "student_enrolment", "students"], "pred_sql": "SELECT last_name \nFROM Students \nWHERE current_address_id IN (\n    SELECT address_id \n    FROM Addresses \n    WHERE state_province_county = 'North Carolina'\n) \nAND student_id NOT IN (\n    SELECT student_id \n    FROM Student_Enrolment\n);", "hint": "\n"}
{"sample_id": "dev.554", "db_id": "student_transcripts_tracking", "question": "What is the mobile phone number of the student named Timmothy Ward ?", "rationale": ["Identify the table that contains student information, which is the 'Students' table.", "Determine the columns needed: we need the 'cell_mobile_number' of the student.", "Filter the results by the student's first name and last name, which are 'Timmothy' and 'Ward' respectively.", "Construct the SQL query using a SELECT statement to retrieve the mobile phone number from the Students table with the specified conditions."], "gold_sql": "select cell_mobile_number from students where first_name  =  'timmothy' and last_name  =  'ward'", "source_tables": ["students"], "pred_sql": "SELECT cell_mobile_number FROM Students WHERE first_name = 'Timmothy' AND last_name = 'Ward';", "hint": "\n"}
{"sample_id": "dev.561", "db_id": "student_transcripts_tracking", "question": "Which address holds the most number of students currently? List the address id and all lines.", "rationale": ["We need to find the address that holds the most number of students currently.", "To do this, we will count the number of distinct students associated with each current address in the 'Students' table.", "We will group the results by 'current_address_id' and order them in descending order based on the count of students.", "To get the address details, we will join this result with the 'Addresses' table on 'address_id'.", "Finally, we will select the address id and all lines (line_1, line_2, line_3) for the address with the highest student count."], "gold_sql": "SELECT T1.address_id ,  T1.line_1 ,  T1.line_2 FROM Addresses AS T1 JOIN Students AS T2 ON T1.address_id  =  T2.current_address_id GROUP BY T1.address_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "students"], "pred_sql": "SELECT a.address_id, a.line_1, a.line_2, a.line_3\nFROM Addresses a\nJOIN (SELECT current_address_id, COUNT(DISTINCT student_id) AS student_count\n      FROM Students\n      GROUP BY current_address_id\n      ORDER BY student_count DESC\n      LIMIT 1) AS address_counts\nON a.address_id = address_counts.current_address_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of distinct current addresses associated with students from the 'Students' table. The placeholder in the SELECT clause represents the unique current address identifiers.\",\n        \"virtual_table\": \"SELECT count(DISTINCT current_address_id) FROM Students\"\n    }\n}\n"}
{"sample_id": "dev.576", "db_id": "student_transcripts_tracking", "question": "What is the id of the semester that had both Masters and Bachelors students enrolled?", "rationale": ["Identify the relevant tables: Student_Enrolment and Degree_Programs.", "We need to find semesters that had both Masters and Bachelors students enrolled.", "Join the Student_Enrolment table with the Degree_Programs table on the degree_program_id.", "Filter the results to include only those degree programs that are either 'Masters' or 'Bachelors'.", "Group the results by semester_id to aggregate the data for each semester.", "Use HAVING clause to ensure that both degree types are present in the results by counting distinct degree_summary_name and checking if it equals 2."], "gold_sql": "SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Master' INTERSECT SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Bachelor'", "source_tables": ["student_enrolment", "degree_programs"], "pred_sql": "SELECT DISTINCT se.semester_id\nFROM Student_Enrolment se\nJOIN Degree_Programs dp ON se.degree_program_id = dp.degree_program_id\nWHERE dp.degree_summary_name IN ('Masters', 'Bachelors')\nGROUP BY se.semester_id\nHAVING COUNT(DISTINCT dp.degree_summary_name) = 2;", "hint": "\n"}
{"sample_id": "dev.580", "db_id": "student_transcripts_tracking", "question": "What other details can you tell me about students in reverse alphabetical order?", "rationale": ["The user is asking for additional details about students.", "We will select the 'other_student_details' column from the 'Students' table.", "To meet the requirement of reverse alphabetical order, we will use the ORDER BY clause with DESC (descending) on 'other_student_details'."], "gold_sql": "SELECT other_student_details FROM Students ORDER BY other_student_details DESC", "source_tables": ["students"], "pred_sql": "SELECT other_student_details FROM Students ORDER BY other_student_details DESC", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of additional details related to students from the 'Students' table, sorted in descending order. The placeholder in the SELECT clause represents the specific details of the students.\",\n        \"virtual_table\": \"SELECT other_student_details FROM Students ORDER BY other_student_details DESC\"\n    }\n}\n"}
{"sample_id": "dev.581", "db_id": "student_transcripts_tracking", "question": "Describe the section h.", "rationale": ["The user wants to describe a specific section identified by the name 'h'.", "To retrieve information about a section, we need to select all columns from the Sections table.", "We will use a WHERE clause to filter the results to only include the section with the name 'h'."], "gold_sql": "SELECT section_description FROM Sections WHERE section_name  =  'h'", "source_tables": ["sections"], "pred_sql": "SELECT * FROM Sections WHERE section_name = 'h';", "hint": "\n"}
{"sample_id": "dev.705", "db_id": "world_1", "question": "How many countries have governments that are republics?", "rationale": ["Identify the relevant table: The 'country' table contains information about countries and their government forms.", "Determine the specific condition: We need to count countries where the GovernmentForm is 'Republic'.", "Construct the SQL query using the count function: We will use SELECT count(*) to get the total number of countries that meet the condition.", "Use the WHERE clause to filter results based on the GovernmentForm being 'Republic'."], "gold_sql": "SELECT count(*) FROM country WHERE GovernmentForm  =  'Republic'", "source_tables": ["country"], "pred_sql": "SELECT count(*) FROM country WHERE GovernmentForm = 'Republic'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM country WHERE GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the number of countries where two specific languages are spoken. The placeholders in the query represent the names of the languages being compared.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average life expectancy of countries from the 'country' table that are located in a specific continent and have a particular form of government. The placeholders in the WHERE clause represent the continent and the government form.\",\n        \"virtual_table\": \"SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING] AND GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.730", "db_id": "world_1", "question": "What is the average GNP and total population in all nations whose government is US territory?", "rationale": ["Identify the required data: average GNP and total population of countries with a specific government form.", "Use the 'country' table to access GNP and Population columns.", "Filter the results based on the government form, which is 'US territory'.", "Calculate the average GNP using the AVG() function and total population using the SUM() function."], "gold_sql": "SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  'US Territory'", "source_tables": ["country"], "pred_sql": "SELECT avg(GNP) AS AverageGNP, sum(Population) AS TotalPopulation FROM country WHERE GovernmentForm = 'US territory'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average life expectancy of countries from the 'country' table that are located in a specific continent and have a particular form of government. The placeholders in the WHERE clause represent the continent and the government form.\",\n        \"virtual_table\": \"SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING] AND GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average life expectancy of countries from the 'country' table that are located in a specific continent and have a particular form of government. The placeholders in the WHERE clause represent the continent and the government form.\",\n        \"virtual_table\": \"SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING] AND GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM country WHERE GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.734", "db_id": "world_1", "question": "How many type of governments are in Africa?", "rationale": ["The question asks for the number of types of governments in Africa, which implies we need to look at the 'GovernmentForm' column in the 'country' table.", "We need to filter the results to only include countries that are located in Africa, which can be done by adding a WHERE clause that specifies 'Continent = 'Africa'.", "To get the distinct types of governments, we will use the DISTINCT keyword in our SELECT statement to ensure we only count unique government forms."], "gold_sql": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  'Africa'", "source_tables": ["country"], "pred_sql": "SELECT DISTINCT GovernmentForm FROM country WHERE Continent = 'Africa'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM country WHERE GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average life expectancy of countries from the 'country' table that are located in a specific continent and have a particular form of government. The placeholders in the WHERE clause represent the continent and the government form.\",\n        \"virtual_table\": \"SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING] AND GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average life expectancy of countries from the 'country' table that are located in a specific continent and have a particular form of government. The placeholders in the WHERE clause represent the continent and the government form.\",\n        \"virtual_table\": \"SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING] AND GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.735", "db_id": "world_1", "question": "How many different forms of governments are there in Africa?", "rationale": ["Identify the relevant table: The 'country' table contains information about countries, including their forms of government and continent.", "Determine the specific requirement: The question asks for the number of different forms of governments in Africa.", "Use the DISTINCT keyword: To find different forms of government, we can use the DISTINCT keyword to ensure we only get unique values.", "Filter by continent: We need to filter the results to only include countries in Africa by adding a WHERE clause that specifies Continent = 'Africa'.", "Construct the SQL query: Combine all these elements into a single SQL query that selects distinct forms of government from the 'country' table where the continent is Africa."], "gold_sql": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  'Africa'", "source_tables": ["country"], "pred_sql": "SELECT DISTINCT GovernmentForm FROM country WHERE Continent = 'Africa'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM country WHERE GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average life expectancy of countries from the 'country' table that are located in a specific continent and have a particular form of government. The placeholders in the WHERE clause represent the continent and the government form.\",\n        \"virtual_table\": \"SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING] AND GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average life expectancy of countries from the 'country' table that are located in a specific continent and have a particular form of government. The placeholders in the WHERE clause represent the continent and the government form.\",\n        \"virtual_table\": \"SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING] AND GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.742", "db_id": "world_1", "question": "Which continent has the most diverse languages?", "rationale": ["Identify the need to find the continent with the most diverse languages.", "To achieve this, we need to count the distinct languages spoken in each continent.", "We will join the 'country' table with the 'countrylanguage' table on the country code.", "We will group the results by continent and count the distinct languages for each continent.", "Finally, we will order the results in descending order based on the count of distinct languages and limit the output to 1 to get the continent with the most diverse languages."], "gold_sql": "SELECT T1.Continent FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT continent, COUNT(DISTINCT Language) AS language_count \nFROM country \nJOIN countrylanguage ON country.Code = countrylanguage.CountryCode \nGROUP BY continent \nORDER BY language_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of countries where two specific languages are spoken. The placeholders in the query represent the names of the languages being compared.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.743", "db_id": "world_1", "question": "Which continent speaks the most languages?", "rationale": ["Identify the tables involved: We need to use the 'country' and 'countrylanguage' tables to find out which continent speaks the most languages.", "Join the 'country' table with the 'countrylanguage' table on the 'Code' and 'CountryCode' columns to get the languages spoken in each country.", "Group the results by continent to count the distinct languages spoken in each continent.", "Use COUNT(DISTINCT cl.Language) to count the number of unique languages for each continent.", "Order the results in descending order based on the count of languages.", "Limit the results to 1 to get the continent with the most languages."], "gold_sql": "SELECT T1.Continent FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT continent, COUNT(DISTINCT cl.Language) AS language_count \nFROM country c \nJOIN countrylanguage cl ON c.Code = cl.CountryCode \nGROUP BY continent \nORDER BY language_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of countries where two specific languages are spoken. The placeholders in the query represent the names of the languages being compared.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.746", "db_id": "world_1", "question": "What are the names of nations speak both English and French?", "rationale": ["Identify the requirement: We need to find the names of nations that speak both English and French.", "Understand the schema: We have a 'country' table and a 'countrylanguage' table that links countries to their languages.", "Use the provided hint: The hint suggests using an INTERSECT query to find countries that speak both languages.", "Construct the first part of the query: Select country names where the language is English.", "Construct the second part of the query: Select country names where the language is French.", "Combine both parts using INTERSECT to get countries that speak both English and French."], "gold_sql": "SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English' INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'French'", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode WHERE T2.Language = 'French'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of countries where two specific languages are spoken. The placeholders in the query represent the names of the languages being compared.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.755", "db_id": "world_1", "question": "Which countries have either English or Dutch as an official language?", "rationale": ["We need to find countries that have either English or Dutch as an official language.", "To do this, we will join the 'country' table with the 'countrylanguage' table on the 'Code' and 'CountryCode' columns respectively.", "We will filter the results to include only those rows where the 'Language' is either 'English' or 'Dutch'.", "Additionally, we will ensure that the language is marked as official by checking that 'IsOfficial' is 'T'.", "Finally, we will select distinct country names to avoid duplicates in the result."], "gold_sql": "SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English' AND IsOfficial  =  'T' UNION SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'Dutch' AND IsOfficial  =  'T'", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT DISTINCT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode WHERE T2.Language IN ('English', 'Dutch') AND T2.IsOfficial = 'T';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of countries where two specific languages are spoken. The placeholders in the query represent the names of the languages being compared.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.766", "db_id": "world_1", "question": "What is the total number of people living in the nations that do not use English?", "rationale": ["Identify the requirement: We need to find the total population of countries that do not use English as a language.", "To achieve this, we will first identify the countries that do use English by querying the countrylanguage table.", "We will select the CountryCode from the countrylanguage table where the Language is 'English'.", "Next, we will use this list of CountryCodes to filter out these countries from the country table.", "Finally, we will sum the Population of the remaining countries that do not have English as an official language."], "gold_sql": "SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English')", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT SUM(Population) FROM country WHERE Code NOT IN (SELECT CountryCode FROM countrylanguage WHERE Language = 'English')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of countries where two specific languages are spoken. The placeholders in the query represent the names of the languages being compared.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.767", "db_id": "world_1", "question": "How many people live in countries that do not speak English?", "rationale": ["Identify the requirement: We need to find the total population of countries that do not speak English.", "To achieve this, we will first identify the countries that speak English by querying the countrylanguage table.", "We will use a subquery to select the CountryCode of countries where the Language is 'English'.", "Next, we will use this subquery in the main query to filter out these countries from the country table.", "Finally, we will sum the Population of the remaining countries to get the total population of countries that do not speak English."], "gold_sql": "SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English')", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT SUM(Population) FROM country WHERE Code NOT IN (SELECT CountryCode FROM countrylanguage WHERE Language = 'English')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of countries where two specific languages are spoken. The placeholders in the query represent the names of the languages being compared.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.783", "db_id": "world_1", "question": "Return the codes of countries that do not speak English and do not have Republics for governments.", "rationale": ["Identify the requirement to find country codes that do not speak English and do not have Republics for governments.", "To find countries that do not speak English, we can use a subquery to select CountryCodes from the countrylanguage table where the Language is 'English'.", "To find countries that do not have Republics for governments, we can filter the country table where the GovernmentForm does not contain the word 'Republic'.", "Combine these two conditions in the main query to select the Code from the country table, ensuring that the Code is not in the list of CountryCodes that speak English and also does not match any country with a GovernmentForm containing 'Republic'."], "gold_sql": "SELECT Code FROM country WHERE GovernmentForm != 'Republic' EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  'English'", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT Code FROM country WHERE Code NOT IN (SELECT CountryCode FROM countrylanguage WHERE Language = 'English') AND GovernmentForm NOT LIKE '%Republic%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of countries where two specific languages are spoken. The placeholders in the query represent the names of the languages being compared.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM country WHERE GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.784", "db_id": "world_1", "question": "Which cities are in European countries where English is not the official language?", "rationale": ["Identify the relevant tables: We need to use the 'city', 'country', and 'countrylanguage' tables to answer the question.", "Determine the relationships: The 'city' table is linked to the 'country' table through the 'CountryCode' field, and the 'country' table is linked to the 'countrylanguage' table also through the 'CountryCode'.", "Filter for European countries: We need to filter the results to only include countries that are in Europe, which can be done by checking the 'Continent' column in the 'country' table.", "Filter for English language: We need to ensure that we are looking at countries where English is spoken, which is indicated by the 'Language' column in the 'countrylanguage' table.", "Check if English is not official: We need to ensure that English is not an official language, which can be checked using the 'IsOfficial' column in the 'countrylanguage' table.", "Select city names: Finally, we want to select the names of the cities that meet all these criteria."], "gold_sql": "SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  'Europe' AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  'T' AND T4.Language  =  'English')", "source_tables": ["country", "city", "countrylanguage"], "pred_sql": "SELECT city.Name \nFROM city \nJOIN country ON city.CountryCode = country.Code \nJOIN countrylanguage ON country.Code = countrylanguage.CountryCode \nWHERE country.Continent = 'Europe' \nAND countrylanguage.Language = 'English' \nAND countrylanguage.IsOfficial = 'FALSE';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of countries where two specific languages are spoken. The placeholders in the query represent the names of the languages being compared.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.785", "db_id": "world_1", "question": "What are the names of cities in Europe for which English is not the official language?", "rationale": ["Identify the relevant tables: We need to get city names, so we will use the 'city' table. We also need to filter by continent and language, so we will join the 'country' and 'countrylanguage' tables.", "Join the 'city' table with the 'country' table on the CountryCode to get the continent information.", "Use a LEFT JOIN with the 'countrylanguage' table to include cities even if they don't have an official language listed.", "Filter for cities in Europe by checking the continent in the 'country' table.", "Filter out cities where English is an official language by checking that the language is not 'English' or is NULL (to include cities where no official language is specified).", "Select only the names of the cities that meet these criteria."], "gold_sql": "SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  'Europe' AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  'T' AND T4.Language  =  'English')", "source_tables": ["country", "city", "countrylanguage"], "pred_sql": "SELECT city.Name \nFROM city \nJOIN country ON city.CountryCode = country.Code \nLEFT JOIN countrylanguage ON country.Code = countrylanguage.CountryCode \nWHERE country.Continent = 'Europe' \nAND (countrylanguage.Language != 'English' OR countrylanguage.Language IS NULL)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of countries where two specific languages are spoken. The placeholders in the query represent the names of the languages being compared.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.788", "db_id": "world_1", "question": "What are the name, independence year, and surface area of the country with the smallest population?", "rationale": ["Identify the required fields: Name, Independence Year (IndepYear), and Surface Area from the country table.", "Determine the condition to find the country with the smallest population, which involves using a subquery to get the minimum population.", "Construct the main query to select the desired fields from the country table where the population matches the minimum population found in the subquery."], "gold_sql": "SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT 1", "source_tables": ["country"], "pred_sql": "SELECT Name, IndepYear, SurfaceArea FROM country WHERE Population = (SELECT MIN(Population) FROM country);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of countries where two specific languages are spoken. The placeholders in the query represent the names of the languages being compared.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM country WHERE GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average life expectancy of countries from the 'country' table that are located in a specific continent and have a particular form of government. The placeholders in the WHERE clause represent the continent and the government form.\",\n        \"virtual_table\": \"SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING] AND GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.789", "db_id": "world_1", "question": "Give the name, year of independence, and surface area of the country that has the lowest population.", "rationale": ["Identify the required fields: Name, year of independence (IndepYear), and surface area (SurfaceArea) from the country table.", "Determine the condition to find the country with the lowest population, which involves using a subquery to get the minimum population from the country table.", "Construct the main query to select the Name, IndepYear, and SurfaceArea from the country table where the Population matches the minimum population found in the subquery."], "gold_sql": "SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT 1", "source_tables": ["country"], "pred_sql": "SELECT Name, IndepYear, SurfaceArea FROM country WHERE Population = (SELECT MIN(Population) FROM country);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of countries where two specific languages are spoken. The placeholders in the query represent the names of the languages being compared.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average life expectancy of countries from the 'country' table that are located in a specific continent and have a particular form of government. The placeholders in the WHERE clause represent the continent and the government form.\",\n        \"virtual_table\": \"SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING] AND GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average life expectancy of countries from the 'country' table that are located in a specific continent and have a particular form of government. The placeholders in the WHERE clause represent the continent and the government form.\",\n        \"virtual_table\": \"SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING] AND GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.793", "db_id": "world_1", "question": "What are the names of countries that speak more than 2 languages, as well as how many languages they speak?", "rationale": ["Identify the relevant tables: We need to use the 'country' table to get country names and the 'countrylanguage' table to count the languages spoken in each country.", "Join the 'country' and 'countrylanguage' tables on the 'Code' and 'CountryCode' columns respectively to associate countries with their languages.", "Group the results by country name to aggregate the language counts for each country.", "Use the COUNT function to count the number of languages spoken in each country.", "Filter the results using HAVING clause to include only those countries that speak more than 2 languages."], "gold_sql": "SELECT COUNT(T2.Language) ,  T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Name HAVING COUNT(*)  >  2", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT c.Name, COUNT(cl.Language) AS LanguageCount \nFROM country AS c \nJOIN countrylanguage AS cl ON c.Code = cl.CountryCode \nGROUP BY c.Name \nHAVING COUNT(cl.Language) > 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of countries where two specific languages are spoken. The placeholders in the query represent the names of the languages being compared.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.796", "db_id": "world_1", "question": "Find the government form name and total population for each government form whose average life expectancy is longer than 72.", "rationale": ["Identify the columns needed: GovernmentForm and Population.", "We need to filter countries based on LifeExpectancy being greater than 72.", "We will group the results by GovernmentForm to get the total population for each form of government.", "Use SUM function to calculate the total population for each government form."], "gold_sql": "SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  72", "source_tables": ["country"], "pred_sql": "SELECT GovernmentForm, SUM(Population) AS TotalPopulation \nFROM country \nWHERE LifeExpectancy > 72 \nGROUP BY GovernmentForm;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average life expectancy of countries from the 'country' table that are located in a specific continent and have a particular form of government. The placeholders in the WHERE clause represent the continent and the government form.\",\n        \"virtual_table\": \"SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING] AND GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average life expectancy of countries from the 'country' table that are located in a specific continent and have a particular form of government. The placeholders in the WHERE clause represent the continent and the government form.\",\n        \"virtual_table\": \"SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING] AND GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM country WHERE GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.797", "db_id": "world_1", "question": "What are the different government forms and what is the total population of each for government forms that have an average life expectancy greater than 72?", "rationale": ["Identify the columns needed: GovernmentForm and Population.", "We need to group the results by GovernmentForm to get the total population for each form.", "We need to filter the countries based on the condition that their average LifeExpectancy is greater than 72.", "Use the SUM function to calculate the total population for each government form.", "Construct the SQL query using the SELECT statement with the necessary columns, filtering, and grouping."], "gold_sql": "SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  72", "source_tables": ["country"], "pred_sql": "SELECT GovernmentForm, SUM(Population) AS TotalPopulation \nFROM country \nWHERE LifeExpectancy > 72 \nGROUP BY GovernmentForm;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average life expectancy of countries from the 'country' table that are located in a specific continent and have a particular form of government. The placeholders in the WHERE clause represent the continent and the government form.\",\n        \"virtual_table\": \"SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING] AND GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average life expectancy of countries from the 'country' table that are located in a specific continent and have a particular form of government. The placeholders in the WHERE clause represent the continent and the government form.\",\n        \"virtual_table\": \"SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING] AND GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM country WHERE GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.801", "db_id": "world_1", "question": "Return the names and surface areas of the 5 largest countries.", "rationale": ["Identify the table that contains the required information: The 'country' table has the columns 'Name' and 'SurfaceArea'.", "We need to return the names and surface areas of the largest countries, which implies sorting by surface area in descending order.", "To get the top 5 largest countries, we will use the LIMIT clause to restrict the results to 5 entries after sorting."], "gold_sql": "SELECT Name ,  SurfaceArea FROM country ORDER BY SurfaceArea DESC LIMIT 5", "source_tables": ["country"], "pred_sql": "SELECT Name, SurfaceArea FROM country ORDER BY SurfaceArea DESC LIMIT 5;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of countries where two specific languages are spoken. The placeholders in the query represent the names of the languages being compared.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average life expectancy of countries from the 'country' table that are located in a specific continent and have a particular form of government. The placeholders in the WHERE clause represent the continent and the government form.\",\n        \"virtual_table\": \"SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING] AND GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average life expectancy of countries from the 'country' table that are located in a specific continent and have a particular form of government. The placeholders in the WHERE clause represent the continent and the government form.\",\n        \"virtual_table\": \"SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING] AND GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.810", "db_id": "world_1", "question": "What is the total population and average area of countries in the continent of North America whose area is bigger than 3000 ?", "rationale": ["Identify the required data: total population and average area of countries.", "Determine the relevant table: 'country' contains both population and surface area.", "Filter the countries based on continent: 'North America'.", "Add a condition to filter countries with surface area greater than 3000.", "Use SUM() to calculate total population and AVG() to calculate average surface area in the SQL query."], "gold_sql": "select sum(population) ,  avg(surfacearea) from country where continent  =  'north america' and surfacearea  >  3000", "source_tables": ["country"], "pred_sql": "SELECT SUM(Population) AS TotalPopulation, AVG(SurfaceArea) AS AverageArea FROM country WHERE Continent = 'North America' AND SurfaceArea > 3000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average life expectancy of countries from the 'country' table that are located in a specific continent and have a particular form of government. The placeholders in the WHERE clause represent the continent and the government form.\",\n        \"virtual_table\": \"SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING] AND GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average life expectancy of countries from the 'country' table that are located in a specific continent and have a particular form of government. The placeholders in the WHERE clause represent the continent and the government form.\",\n        \"virtual_table\": \"SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING] AND GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the number of countries where two specific languages are spoken. The placeholders in the query represent the names of the languages being compared.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.811", "db_id": "world_1", "question": "Give the total population and average surface area corresponding to countries in North America that have a surface area greater than 3000 .", "rationale": ["Identify the relevant tables: We need data from the 'country' table for population and surface area.", "Determine the conditions: We are interested in countries in North America with a surface area greater than 3000.", "Select the required fields: We need to calculate the total population and average surface area.", "Construct the SQL query: Use SUM() for total population and AVG() for average surface area, applying the conditions identified."], "gold_sql": "select sum(population) ,  avg(surfacearea) from country where continent  =  'north america' and surfacearea  >  3000", "source_tables": ["country"], "pred_sql": "SELECT SUM(Population) AS TotalPopulation, AVG(SurfaceArea) AS AverageSurfaceArea FROM country WHERE Continent = 'North America' AND SurfaceArea > 3000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average life expectancy of countries from the 'country' table that are located in a specific continent and have a particular form of government. The placeholders in the WHERE clause represent the continent and the government form.\",\n        \"virtual_table\": \"SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING] AND GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average life expectancy of countries from the 'country' table that are located in a specific continent and have a particular form of government. The placeholders in the WHERE clause represent the continent and the government form.\",\n        \"virtual_table\": \"SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING] AND GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the number of countries where two specific languages are spoken. The placeholders in the query represent the names of the languages being compared.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.812", "db_id": "world_1", "question": "What are the cities whose population is between 160000 and 900000?", "rationale": ["Identify the table to query: The relevant table is 'city' which contains population data.", "Determine the condition for filtering: We need to find cities with a population between 160000 and 900000.", "Construct the SQL query: Use the SELECT statement to retrieve all columns from the 'city' table where the population falls within the specified range using the BETWEEN clause."], "gold_sql": "SELECT name FROM city WHERE Population BETWEEN 160000 AND 900000", "source_tables": ["city"], "pred_sql": "SELECT * FROM city WHERE Population BETWEEN '160000' AND '900000';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of countries where two specific languages are spoken. The placeholders in the query represent the names of the languages being compared.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.921", "db_id": "dog_kennels", "question": "Find the average age of the dogs who went through treatments.", "rationale": ["Identify the relevant tables: Dogs and Treatments.", "We need to find the average age of dogs that have undergone treatments, so we will join the Dogs table with the Treatments table on the dog_id.", "Select the age of the dogs from the Dogs table and calculate the average using the AVG() function.", "Return the result as average_age."], "gold_sql": "SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )", "source_tables": ["dogs", "treatments"], "pred_sql": "SELECT AVG(D.age) AS average_age\nFROM Dogs D\nJOIN Treatments T ON D.dog_id = T.dog_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a unique list of breed codes and size codes for dogs from the 'Dogs' table. The placeholders represent the breed and size categories associated with the dogs.\",\n        \"virtual_table\": \"SELECT DISTINCT breed_code ,  size_code FROM dogs\"\n    }\n}\n"}
{"sample_id": "dev.924", "db_id": "dog_kennels", "question": "Which dogs have not cost their owner more than 1000 for treatment ? List the dog names .", "rationale": ["Identify the relevant tables: Dogs and Treatments.", "We need to find dogs that have not cost their owner more than 1000 for treatment, which means we will need to sum the treatment costs for each dog.", "Join the Dogs table with the Treatments table on the dog_id to link each dog with its treatments.", "Group the results by dog_id to aggregate the treatment costs for each dog.", "Use the HAVING clause to filter out dogs whose total treatment cost is greater than 1000."], "gold_sql": "select name from dogs where dog_id not in ( select dog_id from treatments group by dog_id having sum(cost_of_treatment)  >  1000 )", "source_tables": ["dogs", "treatments"], "pred_sql": "SELECT D.name \nFROM Dogs D \nJOIN Treatments T ON D.dog_id = T.dog_id \nGROUP BY D.dog_id \nHAVING SUM(T.cost_of_treatment) <= 1000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a unique list of breed codes and size codes for dogs from the 'Dogs' table. The placeholders represent the breed and size categories associated with the dogs.\",\n        \"virtual_table\": \"SELECT DISTINCT breed_code ,  size_code FROM dogs\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique first names of professionals along with the descriptions of the treatment types they have administered. The data is sourced from the 'Professionals', 'Treatments', and 'Treatment_Types' tables, ensuring that only distinct combinations of professional names and treatment descriptions are displayed.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code\"\n    }\n}\n"}
{"sample_id": "dev.937", "db_id": "dog_kennels", "question": "Tell me the owner id and last name of the owner who spent the most on treatments of his or her dogs.", "rationale": ["We need to find the owner who spent the most on treatments for their dogs.", "To do this, we will join the Owners table with the Dogs table using the owner_id, and then join the Treatments table using the dog_id.", "This will allow us to access the treatment costs associated with each dog owned by an owner.", "Next, we will group the results by owner_id and last_name to aggregate the total treatment costs for each owner.", "We will use the SUM function to calculate the total cost of treatments for each owner.", "Finally, we will order the results in descending order based on the total treatment costs and limit the result to 1 to get the owner who spent the most."], "gold_sql": "SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["owners", "dogs", "treatments"], "pred_sql": "SELECT O.owner_id, O.last_name\nFROM Owners O\nJOIN Dogs D ON O.owner_id = D.owner_id\nJOIN Treatments T ON D.dog_id = T.dog_id\nGROUP BY O.owner_id, O.last_name\nORDER BY SUM(T.cost_of_treatment) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a unique list of breed codes and size codes for dogs from the 'Dogs' table. The placeholders represent the breed and size categories associated with the dogs.\",\n        \"virtual_table\": \"SELECT DISTINCT breed_code ,  size_code FROM dogs\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique first names of professionals along with the descriptions of the treatment types they have administered. The data is sourced from the 'Professionals', 'Treatments', and 'Treatment_Types' tables, ensuring that only distinct combinations of professional names and treatment descriptions are displayed.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code\"\n    }\n}\n"}
{"sample_id": "dev.942", "db_id": "dog_kennels", "question": "Which professionals have done at least two types of treatments? List the professional id and cell phone.", "rationale": ["Identify the relevant tables: Professionals and Treatments.", "We need to join these tables on the professional_id to link professionals with the treatments they have administered.", "We want to group the results by professional_id to count the number of distinct treatment types each professional has done.", "Use the HAVING clause to filter for professionals who have administered at least two different types of treatments.", "Select the professional_id and cell_number from the filtered results."], "gold_sql": "SELECT T1.professional_id ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  2", "source_tables": ["professionals", "treatments"], "pred_sql": "SELECT professional_id, cell_number \nFROM Professionals AS P \nJOIN Treatments AS T ON P.professional_id = T.professional_id \nGROUP BY P.professional_id \nHAVING COUNT(DISTINCT T.treatment_type_code) >= 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique first names of professionals along with the descriptions of the treatment types they have administered. The data is sourced from the 'Professionals', 'Treatments', and 'Treatment_Types' tables, ensuring that only distinct combinations of professional names and treatment descriptions are displayed.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code\"\n    }\n}\n"}
{"sample_id": "dev.943", "db_id": "dog_kennels", "question": "Find the id and cell phone of the professionals who operate two or more types of treatments.", "rationale": ["The query needs to find professionals who operate two or more types of treatments.", "We will start by joining the 'Professionals', 'Treatments', and 'Treatment_Types' tables to get the necessary information about professionals and the treatments they administer.", "We will count the distinct treatment types for each professional using COUNT(DISTINCT T3.treatment_type_code).", "We will group the results by professional_id to aggregate the treatment counts for each professional.", "Finally, we will filter the results to include only those professionals who have a treatment count of 2 or more.", "We will select the professional_id and cell_number from the filtered results."], "gold_sql": "SELECT T1.professional_id ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  2", "source_tables": ["professionals", "treatments"], "pred_sql": "SELECT professional_id, cell_number \nFROM (\n    SELECT T1.professional_id, COUNT(DISTINCT T3.treatment_type_code) AS treatment_count \n    FROM Professionals AS T1 \n    JOIN Treatments AS T2 ON T1.professional_id = T2.professional_id \n    JOIN Treatment_Types AS T3 ON T2.treatment_type_code = T3.treatment_type_code \n    GROUP BY T1.professional_id \n) AS treatment_counts \nWHERE treatment_count >= 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique first names of professionals along with the descriptions of the treatment types they have administered. The data is sourced from the 'Professionals', 'Treatments', and 'Treatment_Types' tables, ensuring that only distinct combinations of professional names and treatment descriptions are displayed.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code\"\n    }\n}\n"}
{"sample_id": "dev.950", "db_id": "dog_kennels", "question": "List each owner's first name, last name, and the size of his for her dog.", "rationale": ["We need to list each owner's first name and last name, which are found in the Owners table.", "We also need the size of the dog, which is found in the Sizes table.", "To get the size of the dog associated with each owner, we need to join the Owners table with the Dogs table on the owner_id.", "Next, we join the Dogs table with the Sizes table on the size_code to get the size description of each dog.", "Finally, we select the first name and last name from the Owners table and the size description from the Sizes table."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id", "source_tables": ["owners", "dogs"], "pred_sql": "SELECT Owners.first_name, Owners.last_name, Sizes.size_description \nFROM Owners \nJOIN Dogs ON Owners.owner_id = Dogs.owner_id \nJOIN Sizes ON Dogs.size_code = Sizes.size_code;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a unique list of breed codes and size codes for dogs from the 'Dogs' table. The placeholders represent the breed and size categories associated with the dogs.\",\n        \"virtual_table\": \"SELECT DISTINCT breed_code ,  size_code FROM dogs\"\n    }\n}\n"}
{"sample_id": "dev.954", "db_id": "dog_kennels", "question": "List the names of the dogs of the rarest breed and the treatment dates of them.", "rationale": ["Identify the tables needed: Dogs, Breeds, and Treatments.", "We need to list the names of dogs and their treatment dates, so we will select 'name' from Dogs and 'date_of_treatment' from Treatments.", "Join the Dogs table with the Breeds table to filter by breed.", "Join the Treatments table to get the treatment dates for each dog.", "To find the rarest breed, we will use a subquery that counts the number of dogs per breed and orders them in ascending order, limiting the result to 1 to get the rarest breed."], "gold_sql": "SELECT T1.name ,  T2.date_of_treatment FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id WHERE T1.breed_code  =  ( SELECT breed_code FROM Dogs GROUP BY breed_code ORDER BY count(*) ASC LIMIT 1 )", "source_tables": ["dogs", "treatments"], "pred_sql": "SELECT D.name, T.date_of_treatment\nFROM Dogs D\nJOIN Breeds B ON D.breed_code = B.breed_code\nJOIN Treatments T ON D.dog_id = T.dog_id\nWHERE B.breed_code = (\n    SELECT breed_code\n    FROM Dogs\n    GROUP BY breed_code\n    ORDER BY COUNT(*) ASC\n    LIMIT 1\n)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a unique list of breed codes and size codes for dogs from the 'Dogs' table. The placeholders represent the breed and size categories associated with the dogs.\",\n        \"virtual_table\": \"SELECT DISTINCT breed_code ,  size_code FROM dogs\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique first names of professionals along with the descriptions of the treatment types they have administered. The data is sourced from the 'Professionals', 'Treatments', and 'Treatment_Types' tables, ensuring that only distinct combinations of professional names and treatment descriptions are displayed.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code\"\n    }\n}\n"}
{"sample_id": "dev.958", "db_id": "dog_kennels", "question": "What are the arriving date and the departing date of the dogs who have gone through a treatment?", "rationale": ["Identify the relevant tables: Dogs and Treatments.", "We need to find the arriving and departing dates of dogs that have undergone treatment.", "The Dogs table contains the date_arrived and date_departed columns.", "The Treatments table links to the Dogs table through the dog_id column.", "To get the required information, we will perform an INNER JOIN between Dogs and Treatments on the dog_id column.", "Select the date_arrived and date_departed from the Dogs table after the join."], "gold_sql": "SELECT DISTINCT T1.date_arrived ,  T1.date_departed FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id", "source_tables": ["dogs", "treatments"], "pred_sql": "SELECT d.date_arrived, d.date_departed \nFROM Dogs d \nJOIN Treatments t ON d.dog_id = t.dog_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a unique list of breed codes and size codes for dogs from the 'Dogs' table. The placeholders represent the breed and size categories associated with the dogs.\",\n        \"virtual_table\": \"SELECT DISTINCT breed_code ,  size_code FROM dogs\"\n    }\n}\n"}
{"sample_id": "dev.960", "db_id": "dog_kennels", "question": "List the last name of the owner owning the youngest dog.", "rationale": ["Identify the relevant tables: Owners and Dogs.", "We need to find the youngest dog, which can be determined by the latest date of birth.", "Join the Owners table with the Dogs table on the owner_id to link owners with their dogs.", "Order the results by the date_of_birth in descending order to get the youngest dog first.", "Limit the results to 1 to get only the last name of the owner of the youngest dog."], "gold_sql": "SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )", "source_tables": ["owners", "dogs"], "pred_sql": "SELECT Owners.last_name \nFROM Owners \nJOIN Dogs ON Owners.owner_id = Dogs.owner_id \nORDER BY Dogs.date_of_birth DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "dev.997", "db_id": "dog_kennels", "question": "Find the distinct breed type and size type combinations for dogs.", "rationale": ["The task is to find distinct combinations of breed types and size types for dogs.", "We need to select the breed_code and size_code from the Dogs table.", "Using the DISTINCT keyword will ensure that we only get unique combinations of breed_code and size_code.", "The final SQL query is constructed as 'SELECT DISTINCT breed_code, size_code FROM Dogs;'"], "gold_sql": "SELECT DISTINCT breed_code ,  size_code FROM dogs", "source_tables": ["dogs"], "pred_sql": "SELECT DISTINCT breed_code, size_code FROM Dogs;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a unique list of breed codes and size codes for dogs from the 'Dogs' table. The placeholders represent the breed and size categories associated with the dogs.\",\n        \"virtual_table\": \"SELECT DISTINCT breed_code ,  size_code FROM dogs\"\n    }\n}\n"}
{"sample_id": "dev.999", "db_id": "dog_kennels", "question": "What are each professional's first name and description of the treatment they have performed?", "rationale": ["Identify the tables involved: Professionals, Treatments, and Treatment_Types.", "Determine the columns needed: first_name from Professionals and treatment_type_description from Treatment_Types.", "Establish relationships between the tables using JOINs: Professionals to Treatments on professional_id, and Treatments to Treatment_Types on treatment_type_code.", "Use DISTINCT to ensure unique combinations of first names and treatment descriptions are returned."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code", "source_tables": ["professionals", "treatments", "treatment_types"], "pred_sql": "SELECT DISTINCT T1.first_name, T3.treatment_type_description \nFROM Professionals AS T1 \nJOIN Treatments AS T2 ON T1.professional_id = T2.professional_id \nJOIN Treatment_Types AS T3 ON T2.treatment_type_code = T3.treatment_type_code;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique first names of professionals along with the descriptions of the treatment types they have administered. The data is sourced from the 'Professionals', 'Treatments', and 'Treatment_Types' tables, ensuring that only distinct combinations of professional names and treatment descriptions are displayed.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code\"\n    }\n}\n"}
