{"sample_id": "dev.924", "db_id": "dog_kennels", "question": "Which dogs have not cost their owner more than 1000 for treatment ? List the dog names .", "rationale": ["Identify the relevant tables: Dogs and Treatments.", "We need to find dogs that have not cost their owner more than 1000 for treatment, which requires summing the treatment costs for each dog.", "Join the Dogs table with the Treatments table on the dog_id to associate each dog with its treatments.", "Group the results by dog_id to aggregate the treatment costs for each dog.", "Use the HAVING clause to filter the groups where the total treatment cost is less than or equal to 1000."], "gold_sql": "select name from dogs where dog_id not in ( select dog_id from treatments group by dog_id having sum(cost_of_treatment)  >  1000 )", "source_tables": ["dogs", "treatments"], "pred_sql": "SELECT d.name \nFROM Dogs d \nJOIN Treatments t ON d.dog_id = t.dog_id \nGROUP BY d.dog_id \nHAVING SUM(t.cost_of_treatment) <= 1000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a unique list of breed codes and size codes for dogs from the 'Dogs' table. The placeholders represent the breed and size categories associated with the dogs.\"\n}\n"}
{"sample_id": "dev.937", "db_id": "dog_kennels", "question": "Tell me the owner id and last name of the owner who spent the most on treatments of his or her dogs.", "rationale": ["We need to find the owner who spent the most on treatments for their dogs.", "To do this, we will join the Owners table with the Dogs table using the owner_id, and then join the Treatments table using the dog_id.", "We will group the results by owner_id and last_name to aggregate the treatment costs for each owner.", "We will use the SUM function to calculate the total treatment costs for each owner.", "Finally, we will order the results in descending order based on the total treatment costs and limit the results to 1 to get the owner who spent the most."], "gold_sql": "SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["owners", "dogs", "treatments"], "pred_sql": "SELECT Owners.owner_id, Owners.last_name\nFROM Owners\nJOIN Dogs ON Owners.owner_id = Dogs.owner_id\nJOIN Treatments ON Dogs.dog_id = Treatments.dog_id\nGROUP BY Owners.owner_id, Owners.last_name\nORDER BY SUM(Treatments.cost_of_treatment) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a unique list of breed codes and size codes for dogs from the 'Dogs' table. The placeholders represent the breed and size categories associated with the dogs.\"\n}\n"}
{"sample_id": "dev.942", "db_id": "dog_kennels", "question": "Which professionals have done at least two types of treatments? List the professional id and cell phone.", "rationale": ["We need to find professionals who have administered at least two different types of treatments.", "To do this, we will join the 'Professionals' table with the 'Treatments' table on the professional_id.", "We will group the results by professional_id to count the number of distinct treatment types each professional has administered.", "Using the HAVING clause, we will filter the groups to include only those with a count of distinct treatment types greater than or equal to 2.", "Finally, we will select the professional_id and cell_number from the filtered results."], "gold_sql": "SELECT T1.professional_id ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  2", "source_tables": ["professionals", "treatments"], "pred_sql": "SELECT p.professional_id, p.cell_number\nFROM Professionals p\nJOIN Treatments t ON p.professional_id = t.professional_id\nGROUP BY p.professional_id\nHAVING COUNT(DISTINCT t.treatment_type_code) >= 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique first names of professionals along with the descriptions of the treatment types they have administered. The data is sourced from the 'Professionals', 'Treatments', and 'Treatment_Types' tables, ensuring that only distinct combinations of professional names and treatment descriptions are displayed.\"\n}\n"}
{"sample_id": "dev.943", "db_id": "dog_kennels", "question": "Find the id and cell phone of the professionals who operate two or more types of treatments.", "rationale": ["We need to find professionals who operate two or more types of treatments.", "This requires joining the 'Professionals' table with the 'Treatments' table on the professional_id.", "We will group the results by professional_id to count the distinct treatment types each professional has administered.", "Using the HAVING clause, we can filter the groups to include only those with a count of two or more distinct treatment types.", "Finally, we select the professional_id and cell_number from the filtered results."], "gold_sql": "SELECT T1.professional_id ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  2", "source_tables": ["professionals", "treatments"], "pred_sql": "SELECT p.professional_id, p.cell_number\nFROM Professionals p\nJOIN Treatments t ON p.professional_id = t.professional_id\nGROUP BY p.professional_id\nHAVING COUNT(DISTINCT t.treatment_type_code) >= 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique first names of professionals along with the descriptions of the treatment types they have administered. The data is sourced from the 'Professionals', 'Treatments', and 'Treatment_Types' tables, ensuring that only distinct combinations of professional names and treatment descriptions are displayed.\"\n}\n"}
{"sample_id": "dev.950", "db_id": "dog_kennels", "question": "List each owner's first name, last name, and the size of his for her dog.", "rationale": ["Identify the required information: owner's first name, last name, and dog's size.", "Determine the relevant tables: Owners, Dogs, and Sizes.", "Establish relationships between the tables: Owners are linked to Dogs via owner_id, and Dogs are linked to Sizes via size_code.", "Use JOIN clauses to combine the tables based on these relationships.", "Select the appropriate columns from the combined tables."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id", "source_tables": ["owners", "dogs"], "pred_sql": "SELECT Owners.first_name, Owners.last_name, Sizes.size_description \nFROM Owners \nJOIN Dogs ON Owners.owner_id = Dogs.owner_id \nJOIN Sizes ON Dogs.size_code = Sizes.size_code;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a unique list of breed codes and size codes for dogs from the 'Dogs' table. The placeholders represent the breed and size categories associated with the dogs.\"\n}\n"}
{"sample_id": "dev.954", "db_id": "dog_kennels", "question": "List the names of the dogs of the rarest breed and the treatment dates of them.", "rationale": ["Identify the tables needed: Dogs, Breeds, and Treatments.", "We need to list dog names and treatment dates, so we will select 'name' from Dogs and 'date_of_treatment' from Treatments.", "To find the rarest breed, we will group the Breeds table by 'breed_code' and count the occurrences of each breed.", "We will order the counts in ascending order and limit the result to 1 to get the rarest breed.", "Join the Dogs table with the Breeds table to filter dogs by the rarest breed.", "Join the Treatments table to get the treatment dates for those dogs."], "gold_sql": "SELECT T1.name ,  T2.date_of_treatment FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id WHERE T1.breed_code  =  ( SELECT breed_code FROM Dogs GROUP BY breed_code ORDER BY count(*) ASC LIMIT 1 )", "source_tables": ["dogs", "treatments"], "pred_sql": "SELECT d.name AS dog_name, t.date_of_treatment \nFROM Dogs d \nJOIN Breeds b ON d.breed_code = b.breed_code \nJOIN Treatments t ON d.dog_id = t.dog_id \nWHERE b.breed_code = (SELECT breed_code \n                      FROM Breeds \n                      GROUP BY breed_code \n                      ORDER BY COUNT(*) ASC \n                      LIMIT 1);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a unique list of breed codes and size codes for dogs from the 'Dogs' table. The placeholders represent the breed and size categories associated with the dogs.\"\n}\n"}
{"sample_id": "dev.958", "db_id": "dog_kennels", "question": "What are the arriving date and the departing date of the dogs who have gone through a treatment?", "rationale": ["Identify the relevant tables: Dogs and Treatments.", "We need the arriving and departing dates of dogs, which are in the Dogs table.", "We also need to filter for dogs that have undergone treatment, which is indicated in the Treatments table.", "To link the two tables, we can use the dog_id, which is a common field in both tables.", "Construct the SQL query to select the date_arrived and date_departed from the Dogs table, joining it with the Treatments table on dog_id."], "gold_sql": "SELECT DISTINCT T1.date_arrived ,  T1.date_departed FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id", "source_tables": ["dogs", "treatments"], "pred_sql": "SELECT d.date_arrived, d.date_departed \nFROM Dogs d \nJOIN Treatments t ON d.dog_id = t.dog_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a unique list of breed codes and size codes for dogs from the 'Dogs' table. The placeholders represent the breed and size categories associated with the dogs.\"\n}\n"}
{"sample_id": "dev.960", "db_id": "dog_kennels", "question": "List the last name of the owner owning the youngest dog.", "rationale": ["Identify the relevant tables: Owners and Dogs.", "We need to find the youngest dog, which can be determined by the latest date of birth.", "Join the Owners table with the Dogs table on the owner_id to link owners to their dogs.", "Order the results by the date_of_birth in descending order to get the youngest dog first.", "Limit the results to 1 to get only the last name of the owner of the youngest dog."], "gold_sql": "SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )", "source_tables": ["owners", "dogs"], "pred_sql": "SELECT Owners.last_name \nFROM Owners \nJOIN Dogs ON Owners.owner_id = Dogs.owner_id \nORDER BY Dogs.date_of_birth DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "dev.997", "db_id": "dog_kennels", "question": "Find the distinct breed type and size type combinations for dogs.", "rationale": ["We need to find distinct combinations of breed types and size types for dogs.", "The relevant tables for this query are 'Dogs', 'Breeds', and 'Sizes'.", "We will join the 'Dogs' table with the 'Breeds' table on the 'breed_code' to get the breed names.", "We will also join the 'Dogs' table with the 'Sizes' table on the 'size_code' to get the size descriptions.", "Using SELECT DISTINCT will ensure that we only get unique combinations of breed names and size descriptions."], "gold_sql": "SELECT DISTINCT breed_code ,  size_code FROM dogs", "source_tables": ["dogs"], "pred_sql": "SELECT DISTINCT Breeds.breed_name, Sizes.size_description \nFROM Dogs \nJOIN Breeds ON Dogs.breed_code = Breeds.breed_code \nJOIN Sizes ON Dogs.size_code = Sizes.size_code;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a unique list of breed codes and size codes for dogs from the 'Dogs' table. The placeholders represent the breed and size categories associated with the dogs.\"\n}\n"}
{"sample_id": "dev.999", "db_id": "dog_kennels", "question": "What are each professional's first name and description of the treatment they have performed?", "rationale": ["Identify the tables needed: Professionals, Treatments, and Treatment_Types.", "Determine the columns to select: first_name from Professionals and treatment_type_description from Treatment_Types.", "Establish the relationships between the tables using JOINs: Treatments links Professionals and Treatment_Types.", "Use DISTINCT to ensure unique combinations of first names and treatment descriptions are returned."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code", "source_tables": ["professionals", "treatments", "treatment_types"], "pred_sql": "SELECT DISTINCT Professionals.first_name, Treatment_Types.treatment_type_description\nFROM Professionals\nJOIN Treatments ON Professionals.professional_id = Treatments.professional_id\nJOIN Treatment_Types ON Treatments.treatment_type_code = Treatment_Types.treatment_type_code;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique first names of professionals along with the descriptions of the treatment types they have administered. The data is sourced from the 'Professionals', 'Treatments', and 'Treatment_Types' tables, ensuring that only distinct combinations of professional names and treatment descriptions are displayed.\"\n}\n"}
