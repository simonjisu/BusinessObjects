{"sample_id": "train.2612", "db_id": "inn_1", "question": "Find the name of the room with the maximum occupancy.", "rationale": ["Identify the relevant tables: Rooms and Reservations.", "We need to find the room name with the maximum occupancy, which involves checking the maximum occupancy allowed in the Rooms table and the total number of occupants from the Reservations table.", "Join the Rooms table with the Reservations table on the RoomId to access both room details and reservation details.", "Group the results by RoomId to aggregate the number of occupants for each room.", "Use the HAVING clause to filter the results where the total number of occupants (sum of adults and kids) equals the maximum occupancy for that room."], "gold_sql": "SELECT roomName FROM Rooms ORDER BY maxOccupancy DESC LIMIT 1;", "source_tables": ["rooms"], "pred_sql": "SELECT r.roomName \nFROM Rooms r \nJOIN Reservations res ON r.RoomId = res.Room \nGROUP BY r.RoomId \nHAVING SUM(CAST(res.Adults AS INTEGER) + CAST(res.Kids AS INTEGER)) = MAX(CAST(r.maxOccupancy AS INTEGER))", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of reservations where the total number of occupants (adults and kids) matches the maximum occupancy allowed for each room. It joins the 'Reservations' table with the 'Rooms' table based on the room identifier, ensuring that only those reservations that meet the occupancy criteria are counted.\"\n}\n"}
{"sample_id": "train.2621", "db_id": "inn_1", "question": "What is the average minimum and price of the rooms for each different decor.", "rationale": ["Identify the required information: average and minimum price of rooms based on decor.", "Determine the relevant table: Rooms table contains the necessary columns (decor and basePrice).", "Use the AVG() function to calculate the average price and MIN() function to find the minimum price.", "Group the results by the decor column to get the average and minimum prices for each type of decor."], "gold_sql": "SELECT decor , avg(basePrice) ,  min(basePrice) FROM Rooms GROUP BY decor;", "source_tables": ["rooms"], "pred_sql": "SELECT decor, AVG(basePrice) AS average_price, MIN(basePrice) AS minimum_price \nFROM Rooms \nGROUP BY decor;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of room identifiers and their names from the 'Rooms' table, sorted by the base price in descending order. The placeholder in the LIMIT clause represents the maximum number of rooms to be displayed.\"\n}\n"}
{"sample_id": "train.2628", "db_id": "inn_1", "question": "List the name of rooms with king or queen bed.", "rationale": ["Identify the table to query: Rooms.", "Determine the columns needed: roomName.", "Filter the results based on the bedType: king or queen.", "Use the SQL IN clause to specify multiple values for bedType."], "gold_sql": "SELECT roomName FROM Rooms WHERE bedType  =  'King' OR bedType  =  'Queen';", "source_tables": ["rooms"], "pred_sql": "SELECT roomName FROM Rooms WHERE bedType IN ('king', 'queen');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of rooms from the 'Rooms' table that have a specific type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\"\n}\n"}
{"sample_id": "train.2639", "db_id": "inn_1", "question": "For each room, find its name and the number of times reservations were made for it.", "rationale": ["We need to find the name of each room and the number of reservations made for it.", "To achieve this, we will select the 'roomName' from the 'Rooms' table.", "We will also count the number of reservations associated with each room, which can be done using COUNT() on the 'Code' column from the 'Reservations' table.", "To link the two tables, we will use a LEFT JOIN on the 'RoomId' from the 'Rooms' table and the 'Room' from the 'Reservations' table.", "We will group the results by 'RoomId' and 'roomName' to ensure we get a count of reservations for each room."], "gold_sql": "SELECT T2.roomName ,  count(*) ,  T1.Room FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT Rooms.roomName, COUNT(Reservations.Code) AS reservation_count\nFROM Rooms\nLEFT JOIN Reservations ON Rooms.RoomId = Reservations.Room\nGROUP BY Rooms.RoomId, Rooms.roomName;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of reservations where the total number of occupants (adults and kids) matches the maximum occupancy allowed for each room. It joins the 'Reservations' table with the 'Rooms' table based on the room identifier, ensuring that only those reservations that meet the occupancy criteria are counted.\"\n}\n"}
{"sample_id": "train.2846", "db_id": "customer_deliveries", "question": "Show the details of all trucks in the order of their license number.", "rationale": ["Identify the table needed: The question asks for details of trucks, so we will use the 'Trucks' table.", "Select all columns: We need all details, so we will use SELECT *.", "Order by license number: The question specifies to order the results by the truck's license number, so we will add ORDER BY truck_licence_number."], "gold_sql": "SELECT truck_details FROM trucks ORDER BY truck_licence_number", "source_tables": ["trucks"], "pred_sql": "SELECT * FROM Trucks ORDER BY truck_licence_number;", "hint": "\n"}
{"sample_id": "train.2848", "db_id": "customer_deliveries", "question": "Find the names of customers who are not living in the state of California.", "rationale": ["Identify the relevant tables: Customers, Customer_Addresses, and Addresses.", "We need to find customer names, so we will select 'customer_name' from the Customers table.", "To filter customers based on their address, we need to join the Customers table with the Customer_Addresses table using 'customer_id'.", "Next, we join the Customer_Addresses table with the Addresses table using 'address_id' to access the state information.", "Finally, we apply a WHERE clause to filter out customers whose state is 'California'."], "gold_sql": "SELECT customer_name FROM customers EXCEPT SELECT t1.customer_name FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id WHERE t3.state_province_county  =  'California'", "source_tables": ["addresses", "customers", "customer_addresses"], "pred_sql": "SELECT customer_name \nFROM Customers C \nJOIN Customer_Addresses CA ON C.customer_id = CA.customer_id \nJOIN Addresses A ON CA.address_id = A.address_id \nWHERE A.state_province_county != 'California';", "hint": "\n"}
{"sample_id": "train.2856", "db_id": "customer_deliveries", "question": "Find the name of route that has the highest number of deliveries.", "rationale": ["Identify the relevant tables: Delivery_Routes, Delivery_Route_Locations, and Order_Deliveries are needed to find the route with the highest number of deliveries.", "Join Delivery_Routes with Delivery_Route_Locations on route_id to link routes with their locations.", "Join the result with Order_Deliveries on location_code to associate deliveries with their respective routes.", "Group the results by route_name to count the number of deliveries for each route.", "Order the results in descending order based on the count of deliveries to find the route with the highest number.", "Limit the results to 1 to get only the top route."], "gold_sql": "SELECT t1.route_name FROM Delivery_Routes AS t1 JOIN Delivery_Route_Locations AS t2 ON t1.route_id  =  t2.route_id GROUP BY t1.route_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["delivery_route_locations", "delivery_routes"], "pred_sql": "SELECT route_name\nFROM Delivery_Routes\nJOIN Delivery_Route_Locations ON Delivery_Routes.route_id = Delivery_Route_Locations.route_id\nJOIN Order_Deliveries ON Delivery_Route_Locations.location_code = Order_Deliveries.location_code\nGROUP BY route_name\nORDER BY COUNT(Order_Deliveries.actual_order_id) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3175", "db_id": "college_1", "question": "How many professors are teaching class with code ACCT-211?", "rationale": ["Identify the relevant tables: CLASS and EMPLOYEE.", "We need to count the number of distinct professors teaching a specific class, which is identified by the class code 'ACCT-211'.", "Join the CLASS table with the EMPLOYEE table on the professor's identifier (PROF_NUM) to get the professors teaching the class.", "Use a WHERE clause to filter the results to only include the class with the code 'ACCT-211'.", "Use COUNT(DISTINCT EMPLOYEE.EMP_NUM) to count the unique professors teaching that class."], "gold_sql": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["class"], "pred_sql": "SELECT COUNT(DISTINCT EMPLOYEE.EMP_NUM) AS professor_count\nFROM CLASS\nJOIN EMPLOYEE ON CLASS.PROF_NUM = EMPLOYEE.EMP_NUM\nWHERE CLASS.CRS_CODE = 'ACCT-211';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of professors and the course codes they teach from the 'CLASS' and 'EMPLOYEE' tables. The join condition links the professor's identifier in the 'CLASS' table to the corresponding identifier in the 'EMPLOYEE' table.\"\n}\n"}
{"sample_id": "train.3176", "db_id": "college_1", "question": "How many professors teach a class with the code ACCT-211?", "rationale": ["Identify the relevant tables: CLASS and EMPLOYEE.", "We need to count the number of distinct professors teaching a specific class, so we will use COUNT(DISTINCT EMPLOYEE.EMP_NUM).", "Join the CLASS table with the EMPLOYEE table on the condition that CLASS.PROF_NUM matches EMPLOYEE.EMP_NUM to get the professors for each class.", "Filter the results to only include the class with the code 'ACCT-211' using a WHERE clause.", "Construct the SQL query to select the count of distinct professors for the specified class."], "gold_sql": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["class"], "pred_sql": "SELECT COUNT(DISTINCT EMPLOYEE.EMP_NUM) AS professor_count\nFROM CLASS\nJOIN EMPLOYEE ON CLASS.PROF_NUM = EMPLOYEE.EMP_NUM\nWHERE CLASS.CLASS_CODE = 'ACCT-211';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of professors and the course codes they teach from the 'CLASS' and 'EMPLOYEE' tables. The join condition links the professor's identifier in the 'CLASS' table to the corresponding identifier in the 'EMPLOYEE' table.\"\n}\n"}
{"sample_id": "train.3179", "db_id": "college_1", "question": "What are the first names and date of birth of professors teaching course ACCT-211?", "rationale": ["Identify the relevant tables: CLASS and EMPLOYEE.", "We need to retrieve the first names and date of birth of professors, which are in the EMPLOYEE table.", "The CLASS table contains the course codes, and we need to filter for the course ACCT-211.", "Join the CLASS table with the EMPLOYEE table on the professor's identifier (PROF_NUM) to get the professor's details.", "Select the first names (EMP_FNAME) and date of birth (EMP_DOB) from the EMPLOYEE table where the course code matches ACCT-211."], "gold_sql": "SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["employee", "class"], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME, EMPLOYEE.EMP_DOB \nFROM CLASS \nJOIN EMPLOYEE ON CLASS.PROF_NUM = EMPLOYEE.EMP_NUM \nWHERE CLASS.CRS_CODE = 'ACCT-211';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of professors and the course codes they teach from the 'CLASS' and 'EMPLOYEE' tables. The join condition links the professor's identifier in the 'CLASS' table to the corresponding identifier in the 'EMPLOYEE' table.\"\n}\n"}
{"sample_id": "train.3188", "db_id": "college_1", "question": "Where is the history department?", "rationale": ["Identify the relevant table: The DEPARTMENT table contains information about departments, including their names and addresses.", "Formulate the query: We need to select the department name and address where the department name includes 'History'.", "Use the LIKE operator to search for 'History' in the DEPT_NAME column.", "Construct the SQL query to retrieve the DEPT_NAME and DEPT_ADDRESS from the DEPARTMENT table."], "gold_sql": "SELECT dept_address FROM department WHERE dept_name  =  'History'", "source_tables": ["department"], "pred_sql": "SELECT DEPT_NAME, DEPT_ADDRESS FROM DEPARTMENT WHERE DEPT_NAME LIKE '%History%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of department names associated with students, ordered by their GPA. The placeholder in the LIMIT clause allows for specifying the maximum number of department names to retrieve.\"\n}\n"}
{"sample_id": "train.3190", "db_id": "college_1", "question": "What are the different locations of the school with the code BUS?", "rationale": ["Identify the table that contains the school locations, which is the DEPARTMENT table.", "Determine the relevant column for the location, which is DEPT_ADDRESS.", "Filter the results based on the SCHOOL_CODE, specifically looking for the code 'BUS'.", "Use DISTINCT to ensure that only unique locations are returned."], "gold_sql": "SELECT count(DISTINCT dept_address) FROM department WHERE school_code  =  'BUS'", "source_tables": ["department"], "pred_sql": "SELECT DISTINCT DEPT_ADDRESS FROM DEPARTMENT WHERE SCHOOL_CODE = 'BUS';", "hint": "\n"}
{"sample_id": "train.3201", "db_id": "college_1", "question": "What is the total credit does each department offer?", "rationale": ["We need to find the total credit hours offered by each department.", "The relevant tables are DEPARTMENT and COURSE, as COURSE contains the credit hours and DEPARTMENT contains the department names.", "We will join the DEPARTMENT table with the COURSE table on the DEPT_CODE column, which is common to both tables.", "We will use the SUM function to calculate the total credit hours from the CRS_CREDIT column in the COURSE table.", "We will group the results by DEPARTMENT.DEPT_NAME to get the total credit hours for each department."], "gold_sql": "SELECT sum(crs_credit) ,  dept_code FROM course GROUP BY dept_code", "source_tables": ["course"], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME, SUM(CAST(COURSE.CRS_CREDIT AS INTEGER)) AS TOTAL_CREDIT\nFROM DEPARTMENT\nJOIN COURSE ON DEPARTMENT.DEPT_CODE = COURSE.DEPT_CODE\nGROUP BY DEPARTMENT.DEPT_NAME;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of department names associated with students, ordered by their GPA. The placeholder in the LIMIT clause allows for specifying the maximum number of department names to retrieve.\"\n}\n"}
{"sample_id": "train.3202", "db_id": "college_1", "question": "How many credits does the department offer?", "rationale": ["Identify the relevant tables: DEPARTMENT and COURSE.", "We need to count the number of courses offered by each department, so we will use COUNT() function on the CRS_CODE from the COURSE table.", "Join the DEPARTMENT table with the COURSE table on the DEPT_CODE to link courses to their respective departments.", "Group the results by department name to get the count of courses for each department."], "gold_sql": "SELECT sum(crs_credit) ,  dept_code FROM course GROUP BY dept_code", "source_tables": ["course"], "pred_sql": "SELECT COUNT(C.CRS_CODE) AS Course_Count, D.DEPT_NAME\nFROM DEPARTMENT D\nJOIN COURSE C ON D.DEPT_CODE = C.DEPT_CODE\nGROUP BY D.DEPT_NAME;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of courses offered by a specific department from the 'DEPARTMENT' and 'COURSE' tables. The placeholder in the WHERE clause represents the name of the department for which the course count is being queried.\"\n}\n"}
{"sample_id": "train.3213", "db_id": "college_1", "question": "Which school has the smallest amount of professors?", "rationale": ["Identify the relevant table: The PROFESSOR table contains information about professors and their associated departments.", "Determine the required information: We need to find the school with the smallest number of professors.", "Group the data: Use GROUP BY to group the results by SCHOOL_CODE to count the number of professors in each school.", "Count the professors: Use COUNT(PROF_NUM) to count the number of professors for each school.", "Order the results: Use ORDER BY to sort the results in ascending order based on the count of professors.", "Limit the results: Use LIMIT 1 to get only the school with the smallest number of professors."], "gold_sql": "SELECT T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code ORDER BY count(*) LIMIT 1", "source_tables": ["department", "professor"], "pred_sql": "SELECT SCHOOL_CODE, COUNT(PROF_NUM) AS professor_count\nFROM PROFESSOR\nGROUP BY SCHOOL_CODE\nORDER BY professor_count ASC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3215", "db_id": "college_1", "question": "Find the number of professors with a Ph.D. degree in each department.", "rationale": ["We need to find the number of professors with a Ph.D. degree in each department.", "The relevant tables are PROFESSOR and DEPARTMENT.", "We will join the PROFESSOR table with the DEPARTMENT table on the DEPT_CODE column to associate professors with their respective departments.", "We will filter the results to include only those professors whose highest degree is 'Ph.D.' using a WHERE clause.", "To count the number of professors per department, we will use the COUNT function and group the results by department name using GROUP BY."], "gold_sql": "SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  'Ph.D.' GROUP BY dept_code", "source_tables": ["professor"], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME, COUNT(PROFESSOR.EMP_NUM) AS NumberOfProfessors\nFROM PROFESSOR\nJOIN DEPARTMENT ON PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE\nWHERE PROFESSOR.PROF_HIGH_DEGREE = 'Ph.D.'\nGROUP BY DEPARTMENT.DEPT_NAME;", "hint": "\n"}
{"sample_id": "train.3217", "db_id": "college_1", "question": "Find the number of students for each department.", "rationale": ["We need to find the number of students for each department, which involves counting students grouped by their department.", "The relevant tables for this query are DEPARTMENT and STUDENT, as we need to relate students to their respective departments.", "We will use a LEFT JOIN to connect the DEPARTMENT table with the STUDENT table on the DEPT_CODE column, ensuring we include all departments even if they have no students.", "We will select the department name from the DEPARTMENT table and count the number of students (STU_NUM) from the STUDENT table.", "Finally, we will group the results by the department name to get the count of students for each department."], "gold_sql": "SELECT count(*) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME, COUNT(STUDENT.STU_NUM) AS STUDENT_COUNT\nFROM DEPARTMENT\nLEFT JOIN STUDENT ON DEPARTMENT.DEPT_CODE = STUDENT.DEPT_CODE\nGROUP BY DEPARTMENT.DEPT_NAME;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of courses offered by a specific department from the 'DEPARTMENT' and 'COURSE' tables. The placeholder in the WHERE clause represents the name of the department for which the course count is being queried.\"\n}\n"}
{"sample_id": "train.3219", "db_id": "college_1", "question": "Find the total number of hours have done for all students in each department.", "rationale": ["We need to find the total number of hours completed by students in each department.", "The relevant tables are STUDENT and DEPARTMENT, as we need to aggregate student hours by department.", "We will join the STUDENT table with the DEPARTMENT table on the DEPT_CODE column to associate students with their respective departments.", "We will use the SUM function to calculate the total hours (STU_HRS) for each department.", "Finally, we will group the results by DEPARTMENT.DEPT_NAME to get the total hours for each department."], "gold_sql": "SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME, SUM(STUDENT.STU_HRS) AS TOTAL_HOURS\nFROM STUDENT\nJOIN DEPARTMENT ON STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE\nGROUP BY DEPARTMENT.DEPT_NAME;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of department names associated with students, ordered by their GPA. The placeholder in the LIMIT clause allows for specifying the maximum number of department names to retrieve.\"\n}\n"}
{"sample_id": "train.3240", "db_id": "college_1", "question": "Which department offers the most credits all together?", "rationale": ["Identify the relevant tables: DEPARTMENT and COURSE.", "We need to sum the credits from the COURSE table, which is linked to the DEPARTMENT table via DEPT_CODE.", "Use a JOIN to combine DEPARTMENT and COURSE based on DEPT_CODE.", "Group the results by DEPARTMENT name to aggregate the total credits for each department.", "Use SUM to calculate the total credits for each department.", "Order the results in descending order based on the total credits to find the department with the most credits.", "Limit the results to 1 to get only the department with the highest total credits."], "gold_sql": "SELECT T3.dept_name FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code JOIN department AS T3 ON T1.dept_code  =  T3.dept_code GROUP BY T1.dept_code ORDER BY sum(T1.crs_credit) DESC LIMIT 1", "source_tables": ["course", "department", "class"], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME, SUM(CAST(COURSE.CRS_CREDIT AS INTEGER)) AS TOTAL_CREDITS\nFROM DEPARTMENT\nJOIN COURSE ON DEPARTMENT.DEPT_CODE = COURSE.DEPT_CODE\nGROUP BY DEPARTMENT.DEPT_NAME\nORDER BY TOTAL_CREDITS DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of courses offered by a specific department from the 'DEPARTMENT' and 'COURSE' tables. The placeholder in the WHERE clause represents the name of the department for which the course count is being queried.\"\n}\n"}
{"sample_id": "train.3243", "db_id": "college_1", "question": "What is the first name of each student enrolled in class ACCT-211?", "rationale": ["Identify the information needed: the first names of students enrolled in a specific class (ACCT-211).", "Determine the relevant tables: STUDENT for student names, ENROLL for enrollment records, and CLASS for class details.", "Establish relationships between the tables: STUDENT is linked to ENROLL via STU_NUM, and ENROLL is linked to CLASS via CLASS_CODE.", "Construct the SQL query to select the first names from the STUDENT table, joining the necessary tables and filtering by the class code 'ACCT-211'."], "gold_sql": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  'ACCT-211'", "source_tables": ["student", "class", "enroll"], "pred_sql": "SELECT STUDENT.STU_FNAME \nFROM STUDENT \nJOIN ENROLL ON STUDENT.STU_NUM = ENROLL.STU_NUM \nJOIN CLASS ON ENROLL.CLASS_CODE = CLASS.CLASS_CODE \nWHERE CLASS.CLASS_CODE = 'ACCT-211';", "hint": "\n"}
{"sample_id": "train.3245", "db_id": "college_1", "question": "What is the first name of students enrolled in class ACCT-211 and got grade C?", "rationale": ["Identify the tables needed: STUDENT, ENROLL, and CLASS are required to get the first names of students enrolled in a specific class with a specific grade.", "Join the ENROLL table with the STUDENT table on the student number (STU_NUM) to get student details.", "Join the CLASS table with the ENROLL table on the class code (CLASS_CODE) to filter by the specific class (ACCT-211).", "Add a WHERE clause to filter for the class code 'ACCT-211' and the grade 'C'.", "Select the first name (STU_FNAME) of the students who meet these criteria."], "gold_sql": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  'ACCT-211' AND T2.enroll_grade  =  'C'", "source_tables": ["student", "class", "enroll"], "pred_sql": "SELECT STUDENT.STU_FNAME \nFROM STUDENT \nJOIN ENROLL ON STUDENT.STU_NUM = ENROLL.STU_NUM \nJOIN CLASS ON ENROLL.CLASS_CODE = CLASS.CLASS_CODE \nWHERE CLASS.CLASS_CODE = 'ACCT-211' AND ENROLL.ENROLL_GRADE = 'C';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of department names associated with students, ordered by their GPA. The placeholder in the LIMIT clause allows for specifying the maximum number of department names to retrieve.\"\n}\n"}
{"sample_id": "train.3254", "db_id": "college_1", "question": "What is the name of the department with the most students enrolled?", "rationale": ["Identify the relevant tables: DEPARTMENT and STUDENT are needed to find the department names and the number of students enrolled in each department.", "Join the DEPARTMENT table with the STUDENT table on the DEPT_CODE to associate students with their respective departments.", "Group the results by DEPARTMENT.DEPT_NAME to count the number of students in each department.", "Use COUNT(STUDENT.STU_NUM) to count the number of students in each department.", "Order the results in descending order based on the count of students to find the department with the most students.", "Limit the results to 1 to get only the department with the highest enrollment."], "gold_sql": "SELECT T4.dept_name FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code GROUP BY T3.dept_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["course", "department", "class", "enroll"], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME\nFROM DEPARTMENT\nJOIN STUDENT ON DEPARTMENT.DEPT_CODE = STUDENT.DEPT_CODE\nGROUP BY DEPARTMENT.DEPT_NAME\nORDER BY COUNT(STUDENT.STU_NUM) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of department names associated with students, ordered by their GPA. The placeholder in the LIMIT clause allows for specifying the maximum number of department names to retrieve.\"\n}\n"}
{"sample_id": "train.3257", "db_id": "college_1", "question": "List the codes of all courses that take place in room KLR209.", "rationale": ["Identify the relevant table: The CLASS table contains information about classes, including the room where they are held.", "Determine the required columns: We need the course codes (CRS_CODE) for classes held in room KLR209.", "Construct the SQL query: Use a SELECT statement to retrieve distinct CRS_CODE from the CLASS table where CLASS_ROOM is 'KLR209'."], "gold_sql": "SELECT class_code FROM CLASS WHERE class_room  =  'KLR209'", "source_tables": ["class"], "pred_sql": "SELECT DISTINCT CLASS.CRS_CODE\nFROM CLASS\nWHERE CLASS.CLASS_ROOM = 'KLR209';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of students enrolled in classes associated with a specific course code from the 'CLASS' and 'ENROLL' tables. The placeholder in the WHERE clause represents the course code for which the enrollment count is being queried.\"\n}\n"}
{"sample_id": "train.3258", "db_id": "college_1", "question": "What are the codes of all the courses that are located in room KLR209?", "rationale": ["Identify the relevant table: The CLASS table contains information about class locations, including the CLASS_ROOM column.", "Determine the required information: We need the course codes (CRS_CODE) for classes held in room KLR209.", "Construct the SQL query: Use a SELECT statement to retrieve distinct CRS_CODE values from the CLASS table where CLASS_ROOM matches 'KLR209'."], "gold_sql": "SELECT class_code FROM CLASS WHERE class_room  =  'KLR209'", "source_tables": ["class"], "pred_sql": "SELECT DISTINCT CRS_CODE FROM CLASS WHERE CLASS_ROOM = 'KLR209';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of students enrolled in classes associated with a specific course code from the 'CLASS' and 'ENROLL' tables. The placeholder in the WHERE clause represents the course code for which the enrollment count is being queried.\"\n}\n"}
{"sample_id": "train.3267", "db_id": "college_1", "question": "What is the first name of students who got grade C in any class?", "rationale": ["Identify the relevant tables: STUDENT and ENROLL are needed since we want student names and their grades.", "Determine the relationship: STUDENT is related to ENROLL through the STU_NUM column.", "Select the required fields: We need the first name of the students, which is in the STUDENT table (STU_FNAME).", "Filter the results: We want only those students who received a grade of 'C', which is specified in the ENROLL table (ENROLL_GRADE).", "Construct the SQL query using a JOIN to combine STUDENT and ENROLL based on the STU_NUM, and apply the WHERE clause to filter by grade 'C'."], "gold_sql": "SELECT DISTINCT stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE enroll_grade  =  'C'", "source_tables": ["enroll", "student"], "pred_sql": "SELECT STUDENT.STU_FNAME \nFROM STUDENT \nJOIN ENROLL ON STUDENT.STU_NUM = ENROLL.STU_NUM \nWHERE ENROLL.ENROLL_GRADE = 'C';", "hint": "\n"}
{"sample_id": "train.3273", "db_id": "college_1", "question": "What are the first names of the professors who do not teach a class.", "rationale": ["We need to find the first names of professors who do not teach any class.", "To do this, we will use a LEFT JOIN between the EMPLOYEE table (which contains professor information) and the CLASS table (which contains class information).", "The join condition will be on the professor's identifier (EMP_NUM) in the EMPLOYEE table and the corresponding identifier (PROF_NUM) in the CLASS table.", "After performing the LEFT JOIN, we will filter the results to include only those professors who do not have any associated classes. This can be done by checking for NULL values in the CLASS_CODE column of the CLASS table.", "Finally, we will select the EMP_FNAME column from the EMPLOYEE table to get the first names of the professors who do not teach a class."], "gold_sql": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  'PROF' EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num", "source_tables": ["employee", "class"], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME \nFROM EMPLOYEE \nLEFT JOIN CLASS ON EMPLOYEE.EMP_NUM = CLASS.PROF_NUM \nWHERE CLASS.CLASS_CODE IS NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of professors and the course codes they teach from the 'CLASS' and 'EMPLOYEE' tables. The join condition links the professor's identifier in the 'CLASS' table to the corresponding identifier in the 'EMPLOYEE' table.\"\n}\n"}
{"sample_id": "train.3274", "db_id": "college_1", "question": "What are the first names of all professors not teaching any classes?", "rationale": ["We need to find the first names of professors who are not teaching any classes.", "To do this, we will use a LEFT JOIN between the EMPLOYEE table (which contains professor information) and the CLASS table (which contains class information).", "The join condition will be on the professor's identifier (EMP_NUM) in the EMPLOYEE table and the corresponding identifier (PROF_NUM) in the CLASS table.", "By using a LEFT JOIN, we can include all professors from the EMPLOYEE table and any matching classes from the CLASS table. Professors without classes will have NULL values in the CLASS table columns.", "To filter for professors not teaching any classes, we will check for NULL values in the CLASS_CODE column of the CLASS table in the WHERE clause."], "gold_sql": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  'PROF' EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num", "source_tables": ["employee", "class"], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME \nFROM EMPLOYEE \nLEFT JOIN CLASS ON EMPLOYEE.EMP_NUM = CLASS.PROF_NUM \nWHERE CLASS.CLASS_CODE IS NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of professors and the course codes they teach from the 'CLASS' and 'EMPLOYEE' tables. The join condition links the professor's identifier in the 'CLASS' table to the corresponding identifier in the 'EMPLOYEE' table.\"\n}\n"}
{"sample_id": "train.3288", "db_id": "college_1", "question": "How many professors attained either Ph.D. or Masters degrees?", "rationale": ["Identify the table that contains information about professors, which is the PROFESSOR table.", "Determine the relevant column that indicates the highest degree obtained by the professors, which is PROF_HIGH_DEGREE.", "We need to count the number of professors who have either a Ph.D. or a Masters degree.", "Use the COUNT() function to count the number of rows that meet the criteria.", "Construct the SQL query to select the count from the PROFESSOR table where the PROF_HIGH_DEGREE is either 'Ph.D.' or 'Masters'."], "gold_sql": "SELECT count(*) FROM professor WHERE prof_high_degree  =  'Ph.D.' OR prof_high_degree  =  'MA'", "source_tables": ["professor"], "pred_sql": "SELECT COUNT(*) AS NumberOfProfessors\nFROM PROFESSOR\nWHERE PROF_HIGH_DEGREE IN ('Ph.D.', 'Masters');", "hint": "\n"}
{"sample_id": "train.3292", "db_id": "college_1", "question": "What is the first name of the professor who is teaching CIS-220 and QM-261?", "rationale": ["Identify the tables needed: CLASS and EMPLOYEE.", "We need to find the first names of professors, which are in the EMPLOYEE table.", "The CLASS table contains the course codes (CIS-220 and QM-261) and the professor identifiers (PROF_NUM).", "We will join the CLASS table with the EMPLOYEE table on the condition that CLASS.PROF_NUM matches EMPLOYEE.EMP_NUM.", "We will filter the results to include only the courses CIS-220 and QM-261 using a WHERE clause with the IN operator."], "gold_sql": "SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  'CIS-220' INTERSECT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  'QM-261'", "source_tables": ["employee", "class"], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME \nFROM CLASS \nJOIN EMPLOYEE ON CLASS.PROF_NUM = EMPLOYEE.EMP_NUM \nWHERE CLASS.CRS_CODE IN ('CIS-220', 'QM-261');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of professors and the course codes they teach from the 'CLASS' and 'EMPLOYEE' tables. The join condition links the professor's identifier in the 'CLASS' table to the corresponding identifier in the 'EMPLOYEE' table.\"\n}\n"}
{"sample_id": "train.3293", "db_id": "college_1", "question": "Find the first name of student who is taking classes from accounting and Computer Info. Systems departments", "rationale": ["Identify the tables needed: STUDENT, ENROLL, CLASS, COURSE, and DEPARTMENT.", "Join the STUDENT table with the ENROLL table to get the classes each student is enrolled in.", "Join the ENROLL table with the CLASS table to link classes to their respective courses.", "Join the CLASS table with the COURSE table to access course details, including department information.", "Join the COURSE table with the DEPARTMENT table to filter by specific departments (Accounting and Computer Info. Systems).", "Select the distinct first names of students who are enrolled in classes from the specified departments."], "gold_sql": "SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Accounting' INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Computer Info. Systems'", "source_tables": ["course", "enroll", "department", "class", "student"], "pred_sql": "SELECT DISTINCT STUDENT.STU_FNAME \nFROM STUDENT \nJOIN ENROLL ON STUDENT.STU_NUM = ENROLL.STU_NUM \nJOIN CLASS ON ENROLL.CLASS_CODE = CLASS.CLASS_CODE \nJOIN COURSE ON CLASS.CRS_CODE = COURSE.CRS_CODE \nJOIN DEPARTMENT ON COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE \nWHERE DEPARTMENT.DEPT_NAME IN ('Accounting', 'Computer Info. Systems');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first names of employees, the office locations of professors, and descriptions of courses from the respective tables. The data is retrieved by joining the 'CLASS' table with the 'EMPLOYEE', 'COURSE', and 'PROFESSOR' tables based on their relationships, specifically linking professors to their classes and courses.\"\n}\n"}
{"sample_id": "train.3308", "db_id": "college_1", "question": "What are the first names and office of the professors who are in the history department and have a Ph.D?", "rationale": ["Identify the relevant tables: PROFESSOR, EMPLOYEE, and DEPARTMENT.", "We need to select the first names of professors and their office locations, so we will select EMP_FNAME from EMPLOYEE and PROF_OFFICE from PROFESSOR.", "To find professors in the history department, we will join the PROFESSOR table with the DEPARTMENT table on DEPT_CODE and filter for DEPT_NAME = 'History'.", "We also need to filter for professors who have a Ph.D., so we will add a condition for PROF_HIGH_DEGREE = 'Ph.D'.", "Construct the SQL query using SELECT, JOIN, and WHERE clauses to meet the requirements."], "gold_sql": "SELECT T1.emp_fname ,  T2.prof_office FROM employee AS T1 JOIN professor AS T2 ON T1.emp_num  =  T2.emp_num JOIN department AS T3 ON T3.dept_code  =  T2.dept_code WHERE T3.dept_name  =  'History' AND T2.prof_high_degree  =  'Ph.D.'", "source_tables": ["employee", "professor", "department"], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME, PROFESSOR.PROF_OFFICE \nFROM PROFESSOR \nJOIN EMPLOYEE ON PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM \nJOIN DEPARTMENT ON PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE \nWHERE DEPARTMENT.DEPT_NAME = 'History' AND PROFESSOR.PROF_HIGH_DEGREE = 'Ph.D';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of professors and the course codes they teach from the 'CLASS' and 'EMPLOYEE' tables. The join condition links the professor's identifier in the 'CLASS' table to the corresponding identifier in the 'EMPLOYEE' table.\"\n}\n"}
{"sample_id": "train.3319", "db_id": "college_1", "question": "Find names of all students who took some course and got A or C.", "rationale": ["Identify the tables needed: STUDENT for student names and ENROLL for enrollment details including grades.", "We need to find students who received either an 'A' or 'C' grade, so we will filter the ENROLL table based on the ENROLL_GRADE column.", "To get the names of the students, we will select the first and last names from the STUDENT table.", "We will join the STUDENT table with the ENROLL table on the student number (STU_NUM) to link students with their grades.", "Use DISTINCT to ensure that each student's name appears only once in the result, even if they took multiple courses with qualifying grades."], "gold_sql": "SELECT T1.stu_fname ,  T1.stu_lname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE T2.enroll_grade  =  'C' OR T2.enroll_grade  =  'A'", "source_tables": ["enroll", "student"], "pred_sql": "SELECT DISTINCT S.STU_FNAME, S.STU_LNAME \nFROM STUDENT S \nJOIN ENROLL E ON S.STU_NUM = E.STU_NUM \nWHERE E.ENROLL_GRADE IN ('A', 'C');", "hint": "\n"}
{"sample_id": "train.3324", "db_id": "college_1", "question": "What are the different first names and highest degree attained for professors teaching in the Computer Information Systems department?", "rationale": ["Identify the relevant tables: CLASS, EMPLOYEE, PROFESSOR, COURSE, and DEPARTMENT.", "Determine the columns needed: EMP_FNAME from EMPLOYEE and PROF_HIGH_DEGREE from PROFESSOR.", "Establish the relationships between the tables using JOINs: CLASS to EMPLOYEE (via PROF_NUM), EMPLOYEE to PROFESSOR (via EMP_NUM), CLASS to COURSE (via CRS_CODE), and COURSE to DEPARTMENT (via DEPT_CODE).", "Filter the results to only include professors from the 'Computer Information Systems' department using a WHERE clause on DEPARTMENT.DEPT_NAME."], "gold_sql": "SELECT DISTINCT T2.emp_fname ,  T3.prof_high_degree FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN professor AS T3 ON T2.emp_num  =  T3.emp_num JOIN department AS T4 ON T4.dept_code  =  T3.dept_code WHERE T4.dept_name  =  'Computer Info. Systems'", "source_tables": ["employee", "professor", "class", "department"], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME, PROFESSOR.PROF_HIGH_DEGREE \nFROM CLASS \nJOIN EMPLOYEE ON CLASS.PROF_NUM = EMPLOYEE.EMP_NUM \nJOIN PROFESSOR ON EMPLOYEE.EMP_NUM = PROFESSOR.EMP_NUM \nJOIN COURSE ON CLASS.CRS_CODE = COURSE.CRS_CODE \nJOIN DEPARTMENT ON COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE \nWHERE DEPARTMENT.DEPT_NAME = 'Computer Information Systems';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first names of employees, the office locations of professors, and descriptions of courses from the respective tables. The data is retrieved by joining the 'CLASS' table with the 'EMPLOYEE', 'COURSE', and 'PROFESSOR' tables based on their relationships, specifically linking professors to their classes and courses.\"\n}\n"}
{"sample_id": "train.3333", "db_id": "college_1", "question": "Find the name of department that offers the class whose description has the word \"Statistics\".", "rationale": ["Identify the relevant tables: DEPARTMENT, COURSE, and CLASS are needed to find the department offering a specific class.", "The relationship between these tables is established through foreign keys: CLASS.CRS_CODE links to COURSE.CRS_CODE, and COURSE.DEPT_CODE links to DEPARTMENT.DEPT_CODE.", "To find the department offering a class with a description containing 'Statistics', we need to filter the COURSE table based on the CRS_DESCRIPTION column.", "Use a JOIN operation to combine the DEPARTMENT, COURSE, and CLASS tables based on their relationships.", "Finally, select the DEPT_NAME from the DEPARTMENT table where the CRS_DESCRIPTION contains the word 'Statistics'."], "gold_sql": "SELECT T2.dept_name FROM course AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.crs_description LIKE '%Statistics%'", "source_tables": ["course", "department"], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME \nFROM DEPARTMENT \nJOIN COURSE ON DEPARTMENT.DEPT_CODE = COURSE.DEPT_CODE \nJOIN CLASS ON COURSE.CRS_CODE = CLASS.CRS_CODE \nWHERE COURSE.CRS_DESCRIPTION LIKE '%Statistics%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of courses offered by a specific department from the 'DEPARTMENT' and 'COURSE' tables. The placeholder in the WHERE clause represents the name of the department for which the course count is being queried.\"\n}\n"}
{"sample_id": "train.3343", "db_id": "sports_competition", "question": "What are the types and countries of competitions?", "rationale": ["Identify the relevant table: The question asks about competition types and countries, which are found in the 'competition' table.", "Select the required columns: We need to select 'Competition_type' and 'Country' from the 'competition' table.", "Construct the SQL query: Use the SELECT statement to retrieve the specified columns from the 'competition' table."], "gold_sql": "SELECT Competition_type ,  Country FROM competition", "source_tables": ["competition"], "pred_sql": "SELECT Competition_type, Country FROM competition;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides information about the types of competitions and the countries where they are held from the 'competition' table. The placeholders represent the specific competition type and country details.\"\n}\n"}
{"sample_id": "train.3355", "db_id": "sports_competition", "question": "Please show the names and the players of clubs.", "rationale": ["Identify the tables needed: 'club' for club names and 'player' for player names.", "Determine the relationship between the tables: 'club' and 'player' are linked by 'Club_ID'.", "Use a JOIN operation to combine the data from both tables based on 'Club_ID'.", "Select the desired columns: 'club.name' for club names and 'player.name' for player names."], "gold_sql": "SELECT T1.name ,  T2.Player_id FROM club AS T1 JOIN player AS T2 ON T1.Club_ID  =  T2.Club_ID", "source_tables": ["club", "player"], "pred_sql": "SELECT club.name, player.name \nFROM club \nJOIN player ON club.Club_ID = player.Club_ID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of clubs along with the unique identifiers of players associated with those clubs. The join operation links the 'club' table and the 'player' table based on the common 'Club_ID' field, allowing for the retrieval of player information for each club.\"\n}\n"}
{"sample_id": "train.3364", "db_id": "sports_competition", "question": "What are the positions of players whose average number of points scored by that position is larger than 20?", "rationale": ["We need to find the positions of players whose average points scored is greater than 20.", "To do this, we will select the 'Position' column from the 'player' table.", "We will group the results by 'Position' to calculate the average points for each position.", "We will use the HAVING clause to filter the groups where the average points is greater than 20."], "gold_sql": "SELECT POSITION FROM player GROUP BY name HAVING avg(Points)  >=  20", "source_tables": ["player"], "pred_sql": "SELECT Position\nFROM player\nGROUP BY Position\nHAVING AVG(Points) > 20;", "hint": "\n"}
{"sample_id": "train.3374", "db_id": "sports_competition", "question": "What are the positions of both players that have more than 20 20 points and less than 10 points?", "rationale": ["Identify the table that contains player information, which is the 'player' table.", "Determine the relevant column for player positions, which is 'Position'.", "Identify the column that contains the points scored by players, which is 'Points'.", "Formulate the condition to filter players based on their points: greater than 20 or less than 10.", "Construct the SQL query to select the 'Position' from the 'player' table where the points meet the specified conditions."], "gold_sql": "SELECT POSITION FROM player WHERE Points  >  20 INTERSECT SELECT POSITION FROM player WHERE Points  <  10", "source_tables": ["player"], "pred_sql": "SELECT Position FROM player WHERE Points > 20 OR Points < 10;", "hint": "\n"}
{"sample_id": "train.3383", "db_id": "sports_competition", "question": "which country did participated in the most number of Tournament competitions?", "rationale": ["Identify the relevant table: The 'competition' table contains information about competition types and countries.", "Filter for tournament competitions: We need to focus on rows where the 'Competition_type' is 'tournament'.", "Count the number of tournaments per country: Use COUNT(*) to count the occurrences of each country in the filtered results.", "Group the results by country: Use GROUP BY Country to aggregate the counts for each country.", "Order the results: Use ORDER BY to sort the countries by the count of tournaments in descending order.", "Limit the results to the top country: Use LIMIT 1 to get only the country with the most tournaments."], "gold_sql": "SELECT country FROM competition WHERE competition_type  =  'Tournament' GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["competition"], "pred_sql": "SELECT Country, COUNT(*) AS Tournament_Count\nFROM competition\nWHERE Competition_type = 'tournament'\nGROUP BY Country\nORDER BY Tournament_Count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides information about the types of competitions and the countries where they are held from the 'competition' table. The placeholders represent the specific competition type and country details.\"\n}\n"}
{"sample_id": "train.3384", "db_id": "sports_competition", "question": "what is the name of the country that participated in the most tournament competitions?", "rationale": ["Identify the relevant table: The 'competition' table contains information about competition types and countries.", "Filter for tournament competitions: We need to focus on rows where the Competition_type is 'tournament'.", "Group by country: To find out how many tournaments each country participated in, we will group the results by the 'Country' column.", "Count the number of tournaments: We will count the number of entries for each country to determine participation.", "Order the results: We will order the results in descending order based on the count of tournaments to find the country with the most participation.", "Limit the results: We will limit the output to just one result to get the country with the highest count."], "gold_sql": "SELECT country FROM competition WHERE competition_type  =  'Tournament' GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["competition"], "pred_sql": "SELECT Country FROM competition WHERE Competition_type = 'tournament' GROUP BY Country ORDER BY COUNT(*) DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides information about the types of competitions and the countries where they are held from the 'competition' table. The placeholders represent the specific competition type and country details.\"\n}\n"}
{"sample_id": "train.3388", "db_id": "sports_competition", "question": "What are the countries that have never participated in any friendly-type competitions?", "rationale": ["Identify the relevant table: The 'competition' table contains information about the types of competitions and the countries where they are held.", "Determine the competition type: We are interested in 'friendly' competitions.", "Select distinct countries: We want to find countries that have never participated in friendly competitions, so we will select distinct countries from the competition table where the competition type is 'friendly'.", "Use a subquery: To find countries that have never participated, we will use a subquery to select countries that have participated in friendly competitions and exclude them from our main query.", "Construct the final SQL query: Combine the main query and the subquery to get the desired result."], "gold_sql": "SELECT country FROM competition EXCEPT SELECT country FROM competition WHERE competition_type  =  'Friendly'", "source_tables": ["competition"], "pred_sql": "SELECT DISTINCT c.Country \nFROM competition c \nWHERE c.Competition_type = 'friendly' \nAND c.Country NOT IN (\n    SELECT DISTINCT c2.Country \n    FROM competition c2 \n    WHERE c2.Competition_type = 'friendly'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides information about the types of competitions and the countries where they are held from the 'competition' table. The placeholders represent the specific competition type and country details.\"\n}\n"}
{"sample_id": "train.3407", "db_id": "hr_1", "question": "List the full name (first and last name), and salary for those employees who earn below 6000.", "rationale": ["Identify the required fields: full name (first and last name) and salary.", "To get the full name, concatenate the FIRST_NAME and LAST_NAME fields using '||' operator.", "Select the SALARY field directly from the employees table.", "Filter the results to include only those employees whose salary is below 6000 using a WHERE clause."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees WHERE salary  <  6000", "source_tables": ["employees"], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, SALARY \nFROM employees \nWHERE SALARY < 6000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary to filter the results.\"\n}\n"}
{"sample_id": "train.3418", "db_id": "hr_1", "question": "What are the full name, hire date, salary, and department id for employees without the letter M in their first name?", "rationale": ["Identify the required fields: full name (concatenation of first and last names), hire date, salary, and department id.", "The full name can be created by concatenating the FIRST_NAME and LAST_NAME fields from the employees table.", "The data is sourced from the 'employees' table, so we will select from this table.", "We need to filter employees whose first name does not contain the letter 'M'. This can be done using the NOT LIKE operator in the WHERE clause."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%'", "source_tables": ["employees"], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, HIRE_DATE, SALARY, DEPARTMENT_ID \nFROM employees \nWHERE FIRST_NAME NOT LIKE '%M%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\"\n}\n"}
{"sample_id": "train.3419", "db_id": "hr_1", "question": "display the full name (first and last), hire date, salary, and department number for those employees whose first name does not containing the letter M and make the result set in ascending order by department number.", "rationale": ["Identify the columns needed: full name (first and last), hire date, salary, and department number.", "To get the full name, concatenate FIRST_NAME and LAST_NAME with a space in between.", "Filter employees whose first name does not contain the letter 'M'. This can be done using the NOT LIKE operator with a wildcard.", "Sort the results in ascending order by DEPARTMENT_ID.", "Construct the SQL SELECT statement with the identified columns, filtering condition, and ordering."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, HIRE_DATE, SALARY, DEPARTMENT_ID \nFROM employees \nWHERE FIRST_NAME NOT LIKE '%M%' \nORDER BY DEPARTMENT_ID ASC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves all employee records from the 'employees' table where the department ID does not fall within a specified range of manager IDs. The placeholders in the query represent numeric values for the range of manager IDs to filter out departments managed by those IDs.\"\n}\n"}
{"sample_id": "train.3420", "db_id": "hr_1", "question": "What are the full name, hire data, salary and department id for employees without the letter M in their first name, ordered by ascending department id?", "rationale": ["Identify the required fields: full name (first and last), hire date, salary, and department id.", "To create the full name, concatenate the FIRST_NAME and LAST_NAME fields with a space in between.", "Filter the employees to exclude those whose FIRST_NAME contains the letter 'M'.", "Order the results by DEPARTMENT_ID in ascending order.", "Construct the SQL SELECT statement using the identified fields and conditions."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, HIRE_DATE, SALARY, DEPARTMENT_ID \nFROM employees \nWHERE FIRST_NAME NOT LIKE '%M%' \nORDER BY DEPARTMENT_ID ASC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\"\n}\n"}
{"sample_id": "train.3442", "db_id": "hr_1", "question": "Which job titles correspond to jobs with salaries over 9000?", "rationale": ["Identify the relevant table: The 'jobs' table contains job titles and salary information.", "Determine the condition: We need to find jobs with salaries over 9000, which involves checking both the MIN_SALARY and MAX_SALARY columns.", "Construct the SQL query: Use a SELECT statement to retrieve the JOB_TITLE from the jobs table where either MIN_SALARY or MAX_SALARY is greater than 9000."], "gold_sql": "SELECT job_title FROM jobs WHERE min_salary  >  9000", "source_tables": ["jobs"], "pred_sql": "SELECT JOB_TITLE FROM jobs WHERE MIN_SALARY > 9000 OR MAX_SALARY > 9000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary to filter the results.\"\n}\n"}
{"sample_id": "train.3444", "db_id": "hr_1", "question": "What are the job titles, and range of salaries for jobs with maximum salary between 12000 and 18000?", "rationale": ["Identify the relevant table: The 'jobs' table contains the job titles and salary information.", "Determine the required columns: We need to select 'JOB_TITLE', 'MIN_SALARY', and 'MAX_SALARY'.", "Apply the filter condition: We want to find jobs where the 'MAX_SALARY' is between 12000 and 18000.", "Construct the SQL query using SELECT, FROM, and WHERE clauses."], "gold_sql": "SELECT job_title ,  max_salary - min_salary FROM jobs WHERE max_salary BETWEEN 12000 AND 18000", "source_tables": ["jobs"], "pred_sql": "SELECT JOB_TITLE, MIN_SALARY, MAX_SALARY \nFROM jobs \nWHERE MAX_SALARY BETWEEN 12000 AND 18000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary to filter the results.\"\n}\n"}
{"sample_id": "train.3448", "db_id": "hr_1", "question": "What are the employee ids for each employee and final dates of employment at their last job?", "rationale": ["Identify the relevant tables: 'employees' for employee IDs and 'job_history' for employment dates.", "We need to select the employee IDs and the final dates of employment, which are found in the 'job_history' table.", "To get the final date of employment for each employee, we can use a subquery to find the maximum END_DATE for each EMPLOYEE_ID in the job_history table.", "Join the 'employees' table with the 'job_history' table on EMPLOYEE_ID to get the necessary information in one query."], "gold_sql": "SELECT employee_id ,  MAX(end_date) FROM job_history GROUP BY employee_id", "source_tables": ["job_history"], "pred_sql": "SELECT e.EMPLOYEE_ID, jh.END_DATE\nFROM employees e\nJOIN job_history jh ON e.EMPLOYEE_ID = jh.EMPLOYEE_ID\nWHERE jh.END_DATE = (SELECT MAX(END_DATE) FROM job_history WHERE EMPLOYEE_ID = e.EMPLOYEE_ID);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\"\n}\n"}
{"sample_id": "train.3453", "db_id": "hr_1", "question": "display the average salary of employees for each department who gets a commission percentage.", "rationale": ["Identify the tables needed: We need data from the 'employees' table for salary and commission percentage, and from the 'departments' table for department names.", "Join the 'employees' table with the 'departments' table on the DEPARTMENT_ID to associate employees with their respective departments.", "Filter the results to include only those employees who have a non-null commission percentage, indicating they receive a commission.", "Use the AVG() function to calculate the average salary of employees for each department.", "Group the results by department name to get the average salary for each department."], "gold_sql": "SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != 'null' GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT d.DEPARTMENT_NAME, AVG(e.SALARY) AS average_salary\nFROM employees e\nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID\nWHERE e.COMMISSION_PCT IS NOT NULL\nGROUP BY d.DEPARTMENT_NAME;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary to filter the results.\"\n}\n"}
{"sample_id": "train.3454", "db_id": "hr_1", "question": "What is the average salary of employees who have a commission percentage that is not null?", "rationale": ["Identify the relevant table: The 'employees' table contains the salary and commission percentage information.", "Determine the required calculation: We need to calculate the average salary of employees.", "Set the condition: We only want to include employees whose commission percentage is not null.", "Construct the SQL query: Use the AVG() function to calculate the average salary and filter the results based on the commission percentage condition."], "gold_sql": "SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != 'null' GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT AVG(SALARY) AS average_salary\nFROM employees\nWHERE COMMISSION_PCT IS NOT NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary to filter the results.\"\n}\n"}
{"sample_id": "train.3455", "db_id": "hr_1", "question": "display the country ID and number of cities for each country.", "rationale": ["Identify the required columns: COUNTRY_ID from countries and the count of cities from locations.", "To get the number of cities for each country, we need to join the countries table with the locations table on the COUNTRY_ID.", "Use the COUNT function to count the number of cities for each country.", "Group the results by COUNTRY_ID to ensure we get a count for each country."], "gold_sql": "SELECT country_id ,  COUNT(*) FROM locations GROUP BY country_id", "source_tables": ["locations"], "pred_sql": "SELECT countries.COUNTRY_ID, COUNT(locations.CITY) AS number_of_cities\nFROM countries\nJOIN locations ON countries.COUNTRY_ID = locations.COUNTRY_ID\nGROUP BY countries.COUNTRY_ID;", "hint": "\n"}
{"sample_id": "train.3456", "db_id": "hr_1", "question": "Give the country id and corresponding count of cities in each country.", "rationale": ["Identify the tables needed: 'countries' for country information and 'locations' for city information.", "Determine the relationship between the tables: 'locations' has a foreign key 'COUNTRY_ID' that links to 'countries'.", "Use a JOIN to combine 'countries' and 'locations' on 'COUNTRY_ID'.", "Count the number of cities (from 'locations') for each country (from 'countries').", "Group the results by 'COUNTRY_ID' to get the count for each country."], "gold_sql": "SELECT country_id ,  COUNT(*) FROM locations GROUP BY country_id", "source_tables": ["locations"], "pred_sql": "SELECT c.COUNTRY_ID, COUNT(l.CITY) AS CITY_COUNT\nFROM countries c\nJOIN locations l ON c.COUNTRY_ID = l.COUNTRY_ID\nGROUP BY c.COUNTRY_ID;", "hint": "\n"}
{"sample_id": "train.3465", "db_id": "hr_1", "question": "Can you return all detailed info of jobs which was done by any of the employees who is presently earning a salary on and above 12000?", "rationale": ["We need to retrieve detailed information about jobs from the 'jobs' table.", "We will use the 'job_history' table to find the jobs that employees have done.", "We need to join the 'employees' table to filter employees based on their current salary.", "The condition specifies that we only want employees earning a salary of 12000 or more.", "We will join 'job_history' with 'employees' on 'EMPLOYEE_ID' and then join with 'jobs' on 'JOB_ID' to get the job details.", "Finally, we will select all columns from the 'jobs' table where the employee's salary is 12000 or more."], "gold_sql": "SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  12000", "source_tables": ["job_history", "employees"], "pred_sql": "SELECT j.*\nFROM job_history jh\nJOIN employees e ON jh.EMPLOYEE_ID = e.EMPLOYEE_ID\nJOIN jobs j ON jh.JOB_ID = j.JOB_ID\nWHERE e.SALARY >= 12000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary to filter the results.\"\n}\n"}
{"sample_id": "train.3482", "db_id": "hr_1", "question": "What is all the information regarding employees who are managers?", "rationale": ["Identify the requirement: We need to find all information regarding employees who are managers.", "Understand the relationship: An employee is considered a manager if their EMPLOYEE_ID matches the MANAGER_ID in the departments table.", "Use a subquery to find all unique MANAGER_IDs from the departments table.", "Select all columns from the employees table where the EMPLOYEE_ID is in the list of MANAGER_IDs obtained from the subquery."], "gold_sql": "SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T1.employee_id  =  T2.manager_id", "source_tables": ["employees", "departments"], "pred_sql": "SELECT e.* FROM employees e WHERE e.EMPLOYEE_ID IN (SELECT DISTINCT d.MANAGER_ID FROM departments d)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of employees who are also managers in their respective departments. It combines data from the 'employees' and 'departments' tables, ensuring that only those employees whose 'employee_id' matches the 'manager_id' of their department are included. The use of DISTINCT ensures that duplicate records are eliminated, providing a unique list of such employees.\"\n}\n"}
{"sample_id": "train.3487", "db_id": "hr_1", "question": "What are the unique ids of those departments where any manager is managing 4 or more employees.", "rationale": ["We need to find departments where the manager is managing 4 or more employees.", "To do this, we will join the 'departments' table with the 'employees' table on the condition that the 'MANAGER_ID' in the 'departments' table matches the 'EMPLOYEE_ID' in the 'employees' table.", "This join will allow us to see which employees are managers and how many employees they manage.", "Next, we will group the results by 'DEPARTMENT_ID' to count the number of employees managed by each manager.", "Finally, we will use the HAVING clause to filter the groups to only include those where the count of employees is 4 or more. We will select the distinct 'DEPARTMENT_ID' from these results."], "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"], "pred_sql": "SELECT DISTINCT d.DEPARTMENT_ID \nFROM departments d \nJOIN employees e ON d.MANAGER_ID = e.EMPLOYEE_ID \nGROUP BY d.DEPARTMENT_ID \nHAVING COUNT(e.EMPLOYEE_ID) >= 4;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of employees who are also managers in their respective departments. It combines data from the 'employees' and 'departments' tables, ensuring that only those employees whose 'employee_id' matches the 'manager_id' of their department are included. The use of DISTINCT ensures that duplicate records are eliminated, providing a unique list of such employees.\"\n}\n"}
{"sample_id": "train.3488", "db_id": "hr_1", "question": "Give the distinct department ids of departments in which a manager is in charge of 4 or more employees?", "rationale": ["We need to find distinct department IDs where a manager oversees 4 or more employees.", "To do this, we will join the 'departments' table with the 'employees' table on the condition that the 'MANAGER_ID' in the 'departments' table matches the 'EMPLOYEE_ID' in the 'employees' table.", "Next, we will group the results by 'DEPARTMENT_ID' to count the number of employees in each department.", "We will use the HAVING clause to filter the groups, keeping only those departments where the count of employees is 4 or more.", "Finally, we will select the distinct 'DEPARTMENT_ID' from the filtered results."], "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"], "pred_sql": "SELECT DISTINCT d.DEPARTMENT_ID\nFROM departments d\nJOIN employees e ON d.MANAGER_ID = e.EMPLOYEE_ID\nGROUP BY d.DEPARTMENT_ID\nHAVING COUNT(e.EMPLOYEE_ID) >= 4;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of employees who are also managers in their respective departments. It combines data from the 'employees' and 'departments' tables, ensuring that only those employees whose 'employee_id' matches the 'manager_id' of their department are included. The use of DISTINCT ensures that duplicate records are eliminated, providing a unique list of such employees.\"\n}\n"}
{"sample_id": "train.3496", "db_id": "hr_1", "question": "What is all the information regarding employees with salaries above the minimum and under 2500?", "rationale": ["Identify the relevant table: The 'employees' table contains the salary information we need.", "Determine the salary criteria: We want employees with salaries above the minimum salary from the 'jobs' table and below 2500.", "Use a subquery to find the minimum salary: The subquery (SELECT MIN_SALARY FROM jobs WHERE MIN_SALARY IS NOT NULL) retrieves the minimum salary from the 'jobs' table.", "Construct the SQL query: Combine the conditions using the WHERE clause to filter employees based on the specified salary criteria."], "gold_sql": "SELECT * FROM employees WHERE salary BETWEEN (SELECT MIN(salary) FROM employees) AND 2500", "source_tables": ["employees"], "pred_sql": "SELECT * FROM employees WHERE SALARY > (SELECT MIN_SALARY FROM jobs WHERE MIN_SALARY IS NOT NULL) AND SALARY < 2500;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary to filter the results.\"\n}\n"}
{"sample_id": "train.3500", "db_id": "hr_1", "question": "What are the full names and hire dates for employees in the same department as someone with the first name Clara?", "rationale": ["Identify the relevant tables: employees and departments are needed to get employee names and their department information.", "We need to find the department of the employee named Clara, so we will use a subquery to get Clara's department ID.", "The subquery will select the DEPARTMENT_ID from the departments table where the employee's first name is Clara.", "The main query will select the full names (concatenation of FIRST_NAME and LAST_NAME) and HIRE_DATE of employees who belong to the same department as Clara.", "We will join the employees table with the departments table to filter employees based on Clara's department ID."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  (SELECT department_id FROM employees WHERE first_name  =  'Clara')", "source_tables": ["employees"], "pred_sql": "SELECT e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.HIRE_DATE \nFROM employees e \nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nWHERE d.DEPARTMENT_ID = (SELECT d2.DEPARTMENT_ID \n                         FROM employees e2 \n                         JOIN departments d2 ON e2.DEPARTMENT_ID = d2.DEPARTMENT_ID \n                         WHERE e2.FIRST_NAME = 'Clara')", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\"\n}\n"}
{"sample_id": "train.3502", "db_id": "hr_1", "question": "What are the full names and hire dates for employees in the same department as someone with the first name Clara, not including Clara?", "rationale": ["Identify the tables needed: 'employees' for employee details and 'departments' to link employees to their departments.", "We need to find employees in the same department as Clara, so we will use a subquery to get Clara's department ID.", "The subquery selects the DEPARTMENT_ID from the 'departments' table where the employee's first name is 'Clara'.", "The main query selects the full names (concatenation of FIRST_NAME and LAST_NAME) and HIRE_DATE from the 'employees' table.", "We join the 'employees' table with the 'departments' table to filter employees by department.", "We add a condition to exclude Clara from the results by ensuring the FIRST_NAME is not 'Clara'."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  ( SELECT department_id FROM employees WHERE first_name  =  'Clara') AND first_name != 'Clara'", "source_tables": ["employees"], "pred_sql": "SELECT e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.HIRE_DATE \nFROM employees e \nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nWHERE d.DEPARTMENT_ID = (SELECT d2.DEPARTMENT_ID \n                         FROM employees e2 \n                         JOIN departments d2 ON e2.DEPARTMENT_ID = d2.DEPARTMENT_ID \n                         WHERE e2.FIRST_NAME = 'Clara') \nAND e.FIRST_NAME != 'Clara';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\"\n}\n"}
{"sample_id": "train.3503", "db_id": "hr_1", "question": "display the employee number and name( first name and last name ) for all employees who work in a department with any employee whose name contains a \u2019T\u2019.", "rationale": ["We need to display the employee number and name for employees working in departments with any employee whose name contains 'T'.", "First, we identify the employees whose names contain 'T'. This can be done using a subquery that selects from the 'employees' table where either the first name or last name contains 'T'.", "Next, we need to find the departments associated with these employees. We can achieve this by joining the 'employees' table with the 'departments' table on the DEPARTMENT_ID.", "Finally, we select the EMPLOYEE_ID, FIRST_NAME, and LAST_NAME of employees who work in the departments identified in the subquery."], "gold_sql": "SELECT employee_id ,  first_name ,  last_name FROM employees WHERE department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE '%T%' )", "source_tables": ["employees"], "pred_sql": "SELECT e.EMPLOYEE_ID, e.FIRST_NAME, e.LAST_NAME \nFROM employees e \nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nWHERE d.DEPARTMENT_ID IN (\n    SELECT d2.DEPARTMENT_ID \n    FROM employees e2 \n    WHERE e2.FIRST_NAME LIKE '%T%' OR e2.LAST_NAME LIKE '%T%'\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\"\n}\n"}
{"sample_id": "train.3507", "db_id": "hr_1", "question": "display the employee number and job id for all employees whose salary is smaller than any salary of those employees whose job title is MK_MAN.", "rationale": ["Identify the main requirement: We need to display the employee number (EMPLOYEE_ID) and job id (JOB_ID) for employees whose salary is smaller than any salary of those with the job title 'MK_MAN'.", "To achieve this, we will use a subquery to find the minimum salary of employees with the job title 'MK_MAN'.", "The subquery will join the 'employees' table with the 'jobs' table to filter by job title.", "The main query will select EMPLOYEE_ID and JOB_ID from the 'employees' table where the salary is less than the result of the subquery."], "gold_sql": "SELECT employee_id ,  job_id FROM employees WHERE salary  <  ( SELECT min(salary) FROM employees WHERE job_id  =  'MK_MAN' )", "source_tables": ["employees"], "pred_sql": "SELECT EMPLOYEE_ID, JOB_ID \nFROM employees \nWHERE SALARY < (\n    SELECT MIN(SALARY) \n    FROM employees \n    JOIN jobs ON employees.JOB_ID = jobs.JOB_ID \n    WHERE JOB_TITLE = 'MK_MAN'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary to filter the results.\"\n}\n"}
{"sample_id": "train.3512", "db_id": "hr_1", "question": "What are total salaries and department id for each department that has more than 2 employees?", "rationale": ["We need to find the total salaries and department IDs for departments with more than 2 employees.", "To do this, we will use the 'employees' table to get employee salaries and the 'departments' table to get department IDs.", "We will join the 'employees' table with the 'departments' table on the DEPARTMENT_ID column to associate employees with their respective departments.", "Next, we will group the results by DEPARTMENT_ID to calculate the total salary for each department using the SUM function.", "We will also count the number of employees in each department using the COUNT function.", "Finally, we will filter the results using the HAVING clause to include only those departments that have more than 2 employees."], "gold_sql": "SELECT department_id ,  SUM(salary) FROM employees GROUP BY department_id HAVING count(*)  >=  2", "source_tables": ["employees"], "pred_sql": "SELECT d.DEPARTMENT_ID, SUM(e.SALARY) AS total_salaries\nFROM employees e\nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID\nGROUP BY d.DEPARTMENT_ID\nHAVING COUNT(e.EMPLOYEE_ID) > 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\"\n}\n"}
{"sample_id": "train.3515", "db_id": "hr_1", "question": "display the department ID, full name (first and last name), salary for those employees who is highest salary in every department.", "rationale": ["We need to display the department ID, full name (first and last name), and salary of employees with the highest salary in each department.", "To get the full name, we can concatenate the first name and last name using the '||' operator.", "We will select from the 'employees' table, which contains the necessary information about employees, including their salaries and department IDs.", "To find the highest salary in each department, we can use a subquery that selects the maximum salary from the 'employees' table, filtered by the department ID.", "The main query will filter employees whose salary matches the maximum salary for their respective department."], "gold_sql": "SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT e.DEPARTMENT_ID, e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.SALARY \nFROM employees e \nWHERE e.SALARY = (SELECT MAX(SALARY) \n                   FROM employees \n                   WHERE DEPARTMENT_ID = e.DEPARTMENT_ID)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\"\n}\n"}
{"sample_id": "train.3520", "db_id": "hr_1", "question": "What are the full names and cities of employees who have the letter Z in their first names?", "rationale": ["Identify the tables needed: employees for names, departments for department IDs, locations for cities, and countries for country information.", "Join the employees table with the departments table on DEPARTMENT_ID to get department information.", "Join the resulting table with the locations table on LOCATION_ID to get city information.", "Use the WHERE clause to filter employees whose FIRST_NAME contains the letter 'Z'.", "Select the concatenated full name (FIRST_NAME + LAST_NAME) and the city from the joined tables."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T3.city FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id WHERE T1.first_name LIKE '%z%'", "source_tables": ["employees", "departments", "locations"], "pred_sql": "SELECT e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, l.CITY \nFROM employees e \nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nJOIN locations l ON d.LOCATION_ID = l.LOCATION_ID \nJOIN countries c ON l.COUNTRY_ID = c.COUNTRY_ID \nWHERE e.FIRST_NAME LIKE '%Z%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\"\n}\n"}
{"sample_id": "train.3523", "db_id": "hr_1", "question": "display the full name (first and last name ) of employee with ID and name of the country presently where (s)he is working.", "rationale": ["Identify the tables needed: employees, departments, locations, and countries.", "We need to join these tables to get the full name of the employee and the country they are working in.", "The employee's full name can be constructed by concatenating the FIRST_NAME and LAST_NAME from the employees table.", "The country name can be obtained from the countries table, which is linked to the locations table, which in turn is linked to the departments table.", "The join conditions are: employees to departments on DEPARTMENT_ID, departments to locations on LOCATION_ID, and locations to countries on COUNTRY_ID.", "Finally, we filter the results to get the specific employee by their EMPLOYEE_ID."], "gold_sql": "SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id", "source_tables": ["countries", "employees", "departments", "locations"], "pred_sql": "SELECT e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, c.COUNTRY_NAME\nFROM employees e\nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID\nJOIN locations l ON d.LOCATION_ID = l.LOCATION_ID\nJOIN countries c ON l.COUNTRY_ID = c.COUNTRY_ID\nWHERE e.EMPLOYEE_ID = ?;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\"\n}\n"}
{"sample_id": "train.3525", "db_id": "hr_1", "question": "display the department name and number of employees in each of the department.", "rationale": ["We need to display the department name and the number of employees in each department.", "The relevant tables for this query are 'departments' and 'employees'.", "We will use a LEFT JOIN to connect the 'departments' table with the 'employees' table on the 'DEPARTMENT_ID' column.", "We will select the 'DEPARTMENT_NAME' from the 'departments' table and count the 'EMPLOYEE_ID' from the 'employees' table to get the number of employees in each department.", "To ensure we get all departments even if they have no employees, we use LEFT JOIN.", "Finally, we will group the results by 'DEPARTMENT_NAME' to get the count of employees for each department."], "gold_sql": "SELECT department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY department_name", "source_tables": ["employees", "departments"], "pred_sql": "SELECT d.DEPARTMENT_NAME, COUNT(e.EMPLOYEE_ID) AS NUMBER_OF_EMPLOYEES\nFROM departments d\nLEFT JOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID\nGROUP BY d.DEPARTMENT_NAME;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\"\n}\n"}
{"sample_id": "train.3526", "db_id": "hr_1", "question": "What are the department names and how many employees work in each of them?", "rationale": ["Identify the tables needed: We need the 'departments' table for department names and the 'employees' table to count the number of employees in each department.", "Join the 'departments' table with the 'employees' table on the 'DEPARTMENT_ID' to associate employees with their respective departments.", "Use a LEFT JOIN to ensure that departments with no employees are still included in the results with a count of zero.", "Group the results by 'DEPARTMENT_NAME' to aggregate the employee counts for each department.", "Select the department name and the count of employees, labeling the count as 'EMPLOYEE_COUNT'."], "gold_sql": "SELECT department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY department_name", "source_tables": ["employees", "departments"], "pred_sql": "SELECT d.DEPARTMENT_NAME, COUNT(e.EMPLOYEE_ID) AS EMPLOYEE_COUNT\nFROM departments d\nLEFT JOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID\nGROUP BY d.DEPARTMENT_NAME;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\"\n}\n"}
{"sample_id": "train.3527", "db_id": "hr_1", "question": "display the full name (first and last name), and salary of those employees who working in any department located in London.", "rationale": ["Identify the tables needed: employees, departments, locations, and countries.", "We need to join these tables to get the required information: employee names and salaries based on department locations.", "Join employees with departments on DEPARTMENT_ID to get department information for each employee.", "Join departments with locations on LOCATION_ID to filter departments based on their locations.", "Join locations with countries on COUNTRY_ID to ensure we have the correct country information, although it's not directly needed for the query.", "Filter the results to only include employees whose departments are located in London by using a WHERE clause on the CITY column."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  'London'", "source_tables": ["employees", "departments", "locations"], "pred_sql": "SELECT e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.SALARY \nFROM employees e \nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nJOIN locations l ON d.LOCATION_ID = l.LOCATION_ID \nJOIN countries c ON l.COUNTRY_ID = c.COUNTRY_ID \nWHERE l.CITY = 'London';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\"\n}\n"}
{"sample_id": "train.3528", "db_id": "hr_1", "question": "What are full names and salaries of employees working in the city of London?", "rationale": ["Identify the tables needed: employees, departments, locations, and countries.", "We need to retrieve the first name and last name of employees, which are in the employees table.", "To get the city of the employees' departments, we need to join the employees table with the departments table using DEPARTMENT_ID.", "Next, we join the departments table with the locations table using LOCATION_ID to access the city information.", "Finally, we filter the results to only include employees whose departments are located in London by using a WHERE clause on the city column."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  'London'", "source_tables": ["employees", "departments", "locations"], "pred_sql": "SELECT e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.SALARY \nFROM employees e \nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nJOIN locations l ON d.LOCATION_ID = l.LOCATION_ID \nJOIN countries c ON l.COUNTRY_ID = c.COUNTRY_ID \nWHERE l.CITY = 'London';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\"\n}\n"}
{"sample_id": "train.3532", "db_id": "music_1", "question": "Find the id of the song that lasts the longest.", "rationale": ["We need to find the id of the song that lasts the longest, which means we need to look at the duration of the songs.", "The 'song' table contains the song information including the 'f_id', and the 'files' table contains the duration of the audio files.", "To get the duration of each song, we will join the 'song' table with the 'files' table on the 'f_id' column.", "We will order the results by the duration in descending order to get the longest song at the top.", "Finally, we will limit the results to 1 to get only the longest song's id."], "gold_sql": "SELECT f_id FROM files ORDER BY duration DESC LIMIT 1", "source_tables": ["files"], "pred_sql": "SELECT song.f_id FROM song JOIN files ON song.f_id = files.f_id ORDER BY files.duration DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of artists from the 'song' table, joined with the 'files' table to access the duration of their songs. The results are ordered by the duration of the audio files, and a placeholder is used to limit the number of results returned.\"\n}\n"}
{"sample_id": "train.3542", "db_id": "music_1", "question": "What are the names of the artists who sang the shortest song?", "rationale": ["Identify the relevant tables: 'song' for artist names and 'files' for song durations.", "Join the 'song' table with the 'files' table on the foreign key 'f_id' to access the duration of each song.", "Select the 'artist_name' from the 'artist' table, which is linked through the 'song' table.", "Order the results by the 'duration' in ascending order to find the shortest song.", "Limit the results to 1 to get only the artist who sang the shortest song."], "gold_sql": "SELECT T1.artist_name FROM song AS T1 JOIN files AS T2 ON T1.f_id  =  T2.f_id ORDER BY T2.duration LIMIT 1", "source_tables": ["files", "song"], "pred_sql": "SELECT artist.artist_name \nFROM song \nJOIN files ON song.f_id = files.f_id \nORDER BY files.duration ASC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of artists from the 'song' table, joined with the 'files' table to access the duration of their songs. The results are ordered by the duration of the audio files, and a placeholder is used to limit the number of results returned.\"\n}\n"}
{"sample_id": "train.3545", "db_id": "music_1", "question": "How many songs have 4 minute duration?", "rationale": ["Identify the relevant tables: 'song' and 'files' are needed to access song details and their durations.", "Join the 'song' table with the 'files' table on the foreign key 'f_id' to link songs with their respective file details.", "Filter the results to only include songs where the duration is exactly '4:00'.", "Use the COUNT() function to count the number of songs that meet the duration criteria."], "gold_sql": "SELECT count(*) FROM files WHERE duration LIKE '4:%'", "source_tables": ["files"], "pred_sql": "SELECT COUNT(*) FROM song JOIN files ON song.f_id = files.f_id WHERE files.duration = '4:00';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of artists from the 'song' table, joined with the 'files' table to access the duration of their songs. The results are ordered by the duration of the audio files, and a placeholder is used to limit the number of results returned.\"\n}\n"}
{"sample_id": "train.3549", "db_id": "music_1", "question": "What is the average rating of songs produced by female artists?", "rationale": ["Identify the main goal: Calculate the average rating of songs produced by female artists.", "To find the average rating, we need to use the AVG() function on the 'rating' column from the 'song' table.", "We need to filter the songs based on the artists' gender, which requires a subquery to get the names of female artists from the 'artist' table.", "The subquery selects 'artist_name' from the 'artist' table where 'gender' is 'female'.", "The main query then selects the average rating from the 'song' table where the 'artist_name' is in the list of names returned by the subquery."], "gold_sql": "SELECT avg(T2.rating) FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  'Female'", "source_tables": ["artist", "song"], "pred_sql": "SELECT AVG(rating) AS average_rating FROM song WHERE artist_name IN (SELECT artist_name FROM artist WHERE gender = 'female')", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average rating of songs performed by artists of a specific gender. The placeholder in the WHERE clause represents the gender of the artists being queried.\"\n}\n"}
{"sample_id": "train.3552", "db_id": "music_1", "question": "Find the file format that is used by the most files.", "rationale": ["We need to find the file format that is used by the most files.", "To do this, we will select the 'formats' column from the 'files' table.", "We will count the number of occurrences of each format using COUNT(*).", "We will group the results by the 'formats' column to aggregate the counts for each format.", "To find the most common format, we will order the results in descending order based on the count of files.", "Finally, we will limit the results to 1 to get only the most used file format."], "gold_sql": "SELECT formats FROM files GROUP BY formats ORDER BY COUNT (*) DESC LIMIT 1", "source_tables": ["files"], "pred_sql": "SELECT formats, COUNT(*) as file_count \nFROM files \nGROUP BY formats \nORDER BY file_count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of audio file formats from the 'files' table, grouped by format type. The results are ordered by the count of files in each format, allowing users to see the most common formats used. The placeholder in the LIMIT clause represents the maximum number of formats to return.\"\n}\n"}
{"sample_id": "train.3556", "db_id": "music_1", "question": "What is the id of the files that are available in the format of mp4 and a resolution smaller than 1000?", "rationale": ["Identify the table to query: The question asks about files, so we will query the 'files' table.", "Determine the conditions: We need to filter files that are in the 'mp4' format and have a resolution smaller than 1000.", "Construct the SQL query: We will select the 'f_id' from the 'files' table where the 'formats' column contains 'mp4' and the 'resolution' column is less than 1000."], "gold_sql": "SELECT f_id FROM files WHERE formats  =  'mp4' INTERSECT SELECT f_id FROM song WHERE resolution  <  1000", "source_tables": ["files", "song"], "pred_sql": "SELECT f_id FROM files WHERE formats LIKE '%mp4%' AND resolution < '1000';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of file identifiers from the 'files' table, sorted by the duration of the audio files in descending order. The placeholder in the LIMIT clause indicates the maximum number of file identifiers to return.\"\n}\n"}
{"sample_id": "train.3557", "db_id": "music_1", "question": "What is the country of origin of the artist who is female and produced a song in Bangla?", "rationale": ["Identify the relevant tables: 'artist' and 'song'.", "We need to find artists who are female and have produced songs in Bangla, so we will filter the 'artist' table by gender and the 'song' table by languages.", "Join the 'artist' table with the 'song' table on the artist's name to correlate artists with their songs.", "Select the 'country' column from the 'artist' table as the output.", "Construct the SQL query using the SELECT statement, JOIN clause, and WHERE conditions."], "gold_sql": "SELECT T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  'Female' AND T2.languages  =  'bangla'", "source_tables": ["artist", "song"], "pred_sql": "SELECT artist.country \nFROM artist \nJOIN song ON artist.artist_name = song.artist_name \nWHERE artist.gender = 'female' AND song.languages LIKE '%Bangla%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of artist names and their corresponding countries from the 'artist' table, joined with the 'song' table to include only those artists who have songs. The results are ordered by the rating of the songs in descending order, and the number of results is limited by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.3558", "db_id": "music_1", "question": "What countries are the female artists who sung in the language Bangla from?", "rationale": ["Identify the relevant tables: 'artist' and 'song'.", "We need to find female artists, so we will filter the 'artist' table by gender = 'female'.", "We also need to filter songs that are sung in the language Bangla, which is found in the 'languages' column of the 'song' table.", "Join the 'artist' table with the 'song' table on the 'artist_name' column to get the relevant data.", "Select distinct countries from the 'artist' table where the conditions are met."], "gold_sql": "SELECT T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  'Female' AND T2.languages  =  'bangla'", "source_tables": ["artist", "song"], "pred_sql": "SELECT DISTINCT artist.country \nFROM artist \nJOIN song ON artist.artist_name = song.artist_name \nWHERE artist.gender = 'female' \nAND song.languages LIKE '%Bangla%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of artist names and their corresponding countries from the 'artist' table, joined with the 'song' table to include only those artists who have songs. The results are ordered by the rating of the songs in descending order, and the number of results is limited by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.3566", "db_id": "music_1", "question": "What is the gender and name of the artist who sang the song with the smallest resolution?", "rationale": ["Identify the relevant tables: 'artist' and 'song'.", "We need to retrieve the gender and name of the artist, which are in the 'artist' table.", "The song's resolution is in the 'song' table, so we need to join 'artist' and 'song' on the artist's name.", "To find the song with the smallest resolution, we will order the results by the 'resolution' column in ascending order.", "Finally, we limit the results to 1 to get only the artist associated with the song that has the smallest resolution."], "gold_sql": "SELECT T1.gender ,  T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.resolution LIMIT 1", "source_tables": ["artist", "song"], "pred_sql": "SELECT artist.gender, artist.artist_name \nFROM artist \nJOIN song ON artist.artist_name = song.artist_name \nORDER BY song.resolution ASC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the gender and name of artists from the 'artist' table who have songs listed in the 'song' table. The results are ordered by the audio resolution of the songs, and the number of results returned is limited by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.3567", "db_id": "music_1", "question": "For each file format, return the number of artists who released songs in that format.", "rationale": ["We need to count the number of distinct artists who released songs in each file format.", "To do this, we will join the 'files' table with the 'song' table on the 'f_id' column, as this will allow us to associate each file format with the songs that have been released.", "Next, we will group the results by the 'formats' column from the 'files' table to get the count of artists for each format.", "We will use COUNT(DISTINCT artist_name) to ensure that we are counting unique artists for each format, avoiding duplicates.", "Finally, we will select the 'formats' and the count of artists as 'artist_count'."], "gold_sql": "SELECT count(*) ,  formats FROM files GROUP BY formats", "source_tables": ["files"], "pred_sql": "SELECT formats, COUNT(DISTINCT artist_name) AS artist_count \nFROM files \nJOIN song ON files.f_id = song.f_id \nGROUP BY formats;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of audio file formats from the 'files' table, grouped by format type. The results are ordered by the count of files in each format, allowing users to see the most common formats used. The placeholder in the LIMIT clause represents the maximum number of formats to return.\"\n}\n"}
{"sample_id": "train.3576", "db_id": "music_1", "question": "What are the names and genders of all artists who released songs in the month of March?", "rationale": ["Identify the tables involved: 'artist' and 'song'.", "We need to retrieve the names and genders of artists, so we will select 'artist.artist_name' and 'artist.gender'.", "To find artists who released songs in March, we need to join the 'artist' table with the 'song' table on the 'artist_name' column.", "We will filter the results using the 'releasedate' column from the 'song' table, specifically looking for records where the month part of the date is '03' (March).", "Use the strftime function to extract the month from the 'releasedate' field."], "gold_sql": "SELECT T1.artist_name ,  T1.gender FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.releasedate LIKE '%Mar%'", "source_tables": ["artist", "song"], "pred_sql": "SELECT artist.artist_name, artist.gender \nFROM artist \nJOIN song ON artist.artist_name = song.artist_name \nWHERE strftime('%m', song.releasedate) = '03';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the gender and name of artists from the 'artist' table who have songs listed in the 'song' table. The results are ordered by the audio resolution of the songs, and the number of results returned is limited by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.3586", "db_id": "music_1", "question": "What are the languages that are used most often in songs?", "rationale": ["Identify the relevant table: The 'song' table contains the 'languages' column which we need to analyze.", "Count the occurrences of each language: We will use the COUNT function to count how many songs are available in each language.", "Group the results by language: We will use the GROUP BY clause to group the results based on the 'languages' column.", "Order the results: To find the most used languages, we will order the results in descending order based on the count of songs in each language."], "gold_sql": "SELECT languages FROM song GROUP BY languages ORDER BY count(*) DESC LIMIT 1", "source_tables": ["song"], "pred_sql": "SELECT languages, COUNT(*) as song_count \nFROM song \nGROUP BY languages \nORDER BY song_count DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of languages in which songs are available, grouped by language and ordered by the number of songs in each language. The placeholder in the LIMIT clause allows the user to specify the maximum number of languages to retrieve.\"\n}\n"}
{"sample_id": "train.3590", "db_id": "music_1", "question": "What are the names of all male British artists?", "rationale": ["Identify the relevant table: The 'artist' table contains information about artists, including their names, countries, and genders.", "Determine the conditions: We need to filter artists who are from 'British' and are 'male'.", "Construct the SQL query: Use a SELECT statement to retrieve the 'artist_name' from the 'artist' table where the conditions are met."], "gold_sql": "SELECT artist_name FROM artist WHERE country  =  'UK' AND gender  =  'Male'", "source_tables": ["artist"], "pred_sql": "SELECT artist_name FROM artist WHERE country = 'British' AND gender = 'male';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the gender and name of artists from the 'artist' table who have songs listed in the 'song' table. The results are ordered by the audio resolution of the songs, and the number of results returned is limited by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.3598", "db_id": "music_1", "question": "What is the average rating and resolution of all bangla songs?", "rationale": ["Identify the relevant tables: We need to gather information from the 'song' table to find the average rating and resolution of Bangla songs.", "Determine the columns needed: We need the 'rating' and 'resolution' columns from the 'song' table.", "Filter the results: We need to filter the songs to only include those that belong to the Bangla genre, which is indicated by the 'genre_is' column.", "Calculate the averages: Use the AVG() function to calculate the average rating and resolution for the filtered results."], "gold_sql": "SELECT avg(rating) ,  avg(resolution) FROM song WHERE languages  =  'bangla'", "source_tables": ["song"], "pred_sql": "SELECT AVG(song.rating) AS average_rating, AVG(song.resolution) AS average_resolution \nFROM song \nWHERE song.genre_is = 'Bangla';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average rating of songs performed by artists of a specific gender. The placeholder in the WHERE clause represents the gender of the artists being queried.\"\n}\n"}
{"sample_id": "train.3599", "db_id": "music_1", "question": "What are the maximum and minimum resolution of songs whose duration is 3 minutes?", "rationale": ["Identify the tables involved: 'song' and 'files'.", "Determine the columns needed: 'resolution' from 'song' and 'duration' from 'files'.", "Use JOIN to connect 'song' and 'files' on the foreign key 'f_id'.", "Filter the results to only include songs with a duration of 3 minutes (formatted as '3:00').", "Select the maximum and minimum resolution from the filtered results."], "gold_sql": "SELECT max(T2.resolution) ,  min(T2.resolution) FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.duration LIKE '3:%'", "source_tables": ["files", "song"], "pred_sql": "SELECT MAX(resolution) AS max_resolution, MIN(resolution) AS min_resolution \nFROM song \nJOIN files ON song.f_id = files.f_id \nWHERE files.duration = '3:00';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the maximum and minimum audio resolutions of songs from the 'song' table, filtered by the duration of the associated files in the 'files' table. The placeholder in the WHERE clause represents the specific duration pattern to match.\"\n}\n"}
{"sample_id": "train.3601", "db_id": "music_1", "question": "What are the maximum duration and resolution of songs grouped and ordered by languages?", "rationale": ["Identify the relevant table: The 'song' table contains the necessary columns for duration and resolution, as well as languages.", "Select the columns needed: We need to select 'languages', the maximum 'duration', and the maximum 'resolution'.", "Use aggregate functions: To find the maximum values, we will use the MAX() function for both 'duration' and 'resolution'.", "Group the results: We will group the results by 'languages' to get the maximum duration and resolution for each language.", "Order the results: Finally, we will order the results by 'languages' to have a structured output."], "gold_sql": "SELECT max(T1.duration) ,  max(T2.resolution) ,  T2.languages FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.languages ORDER BY T2.languages", "source_tables": ["files", "song"], "pred_sql": "SELECT languages, MAX(duration) AS max_duration, MAX(resolution) AS max_resolution \nFROM song \nGROUP BY languages \nORDER BY languages;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of languages in which songs are available, grouped by language and ordered by the number of songs in each language. The placeholder in the LIMIT clause allows the user to specify the maximum number of languages to retrieve.\"\n}\n"}
{"sample_id": "train.3603", "db_id": "music_1", "question": "What are the shortest duration and lowest rating of songs grouped by genre and ordered by genre?", "rationale": ["Identify the tables needed: We need data from the 'song' and 'genre' tables.", "Determine the required fields: We need the genre name, the shortest duration of songs, and the lowest rating of songs.", "Use aggregate functions: To find the shortest duration, we will use MIN(song.duration), and for the lowest rating, we will use MIN(song.rating).", "Join the tables: We need to join the 'song' table with the 'genre' table on the genre field to get the genre name associated with each song.", "Group the results: We will group the results by genre to get the shortest duration and lowest rating for each genre.", "Order the results: Finally, we will order the results by genre name."], "gold_sql": "SELECT min(T1.duration) ,  min(T2.rating) ,  T2.genre_is FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.genre_is ORDER BY T2.genre_is", "source_tables": ["files", "song"], "pred_sql": "SELECT genre.g_name, MIN(song.duration) AS shortest_duration, MIN(song.rating) AS lowest_rating\nFROM song\nJOIN genre ON song.genre_is = genre.g_name\nGROUP BY genre.g_name\nORDER BY genre.g_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the titles of songs from the 'song' table that belong to a specific genre or are available in a specific language. The placeholders in the WHERE clause represent the genre and language criteria.\"\n}\n"}
{"sample_id": "train.3607", "db_id": "music_1", "question": "Find the name and country of origin for all artists who have release at least one song of resolution above 900.", "rationale": ["Identify the tables involved: 'artist' and 'song'.", "We need to find artists who have released songs with a resolution above 900, so we will join the 'artist' table with the 'song' table on the artist's name.", "Select the distinct artist names and their countries from the 'artist' table.", "Apply a condition to filter songs based on the resolution being greater than 900."], "gold_sql": "SELECT T1.artist_name ,  T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.resolution  >  900 GROUP BY T2.artist_name HAVING count(*)  >=  1", "source_tables": ["artist", "song"], "pred_sql": "SELECT DISTINCT artist.artist_name, artist.country \nFROM artist \nJOIN song ON artist.artist_name = song.artist_name \nWHERE song.resolution > 900;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of artist names and their corresponding countries from the 'artist' table, joined with the 'song' table to include only those artists who have songs. The results are ordered by the rating of the songs in descending order, and the number of results is limited by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.3619", "db_id": "music_1", "question": "Find the top 3 artists who have the largest number of songs works whose language is Bangla.", "rationale": ["Identify the relevant table: The 'song' table contains information about songs, including their languages and the associated artists.", "Filter songs by language: We need to filter the songs to only include those that have 'Bangla' in their 'languages' column.", "Group by artist: To find the number of songs per artist, we will group the results by 'artist_name'.", "Count the number of songs: We will use the COUNT() function to count the number of songs for each artist.", "Order the results: We want the artists with the largest number of songs, so we will order the results in descending order based on the count of songs.", "Limit the results: Finally, we will limit the results to the top 3 artists."], "gold_sql": "SELECT T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.languages  =  'bangla' GROUP BY T2.artist_name ORDER BY count(*) DESC LIMIT 3", "source_tables": ["artist", "song"], "pred_sql": "SELECT artist_name, COUNT(song_name) AS song_count \nFROM song \nWHERE languages LIKE '%Bangla%' \nGROUP BY artist_name \nORDER BY song_count DESC \nLIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of languages in which songs are available, grouped by language and ordered by the number of songs in each language. The placeholder in the LIMIT clause allows the user to specify the maximum number of languages to retrieve.\"\n}\n"}
{"sample_id": "train.3623", "db_id": "music_1", "question": "List the duration, file size and format of songs whose genre is pop, ordered by title?", "rationale": ["Identify the relevant tables: 'song' for song details and 'files' for file details.", "Determine the columns needed: 'duration' from 'song', 'file_size' and 'formats' from 'files'.", "Establish the relationship between the tables using the foreign key: 'song.f_id' relates to 'files.f_id'.", "Filter the results to include only songs where the genre is 'pop'.", "Order the results by the song title, which corresponds to 'song.song_name'."], "gold_sql": "SELECT T1.duration ,  T1.file_size ,  T1.formats FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T2.genre_is  =  'pop' ORDER BY T2.song_name", "source_tables": ["files", "song"], "pred_sql": "SELECT song.duration, files.file_size, files.formats \nFROM song \nJOIN files ON song.f_id = files.f_id \nWHERE song.genre_is = 'pop' \nORDER BY song.song_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of artists from the 'song' table, joined with the 'files' table to access the duration of their songs. The results are ordered by the duration of the audio files, and a placeholder is used to limit the number of results returned.\"\n}\n"}
{"sample_id": "train.3624", "db_id": "music_1", "question": "What is the duration, file size, and song format for every pop song, ordered by title alphabetically?", "rationale": ["Identify the relevant tables: 'song' for song details and 'files' for file details.", "Determine the columns needed: 'duration', 'file_size', and 'formats' from the 'files' table, and 'song_name' from the 'song' table.", "Join the 'song' table with the 'files' table on the foreign key 'f_id' to access the file details for each song.", "Filter the results to include only those songs that belong to the 'pop' genre.", "Order the final results alphabetically by the song title."], "gold_sql": "SELECT T1.duration ,  T1.file_size ,  T1.formats FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T2.genre_is  =  'pop' ORDER BY T2.song_name", "source_tables": ["files", "song"], "pred_sql": "SELECT song.song_name, files.duration, files.file_size, files.formats \nFROM song \nJOIN files ON song.f_id = files.f_id \nWHERE song.genre_is = 'pop' \nORDER BY song.song_name ASC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of artists from the 'song' table, joined with the 'files' table to access the duration of their songs. The results are ordered by the duration of the audio files, and a placeholder is used to limit the number of results returned.\"\n}\n"}
{"sample_id": "train.3631", "db_id": "baseball_1", "question": "What is average salary of the players in the team named 'Boston Red Stockings' ?", "rationale": ["Identify the relevant tables: 'salary' for salary information and 'team' for team names.", "Join the 'salary' table with the 'team' table on 'team_id' to associate salaries with the correct teams.", "Use the AVG() function to calculate the average salary from the 'salary' table.", "Filter the results to only include players from the team named 'Boston Red Stockings' using a WHERE clause."], "gold_sql": "SELECT avg(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings'", "source_tables": ["team", "salary"], "pred_sql": "SELECT AVG(salary.salary) AS average_salary\nFROM salary\nJOIN team ON salary.team_id = team.team_id\nWHERE team.name = 'Boston Red Stockings';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average salary of players from a specific team in the 'salary' table. The placeholder in the WHERE clause represents the name of the team for which the average salary is being calculated.\"\n}\n"}
{"sample_id": "train.3650", "db_id": "baseball_1", "question": "What are the three countries that the least players are from?", "rationale": ["Identify the relevant table: The 'player' table contains information about players, including their birth countries.", "Select the 'birth_country' column and count the number of players from each country using COUNT(player_id).", "Group the results by 'birth_country' to aggregate the player counts for each country.", "Order the results in ascending order based on the player count to find the countries with the least players.", "Limit the results to the top 3 countries with the least players."], "gold_sql": "SELECT birth_country FROM player GROUP BY birth_country ORDER BY count(*) ASC LIMIT 3;", "source_tables": ["player"], "pred_sql": "SELECT birth_country, COUNT(player_id) AS player_count\nFROM player\nGROUP BY birth_country\nORDER BY player_count ASC\nLIMIT 3;", "hint": "\n"}
{"sample_id": "train.3657", "db_id": "baseball_1", "question": "What is the highest salary among each team? List the team name, id and maximum salary.", "rationale": ["We need to find the highest salary for each team, which requires us to aggregate salary data by team.", "The salary table contains the salary information, and the team table contains the team names and IDs.", "To get the maximum salary for each team, we will use the MAX() function on the salary column.", "We will join the salary table with the team table on the team_id to get the team names along with their IDs.", "Finally, we will group the results by team_id to ensure we get the maximum salary for each team."], "gold_sql": "SELECT T1.name ,  T1.team_id ,  max(T2.salary) FROM team AS T1 JOIN salary AS T2 ON T1.team_id  =  T2.team_id GROUP BY T1.team_id;", "source_tables": ["team", "salary"], "pred_sql": "SELECT team.name, salary.team_id, MAX(salary.salary) AS max_salary\nFROM salary\nJOIN team ON salary.team_id = team.team_id\nGROUP BY team.team_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the total salary of players from a specific team for a given year. The placeholders represent the team's name and the year for which the salary data is being queried.\"\n}\n"}
{"sample_id": "train.3658", "db_id": "baseball_1", "question": "For each team, return the team name, id and the maximum salary among the team.", "rationale": ["We need to retrieve the team name, team id, and the maximum salary for each team.", "The relevant tables for this query are 'team' and 'salary'.", "We will join the 'team' table with the 'salary' table on the 'team_id' column to associate each team with its players' salaries.", "To find the maximum salary for each team, we will use the MAX() function on the 'salary' column.", "We will group the results by 'team.team_id' and 'team.name' to ensure we get one result per team."], "gold_sql": "SELECT T1.name ,  T1.team_id ,  max(T2.salary) FROM team AS T1 JOIN salary AS T2 ON T1.team_id  =  T2.team_id GROUP BY T1.team_id;", "source_tables": ["team", "salary"], "pred_sql": "SELECT team.name, team.team_id, MAX(salary.salary) AS max_salary\nFROM team\nJOIN salary ON team.team_id = salary.team_id\nGROUP BY team.team_id, team.name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the total salary of players from a specific team for a given year. The placeholders represent the team's name and the year for which the salary data is being queried.\"\n}\n"}
{"sample_id": "train.3659", "db_id": "baseball_1", "question": "What are the name and id of the team offering the lowest average salary?", "rationale": ["Identify the relevant tables: 'team' and 'salary'.", "Join the 'team' table with the 'salary' table on 'player_id' to associate players with their respective teams.", "Group the results by 'team_id' to calculate the average salary for each team.", "Use the AVG() function to compute the average salary for each team.", "Order the results in ascending order based on the average salary to find the lowest.", "Limit the results to 1 to get only the team with the lowest average salary."], "gold_sql": "SELECT T1.name ,  T1.team_id FROM team AS T1 JOIN salary AS T2 ON T1.team_id = T2.team_id GROUP BY T1.team_id ORDER BY avg(T2.salary) ASC LIMIT 1;", "source_tables": ["team", "salary"], "pred_sql": "SELECT team.name, team.team_id\nFROM team\nJOIN salary ON team.player_id = salary.player_id\nGROUP BY team.team_id\nORDER BY AVG(salary.salary) ASC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average salary of players from a specific team in the 'salary' table. The placeholder in the WHERE clause represents the name of the team for which the average salary is being calculated.\"\n}\n"}
{"sample_id": "train.3661", "db_id": "baseball_1", "question": "Find the players' first name and last name who won award both in 1960 and in 1961.", "rationale": ["Identify the tables needed: We need the 'player' table for player names and the 'player_award' table to check for awards won by players.", "Join the 'player' table with the 'player_award' table twice: once for the year 1960 and once for the year 1961. This allows us to find players who won awards in both years.", "Use the 'WHERE' clause to filter the results to only include players who won awards in both 1960 and 1961."], "gold_sql": "SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1960 INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1961", "source_tables": ["player_award", "player"], "pred_sql": "SELECT p.name_first, p.name_last\nFROM player p\nJOIN player_award pa1 ON p.player_id = pa1.player_id\nJOIN player_award pa2 ON p.player_id = pa2.player_id\nWHERE pa1.year = 1960 AND pa2.year = 1961;", "hint": "\n"}
{"sample_id": "train.3663", "db_id": "baseball_1", "question": "List players' first name and last name who have weight greater than 220 or height shorter than 75.", "rationale": ["Identify the relevant table: The 'player' table contains the necessary columns for player names, weight, and height.", "Select the columns needed: We need 'name_given' for the first name and 'name_last' for the last name.", "Apply the conditions: We want players with a weight greater than 220 or a height shorter than 75.", "Construct the SQL query: Use SELECT to get the names from the player table with the specified conditions in the WHERE clause."], "gold_sql": "SELECT name_first ,  name_last FROM player WHERE weight  >  220 OR height  <  75", "source_tables": ["player"], "pred_sql": "SELECT name_given, name_last FROM player WHERE weight > 220 OR height < 75;", "hint": "\n"}
{"sample_id": "train.3664", "db_id": "baseball_1", "question": "What are the first name and last name of the players who have weight above 220 or height below 75?", "rationale": ["Identify the relevant table: The 'player' table contains the columns for player names, weight, and height.", "Determine the columns to select: We need the first name ('name_first') and last name ('name_last') of the players.", "Set the conditions for filtering: We want players with a weight greater than 220 or a height less than 75.", "Construct the SQL query using the SELECT statement to retrieve the specified columns from the 'player' table with the appropriate WHERE clause."], "gold_sql": "SELECT name_first ,  name_last FROM player WHERE weight  >  220 OR height  <  75", "source_tables": ["player"], "pred_sql": "SELECT name_first, name_last FROM player WHERE weight > 220 OR height < 75;", "hint": "\n"}
{"sample_id": "train.3665", "db_id": "baseball_1", "question": "List the maximum scores of the team Boston Red Stockings when the team won in postseason?", "rationale": ["Identify the team of interest: Boston Red Stockings.", "Determine the relevant table for postseason results: 'postseason'.", "We need to find the maximum scores (wins) for the team when they won in postseason.", "Use a subquery to find the team_id for 'Boston Red Stockings' from the 'team' table.", "Select the maximum wins from the 'postseason' table where the team_id_winner matches the team_id of the Boston Red Stockings."], "gold_sql": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings';", "source_tables": ["postseason", "team"], "pred_sql": "SELECT MAX(wins) AS max_scores\nFROM postseason\nWHERE team_id_winner = (SELECT team_id FROM team WHERE name = 'Boston Red Stockings')", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\"\n}\n"}
{"sample_id": "train.3666", "db_id": "baseball_1", "question": "What are the maximum scores the team Boston Red Stockings got when the team won in postseason?", "rationale": ["Identify the team of interest: Boston Red Stockings.", "Determine the relevant table for postseason results: 'postseason'.", "We need to find the maximum wins for the team when they won in the postseason.", "Use a subquery to get the team_id for 'Boston Red Stockings' from the 'team' table.", "Select the maximum wins from the 'postseason' table where the winning team matches the team_id from the subquery."], "gold_sql": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings';", "source_tables": ["postseason", "team"], "pred_sql": "SELECT MAX(wins) AS max_wins\nFROM postseason\nWHERE team_id_winner = (SELECT team_id FROM team WHERE name = 'Boston Red Stockings')", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\"\n}\n"}
