{"sample_id": "train.1109", "db_id": "match_season", "question": "Return the colleges that have players who play the Midfielder position, as well as players who play the Defender position.", "rationale": ["Identify the relevant table: The 'match_season' table contains information about players, their positions, and the colleges they attended.", "Determine the required positions: We need players who play as 'Midfielder' or 'Defender'.", "Use the WHERE clause to filter players based on their positions.", "Select the 'College' column to get the colleges of the filtered players.", "Use DISTINCT to ensure that each college is listed only once.", "Order the results by 'College' in ascending order as specified in the hint."], "gold_sql": "SELECT College FROM match_season WHERE POSITION  =  'Midfielder' INTERSECT SELECT College FROM match_season WHERE POSITION  =  'Defender'", "source_tables": ["match_season"], "pred_sql": "SELECT DISTINCT College FROM match_season WHERE Position IN ('Midfielder', 'Defender') ORDER BY College ASC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of players from the 'match_season' table, ordered by their college names in ascending order. The placeholder in the ORDER BY clause represents the college names.\"\n}\n"}
{"sample_id": "train.1222", "db_id": "apartment_rentals", "question": "What are the booking start and end dates of the apartments with type code \"Duplex\"?", "rationale": ["Identify the relevant tables: Apartment_Bookings for booking dates and Apartments for apartment type.", "Join the Apartment_Bookings table with the Apartments table on the apt_id to link bookings to their respective apartments.", "Filter the results to only include apartments with the type code 'Duplex'.", "Select the booking_start_date and booking_end_date from the filtered results."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.apt_type_code  =  'Duplex'", "source_tables": ["apartment_bookings", "apartments"], "pred_sql": "SELECT ab.booking_start_date, ab.booking_end_date \nFROM Apartment_Bookings ab \nJOIN Apartments a ON ab.apt_id = a.apt_id \nWHERE a.apt_type_code = 'Duplex';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the start dates of apartment bookings along with the corresponding booking end dates for guests filtered by a specific gender. The placeholders in the WHERE clause represent the gender code of the guests.\",\n    \"1\": \"This virtual table provides the start dates of apartment bookings from the 'Apartment_Bookings' table for apartments of a specific type. The placeholder in the WHERE clause represents the apartment type code.\",\n    \"2\": \"This virtual table provides information about apartment bookings, specifically the apartment number and the start date of the booking. The placeholders in the query allow for filtering or additional conditions to be applied as needed.\"\n}\n"}
{"sample_id": "train.1224", "db_id": "apartment_rentals", "question": "What are the booking start and end dates of the apartments with more than 2 bedrooms?", "rationale": ["Identify the relevant tables: Apartment_Bookings for booking dates and Apartments for bedroom count.", "Join the Apartment_Bookings table with the Apartments table on the apt_id to access both booking dates and bedroom count.", "Filter the results to include only those apartments that have more than 2 bedrooms using the WHERE clause."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  2", "source_tables": ["apartment_bookings", "apartments"], "pred_sql": "SELECT ab.booking_start_date, ab.booking_end_date \nFROM Apartment_Bookings ab \nJOIN Apartments a ON ab.apt_id = a.apt_id \nWHERE a.bedroom_count > 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the start dates of apartment bookings along with the corresponding booking end dates for guests filtered by a specific gender. The placeholders in the WHERE clause represent the gender code of the guests.\",\n    \"1\": \"This virtual table provides information about apartment bookings, specifically the apartment number and the start date of the booking. The placeholders in the query allow for filtering or additional conditions to be applied as needed.\",\n    \"2\": \"This virtual table provides the start dates of apartment bookings from the 'Apartment_Bookings' table for apartments of a specific type. The placeholder in the WHERE clause represents the apartment type code.\"\n}\n"}
{"sample_id": "train.1225", "db_id": "apartment_rentals", "question": "Find the booking start date and end date for the apartments that have more than two bedrooms.", "rationale": ["Identify the relevant tables: Apartment_Bookings for booking dates and Apartments for bedroom count.", "Join the Apartment_Bookings table with the Apartments table on the apt_id to access both booking dates and bedroom count.", "Filter the results to include only those apartments that have more than two bedrooms by using the condition 'a.bedroom_count > 2'.", "Select the booking start date and end date from the filtered results."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  2", "source_tables": ["apartment_bookings", "apartments"], "pred_sql": "SELECT ab.booking_start_date, ab.booking_end_date \nFROM Apartment_Bookings ab \nJOIN Apartments a ON ab.apt_id = a.apt_id \nWHERE a.bedroom_count > 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the start dates of apartment bookings along with the corresponding booking end dates for guests filtered by a specific gender. The placeholders in the WHERE clause represent the gender code of the guests.\",\n    \"1\": \"This virtual table provides information about apartment bookings, specifically the apartment number and the start date of the booking. The placeholders in the query allow for filtering or additional conditions to be applied as needed.\",\n    \"2\": \"This virtual table provides the start dates of apartment bookings from the 'Apartment_Bookings' table for apartments of a specific type. The placeholder in the WHERE clause represents the apartment type code.\"\n}\n"}
{"sample_id": "train.1229", "db_id": "apartment_rentals", "question": "Which apartments have bookings with status code \"Confirmed\"? Return their apartment numbers.", "rationale": ["Identify the relevant tables: We need information from the Apartments and Apartment_Bookings tables.", "Determine the relationship: The Apartments table is linked to the Apartment_Bookings table through the apt_id column.", "Select the required fields: We need to return the apartment numbers, which are in the Apartments table under the apt_number column.", "Apply the filter: We need to filter the bookings to only include those with a status code of 'Confirmed'.", "Construct the SQL query: Using a JOIN to connect the two tables and applying the WHERE clause for the status code."], "gold_sql": "SELECT DISTINCT T2.apt_number FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T1.booking_status_code  =  'Confirmed'", "source_tables": ["apartment_bookings", "apartments"], "pred_sql": "SELECT a.apt_number \nFROM Apartments a \nJOIN Apartment_Bookings ab ON a.apt_id = ab.apt_id \nWHERE ab.booking_status_code = 'Confirmed';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides information about apartment bookings, specifically the apartment number and the start date of the booking. The placeholders in the query allow for filtering or additional conditions to be applied as needed.\",\n    \"1\": \"This virtual table lists the facility codes of apartments that have a specified number of bedrooms. The placeholder in the WHERE clause represents the minimum number of bedrooms required for the apartments.\",\n    \"2\": \"This virtual table provides a list of apartment numbers along with their corresponding booking start dates from the 'Apartment_Bookings' and 'Apartments' tables. The placeholders in the query represent the identifiers linking the bookings to the apartments.\"\n}\n"}
{"sample_id": "train.1232", "db_id": "apartment_rentals", "question": "Show the guest first names, start dates, and end dates of all the apartment bookings.", "rationale": ["Identify the required fields: guest first names, booking start dates, and booking end dates.", "Determine the relevant tables: Guests for guest information and Apartment_Bookings for booking details.", "Establish the relationship between the tables: Guests are linked to Apartment_Bookings through guest_id.", "Construct the SQL SELECT statement to retrieve the desired fields from the joined tables."], "gold_sql": "SELECT T2.guest_first_name ,  T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id", "source_tables": ["apartment_bookings", "guests"], "pred_sql": "SELECT Guests.guest_first_name, Apartment_Bookings.booking_start_date, Apartment_Bookings.booking_end_date\nFROM Apartment_Bookings\nJOIN Guests ON Apartment_Bookings.guest_id = Guests.guest_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first names of guests along with the start dates of their apartment bookings. The placeholders in the query allow for filtering or additional conditions to be applied as needed.\",\n    \"1\": \"This virtual table provides the start dates of apartment bookings along with the corresponding booking end dates for guests filtered by a specific gender. The placeholders in the WHERE clause represent the gender code of the guests.\",\n    \"2\": \"This virtual table provides information about apartment bookings, specifically the apartment number and the start date of the booking. The placeholders in the query allow for filtering or additional conditions to be applied as needed.\"\n}\n"}
{"sample_id": "train.1234", "db_id": "apartment_rentals", "question": "Show the start dates and end dates of all the apartment bookings made by guests with gender code \"Female\".", "rationale": ["Identify the tables involved: Apartment_Bookings for booking dates and Guests for gender information.", "Determine the columns needed: booking_start_date and booking_end_date from Apartment_Bookings.", "Establish the relationship between the tables: Join Apartment_Bookings with Guests on guest_id.", "Apply the filter for gender: Include a WHERE clause to filter guests by gender code 'Female'."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id WHERE T2.gender_code  =  'Female'", "source_tables": ["apartment_bookings", "guests"], "pred_sql": "SELECT Apartment_Bookings.booking_start_date, Apartment_Bookings.booking_end_date \nFROM Apartment_Bookings \nJOIN Guests ON Apartment_Bookings.guest_id = Guests.guest_id \nWHERE Guests.gender_code = 'Female';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the start dates of apartment bookings along with the corresponding booking end dates for guests filtered by a specific gender. The placeholders in the WHERE clause represent the gender code of the guests.\",\n    \"1\": \"This virtual table provides the first names of guests along with the start dates of their apartment bookings. The placeholders in the query allow for filtering or additional conditions to be applied as needed.\",\n    \"2\": \"This virtual table provides information about apartment bookings, specifically the apartment number and the start date of the booking. The placeholders in the query allow for filtering or additional conditions to be applied as needed.\"\n}\n"}
{"sample_id": "train.1238", "db_id": "apartment_rentals", "question": "Show the facility codes of apartments with more than 4 bedrooms.", "rationale": ["Identify the relevant tables: Apartment_Facilities for facility codes and Apartments for bedroom counts.", "Join the Apartment_Facilities table with the Apartments table on the apt_id to link facilities to their respective apartments.", "Filter the results to include only those apartments that have more than 4 bedrooms using the WHERE clause."], "gold_sql": "SELECT T1.facility_code FROM Apartment_Facilities AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  4", "source_tables": ["apartments", "apartment_facilities"], "pred_sql": "SELECT DISTINCT af.facility_code \nFROM Apartment_Facilities af \nJOIN Apartments a ON af.apt_id = a.apt_id \nWHERE a.bedroom_count > 4;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the facility codes of apartments that have a specified number of bedrooms. The placeholder in the WHERE clause represents the minimum number of bedrooms required for the apartments.\",\n    \"1\": \"This virtual table provides information about apartment bookings, specifically the apartment number and the start date of the booking. The placeholders in the query allow for filtering or additional conditions to be applied as needed.\",\n    \"2\": \"This virtual table provides the start dates of apartment bookings along with the corresponding booking end dates for guests filtered by a specific gender. The placeholders in the WHERE clause represent the gender code of the guests.\"\n}\n"}
{"sample_id": "train.1256", "db_id": "apartment_rentals", "question": "Show the top 3 apartment type codes sorted by the average number of rooms in descending order.", "rationale": ["Identify the relevant table: The Apartments table contains the apt_type_code and room_count columns needed for the query.", "Calculate the average number of rooms: Use the AVG() function to compute the average number of rooms for each apartment type code.", "Group the results: Use GROUP BY to group the results by apt_type_code so that the average can be calculated for each type.", "Sort the results: Use ORDER BY to sort the results in descending order based on the average number of rooms.", "Limit the results: Use LIMIT to restrict the output to the top 3 apartment type codes."], "gold_sql": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY avg(room_count) DESC LIMIT 3", "source_tables": ["apartments"], "pred_sql": "SELECT apt_type_code, AVG(room_count) AS average_rooms\nFROM Apartments\nGROUP BY apt_type_code\nORDER BY average_rooms DESC\nLIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the facility codes of apartments that have a specified number of bedrooms. The placeholder in the WHERE clause represents the minimum number of bedrooms required for the apartments.\",\n    \"1\": \"This virtual table provides information about apartment bookings, specifically the apartment number and the start date of the booking. The placeholders in the query allow for filtering or additional conditions to be applied as needed.\",\n    \"2\": \"This virtual table provides the start dates of apartment bookings from the 'Apartment_Bookings' table for apartments of a specific type. The placeholder in the WHERE clause represents the apartment type code.\"\n}\n"}
{"sample_id": "train.1258", "db_id": "apartment_rentals", "question": "Show the apartment type code that has the largest number of total rooms, together with the number of bathrooms and number of bedrooms.", "rationale": ["Identify the relevant columns needed: apt_type_code, room_count, bathroom_count, and bedroom_count from the Apartments table.", "To find the apartment type code with the largest number of total rooms, we will use the MAX function on room_count.", "We need to group the results by apt_type_code to get the maximum room count for each type.", "We will order the results in descending order based on the maximum room count to get the highest value at the top.", "Finally, we will limit the results to 1 to get only the apartment type code with the largest number of total rooms."], "gold_sql": "SELECT apt_type_code ,  bathroom_count ,  bedroom_count FROM Apartments GROUP BY apt_type_code ORDER BY sum(room_count) DESC LIMIT 1", "source_tables": ["apartments"], "pred_sql": "SELECT apt_type_code, MAX(room_count) AS max_rooms, bathroom_count, bedroom_count \nFROM Apartments \nGROUP BY apt_type_code \nORDER BY max_rooms DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the facility codes of apartments that have a specified number of bedrooms. The placeholder in the WHERE clause represents the minimum number of bedrooms required for the apartments.\",\n    \"1\": \"This virtual table provides information about apartment bookings, specifically the apartment number and the start date of the booking. The placeholders in the query allow for filtering or additional conditions to be applied as needed.\",\n    \"2\": \"This virtual table provides the start dates of apartment bookings along with the corresponding booking end dates for guests filtered by a specific gender. The placeholders in the WHERE clause represent the gender code of the guests.\"\n}\n"}
{"sample_id": "train.1261", "db_id": "apartment_rentals", "question": "Which apartment type code appears the most often?", "rationale": ["Identify the relevant table: The Apartments table contains the apt_type_code which we need to analyze.", "Count occurrences: We need to count how many times each apt_type_code appears in the Apartments table.", "Group by apt_type_code: To get the count for each type, we will group the results by apt_type_code.", "Order by count: We will order the results in descending order based on the count of each apt_type_code to find the most frequent one.", "Limit the results: Since we only want the most frequent type code, we will limit the results to 1."], "gold_sql": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["apartments"], "pred_sql": "SELECT apt_type_code, COUNT(*) as type_count \nFROM Apartments \nGROUP BY apt_type_code \nORDER BY type_count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the facility codes of apartments that have a specified number of bedrooms. The placeholder in the WHERE clause represents the minimum number of bedrooms required for the apartments.\",\n    \"1\": \"This virtual table provides information about apartment bookings, specifically the apartment number and the start date of the booking. The placeholders in the query allow for filtering or additional conditions to be applied as needed.\",\n    \"2\": \"This virtual table provides the start dates of apartment bookings from the 'Apartment_Bookings' table for apartments of a specific type. The placeholder in the WHERE clause represents the apartment type code.\"\n}\n"}
{"sample_id": "train.1262", "db_id": "apartment_rentals", "question": "Show the most common apartment type code among apartments with more than 1 bathroom.", "rationale": ["Identify the relevant table: The Apartments table contains the apartment type code and the number of bathrooms.", "Filter apartments: We need to filter apartments that have more than 1 bathroom, which is done using the WHERE clause: bathroom_count > 1.", "Group by apartment type: To find the most common apartment type, we will group the results by apt_type_code.", "Count occurrences: We will count the number of apartments for each apartment type using COUNT(*).", "Order results: To find the most common type, we will order the results in descending order based on the count.", "Limit results: Finally, we will limit the results to 1 to get the most common apartment type code."], "gold_sql": "SELECT apt_type_code FROM Apartments WHERE bathroom_count  >  1 GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["apartments"], "pred_sql": "SELECT apt_type_code, COUNT(*) as count\nFROM Apartments\nWHERE bathroom_count > 1\nGROUP BY apt_type_code\nORDER BY count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the facility codes of apartments that have a specified number of bedrooms. The placeholder in the WHERE clause represents the minimum number of bedrooms required for the apartments.\",\n    \"1\": \"This virtual table provides the start dates of apartment bookings along with the corresponding booking end dates for guests filtered by a specific gender. The placeholders in the WHERE clause represent the gender code of the guests.\",\n    \"2\": \"This virtual table provides the start dates of apartment bookings from the 'Apartment_Bookings' table for apartments of a specific type. The placeholder in the WHERE clause represents the apartment type code.\"\n}\n"}
{"sample_id": "train.1272", "db_id": "apartment_rentals", "question": "Show the apartment numbers of apartments with unit status availability of both 0 and 1.", "rationale": ["Identify the relevant tables: Apartments and View_Unit_Status are needed to get apartment numbers and their availability status.", "Join the Apartments table with the View_Unit_Status table on the apt_id to link apartments with their availability status.", "Filter the results to include only those apartments where the availability status is either '0' or '1', as specified in the query."], "gold_sql": "SELECT T1.apt_number FROM Apartments AS T1 JOIN View_Unit_Status AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.available_yn  =  0 INTERSECT SELECT T1.apt_number FROM Apartments AS T1 JOIN View_Unit_Status AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.available_yn  =  1", "source_tables": ["view_unit_status", "apartments"], "pred_sql": "SELECT a.apt_number \nFROM Apartments a \nJOIN View_Unit_Status vus ON a.apt_id = vus.apt_id \nWHERE vus.available_yn IN ('0', '1');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the facility codes of apartments that have a specified number of bedrooms. The placeholder in the WHERE clause represents the minimum number of bedrooms required for the apartments.\",\n    \"1\": \"This virtual table provides information about apartment bookings, specifically the apartment number and the start date of the booking. The placeholders in the query allow for filtering or additional conditions to be applied as needed.\",\n    \"2\": \"This virtual table provides a list of apartment numbers along with their corresponding booking start dates from the 'Apartment_Bookings' and 'Apartments' tables. The placeholders in the query represent the identifiers linking the bookings to the apartments.\"\n}\n"}
{"sample_id": "train.1294", "db_id": "soccer_1", "question": "How many leagues are there in England?", "rationale": ["Identify the relevant table: The question pertains to leagues, so we will use the 'League' table.", "Determine the condition: We need to filter the leagues to only those in England.", "Construct the SQL query: We will use the COUNT function to count the number of leagues that match the condition."], "gold_sql": "SELECT count(*) FROM Country AS T1 JOIN League AS T2 ON T1.id  =  T2.country_id WHERE T1.name  =  'England'", "source_tables": ["country", "league"], "pred_sql": "SELECT COUNT(*) AS league_count FROM League WHERE name = 'England';", "hint": "\n"}
{"sample_id": "train.1303", "db_id": "soccer_1", "question": "List all of the player ids with a height of at least 180cm and an overall rating higher than 85.", "rationale": ["Identify the relevant tables: Player and Player_Attributes.", "Determine the columns needed: Player.id for player IDs, Player.height for height, and Player_Attributes.overall_rating for overall rating.", "Set the conditions: height must be at least 180 cm and overall rating must be higher than 85.", "Join the Player table with Player_Attributes on the player_api_id to combine player information with their attributes.", "Construct the SQL SELECT statement to retrieve the player IDs that meet the specified conditions."], "gold_sql": "SELECT player_api_id FROM Player WHERE height  >=  180 INTERSECT SELECT player_api_id FROM Player_Attributes WHERE overall_rating  >  85", "source_tables": ["player_attributes", "player"], "pred_sql": "SELECT Player.id \nFROM Player \nJOIN Player_Attributes ON Player.player_api_id = Player_Attributes.player_api_id \nWHERE Player.height >= 180 AND Player_Attributes.overall_rating > 85;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique player names from the 'Player' table, joined with their corresponding attributes from the 'Player_Attributes' table. The results are ordered by the players' overall skill ratings in descending order, and the number of results returned is limited by a specified placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.1304", "db_id": "soccer_1", "question": "List all of the ids for left-footed players with a height between 180cm and 190cm.", "rationale": ["Identify the relevant tables: Player and Player_Attributes.", "We need to select the 'id' from the Player table.", "We need to join Player with Player_Attributes on the common column 'player_api_id'.", "Filter the results to include only left-footed players by checking 'preferred_foot' in Player_Attributes.", "Filter the players based on height, ensuring it is between 180cm and 190cm."], "gold_sql": "SELECT player_api_id FROM Player WHERE height  >=  180 AND height  <=  190 INTERSECT SELECT player_api_id FROM Player_Attributes WHERE preferred_foot  =  'left'", "source_tables": ["player_attributes", "player"], "pred_sql": "SELECT Player.id FROM Player JOIN Player_Attributes ON Player.player_api_id = Player_Attributes.player_api_id WHERE Player.height BETWEEN 180 AND 190 AND Player_Attributes.preferred_foot = 'left';", "hint": "\n"}
{"sample_id": "train.1306", "db_id": "soccer_1", "question": "List the names and birthdays of the top five players in terms of potential.", "rationale": ["Identify the relevant tables: Player and Player_Attributes.", "We need to retrieve player names and birthdays, which are in the Player table.", "The potential attribute is in the Player_Attributes table, so we need to join these two tables on player_api_id.", "Use an ORDER BY clause to sort the results by potential in descending order to get the top players.", "Limit the results to the top five players using LIMIT 5."], "gold_sql": "SELECT DISTINCT T1.player_name ,  T1.birthday FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id  =  T2.player_api_id ORDER BY potential DESC LIMIT 5", "source_tables": ["player_attributes", "player"], "pred_sql": "SELECT player_name, birthday \nFROM Player \nJOIN Player_Attributes ON Player.player_api_id = Player_Attributes.player_api_id \nORDER BY potential DESC \nLIMIT 5;", "hint": "\n"}
{"sample_id": "train.1511", "db_id": "insurance_and_eClaims", "question": "Which type of policy is most frequently used? Give me the policy type code.", "rationale": ["Identify the relevant table: The question asks about policy types, so we will focus on the Policies table.", "Determine the required columns: We need the Policy_Type_Code and a count of how many times each type is used.", "Use the COUNT function: This will allow us to count the occurrences of each Policy_Type_Code.", "Group the results: We will group the results by Policy_Type_Code to get the frequency of each type.", "Order the results: To find the most frequently used policy type, we will order the results by the frequency in descending order.", "Limit the results: Since we only want the most frequently used policy type, we will limit the results to 1."], "gold_sql": "SELECT policy_type_code FROM policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["policies"], "pred_sql": "SELECT Policy_Type_Code, COUNT(*) AS Frequency\nFROM Policies\nGROUP BY Policy_Type_Code\nORDER BY Frequency DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.1513", "db_id": "insurance_and_eClaims", "question": "Find all the policy types that are used by more than 2 customers.", "rationale": ["We need to find policy types used by more than 2 customers.", "First, we will identify the customers who have policies. We can do this by selecting Customer_ID from the Policies table and grouping by Customer_ID.", "Next, we will use the HAVING clause to filter those groups to only include customers that have more than 2 policies.", "After identifying the customers, we will select the Policy_Type_Code from the Policies table where the Customer_ID is in the list of customers identified in the previous step.", "Finally, we will group the results by Policy_Type_Code to get the distinct policy types used by more than 2 customers."], "gold_sql": "SELECT policy_type_code FROM policies GROUP BY policy_type_code HAVING count(*)  >  2", "source_tables": ["policies"], "pred_sql": "SELECT Policy_Type_Code\nFROM Policies\nWHERE Customer_ID IN (\n    SELECT Customer_ID\n    FROM Policies\n    GROUP BY Customer_ID\n    HAVING COUNT(DISTINCT Customer_ID) > 2\n)\nGROUP BY Policy_Type_Code;", "hint": "\n"}
{"sample_id": "train.1516", "db_id": "insurance_and_eClaims", "question": "What are the total amount and average amount paid in claim headers?", "rationale": ["Identify the relevant table: Claim_Headers contains the information about claims, including the amounts paid.", "Determine the required calculations: We need to calculate the total amount paid and the average amount paid.", "Use the SUM function to calculate the total amount paid from the Amount_Paid column.", "Use the AVG function to calculate the average amount paid from the Amount_Paid column.", "Construct the SQL query to select the total and average amounts from the Claim_Headers table."], "gold_sql": "SELECT sum(amount_piad) ,  avg(amount_piad) FROM claim_headers", "source_tables": ["claim_headers"], "pred_sql": "SELECT SUM(Amount_Paid) AS Total_Amount_Paid, AVG(Amount_Paid) AS Average_Amount_Paid FROM Claim_Headers;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total and average amounts paid for claims from the 'Claim_Headers' table. The placeholders in the SELECT clause represent the total and average of the 'amount_paid' column.\"\n}\n"}
{"sample_id": "train.1518", "db_id": "insurance_and_eClaims", "question": "How much amount in total were claimed in the most recently created document?", "rationale": ["Identify the relevant tables: Claim_Headers for the amounts claimed and Claims_Documents for the document creation date.", "We need to sum the 'Amount_Claimed' from the Claim_Headers table.", "Join Claim_Headers with Claims_Documents on the Claim_ID to link claims with their documents.", "Filter the results to only include claims associated with the most recently created document by using a subquery to find the maximum 'Created_Date' in Claims_Documents."], "gold_sql": "SELECT sum(t1.amount_claimed) FROM claim_headers AS t1 JOIN claims_documents AS t2 ON t1.claim_header_id  =  t2.claim_id WHERE t2.created_date  =  (SELECT created_date FROM claims_documents ORDER BY created_date LIMIT 1)", "source_tables": ["claims_documents", "claim_headers"], "pred_sql": "SELECT SUM(ch.Amount_Claimed) AS Total_Claimed\nFROM Claim_Headers ch\nJOIN Claims_Documents cd ON ch.Claim_Header_ID = cd.Claim_ID\nWHERE cd.Created_Date = (SELECT MAX(Created_Date) FROM Claims_Documents);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total and average amounts paid for claims from the 'Claim_Headers' table. The placeholders in the SELECT clause represent the total and average of the 'amount_paid' column.\"\n}\n"}
{"sample_id": "train.1519", "db_id": "insurance_and_eClaims", "question": "What is the name of the customer who has made the largest amount of claim in a single claim?", "rationale": ["Identify the relevant tables: Customers, Policies, and Claim_Headers are needed to find the customer details and their claims.", "Join the Customers table with the Policies table on Customer_ID to link customers to their policies.", "Join the resulting table with the Claim_Headers table on Policy_ID to access claim details for each customer.", "Order the results by the Amount_Claimed in descending order to find the largest claim.", "Limit the results to 1 to get only the customer with the largest claim."], "gold_sql": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_claimed  =  (SELECT max(amount_claimed) FROM claim_headers)", "source_tables": ["policies", "customers", "claim_headers"], "pred_sql": "SELECT c.Customer_Details \nFROM Customers c \nJOIN Policies p ON c.Customer_ID = p.Customer_ID \nJOIN Claim_Headers ch ON p.Policy_ID = ch.Policy_ID \nORDER BY ch.Amount_Claimed DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total and average amounts paid for claims from the 'Claim_Headers' table. The placeholders in the SELECT clause represent the total and average of the 'amount_paid' column.\"\n}\n"}
{"sample_id": "train.1521", "db_id": "insurance_and_eClaims", "question": "What is the name of the customer who has made the minimum amount of payment in one claim?", "rationale": ["Identify the relevant tables: Customers, Policies, and Claim_Headers are needed to find the customer details and their claims.", "Join the Customers table with the Policies table on Customer_ID to link customers to their policies.", "Join the resulting table with the Claim_Headers table on Policy_ID to access claim information related to each customer.", "Use a subquery to find the minimum Amount_Paid from the Claim_Headers table.", "Filter the results to only include the customer(s) who have made a claim with the minimum Amount_Paid."], "gold_sql": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)", "source_tables": ["policies", "customers", "claim_headers"], "pred_sql": "SELECT c.Customer_Details\nFROM Customers c\nJOIN Policies p ON c.Customer_ID = p.Customer_ID\nJOIN Claim_Headers ch ON p.Policy_ID = ch.Policy_ID\nWHERE ch.Amount_Paid = (\n    SELECT MIN(Amount_Paid)\n    FROM Claim_Headers\n);\n", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total and average amounts paid for claims from the 'Claim_Headers' table. The placeholders in the SELECT clause represent the total and average of the 'amount_paid' column.\"\n}\n"}
{"sample_id": "train.1531", "db_id": "insurance_and_eClaims", "question": "Find the names of the customers who have an deputy policy.", "rationale": ["Identify the relevant tables: Customers and Policies.", "Determine the relationship between the tables: Customers are linked to Policies through Customer_ID.", "Select the Customer_Details from the Customers table.", "Filter the results to include only those policies with a Policy_Type_Code of 'deputy'."], "gold_sql": "SELECT DISTINCT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.policy_type_code  =  'Deputy'", "source_tables": ["policies", "customers"], "pred_sql": "SELECT Customers.Customer_Details \nFROM Customers \nJOIN Policies ON Customers.Customer_ID = Policies.Customer_ID \nWHERE Policies.Policy_Type_Code = 'deputy';", "hint": "\n"}
{"sample_id": "train.1533", "db_id": "insurance_and_eClaims", "question": "Find the names of customers who either have an deputy policy or uniformed policy.", "rationale": ["Identify the relevant tables: Customers and Policies.", "Determine the relationship between the tables: Customers are linked to Policies through Customer_ID.", "Select the Customer_Details from the Customers table.", "Filter the results based on the Policy_Type_Code in the Policies table, specifically looking for 'deputy' or 'uniformed' policies.", "Use DISTINCT to ensure that each customer's name appears only once in the results."], "gold_sql": "SELECT DISTINCT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.policy_type_code  =  'Deputy' OR t1.policy_type_code  =  'Uniform'", "source_tables": ["policies", "customers"], "pred_sql": "SELECT DISTINCT c.Customer_Details \nFROM Customers c \nJOIN Policies p ON c.Customer_ID = p.Customer_ID \nWHERE p.Policy_Type_Code IN ('deputy', 'uniformed');", "hint": "\n"}
{"sample_id": "train.1546", "db_id": "insurance_and_eClaims", "question": "Find the customer who started a policy most recently.", "rationale": ["Identify the relevant tables: Customers and Policies.", "We need to find the customer who started a policy most recently, so we will join the Customers table with the Policies table on the Customer_ID.", "We will order the results by the Start_Date of the policies in descending order to get the most recent policy first.", "Finally, we will limit the results to 1 to get only the most recent customer."], "gold_sql": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)", "source_tables": ["policies", "customers"], "pred_sql": "SELECT Customers.Customer_ID, Customers.Customer_Details \nFROM Customers \nJOIN Policies ON Customers.Customer_ID = Policies.Customer_ID \nORDER BY Policies.Start_Date DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.1553", "db_id": "customers_and_invoices", "question": "Show the id, the account name, and other account details for all accounts by the customer with first name 'Meaghan'.", "rationale": ["Identify the relevant tables: Accounts and Customers.", "Determine the columns needed: account_id, account_name, and other_account_details from Accounts.", "Join the Accounts table with the Customers table on customer_id to filter accounts by customer.", "Apply a WHERE clause to filter for customers with the first name 'Meaghan'."], "gold_sql": "SELECT T1.account_id ,  T1.date_account_opened ,  T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  'Meaghan'", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT a.account_id, a.account_name, a.other_account_details \nFROM Accounts a \nJOIN Customers c ON a.customer_id = c.customer_id \nWHERE c.customer_first_name = 'Meaghan';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of unique customers who have opened accounts in the 'Accounts' table. The placeholder in the SELECT statement allows for potential filtering or additional conditions to be applied if needed.\",\n    \"1\": \"This virtual table provides a count of financial transactions grouped by account ID from the 'Financial_Transactions' table. The placeholder in the SELECT clause represents the account ID for which the transaction count is being retrieved.\"\n}\n"}
{"sample_id": "train.1556", "db_id": "customers_and_invoices", "question": "What are the names and other details for accounts corresponding to the customer named Meaghan Keeling?", "rationale": ["Identify the relevant tables: Accounts and Customers.", "Determine the relationship between the tables: Accounts has a foreign key customer_id that references Customers.", "Select the fields needed: account_name and other_account_details from Accounts.", "Filter the results based on the customer's name: Meaghan Keeling.", "Construct the SQL query using JOIN to combine the two tables based on the customer_id."], "gold_sql": "SELECT T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  'Meaghan' AND T2.customer_last_name  =  'Keeling'", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT a.account_name, a.other_account_details \nFROM Accounts a \nJOIN Customers c ON a.customer_id = c.customer_id \nWHERE c.customer_first_name = 'Meaghan' AND c.customer_last_name = 'Keeling';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of unique customers who have opened accounts in the 'Accounts' table. The placeholder in the SELECT statement allows for potential filtering or additional conditions to be applied if needed.\"\n}\n"}
{"sample_id": "train.1558", "db_id": "customers_and_invoices", "question": "What are the full names of customers with the account name 900?", "rationale": ["Identify the relevant tables: Customers and Accounts.", "Determine the columns needed: full names (first and last) from Customers and account name from Accounts.", "Join the Customers table with the Accounts table on the customer_id field to link customers with their accounts.", "Filter the results to include only those accounts with the name '900'.", "Select the concatenated first and last names as the full name."], "gold_sql": "SELECT T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T1.account_name  =  '900'", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT customer_first_name || ' ' || customer_last_name AS full_name\nFROM Customers\nJOIN Accounts ON Customers.customer_id = Accounts.customer_id\nWHERE Accounts.account_name = '900';", "hint": "\n"}
{"sample_id": "train.1568", "db_id": "customers_and_invoices", "question": "Return the id and full name of the customer with the most accounts.", "rationale": ["Identify the goal: We need to find the customer with the most accounts.", "To achieve this, we will first count the number of accounts for each customer in the 'Accounts' table.", "We will group the results by 'customer_id' and order them in descending order based on the count of accounts.", "We will limit the results to the top customer (the one with the most accounts).", "Next, we will retrieve the 'customer_id' and the full name (concatenation of first and last name) from the 'Customers' table for the customer identified in the previous step.", "The final SQL query will combine these steps to return the desired result."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT customer_id, customer_first_name || ' ' || customer_last_name AS full_name\nFROM Customers\nWHERE customer_id IN (\n    SELECT customer_id\n    FROM Accounts\n    GROUP BY customer_id\n    ORDER BY COUNT(account_id) DESC\n    LIMIT 1\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of unique customers who have opened accounts in the 'Accounts' table. The placeholder in the SELECT statement allows for potential filtering or additional conditions to be applied if needed.\"\n}\n"}
{"sample_id": "train.1579", "db_id": "customers_and_invoices", "question": "How many transaction does each account have? Show the number and account id.", "rationale": ["We need to count the number of transactions for each account, which involves the 'Financial_Transactions' table.", "The 'Financial_Transactions' table contains a column 'account_id' that links each transaction to an account.", "To get the count of transactions per account, we will use the COUNT() function on 'transaction_id'.", "We will group the results by 'account_id' to get the count for each account.", "The final SQL query will select the 'account_id' and the count of transactions, aliased as 'transaction_count'."], "gold_sql": "SELECT count(*) ,  account_id FROM Financial_transactions", "source_tables": ["financial_transactions"], "pred_sql": "SELECT account_id, COUNT(transaction_id) AS transaction_count\nFROM Financial_Transactions\nGROUP BY account_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of financial transactions grouped by account ID from the 'Financial_Transactions' table. The placeholder in the SELECT clause represents the account ID for which the transaction count is being retrieved.\",\n    \"1\": \"This virtual table provides the count of unique customers who have opened accounts in the 'Accounts' table. The placeholder in the SELECT statement allows for potential filtering or additional conditions to be applied if needed.\"\n}\n"}
{"sample_id": "train.1589", "db_id": "customers_and_invoices", "question": "Show the account name, id and the number of transactions for each account.", "rationale": ["We need to retrieve the account name and account ID from the Accounts table.", "We also need to count the number of transactions associated with each account from the Financial_Transactions table.", "To achieve this, we will perform a LEFT JOIN between the Accounts table and the Financial_Transactions table on the account_id.", "We will use the COUNT function to count the transaction IDs for each account.", "Finally, we will group the results by account_id and account_name to get the count for each account."], "gold_sql": "SELECT T2.account_name ,  T1.account_id ,  count(*) FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id GROUP BY T1.account_id", "source_tables": ["accounts", "financial_transactions"], "pred_sql": "SELECT a.account_name, a.account_id, COUNT(ft.transaction_id) AS number_of_transactions\nFROM Accounts a\nLEFT JOIN Financial_Transactions ft ON a.account_id = ft.account_id\nGROUP BY a.account_id, a.account_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of financial transactions grouped by account ID from the 'Financial_Transactions' table. The placeholder in the SELECT clause represents the account ID for which the transaction count is being retrieved.\",\n    \"1\": \"This virtual table provides the count of unique customers who have opened accounts in the 'Accounts' table. The placeholder in the SELECT statement allows for potential filtering or additional conditions to be applied if needed.\"\n}\n"}
{"sample_id": "train.1599", "db_id": "customers_and_invoices", "question": "Show the invoice number and the number of transactions for each invoice.", "rationale": ["We need to retrieve the invoice number and the number of transactions for each invoice.", "The 'Invoices' table contains the invoice numbers, so we will select 'invoice_number' from this table.", "The 'Financial_Transactions' table contains the transactions related to invoices, so we will join this table with 'Invoices' on the 'invoice_number'.", "To count the number of transactions for each invoice, we will use the COUNT() function on 'transaction_id' from the 'Financial_Transactions' table.", "We will group the results by 'invoice_number' to get the count of transactions for each invoice."], "gold_sql": "SELECT invoice_number ,  count(*) FROM Financial_transactions GROUP BY invoice_number", "source_tables": ["financial_transactions"], "pred_sql": "SELECT i.invoice_number, COUNT(ft.transaction_id) AS number_of_transactions\nFROM Invoices i\nLEFT JOIN Financial_Transactions ft ON i.invoice_number = ft.invoice_number\nGROUP BY i.invoice_number;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of financial transactions grouped by account ID from the 'Financial_Transactions' table. The placeholder in the SELECT clause represents the account ID for which the transaction count is being retrieved.\",\n    \"1\": \"This virtual table provides the count of unique customers who have opened accounts in the 'Accounts' table. The placeholder in the SELECT statement allows for potential filtering or additional conditions to be applied if needed.\"\n}\n"}
{"sample_id": "train.1602", "db_id": "customers_and_invoices", "question": "What is the invoice number and invoice date corresponding to the invoice with the greatest number of transactions?", "rationale": ["We need to find the invoice number and invoice date for the invoice with the greatest number of transactions.", "To do this, we will first count the number of transactions for each invoice in the Financial_Transactions table.", "We will group the results by invoice_number and order them in descending order based on the count of transactions.", "We will limit the results to only the top result, which will give us the invoice with the greatest number of transactions.", "Next, we will join this result with the Invoices table to get the corresponding invoice number and date.", "Finally, we will select the invoice_number and invoice_date from the joined result."], "gold_sql": "SELECT T2.invoice_number ,  T2.invoice_date FROM Financial_transactions AS T1 JOIN Invoices AS T2 ON T1.invoice_number  =  T2.invoice_number GROUP BY T1.invoice_number ORDER BY count(*) DESC LIMIT 1", "source_tables": ["invoices", "financial_transactions"], "pred_sql": "SELECT Invoices.invoice_number, Invoices.invoice_date \nFROM Invoices \nJOIN (SELECT invoice_number, COUNT(*) as transaction_count \n      FROM Financial_Transactions \n      GROUP BY invoice_number \n      ORDER BY transaction_count DESC \n      LIMIT 1) as TransactionCounts \nON Invoices.invoice_number = TransactionCounts.invoice_number;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of financial transactions grouped by account ID from the 'Financial_Transactions' table. The placeholder in the SELECT clause represents the account ID for which the transaction count is being retrieved.\"\n}\n"}
{"sample_id": "train.1617", "db_id": "customers_and_invoices", "question": "Show the order ids and the number of items in each order.", "rationale": ["Identify the tables needed: We need data from the Orders table for order ids and the Order_Items table to count the number of items in each order.", "Use a LEFT JOIN to combine Orders and Order_Items on the order_id, ensuring we include all orders even if they have no items.", "Use COUNT() to count the number of items in each order, grouping the results by order_id to get the count for each specific order."], "gold_sql": "SELECT order_id ,  count(*) FROM Order_items GROUP BY order_id", "source_tables": ["order_items"], "pred_sql": "SELECT Orders.order_id, COUNT(Order_Items.order_item_id) AS number_of_items\nFROM Orders\nLEFT JOIN Order_Items ON Orders.order_id = Order_Items.order_id\nGROUP BY Orders.order_id;", "hint": "\n"}
{"sample_id": "train.2049", "db_id": "party_people", "question": "Show all ministers who do not belong to Progress Party.", "rationale": ["Identify the tables involved: We need information from the 'member' and 'party' tables.", "Determine the relationship: The 'member' table has a foreign key 'Party_ID' that links to the 'party' table.", "Select the relevant columns: We want to show the names of the ministers, which are in the 'member' table under 'Member_Name'.", "Filter the results: We need to exclude members belonging to the 'Progress Party'. This is done using a WHERE clause that checks if the 'Party_name' in the 'party' table is not equal to 'Progress Party'.", "Use JOIN to combine the 'member' and 'party' tables based on the 'Party_ID' to get the necessary information."], "gold_sql": "SELECT minister FROM party WHERE party_name != 'Progress Party'", "source_tables": ["party"], "pred_sql": "SELECT DISTINCT m.Member_Name \nFROM member m \nJOIN party p ON m.Party_ID = p.Party_ID \nWHERE p.Party_name != 'Progress Party';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the ministers associated with political parties from the 'party' table, excluding a specific party name. The placeholder in the WHERE clause represents the name of the party to be excluded.\"\n}\n"}
{"sample_id": "train.2058", "db_id": "party_people", "question": "How many members are in each party?", "rationale": ["Identify the tables involved: We need to gather information from the 'party' and 'member' tables.", "Determine the relationship: The 'member' table has a foreign key 'Party_ID' that links to the 'party' table's 'Party_ID'.", "We want to count the number of members in each party, so we will use the COUNT() function.", "To get the party names along with the count of members, we will select 'Party_name' from the 'party' table and count 'Member_ID' from the 'member' table.", "Use a LEFT JOIN to ensure we include parties even if they have no members.", "Group the results by 'Party_name' to get the count of members for each party."], "gold_sql": "SELECT T2.party_name ,  count(*) FROM Member AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id", "source_tables": ["party", "member"], "pred_sql": "SELECT party.Party_name, COUNT(member.Member_ID) AS Member_Count\nFROM party\nLEFT JOIN member ON party.Party_ID = member.Party_ID\nGROUP BY party.Party_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the ministers associated with political parties from the 'party' table, excluding a specific party name. The placeholder in the WHERE clause represents the name of the party to be excluded.\"\n}\n"}
{"sample_id": "train.2071", "db_id": "party_people", "question": "Show party names and the number of events for each party.", "rationale": ["Identify the tables needed: We need data from the 'party' table for party names and the 'party_events' table for counting events.", "We will use a LEFT JOIN to combine the 'party' and 'party_events' tables on the Party_ID, ensuring we get all parties even if they have no events.", "We will use COUNT(party_events.Event_ID) to count the number of events for each party.", "We will group the results by party name to get the count of events for each individual party."], "gold_sql": "SELECT T2.party_name ,  count(*) FROM party_events AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id", "source_tables": ["party", "party_events"], "pred_sql": "SELECT party.Party_name, COUNT(party_events.Event_ID) AS Number_of_Events\nFROM party\nLEFT JOIN party_events ON party.Party_ID = party_events.Party_ID\nGROUP BY party.Party_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the ministers associated with political parties from the 'party' table, excluding a specific party name. The placeholder in the WHERE clause represents the name of the party to be excluded.\"\n}\n"}
{"sample_id": "train.2081", "db_id": "party_people", "question": "How many Annual Meeting events happened in the United Kingdom region?", "rationale": ["Identify the relevant tables: party_events, party, and region.", "We need to count the number of events, so we will use the COUNT() function.", "Join the party_events table with the party table on Party_ID to link events to their respective parties.", "Join the party table with the region table on Region_ID to filter events by region.", "Add a WHERE clause to filter for events named 'Annual Meeting' and for the region named 'United Kingdom'.", "Select the count of these filtered events."], "gold_sql": "SELECT count(*) FROM region AS t1 JOIN party AS t2 ON t1.region_id  =  t2.region_id JOIN party_events AS t3 ON t2.party_id  =  t3.party_id WHERE t1.region_name  =  'United Kingdom' AND t3.Event_Name  =  'Annaual Meeting'", "source_tables": ["party", "party_events", "region"], "pred_sql": "SELECT COUNT(*) AS Annual_Meeting_Count\nFROM party_events pe\nJOIN party p ON pe.Party_ID = p.Party_ID\nJOIN region r ON p.Region_ID = r.Region_ID\nWHERE pe.Event_Name = 'Annual Meeting' AND r.Region_name = 'United Kingdom';", "hint": "\n"}
{"sample_id": "train.2176", "db_id": "formula_1", "question": "What are the names and years of all races that had a driver with the last name Lewis?", "rationale": ["Identify the tables needed: We need the 'races' table for race names and years, the 'results' table to link races with drivers, and the 'drivers' table to filter by the last name 'Lewis'.", "Join the 'races' table with the 'results' table on 'raceId' to get the results for each race.", "Join the 'results' table with the 'drivers' table on 'driverId' to filter the results for drivers with the last name 'Lewis'.", "Select the 'name' and 'year' columns from the 'races' table where the driver's surname matches 'Lewis'."], "gold_sql": "SELECT T2.name ,  T2.year FROM results AS T1 JOIN races AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T1.driverid = T3.driverid WHERE T3.forename = 'Lewis'", "source_tables": ["results", "drivers", "races"], "pred_sql": "SELECT races.name, races.year \nFROM races \nJOIN results ON races.raceId = results.raceId \nJOIN drivers ON results.driverId = drivers.driverId \nWHERE drivers.surname = 'Lewis';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of drivers along with their surnames from the 'drivers' table, ordered by their lap times recorded in the 'lapTimes' table. The results are limited to a specified number of entries, represented by a placeholder for numeric values.\",\n    \"1\": \"This virtual table provides a list of drivers along with their surnames from the 'drivers' table, ordered by their lap times recorded in the 'lapTimes' table. The placeholder in the LIMIT clause allows the user to specify the number of top results to retrieve based on the fastest lap times.\",\n    \"2\": \"This virtual table provides a distinct list of race names from the 'races' table, sorted in descending order. The placeholder in the ORDER BY clause indicates that the results will be organized based on the race names.\"\n}\n"}
{"sample_id": "train.2182", "db_id": "formula_1", "question": "What are the first and last names of all drivers who participated in the Australian Grand Prix but not the Chinese Grand Prix?", "rationale": ["Identify the tables needed: We need the 'drivers' table to get driver names and the 'results' and 'races' tables to filter by race participation.", "Join the 'drivers' table with the 'results' table to link drivers to their race results.", "Join the 'results' table with the 'races' table to filter for the Australian Grand Prix.", "Use a subquery to find drivers who participated in the Chinese Grand Prix and exclude them from the main query results.", "Select the first and last names of drivers who participated in the Australian Grand Prix but not in the Chinese Grand Prix."], "gold_sql": "SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Australian Grand Prix' EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Chinese Grand Prix'", "source_tables": ["races", "drivers", "results"], "pred_sql": "SELECT d.forename, d.surname \nFROM drivers d \nJOIN results r1 ON d.driverId = r1.driverId \nJOIN races ra ON r1.raceId = ra.raceId \nWHERE ra.name = 'Australian Grand Prix' \nAND d.driverId NOT IN (\n    SELECT d2.driverId \n    FROM drivers d2 \n    JOIN results r2 ON d2.driverId = r2.driverId \n    JOIN races rb ON r2.raceId = rb.raceId \n    WHERE rb.name = 'Chinese Grand Prix'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of drivers along with their surnames from the 'drivers' table, ordered by their lap times recorded in the 'lapTimes' table. The results are limited to a specified number of entries, represented by a placeholder for numeric values.\",\n    \"1\": \"This virtual table provides a list of drivers along with their surnames from the 'drivers' table, ordered by their lap times recorded in the 'lapTimes' table. The placeholder in the LIMIT clause allows the user to specify the number of top results to retrieve based on the fastest lap times.\"\n}\n"}
{"sample_id": "train.2183", "db_id": "formula_1", "question": "Find all the forenames of distinct drivers who was in position 1 as standing and won?", "rationale": ["We need to find distinct drivers who were in position 1 in the standings and also won races.", "To do this, we will select the 'forename' from the 'drivers' table.", "We will join the 'drivers' table with the 'driverStandings' table on the 'driverId' to get the standings information for each driver.", "We will filter the results where the 'position' in the standings is 1 and the number of 'wins' is greater than 0 to ensure they have won races.", "Finally, we will use DISTINCT to ensure that we only get unique forenames."], "gold_sql": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = 1 AND T2.wins = 1", "source_tables": ["drivers", "driverstandings"], "pred_sql": "SELECT DISTINCT d.forename \nFROM drivers d \nJOIN driverStandings ds ON d.driverId = ds.driverId \nWHERE ds.position = 1 AND ds.wins > 0;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of drivers along with their surnames from the 'drivers' table, ordered by their lap times recorded in the 'lapTimes' table. The results are limited to a specified number of entries, represented by a placeholder for numeric values.\",\n    \"1\": \"This virtual table provides a list of drivers along with their surnames from the 'drivers' table, ordered by their lap times recorded in the 'lapTimes' table. The placeholder in the LIMIT clause allows the user to specify the number of top results to retrieve based on the fastest lap times.\"\n}\n"}
{"sample_id": "train.2185", "db_id": "formula_1", "question": "Find all the forenames of distinct drivers who won in position 1 as driver standing and had more than 20 points?", "rationale": ["We need to find distinct drivers who won in position 1 as per driver standings and had more than 20 points.", "To achieve this, we will select the 'forename' from the 'drivers' table.", "We will join the 'drivers' table with the 'driverStandings' table on the 'driverId' to get the standings of each driver.", "We will filter the results where the position is 1 (indicating a win) and the points are greater than 20.", "Using DISTINCT ensures that we only get unique forenames of the drivers."], "gold_sql": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = 1 AND T2.wins = 1 AND T2.points > 20", "source_tables": ["drivers", "driverstandings"], "pred_sql": "SELECT DISTINCT d.forename \nFROM drivers d \nJOIN driverStandings ds ON d.driverId = ds.driverId \nWHERE ds.position = 1 AND ds.points > 20;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of drivers along with their surnames from the 'drivers' table, ordered by their lap times recorded in the 'lapTimes' table. The results are limited to a specified number of entries, represented by a placeholder for numeric values.\",\n    \"1\": \"This virtual table provides a list of drivers along with their surnames from the 'drivers' table, ordered by their lap times recorded in the 'lapTimes' table. The placeholder in the LIMIT clause allows the user to specify the number of top results to retrieve based on the fastest lap times.\"\n}\n"}
{"sample_id": "train.2186", "db_id": "formula_1", "question": "What are the first names of the different drivers who won in position 1 as driver standing and had more than 20 points?", "rationale": ["Identify the relevant tables: drivers, driverStandings, and results.", "We need to find drivers who won (position 1) and had more than 20 points in the driver standings.", "Join the drivers table with the driverStandings table on driverId to access the standings information.", "Join the results table to ensure we are considering only those drivers who have results recorded.", "Use a WHERE clause to filter for drivers who are in position 1 and have more than 20 points.", "Select the distinct first names of these drivers to avoid duplicates."], "gold_sql": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = 1 AND T2.wins = 1 AND T2.points > 20", "source_tables": ["drivers", "driverstandings"], "pred_sql": "SELECT DISTINCT d.forename \nFROM drivers d \nJOIN driverStandings ds ON d.driverId = ds.driverId \nJOIN results r ON d.driverId = r.driverId \nWHERE ds.position = 1 AND ds.points > 20;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of drivers along with their surnames from the 'drivers' table, ordered by their lap times recorded in the 'lapTimes' table. The results are limited to a specified number of entries, represented by a placeholder for numeric values.\",\n    \"1\": \"This virtual table provides a list of drivers along with their surnames from the 'drivers' table, ordered by their lap times recorded in the 'lapTimes' table. The placeholder in the LIMIT clause allows the user to specify the number of top results to retrieve based on the fastest lap times.\"\n}\n"}
{"sample_id": "train.2189", "db_id": "formula_1", "question": "What are the numbers of races for each constructor id?", "rationale": ["We need to count the number of races for each constructor id.", "The relevant table for this information is 'constructorResults', which links constructors to races.", "We will use the COUNT() function to count the occurrences of raceId for each constructorId.", "We will group the results by constructorId to get the count for each constructor."], "gold_sql": "SELECT count(*) ,  constructorid FROM constructorStandings GROUP BY constructorid", "source_tables": ["constructorstandings"], "pred_sql": "SELECT constructorId, COUNT(raceId) AS number_of_races\nFROM constructorResults\nGROUP BY constructorId;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a distinct list of race names from the 'races' table, sorted in descending order. The placeholder in the ORDER BY clause indicates that the results will be organized based on the race names.\",\n    \"1\": \"This virtual table provides a list of drivers along with their surnames from the 'drivers' table, ordered by their lap times recorded in the 'lapTimes' table. The results are limited to a specified number of entries, represented by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.2218", "db_id": "formula_1", "question": "What are the names of all the Japanese constructors that have earned more than 5 points?", "rationale": ["Identify the relevant table: We need to look at the 'constructors' table to find the names of constructors.", "Filter by nationality: We want constructors from Japan, so we will add a condition for 'nationality = 'Japanese' '.", "Aggregate points: We need to check the total points earned by each constructor, which is stored in the 'constructorResults' table.", "Use a subquery: We will use a subquery to sum the points for each constructor and filter those with more than 5 points.", "Join the results: We will join the results of the constructors with the filtered constructor IDs from the subquery to get the names of the constructors."], "gold_sql": "SELECT T1.name FROM constructors AS T1 JOIN constructorstandings AS T2 ON T1.constructorid = T2.constructorid WHERE T1.nationality = 'Japanese' AND T2.points > 5", "source_tables": ["constructorstandings", "constructors"], "pred_sql": "SELECT name FROM constructors WHERE nationality = 'Japanese' AND constructorId IN (SELECT constructorId FROM constructorResults GROUP BY constructorId HAVING SUM(points) > 5);", "hint": "\n"}
{"sample_id": "train.2220", "db_id": "formula_1", "question": "What is the average fastest lap speed for the Monaco Grand Prix in 2008?", "rationale": ["Identify the relevant tables: races, results, and lapTimes are needed to get the average fastest lap speed for a specific race.", "The races table will provide the year and name of the race (Monaco Grand Prix in 2008).", "The results table links races to the drivers and their performance in those races.", "The lapTimes table contains the fastest lap speed for each driver in each race.", "Join the races table with the results table on raceId, and then join the results table with the lapTimes table on raceId and driverId.", "Filter the results to only include the Monaco Grand Prix in 2008 using the WHERE clause.", "Calculate the average fastest lap speed using the AVG() function on the fastestLapSpeed column from the lapTimes table."], "gold_sql": "SELECT avg(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "pred_sql": "SELECT AVG(lapTimes.fastestLapSpeed) AS average_fastest_lap_speed\nFROM races\nJOIN results ON races.raceId = results.raceId\nJOIN lapTimes ON results.raceId = lapTimes.raceId AND results.driverId = lapTimes.driverId\nWHERE races.year = 2008 AND races.name = 'Monaco Grand Prix';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average fastest lap speed from the 'results' table for races that occurred in a specific year and have a particular name. The placeholders in the WHERE clause represent the year of the race and the name of the race.\",\n    \"1\": \"This virtual table provides a list of drivers along with their surnames from the 'drivers' table, ordered by their lap times recorded in the 'lapTimes' table. The placeholder in the LIMIT clause allows the user to specify the number of top results to retrieve based on the fastest lap times.\",\n    \"2\": \"This virtual table provides a list of drivers along with their surnames from the 'drivers' table, ordered by their lap times recorded in the 'lapTimes' table. The results are limited to a specified number of entries, represented by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.2221", "db_id": "formula_1", "question": "What is the maximum fastest lap speed in race named 'Monaco Grand Prix' in 2008 ?", "rationale": ["Identify the relevant tables: races, results, and lapTimes are needed to find the fastest lap speed for the specified race.", "Join the races table with the results table on raceId to link races with their results.", "Join the results table with the lapTimes table on raceId and driverId to access the fastest lap speeds for each driver in the race.", "Filter the results to only include the race named 'Monaco Grand Prix' that took place in 2008.", "Select the maximum fastest lap speed from the filtered results."], "gold_sql": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "pred_sql": "SELECT MAX(lapTimes.fastestLapSpeed) AS max_fastest_lap_speed\nFROM races\nJOIN results ON races.raceId = results.raceId\nJOIN lapTimes ON results.raceId = lapTimes.raceId AND results.driverId = lapTimes.driverId\nWHERE races.name = 'Monaco Grand Prix' AND races.year = 2008;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average fastest lap speed from the 'results' table for races that occurred in a specific year and have a particular name. The placeholders in the WHERE clause represent the year of the race and the name of the race.\",\n    \"1\": \"This virtual table provides a list of drivers along with their surnames from the 'drivers' table, ordered by their lap times recorded in the 'lapTimes' table. The placeholder in the LIMIT clause allows the user to specify the number of top results to retrieve based on the fastest lap times.\",\n    \"2\": \"This virtual table provides a list of drivers along with their surnames from the 'drivers' table, ordered by their lap times recorded in the 'lapTimes' table. The results are limited to a specified number of entries, represented by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.2222", "db_id": "formula_1", "question": "What is the maximum fastest lap speed in the Monaco Grand Prix in 2008?", "rationale": ["Identify the relevant tables: races, lapTimes, and circuits are needed to find the fastest lap speed for the Monaco Grand Prix in 2008.", "Use the races table to filter for the year 2008 and the specific race name 'Monaco Grand Prix'.", "Join the lapTimes table to access the fastest lap speed data associated with the races.", "Join the circuits table to ensure we are looking at the correct circuit for the Monaco Grand Prix.", "Select the maximum fastest lap speed from the lapTimes table for the filtered results."], "gold_sql": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "pred_sql": "SELECT MAX(lapTimes.fastestLapSpeed) AS max_fastest_lap_speed \nFROM races \nJOIN lapTimes ON races.raceId = lapTimes.raceId \nJOIN circuits ON races.circuitId = circuits.circuitId \nWHERE circuits.name = 'Monaco Grand Prix' AND races.year = 2008;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average fastest lap speed from the 'results' table for races that occurred in a specific year and have a particular name. The placeholders in the WHERE clause represent the year of the race and the name of the race.\",\n    \"1\": \"This virtual table provides a list of drivers along with their surnames from the 'drivers' table, ordered by their lap times recorded in the 'lapTimes' table. The placeholder in the LIMIT clause allows the user to specify the number of top results to retrieve based on the fastest lap times.\",\n    \"2\": \"This virtual table provides a list of drivers along with their surnames from the 'drivers' table, ordered by their lap times recorded in the 'lapTimes' table. The results are limited to a specified number of entries, represented by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.2224", "db_id": "formula_1", "question": "For each race name, What is the maximum fastest lap speed for races after 2004 ordered by year?", "rationale": ["Identify the relevant tables: 'races' for race names and years, and 'results' for fastest lap speeds.", "Join the 'races' table with the 'results' table on the raceId to access both race names and their corresponding fastest lap speeds.", "Filter the results to include only races that occurred after the year 2004 using the WHERE clause.", "Group the results by race name to calculate the maximum fastest lap speed for each race using the MAX function.", "Order the final results by year to meet the requirement of the query."], "gold_sql": "SELECT max(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "pred_sql": "SELECT r.name, MAX(rf.fastestLapSpeed) AS max_fastest_lap_speed\nFROM races r\nJOIN results rf ON r.raceId = rf.raceId\nWHERE r.year > 2004\nGROUP BY r.name\nORDER BY r.year;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average fastest lap speed from the 'results' table for races that occurred in a specific year and have a particular name. The placeholders in the WHERE clause represent the year of the race and the name of the race.\",\n    \"1\": \"This virtual table provides a list of drivers along with their surnames from the 'drivers' table, ordered by their lap times recorded in the 'lapTimes' table. The placeholder in the LIMIT clause allows the user to specify the number of top results to retrieve based on the fastest lap times.\",\n    \"2\": \"This virtual table provides a list of drivers along with their surnames from the 'drivers' table, ordered by their lap times recorded in the 'lapTimes' table. The results are limited to a specified number of entries, represented by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.2225", "db_id": "formula_1", "question": "What are the average fastest lap speed in races held after 2004 grouped by race name and ordered by year?", "rationale": ["Identify the relevant tables: races, results, and lapTimes are needed to get race names, results, and fastest lap speeds.", "Join the races table with the results table on raceId to link races with their results.", "Join the results table with the lapTimes table on raceId and driverId to get the fastest lap speeds for each driver in each race.", "Filter the results to include only races that occurred after 2004 using the WHERE clause.", "Group the results by race name to calculate the average fastest lap speed for each race.", "Select the race name and the average of the fastest lap speeds, ordering the results by year."], "gold_sql": "SELECT avg(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "pred_sql": "SELECT r.name AS race_name, AVG(lap.fastestLapSpeed) AS average_fastest_lap_speed\nFROM races r\nJOIN results res ON r.raceId = res.raceId\nJOIN lapTimes lap ON res.raceId = lap.raceId AND res.driverId = lap.driverId\nWHERE r.year > 2004\nGROUP BY r.name\nORDER BY r.year;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average fastest lap speed from the 'results' table for races that occurred in a specific year and have a particular name. The placeholders in the WHERE clause represent the year of the race and the name of the race.\",\n    \"1\": \"This virtual table provides a list of drivers along with their surnames from the 'drivers' table, ordered by their lap times recorded in the 'lapTimes' table. The placeholder in the LIMIT clause allows the user to specify the number of top results to retrieve based on the fastest lap times.\",\n    \"2\": \"This virtual table provides a list of drivers along with their surnames from the 'drivers' table, ordered by their lap times recorded in the 'lapTimes' table. The results are limited to a specified number of entries, represented by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.2226", "db_id": "formula_1", "question": "What is the average fastest lap speed for races held after 2004, for each race, ordered by year?", "rationale": ["Identify the relevant tables: 'races' and 'results' are needed to get the race years and the fastest lap speeds.", "We need to calculate the average fastest lap speed, so we will use the AVG() function on the 'fastestLapSpeed' column from the 'results' table.", "We need to filter the races to only include those held after the year 2004, which will be done using a WHERE clause.", "To get the average fastest lap speed for each year, we will group the results by the 'year' column from the 'races' table using GROUP BY.", "Finally, we will order the results by year in ascending order using ORDER BY."], "gold_sql": "SELECT avg(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "pred_sql": "SELECT races.year, AVG(results.fastestLapSpeed) AS average_fastest_lap_speed\nFROM races\nJOIN results ON races.raceId = results.raceId\nWHERE races.year > 2004\nGROUP BY races.year\nORDER BY races.year;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average fastest lap speed from the 'results' table for races that occurred in a specific year and have a particular name. The placeholders in the WHERE clause represent the year of the race and the name of the race.\",\n    \"1\": \"This virtual table provides a list of drivers along with their surnames from the 'drivers' table, ordered by their lap times recorded in the 'lapTimes' table. The placeholder in the LIMIT clause allows the user to specify the number of top results to retrieve based on the fastest lap times.\",\n    \"2\": \"This virtual table provides a list of drivers along with their surnames from the 'drivers' table, ordered by their lap times recorded in the 'lapTimes' table. The results are limited to a specified number of entries, represented by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.2243", "db_id": "machine_repair", "question": "What is the starting year of the oldest technicians?", "rationale": ["Identify the relevant table: The question pertains to the 'technician' table, specifically the 'Starting_Year' column.", "Determine the criteria: We need to find the oldest technician, which implies sorting by age.", "Sort the technicians by age in ascending order to find the oldest technician.", "Use the LIMIT clause to return only the first record, which will be the oldest technician's starting year."], "gold_sql": "SELECT Starting_Year FROM technician ORDER BY Age DESC LIMIT 1", "source_tables": ["technician"], "pred_sql": "SELECT Starting_Year FROM technician ORDER BY Age ASC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the starting years of technicians from the 'technician' table, ordered by their age in descending order. The placeholder in the LIMIT clause represents the maximum number of records to return.\"\n}\n"}
{"sample_id": "train.2248", "db_id": "machine_repair", "question": "What are the teams with the most technicians?", "rationale": ["Identify the relevant table: The 'technician' table contains information about technicians and their teams.", "Count the number of technicians per team: Use the COUNT() function to count the number of technician IDs for each team.", "Group the results by team: Use GROUP BY to aggregate the counts for each team.", "Order the results: Use ORDER BY to sort the teams by the count of technicians in descending order."], "gold_sql": "SELECT Team FROM technician GROUP BY Team ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["technician"], "pred_sql": "SELECT Team, COUNT(technician_id) AS technician_count\nFROM technician\nGROUP BY Team\nORDER BY technician_count DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the starting years of technicians from the 'technician' table, ordered by their age in descending order. The placeholder in the LIMIT clause represents the maximum number of records to return.\"\n}\n"}
{"sample_id": "train.2258", "db_id": "machine_repair", "question": "What are the names of the technicians  and how many machines are they assigned to repair?", "rationale": ["Identify the relevant tables: technician and repair_assignment.", "We need the names of technicians, which are in the technician table.", "We also need to count the number of machines assigned to each technician, which can be found in the repair_assignment table.", "To get the count of machines, we will use the COUNT() function on the Machine_ID from the repair_assignment table.", "We will perform a LEFT JOIN between the technician and repair_assignment tables on the technician_id to ensure we get all technicians, even those with no assigned machines.", "Finally, we will group the results by technician name to get the count of machines for each technician."], "gold_sql": "SELECT T2.Name ,  COUNT(*) FROM repair_assignment AS T1 JOIN technician AS T2 ON T1.technician_ID  =  T2.technician_ID GROUP BY T2.Name", "source_tables": ["repair_assignment", "technician"], "pred_sql": "SELECT technician.Name, COUNT(repair_assignment.Machine_ID) AS machine_count\nFROM technician\nLEFT JOIN repair_assignment ON technician.technician_id = repair_assignment.technician_id\nGROUP BY technician.Name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the starting years of technicians from the 'technician' table, ordered by their age in descending order. The placeholder in the LIMIT clause represents the maximum number of records to return.\"\n}\n"}
{"sample_id": "train.2328", "db_id": "csu_1", "question": "Find all the campuses opened in 1958.", "rationale": ["Identify the relevant table: The 'Campuses' table contains information about the campuses, including the year they were opened.", "Determine the condition: We need to find campuses that were opened in the year 1958.", "Construct the SQL query: Use a SELECT statement to retrieve all columns from the 'Campuses' table where the 'Year' column matches '1958'."], "gold_sql": "SELECT campus FROM campuses WHERE YEAR  =  1958", "source_tables": ["campuses"], "pred_sql": "SELECT * FROM Campuses WHERE Year = '1958';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the campuses from the 'Campuses' table that are located in a specific geographical location. The placeholder in the WHERE clause represents the location of interest.\",\n    \"1\": \"This virtual table describes the campuses located in a specific county from the 'Campuses' table. The placeholder in the WHERE clause represents the name of the county.\",\n    \"2\": \"This virtual table describes the names of campuses from the 'Campuses' table that are located in a specific county. The placeholder in the WHERE clause represents the name of the county.\"\n}\n"}
{"sample_id": "train.2334", "db_id": "csu_1", "question": "Find the name of the campuses that is in Northridge, Los Angeles or in San Francisco, San Francisco.", "rationale": ["Identify the relevant table: The 'Campuses' table contains the information about campus names and their locations.", "Determine the filtering criteria: The user is interested in campuses located in either 'Northridge, Los Angeles' or 'San Francisco, San Francisco'.", "Construct the SQL query: Use a SELECT statement to retrieve the 'Campus' names from the 'Campuses' table where the 'Location' matches either of the specified locations."], "gold_sql": "SELECT campus FROM campuses WHERE LOCATION  =  'Northridge' AND county  =  'Los Angeles' UNION SELECT campus FROM campuses WHERE LOCATION  =  'San Francisco' AND county  =  'San Francisco'", "source_tables": ["campuses"], "pred_sql": "SELECT Campus FROM Campuses WHERE (Location = 'Northridge, Los Angeles' OR Location = 'San Francisco, San Francisco');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the campuses from the 'Campuses' table that are located in a specific geographical location. The placeholder in the WHERE clause represents the location of interest.\",\n    \"1\": \"This virtual table describes the names of campuses from the 'Campuses' table that are located in a specific county. The placeholder in the WHERE clause represents the name of the county.\",\n    \"2\": \"This virtual table describes the campuses located in a specific county from the 'Campuses' table. The placeholder in the WHERE clause represents the name of the county.\"\n}\n"}
{"sample_id": "train.2350", "db_id": "csu_1", "question": "Which campus has the most faculties in year 2003?", "rationale": ["Identify the relevant table: The 'faculty' table contains the number of faculty members associated with each campus for different years.", "Determine the year of interest: The user is asking for data from the year 2003.", "Construct the SQL query to select the 'Campus' and 'Faculty' columns from the 'faculty' table where the 'Year' is 2003.", "Order the results by the 'Faculty' column in descending order to get the campus with the most faculty members at the top.", "Limit the results to 1 to get only the campus with the highest number of faculty members."], "gold_sql": "SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  2003 ORDER BY T2.faculty DESC LIMIT 1", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT Campus, Faculty \nFROM faculty \nWHERE Year = 2003 \nORDER BY Faculty DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the types of degrees awarded at a specific campus during a particular year. The placeholders in the WHERE clause represent the campus name and the year of the degrees awarded.\",\n    \"1\": \"This virtual table describes the campuses from the 'Campuses' table that are located in a specific geographical location. The placeholder in the WHERE clause represents the location of interest.\",\n    \"2\": \"This virtual table describes the campuses located in a specific county from the 'Campuses' table. The placeholder in the WHERE clause represents the name of the county.\"\n}\n"}
{"sample_id": "train.2356", "db_id": "csu_1", "question": "report the total number of degrees granted between 1998 and 2002.", "rationale": ["Identify the relevant table: The 'degrees' table contains information about degrees awarded, including the year and the number of degrees.", "Determine the required data: We need to sum the total number of degrees awarded between the years 1998 and 2002.", "Construct the SQL query: Use the SUM function to calculate the total degrees and filter the results using a WHERE clause to specify the year range."], "gold_sql": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  1998 AND T2.year  <=  2002 GROUP BY T1.campus", "source_tables": ["degrees", "campuses"], "pred_sql": "SELECT SUM(Degrees) AS TotalDegrees\nFROM degrees\nWHERE Year BETWEEN '1998' AND '2002';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the years in which degrees were awarded, grouped by year and ordered by the total number of degrees awarded in descending order. The placeholder in the LIMIT clause represents the maximum number of years to return.\",\n    \"1\": \"This virtual table describes the types of degrees awarded at a specific campus during a particular year. The placeholders in the WHERE clause represent the campus name and the year of the degrees awarded.\"\n}\n"}
{"sample_id": "train.2359", "db_id": "csu_1", "question": "What is the total number of degrees granted after 2000 for each Orange county campus?", "rationale": ["Identify the relevant tables: Campuses and degrees.", "We need to count the total number of degrees granted after 2000, so we will use the degrees table for the count and the year filter.", "We need to filter the campuses to only those located in Orange County, which is done using the Campuses table.", "Join the Campuses table with the degrees table on the campus identifier to link campuses with their awarded degrees.", "Apply the condition to count only degrees awarded after the year 2000.", "Group the results by campus to get the total number of degrees for each campus."], "gold_sql": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  'Orange' AND T2.year  >=  2000 GROUP BY T1.campus", "source_tables": ["degrees", "campuses"], "pred_sql": "SELECT c.Campus, COUNT(d.Degrees) AS TotalDegrees\nFROM Campuses c\nJOIN degrees d ON c.Id = d.Campus\nWHERE c.County = 'Orange' AND d.Year > '2000'\nGROUP BY c.Campus;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the types of degrees awarded at a specific campus during a particular year. The placeholders in the WHERE clause represent the campus name and the year of the degrees awarded.\",\n    \"1\": \"This virtual table summarizes the years in which degrees were awarded, grouped by year and ordered by the total number of degrees awarded in descending order. The placeholder in the LIMIT clause represents the maximum number of years to return.\",\n    \"2\": \"This virtual table provides the total count of campuses located in a specific county from the 'Campuses' table. The placeholder in the WHERE clause represents the name of the county.\"\n}\n"}
{"sample_id": "train.2362", "db_id": "csu_1", "question": "What campus had more than 400 total enrollment but more than 200 full time enrollment in year 1956?", "rationale": ["Identify the relevant table: The 'enrollments' table contains the total enrollment and full-time equivalent (FTE) data.", "Specify the year: We need to filter the data for the year 1956.", "Set the conditions: We need to find campuses with total enrollment greater than 400 and full-time enrollment greater than 200.", "Construct the SQL query: Select the 'Campus' from the 'enrollments' table where the specified conditions are met."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN enrollments AS t2 ON t1.id  =  t2.campus WHERE t2.year  =  1956 AND totalenrollment_ay  >  400 AND FTE_AY  >  200", "source_tables": ["enrollments", "campuses"], "pred_sql": "SELECT Campus \nFROM enrollments \nWHERE Year = '1956' \n  AND TotalEnrollment_AY > 400 \n  AND FTE_AY > 200;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the total number of graduate enrollments from the 'discipline_enrollments' table for a specific campus and year. The placeholders in the WHERE clause represent the year of enrollment and the name of the campus.\",\n    \"1\": \"This virtual table describes the types of degrees awarded at a specific campus during a particular year. The placeholders in the WHERE clause represent the campus name and the year of the degrees awarded.\",\n    \"2\": \"This virtual table describes the campuses located in a specific county from the 'Campuses' table. The placeholder in the WHERE clause represents the name of the county.\"\n}\n"}
{"sample_id": "train.2363", "db_id": "csu_1", "question": "What campus started in year 1956, has more than 200 full time students, and more than 400 students enrolled?", "rationale": ["Identify the relevant tables: Campuses and enrollments are needed to find the campus that started in 1956 and has specific enrollment numbers.", "Use the Campuses table to filter campuses that started in the year 1956.", "Join the enrollments table to access the enrollment data for the campuses.", "Apply the conditions to filter campuses with more than 200 full-time students (FTE_AY) and more than 400 total enrollments (TotalEnrollment_AY).", "Select the Campus name from the resulting dataset."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN enrollments AS t2 ON t1.id  =  t2.campus WHERE t2.year  =  1956 AND totalenrollment_ay  >  400 AND FTE_AY  >  200", "source_tables": ["enrollments", "campuses"], "pred_sql": "SELECT c.Campus \nFROM Campuses c \nJOIN enrollments e ON c.Id = e.Campus \nWHERE c.Year = '1956' \nAND e.FTE_AY > '200' \nAND e.TotalEnrollment_AY > '400';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the types of degrees awarded at a specific campus during a particular year. The placeholders in the WHERE clause represent the campus name and the year of the degrees awarded.\",\n    \"1\": \"This virtual table calculates the total number of graduate enrollments from the 'discipline_enrollments' table for a specific campus and year. The placeholders in the WHERE clause represent the year of enrollment and the name of the campus.\",\n    \"2\": \"This virtual table describes the campuses located in a specific county from the 'Campuses' table. The placeholder in the WHERE clause represents the name of the county.\"\n}\n"}
{"sample_id": "train.2366", "db_id": "csu_1", "question": "List the campuses in Los Angeles county.", "rationale": ["Identify the relevant table: The 'Campuses' table contains information about campuses, including their location and county.", "Determine the specific condition: We need to filter campuses based on the county, which is 'Los Angeles'.", "Construct the SQL query: Use a SELECT statement to retrieve the 'Campus' names from the 'Campuses' table where the 'County' matches 'Los Angeles'."], "gold_sql": "SELECT campus FROM campuses WHERE county  =  'Los Angeles'", "source_tables": ["campuses"], "pred_sql": "SELECT Campus FROM Campuses WHERE County = 'Los Angeles';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the campuses located in a specific county from the 'Campuses' table. The placeholder in the WHERE clause represents the name of the county.\",\n    \"1\": \"This virtual table describes the names of campuses from the 'Campuses' table that are located in a specific county. The placeholder in the WHERE clause represents the name of the county.\",\n    \"2\": \"This virtual table describes the campuses from the 'Campuses' table that are located in a specific geographical location. The placeholder in the WHERE clause represents the location of interest.\"\n}\n"}
{"sample_id": "train.2368", "db_id": "csu_1", "question": "How many degrees were conferred in \"San Jose State University\" in 2000?", "rationale": ["Identify the relevant tables: degrees and Campuses.", "We need to count the number of degrees conferred, so we will use the COUNT function on the Degrees column from the degrees table.", "To filter the results for 'San Jose State University', we will join the degrees table with the Campuses table on the Campus identifier.", "We will also filter the results for the year 2000 by adding a WHERE clause for degrees.Year.", "The final SQL query will select the count of degrees for the specified campus and year."], "gold_sql": "SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  'San Jose State University' AND t2.year  =  2000", "source_tables": ["degrees", "campuses"], "pred_sql": "SELECT COUNT(Degrees) AS TotalDegrees\nFROM degrees\nJOIN Campuses ON degrees.Campus = Campuses.Id\nWHERE Campuses.Campus = 'San Jose State University' AND degrees.Year = '2000';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the types of degrees awarded at a specific campus during a particular year. The placeholders in the WHERE clause represent the campus name and the year of the degrees awarded.\",\n    \"1\": \"This virtual table summarizes the years in which degrees were awarded, grouped by year and ordered by the total number of degrees awarded in descending order. The placeholder in the LIMIT clause represents the maximum number of years to return.\",\n    \"2\": \"This virtual table calculates the total number of graduate enrollments from the 'discipline_enrollments' table for a specific campus and year. The placeholders in the WHERE clause represent the year of enrollment and the name of the campus.\"\n}\n"}
{"sample_id": "train.2374", "db_id": "csu_1", "question": "What is the number of faculty lines in campus \"Long Beach State University\" in 2002?", "rationale": ["Identify the relevant tables: 'faculty' for faculty data and 'Campuses' for campus names.", "Join the 'faculty' table with the 'Campuses' table on the campus identifier to access campus names.", "Filter the results to only include records for 'Long Beach State University' and the year 2002.", "Select the 'Faculty' column to get the number of faculty lines for the specified campus and year."], "gold_sql": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  2002 AND T2.campus  =  'Long Beach State University'", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT Faculty FROM faculty INNER JOIN Campuses ON faculty.Campus = Campuses.Id WHERE Campuses.Campus = 'Long Beach State University' AND faculty.Year = 2002;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the types of degrees awarded at a specific campus during a particular year. The placeholders in the WHERE clause represent the campus name and the year of the degrees awarded.\"\n}\n"}
{"sample_id": "train.2376", "db_id": "csu_1", "question": "How many faculty lines are there in \"San Francisco State University\" in year 2004?", "rationale": ["Identify the relevant tables: 'faculty' for faculty data and 'Campuses' for campus names.", "We need to count the number of faculty lines, so we will use the COUNT() function.", "We need to filter the results to only include faculty from 'San Francisco State University' in the year 2004.", "Join the 'faculty' table with the 'Campuses' table on the campus identifier to access the campus name.", "Use a WHERE clause to specify the campus name and the year for filtering."], "gold_sql": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  2004 AND T2.campus  =  'San Francisco State University'", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT COUNT(*) AS FacultyCount \nFROM faculty f \nJOIN Campuses c ON f.Campus = c.Id \nWHERE c.Campus = 'San Francisco State University' AND f.Year = 2004;", "hint": "\n"}
{"sample_id": "train.2377", "db_id": "csu_1", "question": "How many faculty lines are there at San Francisco State University in 2004?", "rationale": ["Identify the relevant table: The 'faculty' table contains the number of faculty members.", "Determine the specific campus: We need to find the Id for 'San Francisco State University' from the 'Campuses' table.", "Filter by year: We are interested in the year 2004.", "Construct the SQL query to select the Faculty count for the specified campus and year."], "gold_sql": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  2004 AND T2.campus  =  'San Francisco State University'", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT Faculty FROM faculty WHERE Campus = (SELECT Id FROM Campuses WHERE Campus = 'San Francisco State University') AND Year = 2004;", "hint": "\n"}
{"sample_id": "train.2381", "db_id": "csu_1", "question": "How many faculty members did the university that conferred the most degrees in 2002 have?", "rationale": ["Identify the year of interest, which is 2002, to filter the degrees awarded.", "Determine which campus conferred the most degrees in 2002 by grouping the degrees table by campus and counting the number of degrees awarded, ordering the results in descending order, and limiting the result to the top campus.", "Join the faculty table with the degrees table on the campus identifier to get the faculty count for the campus that awarded the most degrees in 2002.", "Select the faculty count from the faculty table where the campus matches the one identified in the previous step."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2002 ORDER BY t3.degrees DESC LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "pred_sql": "SELECT f.Faculty \nFROM faculty f \nJOIN degrees d ON f.Campus = d.Campus \nWHERE d.Year = '2002' \nAND d.Campus = (SELECT d2.Campus \n                FROM degrees d2 \n                WHERE d2.Year = '2002' \n                GROUP BY d2.Campus \n                ORDER BY COUNT(d2.Degrees) DESC \n                LIMIT 1)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the types of degrees awarded at a specific campus during a particular year. The placeholders in the WHERE clause represent the campus name and the year of the degrees awarded.\",\n    \"1\": \"This virtual table summarizes the years in which degrees were awarded, grouped by year and ordered by the total number of degrees awarded in descending order. The placeholder in the LIMIT clause represents the maximum number of years to return.\"\n}\n"}
{"sample_id": "train.2382", "db_id": "csu_1", "question": "How many faculty lines are there in the university that conferred the least number of degrees in year 2001?", "rationale": ["Identify the year of interest, which is 2001, for degrees awarded.", "Determine which campus conferred the least number of degrees in 2001 by grouping the degrees table by campus and counting the degrees, ordering by the count in ascending order, and limiting the result to 1 campus.", "Join the faculty table with the degrees table on the campus identifier to get the faculty data for the campus that conferred the least degrees.", "Count the number of faculty lines for that specific campus in the year 2001."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2001 ORDER BY t3.degrees LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "pred_sql": "SELECT COUNT(faculty.Faculty) AS FacultyCount\nFROM faculty\nJOIN degrees ON faculty.Campus = degrees.Campus\nWHERE degrees.Year = '2001'\nAND degrees.Campus = (SELECT Campus\n                     FROM degrees\n                     WHERE Year = '2001'\n                     GROUP BY Campus\n                     ORDER BY COUNT(Degrees) ASC\n                     LIMIT 1);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the years in which degrees were awarded, grouped by year and ordered by the total number of degrees awarded in descending order. The placeholder in the LIMIT clause represents the maximum number of years to return.\",\n    \"1\": \"This virtual table describes the types of degrees awarded at a specific campus during a particular year. The placeholders in the WHERE clause represent the campus name and the year of the degrees awarded.\"\n}\n"}
{"sample_id": "train.2383", "db_id": "csu_1", "question": "How many faculty members are at the university that gave the least number of degrees in 2001?", "rationale": ["Identify the year of interest, which is 2001.", "Determine the campus that awarded the least number of degrees in 2001 by counting the degrees for each campus and ordering them in ascending order.", "Join the 'faculty' table with the 'degrees' table on the campus identifier to get the faculty count for the campus with the least degrees awarded.", "Select the faculty count for the campus that awarded the least degrees in 2001."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2001 ORDER BY t3.degrees LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "pred_sql": "SELECT f.Faculty \nFROM faculty f \nJOIN degrees d ON f.Campus = d.Campus \nWHERE d.Year = '2001' \nORDER BY (SELECT COUNT(*) FROM degrees WHERE Year = '2001') ASC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the years in which degrees were awarded, grouped by year and ordered by the total number of degrees awarded in descending order. The placeholder in the LIMIT clause represents the maximum number of years to return.\",\n    \"1\": \"This virtual table describes the types of degrees awarded at a specific campus during a particular year. The placeholders in the WHERE clause represent the campus name and the year of the degrees awarded.\"\n}\n"}
{"sample_id": "train.2385", "db_id": "csu_1", "question": "How many undergraduates are there at San Jose State", "rationale": ["Identify the relevant table for undergraduate enrollments, which is 'discipline_enrollments'.", "Determine the necessary columns: we need to sum the 'Undergraduate' column to get the total number of undergraduates.", "Join the 'discipline_enrollments' table with the 'Campuses' table to filter by campus name.", "Use a WHERE clause to specify the campus name as 'San Jose State'.", "Construct the SQL query to select the sum of undergraduates for the specified campus."], "gold_sql": "SELECT sum(t1.undergraduate) FROM discipline_enrollments AS t1 JOIN campuses AS t2 ON t1.campus  =  t2.id WHERE t1.year  =  2004 AND t2.campus  =  'San Jose State University'", "source_tables": ["discipline_enrollments", "campuses"], "pred_sql": "SELECT SUM(Undergraduate) AS TotalUndergraduates \nFROM discipline_enrollments \nJOIN Campuses ON discipline_enrollments.Campus = Campuses.Id \nWHERE Campuses.Campus = 'San Jose State';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the total number of graduate enrollments from the 'discipline_enrollments' table for a specific campus and year. The placeholders in the WHERE clause represent the year of enrollment and the name of the campus.\",\n    \"1\": \"This virtual table describes the types of degrees awarded at a specific campus during a particular year. The placeholders in the WHERE clause represent the campus name and the year of the degrees awarded.\"\n}\n"}
{"sample_id": "train.2397", "db_id": "candidate_poll", "question": "Return the poll resource associated with the most candidates.", "rationale": ["We need to find the poll resource associated with the most candidates.", "This requires counting the number of candidates for each poll source.", "We will use the COUNT function to count the Candidate_IDs grouped by Poll_Source.", "To get the poll source with the highest count, we will order the results in descending order.", "Finally, we will limit the results to just one entry to get the top poll source."], "gold_sql": "SELECT poll_source FROM candidate GROUP BY poll_source ORDER BY count(*) DESC LIMIT 1", "source_tables": ["candidate"], "pred_sql": "SELECT Poll_Source, COUNT(Candidate_ID) AS Candidate_Count\nFROM candidate\nGROUP BY Poll_Source\nORDER BY Candidate_Count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the support rates of candidates from the 'candidate' table, ordered from highest to lowest. The placeholder in the LIMIT clause indicates the maximum number of results to return.\"\n}\n"}
{"sample_id": "train.2405", "db_id": "candidate_poll", "question": "Return the poll source corresponding to the candidate who has the oppose rate.", "rationale": ["Identify the relevant table: The 'candidate' table contains the 'Poll_Source' and 'Oppose_rate' columns.", "Determine the condition: We want to return the 'Poll_Source' for candidates who have an 'Oppose_rate'.", "Formulate the SQL query: Use a SELECT statement to retrieve 'Poll_Source' from the 'candidate' table where 'Oppose_rate' is not null."], "gold_sql": "SELECT poll_source FROM candidate ORDER BY oppose_rate DESC LIMIT 1", "source_tables": ["candidate"], "pred_sql": "SELECT Poll_Source FROM candidate WHERE Oppose_rate IS NOT NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the support rates of candidates from the 'candidate' table, ordered from highest to lowest. The placeholder in the LIMIT clause indicates the maximum number of results to return.\"\n}\n"}
{"sample_id": "train.2417", "db_id": "candidate_poll", "question": "For each sex, what is the name and sex of the candidate with the oppose rate for their sex?", "rationale": ["Identify the relevant tables: 'candidate' and 'people'.", "We need to join these tables on the common column 'People_ID'.", "Select the 'Name' and 'Sex' from the 'people' table and the 'Oppose_rate' from the 'candidate' table.", "Filter the results to include only candidates of each sex by using a subquery to get distinct sexes from the 'people' table.", "Order the results by 'Oppose_rate' in descending order to get the candidates with the highest oppose rates for each sex."], "gold_sql": "SELECT t1.name ,  t1.sex ,  min(oppose_rate) FROM people AS t1 JOIN candidate AS t2 ON t1.people_id  =  t2.people_id GROUP BY t1.sex", "source_tables": ["candidate", "people"], "pred_sql": "SELECT p.Name, p.Sex, c.Oppose_rate \nFROM candidate c \nJOIN people p ON c.People_ID = p.People_ID \nWHERE p.Sex IN (SELECT DISTINCT Sex FROM people) \nORDER BY c.Oppose_rate DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the support rates of candidates from the 'candidate' table, ordered from highest to lowest. The placeholder in the LIMIT clause indicates the maximum number of results to return.\"\n}\n"}
{"sample_id": "train.2434", "db_id": "movie_1", "question": "Find the titles of all movies directed by steven spielberg.", "rationale": ["Identify the table needed: The 'Movie' table contains the titles and directors of movies.", "Determine the condition: We need to filter the movies directed by 'steven spielberg'.", "Construct the SQL query: Use a SELECT statement to get the 'title' from the 'Movie' table where the 'director' matches 'steven spielberg'."], "gold_sql": "SELECT title FROM Movie WHERE director = 'Steven Spielberg'", "source_tables": ["movie"], "pred_sql": "SELECT title FROM Movie WHERE director = 'steven spielberg';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the titles of movies from the 'Movie' table that have received ratings within a specified range of stars. The placeholders in the WHERE clause represent the minimum and maximum star ratings.\"\n}\n"}
{"sample_id": "train.2461", "db_id": "movie_1", "question": "What are the different names of all reviewers whose ratings do not have a date field?", "rationale": ["We need to find the names of reviewers whose ratings do not have a date field, which means we are looking for records in the Rating table where the ratingDate is NULL.", "To achieve this, we will join the Reviewer table with the Rating table on the reviewer ID (rID).", "We will select distinct names from the Reviewer table to ensure that we do not have duplicate names in our result.", "The condition to filter the ratings without a date is specified in the WHERE clause as 'Rating.ratingDate IS NULL'."], "gold_sql": "SELECT DISTINCT name FROM Reviewer AS T1 JOIN Rating AS T2 ON T1.rID  =  T2.rID WHERE ratingDate  =  'null'", "source_tables": ["rating", "reviewer"], "pred_sql": "SELECT DISTINCT Reviewer.name \nFROM Reviewer \nJOIN Rating ON Reviewer.rID = Rating.rID \nWHERE Rating.ratingDate IS NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the unique identifiers of reviewers from the 'Rating' table who have given a rating that is not equal to a specified number of stars. The placeholder in the WHERE clause represents the number of stars.\",\n    \"1\": \"This virtual table lists the distinct names of reviewers who submitted ratings on a specific date. The query joins the 'Reviewer' and 'Rating' tables based on the reviewer's ID, filtering the results by the date of the rating submission.\",\n    \"2\": \"This virtual table describes the unique identifiers of reviewers from the 'Rating' table who have given a rating that is not equal to a specified number of stars. The placeholder in the WHERE clause represents the number of stars to filter out.\"\n}\n"}
{"sample_id": "train.2476", "db_id": "movie_1", "question": "Find the names of all reviewers who rated Gone with the Wind.", "rationale": ["Identify the tables involved: Reviewer, Rating, and Movie.", "We need to find the names of reviewers, so we will select the 'name' column from the Reviewer table.", "To link reviewers to their ratings, we will join the Reviewer table with the Rating table on the rID column.", "Next, we need to link the ratings to the movies, so we will join the Rating table with the Movie table on the mID column.", "We need to filter the results to only include ratings for the movie titled 'Gone with the Wind', so we will add a WHERE clause to specify this title."], "gold_sql": "SELECT DISTINCT T3.name FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID JOIN Reviewer AS T3 ON T1.rID  =  T3.rID WHERE T2.title  =  'Gone with the Wind'", "source_tables": ["rating", "movie", "reviewer"], "pred_sql": "SELECT Reviewer.name \nFROM Reviewer \nJOIN Rating ON Reviewer.rID = Rating.rID \nJOIN Movie ON Rating.mID = Movie.mID \nWHERE Movie.title = 'Gone with the Wind';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct names of reviewers who submitted ratings on a specific date. The query joins the 'Reviewer' and 'Rating' tables based on the reviewer's ID, filtering the results by the date of the rating submission.\",\n    \"1\": \"This virtual table describes the unique identifiers of reviewers from the 'Rating' table who have given a rating that is not equal to a specified number of stars. The placeholder in the WHERE clause represents the number of stars.\",\n    \"2\": \"This virtual table describes the unique identifiers of reviewers from the 'Rating' table who have given a rating that is not equal to a specified number of stars. The placeholder in the WHERE clause represents the number of stars to filter out.\"\n}\n"}
{"sample_id": "train.2483", "db_id": "movie_1", "question": "What are the names of all the reviewers and movie names?", "rationale": ["We need to retrieve the names of all reviewers and the titles of the movies they rated.", "To do this, we will join the 'Reviewer' table with the 'Rating' table on the reviewer ID (rID).", "Next, we will join the 'Rating' table with the 'Movie' table on the movie ID (mID).", "Finally, we will select the 'name' from the 'Reviewer' table and the 'title' from the 'Movie' table."], "gold_sql": "SELECT name FROM Reviewer UNION SELECT title FROM Movie", "source_tables": ["movie", "reviewer"], "pred_sql": "SELECT Reviewer.name, Movie.title\nFROM Reviewer\nJOIN Rating ON Reviewer.rID = Rating.rID\nJOIN Movie ON Rating.mID = Movie.mID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct names of reviewers who submitted ratings on a specific date. The query joins the 'Reviewer' and 'Rating' tables based on the reviewer's ID, filtering the results by the date of the rating submission.\",\n    \"1\": \"This virtual table lists the titles of movies from the 'Movie' table that have received ratings within a specified range of stars. The placeholders in the WHERE clause represent the minimum and maximum star ratings.\",\n    \"2\": \"This virtual table describes the unique identifiers of reviewers from the 'Rating' table who have given a rating that is not equal to a specified number of stars. The placeholder in the WHERE clause represents the number of stars to filter out.\"\n}\n"}
{"sample_id": "train.2495", "db_id": "movie_1", "question": "For each director, how many reviews have they received?", "rationale": ["We need to find out how many reviews each director has received.", "To do this, we will join the 'Movie' table with the 'Rating' table on the movie ID (mID).", "We will select the director's name from the 'Movie' table and count the number of ratings (reviews) from the 'Rating' table.", "The COUNT function will count the number of ratings for each director.", "Finally, we will group the results by the director's name to get the total count of reviews for each director."], "gold_sql": "SELECT count(*) ,  T1.director FROM Movie AS T1 JOIN Rating AS T2 ON T1.mID  =  T2.mID GROUP BY T1.director", "source_tables": ["rating", "movie"], "pred_sql": "SELECT Movie.director, COUNT(Rating.rID) AS review_count\nFROM Movie\nJOIN Rating ON Movie.mID = Rating.mID\nGROUP BY Movie.director;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct names of reviewers who submitted ratings on a specific date. The query joins the 'Reviewer' and 'Rating' tables based on the reviewer's ID, filtering the results by the date of the rating submission.\",\n    \"1\": \"This virtual table describes the unique identifiers of reviewers from the 'Rating' table who have given a rating that is not equal to a specified number of stars. The placeholder in the WHERE clause represents the number of stars.\",\n    \"2\": \"This virtual table describes the unique identifiers of reviewers from the 'Rating' table who have given a rating that is not equal to a specified number of stars. The placeholder in the WHERE clause represents the number of stars to filter out.\"\n}\n"}
{"sample_id": "train.2500", "db_id": "movie_1", "question": "What are the names and years of the movies that has the top 3 highest rating star?", "rationale": ["Identify the relevant tables: Movie and Rating are needed to get movie titles and their ratings.", "We need to join the Movie table with the Rating table on the movie ID (mID) to access both movie titles and their corresponding ratings.", "We want to order the results by the number of stars in descending order to get the highest ratings first.", "Finally, we limit the results to the top 3 highest ratings to meet the requirement of the query."], "gold_sql": "SELECT T2.title ,  T2.year FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID ORDER BY T1.stars DESC LIMIT 3", "source_tables": ["rating", "movie"], "pred_sql": "SELECT title, year \nFROM Movie \nJOIN Rating ON Movie.mID = Rating.mID \nORDER BY stars DESC \nLIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the titles of movies from the 'Movie' table that have received ratings within a specified range of stars. The placeholders in the WHERE clause represent the minimum and maximum star ratings.\",\n    \"1\": \"This virtual table lists the distinct names of reviewers who submitted ratings on a specific date. The query joins the 'Reviewer' and 'Rating' tables based on the reviewer's ID, filtering the results by the date of the rating submission.\",\n    \"2\": \"This virtual table describes the unique identifiers of reviewers from the 'Rating' table who have given a rating that is not equal to a specified number of stars. The placeholder in the WHERE clause represents the number of stars to filter out.\"\n}\n"}
{"sample_id": "train.2502", "db_id": "movie_1", "question": "For each director, return the director's name together with the title of the movie they directed that received the highest rating among all of their movies, and the value of that rating. Ignore movies whose director is NULL.", "rationale": ["We need to find the highest-rated movie for each director.", "First, we will join the 'Movie' table with the 'Rating' table on the movie ID (mID).", "We will filter out any movies where the director is NULL using a WHERE clause.", "Next, we will group the results by director and movie title to aggregate the ratings.", "To find the highest rating for each director, we will use the MAX function on the stars column.", "Finally, we will use a HAVING clause to ensure we only return the movie with the highest rating for each director."], "gold_sql": "SELECT T2.title ,  T1.stars ,  T2.director ,  max(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE director != 'null' GROUP BY director", "source_tables": ["rating", "movie"], "pred_sql": "SELECT m.director, m.title, MAX(r.stars) AS highest_rating\nFROM Movie m\nJOIN Rating r ON m.mID = r.mID\nWHERE m.director IS NOT NULL\nGROUP BY m.director, m.title\nHAVING r.stars = (SELECT MAX(stars) FROM Rating WHERE mID = m.mID)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the titles of movies from the 'Movie' table that have received ratings within a specified range of stars. The placeholders in the WHERE clause represent the minimum and maximum star ratings.\",\n    \"1\": \"This virtual table lists the distinct names of reviewers who submitted ratings on a specific date. The query joins the 'Reviewer' and 'Rating' tables based on the reviewer's ID, filtering the results by the date of the rating submission.\"\n}\n"}
{"sample_id": "train.2503", "db_id": "movie_1", "question": "For each director, what are the titles and ratings for all the movies they reviewed?", "rationale": ["We need to retrieve the titles and ratings of movies for each director.", "The relevant tables are Movie, Rating, and Reviewer.", "We will join the Movie table with the Rating table on the movie ID (mID) to get the ratings for each movie.", "Next, we will join the Reviewer table with the Rating table on the reviewer ID (rID) to get the names of the reviewers.", "Finally, we will select the director's name, movie title, and the stars given in the rating from the joined tables."], "gold_sql": "SELECT T2.title ,  T1.stars ,  T2.director ,  max(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE director != 'null' GROUP BY director", "source_tables": ["rating", "movie"], "pred_sql": "SELECT Movie.director, Movie.title, Rating.stars \nFROM Movie \nJOIN Rating ON Movie.mID = Rating.mID \nJOIN Reviewer ON Rating.rID = Reviewer.rID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the titles of movies from the 'Movie' table that have received ratings within a specified range of stars. The placeholders in the WHERE clause represent the minimum and maximum star ratings.\",\n    \"1\": \"This virtual table lists the distinct names of reviewers who submitted ratings on a specific date. The query joins the 'Reviewer' and 'Rating' tables based on the reviewer's ID, filtering the results by the date of the rating submission.\",\n    \"2\": \"This virtual table describes the unique identifiers of reviewers from the 'Rating' table who have given a rating that is not equal to a specified number of stars. The placeholder in the WHERE clause represents the number of stars to filter out.\"\n}\n"}
{"sample_id": "train.2505", "db_id": "movie_1", "question": "For each reviewer id, what is the title and rating for the movie with the smallest rating?", "rationale": ["We need to find the title and rating for the movie with the smallest rating for each reviewer.", "To do this, we will select the reviewer ID (r.rID), movie title (m.title), and the stars given (r.stars) from the Rating and Movie tables.", "We will join the Rating table with the Movie table on the movie ID (mID) to get the movie titles.", "To find the smallest rating for each reviewer, we will use a subquery that selects the minimum stars from the Rating table where the reviewer ID matches the current reviewer in the outer query.", "The final query will return the reviewer ID, movie title, and the smallest rating for each reviewer."], "gold_sql": "SELECT T2.title ,  T1.rID ,  T1.stars ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.rID", "source_tables": ["rating", "movie"], "pred_sql": "SELECT r.rID, m.title, r.stars \nFROM Rating r \nJOIN Movie m ON r.mID = m.mID \nWHERE r.stars = (SELECT MIN(stars) \n                 FROM Rating r2 \n                 WHERE r2.rID = r.rID)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the titles of movies from the 'Movie' table that have received ratings within a specified range of stars. The placeholders in the WHERE clause represent the minimum and maximum star ratings.\",\n    \"1\": \"This virtual table describes the unique identifiers of reviewers from the 'Rating' table who have given a rating that is not equal to a specified number of stars. The placeholder in the WHERE clause represents the number of stars to filter out.\",\n    \"2\": \"This virtual table describes the unique identifiers of reviewers from the 'Rating' table who have given a rating that is not equal to a specified number of stars. The placeholder in the WHERE clause represents the number of stars.\"\n}\n"}
{"sample_id": "train.2507", "db_id": "movie_1", "question": "For each director, what is the title and score of their most poorly rated movie?", "rationale": ["We need to find the title and score of the most poorly rated movie for each director.", "To do this, we will join the Movie table with the Rating table on the movie ID (mID).", "We will group the results by director and movie title to aggregate the ratings.", "We will use the MIN function to find the lowest rating for each movie.", "To ensure we only get the most poorly rated movie for each director, we will use a HAVING clause that compares the lowest rating of each movie to the minimum rating of all movies directed by the same director.", "Finally, we will order the results by director to make it easier to read."], "gold_sql": "SELECT T2.title ,  T1.stars ,  T2.director ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T2.director", "source_tables": ["rating", "movie"], "pred_sql": "SELECT m.title, MIN(r.stars) AS lowest_rating, m.director \nFROM Movie m \nJOIN Rating r ON m.mID = r.mID \nGROUP BY m.director, m.title \nHAVING lowest_rating = (SELECT MIN(stars) \n                       FROM Rating r2 \n                       JOIN Movie m2 ON r2.mID = m2.mID \n                       WHERE m2.director = m.director) \nORDER BY m.director;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the titles of movies from the 'Movie' table that have received ratings within a specified range of stars. The placeholders in the WHERE clause represent the minimum and maximum star ratings.\",\n    \"1\": \"This virtual table describes the unique identifiers of reviewers from the 'Rating' table who have given a rating that is not equal to a specified number of stars. The placeholder in the WHERE clause represents the number of stars.\",\n    \"2\": \"This virtual table describes the unique identifiers of reviewers from the 'Rating' table who have given a rating that is not equal to a specified number of stars. The placeholder in the WHERE clause represents the number of stars to filter out.\"\n}\n"}
{"sample_id": "train.2508", "db_id": "movie_1", "question": "What is the name of the movie that is rated by most of times?", "rationale": ["Identify the tables involved: We need to get the movie title from the 'Movie' table and the ratings from the 'Rating' table.", "Join the 'Movie' and 'Rating' tables on the movie ID (mID) to link ratings to their respective movies.", "Group the results by movie ID to count how many times each movie has been rated.", "Order the results in descending order based on the count of ratings to find the movie with the most ratings.", "Limit the results to 1 to get only the top movie that has been rated the most times."], "gold_sql": "SELECT T2.title ,  T1.mID FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY count(*) DESC LIMIT 1", "source_tables": ["rating", "movie"], "pred_sql": "SELECT Movie.title\nFROM Movie\nJOIN Rating ON Movie.mID = Rating.mID\nGROUP BY Movie.mID\nORDER BY COUNT(Rating.mID) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the titles of movies from the 'Movie' table that have received ratings within a specified range of stars. The placeholders in the WHERE clause represent the minimum and maximum star ratings.\",\n    \"1\": \"This virtual table lists the distinct names of reviewers who submitted ratings on a specific date. The query joins the 'Reviewer' and 'Rating' tables based on the reviewer's ID, filtering the results by the date of the rating submission.\"\n}\n"}
{"sample_id": "train.2509", "db_id": "movie_1", "question": "What is the name of the movie that has been reviewed the most?", "rationale": ["To find the movie that has been reviewed the most, we need to count the number of reviews for each movie.", "We can achieve this by grouping the ratings by movie ID (mID) in the Rating table and counting the number of entries for each movie.", "Next, we will order these counts in descending order to get the movie with the highest number of reviews at the top.", "Finally, we will limit the results to just one entry to get the top movie.", "We will then use the movie ID from the previous step to select the corresponding title from the Movie table."], "gold_sql": "SELECT T2.title ,  T1.mID FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY count(*) DESC LIMIT 1", "source_tables": ["rating", "movie"], "pred_sql": "SELECT title FROM Movie WHERE mID IN (SELECT mID FROM Rating GROUP BY mID ORDER BY COUNT(*) DESC LIMIT 1);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the titles of movies from the 'Movie' table that have received ratings within a specified range of stars. The placeholders in the WHERE clause represent the minimum and maximum star ratings.\",\n    \"1\": \"This virtual table lists the distinct names of reviewers who submitted ratings on a specific date. The query joins the 'Reviewer' and 'Rating' tables based on the reviewer's ID, filtering the results by the date of the rating submission.\"\n}\n"}
{"sample_id": "train.2517", "db_id": "movie_1", "question": "What are the ids of all moviest hat have not been reviewed by Britanny Harris?", "rationale": ["Identify the movies that have not been reviewed by Britanny Harris.", "To do this, we need to find the IDs of the movies that have been reviewed by her.", "We can achieve this by first selecting the rID of Britanny Harris from the Reviewer table.", "Next, we will use this rID to find all mIDs from the Rating table that correspond to her reviews.", "Finally, we will select all mIDs from the Movie table that are not in the list of mIDs reviewed by Britanny Harris."], "gold_sql": "SELECT mID FROM Rating EXCEPT SELECT T1.mID FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T2.name  =  'Brittany Harris'", "source_tables": ["rating", "reviewer"], "pred_sql": "SELECT mID FROM Movie WHERE mID NOT IN (SELECT mID FROM Rating WHERE rID IN (SELECT rID FROM Reviewer WHERE name = 'Britanny Harris'));", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the unique identifiers of reviewers from the 'Rating' table who have given a rating that is not equal to a specified number of stars. The placeholder in the WHERE clause represents the number of stars.\",\n    \"1\": \"This virtual table describes the unique identifiers of reviewers from the 'Rating' table who have given a rating that is not equal to a specified number of stars. The placeholder in the WHERE clause represents the number of stars to filter out.\",\n    \"2\": \"This virtual table lists the titles of movies from the 'Movie' table that have received ratings within a specified range of stars. The placeholders in the WHERE clause represent the minimum and maximum star ratings.\"\n}\n"}
{"sample_id": "train.2518", "db_id": "movie_1", "question": "Find the average rating star for each movie that received at least 2 ratings.", "rationale": ["We need to find the average rating star for each movie that has received at least 2 ratings.", "To do this, we will join the 'Movie' table with the 'Rating' table on the movie ID (mID).", "We will use the AVG() function to calculate the average of the stars given in the ratings.", "We will group the results by the movie ID to ensure we get the average rating for each movie.", "To filter the results to only include movies that have received at least 2 ratings, we will use the HAVING clause with COUNT(Rating.rID) >= 2."], "gold_sql": "SELECT mID ,  avg(stars) FROM Rating GROUP BY mID HAVING count(*)  >=  2", "source_tables": ["rating"], "pred_sql": "SELECT Movie.title, AVG(Rating.stars) AS average_rating\nFROM Movie\nJOIN Rating ON Movie.mID = Rating.mID\nGROUP BY Movie.mID\nHAVING COUNT(Rating.rID) >= 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the titles of movies from the 'Movie' table that have received ratings within a specified range of stars. The placeholders in the WHERE clause represent the minimum and maximum star ratings.\",\n    \"1\": \"This virtual table describes the unique identifiers of reviewers from the 'Rating' table who have given a rating that is not equal to a specified number of stars. The placeholder in the WHERE clause represents the number of stars to filter out.\",\n    \"2\": \"This virtual table describes the unique identifiers of reviewers from the 'Rating' table who have given a rating that is not equal to a specified number of stars. The placeholder in the WHERE clause represents the number of stars.\"\n}\n"}
{"sample_id": "train.2528", "db_id": "movie_1", "question": "What are the names of reviewers who had rated 3 star and 4 star?", "rationale": ["We need to find the names of reviewers who rated movies with 3 stars and 4 stars.", "To do this, we will join the 'Reviewer' table with the 'Rating' table using the common column 'rID'.", "We will select the distinct names of reviewers to avoid duplicates.", "In the WHERE clause, we will filter the ratings to include only those that are either 3 or 4 stars using the IN operator."], "gold_sql": "SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T1.stars  =  3 INTERSECT SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T1.stars  =  4", "source_tables": ["rating", "reviewer"], "pred_sql": "SELECT DISTINCT Reviewer.name \nFROM Reviewer \nJOIN Rating ON Reviewer.rID = Rating.rID \nWHERE Rating.stars IN ('3', '4');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the unique identifiers of reviewers from the 'Rating' table who have given a rating that is not equal to a specified number of stars. The placeholder in the WHERE clause represents the number of stars.\",\n    \"1\": \"This virtual table describes the unique identifiers of reviewers from the 'Rating' table who have given a rating that is not equal to a specified number of stars. The placeholder in the WHERE clause represents the number of stars to filter out.\",\n    \"2\": \"This virtual table lists the distinct names of reviewers who submitted ratings on a specific date. The query joins the 'Reviewer' and 'Rating' tables based on the reviewer's ID, filtering the results by the date of the rating submission.\"\n}\n"}
{"sample_id": "train.2530", "db_id": "movie_1", "question": "What are the names of movies that get 3 star and 4 star?", "rationale": ["We need to find the names of movies that received ratings of 3 stars and 4 stars.", "To do this, we will join the 'Movie' table with the 'Rating' table on the movie ID (mID).", "We will then filter the results to include only those ratings that are either 3 or 4 stars using the IN clause.", "Finally, we will select the distinct titles of the movies to avoid duplicates in the result set."], "gold_sql": "SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  3 INTERSECT SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  4", "source_tables": ["rating", "movie"], "pred_sql": "SELECT DISTINCT Movie.title \nFROM Movie \nJOIN Rating ON Movie.mID = Rating.mID \nWHERE Rating.stars IN ('3', '4');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the titles of movies from the 'Movie' table that have received ratings within a specified range of stars. The placeholders in the WHERE clause represent the minimum and maximum star ratings.\",\n    \"1\": \"This virtual table describes the unique identifiers of reviewers from the 'Rating' table who have given a rating that is not equal to a specified number of stars. The placeholder in the WHERE clause represents the number of stars to filter out.\",\n    \"2\": \"This virtual table describes the unique identifiers of reviewers from the 'Rating' table who have given a rating that is not equal to a specified number of stars. The placeholder in the WHERE clause represents the number of stars.\"\n}\n"}
{"sample_id": "train.2576", "db_id": "inn_1", "question": "Find the most popular room in the hotel. The most popular room is the room that had seen the largest number of reservations.", "rationale": ["Identify the tables involved: Rooms and Reservations.", "To find the most popular room, we need to count the number of reservations for each room.", "Join the Rooms table with the Reservations table on the RoomId to get the relevant data.", "Group the results by RoomId to aggregate the count of reservations for each room.", "Order the results by the count of reservations in descending order to get the most popular room at the top.", "Limit the results to 1 to get only the most popular room."], "gold_sql": "SELECT T2.roomName FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT Rooms.roomName, COUNT(Reservations.Code) AS reservation_count\nFROM Rooms\nJOIN Reservations ON Rooms.RoomId = Reservations.Room\nGROUP BY Rooms.RoomId\nORDER BY reservation_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of reservations where the total number of occupants (adults and kids) matches the maximum occupancy allowed for each room. It joins the 'Reservations' table with the 'Rooms' table based on the room identifier, ensuring that only those reservations that meet the occupancy criteria are counted.\",\n    \"1\": \"This virtual table provides a list of room identifiers and their names from the 'Rooms' table, sorted by the base price in descending order. The placeholder in the LIMIT clause represents the maximum number of rooms to be displayed.\",\n    \"2\": \"This virtual table calculates the total number of beds available in rooms of a specific bed type from the 'Rooms' table. The placeholder in the WHERE clause represents the type of bed being queried.\"\n}\n"}
{"sample_id": "train.2577", "db_id": "inn_1", "question": "Which room has the largest number of reservations?", "rationale": ["Identify the relevant tables: Rooms and Reservations.", "We need to count the number of reservations for each room, so we will join the Rooms table with the Reservations table on the RoomId.", "Use COUNT() to count the number of reservations (using the unique reservation code) for each room.", "Group the results by the RoomId to get the count per room.", "Order the results by the count of reservations in descending order to find the room with the largest number of reservations.", "Limit the results to 1 to get only the room with the highest count."], "gold_sql": "SELECT T2.roomName FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT Rooms.roomName, COUNT(Reservations.Code) AS reservation_count\nFROM Rooms\nJOIN Reservations ON Rooms.RoomId = Reservations.Room\nGROUP BY Rooms.RoomId\nORDER BY reservation_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of reservations where the total number of occupants (adults and kids) matches the maximum occupancy allowed for each room. It joins the 'Reservations' table with the 'Rooms' table based on the room identifier, ensuring that only those reservations that meet the occupancy criteria are counted.\",\n    \"1\": \"This virtual table provides a list of room identifiers and their names from the 'Rooms' table, sorted by the base price in descending order. The placeholder in the LIMIT clause represents the maximum number of rooms to be displayed.\",\n    \"2\": \"This virtual table calculates the total number of beds available in rooms of a specific bed type from the 'Rooms' table. The placeholder in the WHERE clause represents the type of bed being queried.\"\n}\n"}
{"sample_id": "train.2578", "db_id": "inn_1", "question": "How many kids stay in the rooms reserved by ROY SWEAZY?", "rationale": ["Identify the relevant tables: Reservations and Rooms.", "Determine the information needed: total number of kids from reservations made by ROY SWEAZY.", "Use the Reservations table to filter by the guest's name (LastName and FirstName).", "Sum the number of kids from the filtered reservations to get the total count."], "gold_sql": "SELECT kids FROM Reservations WHERE FirstName = 'ROY' AND LastName  =  'SWEAZY';", "source_tables": ["reservations"], "pred_sql": "SELECT SUM(Kids) AS TotalKids\nFROM Reservations\nWHERE LastName = 'SWEAZY' AND FirstName = 'ROY';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of reservations where the total number of occupants (adults and kids) matches the maximum occupancy allowed for each room. It joins the 'Reservations' table with the 'Rooms' table based on the room identifier, ensuring that only those reservations that meet the occupancy criteria are counted.\",\n    \"1\": \"This virtual table provides the count of rooms from the 'Rooms' table that have a specific type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\"\n}\n"}
{"sample_id": "train.2582", "db_id": "inn_1", "question": "Which room has the highest rate? List the room's full name, rate, check in and check out date.", "rationale": ["Identify the relevant tables: Rooms and Reservations.", "We need to find the room with the highest rate, which is stored in the Reservations table under the Rate column.", "Join the Rooms table with the Reservations table on the RoomId to access room names along with their rates.", "Sort the results by the Rate in descending order to get the highest rate at the top.", "Limit the results to 1 to get only the room with the highest rate.", "Select the room's full name (roomName), rate (Rate), check-in date (CheckIn), and check-out date (CheckOut) for the final output."], "gold_sql": "SELECT T2.roomName ,  T1.Rate ,  T1.CheckIn ,  T1.CheckOut FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY T1.Rate DESC LIMIT 1;", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT r.roomName, res.Rate, res.CheckIn, res.CheckOut \nFROM Rooms r \nJOIN Reservations res ON r.RoomId = res.Room \nORDER BY res.Rate DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of room identifiers and their names from the 'Rooms' table, sorted by the base price in descending order. The placeholder in the LIMIT clause represents the maximum number of rooms to be displayed.\",\n    \"1\": \"This virtual table provides a count of reservations where the total number of occupants (adults and kids) matches the maximum occupancy allowed for each room. It joins the 'Reservations' table with the 'Rooms' table based on the room identifier, ensuring that only those reservations that meet the occupancy criteria are counted.\",\n    \"2\": \"This virtual table provides the count of rooms from the 'Rooms' table that have a specific type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\"\n}\n"}
{"sample_id": "train.2583", "db_id": "inn_1", "question": "Return the name, rate, check in and check out date for the room with the highest rate.", "rationale": ["Identify the required fields: room name, rate, check-in date, and check-out date.", "Join the 'Rooms' table with the 'Reservations' table on the RoomId to access the necessary information from both tables.", "Use a subquery to find the maximum rate from the 'Reservations' table.", "Filter the results to only include the reservation(s) with the highest rate."], "gold_sql": "SELECT T2.roomName ,  T1.Rate ,  T1.CheckIn ,  T1.CheckOut FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY T1.Rate DESC LIMIT 1;", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT r.roomName, res.Rate, res.CheckIn, res.CheckOut \nFROM Rooms r \nJOIN Reservations res ON r.RoomId = res.Room \nWHERE res.Rate = (SELECT MAX(Rate) FROM Reservations)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of room identifiers and their names from the 'Rooms' table, sorted by the base price in descending order. The placeholder in the LIMIT clause represents the maximum number of rooms to be displayed.\",\n    \"1\": \"This virtual table provides a count of reservations where the total number of occupants (adults and kids) matches the maximum occupancy allowed for each room. It joins the 'Reservations' table with the 'Rooms' table based on the room identifier, ensuring that only those reservations that meet the occupancy criteria are counted.\"\n}\n"}
{"sample_id": "train.2589", "db_id": "inn_1", "question": "Find the total number of king beds available.", "rationale": ["Identify the relevant table: The 'Rooms' table contains information about the beds available in each room.", "Determine the specific bed type: The query is focused on counting the total number of 'king' beds.", "Use the SUM function: To get the total number of king beds, we will sum the 'beds' column for rooms that have 'king' as their bed type.", "Construct the SQL query: The final SQL query selects the sum of beds from the 'Rooms' table where the bed type is 'king'."], "gold_sql": "SELECT sum(beds) FROM Rooms WHERE bedtype  =  'King';", "source_tables": ["rooms"], "pred_sql": "SELECT SUM(beds) AS total_king_beds FROM Rooms WHERE bedType = 'king';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the total number of beds available in rooms of a specific bed type from the 'Rooms' table. The placeholder in the WHERE clause represents the type of bed being queried.\",\n    \"1\": \"This virtual table provides the count of rooms from the 'Rooms' table that have a specific type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\",\n    \"2\": \"This virtual table provides a count of reservations where the total number of occupants (adults and kids) matches the maximum occupancy allowed for each room. It joins the 'Reservations' table with the 'Rooms' table based on the room identifier, ensuring that only those reservations that meet the occupancy criteria are counted.\"\n}\n"}
{"sample_id": "train.2590", "db_id": "inn_1", "question": "List the names and decor of rooms that have a king bed. Sort the list by their price.", "rationale": ["Identify the relevant table: The 'Rooms' table contains the information about room names, decor, and bed types.", "Determine the required columns: We need to select 'roomName' and 'decor' from the 'Rooms' table.", "Apply the filter: We need to filter the rooms to only include those with a 'king' bed, which is done using the WHERE clause.", "Sort the results: The results should be sorted by 'basePrice' in ascending order, which is done using the ORDER BY clause."], "gold_sql": "SELECT roomName ,  decor FROM Rooms WHERE bedtype  =  'King' ORDER BY basePrice;", "source_tables": ["rooms"], "pred_sql": "SELECT roomName, decor FROM Rooms WHERE bedType = 'king' ORDER BY basePrice;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of room identifiers and their names from the 'Rooms' table, sorted by the base price in descending order. The placeholder in the LIMIT clause represents the maximum number of rooms to be displayed.\",\n    \"1\": \"This virtual table provides the count of rooms from the 'Rooms' table that have a specific type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\"\n}\n"}
{"sample_id": "train.2594", "db_id": "inn_1", "question": "What is the decor of room Recluse and defiance?", "rationale": ["Identify the relevant table: The question pertains to the decor of specific rooms, which are listed in the 'Rooms' table.", "Determine the columns needed: We need the 'decor' column from the 'Rooms' table.", "Filter the results: We need to filter the rooms by their names, which are 'Recluse' and 'defiance'.", "Construct the SQL query: Use a SELECT statement to retrieve the 'decor' for the specified room names."], "gold_sql": "SELECT decor FROM Rooms WHERE roomName  =  'Recluse and defiance';", "source_tables": ["rooms"], "pred_sql": "SELECT decor FROM Rooms WHERE roomName IN ('Recluse', 'defiance');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of room identifiers and their names from the 'Rooms' table, sorted by the base price in descending order. The placeholder in the LIMIT clause represents the maximum number of rooms to be displayed.\",\n    \"1\": \"This virtual table provides a count of reservations where the total number of occupants (adults and kids) matches the maximum occupancy allowed for each room. It joins the 'Reservations' table with the 'Rooms' table based on the room identifier, ensuring that only those reservations that meet the occupancy criteria are counted.\"\n}\n"}
{"sample_id": "train.2604", "db_id": "inn_1", "question": "Find the first and last names of people who payed more than the rooms' base prices.", "rationale": ["Identify the tables involved: Reservations and Rooms.", "We need to find the first and last names of guests, which are in the Reservations table.", "We need to compare the Rate from the Reservations table with the basePrice from the Rooms table.", "To do this, we will join the Reservations table with the Rooms table on the Room identifier (RoomId).", "The condition for the query is that the Rate in Reservations must be greater than the basePrice in Rooms.", "Select the FirstName and LastName from the Reservations table where the condition is met."], "gold_sql": "SELECT T1.firstname ,  T1.lastname FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T1.Rate - T2.basePrice  >  0", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT r.FirstName, r.LastName\nFROM Reservations r\nJOIN Rooms rm ON r.Room = rm.RoomId\nWHERE r.Rate > rm.basePrice;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of room identifiers and their names from the 'Rooms' table, sorted by the base price in descending order. The placeholder in the LIMIT clause represents the maximum number of rooms to be displayed.\"\n}\n"}
{"sample_id": "train.2609", "db_id": "inn_1", "question": "How many rooms have a king bed?", "rationale": ["Identify the relevant table: The question pertains to the 'Rooms' table, which contains information about room types and bed types.", "Determine the specific condition: The question asks for rooms that have a king bed, which corresponds to the 'bedType' column in the 'Rooms' table.", "Construct the SQL query: Use the COUNT function to count the number of rooms that meet the condition of having a 'king' bed type."], "gold_sql": "SELECT count(*) FROM Rooms WHERE bedType  =  'King';", "source_tables": ["rooms"], "pred_sql": "SELECT COUNT(*) AS RoomCount FROM Rooms WHERE bedType = 'king';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of rooms from the 'Rooms' table that have a specific type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\",\n    \"1\": \"This virtual table provides a count of reservations where the total number of occupants (adults and kids) matches the maximum occupancy allowed for each room. It joins the 'Reservations' table with the 'Rooms' table based on the room identifier, ensuring that only those reservations that meet the occupancy criteria are counted.\",\n    \"2\": \"This virtual table calculates the total number of beds available in rooms of a specific bed type from the 'Rooms' table. The placeholder in the WHERE clause represents the type of bed being queried.\"\n}\n"}
