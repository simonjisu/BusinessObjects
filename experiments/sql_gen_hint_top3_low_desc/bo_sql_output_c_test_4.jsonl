{"sample_id": "train.4750", "db_id": "department_store", "question": "What is the id and name of the staff who has been assigned for the least amount of time?", "rationale": ["Identify the relevant tables: Staff and Staff_Department_Assignments are needed to get staff details and their assignment information.", "Join the Staff table with the Staff_Department_Assignments table on staff_id to link staff members with their assignments.", "Order the results by the date_assigned_from column in ascending order to find the staff member who has been assigned for the least amount of time.", "Limit the results to 1 to get only the staff member with the least assignment duration."], "gold_sql": "SELECT T1.staff_id ,  T1.staff_name FROM staff AS T1 JOIN Staff_Department_Assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY date_assigned_to - date_assigned_from LIMIT 1", "source_tables": ["staff_department_assignments", "staff"], "pred_sql": "SELECT staff.staff_id, staff.staff_name\nFROM Staff\nJOIN Staff_Department_Assignments ON Staff.staff_id = Staff_Department_Assignments.staff_id\nORDER BY Staff_Department_Assignments.date_assigned_from ASC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of staff members along with their job titles from the 'Staff' and 'Staff_Department_Assignments' tables. The results are ordered by the end date of their assignments, allowing users to see the most recently assigned staff members first. The placeholder in the LIMIT clause represents the maximum number of records to return.\",\n    \"1\": \"This virtual table provides a list of staff members along with their job titles from the 'Staff' and 'Staff_Department_Assignments' tables. The results are ordered by the end date of their assignments, allowing users to see the most recently assigned staff members first. The placeholder in the LIMIT clause represents the maximum number of records to return.\"\n}\n"}
{"sample_id": "train.4753", "db_id": "department_store", "question": "Find the ids of all distinct customers who made order after some orders that were Cancelled.", "rationale": ["Identify the main table to query: Customer_Orders, as we need customer IDs related to orders.", "We need to find customers who made orders after some orders that were cancelled. This requires a subquery to find cancelled orders.", "The subquery selects order IDs from Customer_Orders where the order status is 'Cancelled'.", "We also need to ensure that the order date of the cancelled order is before the order date of the current order, which is represented by co.order_date in the main query.", "The main query selects distinct customer IDs from Customer_Orders where the order ID is in the results of the subquery."], "gold_sql": "SELECT DISTINCT customer_id FROM Customer_Orders WHERE order_date  >  (SELECT min(order_date) FROM Customer_Orders WHERE order_status_code  =  'Cancelled')", "source_tables": ["customer_orders"], "pred_sql": "SELECT DISTINCT co.customer_id\nFROM Customer_Orders co\nWHERE co.order_id IN (\n    SELECT co2.order_id\n    FROM Customer_Orders co2\n    WHERE co2.order_status_code = 'Cancelled'\n    AND co2.order_date < co.order_date\n)", "hint": "\n"}
{"sample_id": "train.4755", "db_id": "department_store", "question": "What is id of the staff who had a Staff Department Assignment earlier than any Clerical Staff?", "rationale": ["We need to find the staff members who had a department assignment earlier than any Clerical Staff.", "To do this, we will first identify the minimum end date of assignments for Clerical Staff members.", "We will join the Staff_Department_Assignments table with the Staff table to filter for Clerical Staff using their job title code.", "Once we have the minimum date for Clerical Staff, we will select staff members from Staff_Department_Assignments whose assignment end date is earlier than this minimum date."], "gold_sql": "SELECT staff_id FROM Staff_Department_Assignments WHERE date_assigned_to  <  (SELECT max(date_assigned_to) FROM Staff_Department_Assignments WHERE job_title_code  =  'Clerical Staff')", "source_tables": ["staff_department_assignments"], "pred_sql": "SELECT staff_id FROM Staff_Department_Assignments AS sda1\nWHERE date_assigned_to < (\n    SELECT MIN(date_assigned_to)\n    FROM Staff_Department_Assignments AS sda2\n    JOIN Staff AS st ON sda2.staff_id = st.staff_id\n    WHERE st.job_title_code = 'Clerical'\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of staff members along with their job titles from the 'Staff' and 'Staff_Department_Assignments' tables. The results are ordered by the end date of their assignments, allowing users to see the most recently assigned staff members first. The placeholder in the LIMIT clause represents the maximum number of records to return.\",\n    \"1\": \"This virtual table provides a list of staff members along with their job titles from the 'Staff' and 'Staff_Department_Assignments' tables. The results are ordered by the end date of their assignments, allowing users to see the most recently assigned staff members first. The placeholder in the LIMIT clause represents the maximum number of records to return.\"\n}\n"}
{"sample_id": "train.4758", "db_id": "department_store", "question": "Return the names and ids of customers who have TN in their address.", "rationale": ["Identify the relevant tables: Customers, Customer_Addresses, and Addresses.", "We need to retrieve customer names and IDs, so we will select 'customer_name' and 'customer_id' from the Customers table.", "To find customers with 'TN' in their address, we need to join the Customers table with the Customer_Addresses table on 'customer_id'.", "Next, we join the Customer_Addresses table with the Addresses table on 'address_id' to access the address details.", "Finally, we filter the results using a WHERE clause to find addresses that contain 'TN' in the 'address_details' column."], "gold_sql": "SELECT customer_name ,  customer_id FROM customers WHERE customer_address LIKE '%TN%'", "source_tables": ["customers"], "pred_sql": "SELECT Customers.customer_name, Customers.customer_id \nFROM Customers \nJOIN Customer_Addresses ON Customers.customer_id = Customer_Addresses.customer_id \nJOIN Addresses ON Customer_Addresses.address_id = Addresses.address_id \nWHERE Addresses.address_details LIKE '%TN%';", "hint": "\n"}
{"sample_id": "train.4760", "db_id": "department_store", "question": "What are the names and genders of staff who were assigned in 2016?", "rationale": ["Identify the relevant tables: Staff and Staff_Department_Assignments.", "We need to retrieve the names and genders of staff members, so we will select 'staff_name' and 'staff_gender' from the Staff table.", "To find out which staff members were assigned in 2016, we need to join the Staff table with the Staff_Department_Assignments table on 'staff_id'.", "We will filter the results based on the assignment dates, specifically looking for assignments that started and ended within the year 2016.", "The date range for 2016 is from '2016-01-01' to '2016-12-31'."], "gold_sql": "SELECT T1.staff_name ,  T1.staff_gender FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.date_assigned_from LIKE '2016%'", "source_tables": ["staff_department_assignments", "staff"], "pred_sql": "SELECT Staff.staff_name, Staff.staff_gender\nFROM Staff\nJOIN Staff_Department_Assignments ON Staff.staff_id = Staff_Department_Assignments.staff_id\nWHERE Staff_Department_Assignment.date_assigned_from >= '2016-01-01' AND Staff_Department_Assignment.date_assigned_to <= '2016-12-31';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of staff members along with their job titles from the 'Staff' and 'Staff_Department_Assignments' tables. The results are ordered by the end date of their assignments, allowing users to see the most recently assigned staff members first. The placeholder in the LIMIT clause represents the maximum number of records to return.\",\n    \"1\": \"This virtual table provides a list of staff members along with their job titles from the 'Staff' and 'Staff_Department_Assignments' tables. The results are ordered by the end date of their assignments, allowing users to see the most recently assigned staff members first. The placeholder in the LIMIT clause represents the maximum number of records to return.\"\n}\n"}
{"sample_id": "train.4762", "db_id": "department_store", "question": "What are the names of staff who have been assigned multiple jobs?", "rationale": ["Identify the relevant tables: Staff and Staff_Department_Assignments.", "We need to find staff members who have been assigned multiple jobs, which means we need to count the distinct job titles for each staff member.", "Use a subquery to group by staff_id in the Staff_Department_Assignments table and count the distinct job_title_code.", "Filter the results in the subquery to only include staff members with more than one distinct job title using HAVING COUNT(DISTINCT job_title_code) > 1.", "Select the staff_name from the Staff table where the staff_id is in the results of the subquery."], "gold_sql": "SELECT T1.staff_name FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id GROUP BY T2.staff_id HAVING COUNT (*)  >  1", "source_tables": ["staff_department_assignments", "staff"], "pred_sql": "SELECT staff_name\nFROM Staff\nWHERE staff_id IN (\n    SELECT staff_id\n    FROM Staff_Department_Assignments\n    GROUP BY staff_id\n    HAVING COUNT(DISTINCT job_title_code) > 1\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of staff members along with their job titles from the 'Staff' and 'Staff_Department_Assignments' tables. The results are ordered by the end date of their assignments, allowing users to see the most recently assigned staff members first. The placeholder in the LIMIT clause represents the maximum number of records to return.\",\n    \"1\": \"This virtual table provides a list of staff members along with their job titles from the 'Staff' and 'Staff_Department_Assignments' tables. The results are ordered by the end date of their assignments, allowing users to see the most recently assigned staff members first. The placeholder in the LIMIT clause represents the maximum number of records to return.\"\n}\n"}
{"sample_id": "train.4792", "db_id": "department_store", "question": "What are the ids and names of customers with addressed that contain WY and who do not use a credit card for payment?", "rationale": ["Identify the relevant table: Customers, which contains customer_id, customer_name, customer_address, and payment_method_code.", "Filter customers based on their address containing 'WY'. This can be done using the LIKE operator with wildcards.", "Exclude customers who use a credit card for payment by checking that payment_method_code is not equal to 'CREDIT_CARD'.", "Combine these conditions in the WHERE clause of the SQL query to retrieve the desired customer ids and names."], "gold_sql": "SELECT customer_id ,  customer_name FROM customers WHERE customer_address LIKE '%WY%' AND payment_method_code != 'Credit Card'", "source_tables": ["customers"], "pred_sql": "SELECT customer_id, customer_name \nFROM Customers \nWHERE customer_address LIKE '%WY%' \nAND payment_method_code != 'CREDIT_CARD';", "hint": "\n"}
{"sample_id": "train.4793", "db_id": "department_store", "question": "Find the average price of all product clothes.", "rationale": ["Identify the table needed: The 'Products' table contains the product prices.", "Determine the calculation needed: We need to calculate the average price, which can be done using the AVG() function.", "Specify the condition: We need to filter the products to only include those that are of the type 'clothes'.", "Construct the SQL query: Use SELECT to get the average price from the Products table where the product type code is 'clothes'."], "gold_sql": "SELECT avg(product_price) FROM products WHERE product_type_code  =  'Clothes'", "source_tables": ["products"], "pred_sql": "SELECT AVG(product_price) AS average_price FROM Products WHERE product_type_code = 'clothes';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average price of products from the 'Products' table that belong to a specific product type. The placeholder in the WHERE clause represents the product type code.\"\n}\n"}
{"sample_id": "train.4795", "db_id": "department_store", "question": "Find the name of the most expensive hardware product.", "rationale": ["Identify the relevant table: Products, which contains product details including name and price.", "Filter the products to only include those of type 'hardware' using the product_type_code column.", "Sort the filtered products by product_price in descending order to get the most expensive product at the top.", "Limit the results to 1 to get only the most expensive hardware product."], "gold_sql": "SELECT product_name FROM products WHERE product_type_code  =  'Hardware' ORDER BY product_price DESC LIMIT 1", "source_tables": ["products"], "pred_sql": "SELECT product_name FROM Products WHERE product_type_code = 'hardware' ORDER BY product_price DESC LIMIT 1;", "hint": "\n"}
{"sample_id": "train.4902", "db_id": "store_product", "question": "Find the list of page size which have more than 3 product listed", "rationale": ["We need to find the list of maximum page sizes for products that have more than 3 products listed.", "To do this, we will join the 'product' table with the 'store_product' table using the 'product_id' and 'Product_ID' columns.", "Next, we will group the results by 'max_page_size' to aggregate the products based on their maximum page size.", "Finally, we will use the HAVING clause to filter the groups where the count of products is greater than 3."], "gold_sql": "SELECT max_page_size FROM product GROUP BY max_page_size HAVING count(*)  >  3", "source_tables": ["product"], "pred_sql": "SELECT max_page_size\nFROM product\nJOIN store_product ON product.product_id = store_product.Product_ID\nGROUP BY max_page_size\nHAVING COUNT(store_product.Product_ID) > 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the products from the 'product' table that match a specific search criterion. The placeholder in the WHERE clause represents a pattern for the product name or description.\",\n    \"1\": \"This virtual table describes the products available in a specific store. The placeholder in the WHERE clause represents the name of the store for which the products are being queried.\"\n}\n"}
{"sample_id": "train.4903", "db_id": "store_product", "question": "What is the maximum page size for everything that has more than 3 products listed?", "rationale": ["Identify the relevant tables: product, store_product, and store.", "We need to find the maximum page size for products, so we will select the max_page_size from the product table.", "Join the product table with the store_product table to link products to their respective stores.", "Join the store_product table with the store table to access store information.", "Group the results by Store_ID to aggregate the products per store.", "Use the HAVING clause to filter stores that have more than 3 products listed."], "gold_sql": "SELECT max_page_size FROM product GROUP BY max_page_size HAVING count(*)  >  3", "source_tables": ["product"], "pred_sql": "SELECT MAX(p.max_page_size) \nFROM product p \nJOIN store_product sp ON p.product_id = sp.Product_ID \nJOIN store s ON sp.Store_ID = s.Store_ID \nGROUP BY s.Store_ID \nHAVING COUNT(sp.Product_ID) > 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the products available in a specific store. The placeholder in the WHERE clause represents the name of the store for which the products are being queried.\",\n    \"1\": \"This virtual table describes the products from the 'product' table that match a specific search criterion. The placeholder in the WHERE clause represents a pattern for the product name or description.\"\n}\n"}
{"sample_id": "train.4913", "db_id": "store_product", "question": "What is the total number of residents for the districts with the 3 largest areas?", "rationale": ["Identify the relevant table: The question pertains to districts and their populations, so we will use the 'district' table.", "Determine the required data: We need the total number of residents, which corresponds to the 'City_Population' column.", "Find the districts with the largest areas: We will order the districts by 'City_Area' in descending order and limit the results to the top 3 districts.", "Use a subquery to get the District_IDs of the top 3 largest areas and then sum the 'City_Population' for those districts."], "gold_sql": "SELECT sum(city_population) FROM district ORDER BY city_area DESC LIMIT 3", "source_tables": ["district"], "pred_sql": "SELECT SUM(City_Population) AS Total_Residents\nFROM district\nWHERE District_ID IN (\n    SELECT District_ID\n    FROM district\n    ORDER BY City_Area DESC\n    LIMIT 3\n);", "hint": "\n"}
{"sample_id": "train.4917", "db_id": "store_product", "question": "What are the names of all the stores located in Khanewal District?", "rationale": ["Identify the tables involved: 'store', 'store_district', and 'district'.", "Determine the relationship between these tables: 'store' is linked to 'store_district' via Store_ID, and 'store_district' is linked to 'district' via District_ID.", "We need to filter the results based on the district name 'Khanewal'.", "Construct the SQL query to select the store names from the 'store' table where the district name matches 'Khanewal' by joining the relevant tables."], "gold_sql": "SELECT t1.store_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t3.district_name  =  'Khanewal District'", "source_tables": ["store_district", "store", "district"], "pred_sql": "SELECT store.Store_Name \nFROM store \nJOIN store_district ON store.Store_ID = store_district.Store_ID \nJOIN district ON store_district.District_ID = district.District_ID \nWHERE district.District_name = 'Khanewal';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of stores located in a specific district. The query joins the 'store', 'store_district', and 'district' tables to filter stores based on the district's name provided as a placeholder.\",\n    \"1\": \"This virtual table describes the products available in a specific store. The placeholder in the WHERE clause represents the name of the store for which the products are being queried.\"\n}\n"}
{"sample_id": "train.4924", "db_id": "store_product", "question": "Find the city with the most number of stores.", "rationale": ["To find the city with the most number of stores, we need to count the number of stores in each city.", "We will join the 'store' table with the 'store_district' table to associate each store with its district.", "Next, we will join the 'district' table to get the city information for each district.", "We will group the results by the city name (Headquartered_City) and count the number of stores in each city.", "Finally, we will order the results in descending order based on the count of stores and limit the result to 1 to get the city with the most stores."], "gold_sql": "SELECT t3.headquartered_city FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id GROUP BY t3.headquartered_city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["store_district", "store", "district"], "pred_sql": "SELECT d.Headquartered_City, COUNT(s.Store_ID) AS Number_of_Stores\nFROM store s\nJOIN store_district sd ON s.Store_ID = sd.Store_ID\nJOIN district d ON sd.District_ID = d.District_ID\nGROUP BY d.Headquartered_City\nORDER BY Number_of_Stores DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of stores located in a specific district. The query joins the 'store', 'store_district', and 'district' tables to filter stores based on the district's name provided as a placeholder.\",\n    \"1\": \"This virtual table describes the products available in a specific store. The placeholder in the WHERE clause represents the name of the store for which the products are being queried.\"\n}\n"}
{"sample_id": "train.4930", "db_id": "store_product", "question": "Find products with max page size as \"A4\" and pages per minute color smaller than 5.", "rationale": ["Identify the relevant table: The 'product' table contains the necessary columns for the query.", "Determine the conditions: We need to filter products based on 'max_page_size' and 'pages_per_minute_color'.", "Formulate the WHERE clause: The conditions are 'max_page_size = \"A4\"' and 'pages_per_minute_color < 5'.", "Construct the SQL query: Use SELECT to retrieve all columns from the 'product' table that meet the specified conditions."], "gold_sql": "SELECT product FROM product WHERE max_page_size  =  'A4' AND pages_per_minute_color  <  5", "source_tables": ["product"], "pred_sql": "SELECT * FROM product WHERE max_page_size = 'A4' AND pages_per_minute_color < '5';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the products from the 'product' table that match a specific search criterion. The placeholder in the WHERE clause represents a pattern for the product name or description.\"\n}\n"}
{"sample_id": "train.4932", "db_id": "store_product", "question": "Find products with max page size as \"A4\" or pages per minute color smaller than 5.", "rationale": ["Identify the relevant table: The 'product' table contains the columns we need to filter by: 'max_page_size' and 'pages_per_minute_color'.", "Determine the filtering criteria: We need to find products where 'max_page_size' is 'A4' or 'pages_per_minute_color' is less than 5.", "Construct the SQL query: Use a SELECT statement to retrieve all columns from the 'product' table, applying the WHERE clause to filter based on the specified conditions."], "gold_sql": "SELECT product FROM product WHERE max_page_size  =  'A4' OR pages_per_minute_color  <  5", "source_tables": ["product"], "pred_sql": "SELECT * FROM product WHERE max_page_size = 'A4' OR pages_per_minute_color < '5';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the products from the 'product' table that match a specific search criterion. The placeholder in the WHERE clause represents a pattern for the product name or description.\"\n}\n"}
{"sample_id": "train.4935", "db_id": "store_product", "question": "What are all of the products whose name includes the substring \"Scanner\"?", "rationale": ["Identify the relevant table: The 'product' table contains the information about products.", "Determine the condition: We need to find products whose name includes the substring 'Scanner'.", "Use the SQL LIKE operator: The '%' wildcard is used to match any sequence of characters before and after 'Scanner'.", "Construct the SQL query: Combine the SELECT statement with the WHERE clause to filter the products accordingly."], "gold_sql": "SELECT product FROM product WHERE product LIKE '%Scanner%'", "source_tables": ["product"], "pred_sql": "SELECT * FROM product WHERE product LIKE '%Scanner%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the products from the 'product' table that match a specific search criterion. The placeholder in the WHERE clause represents a pattern for the product name or description.\",\n    \"1\": \"This virtual table describes the products available in a specific store. The placeholder in the WHERE clause represents the name of the store for which the products are being queried.\"\n}\n"}
{"sample_id": "train.4937", "db_id": "store_product", "question": "What is the most common maximum page size?", "rationale": ["Identify the relevant table: The question pertains to the maximum page size of products, which is found in the 'product' table.", "Determine the required information: We need to find the most common maximum page size, which implies counting occurrences of each maximum page size.", "Use the COUNT function: To find the frequency of each maximum page size, we will use the COUNT function in SQL.", "Group the results: We will group the results by 'max_page_size' to aggregate the counts for each unique maximum page size.", "Order the results: To find the most common maximum page size, we will order the results by the count in descending order.", "Limit the results: Since we only want the most common maximum page size, we will limit the results to 1."], "gold_sql": "SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT 1", "source_tables": ["product"], "pred_sql": "SELECT max_page_size, COUNT(*) as count\nFROM product\nGROUP BY max_page_size\nORDER BY count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.4938", "db_id": "store_product", "question": "Find the name of the products that are not using the most frequently-used max page size.", "rationale": ["Identify the main requirement: Find products that do not use the most frequently-used max page size.", "To achieve this, we need to first determine what the most frequently-used max page size is.", "We can do this by grouping the products by 'max_page_size' and counting how many products fall into each group.", "We will order these groups by the count in descending order and limit the result to 1 to get the most common max page size.", "Next, we will select the product names from the 'product' table where the 'max_page_size' is not equal to the most frequently-used max page size found in the previous step."], "gold_sql": "SELECT product FROM product WHERE product != (SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["product"], "pred_sql": "SELECT product.product \nFROM product \nWHERE product.max_page_size != (SELECT max_page_size \n                                 FROM product \n                                 GROUP BY max_page_size \n                                 ORDER BY COUNT(*) DESC \n                                 LIMIT 1);", "hint": "\n"}
{"sample_id": "train.4947", "db_id": "soccer_2", "question": "How many students, on average, does each college have enrolled?", "rationale": ["Identify the table that contains the enrollment information, which is the College table.", "To find the average number of students enrolled in each college, we need to use the AVG() function on the 'enr' column.", "The query should select the average enrollment from the College table without any grouping since we want the overall average across all colleges."], "gold_sql": "SELECT avg(enr) FROM College", "source_tables": ["college"], "pred_sql": "SELECT AVG(enr) AS average_enrollment FROM College;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average enrollment number of colleges located in a specific state. The placeholder in the WHERE clause represents the name of the state.\",\n    \"1\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n    \"2\": \"This virtual table counts the number of players from the 'Player' table who attended high schools with an enrollment number greater than a specified value. The placeholder in the WHERE clause represents the enrollment number of students at the high school.\"\n}\n"}
{"sample_id": "train.4955", "db_id": "soccer_2", "question": "How many hours do the players train on average?", "rationale": ["The question asks for the average number of hours players train, which implies we need to calculate an average from a relevant column.", "Since the schema provided does not include a direct column for training hours, we assume there is a virtual table or additional context that provides this information.", "The SQL query uses the AVG() function to calculate the average of the training hours from the Player table, which is assumed to have a column named 'training_hours'."], "gold_sql": "SELECT avg(HS) FROM Player", "source_tables": ["player"], "pred_sql": "SELECT AVG(training_hours) AS average_training_hours FROM Player", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n    \"1\": \"This virtual table calculates the average high school attended by players from the 'Player' table. The placeholder in the SELECT clause represents the high school data that will be averaged.\",\n    \"2\": \"This virtual table calculates the average high school identifier of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\"\n}\n"}
{"sample_id": "train.4956", "db_id": "soccer_2", "question": "Find the name and training hours of players whose hours are below 1500.", "rationale": ["Identify the relevant table: The 'Player' table contains the names of players.", "Determine the required fields: We need the player's name and their training hours.", "Apply the condition: We need to filter players whose training hours are below 1500.", "Construct the SQL query: Use SELECT to get the required fields from the 'Player' table with the specified condition."], "gold_sql": "SELECT pName ,  HS FROM Player WHERE HS  <  1500", "source_tables": ["player"], "pred_sql": "SELECT pName, training_hours FROM Player WHERE training_hours < 1500;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n    \"1\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n    \"2\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\"\n}\n"}
{"sample_id": "train.4961", "db_id": "soccer_2", "question": "What are the different types of player positions?", "rationale": ["The question asks for the different types of player positions.", "To find the different types of player positions, we need to look at the 'pPos' column in the 'Tryout' table.", "Using the DISTINCT keyword will allow us to retrieve only unique positions from the 'pPos' column.", "The final SQL query selects distinct player positions from the Tryout table."], "gold_sql": "SELECT count(DISTINCT pPos) FROM tryout", "source_tables": ["tryout"], "pred_sql": "SELECT DISTINCT pPos FROM Tryout;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of distinct positions that players are trying out for in the 'Tryout' table. The result will give an overview of the variety of positions available for players during tryouts.\",\n    \"1\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n    \"2\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\"\n}\n"}
{"sample_id": "train.4962", "db_id": "soccer_2", "question": "How many students got accepted after the tryout?", "rationale": ["Identify the relevant table: The 'Tryout' table contains the decision made regarding each player's tryout.", "Determine the condition: We need to count the number of players who were accepted, which corresponds to the 'decision' column being equal to 'accepted'.", "Construct the SQL query: Use the COUNT function to count the number of rows that meet the condition from the 'Tryout' table."], "gold_sql": "SELECT count(*) FROM tryout WHERE decision  =  'yes'", "source_tables": ["tryout"], "pred_sql": "SELECT COUNT(*) AS accepted_students\nFROM Tryout\nWHERE decision = 'accepted';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n    \"1\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n    \"2\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\"\n}\n"}
{"sample_id": "train.4966", "db_id": "soccer_2", "question": "Find the max, average and min training hours of all players.", "rationale": ["Identify the need to calculate maximum, average, and minimum training hours of players.", "Recognize that the training hours data is not explicitly mentioned in the schema, but we can assume it is a part of the Player table or needs to be derived from another context.", "Construct the SQL query to select the maximum, average, and minimum of the training hours from the Player table."], "gold_sql": "SELECT avg(HS) ,  max(HS) ,  min(HS) FROM Player", "source_tables": ["player"], "pred_sql": "SELECT MAX(training_hours) AS max_hours, AVG(training_hours) AS avg_hours, MIN(training_hours) AS min_hours FROM Player;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average high school attended by players from the 'Player' table. The placeholder in the SELECT clause represents the high school data that will be averaged.\",\n    \"1\": \"This virtual table calculates the average high school identifier of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\",\n    \"2\": \"This virtual table provides the count of distinct positions that players are trying out for in the 'Tryout' table. The result will give an overview of the variety of positions available for players during tryouts.\"\n}\n"}
{"sample_id": "train.4967", "db_id": "soccer_2", "question": "What is the average, maximum, and minimum for the number of hours spent training?", "rationale": ["Identify the need to calculate average, maximum, and minimum values for training hours.", "Determine the relevant table that contains training hours data, which is assumed to be a 'Training' table based on the context.", "Construct the SQL query using aggregate functions AVG(), MAX(), and MIN() to retrieve the desired statistics from the 'Training' table."], "gold_sql": "SELECT avg(HS) ,  max(HS) ,  min(HS) FROM Player", "source_tables": ["player"], "pred_sql": "SELECT AVG(training_hours) AS average_training_hours, MAX(training_hours) AS max_training_hours, MIN(training_hours) AS min_training_hours FROM Training;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average high school attended by players from the 'Player' table. The placeholder in the SELECT clause represents the high school data that will be averaged.\",\n    \"1\": \"This virtual table provides the count of distinct positions that players are trying out for in the 'Tryout' table. The result will give an overview of the variety of positions available for players during tryouts.\"\n}\n"}
{"sample_id": "train.4970", "db_id": "soccer_2", "question": "What are the names of players whose training hours is between 500 and 1500?", "rationale": ["Identify the relevant table: The question asks for player names, so we will focus on the 'Player' table.", "Determine the condition: We need to filter players based on their training hours being between 500 and 1500.", "Since the 'Player' table does not have a 'training_hours' column, we need to assume that this information is available through the 'Tryout' table or another source.", "Use a subquery to find players who are participating in tryouts, as indicated by the hint about the virtual table listing players in tryouts.", "Combine the results to filter players based on the training hours condition."], "gold_sql": "SELECT pName FROM Player WHERE HS BETWEEN 500 AND 1500", "source_tables": ["player"], "pred_sql": "SELECT pName FROM Player WHERE pID IN (SELECT pID FROM Tryout) AND training_hours BETWEEN 500 AND 1500;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n    \"1\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n    \"2\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\"\n}\n"}
{"sample_id": "train.4971", "db_id": "soccer_2", "question": "What are the names of players who train between 500 and 1500 hours?", "rationale": ["Identify the relevant table: The 'Player' table contains player names.", "Determine the criteria: We need to find players who train between 500 and 1500 hours.", "Since the training hours are not directly in the schema, we assume 'pPos' in the Tryout table might represent training hours, although this is unconventional.", "Use a subquery to filter players based on the training hours criteria, assuming 'pPos' can be interpreted as such.", "Select the player names from the 'Player' table where the player IDs match those from the filtered Tryout results.", "Order the results alphabetically by player name."], "gold_sql": "SELECT pName FROM Player WHERE HS BETWEEN 500 AND 1500", "source_tables": ["player"], "pred_sql": "SELECT pName FROM Player WHERE pID IN (SELECT pID FROM Tryout WHERE pPos BETWEEN '500' AND '1500') ORDER BY pName;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n    \"1\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n    \"2\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\"\n}\n"}
{"sample_id": "train.4975", "db_id": "soccer_2", "question": "What are the names and enrollment numbers for colleges that have more than 10000 enrolled and are located in Louisiana?", "rationale": ["Identify the columns needed: 'cName' and 'enr' from the College table.", "Determine the conditions: enrollment number ('enr') must be greater than 10000 and the state must be 'Louisiana'.", "Construct the SQL SELECT statement to retrieve the specified columns from the College table with the given conditions."], "gold_sql": "SELECT cName ,  enr FROM College WHERE enr  >  10000 AND state = 'LA'", "source_tables": ["college"], "pred_sql": "SELECT cName, enr FROM College WHERE enr > 10000 AND state = 'Louisiana';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average enrollment number of colleges located in a specific state. The placeholder in the WHERE clause represents the name of the state.\",\n    \"1\": \"This virtual table counts the number of players from the 'Player' table who attended high schools with an enrollment number greater than a specified value. The placeholder in the WHERE clause represents the enrollment number of students at the high school.\",\n    \"2\": \"This virtual table provides the count of players from the 'Player' table who attended high schools with an enrollment number greater than a specified value. The placeholder in the WHERE clause represents the minimum enrollment number of students at the high school.\"\n}\n"}
{"sample_id": "train.4981", "db_id": "soccer_2", "question": "What are the name of the players who received a card in descending order of the hours of training?", "rationale": ["Identify the relevant table: The 'Player' table contains the names of the players.", "Determine the required output: We need the names of the players who received a card.", "Sort the results: The results should be ordered in descending order, but the hint does not provide a specific column related to 'hours of training'.", "Since there is no direct column for hours of training in the provided schema, we will sort by 'pID' as a proxy for the order of players, assuming it relates to their eligibility or experience."], "gold_sql": "SELECT pName FROM Player WHERE yCard  =  'yes' ORDER BY HS DESC", "source_tables": ["player"], "pred_sql": "SELECT pName FROM Player ORDER BY pID DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n    \"1\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n    \"2\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\"\n}\n"}
{"sample_id": "train.4984", "db_id": "soccer_2", "question": "Which position is most popular among players in the tryout?", "rationale": ["We need to find out which position is most popular among players in the tryout.", "To do this, we will count the number of players trying out for each position.", "We will use the COUNT function to count the occurrences of each position in the Tryout table.", "We will group the results by the position (pPos) to get the count for each position.", "Finally, we will order the results in descending order based on the count and limit the results to 1 to get the most popular position."], "gold_sql": "SELECT pPos FROM tryout GROUP BY pPos ORDER BY count(*) DESC LIMIT 1", "source_tables": ["tryout"], "pred_sql": "SELECT pPos, COUNT(*) as position_count \nFROM Tryout \nGROUP BY pPos \nORDER BY position_count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of distinct positions that players are trying out for in the 'Tryout' table. The result will give an overview of the variety of positions available for players during tryouts.\",\n    \"1\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n    \"2\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\"\n}\n"}
{"sample_id": "train.4985", "db_id": "soccer_2", "question": "What was the most popular position at tryouts?", "rationale": ["To find the most popular position at tryouts, we need to count how many players are trying out for each position.", "We will use the 'Tryout' table, which contains the 'pPos' column representing the position players are trying out for.", "We will group the results by 'pPos' to aggregate the counts for each position.", "Next, we will count the number of occurrences of each position using COUNT(*).", "To determine the most popular position, we will order the results in descending order based on the count of players for each position.", "Finally, we will limit the results to 1 to get only the most popular position."], "gold_sql": "SELECT pPos FROM tryout GROUP BY pPos ORDER BY count(*) DESC LIMIT 1", "source_tables": ["tryout"], "pred_sql": "SELECT pPos, COUNT(*) as position_count \nFROM Tryout \nGROUP BY pPos \nORDER BY position_count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of distinct positions that players are trying out for in the 'Tryout' table. The result will give an overview of the variety of positions available for players during tryouts.\",\n    \"1\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n    \"2\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\"\n}\n"}
{"sample_id": "train.4988", "db_id": "soccer_2", "question": "What is minimum hours of the students playing in different position?", "rationale": ["Identify the relevant table: The 'Tryout' table contains information about players and their positions during tryouts.", "Determine the required information: We need to find the number of players trying out for each position.", "Use the COUNT function to count the number of players (pID) for each position (pPos).", "Group the results by position (pPos) to get the count for each distinct position."], "gold_sql": "SELECT min(T2.HS) ,   T1.pPos FROM tryout AS T1 JOIN player AS T2 ON T1.pID  =  T2.pID GROUP BY T1.pPos", "source_tables": ["player", "tryout"], "pred_sql": "SELECT pPos, COUNT(pID) AS num_players\nFROM Tryout\nGROUP BY pPos;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n    \"1\": \"This virtual table provides the count of distinct positions that players are trying out for in the 'Tryout' table. The result will give an overview of the variety of positions available for players during tryouts.\",\n    \"2\": \"This virtual table provides the total number of players who are trying out for a specific position from the 'Tryout' table. The placeholder in the WHERE clause represents the position for which the count is being calculated.\"\n}\n"}
{"sample_id": "train.4989", "db_id": "soccer_2", "question": "For each position, what is the minimum time students spent practicing?", "rationale": ["Identify the relevant tables: We need to find information about players and their practice times, which suggests a table that records practice sessions.", "Determine the necessary columns: We need the position (pPos) and the minimum practice time for each position.", "Group the results: To find the minimum practice time for each position, we will group the results by pPos.", "Construct the SQL query: Using the SELECT statement to retrieve the position and the minimum practice time, and using GROUP BY to aggregate the results."], "gold_sql": "SELECT min(T2.HS) ,   T1.pPos FROM tryout AS T1 JOIN player AS T2 ON T1.pID  =  T2.pID GROUP BY T1.pPos", "source_tables": ["player", "tryout"], "pred_sql": "SELECT pPos, MIN(practice_time) AS min_practice_time\nFROM Practice\nGROUP BY pPos;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n    \"1\": \"This virtual table provides the count of distinct positions that players are trying out for in the 'Tryout' table. The result will give an overview of the variety of positions available for players during tryouts.\",\n    \"2\": \"This virtual table provides the total number of players who are trying out for a specific position from the 'Tryout' table. The placeholder in the WHERE clause represents the position for which the count is being calculated.\"\n}\n"}
{"sample_id": "train.5003", "db_id": "soccer_2", "question": "What are the names and hours spent practicing of every student who received a yes at tryouts?", "rationale": ["Identify the tables involved: Player and Tryout.", "We need to select the names of players, which is in the Player table, and the hours spent practicing, which is represented by the position they are trying out for in the Tryout table.", "Join the Player table with the Tryout table on the player ID (pID) to get the relevant information from both tables.", "Filter the results to include only those players who received a 'yes' decision in the tryouts."], "gold_sql": "SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes'", "source_tables": ["player", "tryout"], "pred_sql": "SELECT Player.pName, Tryout.pPos \nFROM Player \nJOIN Tryout ON Player.pID = Tryout.pID \nWHERE Tryout.decision = 'yes';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n    \"1\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n    \"2\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\"\n}\n"}
{"sample_id": "train.5007", "db_id": "soccer_2", "question": "What are the names of all students who successfully tried out for the position of striker?", "rationale": ["Identify the relevant tables: Player and Tryout.", "We need to find the names of players, so we will select 'pName' from the Player table.", "To find players who tried out for a specific position, we will join the Player table with the Tryout table on 'pID'.", "We will filter the results to include only those players who tried out for the position of 'striker'.", "Additionally, we need to ensure that we only include players who were successful in their tryout, so we will add a condition for 'decision' to be 'successful'.", "Combine all these elements into a SQL SELECT statement."], "gold_sql": "SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes' AND T2.pPos  =  'striker'", "source_tables": ["player", "tryout"], "pred_sql": "SELECT pName FROM Player JOIN Tryout ON Player.pID = Tryout.pID WHERE Tryout.pPos = 'striker' AND Tryout.decision = 'successful';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n    \"1\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n    \"2\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\"\n}\n"}
{"sample_id": "train.5013", "db_id": "soccer_2", "question": "What is the average number of hours spent practicing for students who got rejected?", "rationale": ["Identify the relevant tables: Player and Tryout are needed to find players who were rejected.", "Join the Player table with the Tryout table on the pID to access player information and their tryout decisions.", "Filter the results to include only those players whose decision was 'rejected'.", "Calculate the average number of hours spent practicing for these players."], "gold_sql": "SELECT avg(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'no'", "source_tables": ["player", "tryout"], "pred_sql": "SELECT AVG(hours) AS average_hours_practicing\nFROM Player\nJOIN Tryout ON Player.pID = Tryout.pID\nWHERE Tryout.decision = 'rejected';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average high school identifier of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\",\n    \"1\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n    \"2\": \"This virtual table calculates the average high school attended by players from the 'Player' table. The placeholder in the SELECT clause represents the high school data that will be averaged.\"\n}\n"}
{"sample_id": "train.5018", "db_id": "soccer_2", "question": "Which college has any student who is a goalie and succeeded in the tryout.", "rationale": ["Identify the relevant tables: College, Player, and Tryout are needed to answer the question.", "We need to find colleges that have students who are goalies and succeeded in their tryouts.", "To do this, we will join the College table with the Tryout table on the college name (cName) and then join the Player table on the player ID (pID).", "We will filter the results where the position (pPos) is 'goalie' and the decision is 'succeeded'.", "Finally, we will select distinct college names (cName) to avoid duplicates."], "gold_sql": "SELECT cName FROM  tryout WHERE decision  =  'yes' AND pPos  =  'goalie'", "source_tables": ["tryout"], "pred_sql": "SELECT DISTINCT College.cName \nFROM College \nJOIN Tryout ON College.cName = Tryout.cName \nJOIN Player ON Tryout.pID = Player.pID \nWHERE Tryout.pPos = 'goalie' AND Tryout.decision = 'succeeded';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the states of colleges where a specific player has participated in tryouts. The placeholder in the WHERE clause represents the player's name.\",\n    \"1\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n    \"2\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\"\n}\n"}
{"sample_id": "train.5022", "db_id": "soccer_2", "question": "What is the state and enrollment of the colleges where have any students who got accepted in the tryout decision.", "rationale": ["Identify the relevant tables: College and Tryout are needed to get the state and enrollment of colleges where students participated in tryouts.", "We need to join the College table with the Tryout table on the common column cName to link colleges with their respective tryouts.", "We are interested in colleges where students have been accepted, so we filter the results using the condition Tryout.decision = 'accepted'.", "Finally, we select the state and enrollment number from the College table."], "gold_sql": "SELECT DISTINCT T1.state ,  T1.enr FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  'yes'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT College.state, College.enr \nFROM College \nJOIN Tryout ON College.cName = Tryout.cName \nWHERE Tryout.decision = 'accepted';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the states of colleges where a specific player has participated in tryouts. The placeholder in the WHERE clause represents the player's name.\",\n    \"1\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n    \"2\": \"This virtual table calculates the average enrollment number of colleges located in a specific state. The placeholder in the WHERE clause represents the name of the state.\"\n}\n"}
{"sample_id": "train.5023", "db_id": "soccer_2", "question": "How many students are enrolled in colleges that have student accepted during tryouts, and in which states are those colleges?", "rationale": ["Identify the relevant tables: College and Tryout are needed to find the enrollment numbers and the colleges where players were accepted during tryouts.", "We need to sum the enrollment numbers from the College table, so we will use the SUM function on the 'enr' column.", "To find colleges that accepted students during tryouts, we will join the College table with the Tryout table on the college name (cName).", "We will filter the results to only include rows where the decision in the Tryout table is 'accepted'.", "Finally, we will group the results by the state of the colleges to get the total enrollment per state."], "gold_sql": "SELECT DISTINCT T1.state ,  T1.enr FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  'yes'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT SUM(CAST(College.enr AS INTEGER)) AS total_enrollment, College.state \nFROM College \nJOIN Tryout ON College.cName = Tryout.cName \nWHERE Tryout.decision = 'accepted' \nGROUP BY College.state;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n    \"1\": \"This virtual table provides the states of colleges where a specific player has participated in tryouts. The placeholder in the WHERE clause represents the player's name.\",\n    \"2\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\"\n}\n"}
{"sample_id": "train.5026", "db_id": "soccer_2", "question": "Find the names of schools that have some students playing in goalie and mid positions.", "rationale": ["Identify the relevant table: The 'Tryout' table contains the information about players and their positions.", "Filter for specific positions: We need to find colleges where players are trying out for 'goalie' and 'mid' positions.", "Use DISTINCT to avoid duplicates: Since multiple players can try out for the same position at the same college, we use DISTINCT to get unique college names.", "Group by college name: We group the results by 'cName' to aggregate the data for each college.", "Count players: We use HAVING COUNT(DISTINCT pID) > 0 to ensure that we only include colleges that have players trying out for at least one of the specified positions."], "gold_sql": "SELECT cName FROM  tryout WHERE pPos  =  'goalie' INTERSECT SELECT cName FROM  tryout WHERE pPos  =  'mid'", "source_tables": ["tryout"], "pred_sql": "SELECT DISTINCT cName \nFROM Tryout \nWHERE pPos IN ('goalie', 'mid') \nGROUP BY cName \nHAVING COUNT(DISTINCT pID) > 0;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n    \"1\": \"This virtual table provides the states of colleges where a specific player has participated in tryouts. The placeholder in the WHERE clause represents the player's name.\",\n    \"2\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\"\n}\n"}
{"sample_id": "train.5028", "db_id": "soccer_2", "question": "Find the names of states that have some college students playing in goalie and mid positions.", "rationale": ["We need to find the states of colleges that have students trying out for specific positions (goalie and mid).", "To do this, we will join the College table with the Tryout table on the college name (cName).", "We will filter the results to include only those tryouts where the position (pPos) is either 'goalie' or 'mid'.", "We will use DISTINCT to ensure that we only get unique state names in our final result.", "The final query will select the state from the College table where there are corresponding entries in the Tryout table for the specified positions."], "gold_sql": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'goalie' INTERSECT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'mid'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT DISTINCT College.state \nFROM College \nJOIN Tryout ON College.cName = Tryout.cName \nWHERE Tryout.pPos IN ('goalie', 'mid') \nAND Tryout.pID IN (SELECT pID FROM Player);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the states of colleges where a specific player has participated in tryouts. The placeholder in the WHERE clause represents the player's name.\",\n    \"1\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\"\n}\n"}
{"sample_id": "train.5029", "db_id": "soccer_2", "question": "What are the names of the states that have some college students playing in the positions of goalie and mid-field?", "rationale": ["We need to find the states of colleges that have students playing in specific positions: goalie and mid-field.", "To do this, we will join the College table with the Tryout table on the college name (cName).", "We will filter the results to include only those rows where the position (pPos) is either 'goalie' or 'mid-field'.", "Finally, we will select distinct states to avoid duplicates in our results."], "gold_sql": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'goalie' INTERSECT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'mid'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT DISTINCT College.state\nFROM College\nJOIN Tryout ON College.cName = Tryout.cName\nWHERE Tryout.pPos IN ('goalie', 'mid-field');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n    \"1\": \"This virtual table provides the states of colleges where a specific player has participated in tryouts. The placeholder in the WHERE clause represents the player's name.\",\n    \"2\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\"\n}\n"}
{"sample_id": "train.5030", "db_id": "soccer_2", "question": "How many schools have some students playing in goalie and mid positions.", "rationale": ["Identify the relevant tables: We need to look at the 'Tryout' table to find players trying out for specific positions.", "Determine the positions of interest: The user is interested in players trying out for 'goalie' and 'mid' positions.", "Count the distinct colleges: We need to count how many unique colleges (cName) have players trying out for these positions.", "Construct the SQL query: Use COUNT(DISTINCT cName) to count the unique colleges and filter the results using a WHERE clause for the specified positions."], "gold_sql": "SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  'goalie' INTERSECT SELECT cName FROM  tryout WHERE pPos  =  'mid')", "source_tables": ["tryout"], "pred_sql": "SELECT COUNT(DISTINCT cName) AS school_count \nFROM Tryout \nWHERE pPos IN ('goalie', 'mid');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n    \"1\": \"This virtual table provides the count of distinct positions that players are trying out for in the 'Tryout' table. The result will give an overview of the variety of positions available for players during tryouts.\",\n    \"2\": \"This virtual table provides the states of colleges where a specific player has participated in tryouts. The placeholder in the WHERE clause represents the player's name.\"\n}\n"}
{"sample_id": "train.5037", "db_id": "soccer_2", "question": "What is the count of states with college students playing in the mid position but not as goalies?", "rationale": ["Identify the requirement to count distinct states with colleges that have students trying out for the 'mid' position but not as goalies.", "The relevant table for this query is 'College' which contains the state information and the 'Tryout' table which contains the position and decision of players.", "We need to filter the 'Tryout' table for entries where the position is 'mid' and the decision is not 'goalie'.", "We will then use the filtered results to find the corresponding college names from the 'Tryout' table.", "Finally, we will count the distinct states from the 'College' table where the college names match those from the filtered 'Tryout' results."], "gold_sql": "SELECT COUNT(*) FROM (SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'mid' EXCEPT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'goalie')", "source_tables": ["tryout", "college"], "pred_sql": "SELECT COUNT(DISTINCT state) AS state_count\nFROM College\nWHERE cName IN (\n    SELECT cName\n    FROM Tryout\n    WHERE pPos = 'mid' AND decision != 'goalie'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n    \"1\": \"This virtual table provides the states of colleges where a specific player has participated in tryouts. The placeholder in the WHERE clause represents the player's name.\",\n    \"2\": \"This virtual table provides the count of distinct positions that players are trying out for in the 'Tryout' table. The result will give an overview of the variety of positions available for players during tryouts.\"\n}\n"}
{"sample_id": "train.5039", "db_id": "soccer_2", "question": "What are the states with colleges that have enrollments less than the some other college?", "rationale": ["Identify the requirement to find states with colleges that have enrollments less than some other college.", "Determine that we need to compare the enrollment numbers of colleges.", "Use a subquery to calculate the average enrollment number of colleges, which serves as the comparison value.", "Select distinct states from the College table where the enrollment number is less than the calculated average."], "gold_sql": "SELECT DISTINCT state FROM college WHERE enr  <  (SELECT max(enr) FROM college)", "source_tables": ["college"], "pred_sql": "SELECT DISTINCT state FROM College WHERE enr < (SELECT AVG(enr) FROM College)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average enrollment number of colleges located in a specific state. The placeholder in the WHERE clause represents the name of the state.\",\n    \"1\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n    \"2\": \"This virtual table provides the states of colleges where a specific player has participated in tryouts. The placeholder in the WHERE clause represents the player's name.\"\n}\n"}
{"sample_id": "train.5102", "db_id": "cre_Drama_Workshop_Groups", "question": "Show the minimum, average, maximum order quantity of all invoices.", "rationale": ["Identify the relevant table: Invoices, which contains the order quantities.", "Use aggregate functions to calculate the minimum, average, and maximum of the 'Order_Quantity' column.", "Construct the SQL query using SELECT to retrieve the aggregated values from the Invoices table."], "gold_sql": "SELECT min(Order_Quantity) ,  avg(Order_Quantity) ,  max(Order_Quantity) FROM INVOICES", "source_tables": ["invoices"], "pred_sql": "SELECT MIN(Order_Quantity) AS Min_Quantity, AVG(Order_Quantity) AS Avg_Quantity, MAX(Order_Quantity) AS Max_Quantity\nFROM Invoices;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the minimum, average, and maximum quantities of products ordered as recorded in the 'Invoices' table. The placeholders in the SELECT statement represent the aggregated values of the order quantities.\",\n    \"1\": \"This virtual table calculates the average quantity of products ordered from the 'Invoices' table for a specific payment method. The placeholder in the WHERE clause represents the payment method code used for filtering the results.\",\n    \"2\": \"This virtual table calculates the average quantity of products ordered from the 'Invoices' table for a specific payment method. The placeholder in the WHERE clause represents the payment method code used for filtering the results.\"\n}\n"}
{"sample_id": "train.5118", "db_id": "cre_Drama_Workshop_Groups", "question": "What is the payment method code used by the most orders?", "rationale": ["We need to find the payment method code used by the most orders, which implies we need to count the number of orders associated with each payment method.", "The relevant table for this information is the 'Invoices' table, which contains the 'payment_method_code' and 'Order_ID'.", "We will group the results by 'payment_method_code' to count how many orders correspond to each payment method.", "To find the payment method with the most orders, we will order the results in descending order based on the count of 'Order_ID'.", "Finally, we will limit the results to 1 to get only the payment method code used by the most orders."], "gold_sql": "SELECT payment_method_code FROM INVOICES GROUP BY payment_method_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["invoices"], "pred_sql": "SELECT payment_method_code\nFROM Invoices\nGROUP BY payment_method_code\nORDER BY COUNT(Order_ID) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average quantity of products ordered from the 'Invoices' table for a specific payment method. The placeholder in the WHERE clause represents the payment method code used for filtering the results.\",\n    \"1\": \"This virtual table calculates the average quantity of products ordered from the 'Invoices' table for a specific payment method. The placeholder in the WHERE clause represents the payment method code used for filtering the results.\",\n    \"2\": \"This virtual table summarizes the minimum, average, and maximum quantities of products ordered as recorded in the 'Invoices' table. The placeholders in the SELECT statement represent the aggregated values of the order quantities.\"\n}\n"}
{"sample_id": "train.5127", "db_id": "cre_Drama_Workshop_Groups", "question": "Give me the descriptions of the service types that cost more than 100.", "rationale": ["Identify the relevant table for service types, which is 'Ref_Service_Types'.", "Determine that we need to join the 'Services' table to access the product prices associated with each service type.", "Use the condition to filter services where the product price is greater than 100.", "Select the 'Service_Type_Description' from the 'Ref_Service_Types' table after applying the necessary join and filter."], "gold_sql": "SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Price  >  100", "source_tables": ["services", "ref_service_types"], "pred_sql": "SELECT Ref_Service_Types.Service_Type_Description \nFROM Ref_Service_Types \nJOIN Services ON Ref_Service_Types.Service_Type_Code = Services.Service_Type_Code \nWHERE Services.Product_Price > 100;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of service type descriptions from the 'Ref_Service_Types' table that are associated with services having a product price greater than a specified amount. The placeholder in the WHERE clause represents the minimum product price to filter the results.\"\n}\n"}
{"sample_id": "train.5134", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the names of workshop groups in which services with product name \"film\" are performed?", "rationale": ["Identify the relevant tables: 'Drama_Workshop_Groups' for workshop groups and 'Services' for services related to those groups.", "Determine the relationship between the tables: 'Drama_Workshop_Groups' can be joined with 'Services' using the 'Workshop_Group_ID'.", "Specify the condition: We need to filter services where the 'Product_Name' is 'film'.", "Select the distinct names of the workshop groups from the joined tables based on the specified condition."], "gold_sql": "SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T2.Product_Name  =  'film'", "source_tables": ["services", "drama_workshop_groups"], "pred_sql": "SELECT DISTINCT DWG.Store_Name \nFROM Drama_Workshop_Groups DWG \nJOIN Services S ON DWG.Workshop_Group_ID = S.Workshop_Group_ID \nWHERE S.Product_Name = 'film';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the phone numbers and email addresses of stores associated with specific drama workshop groups. The data is retrieved by joining the 'Drama_Workshop_Groups' table with the 'Services' table based on the workshop group identifier, allowing for the extraction of relevant contact information for each store linked to the workshop groups.\",\n    \"1\": \"This virtual table provides the phone numbers and email addresses of stores associated with specific drama workshop groups. The data is retrieved by joining the 'Drama_Workshop_Groups' table with the 'Services' table based on the workshop group identifier, allowing for the extraction of relevant contact information for each store linked to the workshop groups.\"\n}\n"}
{"sample_id": "train.5142", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the order details of the products with price higher than 2000?", "rationale": ["Identify the relevant tables: Customer_Orders, Order_Items, and Products are needed to get order details and product information.", "Join the Customer_Orders table with Order_Items to link orders with their respective items.", "Join the Order_Items table with Products to access product details such as name and price.", "Filter the results to include only those products with a price greater than 2000."], "gold_sql": "SELECT T1.Other_Item_Details FROM ORDER_ITEMS AS T1 JOIN Products AS T2 ON T1.Product_ID  =  T2.Product_ID WHERE T2.Product_price  >  2000", "source_tables": ["products", "order_items"], "pred_sql": "SELECT o.Order_ID, o.Order_Date, o.Planned_Delivery_Date, o.Actual_Delivery_Date, oi.Order_Quantity, p.Product_Name, p.Product_Price \nFROM Customer_Orders o \nJOIN Order_Items oi ON o.Order_ID = oi.Order_ID \nJOIN Products p ON oi.Product_ID = p.Product_ID \nWHERE p.Product_Price > 2000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of service type descriptions from the 'Ref_Service_Types' table that are associated with services having a product price greater than a specified amount. The placeholder in the WHERE clause represents the minimum product price to filter the results.\",\n    \"1\": \"This virtual table summarizes the minimum, average, and maximum quantities of products ordered as recorded in the 'Invoices' table. The placeholders in the SELECT statement represent the aggregated values of the order quantities.\"\n}\n"}
{"sample_id": "train.5143", "db_id": "cre_Drama_Workshop_Groups", "question": "Find the order detail for the products with price above 2000.", "rationale": ["Identify the relevant tables: Order_Items and Products are needed to get order details and product prices.", "Join the Order_Items table with the Products table on Product_ID to access product details for each order item.", "Filter the results to include only those products where the Product_Price is greater than 2000."], "gold_sql": "SELECT T1.Other_Item_Details FROM ORDER_ITEMS AS T1 JOIN Products AS T2 ON T1.Product_ID  =  T2.Product_ID WHERE T2.Product_price  >  2000", "source_tables": ["products", "order_items"], "pred_sql": "SELECT oi.Order_Item_ID, oi.Order_ID, oi.Product_ID, oi.Order_Quantity, p.Product_Name, p.Product_Price \nFROM Order_Items oi \nJOIN Products p ON oi.Product_ID = p.Product_ID \nWHERE p.Product_Price > 2000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of service type descriptions from the 'Ref_Service_Types' table that are associated with services having a product price greater than a specified amount. The placeholder in the WHERE clause represents the minimum product price to filter the results.\"\n}\n"}
{"sample_id": "train.5160", "db_id": "cre_Drama_Workshop_Groups", "question": "What is the most frequent status of bookings?", "rationale": ["Identify the relevant table: The question pertains to bookings, so we will use the 'Bookings' table.", "Determine the required information: We need to find the most frequent status of bookings, which means we need to count occurrences of each status code.", "Use the COUNT function: We will count the number of bookings for each status code using COUNT(*) and group the results by 'Status_Code'.", "Sort the results: To find the most frequent status, we will order the results in descending order based on the count of bookings.", "Limit the results: Since we only want the most frequent status, we will limit the results to 1."], "gold_sql": "SELECT Status_Code FROM BOOKINGS GROUP BY Status_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["bookings"], "pred_sql": "SELECT Status_Code, COUNT(*) as Frequency\nFROM Bookings\nGROUP BY Status_Code\nORDER BY Frequency DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5161", "db_id": "cre_Drama_Workshop_Groups", "question": "Which status code is the most common of all the bookings?", "rationale": ["Identify the relevant table: The question pertains to bookings, so we will use the 'Bookings' table.", "Determine the required information: We need to find the most common status code, which implies counting occurrences of each status code.", "Use the COUNT function: We will count the number of bookings for each status code.", "Group the results: We will group the results by 'Status_Code' to aggregate the counts for each unique status code.", "Order the results: To find the most common status code, we will order the results in descending order based on the count.", "Limit the results: Since we only need the most common status code, we will limit the results to 1."], "gold_sql": "SELECT Status_Code FROM BOOKINGS GROUP BY Status_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["bookings"], "pred_sql": "SELECT Status_Code, COUNT(*) as Count\nFROM Bookings\nGROUP BY Status_Code\nORDER BY Count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5162", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the names of the workshop groups that have bookings with status code \"stop\"?", "rationale": ["Identify the relevant tables: 'Drama_Workshop_Groups' for workshop group names and 'Bookings' for booking status.", "Join the 'Drama_Workshop_Groups' table with the 'Bookings' table on the 'Workshop_Group_ID' to link workshop groups with their bookings.", "Filter the results to include only those bookings where the 'Status_Code' is 'stop'.", "Select the distinct names of the workshop groups from the joined tables."], "gold_sql": "SELECT T2.Store_Name FROM Bookings AS T1 JOIN Drama_Workshop_Groups AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T1.Status_Code  =  'stop'", "source_tables": ["drama_workshop_groups", "bookings"], "pred_sql": "SELECT DISTINCT DW.Store_Name \nFROM Drama_Workshop_Groups DW \nJOIN Bookings B ON DW.Workshop_Group_ID = B.Workshop_Group_ID \nWHERE B.Status_Code = 'stop';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the phone numbers and email addresses of stores associated with specific drama workshop groups. The data is retrieved by joining the 'Drama_Workshop_Groups' table with the 'Services' table based on the workshop group identifier, allowing for the extraction of relevant contact information for each store linked to the workshop groups.\",\n    \"1\": \"This virtual table provides the phone numbers and email addresses of stores associated with specific drama workshop groups. The data is retrieved by joining the 'Drama_Workshop_Groups' table with the 'Services' table based on the workshop group identifier, allowing for the extraction of relevant contact information for each store linked to the workshop groups.\"\n}\n"}
{"sample_id": "train.5171", "db_id": "cre_Drama_Workshop_Groups", "question": "Give me the description of the service type that offers not only the photo product but also the film product.", "rationale": ["Identify the relevant tables: We need to retrieve service type descriptions, which are in the 'Ref_Service_Types' table, and we need to link them to services that offer specific products (photo and film).", "Join the 'Ref_Service_Types' table with the 'Services' table using the 'Service_Type_Code' to get the service types associated with each service.", "Next, we need to join the 'Services' table with the 'Order_Items' table to link services to the products they offer.", "We will filter the products to only include those with names 'photo' and 'film'.", "To ensure we get service types that offer both products, we will use a GROUP BY clause on the service type description and a HAVING clause to count distinct product IDs, ensuring it equals 2 (indicating both products are offered).", "Select distinct service type descriptions to avoid duplicates in the final output."], "gold_sql": "SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  'photo' INTERSECT SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  'film'", "source_tables": ["services", "ref_service_types"], "pred_sql": "SELECT DISTINCT rst.Service_Type_Description\nFROM Ref_Service_Types rst\nJOIN Services s ON rst.Service_Type_Code = s.Service_Type_Code\nJOIN Order_Items oi ON s.Product_ID = oi.Product_ID\nWHERE oi.Product_ID IN (\n    SELECT Product_ID FROM Products WHERE Product_Name IN ('photo', 'film')\n) \nGROUP BY rst.Service_Type_Description\nHAVING COUNT(DISTINCT oi.Product_ID) = 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of service type descriptions from the 'Ref_Service_Types' table that are associated with services having a product price greater than a specified amount. The placeholder in the WHERE clause represents the minimum product price to filter the results.\",\n    \"1\": \"This virtual table provides the phone numbers and email addresses of stores associated with specific drama workshop groups. The data is retrieved by joining the 'Drama_Workshop_Groups' table with the 'Services' table based on the workshop group identifier, allowing for the extraction of relevant contact information for each store linked to the workshop groups.\",\n    \"2\": \"This virtual table provides the phone numbers and email addresses of stores associated with specific drama workshop groups. The data is retrieved by joining the 'Drama_Workshop_Groups' table with the 'Services' table based on the workshop group identifier, allowing for the extraction of relevant contact information for each store linked to the workshop groups.\"\n}\n"}
{"sample_id": "train.5459", "db_id": "voter_2", "question": "Find the average age of female students.", "rationale": ["Identify the table needed: The 'Student' table contains the relevant information about students, including their age and sex.", "Determine the condition: We need to filter the records to include only female students, which is specified by the condition 'Sex = 'Female' '.", "Calculate the average: Use the AVG() function to calculate the average age of the filtered records.", "Select the average age: The result should be labeled as 'Average_Age' for clarity in the output."], "gold_sql": "SELECT avg(Age) FROM STUDENT WHERE Sex  =  'F'", "source_tables": ["student"], "pred_sql": "SELECT AVG(Age) AS Average_Age FROM Student WHERE Sex = 'Female';", "hint": "\n"}
{"sample_id": "train.5466", "db_id": "voter_2", "question": "What are the distinct president votes on 08/30/2015?", "rationale": ["Identify the relevant table for the query: Voting_record contains the voting information.", "We need to find distinct president votes, so we will use the DISTINCT keyword.", "The date specified is 08/30/2015, which needs to be matched in the Registration_Date column.", "Construct the SQL query to select distinct President_Vote from Voting_record where the Registration_Date matches the specified date."], "gold_sql": "SELECT DISTINCT PRESIDENT_Vote FROM VOTING_RECORD WHERE Registration_Date  =  '08/30/2015'", "source_tables": ["voting_record"], "pred_sql": "SELECT DISTINCT President_Vote \nFROM Voting_record \nWHERE Registration_Date = '2015-08-30';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the distinct first names of students who have voted for the class senator. The query joins the 'Student' table with the 'Voting_record' table based on the student identifier, ensuring that only those students who participated in the voting for class senator are included.\"\n}\n"}
{"sample_id": "train.5467", "db_id": "voter_2", "question": "Show all the distinct president votes made on 08/30/2015.", "rationale": ["Identify the relevant table for the voting records, which is 'Voting_record'.", "We need to select distinct values for the 'President_Vote' column.", "We need to filter the results based on the 'Registration_Date' to only include votes made on '08/30/2015'.", "The date format in SQL should be 'YYYY-MM-DD', so '08/30/2015' will be converted to '2015-08-30'.", "Construct the SQL query to select distinct president votes from the Voting_record table with the specified date condition."], "gold_sql": "SELECT DISTINCT PRESIDENT_Vote FROM VOTING_RECORD WHERE Registration_Date  =  '08/30/2015'", "source_tables": ["voting_record"], "pred_sql": "SELECT DISTINCT President_Vote \nFROM Voting_record \nWHERE Registration_Date = '2015-08-30';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the distinct first names of students who have voted for the class senator. The query joins the 'Student' table with the 'Voting_record' table based on the student identifier, ensuring that only those students who participated in the voting for class senator are included.\"\n}\n"}
{"sample_id": "train.5476", "db_id": "voter_2", "question": "Find the distinct ages of students who have secretary votes in the fall election cycle.", "rationale": ["Identify the relevant tables: 'Student' and 'Voting_record'.", "We need to find distinct ages, so we will use the DISTINCT keyword on the Age column from the Student table.", "We need to join the Student table with the Voting_record table on the StuID column to link students with their voting records.", "We are specifically interested in students who have voted for the secretary, so we will check for non-null values in the Secretary_Vote column.", "We also need to filter the results to include only those records from the fall election cycle, which will be done using a WHERE clause."], "gold_sql": "SELECT DISTINCT T1.Age FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Secretary_Vote WHERE T2.Election_Cycle  =  'Fall'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT S.Age \nFROM Student S \nJOIN Voting_record V ON S.StuID = V.StuID \nWHERE V.Secretary_Vote IS NOT NULL \nAND V.Election_Cycle = 'fall';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the distinct first names of students who have voted for the class senator. The query joins the 'Student' table with the 'Voting_record' table based on the student identifier, ensuring that only those students who participated in the voting for class senator are included.\"\n}\n"}
{"sample_id": "train.5479", "db_id": "voter_2", "question": "Who served as an advisor for students who have treasurer votes in the spring election cycle?", "rationale": ["Identify the relevant tables: We need to look at the 'Student' table for advisor information and the 'Voting_record' table for voting details.", "Determine the relationship: We will join the 'Student' table with the 'Voting_record' table using the 'StuID' column, which is common to both tables.", "Filter the records: We need to find students who have cast a vote for treasurer, which means we will check if 'Treasurer_Vote' is not null.", "Specify the election cycle: We are interested in the spring election cycle, so we will add a condition to filter by 'Election_Cycle'.", "Select the distinct advisors: Finally, we will select the distinct advisors from the filtered results."], "gold_sql": "SELECT DISTINCT T1.Advisor FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Treasurer_Vote WHERE T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT Student.Advisor \nFROM Student \nJOIN Voting_record ON Student.StuID = Voting_record.StuID \nWHERE Voting_record.Treasurer_Vote IS NOT NULL \nAND Voting_record.Election_Cycle = 'spring';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the distinct first names of students who have voted for the class senator. The query joins the 'Student' table with the 'Voting_record' table based on the student identifier, ensuring that only those students who participated in the voting for class senator are included.\"\n}\n"}
{"sample_id": "train.5486", "db_id": "voter_2", "question": "How many male (sex is M) students have class senator votes in the fall election cycle?", "rationale": ["Identify the tables involved: 'Student' and 'Voting_record'.", "Determine the relevant columns: we need to count male students who voted for class senator.", "Join the 'Student' table with the 'Voting_record' table on the StuID to link students with their voting records.", "Filter the results to include only male students (Sex = 'M').", "Also, filter for the specific election cycle, which is the fall election cycle.", "Use COUNT(DISTINCT) to ensure we count unique male students who voted for class senator."], "gold_sql": "SELECT count(*) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  Class_Senator_Vote WHERE T1.Sex  =  'M' AND T2.Election_Cycle  =  'Fall'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT COUNT(DISTINCT Student.Fname) AS Male_Class_Senator_Voters\nFROM Student\nJOIN Voting_record ON Student.StuID = Voting_record.Class_Senator_Vote\nWHERE Student.Sex = 'M' AND Voting_record.Election_Cycle = 'fall';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the distinct first names of students who have voted for the class senator. The query joins the 'Student' table with the 'Voting_record' table based on the student identifier, ensuring that only those students who participated in the voting for class senator are included.\",\n    \"1\": \"This virtual table describes the field of study (Major) of students from the 'Student' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the students.\"\n}\n"}
{"sample_id": "train.5491", "db_id": "voter_2", "question": "What is the average age of students who have city code \"NYC\" and have secretary votes for the spring election cycle?", "rationale": ["Identify the tables involved: 'Student' and 'Voting_record'.", "Determine the columns needed: average age from 'Student' and filter conditions from 'Voting_record'.", "Join the 'Student' table with the 'Voting_record' table on 'StuID'.", "Filter the results to include only students with city code 'NYC'.", "Add a condition to check for non-null 'Secretary_Vote' to ensure they voted for secretary.", "Specify the election cycle as 'spring'.", "Use the AVG() function to calculate the average age of the filtered students."], "gold_sql": "SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.city_code  =  'NYC' AND T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT AVG(Age) AS Average_Age\nFROM Student\nJOIN Voting_record ON Student.StuID = Voting_record.StuID\nWHERE Student.city_code = 'NYC' AND Voting_record.Secretary_Vote IS NOT NULL AND Voting_record.Election_Cycle = 'spring';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the distinct first names of students who have voted for the class senator. The query joins the 'Student' table with the 'Voting_record' table based on the student identifier, ensuring that only those students who participated in the voting for class senator are included.\"\n}\n"}
{"sample_id": "train.5492", "db_id": "voter_2", "question": "Find the average age of female (sex is F) students who have secretary votes in the spring election cycle.", "rationale": ["Identify the tables involved: 'Student' and 'Voting_record'.", "We need to find the average age of female students, so we will filter the 'Student' table where 'Sex' is 'F'.", "We also need to ensure that these students have voted for the secretary, which means we will check that 'Secretary_Vote' is not null in the 'Voting_record' table.", "The query must also filter for the spring election cycle, so we will add a condition for 'Election_Cycle'.", "Finally, we will use the AVG() function to calculate the average age of the filtered results."], "gold_sql": "SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.Sex  =  'F' AND T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT AVG(Age) AS Average_Age\nFROM Student\nJOIN Voting_record ON Student.StuID = Voting_record.StuID\nWHERE Sex = 'F' AND Secretary_Vote IS NOT NULL AND Election_Cycle = 'spring';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the distinct first names of students who have voted for the class senator. The query joins the 'Student' table with the 'Voting_record' table based on the student identifier, ensuring that only those students who participated in the voting for class senator are included.\"\n}\n"}
{"sample_id": "train.5494", "db_id": "voter_2", "question": "Find the distinct first names of all the students who have vice president votes and whose city code is not PIT.", "rationale": ["We need to find distinct first names of students who voted for vice president.", "To do this, we will join the 'Student' table with the 'Voting_record' table on the 'StuID' column, which is the unique identifier for students in both tables.", "We will filter the results to include only those records where 'Vice_President_Vote' is not null, indicating that the student has cast a vote for vice president.", "Additionally, we will add a condition to exclude students whose 'city_code' is 'PIT'.", "Finally, we will select distinct first names from the resulting dataset."], "gold_sql": "SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_PRESIDENT_Vote EXCEPT SELECT DISTINCT Fname FROM STUDENT WHERE city_code  =  'PIT'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT Student.Fname \nFROM Student \nJOIN Voting_record ON Student.StuID = Voting_record.StuID \nWHERE Voting_record.Vice_President_Vote IS NOT NULL \nAND Student.city_code != 'PIT';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the distinct first names of students who have voted for the class senator. The query joins the 'Student' table with the 'Voting_record' table based on the student identifier, ensuring that only those students who participated in the voting for class senator are included.\"\n}\n"}
{"sample_id": "train.5495", "db_id": "voter_2", "question": "What are the distinct first names of the students who have vice president votes and reside in a city whose city code is not PIT?", "rationale": ["We need to find distinct first names of students who voted for vice president.", "This requires joining the 'Student' table with the 'Voting_record' table on the StuID column, which is the unique identifier for students.", "We filter the results to include only those records where the Vice_President_Vote is not null, indicating that the student voted for vice president.", "Additionally, we need to ensure that the city code of the student is not 'PIT', so we add a condition to exclude those records."], "gold_sql": "SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_PRESIDENT_Vote EXCEPT SELECT DISTINCT Fname FROM STUDENT WHERE city_code  =  'PIT'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT Student.Fname \nFROM Student \nJOIN Voting_record ON Student.StuID = Voting_record.StuID \nWHERE Voting_record.Vice_President_Vote IS NOT NULL \nAND Student.city_code != 'PIT';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the distinct first names of students who have voted for the class senator. The query joins the 'Student' table with the 'Voting_record' table based on the student identifier, ensuring that only those students who participated in the voting for class senator are included.\"\n}\n"}
{"sample_id": "train.5496", "db_id": "voter_2", "question": "Find the distinct last names of all the students who have president votes and whose advisor is not 2192.", "rationale": ["We need to find distinct last names of students who have voted for president.", "To do this, we will join the 'Student' table with the 'Voting_record' table on the 'StuID' column.", "We will filter the results to include only those students who have a president vote by checking the 'President_Vote' column in the 'Voting_record' table.", "Additionally, we need to ensure that the advisor of the students is not '2192', so we will add a condition in the WHERE clause for that."], "gold_sql": "SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote EXCEPT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  '2192'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT Student.LName \nFROM Student \nJOIN Voting_record ON Student.StuID = Voting_record.President_Vote \nWHERE Student.Advisor != '2192';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the distinct first names of students who have voted for the class senator. The query joins the 'Student' table with the 'Voting_record' table based on the student identifier, ensuring that only those students who participated in the voting for class senator are included.\"\n}\n"}
{"sample_id": "train.5499", "db_id": "voter_2", "question": "What are the distinct last names of the students who have president votes and have 8741 as the advisor?", "rationale": ["Identify the relevant tables: We need to look at the 'Student' table for last names and the 'Voting_record' table for voting information.", "We need to find students who have cast a vote for president, which means we will check for non-null values in the 'President_Vote' column.", "We also need to filter students based on their advisor, specifically those with '8741' as their advisor.", "To get the distinct last names, we will use the DISTINCT keyword in our SELECT statement.", "We will join the 'Student' table with the 'Voting_record' table on the StuID column to correlate students with their voting records."], "gold_sql": "SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote INTERSECT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  '8741'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT LName FROM Student JOIN Voting_record ON Student.StuID = Voting_record.StuID WHERE President_Vote IS NOT NULL AND Advisor = '8741';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the distinct first names of students who have voted for the class senator. The query joins the 'Student' table with the 'Voting_record' table based on the student identifier, ensuring that only those students who participated in the voting for class senator are included.\"\n}\n"}
{"sample_id": "train.5510", "db_id": "voter_2", "question": "What is the most common major among female (sex is F) students?", "rationale": ["Identify the relevant table: The 'Student' table contains information about students, including their major and gender.", "Filter the records: We need to focus on female students, so we will add a WHERE clause to filter by Sex = 'F'.", "Count the occurrences: To find the most common major, we will use the COUNT function to count how many students are in each major.", "Group the results: We will group the results by Major to aggregate the counts for each major.", "Order the results: To find the most common major, we will order the results in descending order based on the count of students in each major.", "Limit the results: Since we only want the most common major, we will limit the results to 1."], "gold_sql": "SELECT Major FROM STUDENT WHERE Sex  =  'F' GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Major, COUNT(*) as MajorCount \nFROM Student \nWHERE Sex = 'F' \nGROUP BY Major \nORDER BY MajorCount DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the field of study (Major) of students from the 'Student' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the students.\"\n}\n"}
{"sample_id": "train.5511", "db_id": "voter_2", "question": "Find the major that is studied by the most female students.", "rationale": ["We need to find the major studied by the most female students.", "We will filter the students by gender, specifically selecting those who are female.", "We will group the results by the 'Major' column to count how many female students are in each major.", "To count the number of female students in each major, we will use the COUNT() function.", "We will order the results in descending order based on the count of female students to get the major with the highest count at the top.", "Finally, we will limit the results to just one entry to get the major with the most female students."], "gold_sql": "SELECT Major FROM STUDENT WHERE Sex  =  'F' GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Major, COUNT(*) AS Female_Student_Count\nFROM Student\nWHERE Sex = 'Female'\nGROUP BY Major\nORDER BY Female_Student_Count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the field of study (Major) of students from the 'Student' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the students.\"\n}\n"}
{"sample_id": "train.5534", "db_id": "products_gen_characteristics", "question": "Find the number of products with category \"Spices\" and typically sold above 1000.", "rationale": ["Identify the relevant tables: Products and Ref_Product_Categories.", "Determine the relationship between the tables: Products has a foreign key product_category_code that links to Ref_Product_Categories.", "We need to filter products based on the category description 'Spices' and a selling price greater than 1000.", "Use COUNT(*) to get the total number of products that meet the criteria.", "Construct the SQL query using JOIN to combine the two tables and apply the WHERE clause for filtering."], "gold_sql": "SELECT count(*) FROM products WHERE product_category_code  =  'Spices' AND typical_buying_price  >  1000", "source_tables": ["products"], "pred_sql": "SELECT COUNT(*) AS product_count\nFROM Products p\nJOIN Ref_Product_Categories c ON p.product_category_code = c.product_category_code\nWHERE c.product_category_description = 'Spices' AND p.typical_selling_price > 1000;", "hint": "\n"}
{"sample_id": "train.5543", "db_id": "products_gen_characteristics", "question": "What are the descriptions of the categories that products with product descriptions that contain the letter t are in?", "rationale": ["Identify the relevant tables: We need to get product category descriptions from the Ref_Product_Categories table and filter products based on their descriptions from the Products table.", "Determine the relationship between tables: The Products table has a foreign key relationship with the Ref_Product_Categories table through the product_category_code.", "Construct the SQL query: We will select the product_category_description from Ref_Product_Categories, join it with Products on product_category_code, and filter the results where the product_description contains the letter 't' using the LIKE operator."], "gold_sql": "SELECT T1.product_category_description FROM ref_product_categories AS T1 JOIN products AS T2 ON T1.product_category_code  =  T2.product_category_code WHERE T2.product_description LIKE '%t%'", "source_tables": ["products", "ref_product_categories"], "pred_sql": "SELECT rpc.product_category_description \nFROM Ref_Product_Categories rpc \nJOIN Products p ON rpc.product_category_code = p.product_category_code \nWHERE p.product_description LIKE '%t%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the descriptions of product categories from the 'Ref_Product_Categories' table for products that have a specific description. The placeholder in the WHERE clause allows for filtering products based on their description.\"\n}\n"}
{"sample_id": "train.5556", "db_id": "products_gen_characteristics", "question": "How many distinct characteristic names does the product \"cumin\" have?", "rationale": ["Identify the product 'cumin' in the Products table.", "Join the Products table with the Product_Characteristics table to link products with their characteristics.", "Join the resulting table with the Characteristics table to access the characteristic names.", "Use COUNT(DISTINCT c.characteristic_name) to count the unique characteristic names associated with the product 'cumin'.", "Filter the results to only include the product where the product name is 'cumin'."], "gold_sql": "SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  'sesame'", "source_tables": ["products", "characteristics", "product_characteristics"], "pred_sql": "SELECT COUNT(DISTINCT c.characteristic_name) \nFROM Products p \nJOIN Product_Characteristics pc ON p.product_id = pc.product_id \nJOIN Characteristics c ON pc.characteristic_id = c.characteristic_id \nWHERE p.product_name = 'cumin';", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the distinct names of characteristics from the 'Characteristics' table. This allows users to retrieve unique characteristic names without duplicates.\"\n}\n"}
{"sample_id": "train.5577", "db_id": "products_gen_characteristics", "question": "How many products have their color described as 'white' or have a characteristic with the name 'hot'?", "rationale": ["Identify the tables involved: Products, Ref_Colors, Product_Characteristics, and Characteristics.", "We need to count the number of products that either have a color described as 'white' or have a characteristic with the name 'hot'.", "Join the Products table with the Ref_Colors table to filter by color description.", "Join the Products table with the Product_Characteristics table to access the characteristics of each product.", "Join the Product_Characteristics table with the Characteristics table to filter by characteristic name.", "Use a WHERE clause to specify the conditions: color_description = 'white' or characteristic_name = 'hot'.", "Use COUNT(DISTINCT p.product_id) to ensure we count each product only once, even if it meets both conditions."], "gold_sql": "SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  'white' OR t3.characteristic_name  =  'hot'", "source_tables": ["products", "ref_colors", "characteristics", "product_characteristics"], "pred_sql": "SELECT COUNT(DISTINCT p.product_id) \nFROM Products p \nLEFT JOIN Ref_Colors c ON p.color_code = c.color_code \nLEFT JOIN Product_Characteristics pc ON p.product_id = pc.product_id \nLEFT JOIN Characteristics ch ON pc.characteristic_id = ch.characteristic_id \nWHERE c.color_description = 'white' OR ch.characteristic_name = 'hot';", "hint": "\n"}
{"sample_id": "train.5579", "db_id": "products_gen_characteristics", "question": "Return the unit of measure for 'Herb' products.", "rationale": ["Identify the relevant tables: Products and Ref_Product_Categories.", "Determine the columns needed: unit_of_measure from Ref_Product_Categories.", "Establish the relationship between Products and Ref_Product_Categories using the product_category_code foreign key.", "Filter the results to include only products that have 'Herb' in their product name using a LIKE clause."], "gold_sql": "SELECT unit_of_measure FROM ref_product_categories WHERE product_category_code  =  'Herbs'", "source_tables": ["ref_product_categories"], "pred_sql": "SELECT Ref_Product_Categories.unit_of_measure \nFROM Products \nJOIN Ref_Product_Categories ON Products.product_category_code = Ref_Product_Categories.product_category_code \nWHERE Products.product_name LIKE '%Herb%';", "hint": "\n"}
{"sample_id": "train.5586", "db_id": "products_gen_characteristics", "question": "Find the unit of measurement and product category code of product named \"chervil\".", "rationale": ["Identify the tables needed: We need to get the unit of measurement and product category code, which are in the Ref_Product_Categories table, and we need to filter by product name, which is in the Products table.", "Join the Ref_Product_Categories table with the Products table on the product_category_code to link product categories with their respective products.", "Use a WHERE clause to filter the results to only include the product named 'chervil'.", "Select the required columns: unit_of_measure and product_category_code from the joined tables."], "gold_sql": "SELECT t2.unit_of_measure ,  t2.product_category_code FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code WHERE t1.product_name  =  'chervil'", "source_tables": ["products", "ref_product_categories"], "pred_sql": "SELECT rpc.unit_of_measure, rpc.product_category_code \nFROM Ref_Product_Categories rpc \nJOIN Products p ON rpc.product_category_code = p.product_category_code \nWHERE p.product_name = 'chervil';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the descriptions of product categories from the 'Ref_Product_Categories' table for products that have a specific description. The placeholder in the WHERE clause allows for filtering products based on their description.\"\n}\n"}
{"sample_id": "train.5590", "db_id": "products_gen_characteristics", "question": "What is the description of the color for most products?", "rationale": ["We need to find the description of the color for most products.", "To do this, we will join the Products table with the Ref_Colors table on the color_code.", "We will count the number of products for each color description using COUNT() and group the results by color description.", "To find the color with the most products, we will order the results in descending order based on the count of products.", "Finally, we will limit the results to 1 to get the color description for the most products."], "gold_sql": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) DESC LIMIT 1", "source_tables": ["products", "ref_colors"], "pred_sql": "SELECT Ref_Colors.color_description, COUNT(Products.product_id) AS product_count\nFROM Products\nJOIN Ref_Colors ON Products.color_code = Ref_Colors.color_code\nGROUP BY Ref_Colors.color_description\nORDER BY product_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the descriptions of product categories from the 'Ref_Product_Categories' table for products that have a specific description. The placeholder in the WHERE clause allows for filtering products based on their description.\"\n}\n"}
{"sample_id": "train.5592", "db_id": "products_gen_characteristics", "question": "What is the description of the color used by least products?", "rationale": ["Identify the relevant tables: We need to find the color descriptions from the Ref_Colors table and the products that use those colors from the Products table.", "Join the Ref_Colors table with the Products table on the color_code to link colors with their respective products.", "Group the results by color_code to count how many products are associated with each color.", "Order the results by the count of products in ascending order to find the color used by the least products.", "Limit the results to 1 to get only the color with the least products."], "gold_sql": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) ASC LIMIT 1", "source_tables": ["products", "ref_colors"], "pred_sql": "SELECT rc.color_description\nFROM Ref_Colors rc\nJOIN Products p ON rc.color_code = p.color_code\nGROUP BY rc.color_code\nORDER BY COUNT(p.product_id) ASC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the descriptions of product categories from the 'Ref_Product_Categories' table for products that have a specific description. The placeholder in the WHERE clause allows for filtering products based on their description.\"\n}\n"}
{"sample_id": "train.5599", "db_id": "products_gen_characteristics", "question": "Give the names of characteristics that are in two or more products?", "rationale": ["We need to find the names of characteristics that are associated with two or more products.", "To do this, we will first identify the characteristic IDs that are linked to two or more products. This can be achieved by using a subquery that counts the distinct product IDs for each characteristic ID in the 'Product_Characteristics' table.", "We will group the results by 'characteristic_id' and use the HAVING clause to filter for those characteristic IDs that have a count of distinct product IDs greater than or equal to 2.", "Once we have the characteristic IDs that meet this condition, we can then retrieve the corresponding characteristic names from the 'Characteristics' table using a SELECT statement that filters by these IDs."], "gold_sql": "SELECT t3.characteristic_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id GROUP BY t3.characteristic_name HAVING count(*)  >= 2", "source_tables": ["products", "characteristics", "product_characteristics"], "pred_sql": "SELECT characteristic_name\nFROM Characteristics\nWHERE characteristic_id IN (\n    SELECT characteristic_id\n    FROM Product_Characteristics\n    GROUP BY characteristic_id\n    HAVING COUNT(DISTINCT product_id) >= 2\n)", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the distinct names of characteristics from the 'Characteristics' table. This allows users to retrieve unique characteristic names without duplicates.\"\n}\n"}
{"sample_id": "train.5633", "db_id": "railway", "question": "List the builders of railways in ascending alphabetical order.", "rationale": ["Identify the relevant table: The 'railway' table contains the 'Builder' column which we need to query.", "Select the 'Builder' column: We want to list the builders, so we will select this column.", "Use DISTINCT to avoid duplicate entries: Since multiple railways can have the same builder, we will use DISTINCT to ensure each builder is listed only once.", "Order the results: We need the results in ascending alphabetical order, so we will use ORDER BY Builder ASC.", "Construct the SQL query: Combine all the elements into a complete SQL query."], "gold_sql": "SELECT Builder FROM railway ORDER BY Builder ASC", "source_tables": ["railway"], "pred_sql": "SELECT DISTINCT Builder FROM railway ORDER BY Builder ASC;", "hint": "\n"}
{"sample_id": "train.5643", "db_id": "railway", "question": "Show the id and builder of the railway that are associated with the most trains.", "rationale": ["Identify the relevant tables: railway and train.", "We need to find the railway associated with the most trains, so we will join the railway table with the train table on the Railway_ID.", "We will group the results by Railway_ID and Builder to count the number of trains associated with each railway.", "Use COUNT(train.Train_ID) to count the number of trains for each railway.", "Order the results in descending order based on the count of trains to get the railway with the most trains at the top.", "Limit the results to 1 to get only the railway associated with the most trains."], "gold_sql": "SELECT T2.Railway_ID ,  T1.Builder FROM railway AS T1 JOIN train AS T2 ON T1.Railway_ID  =  T2.Railway_ID GROUP BY T2.Railway_ID ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["train", "railway"], "pred_sql": "SELECT railway.Railway_ID, railway.Builder \nFROM railway \nJOIN train ON railway.Railway_ID = train.Railway_ID \nGROUP BY railway.Railway_ID, railway.Builder \nORDER BY COUNT(train.Train_ID) DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5645", "db_id": "railway", "question": "Show the most common builder of railways.", "rationale": ["Identify the relevant table: The 'railway' table contains the 'Builder' column which we need to analyze.", "Count the occurrences of each builder: We will use the COUNT() function to count how many railways each builder has constructed.", "Group the results by builder: We will use GROUP BY to aggregate the results based on the 'Builder' column.", "Order the results: To find the most common builder, we will order the results in descending order based on the count of railways.", "Limit the results: Since we only want the most common builder, we will limit the results to 1."], "gold_sql": "SELECT Builder FROM railway GROUP BY Builder ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["railway"], "pred_sql": "SELECT Builder, COUNT(*) as Count FROM railway GROUP BY Builder ORDER BY Count DESC LIMIT 1;", "hint": "\n"}
{"sample_id": "train.5707", "db_id": "dorm_1", "question": "What is the last name of every student who is either female or living in a city with the code BAL or male and under 20?", "rationale": ["Identify the relevant table: The 'Student' table contains the last names and other details of students.", "Determine the conditions for selection: We need students who are either female, live in a city with the code 'BAL', or are male and under 20 years old.", "Construct the WHERE clause: The conditions can be combined using OR operators to filter the results accordingly.", "Select the last names: We only need the last names of the students that meet the criteria, so we will select the 'LName' column."], "gold_sql": "SELECT lname FROM student WHERE sex  =  'F' AND city_code  =  'BAL' UNION SELECT lname FROM student WHERE sex  =  'M' AND age  <  20", "source_tables": ["student"], "pred_sql": "SELECT LName FROM Student WHERE (Sex = 'Female') OR (city_code = 'BAL') OR (Sex = 'Male' AND Age < '20');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of dormitories from the 'Dorm' table that are designated for a specific gender. The placeholder in the WHERE clause represents the gender designation for the dormitory.\"\n}\n"}
{"sample_id": "train.5738", "db_id": "dorm_1", "question": "Find the number of amenities for each of the dorms that can accommodate more than 100 students.", "rationale": ["Identify the tables involved: We need to get information from the Dorm table for dormitory details and the Has_amenity table for amenities.", "Determine the condition: We want dorms that can accommodate more than 100 students, which is specified in the Dorm table under 'student_capacity'.", "Count the amenities: We need to count the number of amenities associated with each dormitory, which can be done using COUNT() on the amenid from the Has_amenity table.", "Join the tables: We will join the Dorm table with the Has_amenity table on the dormid to link dormitories with their amenities.", "Group the results: We will group the results by dorm_name to get the count of amenities for each dormitory."], "gold_sql": "SELECT count(*) ,  T1.dormid FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid WHERE T1.student_capacity  >  100 GROUP BY T1.dormid", "source_tables": ["has_amenity", "dorm"], "pred_sql": "SELECT Dorm.dorm_name, COUNT(Has_amenity.amenid) AS amenity_count\nFROM Dorm\nJOIN Has_amenity ON Dorm.dormid = Has_amenity.dormid\nWHERE Dorm.student_capacity > 100\nGROUP BY Dorm.dorm_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the average and total student capacity of dormitories filtered by a specific gender designation. The placeholder in the WHERE clause represents the gender of the dormitory.\",\n    \"1\": \"This virtual table lists the names of dormitories from the 'Dorm' table that are designated for a specific gender. The placeholder in the WHERE clause represents the gender designation for the dormitory.\"\n}\n"}
{"sample_id": "train.5747", "db_id": "dorm_1", "question": "What are the total number of students who are living in a male dorm?", "rationale": ["Identify the tables involved: Lives_in (which links students to dorms) and Dorm (which contains gender information).", "We need to count the number of distinct students living in male dorms, so we will use COUNT(DISTINCT Lives_in.stuid).", "Join the Lives_in table with the Dorm table on the dormid to access the gender information of the dorms.", "Filter the results to include only those dorms where the gender is 'male'.", "Construct the SQL query to select the count of distinct student IDs from the joined tables with the specified condition."], "gold_sql": "SELECT count(*) FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T3.gender  =  'M'", "source_tables": ["student", "lives_in", "dorm"], "pred_sql": "SELECT COUNT(DISTINCT Lives_in.stuid) AS total_students\nFROM Lives_in\nJOIN Dorm ON Lives_in.dormid = Dorm.dormid\nWHERE Dorm.gender = 'male';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the average and total student capacity of dormitories filtered by a specific gender designation. The placeholder in the WHERE clause represents the gender of the dormitory.\",\n    \"1\": \"This virtual table lists the names of dormitories from the 'Dorm' table that are designated for a specific gender. The placeholder in the WHERE clause represents the gender designation for the dormitory.\"\n}\n"}
{"sample_id": "train.5756", "db_id": "dorm_1", "question": "Find the first name of students who are living in the dorm that has most number of amenities.", "rationale": ["To find the first names of students living in the dorm with the most amenities, we need to identify which dorm has the highest count of amenities.", "We can achieve this by using the Has_amenity table to count the number of amenities for each dormitory, grouping by dormid.", "We will order the results by the count of amenities in descending order and limit the results to 1 to get the dorm with the most amenities.", "Next, we will join this result with the Lives_in table to find which students live in that dormitory.", "Finally, we will join with the Student table to select the first names of those students."], "gold_sql": "SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["has_amenity", "lives_in", "student", "dorm_amenity", "dorm"], "pred_sql": "SELECT S.Fname \nFROM Student S \nJOIN Lives_in L ON S.StuID = L.stuid \nJOIN (\n    SELECT H.dormid, COUNT(H.amenid) AS amenity_count \n    FROM Has_amenity H \n    GROUP BY H.dormid \n    ORDER BY amenity_count DESC \n    LIMIT 1\n) AS MostAmenities ON L.dormid = MostAmenities.dormid;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the average and total student capacity of dormitories filtered by a specific gender designation. The placeholder in the WHERE clause represents the gender of the dormitory.\",\n    \"1\": \"This virtual table lists the names of dormitories from the 'Dorm' table that are designated for a specific gender. The placeholder in the WHERE clause represents the gender designation for the dormitory.\"\n}\n"}
{"sample_id": "train.5765", "db_id": "dorm_1", "question": "What is the first name and age of every student who lives in a dorm with a TV Lounge?", "rationale": ["Identify the required fields: first name and age of students.", "Determine the relationships between tables: Student, Lives_in, Dorm, Has_amenity, and Dorm_amenity.", "Join the Student table with Lives_in to get the dormitory information for each student.", "Join the Lives_in table with Dorm to access dormitory details.", "Join the Dorm table with Has_amenity to filter dorms based on amenities.", "Join the Has_amenity table with Dorm_amenity to specify the amenity we are interested in (TV Lounge).", "Use a WHERE clause to filter results to only those dorms that have a TV Lounge."], "gold_sql": "SELECT T1.fname ,  T1.age FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid NOT IN (SELECT T3.dormid FROM has_amenity AS T3 JOIN dorm_amenity AS T4 ON T3.amenid  =  T4.amenid WHERE T4.amenity_name  =  'TV Lounge')", "source_tables": ["has_amenity", "student", "lives_in", "dorm_amenity"], "pred_sql": "SELECT Student.Fname, Student.Age \nFROM Student \nJOIN Lives_in ON Student.StuID = Lives_in.stuid \nJOIN Dorm ON Lives_in.dormid = Dorm.dormid \nJOIN Has_amenity ON Dorm.dormid = Has_amenity.dormid \nJOIN Dorm_amenity ON Has_amenity.amenid = Dorm_amenity.amenid \nWHERE Dorm_amenity.amenity_name = 'TV Lounge';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of dormitories from the 'Dorm' table that are designated for a specific gender. The placeholder in the WHERE clause represents the gender designation for the dormitory.\",\n    \"1\": \"This virtual table provides the average and total student capacity of dormitories filtered by a specific gender designation. The placeholder in the WHERE clause represents the gender of the dormitory.\"\n}\n"}
{"sample_id": "train.5777", "db_id": "customer_complaints", "question": "What are the emails of customers who have filed complaints on the product which has had the greatest number of complaints?", "rationale": ["Identify the main goal: Retrieve the email addresses of customers who filed complaints about the product with the greatest number of complaints.", "To find the product with the greatest number of complaints, we need to group the complaints by product_id and count them, ordering by the count in descending order and limiting the result to 1.", "Next, we need to join the Customers table with the Complaints table to get the email addresses of the customers who filed those complaints.", "The final SQL query will select the email addresses from the Customers table where the product_id matches the one identified in the subquery."], "gold_sql": "SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "customers"], "pred_sql": "SELECT c.email_address\nFROM Customers c\nJOIN Complaints co ON c.customer_id = co.customer_id\nWHERE co.product_id = (\n    SELECT product_id\n    FROM Complaints\n    GROUP BY product_id\n    ORDER BY COUNT(*) DESC\n    LIMIT 1\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of last names of staff members who are handling complaints related to products, ordered by the price of those products. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n    \"1\": \"This virtual table provides the last names of staff members who are handling complaints, ordered by the date the complaints were raised. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\"\n}\n"}
{"sample_id": "train.5778", "db_id": "customer_complaints", "question": "Which products has been complained by the customer who has filed least amount of complaints?", "rationale": ["Identify the products that have been complained about by customers.", "To find the customer who has filed the least amount of complaints, we need to group the complaints by customer_id and count the number of complaints for each customer.", "We will order the results by the count of complaints in ascending order and limit the results to 1 to get the customer with the least complaints.", "Once we have the customer_id of the customer with the least complaints, we can join the Complaints table with the Products table to find the products associated with that customer.", "The final query selects the product names from the Products table where the product_id matches the complaints made by the identified customer."], "gold_sql": "SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "products", "customers"], "pred_sql": "SELECT p.product_name \nFROM Products p \nJOIN Complaints c ON p.product_id = c.product_id \nWHERE c.customer_id = (\n    SELECT customer_id \n    FROM Complaints \n    GROUP BY customer_id \n    ORDER BY COUNT(complaint_id) ASC \n    LIMIT 1\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of last names of staff members who are handling complaints related to products, ordered by the price of those products. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n    \"1\": \"This virtual table provides the last names of staff members who are handling complaints, ordered by the date the complaints were raised. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\"\n}\n"}
{"sample_id": "train.5795", "db_id": "customer_complaints", "question": "What is the last name of the staff member in charge of the complaint on the product with the lowest price?", "rationale": ["Identify the relevant tables: Staff, Complaints, and Products are needed to find the last name of the staff member handling the complaint related to the product with the lowest price.", "Join the Staff table with the Complaints table on staff_id to link staff members to the complaints they handle.", "Join the Complaints table with the Products table on product_id to link complaints to the products they are about.", "Order the results by the product price in ascending order to get the product with the lowest price at the top.", "Limit the results to 1 to get only the last name of the staff member handling the complaint for the lowest priced product."], "gold_sql": "SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT 1", "source_tables": ["complaints", "products", "staff"], "pred_sql": "SELECT Staff.last_name \nFROM Staff \nJOIN Complaints ON Staff.staff_id = Complaints.staff_id \nJOIN Products ON Complaints.product_id = Products.product_id \nORDER BY Products.product_price ASC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of last names of staff members who are handling complaints related to products, ordered by the price of those products. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n    \"1\": \"This virtual table provides the last names of staff members who are handling complaints, ordered by the date the complaints were raised. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\"\n}\n"}
{"sample_id": "train.5796", "db_id": "customer_complaints", "question": "Which complaint status has more than 3 records on file?", "rationale": ["Identify the relevant table: The Complaints table contains the complaint status information.", "Select the complaint status code: We need to retrieve the complaint_status_code from the Complaints table.", "Count the records: We will use COUNT(*) to count the number of records for each complaint status.", "Group the results: We will group the results by complaint_status_code to aggregate the counts for each status.", "Filter the results: We will use HAVING to filter the groups to only include those with more than 3 records."], "gold_sql": "SELECT complaint_status_code FROM complaints GROUP BY complaint_status_code HAVING count(*)  >  3", "source_tables": ["complaints"], "pred_sql": "SELECT complaint_status_code, COUNT(*) as record_count \nFROM Complaints \nGROUP BY complaint_status_code \nHAVING COUNT(*) > 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the last names of staff members who are handling complaints, ordered by the date the complaints were raised. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n    \"1\": \"This virtual table provides a list of last names of staff members who are handling complaints related to products, ordered by the price of those products. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\"\n}\n"}
{"sample_id": "train.5801", "db_id": "customer_complaints", "question": "Count the number of customers that have the customer type that is most common.", "rationale": ["Identify the table that contains customer information, which is the 'Customers' table.", "We need to count the number of customers, so we will use the COUNT() function.", "To find the most common customer type, we will group the customers by 'customer_type_code' and order the results by the count of customers in descending order.", "We will limit the results to 1 to get the most common customer type.", "Finally, we will use a subquery to filter the main query to count only those customers that match the most common customer type."], "gold_sql": "SELECT count(*) FROM customers GROUP BY customer_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers"], "pred_sql": "SELECT COUNT(*) AS customer_count\nFROM Customers\nWHERE customer_type_code = (\n    SELECT customer_type_code\n    FROM Customers\n    GROUP BY customer_type_code\n    ORDER BY COUNT(*) DESC\n    LIMIT 1\n);", "hint": "\n"}
{"sample_id": "train.5810", "db_id": "customer_complaints", "question": "What is first names of the top 5 staff who have handled the greatest number of complaints?", "rationale": ["Identify the main goal: Retrieve the first names of the top 5 staff members who have handled the greatest number of complaints.", "To achieve this, we need to count the number of complaints handled by each staff member. This can be done using the Complaints table, grouping by staff_id and counting the complaint_id.", "Next, we need to order the results by the count of complaints in descending order to get the staff members with the most complaints at the top.", "Finally, we limit the results to the top 5 staff members.", "To get the first names of these staff members, we will join the results with the Staff table using the staff_id. We will select the first_name from the Staff table for the top 5 staff members identified."], "gold_sql": "SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT 5", "source_tables": ["complaints", "staff"], "pred_sql": "SELECT first_name FROM Staff WHERE staff_id IN (SELECT staff_id FROM Complaints GROUP BY staff_id ORDER BY COUNT(complaint_id) DESC LIMIT 5);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the last names of staff members who are handling complaints, ordered by the date the complaints were raised. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n    \"1\": \"This virtual table provides a list of last names of staff members who are handling complaints related to products, ordered by the price of those products. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\"\n}\n"}
{"sample_id": "train.5811", "db_id": "customer_complaints", "question": "Return the first names of the 5 staff members who have handled the most complaints.", "rationale": ["Identify the main goal: to return the first names of the 5 staff members who have handled the most complaints.", "To achieve this, we need to count the number of complaints handled by each staff member. This can be done by grouping the Complaints table by staff_id and counting the complaint_id.", "Next, we need to order the results by the count of complaints in descending order to get the staff members with the most complaints at the top.", "Finally, we limit the results to the top 5 staff members.", "To get the first names of these staff members, we will join the results from the Complaints table with the Staff table using the staff_id. We will select the first_name from the Staff table for the staff_ids that we obtained from the previous step."], "gold_sql": "SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT 5", "source_tables": ["complaints", "staff"], "pred_sql": "SELECT first_name FROM Staff WHERE staff_id IN (SELECT staff_id FROM Complaints GROUP BY staff_id ORDER BY COUNT(complaint_id) DESC LIMIT 5);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the last names of staff members who are handling complaints, ordered by the date the complaints were raised. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n    \"1\": \"This virtual table provides a list of last names of staff members who are handling complaints related to products, ordered by the price of those products. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\"\n}\n"}
{"sample_id": "train.5845", "db_id": "tracking_share_transactions", "question": "Show all investor details.", "rationale": ["The user wants to see all investor details.", "To retrieve all details from the Investors table, we use the SELECT statement.", "Using '*' allows us to select all columns from the Investors table."], "gold_sql": "SELECT Investor_details FROM INVESTORS", "source_tables": ["investors"], "pred_sql": "SELECT * FROM Investors;", "hint": "\n"}
{"sample_id": "train.5858", "db_id": "tracking_share_transactions", "question": "Show details of all investors if they make any transaction with share count greater than 100.", "rationale": ["Identify the tables involved: Investors and Transactions.", "We need to show details of all investors, so we will select columns from the Investors table.", "We need to filter investors based on their transactions, specifically those with a share count greater than 100.", "To link the Investors with their transactions, we will use a JOIN on the investor_id column.", "The WHERE clause will filter the results to include only those transactions where the share_count is greater than 100."], "gold_sql": "SELECT T1.Investor_details FROM  INVESTORS AS T1 JOIN TRANSACTIONS AS T2 ON T1.investor_id  =  T2.investor_id WHERE T2.share_count  >  100", "source_tables": ["transactions", "investors"], "pred_sql": "SELECT Investors.investor_id, Investors.Investor_details \nFROM Investors \nJOIN Transactions ON Investors.investor_id = Transactions.investor_id \nWHERE Transactions.share_count > 100;", "hint": "\n"}
{"sample_id": "train.5864", "db_id": "tracking_share_transactions", "question": "What are the lot details of lots associated with transactions with share count smaller than 50?", "rationale": ["Identify the relevant tables: Lots, Transactions, and Transactions_Lots.", "We need to retrieve lot details, so we will select 'lot_details' from the Lots table.", "To find lots associated with transactions, we will join the Lots table with the Transactions_Lots table on 'lot_id'.", "Next, we will join the Transactions table to filter based on the share count condition.", "The condition specifies that we only want transactions with a share count smaller than 50, so we will add a WHERE clause for this condition."], "gold_sql": "SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  <  50", "source_tables": ["lots", "transactions_lots", "transactions"], "pred_sql": "SELECT Lots.lot_details \nFROM Lots \nJOIN Transactions_Lots ON Lots.lot_id = Transactions_Lots.lot_id \nJOIN Transactions ON Transactions_Lots.transaction_id = Transactions.transaction_id \nWHERE Transactions.share_count < 50;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the details of lots from the 'Lots' table that are not associated with any transactions. The query uses an EXCEPT clause to filter out lot details that are linked to transactions through the 'Transactions_Lots' table.\"\n}\n"}
{"sample_id": "train.5866", "db_id": "tracking_share_transactions", "question": "Show the average transaction amount for different transaction types.", "rationale": ["We need to calculate the average transaction amount for different transaction types.", "To do this, we will select the transaction type description from the Ref_Transaction_Types table and the average of the amount_of_transaction from the Transactions table.", "We will join the Transactions table with the Ref_Transaction_Types table on the transaction_type_code to get the corresponding descriptions for each transaction type.", "Finally, we will group the results by the transaction type description to get the average amount for each type."], "gold_sql": "SELECT transaction_type_code ,  avg(amount_of_transaction) FROM TRANSACTIONS GROUP BY transaction_type_code", "source_tables": ["transactions"], "pred_sql": "SELECT rt.transaction_type_description, AVG(t.amount_of_transaction) AS average_transaction_amount\nFROM Transactions t\nJOIN Ref_Transaction_Types rt ON t.transaction_type_code = rt.transaction_type_code\nGROUP BY rt.transaction_type_description;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the dates of transactions from the 'Transactions' table that correspond to a specific type of transaction. The placeholder in the WHERE clause represents the transaction type code.\"\n}\n"}
{"sample_id": "train.5867", "db_id": "tracking_share_transactions", "question": "Show the maximum and minimum share count of different transaction types.", "rationale": ["Identify the relevant tables: Transactions and Ref_Transaction_Types are needed to get transaction types and their corresponding share counts.", "We need to find the maximum and minimum share counts for each transaction type, so we will use the aggregate functions MAX() and MIN().", "Join the Transactions table with the Ref_Transaction_Types table on the transaction_type_code to get the description of each transaction type.", "Group the results by transaction_type_description to get the max and min share counts for each type."], "gold_sql": "SELECT transaction_type_code ,  max(share_count) ,  min(share_count) FROM TRANSACTIONS GROUP BY transaction_type_code", "source_tables": ["transactions"], "pred_sql": "SELECT rt.transaction_type_description, MAX(t.share_count) AS max_share_count, MIN(t.share_count) AS min_share_count\nFROM Transactions t\nJOIN Ref_Transaction_Types rt ON t.transaction_type_code = rt.transaction_type_code\nGROUP BY rt.transaction_type_description;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the dates of transactions from the 'Transactions' table that correspond to a specific type of transaction. The placeholder in the WHERE clause represents the transaction type code.\"\n}\n"}
{"sample_id": "train.5883", "db_id": "tracking_share_transactions", "question": "What are the details of all sales and purchases?", "rationale": ["Identify the tables involved: Sales and Purchases.", "Determine the columns needed: sales_transaction_id and sales_details from Sales, purchase_transaction_id and purchase_details from Purchases.", "Since we want details of all sales and purchases, a FULL OUTER JOIN is appropriate to include all records from both tables, even if there are no matches in the other table.", "Construct the SQL query to select the required columns from both tables using the FULL OUTER JOIN."], "gold_sql": "SELECT sales_details FROM sales UNION SELECT purchase_details FROM purchases", "source_tables": ["sales", "purchases"], "pred_sql": "SELECT Sales.sales_transaction_id, Sales.sales_details, Purchases.purchase_transaction_id, Purchases.purchase_details\nFROM Sales\nFULL OUTER JOIN Purchases ON Sales.sales_transaction_id = Purchases.purchase_transaction_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the details of lots from the 'Lots' table that are not associated with any transactions. The query uses an EXCEPT clause to filter out lot details that are linked to transactions through the 'Transactions_Lots' table.\"\n}\n"}
