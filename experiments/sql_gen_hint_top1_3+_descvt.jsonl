{"sample_id": "train.64", "db_id": "student_assessment", "question": "List the id of students who attended some courses?", "rationale": ["We need to find the IDs of students who have attended courses.", "The relevant table for attendance is 'Student_Course_Attendance', which contains the 'student_id' of students who attended courses.", "To get unique student IDs, we will use the DISTINCT keyword to avoid duplicates in the results."], "gold_sql": "SELECT student_id FROM student_course_attendance", "source_tables": ["student_course_attendance"], "pred_sql": "SELECT DISTINCT student_id FROM Student_Course_Attendance;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve course names. The result is grouped by course ID to count the number of students per course.\",\n        \"virtual_table\": \"SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id\"\n    }\n}\n"}
{"sample_id": "train.68", "db_id": "student_assessment", "question": "What details do we have on the students who registered for courses most recently?", "rationale": ["We need to find details on students who registered for courses most recently.", "To do this, we will join the 'Students' table with the 'Student_Course_Registrations' table to get the registration dates.", "Next, we will join with the 'Courses' table to get the course names associated with each registration.", "We will order the results by the registration date in descending order to get the most recent registrations first.", "Finally, we will limit the results to the top 10 most recent registrations."], "gold_sql": "SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT 1", "source_tables": ["student_course_registrations", "students"], "pred_sql": "SELECT S.student_id, S.student_details, SCR.registration_date, C.course_name \nFROM Students AS S \nJOIN Student_Course_Registrations AS SCR ON S.student_id = SCR.student_id \nJOIN Courses AS C ON SCR.course_id = C.course_id \nORDER BY SCR.registration_date DESC \nLIMIT 10;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve course names. The result is grouped by course ID to count the number of students per course.\",\n        \"virtual_table\": \"SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id\"\n    }\n}\n"}
{"sample_id": "train.76", "db_id": "student_assessment", "question": "What is the id of the candidate who most recently accessed the course?", "rationale": ["Identify the relevant tables: Candidates, Student_Course_Attendance, and Student_Course_Registrations.", "We need to find the candidate who accessed a course, which means we need to join Candidates with Student_Course_Attendance on candidate_id and student_id.", "We also need to ensure that we are considering the correct course, so we join with Student_Course_Registrations on student_id and course_id.", "To find the most recent access, we will order the results by date_of_attendance in descending order.", "Finally, we limit the results to 1 to get the most recent candidate."], "gold_sql": "SELECT candidate_id FROM candidate_assessments ORDER BY assessment_date DESC LIMIT 1", "source_tables": ["candidate_assessments"], "pred_sql": "SELECT c.candidate_id\nFROM Candidates c\nJOIN Student_Course_Attendance sca ON c.candidate_id = sca.student_id\nJOIN Student_Course_Registrations scr ON sca.student_id = scr.student_id AND sca.course_id = scr.course_id\nORDER BY sca.date_of_attendance DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.78", "db_id": "student_assessment", "question": "What are the details of the student who registered for the most number of courses?", "rationale": ["We need to find the details of the student who registered for the most number of courses.", "To do this, we will join the 'Students' table with the 'Student_Course_Registrations' table on the student_id.", "We will group the results by student_id to count the number of courses each student has registered for.", "We will order the results in descending order based on the count of course registrations.", "Finally, we will limit the results to 1 to get the student with the highest number of registrations."], "gold_sql": "SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_course_registrations", "students"], "pred_sql": "SELECT T1.student_id, T1.student_details \nFROM Students AS T1 \nJOIN Student_Course_Registrations AS T2 ON T1.student_id = T2.student_id \nGROUP BY T1.student_id \nORDER BY COUNT(T2.course_id) DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve course names. The result is grouped by course ID to count the number of students per course.\",\n        \"virtual_table\": \"SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id\"\n    }\n}\n"}
{"sample_id": "train.82", "db_id": "student_assessment", "question": "For each course id, how many students are registered and what are the course names?", "rationale": ["Identify the tables involved: Students, Student_Course_Registrations, and Courses.", "Join the Students table with the Student_Course_Registrations table on student_id to link students to their course registrations.", "Join the result with the Courses table on course_id to retrieve course names.", "Use COUNT(*) to count the number of students registered for each course.", "Group the results by course_id to get the count for each course."], "gold_sql": "SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id", "source_tables": ["courses", "student_course_registrations", "students"], "pred_sql": "SELECT T3.course_name, COUNT(*) AS student_count FROM Students AS T1 JOIN Student_Course_Registrations AS T2 ON T1.student_id = T2.student_id JOIN Courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve course names. The result is grouped by course ID to count the number of students per course.\",\n        \"virtual_table\": \"SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id\"\n    }\n}\n"}
{"sample_id": "train.89", "db_id": "student_assessment", "question": "What is the id of the student who most recently registered course 301?", "rationale": ["Identify the relevant table for course registrations, which is 'Student_Course_Registrations'.", "Filter the records in 'Student_Course_Registrations' to only include those with course_id '301'.", "Order the results by 'registration_date' in descending order to get the most recent registration first.", "Limit the results to 1 to get only the most recent student registration for course 301."], "gold_sql": "SELECT student_id FROM student_course_attendance WHERE course_id = 301 ORDER BY date_of_attendance DESC LIMIT 1", "source_tables": ["student_course_attendance"], "pred_sql": "SELECT student_id FROM Student_Course_Registrations WHERE course_id = '301' ORDER BY registration_date DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve course names. The result is grouped by course ID to count the number of students per course.\",\n        \"virtual_table\": \"SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id\"\n    }\n}\n"}
{"sample_id": "train.92", "db_id": "student_assessment", "question": "What are the different cities where people live?", "rationale": ["The question asks for different cities where people live, which implies we need to extract unique city names from the database.", "To find the cities, we need to join the 'Addresses' table with the 'People_Addresses' table to link addresses to people.", "Since we are interested in people, we also need to join the 'Students' table to ensure we are only considering individuals who are students.", "Using 'SELECT DISTINCT' will ensure that we only get unique city names without duplicates."], "gold_sql": "SELECT DISTINCT T1.city FROM addresses AS T1 JOIN people_addresses AS T2 ON T1.address_id = T2.address_id", "source_tables": ["addresses", "people_addresses"], "pred_sql": "SELECT DISTINCT T1.city FROM Addresses AS T1 JOIN People_Addresses AS T2 ON T1.address_id = T2.address_id JOIN Students AS T3 ON T2.person_id = T3.student_id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique cities where students are located, by joining the 'Addresses', 'People_Addresses', and 'Students' tables. The placeholders in the query represent the necessary identifiers for the relationships between these tables.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.city FROM addresses AS T1 JOIN people_addresses AS T2 ON T1.address_id = T2.address_id JOIN students AS T3 ON T2.person_id = T3.student_id\"\n    }\n}\n"}
{"sample_id": "train.105", "db_id": "student_assessment", "question": "List the id of students who registered course statistics in the order of registration date.", "rationale": ["Identify the relevant tables: We need to look at the 'Students' and 'Student_Course_Registrations' tables to find students who registered for a specific course.", "Determine the course: The course we are interested in is 'Statistics'. We will need to find the course_id associated with this course from the 'Courses' table.", "Join the tables: We will join the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations.", "Filter by course: We will filter the results to only include registrations for the course 'Statistics'.", "Order by registration date: Finally, we will order the results by the registration date to get the desired output."], "gold_sql": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = 'statistics' ORDER BY T2.registration_date", "source_tables": ["courses", "student_course_registrations"], "pred_sql": "SELECT student_id FROM Student_Course_Registrations WHERE course_id = (SELECT course_id FROM Courses WHERE course_name = 'Statistics') ORDER BY registration_date;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve course names. The result is grouped by course ID to count the number of students per course.\",\n        \"virtual_table\": \"SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id\"\n    }\n}\n"}
{"sample_id": "train.106", "db_id": "student_assessment", "question": "What are the ids of the students who registered course statistics by order of registration date?", "rationale": ["Identify the relevant tables: We need to look at the 'Students' table and the 'Student_Course_Registrations' table to find student registrations.", "Filter for the specific course: We need to filter the registrations to only include those for the course named 'Statistics'.", "Select the student IDs: We want to retrieve the IDs of the students who registered for this course.", "Order by registration date: Finally, we need to order the results by the registration date to meet the requirement of the query."], "gold_sql": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = 'statistics' ORDER BY T2.registration_date", "source_tables": ["courses", "student_course_registrations"], "pred_sql": "SELECT T2.student_id FROM Student_Course_Registrations AS T2 JOIN Courses AS T3 ON T2.course_id = T3.course_id WHERE T3.course_name = 'Statistics' ORDER BY T2.registration_date;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve course names. The result is grouped by course ID to count the number of students per course.\",\n        \"virtual_table\": \"SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id\"\n    }\n}\n"}
{"sample_id": "train.387", "db_id": "flight_1", "question": "Show origins of all flights with destination Honolulu.", "rationale": ["Identify the relevant table: The 'flight' table contains information about flights, including their origins and destinations.", "Determine the required columns: We need the 'origin' column for flights that have 'Honolulu' as their destination.", "Construct the SQL query: Use a SELECT statement to retrieve the 'origin' from the 'flight' table where the 'destination' is 'Honolulu'."], "gold_sql": "SELECT origin FROM Flight WHERE destination  =  'Honolulu'", "source_tables": ["flight"], "pred_sql": "SELECT origin FROM flight WHERE destination = 'Honolulu';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of employees who hold certificates for aircraft that can travel a distance greater than a specified value. The results are grouped by employee ID and ordered by the number of certificates held, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.eid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.390", "db_id": "flight_1", "question": "What are the departure and arrival dates of all flights from LA to Honolulu?", "rationale": ["Identify the relevant table: The 'flight' table contains the information about flights, including departure and arrival dates.", "Determine the columns needed: We need 'departure_date' and 'arrival_date' for the flights.", "Specify the conditions: We want flights that originate from 'LA' and have 'Honolulu' as their destination.", "Construct the SQL query using the SELECT statement to retrieve the specified columns from the 'flight' table with the appropriate WHERE clause."], "gold_sql": "SELECT departure_date ,  arrival_date FROM Flight WHERE origin  =  'Los Angeles' AND destination  =  'Honolulu'", "source_tables": ["flight"], "pred_sql": "SELECT departure_date, arrival_date FROM flight WHERE origin = 'LA' AND destination = 'Honolulu';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of employees who hold certificates for aircraft that can travel a distance greater than a specified value. The results are grouped by employee ID and ordered by the number of certificates held, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.eid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.400", "db_id": "flight_1", "question": "What are the numbers of the shortest flights?", "rationale": ["Identify the relevant table: The 'flight' table contains information about flights, including their distances.", "Determine the requirement: The user wants to find the numbers of the shortest flights, which implies sorting the flights by distance.", "Construct the SQL query: Use 'SELECT flno' to get the flight numbers, 'ORDER BY distance ASC' to sort the flights in ascending order of distance, and 'LIMIT 1' to get only the shortest flight."], "gold_sql": "SELECT flno FROM Flight ORDER BY distance ASC LIMIT 3", "source_tables": ["flight"], "pred_sql": "SELECT flno FROM flight ORDER BY distance ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of employees who hold certificates for aircraft that can travel a distance greater than a specified value. The results are grouped by employee ID and ordered by the number of certificates held, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.eid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.408", "db_id": "flight_1", "question": "What place has the most flights coming from there?", "rationale": ["Identify the table that contains flight information, which is the 'flight' table.", "We need to find out which place has the most flights coming from there, so we will focus on the 'origin' column.", "We will count the number of flights for each origin using COUNT(*) and group the results by the 'origin' column.", "To get the place with the most flights, we will order the results in descending order based on the count of flights.", "Finally, we will limit the results to 1 to get the top origin with the most flights."], "gold_sql": "SELECT origin FROM Flight GROUP BY origin ORDER BY count(*) DESC LIMIT 1", "source_tables": ["flight"], "pred_sql": "SELECT origin, COUNT(*) AS flight_count FROM flight GROUP BY origin ORDER BY flight_count DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of employees who hold certificates for aircraft that can travel a distance greater than a specified value. The results are grouped by employee ID and ordered by the number of certificates held, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.eid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.416", "db_id": "flight_1", "question": "What is the name of each aircraft and how many flights does each one complete?", "rationale": ["Identify the tables needed: We need data from the 'aircraft' table for aircraft names and from the 'flight' table to count the number of flights.", "Use a LEFT JOIN to connect the 'aircraft' table with the 'flight' table on the aircraft ID (aid) to ensure we get all aircraft, even those with no flights.", "Select the aircraft name and count the number of flights (using COUNT(flight.flno)) for each aircraft.", "Group the results by aircraft ID to get the count of flights for each aircraft."], "gold_sql": "SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid", "source_tables": ["aircraft", "flight"], "pred_sql": "SELECT aircraft.name, COUNT(flight.flno) AS flight_count \nFROM aircraft \nLEFT JOIN flight ON aircraft.aid = flight.aid \nGROUP BY aircraft.aid;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of employees who hold certificates for aircraft that can travel a distance greater than a specified value. The results are grouped by employee ID and ordered by the number of certificates held, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.eid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.429", "db_id": "flight_1", "question": "Show names for all employees who do not have certificate of Boeing 737-800.", "rationale": ["Identify the main requirement: to find names of employees without a certificate for the Boeing 737-800.", "Use the 'employee' table to get the names of all employees.", "Use the 'certificate' table to find employees who have a certificate for the Boeing 737-800.", "Join the 'employee' table with the 'certificate' table and the 'aircraft' table to filter out those who have the specified certificate.", "Use the EXCEPT clause to subtract the list of employees who have the certificate from the list of all employees."], "gold_sql": "SELECT name FROM Employee EXCEPT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  'Boeing 737-800'", "source_tables": ["employee", "certificate", "aircraft"], "pred_sql": "SELECT name FROM employee EXCEPT SELECT T1.name FROM employee AS T1 JOIN certificate AS T2 ON T1.eid = T2.eid JOIN aircraft AS T3 ON T3.aid = T2.aid WHERE T3.name = 'Boeing 737-800'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of employees from the 'Employee' table who do not hold a certificate for a specific aircraft model. The placeholder in the query represents the name of the aircraft model.\",\n        \"virtual_table\": \"SELECT name FROM Employee EXCEPT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.433", "db_id": "flight_1", "question": "Show the name and distance of the aircrafts with more than 5000 distance and which at least 5 people have its certificate.", "rationale": ["We need to select the name and distance of aircrafts.", "The aircrafts must have a distance greater than 5000.", "We also need to ensure that at least 5 people have certificates for these aircrafts.", "To achieve this, we will join the 'aircraft' table with the 'certificate' table on the aircraft ID (aid).", "We will group the results by the aircraft ID to count the number of certificates associated with each aircraft.", "Finally, we will use the HAVING clause to filter the results based on the distance and the count of certificates."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  5000 GROUP BY T1.aid ORDER BY count(*)  >=  5", "source_tables": ["aircraft", "certificate"], "pred_sql": "SELECT T3.name, T3.distance FROM aircraft AS T3 JOIN certificate AS T2 ON T3.aid = T2.aid GROUP BY T3.aid HAVING T3.distance > 5000 AND COUNT(T2.eid) >= 5;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of employees who hold certificates for aircraft that can travel a distance greater than a specified value. The results are grouped by employee ID and ordered by the number of certificates held, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.eid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.434", "db_id": "flight_1", "question": "What is the name and distance of every aircraft that can cover a distance of more than 5000 and which at least 5 people can fly?", "rationale": ["Identify the columns needed: name and distance from the aircraft table.", "Determine the condition for distance: it should be greater than 5000.", "Identify the condition for the number of people that can fly: at least 5 people should hold certificates for the aircraft.", "Use a subquery to find aircraft IDs (aid) that have at least 5 certificates associated with them.", "Combine the conditions to form the final SQL query that selects the name and distance of the aircraft meeting both criteria."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  5000 GROUP BY T1.aid ORDER BY count(*)  >=  5", "source_tables": ["aircraft", "certificate"], "pred_sql": "SELECT name, distance FROM aircraft WHERE distance > 5000 AND aid IN (SELECT aid FROM certificate GROUP BY aid HAVING COUNT(eid) >= 5)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of employees who hold certificates for aircraft that can travel a distance greater than a specified value. The results are grouped by employee ID and ordered by the number of certificates held, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.eid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.437", "db_id": "flight_1", "question": "What is the salary and name of the employee who has the most number of certificates on aircrafts with distance more than 5000?", "rationale": ["Identify the tables involved: employee, certificate, and aircraft.", "We need to join these tables to get the employee's name and salary along with the aircraft distance.", "The condition specifies that we only want aircraft with a distance greater than 5000.", "We will group the results by employee ID to count the number of certificates each employee holds.", "We will order the results by the count of certificates in descending order to find the employee with the most certificates.", "Finally, we limit the results to 1 to get only the top employee."], "gold_sql": "SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  5000 GROUP BY T1.eid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employee", "certificate", "aircraft"], "pred_sql": "SELECT T1.name, T1.salary FROM employee AS T1 JOIN certificate AS T2 ON T1.eid = T2.eid JOIN aircraft AS T3 ON T3.aid = T2.aid WHERE T3.distance > 5000 GROUP BY T1.eid ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of employees who hold certificates for aircraft that can travel a distance greater than a specified value. The results are grouped by employee ID and ordered by the number of certificates held, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.eid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.448", "db_id": "allergy_1", "question": "What are all the different food allergies?", "rationale": ["The question asks for all the different food allergies, which implies we need to retrieve unique allergy names.", "The relevant table for allergies is 'Allergy_Type', which contains the column 'Allergy' that lists the names of the allergies.", "To ensure we get only unique allergy names, we will use the DISTINCT keyword in our SQL query."], "gold_sql": "SELECT DISTINCT allergy FROM Allergy_type WHERE allergytype  =  'food'", "source_tables": ["allergy_type"], "pred_sql": "SELECT DISTINCT Allergy FROM Allergy_Type", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.456", "db_id": "allergy_1", "question": "Which allergy type is most common?", "rationale": ["Identify the tables involved: Has_Allergy and Allergy_Type.", "We need to count the occurrences of each allergy type, so we will use COUNT() function.", "Join the Has_Allergy table with the Allergy_Type table on the Allergy column to get the type of each allergy.", "Group the results by AllergyType to aggregate the counts for each type.", "Order the results by the count in descending order to find the most common allergy type.", "Limit the results to 1 to get only the most common allergy type."], "gold_sql": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT 1", "source_tables": ["allergy_type"], "pred_sql": "SELECT AllergyType, COUNT(*) as AllergyCount FROM Has_Allergy JOIN Allergy_Type ON Has_Allergy.Allergy = Allergy_Type.Allergy GROUP BY AllergyType ORDER BY AllergyCount DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.458", "db_id": "allergy_1", "question": "Which allergy type is the least common?", "rationale": ["Identify the tables involved: Allergy_Type and Has_Allergy.", "We need to count the occurrences of each allergy type, so we will join the Allergy_Type table with the Has_Allergy table on the Allergy column.", "Use COUNT(*) to count how many students have each allergy type.", "Group the results by AllergyType to get the count for each type.", "Order the results by the count in ascending order to find the least common allergy type.", "Limit the results to 1 to get only the least common allergy type."], "gold_sql": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) ASC LIMIT 1", "source_tables": ["allergy_type"], "pred_sql": "SELECT AllergyType, COUNT(*) AS AllergyCount FROM Allergy_Type AT JOIN Has_Allergy HA ON AT.Allergy = HA.Allergy GROUP BY AllergyType ORDER BY AllergyCount ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.462", "db_id": "allergy_1", "question": "What are the full names of all students", "rationale": ["Identify the table that contains student names, which is the 'Student' table.", "To get the full names, we need to concatenate the 'Fname' and 'LName' columns.", "Use the SQL SELECT statement to retrieve the concatenated names as 'FullName'."], "gold_sql": "SELECT Fname ,  Lname FROM Student", "source_tables": ["student"], "pred_sql": "SELECT Fname || ' ' || LName AS FullName FROM Student;", "hint": "\n"}
{"sample_id": "train.472", "db_id": "allergy_1", "question": "What are the student ids for all male students?", "rationale": ["Identify the relevant table: The 'Student' table contains the information about students, including their gender.", "Determine the condition: We need to filter the students based on their gender, specifically for male students.", "Construct the SQL query: We will select the 'StuID' from the 'Student' table where the 'Sex' column is equal to 'Male'."], "gold_sql": "SELECT StuID FROM Student WHERE Sex  =  'M'", "source_tables": ["student"], "pred_sql": "SELECT StuID FROM Student WHERE Sex = 'Male'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the WHERE clause represent the gender of the students and the type of allergy they have.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.492", "db_id": "allergy_1", "question": "What is the largest major?", "rationale": ["Identify the table that contains the major information, which is the 'Student' table.", "To find the largest major, we need to count the number of students in each major.", "We will use the COUNT function to count the number of students for each major.", "We will group the results by the 'Major' column to get the count for each major.", "To find the largest major, we will order the results in descending order based on the count of students.", "Finally, we will limit the results to 1 to get the major with the highest count."], "gold_sql": "SELECT major FROM Student GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Major FROM Student GROUP BY Major ORDER BY COUNT(*) DESC LIMIT 1;", "hint": "\n"}
{"sample_id": "train.501", "db_id": "allergy_1", "question": "Which advisor has most number of students?", "rationale": ["Identify the relevant table: The 'Student' table contains the 'Advisor' and 'StuID' columns.", "Count the number of students for each advisor: Use COUNT(StuID) to count the number of students associated with each advisor.", "Group the results by advisor: Use GROUP BY Advisor to aggregate the counts for each advisor.", "Order the results to find the advisor with the most students: Use ORDER BY StudentCount DESC to sort the advisors by the number of students in descending order.", "Limit the results to the top advisor: Use LIMIT 1 to get only the advisor with the highest count."], "gold_sql": "SELECT advisor FROM Student GROUP BY advisor ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Advisor, COUNT(StuID) AS StudentCount\nFROM Student\nGROUP BY Advisor\nORDER BY StudentCount DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.504", "db_id": "allergy_1", "question": "How many students are affected by cat allergies?", "rationale": ["Identify the relevant table: We need to find students with cat allergies, so we will focus on the Has_Allergy table.", "Determine the condition: We are looking for records where the Allergy column matches 'cat'.", "Count the distinct students: We want to know how many unique students have this allergy, so we will use COUNT(DISTINCT StuID).", "Construct the SQL query: Combine the elements identified above into a complete SQL query."], "gold_sql": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  'Cat'", "source_tables": ["has_allergy"], "pred_sql": "SELECT COUNT(DISTINCT StuID) FROM Has_Allergy WHERE Allergy = 'cat';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.508", "db_id": "allergy_1", "question": "Which students are unaffected by allergies?", "rationale": ["We need to find students who are unaffected by allergies.", "A student is considered unaffected if their StuID does not appear in the Has_Allergy table.", "We can achieve this by selecting all students from the Student table where their StuID is not in the list of StuIDs from the Has_Allergy table."], "gold_sql": "SELECT StuID FROM Student EXCEPT SELECT StuID FROM Has_allergy", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT * FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_Allergy)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.509", "db_id": "allergy_1", "question": "How many female students have milk or egg allergies?", "rationale": ["Identify the target demographic: female students.", "Determine the allergies of interest: milk and egg allergies.", "Join the Student table with the Has_Allergy table to filter students based on their allergies.", "Count the number of female students who have either milk or egg allergies."], "gold_sql": "SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  'F' AND T1.allergy  =  'Milk' OR T1.allergy  =  'Eggs'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT COUNT(*) FROM Student WHERE Sex = 'Female' AND StuID IN (SELECT StuID FROM Has_Allergy WHERE Allergy IN ('Milk', 'Egg'));", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.510", "db_id": "allergy_1", "question": "How many students who are female are allergic to milk or eggs?", "rationale": ["Identify the target group: female students.", "Count the number of students who are female.", "Filter the students based on their allergies to either milk or eggs.", "Use a subquery to find students with the specified allergies from the Has_Allergy table.", "Combine the conditions to count only those female students who have the specified allergies."], "gold_sql": "SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  'F' AND T1.allergy  =  'Milk' OR T1.allergy  =  'Eggs'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT COUNT(*) FROM Student WHERE Sex = 'Female' AND StuID IN (SELECT StuID FROM Has_Allergy WHERE Allergy IN ('Milk', 'Eggs'))", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.513", "db_id": "allergy_1", "question": "Which allergy has most number of students affected?", "rationale": ["Identify the table that contains the information about allergies and students affected by them, which is the Has_Allergy table.", "To find out which allergy has the most number of students affected, we need to count the number of unique students (StuID) for each allergy.", "We will use the COUNT function to count the number of students for each allergy and group the results by the Allergy column.", "To get the allergy with the highest count, we will order the results in descending order based on the count and limit the results to 1."], "gold_sql": "SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT 1", "source_tables": ["has_allergy"], "pred_sql": "SELECT Allergy, COUNT(StuID) AS StudentCount FROM Has_Allergy GROUP BY Allergy ORDER BY StudentCount DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.518", "db_id": "allergy_1", "question": "How many students are affected by each allergy type?", "rationale": ["Identify the tables involved: Allergy_Type, Has_Allergy, and Student.", "We need to count the number of students affected by each allergy type, which means we need to group the results by AllergyType.", "Join the Allergy_Type table with the Has_Allergy table on the Allergy column to link allergies to students.", "Then, join the resulting table with the Student table on the StuID to get student information.", "Use COUNT() to count the number of unique StuID for each AllergyType.", "Group the results by AllergyType to get the count for each type."], "gold_sql": "SELECT T2.allergytype ,  count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy GROUP BY T2.allergytype", "source_tables": ["has_allergy", "allergy_type"], "pred_sql": "SELECT AT.AllergyType, COUNT(S.StuID) AS StudentCount\nFROM Allergy_Type AS AT\nJOIN Has_Allergy AS HA ON AT.Allergy = HA.Allergy\nJOIN Student AS S ON HA.StuID = S.StuID\nGROUP BY AT.AllergyType;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.520", "db_id": "allergy_1", "question": "What are the last names and ages of the students who are allergic to milk and cat?", "rationale": ["Identify the information needed: last names and ages of students with specific allergies.", "Determine the relevant tables: Student and Has_Allergy.", "Use the Has_Allergy table to filter students who have allergies to 'milk' and 'cat'.", "Select the StuID from Has_Allergy where the Allergy is either 'milk' or 'cat'.", "Join this result with the Student table to get the last names and ages of those students."], "gold_sql": "SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT LName, Age FROM Student WHERE StuID IN (SELECT StuID FROM Has_Allergy WHERE Allergy IN ('milk', 'cat'))", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.522", "db_id": "allergy_1", "question": "What are the allergies the girl named Lisa has? And what are the types of them? Order the result by allergy names.", "rationale": ["Identify the tables needed: Student, Has_Allergy, and Allergy_Type.", "We need to find allergies for a specific student named Lisa, so we will filter the Student table by first name and gender.", "Join the Has_Allergy table to link students with their allergies using StuID.", "Join the Allergy_Type table to get the type of each allergy.", "Select the Allergy and AllergyType columns from the joined tables.", "Order the results by the Allergy names."], "gold_sql": "SELECT T1.Allergy ,  T1.AllergyType FROM Allergy_type AS T1 JOIN Has_allergy AS T2 ON T1.Allergy  =  T2.Allergy JOIN Student AS T3 ON T3.StuID  =  T2.StuID WHERE T3.Fname  =  'Lisa' ORDER BY T1.Allergy", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT A.Allergy, T.AllergyType FROM Student S JOIN Has_Allergy H ON S.StuID = H.StuID JOIN Allergy_Type A ON H.Allergy = A.Allergy WHERE S.Fname = 'Lisa' AND S.Sex = 'Female' ORDER BY A.Allergy;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.525", "db_id": "allergy_1", "question": "Find the average age of the students who have allergies with food and animal types.", "rationale": ["Identify the goal: Calculate the average age of students with specific allergy types (food and animal).", "Understand the schema: We need to join the Student table with Has_Allergy and Allergy_Type to filter students based on their allergies.", "Use the INTERSECT operator to find students who have both food and animal allergies.", "Construct the inner queries to select StuID from Has_Allergy where the allergies match the specified types.", "Finally, calculate the average age from the Student table for the filtered StuIDs."], "gold_sql": "SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food' INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'animal')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT avg(Age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_Allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.AllergyType = 'food' INTERSECT SELECT T1.StuID FROM Has_Allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.AllergyType = 'animal')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.527", "db_id": "allergy_1", "question": "List the first and last name of the students who do not have any food type allergy.", "rationale": ["Identify the tables involved: Student, Has_Allergy, and Allergy_Type.", "Determine the required output: first and last names of students without food allergies.", "Use a subquery to find students with food allergies by joining Has_Allergy and Allergy_Type on the Allergy column.", "Filter the results of the subquery to only include those with AllergyType = 'Food'.", "Use the NOT IN clause to exclude these students from the main query that selects from the Student table."], "gold_sql": "SELECT fname ,  lname FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT Fname, LName FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_Allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.AllergyType = 'Food')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of students from the 'Student' table who do not have a specific type of allergy. The placeholder in the subquery represents the allergy type that is being filtered out.\",\n        \"virtual_table\": \"SELECT fname ,  lname FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.529", "db_id": "allergy_1", "question": "Find the number of male (sex is 'M') students who have some food type allery.", "rationale": ["Identify the requirement to count students who are male and have a food allergy.", "Use the 'Student' table to filter students by gender (Sex = 'M').", "Join the 'Has_Allergy' table with the 'Allergy_Type' table to filter for students with a specific type of allergy (Food).", "Use a subquery to find the StuID of students who have a food allergy by joining the two tables on the Allergy column.", "Count the number of students that meet both criteria: being male and having a food allergy."], "gold_sql": "SELECT count(*) FROM Student WHERE sex  =  'M' AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT count(*) FROM Student WHERE Sex = 'M' AND StuID IN (SELECT StuID FROM Has_Allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.AllergyType = 'Food')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the WHERE clause represent the gender of the students and the type of allergy they have.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.531", "db_id": "allergy_1", "question": "Find the different first names and cities of the students who have allergy to milk or cat.", "rationale": ["Identify the tables needed: We need data from the Student and Has_Allergy tables.", "Determine the columns to select: We want distinct first names (Fname) and city codes (city_code) of students.", "Establish the relationship: We need to join the Student table with the Has_Allergy table on StuID.", "Filter the results: We only want students who have allergies to either 'milk' or 'cat'.", "Construct the SQL query using the SELECT statement, JOIN clause, and WHERE condition."], "gold_sql": "SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  'Milk' OR T2.Allergy  =  'Cat'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT DISTINCT S.Fname, S.city_code FROM Student S JOIN Has_Allergy H ON S.StuID = H.StuID WHERE H.Allergy IN ('milk', 'cat');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.533", "db_id": "allergy_1", "question": "Find the number of students who are older than 18 and do not have allergy to either food or animal.", "rationale": ["Identify the main table to query from, which is the 'Student' table.", "We need to count the number of students, so we will use the COUNT function.", "The condition specifies that we are interested in students older than 18, so we will add a WHERE clause with 'Age > 18'.", "Next, we need to exclude students who have allergies to either food or animals.", "To do this, we will use a subquery that selects 'StuID' from the 'Has_Allergy' table joined with the 'Allergy_Type' table.", "In the subquery, we will filter for allergies where the 'AllergyType' is either 'food' or 'animal'.", "Finally, we will combine these conditions in the main query to get the desired count of students."], "gold_sql": "SELECT count(*) FROM Student WHERE age  >  18 AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food' OR T2.allergytype  =  'animal')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT count(*) FROM Student WHERE Age > 18 AND StuID NOT IN ( SELECT StuID FROM Has_Allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.AllergyType = 'food' OR T2.AllergyType = 'animal')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the allergy types to be excluded.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE age  >  [PLACEHOLDER-TYPE:NUMBER] AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] OR T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.535", "db_id": "allergy_1", "question": "Find the first name and major of the students who are not allegry to soy.", "rationale": ["Identify the required fields: first name (Fname) and major from the Student table.", "Determine the condition: students who do not have an allergy to soy.", "Use a subquery to find students with an allergy to soy by joining Has_Allergy and Allergy_Type tables.", "The subquery selects StuID from Has_Allergy where the allergy matches 'soy'.", "The main query selects Fname and Major from Student where StuID is not in the result of the subquery."], "gold_sql": "SELECT fname ,  major FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Soy')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT Fname, Major FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_Allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.Allergy = 'soy')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of students from the 'Student' table who do not have a specific type of allergy. The placeholder in the subquery represents the allergy type that is being filtered out.\",\n        \"virtual_table\": \"SELECT fname ,  lname FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.542", "db_id": "store_1", "question": "What are the names of the countries and average invoice size of the top countries by size?", "rationale": ["Identify the relevant table: The invoices table contains the billing country and total amount of each invoice.", "Select the columns needed: We need the billing_country and the average of the total column.", "Use the AVG() function to calculate the average invoice size for each country.", "Group the results by billing_country to get the average for each country.", "Order the results by average_invoice_size in descending order to get the top countries by size.", "Limit the results to the top 10 countries."], "gold_sql": "SELECT billing_country ,  AVG(total) FROM invoices GROUP BY billing_country ORDER BY AVG(total) DESC LIMIT 10;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_country, AVG(total) AS average_invoice_size\nFROM invoices\nGROUP BY billing_country\nORDER BY average_invoice_size DESC\nLIMIT 10;", "hint": "\n"}
{"sample_id": "train.553", "db_id": "store_1", "question": "List every album ordered by album title in ascending order.", "rationale": ["Identify the table that contains album information, which is the 'albums' table.", "Determine the column that holds the album titles, which is 'title'.", "Specify that we want to select the 'title' column from the 'albums' table.", "Add an ORDER BY clause to sort the results by 'title' in ascending order."], "gold_sql": "SELECT title FROM albums ORDER BY title;", "source_tables": ["albums"], "pred_sql": "SELECT title FROM albums ORDER BY title ASC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of tracks from the 'tracks' table that have been purchased by customers with a specific first and last name. The placeholders in the WHERE clause represent the customer's first and last names.\",\n        \"virtual_table\": \"SELECT T1.name FROM tracks AS T1 JOIN invoice_lines AS T2 ON T1.id = T2.track_id JOIN invoices AS T3 ON T3.id = T2.invoice_id JOIN customers AS T4 ON T4.id = T3.customer_id WHERE T4.first_name = [PLACEHOLDER-TYPE:STRING] AND T4.last_name = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.560", "db_id": "store_1", "question": "What are the total amount of money in the invoices billed from Chicago, Illinois?", "rationale": ["Identify the relevant table: invoices, as it contains billing information and total amounts.", "Determine the columns needed: total (for the amount) and billing_city, billing_state (for filtering).", "Formulate the SQL query to sum the total amounts from invoices where the billing city is 'Chicago' and the billing state is 'Illinois'.", "Use the SUM() function to calculate the total amount and apply the WHERE clause to filter the results accordingly."], "gold_sql": "SELECT sum(total) FROM invoices WHERE billing_city  =  'Chicago' AND billing_state  =  'IL';", "source_tables": ["invoices"], "pred_sql": "SELECT SUM(total) AS total_amount FROM invoices WHERE billing_city = 'Chicago' AND billing_state = 'Illinois';", "hint": "\n"}
{"sample_id": "train.564", "db_id": "store_1", "question": "How many invoices were billed from each state?", "rationale": ["Identify the relevant table: The invoices table contains the billing information including the state.", "Determine the required fields: We need the billing_state and a count of invoices for each state.", "Use the COUNT() function to count the number of invoices for each state.", "Group the results by billing_state to get the count for each state."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_state, COUNT(*) AS invoice_count\nFROM invoices\nGROUP BY billing_state;", "hint": "\n"}
{"sample_id": "train.565", "db_id": "store_1", "question": "List the state in the US with the most invoices.", "rationale": ["We need to find the state in the US with the most invoices.", "The relevant table for invoices is the 'invoices' table, which contains a column 'billing_state'.", "To count the number of invoices per state, we will use the COUNT() function and group the results by 'billing_state'.", "We will order the results in descending order based on the count of invoices to get the state with the most invoices at the top.", "Finally, we will limit the results to 1 to get only the state with the highest count."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT 1;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_state, COUNT(*) AS invoice_count\nFROM invoices\nGROUP BY billing_state\nORDER BY invoice_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.566", "db_id": "store_1", "question": "What are the states with the most invoices?", "rationale": ["Identify the relevant table: The 'invoices' table contains the billing information including the state.", "Determine the required information: We need to count the number of invoices per state.", "Use the COUNT() function to count invoices grouped by 'billing_state'.", "Group the results by 'billing_state' to aggregate the counts for each state.", "Order the results in descending order to find the states with the most invoices."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT 1;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_state, COUNT(*) AS invoice_count\nFROM invoices\nGROUP BY billing_state\nORDER BY invoice_count DESC;", "hint": "\n"}
{"sample_id": "train.567", "db_id": "store_1", "question": "List the number of invoices and the invoice total from California.", "rationale": ["We need to count the number of invoices and sum the total of those invoices from customers in California.", "The relevant tables are 'invoices' and 'customers'.", "We will join the 'invoices' table with the 'customers' table on the customer_id field.", "We will filter the results to include only those customers who are located in California using a WHERE clause.", "Finally, we will use COUNT(*) to get the number of invoices and SUM(total) to get the total amount of those invoices."], "gold_sql": "SELECT billing_state ,  COUNT(*) ,  SUM(total) FROM invoices WHERE billing_state  =  'CA';", "source_tables": ["invoices"], "pred_sql": "SELECT COUNT(*) AS number_of_invoices, SUM(total) AS invoice_total\nFROM invoices\nJOIN customers ON invoices.customer_id = customers.id\nWHERE customers.state = 'California';", "hint": "\n"}
{"sample_id": "train.575", "db_id": "store_1", "question": "What is Astrid Gruber's email and phone number?", "rationale": ["Identify the table that contains employee information, which is the 'employees' table.", "Determine the columns needed for the output, which are 'email' and 'phone'.", "Filter the results to find the specific employee by their first name 'Astrid' and last name 'Gruber'.", "Construct the SQL query using a SELECT statement to retrieve the desired columns from the 'employees' table with the appropriate WHERE clause."], "gold_sql": "SELECT email ,  phone FROM customers WHERE first_name = 'Astrid' AND last_name = 'Gruber';", "source_tables": ["customers"], "pred_sql": "SELECT email, phone FROM employees WHERE first_name = 'Astrid' AND last_name = 'Gruber';", "hint": "\n"}
{"sample_id": "train.593", "db_id": "store_1", "question": "Find the full name of employee who supported the most number of customers.", "rationale": ["Identify the relevant tables: employees and customers.", "We need to find the employee who has supported the most customers, which means we need to join the employees table with the customers table on the support_rep_id.", "Use GROUP BY to group the results by employee ID, which will allow us to count the number of customers each employee has supported.", "Use COUNT to count the number of customers for each employee.", "Order the results in descending order based on the count of customers supported.", "Limit the results to 1 to get the employee with the highest count."], "gold_sql": "SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employees", "customers"], "pred_sql": "SELECT e.first_name || ' ' || e.last_name AS full_name\nFROM employees e\nJOIN customers c ON e.id = c.support_rep_id\nGROUP BY e.id\nORDER BY COUNT(c.id) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.594", "db_id": "store_1", "question": "What is the full name of the employee who has the most customers?", "rationale": ["Identify the relevant tables: employees and customers.", "We need to find the employee who has the most customers, so we will join the employees table with the customers table on the support_rep_id.", "We will group the results by employee ID to count the number of customers each employee has.", "We will order the results in descending order based on the count of customers to find the employee with the most customers.", "Finally, we will limit the results to 1 to get only the top employee.", "Select the full name of the employee by concatenating first_name and last_name."], "gold_sql": "SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employees", "customers"], "pred_sql": "SELECT e.first_name || ' ' || e.last_name AS full_name\nFROM employees e\nJOIN customers c ON e.id = c.support_rep_id\nGROUP BY e.id\nORDER BY COUNT(c.id) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.604", "db_id": "store_1", "question": "How many employees who are IT staff are from each city?", "rationale": ["Identify the relevant table: The 'employees' table contains information about employees, including their job titles and cities.", "Determine the criteria: We need to filter employees who are in the IT staff, which can be identified by checking if the 'title' column contains 'IT'.", "Count the number of employees: We will use the COUNT() function to count the number of employees that meet the criteria.", "Group the results: We will group the results by 'city' to get the count of IT staff from each city."], "gold_sql": "SELECT count(*) ,  city FROM employees WHERE title  =  'IT Staff' GROUP BY city", "source_tables": ["employees"], "pred_sql": "SELECT city, COUNT(*) AS employee_count \nFROM employees \nWHERE title LIKE '%IT%' \nGROUP BY city;", "hint": "\n"}
{"sample_id": "train.624", "db_id": "store_1", "question": "What is the name of the album that has the track Ball to the Wall?", "rationale": ["Identify the relevant tables: We need to find the album title, which is in the 'albums' table, and we need to link it to the 'tracks' table to find the specific track.", "Determine the relationship: The 'albums' table is linked to the 'tracks' table through the 'album_id' foreign key in the 'tracks' table.", "Formulate the SQL query: We will select the album title from the 'albums' table and join it with the 'tracks' table on the album ID, filtering for the track name 'Ball to the Wall'."], "gold_sql": "SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T2.name = 'Balls to the Wall';", "source_tables": ["albums", "tracks"], "pred_sql": "SELECT albums.title \nFROM albums \nJOIN tracks ON albums.id = tracks.album_id \nWHERE tracks.name = 'Ball to the Wall';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of tracks from the 'tracks' table that have been purchased by customers with a specific first and last name. The placeholders in the WHERE clause represent the customer's first and last names.\",\n        \"virtual_table\": \"SELECT T1.name FROM tracks AS T1 JOIN invoice_lines AS T2 ON T1.id = T2.track_id JOIN invoices AS T3 ON T3.id = T2.invoice_id JOIN customers AS T4 ON T4.id = T3.customer_id WHERE T4.first_name = [PLACEHOLDER-TYPE:STRING] AND T4.last_name = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.632", "db_id": "store_1", "question": "What are the names of all tracks that belong to the Rock genre and whose media type is MPEG?", "rationale": ["Identify the relevant tables: genres, tracks, and media_types.", "Join the genres table with the tracks table on the genre_id to filter tracks by genre.", "Join the tracks table with the media_types table on the media_type_id to filter tracks by media type.", "Use the WHERE clause to specify the genre as 'Rock' and the media type as 'MPEG'.", "Construct the SQL query using the identified tables and conditions."], "gold_sql": "SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = 'Rock' OR T3.name = 'MPEG audio file';", "source_tables": ["tracks", "genres", "media_types"], "pred_sql": "SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = 'Rock' AND T3.name = 'MPEG';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of tracks from the 'tracks' table that belong to a specific genre and media type. The placeholders in the WHERE clause represent the genre's name and the media type's name.\",\n        \"virtual_table\": \"SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = [PLACEHOLDER-TYPE:STRING] AND T3.name = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.946", "db_id": "medicine_enzyme_interaction", "question": "What are the names and trade names of the medcines that are FDA approved?", "rationale": ["Identify the relevant table: The 'medicine' table contains the information about medicines, including their names, trade names, and FDA approval status.", "Determine the required columns: We need the 'name' and 'Trade_Name' columns from the 'medicine' table.", "Specify the condition: We only want medicines that are FDA approved, which is indicated by the 'FDA_approved' column being equal to 'yes'.", "Construct the SQL query: Combine the selected columns and the condition into a SQL SELECT statement."], "gold_sql": "SELECT name ,  trade_name FROM medicine WHERE FDA_approved  =  'Yes'", "source_tables": ["medicine"], "pred_sql": "SELECT name, Trade_Name FROM medicine WHERE FDA_approved = 'yes'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names and trade names of medicines from the 'medicine' table that do not interact with a specific enzyme product. The placeholder in the EXCEPT clause represents the product associated with the enzyme.\",\n        \"virtual_table\": \"SELECT name ,  trade_name FROM medicine EXCEPT SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id JOIN enzyme AS T3 ON T3.id  =  T2.enzyme_id WHERE T3.product  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.951", "db_id": "medicine_enzyme_interaction", "question": "What are the ids, names and FDA approval status of medicines in descending order of the number of enzymes that it can interact with.", "rationale": ["Identify the columns needed: ids, names, and FDA approval status of medicines.", "To get the number of enzymes each medicine interacts with, we need to join the 'medicine' table with the 'medicine_enzyme_interaction' table.", "Use a LEFT JOIN to include all medicines, even those that do not interact with any enzymes.", "Group the results by medicine id, name, and FDA approval status to count the number of enzyme interactions for each medicine.", "Count the enzyme interactions using COUNT() function and alias it as 'enzyme_count'.", "Finally, order the results in descending order based on the enzyme count."], "gold_sql": "SELECT T1.id ,  T1.Name ,  T1.FDA_approved FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id GROUP BY T1.id ORDER BY count(*) DESC", "source_tables": ["medicine", "medicine_enzyme_interaction"], "pred_sql": "SELECT m.id, m.name, m.FDA_approved, COUNT(mei.enzyme_id) AS enzyme_count \nFROM medicine m \nLEFT JOIN medicine_enzyme_interaction mei ON m.id = mei.medicine_id \nGROUP BY m.id, m.name, m.FDA_approved \nORDER BY enzyme_count DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names and trade names of medicines from the 'medicine' table that do not interact with a specific enzyme product. The placeholder in the EXCEPT clause represents the product associated with the enzyme.\",\n        \"virtual_table\": \"SELECT name ,  trade_name FROM medicine EXCEPT SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id JOIN enzyme AS T3 ON T3.id  =  T2.enzyme_id WHERE T3.product  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.953", "db_id": "medicine_enzyme_interaction", "question": "What is the id and name of the enzyme with most number of medicines that can interact as 'activator'?", "rationale": ["Identify the relevant tables: We need to work with the 'enzyme' and 'medicine_enzyme_interaction' tables to find the enzyme that interacts with the most medicines as an 'activator'.", "Join the tables: We will join the 'enzyme' table with the 'medicine_enzyme_interaction' table on the enzyme ID to get the necessary data about interactions.", "Filter the interactions: We will filter the results to only include those interactions where the interaction type is 'activator'.", "Group the results: We will group the results by enzyme ID and name to count the number of medicines that interact with each enzyme.", "Order the results: We will order the results in descending order based on the count of interacting medicines to find the enzyme with the most interactions.", "Limit the results: Finally, we will limit the results to only the top entry to get the enzyme with the most medicines that can interact as 'activator'."], "gold_sql": "SELECT T1.id ,  T1.name FROM enzyme AS T1 JOIN medicine_enzyme_interaction AS T2 ON T1.id  =  T2.enzyme_id WHERE T2.interaction_type  =  'activitor' GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["enzyme", "medicine_enzyme_interaction"], "pred_sql": "SELECT e.id, e.name\nFROM enzyme e\nJOIN medicine_enzyme_interaction mei ON e.id = mei.enzyme_id\nWHERE mei.interaction_type = 'activator'\nGROUP BY e.id, e.name\nORDER BY COUNT(mei.medicine_id) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names and trade names of medicines from the 'medicine' table that do not interact with a specific enzyme product. The placeholder in the EXCEPT clause represents the product associated with the enzyme.\",\n        \"virtual_table\": \"SELECT name ,  trade_name FROM medicine EXCEPT SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id JOIN enzyme AS T3 ON T3.id  =  T2.enzyme_id WHERE T3.product  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.968", "db_id": "medicine_enzyme_interaction", "question": "What are the medicine and trade names that can interact as an inhibitor and activitor with enzymes?", "rationale": ["Identify the relevant tables: medicine, enzyme, and medicine_enzyme_interaction.", "We need to retrieve the names and trade names of medicines that interact with enzymes as either inhibitors or activators.", "Join the medicine table with the medicine_enzyme_interaction table on the medicine_id to get the interaction details.", "Join the enzyme table to access enzyme-related information if needed, but primarily focus on the interaction type.", "Filter the results to include only those interactions where the interaction_type is either 'inhibitor' or 'activator'.", "Select the required columns: name and Trade_Name from the medicine table."], "gold_sql": "SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id WHERE interaction_type  =  'inhibitor' INTERSECT SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id WHERE interaction_type  =  'activitor'", "source_tables": ["medicine", "medicine_enzyme_interaction"], "pred_sql": "SELECT m.name, m.Trade_Name FROM medicine AS m JOIN medicine_enzyme_interaction AS mei ON mei.medicine_id = m.id JOIN enzyme AS e ON e.id = mei.enzyme_id WHERE mei.interaction_type IN ('inhibitor', 'activator')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names and trade names of medicines from the 'medicine' table that do not interact with a specific enzyme product. The placeholder in the EXCEPT clause represents the product associated with the enzyme.\",\n        \"virtual_table\": \"SELECT name ,  trade_name FROM medicine EXCEPT SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id JOIN enzyme AS T3 ON T3.id  =  T2.enzyme_id WHERE T3.product  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.970", "db_id": "medicine_enzyme_interaction", "question": "What are the medicine and trade names that cannot interact with the enzyme with the product 'Heme'?", "rationale": ["Identify the main requirement: to find medicine and trade names that cannot interact with the enzyme that produces 'Heme'.", "Use the medicine table to get the names and trade names of all medicines.", "To find medicines that interact with the enzyme producing 'Heme', join the medicine table with the medicine_enzyme_interaction table and the enzyme table.", "Filter the results of the join to only include those where the enzyme's product is 'Heme'.", "Use the EXCEPT clause to exclude the medicines that interact with the 'Heme' enzyme from the complete list of medicines."], "gold_sql": "SELECT name ,  trade_name FROM medicine EXCEPT SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id JOIN enzyme AS T3 ON T3.id  =  T2.enzyme_id WHERE T3.product  =  'Protoporphyrinogen IX'", "source_tables": ["enzyme", "medicine", "medicine_enzyme_interaction"], "pred_sql": "SELECT name, trade_name FROM medicine EXCEPT SELECT T1.name, T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id = T1.id JOIN enzyme AS T3 ON T3.id = T2.enzyme_id WHERE T3.product = 'Heme'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names and trade names of medicines from the 'medicine' table that do not interact with a specific enzyme product. The placeholder in the EXCEPT clause represents the product associated with the enzyme.\",\n        \"virtual_table\": \"SELECT name ,  trade_name FROM medicine EXCEPT SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id JOIN enzyme AS T3 ON T3.id  =  T2.enzyme_id WHERE T3.product  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.1355", "db_id": "college_2", "question": "What is the name of the department with an instructure who has a name like 'Soisalon'?", "rationale": ["We need to find the name of the department that has an instructor with a name like 'Soisalon'.", "To do this, we will join the 'department' table with the 'instructor' table on the 'dept_name' column, since the instructor belongs to a department.", "We will then filter the results using a WHERE clause to find instructors whose name matches the pattern 'Soisalon'.", "Finally, we will select the 'dept_name' from the resulting joined table."], "gold_sql": "SELECT dept_name FROM instructor WHERE name LIKE '%Soisalon%'", "source_tables": ["instructor"], "pred_sql": "SELECT dept_name FROM department AS T1 JOIN instructor AS T2 ON T1.dept_name = T2.dept_name WHERE T2.name LIKE 'Soisalon';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of distinct students and instructors associated with each academic department. It joins the 'department', 'student', and 'instructor' tables based on the department name, and groups the results by department name to provide a count of unique students and instructors for each department.\",\n        \"virtual_table\": \"SELECT count(DISTINCT T2.id) ,  count(DISTINCT T3.id) ,  T3.dept_name FROM department AS T1 JOIN student AS T2 ON T1.dept_name  =  T2.dept_name JOIN instructor AS T3 ON T1.dept_name  =  T3.dept_name GROUP BY T3.dept_name\"\n    }\n}\n"}
{"sample_id": "train.1365", "db_id": "college_2", "question": "What are the titles of courses that are in the Statistics department but not the Psychology department?", "rationale": ["Identify the relevant table: The 'course' table contains the titles of courses and their associated departments.", "Filter for courses in the Statistics department: Use a WHERE clause to specify that dept_name must be 'Statistics'.", "Exclude courses in the Psychology department: Since we want courses that are not in the Psychology department, we can use a condition that checks for this exclusion.", "Construct the SQL query: Combine the conditions into a single SELECT statement that retrieves the titles of the courses meeting the criteria."], "gold_sql": "SELECT title FROM course WHERE dept_name  =  'Statistics' EXCEPT SELECT title FROM course WHERE dept_name  =  'Psychology'", "source_tables": ["course"], "pred_sql": "SELECT title FROM course WHERE dept_name = 'Statistics' AND dept_name != 'Psychology';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of students who are not enrolled in any courses offered by a specific department. The placeholder in the subquery represents the department's name.\",\n        \"virtual_table\": \"SELECT name FROM student WHERE id NOT IN (SELECT T1.id FROM takes AS T1 JOIN course AS T2 ON T1.course_id  =  T2.course_id WHERE T2.dept_name  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.1424", "db_id": "college_2", "question": "Find the title of course whose prerequisite is course Differential Geometry.", "rationale": ["Identify the course title we need to find, which is linked to a prerequisite.", "We need to join the 'course' table with the 'prereq' table to find courses that have prerequisites.", "The prerequisite we are interested in is 'Differential Geometry'.", "To find the course_id for 'Differential Geometry', we can use a subquery that selects the course_id from the 'course' table where the title matches 'Differential Geometry'.", "Finally, we select the title of the course from the 'course' table that matches the course_id found in the prerequisite table."], "gold_sql": "SELECT title FROM course WHERE course_id IN (SELECT T1.course_id FROM prereq AS T1 JOIN course AS T2 ON T1.prereq_id  =  T2.course_id WHERE T2.title  =  'Differential Geometry')", "source_tables": ["course", "prereq"], "pred_sql": "SELECT c.title \nFROM course c \nJOIN prereq p ON c.course_id = p.course_id \nWHERE p.prereq_id = (SELECT course_id FROM course WHERE title = 'Differential Geometry');", "hint": "\n"}
{"sample_id": "train.1426", "db_id": "college_2", "question": "Find the names of students who have taken any course in the fall semester of year 2003.", "rationale": ["We need to find the names of students who have taken any course in the fall semester of year 2003.", "To do this, we will join the 'student' table with the 'takes' table on the student ID.", "Next, we will join the 'takes' table with the 'section' table to access the semester and year information for the courses taken by the students.", "We will filter the results to include only those records where the semester is 'Fall' and the year is '2003'.", "Finally, we will select the 'name' column from the 'student' table to get the desired output."], "gold_sql": "SELECT name FROM student WHERE id IN (SELECT id FROM takes WHERE semester  =  'Fall' AND YEAR  =  2003)", "source_tables": ["student", "takes"], "pred_sql": "SELECT student.name \nFROM student \nJOIN takes ON student.ID = takes.ID \nJOIN section ON takes.course_id = section.course_id AND takes.sec_id = section.sec_id \nWHERE section.semester = 'Fall' AND section.year = '2003';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of students who are not enrolled in any courses offered by a specific department. The placeholder in the subquery represents the department's name.\",\n        \"virtual_table\": \"SELECT name FROM student WHERE id NOT IN (SELECT T1.id FROM takes AS T1 JOIN course AS T2 ON T1.course_id  =  T2.course_id WHERE T2.dept_name  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.1435", "db_id": "college_2", "question": "What are the names of all instructors who advise students in the math depart sorted by total credits of the student.", "rationale": ["Identify the tables involved: advisor, instructor, student, and department.", "Join the advisor table with the instructor table to get the names of instructors who are advisors.", "Join the resulting table with the student table to get the total credits of the students advised by those instructors.", "Join with the department table to filter for students in the math department.", "Use a WHERE clause to specify that we only want students from the math department.", "Order the results by the total credits of the students in descending order."], "gold_sql": "SELECT T2.name FROM advisor AS T1 JOIN instructor AS T2 ON T1.i_id  =  T2.id JOIN student AS T3 ON T1.s_id  =  T3.id WHERE T3.dept_name  =  'Math' ORDER BY T3.tot_cred", "source_tables": ["instructor", "student", "advisor"], "pred_sql": "SELECT T2.name FROM advisor AS T1 JOIN instructor AS T2 ON T1.i_ID = T2.ID JOIN student AS T3 ON T1.s_ID = T3.ID JOIN department AS T4 ON T3.dept_name = T4.dept_name WHERE T4.dept_name = 'math' ORDER BY T3.tot_cred DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of instructors who are advisors to students, ordered by the total credits earned by the students in descending order. The placeholder in the LIMIT clause represents the maximum number of instructor names to be returned.\",\n        \"virtual_table\": \"SELECT T2.name FROM advisor AS T1 JOIN instructor AS T2 ON T1.i_id  =  T2.id JOIN student AS T3 ON T1.s_id  =  T3.id ORDER BY T3.tot_cred DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1436", "db_id": "college_2", "question": "What is the course title of the prerequisite of course Mobile Computing?", "rationale": ["Identify the course title of the prerequisite for 'Mobile Computing'.", "First, find the course_id for 'Mobile Computing' from the course table.", "Next, use the prereq table to find the prerequisite course_id associated with 'Mobile Computing'.", "Finally, join the course table again to get the title of the course that corresponds to the prerequisite course_id."], "gold_sql": "SELECT title FROM course WHERE course_id IN (SELECT T1.prereq_id FROM prereq AS T1 JOIN course AS T2 ON T1.course_id  =  T2.course_id WHERE T2.title  =  'Mobile Computing')", "source_tables": ["course", "prereq"], "pred_sql": "SELECT c.title \nFROM course c \nJOIN prereq p ON c.course_id = p.prereq_id \nWHERE p.course_id = (SELECT course_id FROM course WHERE title = 'Mobile Computing');", "hint": "\n"}
{"sample_id": "train.1439", "db_id": "college_2", "question": "What is the name of the instructor who advises the student with the greatest number of total credits?", "rationale": ["Identify the tables involved: advisor, instructor, and student.", "We need to find the instructor who advises the student with the greatest number of total credits.", "Join the advisor table with the instructor table to get the names of instructors.", "Join the advisor table with the student table to access the total credits of students.", "Order the results by total credits in descending order to get the student with the highest credits at the top.", "Limit the results to 1 to get only the name of the instructor advising the top student."], "gold_sql": "SELECT T2.name FROM advisor AS T1 JOIN instructor AS T2 ON T1.i_id  =  T2.id JOIN student AS T3 ON T1.s_id  =  T3.id ORDER BY T3.tot_cred DESC LIMIT 1", "source_tables": ["instructor", "student", "advisor"], "pred_sql": "SELECT T2.name FROM advisor AS T1 JOIN instructor AS T2 ON T1.i_ID = T2.ID JOIN student AS T3 ON T1.s_ID = T3.ID ORDER BY T3.tot_cred DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of instructors who are advisors to students, ordered by the total credits earned by the students in descending order. The placeholder in the LIMIT clause represents the maximum number of instructor names to be returned.\",\n        \"virtual_table\": \"SELECT T2.name FROM advisor AS T1 JOIN instructor AS T2 ON T1.i_id  =  T2.id JOIN student AS T3 ON T1.s_id  =  T3.id ORDER BY T3.tot_cred DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1448", "db_id": "college_2", "question": "Find the number and averaged salary of all instructors who are in the department with the highest budget.", "rationale": ["Identify the department with the highest budget by selecting the 'dept_name' from the 'department' table and ordering by 'budget' in descending order, limiting the result to 1.", "Count the number of instructors in that department using COUNT(ID) from the 'instructor' table where 'dept_name' matches the department identified in the previous step.", "Calculate the average salary of instructors in that department using AVG(salary) from the 'instructor' table with the same condition on 'dept_name'.", "Combine the count and average salary in a single SELECT statement."], "gold_sql": "SELECT avg(T1.salary) ,  count(*) FROM instructor AS T1 JOIN department AS T2 ON T1.dept_name  =  T2.dept_name ORDER BY T2.budget DESC LIMIT 1", "source_tables": ["instructor", "department"], "pred_sql": "SELECT COUNT(ID) AS instructor_count, AVG(salary) AS average_salary \nFROM instructor \nWHERE dept_name = (SELECT dept_name \n                   FROM department \n                   ORDER BY budget DESC \n                   LIMIT 1);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of distinct students and instructors associated with each academic department. It joins the 'department', 'student', and 'instructor' tables based on the department name, and groups the results by department name to provide a count of unique students and instructors for each department.\",\n        \"virtual_table\": \"SELECT count(DISTINCT T2.id) ,  count(DISTINCT T3.id) ,  T3.dept_name FROM department AS T1 JOIN student AS T2 ON T1.dept_name  =  T2.dept_name JOIN instructor AS T3 ON T1.dept_name  =  T3.dept_name GROUP BY T3.dept_name\"\n    }\n}\n"}
{"sample_id": "train.1449", "db_id": "college_2", "question": "How many instructors are in the department with the highest budget, and what is their average salary?", "rationale": ["Identify the department with the highest budget by selecting the 'dept_name' from the 'department' table and ordering by 'budget' in descending order, limiting the result to 1.", "Use the result from the previous step to filter the 'instructor' table, counting the number of instructors and calculating the average salary for that department."], "gold_sql": "SELECT avg(T1.salary) ,  count(*) FROM instructor AS T1 JOIN department AS T2 ON T1.dept_name  =  T2.dept_name ORDER BY T2.budget DESC LIMIT 1", "source_tables": ["instructor", "department"], "pred_sql": "SELECT COUNT(ID) AS instructor_count, AVG(salary) AS average_salary \nFROM instructor \nWHERE dept_name = (SELECT dept_name \n                   FROM department \n                   ORDER BY budget DESC \n                   LIMIT 1);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of distinct students and instructors associated with each academic department. It joins the 'department', 'student', and 'instructor' tables based on the department name, and groups the results by department name to provide a count of unique students and instructors for each department.\",\n        \"virtual_table\": \"SELECT count(DISTINCT T2.id) ,  count(DISTINCT T3.id) ,  T3.dept_name FROM department AS T1 JOIN student AS T2 ON T1.dept_name  =  T2.dept_name JOIN instructor AS T3 ON T1.dept_name  =  T3.dept_name GROUP BY T3.dept_name\"\n    }\n}\n"}
{"sample_id": "train.1452", "db_id": "college_2", "question": "Find the name of students who didn't take any course from Biology department.", "rationale": ["Identify the main requirement: Find students who didn't take any course from the Biology department.", "Use the student table to get the names of students.", "To find students who didn't take any courses from Biology, we need to exclude those who are enrolled in courses from the Biology department.", "Create a subquery that selects student IDs from the takes table that join with the course table where the department name is 'Biology'.", "Use the NOT IN clause to filter out these student IDs from the main query that selects names from the student table."], "gold_sql": "SELECT name FROM student WHERE id NOT IN (SELECT T1.id FROM takes AS T1 JOIN course AS T2 ON T1.course_id  =  T2.course_id WHERE T2.dept_name  =  'Biology')", "source_tables": ["course", "student", "takes"], "pred_sql": "SELECT name FROM student WHERE ID NOT IN (SELECT T1.ID FROM takes AS T1 JOIN course AS T2 ON T1.course_id = T2.course_id WHERE T2.dept_name = 'Biology')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of students who are not enrolled in any courses offered by a specific department. The placeholder in the subquery represents the department's name.\",\n        \"virtual_table\": \"SELECT name FROM student WHERE id NOT IN (SELECT T1.id FROM takes AS T1 JOIN course AS T2 ON T1.course_id  =  T2.course_id WHERE T2.dept_name  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.1458", "db_id": "college_2", "question": "Find the name and salary of instructors whose salary is below the average salary of the instructors in the Physics department.", "rationale": ["Identify the relevant table: The 'instructor' table contains the information about instructors, including their names and salaries.", "Determine the condition: We need to find instructors whose salary is below the average salary of instructors in the Physics department.", "Calculate the average salary: Use a subquery to calculate the average salary of instructors in the Physics department by filtering the 'instructor' table where dept_name is 'Physics'.", "Combine the conditions: Use a SELECT statement to retrieve the name and salary of instructors from the 'instructor' table where their salary is less than the average salary calculated in the subquery."], "gold_sql": "SELECT name ,  salary FROM instructor WHERE salary  <  (SELECT avg(salary) FROM instructor WHERE dept_name  =  'Physics')", "source_tables": ["instructor"], "pred_sql": "SELECT name, salary FROM instructor WHERE salary < (SELECT AVG(salary) FROM instructor WHERE dept_name = 'Physics');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of instructors who are advisors to students, ordered by the total credits earned by the students in descending order. The placeholder in the LIMIT clause represents the maximum number of instructor names to be returned.\",\n        \"virtual_table\": \"SELECT T2.name FROM advisor AS T1 JOIN instructor AS T2 ON T1.i_id  =  T2.id JOIN student AS T3 ON T1.s_id  =  T3.id ORDER BY T3.tot_cred DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1461", "db_id": "college_2", "question": "What are the names of students who have taken Statistics courses?", "rationale": ["Identify the relevant tables: We need to find student names, so we will use the 'student' table. We also need to check which courses they have taken, so we will use the 'takes' and 'course' tables.", "Determine the relationship between tables: The 'takes' table links students to the courses they have taken through the student ID and course ID. The 'course' table contains the course titles.", "Filter for Statistics courses: We need to filter the courses to only include those that have 'Statistics' in their title. This can be done using a LIKE clause in the WHERE condition.", "Select the student names: Finally, we will select the names of the students who meet the criteria."], "gold_sql": "SELECT T3.name FROM course AS T1 JOIN takes AS T2 ON T1.course_id  =  T2.course_id JOIN student AS T3 ON T2.id  =  T3.id WHERE T1.dept_name  =  'Statistics'", "source_tables": ["course", "student", "takes"], "pred_sql": "SELECT student.name FROM student JOIN takes ON student.ID = takes.ID JOIN course ON takes.course_id = course.course_id WHERE course.title LIKE '%Statistics%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of students who are not enrolled in any courses offered by a specific department. The placeholder in the subquery represents the department's name.\",\n        \"virtual_table\": \"SELECT name FROM student WHERE id NOT IN (SELECT T1.id FROM takes AS T1 JOIN course AS T2 ON T1.course_id  =  T2.course_id WHERE T2.dept_name  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.1464", "db_id": "college_2", "question": "Find the names of all instructors in computer science department", "rationale": ["Identify the table that contains instructor information, which is the 'instructor' table.", "Determine the relevant column for instructor names, which is 'name'.", "Identify the department of interest, which is 'computer science'.", "Construct the SQL query to select the names of instructors from the 'instructor' table where the 'dept_name' matches 'computer science'."], "gold_sql": "SELECT name FROM instructor WHERE dept_name  =  'Comp. Sci.'", "source_tables": ["instructor"], "pred_sql": "SELECT name FROM instructor WHERE dept_name = 'computer science'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of instructors who are advisors to students, ordered by the total credits earned by the students in descending order. The placeholder in the LIMIT clause represents the maximum number of instructor names to be returned.\",\n        \"virtual_table\": \"SELECT T2.name FROM advisor AS T1 JOIN instructor AS T2 ON T1.i_id  =  T2.id JOIN student AS T3 ON T1.s_id  =  T3.id ORDER BY T3.tot_cred DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1480", "db_id": "college_2", "question": "Find courses that ran in Fall 2009 but not in Spring 2010.", "rationale": ["Identify the courses that were offered in Fall 2009 by joining the 'course' and 'section' tables on 'course_id'.", "Filter the results to include only those sections that were offered in the Fall semester of 2009.", "To find courses that did not run in Spring 2010, create a subquery that selects 'course_id' from the 'section' table for the Spring semester of 2010.", "Use the NOT IN clause to exclude any courses from the Fall 2009 results that appear in the Spring 2010 subquery."], "gold_sql": "SELECT course_id FROM SECTION WHERE semester  =  'Fall' AND YEAR  =  2009 EXCEPT SELECT course_id FROM SECTION WHERE semester  =  'Spring' AND YEAR  =  2010", "source_tables": ["section"], "pred_sql": "SELECT DISTINCT c.title \nFROM course c \nJOIN section s1 ON c.course_id = s1.course_id \nWHERE s1.semester = 'Fall' AND s1.year = '2009' \nAND c.course_id NOT IN (\n    SELECT s2.course_id \n    FROM section s2 \n    WHERE s2.semester = 'Spring' AND s2.year = '2010'\n);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of students who are not enrolled in any courses offered by a specific department. The placeholder in the subquery represents the department's name.\",\n        \"virtual_table\": \"SELECT name FROM student WHERE id NOT IN (SELECT T1.id FROM takes AS T1 JOIN course AS T2 ON T1.course_id  =  T2.course_id WHERE T2.dept_name  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.1489", "db_id": "college_2", "question": "What are the names of instructors who earn more than at least one instructor from the Biology department?", "rationale": ["Identify the main requirement: we need the names of instructors who earn more than at least one instructor from the Biology department.", "To find this, we need to compare the salaries of instructors with those in the Biology department.", "We can use a subquery to find the maximum salary of instructors in the Biology department.", "The subquery will be: SELECT MAX(salary) FROM instructor WHERE dept_name = 'Biology'.", "The main query will select the names of instructors whose salary is greater than the result of the subquery.", "Combine these into a single SQL statement."], "gold_sql": "SELECT name FROM instructor WHERE salary  >  (SELECT min(salary) FROM instructor WHERE dept_name  =  'Biology')", "source_tables": ["instructor"], "pred_sql": "SELECT name FROM instructor WHERE salary > (SELECT MAX(salary) FROM instructor WHERE dept_name = 'Biology')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of instructors who are advisors to students, ordered by the total credits earned by the students in descending order. The placeholder in the LIMIT clause represents the maximum number of instructor names to be returned.\",\n        \"virtual_table\": \"SELECT T2.name FROM advisor AS T1 JOIN instructor AS T2 ON T1.i_id  =  T2.id JOIN student AS T3 ON T1.s_id  =  T3.id ORDER BY T3.tot_cred DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1515", "db_id": "insurance_and_eClaims", "question": "Find the total and average amount paid in claim headers.", "rationale": ["The task is to find the total and average amount paid in claim headers.", "To achieve this, we need to use the Claim_Headers table, which contains the Amount_Paid column.", "We can use the SUM() function to calculate the total amount paid and the AVG() function to calculate the average amount paid.", "The SQL query will select the sum and average of the Amount_Paid column from the Claim_Headers table."], "gold_sql": "SELECT sum(amount_piad) ,  avg(amount_piad) FROM claim_headers", "source_tables": ["claim_headers"], "pred_sql": "SELECT SUM(Amount_Piad) AS Total_Amount_Paid, AVG(Amount_Piad) AS Average_Amount_Paid FROM Claim_Headers;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves detailed information about customers associated with claims that have the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to their respective policies, and then joins with the 'Customers' table to get customer details. The placeholder in the WHERE clause represents the minimum amount paid for claims.\",\n        \"virtual_table\": \"SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)\"\n    }\n}\n"}
{"sample_id": "train.1516", "db_id": "insurance_and_eClaims", "question": "What are the total amount and average amount paid in claim headers?", "rationale": ["Identify the relevant table: The 'Claim_Headers' table contains the 'Amount_Piad' column which is needed to calculate the total and average amounts paid.", "Use aggregate functions: To get the total amount paid, use the SUM function, and to get the average amount paid, use the AVG function.", "Construct the SQL query: Combine the SUM and AVG functions in a SELECT statement from the 'Claim_Headers' table."], "gold_sql": "SELECT sum(amount_piad) ,  avg(amount_piad) FROM claim_headers", "source_tables": ["claim_headers"], "pred_sql": "SELECT SUM(Amount_Piad) AS Total_Amount_Paid, AVG(Amount_Piad) AS Average_Amount_Paid FROM Claim_Headers;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves detailed information about customers associated with claims that have the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to their respective policies, and then joins with the 'Customers' table to get customer details. The placeholder in the WHERE clause represents the minimum amount paid for claims.\",\n        \"virtual_table\": \"SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)\"\n    }\n}\n"}
{"sample_id": "train.1517", "db_id": "insurance_and_eClaims", "question": "Find the total amount claimed in the most recently created document.", "rationale": ["Identify the relevant tables: Claim_Headers and Claims_Documents are needed to find the total amount claimed associated with the most recently created document.", "Join Claim_Headers with Claims_Documents on Claim_Header_ID and Claim_ID to link claims with their documents.", "Use the SUM function to calculate the total amount claimed from the Claim_Headers table.", "To find the most recently created document, use a subquery to get the maximum Created_Date from the Claims_Documents table."], "gold_sql": "SELECT sum(t1.amount_claimed) FROM claim_headers AS t1 JOIN claims_documents AS t2 ON t1.claim_header_id  =  t2.claim_id WHERE t2.created_date  =  (SELECT created_date FROM claims_documents ORDER BY created_date LIMIT 1)", "source_tables": ["claims_documents", "claim_headers"], "pred_sql": "SELECT SUM(ch.Amount_Claimed) AS Total_Amount_Claimed \nFROM Claim_Headers AS ch \nJOIN Claims_Documents AS cd ON ch.Claim_Header_ID = cd.Claim_ID \nWHERE cd.Created_Date = (SELECT MAX(Created_Date) FROM Claims_Documents)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the detailed information about customers associated with the claim that has the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to policies, and then joins with the 'Customers' table to get customer details. The placeholder in the WHERE clause represents the minimum amount paid for claims.\",\n        \"virtual_table\": \"SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)\"\n    }\n}\n"}
{"sample_id": "train.1519", "db_id": "insurance_and_eClaims", "question": "What is the name of the customer who has made the largest amount of claim in a single claim?", "rationale": ["Identify the relevant tables: Claim_Headers for claims, Policies for linking claims to customers, and Customers for customer details.", "Join the Claim_Headers table with the Policies table on Policy_ID to link claims to their respective policies.", "Join the resulting table with the Customers table on Customer_ID to retrieve customer details.", "Use a subquery to find the maximum amount claimed from the Claim_Headers table.", "Filter the results to only include the customer(s) who made the claim with the maximum amount claimed."], "gold_sql": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_claimed  =  (SELECT max(amount_claimed) FROM claim_headers)", "source_tables": ["policies", "customers", "claim_headers"], "pred_sql": "SELECT t3.Customer_Details FROM Claim_Headers AS t1 JOIN Policies AS t2 ON t1.Policy_ID = t2.Policy_ID JOIN Customers AS t3 ON t2.Customer_ID = t3.Customer_ID WHERE t1.Amount_Claimed = (SELECT max(Amount_Claimed) FROM Claim_Headers)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the detailed information about customers associated with the claim that has the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to policies, and then joins with the 'Customers' table to get customer details. The placeholder in the WHERE clause represents the minimum amount paid for claims.\",\n        \"virtual_table\": \"SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)\"\n    }\n}\n"}
{"sample_id": "train.1527", "db_id": "insurance_and_eClaims", "question": "What is the name of the claim processing stage that most of the claims are on?", "rationale": ["We need to find the claim processing stage that most claims are currently in.", "To do this, we will join the Claims_Processing table with the Claims_Processing_Stages table on the Claim_Stage_ID.", "We will then group the results by Claim_Status_Name to count how many claims are in each stage.", "Finally, we will order the results by the count of claims in descending order and limit the results to 1 to get the stage with the most claims."], "gold_sql": "SELECT t2.claim_status_name FROM claims_processing AS t1 JOIN claims_processing_stages AS t2 ON t1.claim_stage_id  =  t2.claim_stage_id GROUP BY t1.claim_stage_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["claims_processing", "claims_processing_stages"], "pred_sql": "SELECT cps.Claim_Status_Name, COUNT(*) as Claim_Count\nFROM Claims_Processing cp\nJOIN Claims_Processing_Stages cps ON cp.Claim_Stage_ID = cps.Claim_Stage_ID\nGROUP BY cps.Claim_Status_Name\nORDER BY Claim_Count DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the detailed information about customers associated with the claim that has the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to policies, and then joins with the 'Customers' table to get customer details. The placeholder in the WHERE clause represents the minimum amount paid for claims.\",\n        \"virtual_table\": \"SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)\"\n    }\n}\n"}
{"sample_id": "train.1535", "db_id": "insurance_and_eClaims", "question": "Find the names of all the customers and staff members.", "rationale": ["Identify the tables needed: Customers and Staff.", "Determine the columns to select: Customer_Details from Customers and Staff_Details from Staff.", "Use a SELECT statement to retrieve the desired columns.", "Since we want to find names from both tables, we can use a cross join (implicit join) by listing both tables in the FROM clause."], "gold_sql": "SELECT customer_details FROM customers UNION SELECT staff_details FROM staff", "source_tables": ["staff", "customers"], "pred_sql": "SELECT Customers.Customer_Details AS Customer_Name, Staff.Staff_Details AS Staff_Name \nFROM Customers, Staff;", "hint": "\n"}
{"sample_id": "train.1545", "db_id": "insurance_and_eClaims", "question": "Which customer is associated with the latest policy?", "rationale": ["Identify the relevant tables: We need to find the customer associated with the latest policy, so we will work with the 'Policies' and 'Customers' tables.", "Determine the latest policy: The latest policy can be identified by finding the maximum 'Start_Date' in the 'Policies' table.", "Join the tables: We will join the 'Policies' table with the 'Customers' table using the 'Customer_ID' to get the customer details associated with the latest policy.", "Construct the SQL query: The final query will select the customer details from the 'Customers' table where the 'Start_Date' of the policy is the maximum 'Start_Date' from the 'Policies' table."], "gold_sql": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)", "source_tables": ["policies", "customers"], "pred_sql": "SELECT t3.Customer_Details FROM Policies AS t1 JOIN Customers AS t3 ON t1.Customer_ID = t3.Customer_ID WHERE t1.Start_Date = (SELECT MAX(Start_Date) FROM Policies)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the detailed information about customers associated with the claim that has the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to policies, and then joins with the 'Customers' table to get customer details. The placeholder in the WHERE clause represents the minimum amount paid for claims.\",\n        \"virtual_table\": \"SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)\"\n    }\n}\n"}
{"sample_id": "train.1546", "db_id": "insurance_and_eClaims", "question": "Find the customer who started a policy most recently.", "rationale": ["Identify the relevant tables: We need to find information about customers and their policies, so we will use the Customers and Policies tables.", "Determine the relationship: The Policies table has a foreign key linking to the Customers table via Customer_ID.", "Find the most recent policy: We need to find the policy with the maximum Start_Date, which indicates the most recent policy.", "Construct the SQL query: We will select the Customer_Details from the Customers table where the Start_Date of the policy matches the maximum Start_Date found in the Policies table."], "gold_sql": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)", "source_tables": ["policies", "customers"], "pred_sql": "SELECT t3.Customer_Details FROM Policies AS t1 JOIN Customers AS t3 ON t1.Customer_ID = t3.Customer_ID WHERE t1.Start_Date = (SELECT MAX(Start_Date) FROM Policies)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the detailed information about customers associated with the claim that has the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to policies, and then joins with the 'Customers' table to get customer details. The placeholder in the WHERE clause represents the minimum amount paid for claims.\",\n        \"virtual_table\": \"SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)\"\n    }\n}\n"}
{"sample_id": "train.1553", "db_id": "customers_and_invoices", "question": "Show the id, the account name, and other account details for all accounts by the customer with first name 'Meaghan'.", "rationale": ["Identify the relevant tables: Accounts and Customers.", "Determine the columns needed: account_id, account_name, and other_account_details from Accounts.", "Establish the relationship between Accounts and Customers using the customer_id foreign key.", "Filter the results to include only those accounts associated with the customer whose first name is 'Meaghan'.", "Construct the SQL query using SELECT, JOIN, and WHERE clauses."], "gold_sql": "SELECT T1.account_id ,  T1.date_account_opened ,  T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  'Meaghan'", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT Accounts.account_id, Accounts.account_name, Accounts.other_account_details \nFROM Accounts \nJOIN Customers ON Accounts.customer_id = Customers.customer_id \nWHERE Customers.customer_first_name = 'Meaghan';", "hint": "\n"}
{"sample_id": "train.1556", "db_id": "customers_and_invoices", "question": "What are the names and other details for accounts corresponding to the customer named Meaghan Keeling?", "rationale": ["Identify the relevant tables: Customers and Accounts.", "We need to retrieve account details, so we will select columns from the Accounts table: account_name and other_account_details.", "To link the Customers and Accounts tables, we will use the customer_id foreign key.", "We need to filter the results to only include the customer named Meaghan Keeling, so we will add a WHERE clause that checks for the first name 'Meaghan' and last name 'Keeling'.", "Construct the SQL query using SELECT, JOIN, and WHERE clauses."], "gold_sql": "SELECT T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  'Meaghan' AND T2.customer_last_name  =  'Keeling'", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT Accounts.account_name, Accounts.other_account_details \nFROM Customers \nJOIN Accounts ON Customers.customer_id = Accounts.customer_id \nWHERE Customers.customer_first_name = 'Meaghan' AND Customers.customer_last_name = 'Keeling';", "hint": "\n"}
{"sample_id": "train.1558", "db_id": "customers_and_invoices", "question": "What are the full names of customers with the account name 900?", "rationale": ["Identify the relevant tables: Customers and Accounts.", "We need to retrieve the full names of customers, which requires the first and last names from the Customers table.", "The account name is specified, so we will filter results based on the account name from the Accounts table.", "Join the Customers table with the Accounts table on the customer_id to link customers with their accounts.", "Select the full name by concatenating the first and last names, and apply the filter for account name '900'."], "gold_sql": "SELECT T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T1.account_name  =  '900'", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT customer_first_name || ' ' || customer_last_name AS full_name\nFROM Customers\nJOIN Accounts ON Customers.customer_id = Accounts.customer_id\nWHERE Accounts.account_name = '900';", "hint": "\n"}
{"sample_id": "train.1569", "db_id": "customers_and_invoices", "question": "Show id, first name and last name for all customers and the number of accounts.", "rationale": ["Identify the required fields: customer_id, customer_first_name, customer_last_name from the Customers table, and the count of accounts from the Accounts table.", "To get the number of accounts per customer, a JOIN operation is needed between the Customers table and the Accounts table on the customer_id field.", "Use a LEFT JOIN to ensure all customers are included, even those without accounts.", "Use the COUNT function to count the number of accounts for each customer.", "Group the results by customer_id, customer_first_name, and customer_last_name to get the count of accounts for each customer."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT c.customer_id, c.customer_first_name, c.customer_last_name, COUNT(a.account_id) AS number_of_accounts\nFROM Customers c\nLEFT JOIN Accounts a ON c.customer_id = a.customer_id\nGROUP BY c.customer_id, c.customer_first_name, c.customer_last_name;", "hint": "\n"}
{"sample_id": "train.1570", "db_id": "customers_and_invoices", "question": "What are the the full names and ids for all customers, and how many accounts does each have?", "rationale": ["Identify the required fields: customer_id, full name (first and last), and account count.", "To get the full name, concatenate customer_first_name and customer_last_name.", "We need to count the number of accounts for each customer, which requires a join between Customers and Accounts tables.", "Use a LEFT JOIN to ensure all customers are included, even those without accounts.", "Group the results by customer_id and full name to get the count of accounts per customer."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT c.customer_id, c.customer_first_name || ' ' || c.customer_last_name AS full_name, COUNT(a.account_id) AS account_count\nFROM Customers c\nLEFT JOIN Accounts a ON c.customer_id = a.customer_id\nGROUP BY c.customer_id, c.customer_first_name, c.customer_last_name;", "hint": "\n"}
{"sample_id": "train.1580", "db_id": "customers_and_invoices", "question": "Count the number of financial transactions that correspond to each account id.", "rationale": ["Identify the relevant table: Financial_Transactions contains the account_id and transaction_id.", "We need to count the number of transactions for each account, so we will use the COUNT() function.", "To group the results by account_id, we will use the GROUP BY clause.", "The final query will select the account_id and the count of transaction_id, giving us the number of transactions per account."], "gold_sql": "SELECT count(*) ,  account_id FROM Financial_transactions", "source_tables": ["financial_transactions"], "pred_sql": "SELECT account_id, COUNT(transaction_id) AS transaction_count\nFROM Financial_Transactions\nGROUP BY account_id;", "hint": "\n"}
{"sample_id": "train.1607", "db_id": "customers_and_invoices", "question": "Show the order ids and the number of invoices for each order.", "rationale": ["We need to retrieve the order ids and the number of invoices for each order.", "The relevant tables for this query are 'Orders' and 'Invoices'.", "We will perform a LEFT JOIN between 'Orders' and 'Invoices' on the order_id to ensure we get all orders even if they have no invoices.", "We will use the COUNT function to count the number of invoices associated with each order.", "Finally, we will group the results by order_id to get the count for each order."], "gold_sql": "SELECT order_id ,  count(*) FROM Invoices GROUP BY order_id", "source_tables": ["invoices"], "pred_sql": "SELECT O.order_id, COUNT(I.invoice_number) AS number_of_invoices \nFROM Orders AS O \nLEFT JOIN Invoices AS I ON O.order_id = I.order_id \nGROUP BY O.order_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total quantity of each product ordered from the 'Products' table by joining it with the 'Order_Items' and 'Orders' tables. The placeholder in the SELECT statement represents the product name, and the count function aggregates the total number of items ordered for each product.\",\n        \"virtual_table\": \"SELECT T2.product_name ,  count(*) FROM Order_items AS T1 JOIN Products AS T2 ON T1.product_id  =  T2.product_id JOIN Orders AS T3 ON T3.order_id  =  T1.order_id GROUP BY T2.product_name\"\n    }\n}\n"}
{"sample_id": "train.1617", "db_id": "customers_and_invoices", "question": "Show the order ids and the number of items in each order.", "rationale": ["We need to show the order ids and the number of items in each order.", "To achieve this, we will use the 'Order_Items' table to count the number of items for each order.", "We will join the 'Order_Items' table with the 'Orders' table to get the order ids associated with each order item.", "We will use the COUNT function to count the number of items (order_item_id) for each order.", "Finally, we will group the results by order_id to get the count of items for each order."], "gold_sql": "SELECT order_id ,  count(*) FROM Order_items GROUP BY order_id", "source_tables": ["order_items"], "pred_sql": "SELECT T3.order_id, COUNT(T1.order_item_id) AS number_of_items \nFROM Order_Items AS T1 \nJOIN Orders AS T3 ON T3.order_id = T1.order_id \nGROUP BY T3.order_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total quantity of each product ordered from the 'Products' table by joining it with the 'Order_Items' and 'Orders' tables. The placeholder in the SELECT statement represents the product name, and the count function aggregates the total number of items ordered for each product.\",\n        \"virtual_table\": \"SELECT T2.product_name ,  count(*) FROM Order_items AS T1 JOIN Products AS T2 ON T1.product_id  =  T2.product_id JOIN Orders AS T3 ON T3.order_id  =  T1.order_id GROUP BY T2.product_name\"\n    }\n}\n"}
{"sample_id": "train.1622", "db_id": "customers_and_invoices", "question": "What are teh names of the different products, as well as the number of customers who have ordered each product.", "rationale": ["Identify the tables needed: Products, Order_Items, and Orders are required to get product names and customer information.", "Join the Order_Items table with the Products table to get product names using the product_id.", "Join the Orders table to link each order to the customer who placed it using the order_id.", "Use COUNT(DISTINCT T3.customer_id) to count the unique customers who ordered each product, ensuring we don't double count customers who ordered the same product multiple times.", "Group the results by product name to get the count of customers for each product."], "gold_sql": "SELECT T2.product_name ,  count(*) FROM Order_items AS T1 JOIN Products AS T2 ON T1.product_id  =  T2.product_id JOIN Orders AS T3 ON T3.order_id  =  T1.order_id GROUP BY T2.product_name", "source_tables": ["orders", "products", "order_items"], "pred_sql": "SELECT T2.product_name, COUNT(DISTINCT T3.customer_id) AS customer_count \nFROM Order_Items AS T1 \nJOIN Products AS T2 ON T1.product_id = T2.product_id \nJOIN Orders AS T3 ON T3.order_id = T1.order_id \nGROUP BY T2.product_name", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total quantity of each product ordered from the 'Products' table by joining it with the 'Order_Items' and 'Orders' tables. The placeholder in the SELECT statement represents the product name, and the count function aggregates the total number of items ordered for each product.\",\n        \"virtual_table\": \"SELECT T2.product_name ,  count(*) FROM Order_items AS T1 JOIN Products AS T2 ON T1.product_id  =  T2.product_id JOIN Orders AS T3 ON T3.order_id  =  T1.order_id GROUP BY T2.product_name\"\n    }\n}\n"}
{"sample_id": "train.2050", "db_id": "party_people", "question": "Which ministers are not a part of the Progress Party?", "rationale": ["Identify the relevant tables: We need to look at the 'member' table to get the names of the ministers and the 'party' table to identify which party they belong to.", "Join the 'member' table with the 'party' table on the Party_ID to associate members with their respective parties.", "Filter the results to exclude members who are part of the 'Progress Party' by using a WHERE clause that checks if the Party_name is not equal to 'Progress Party'.", "Select distinct member names to ensure that we do not have duplicate entries in the result."], "gold_sql": "SELECT minister FROM party WHERE party_name != 'Progress Party'", "source_tables": ["party"], "pred_sql": "SELECT DISTINCT m.Member_Name \nFROM member AS m \nJOIN party AS p ON m.Party_ID = p.Party_ID \nWHERE p.Party_name != 'Progress Party';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of party events that are associated with a specific region and event name. The placeholders in the WHERE clause represent the region's name and the event's name, allowing users to filter the results based on their input.\",\n        \"virtual_table\": \"SELECT count(*) FROM region AS t1 JOIN party AS t2 ON t1.region_id  =  t2.region_id JOIN party_events AS t3 ON t2.party_id  =  t3.party_id WHERE t1.region_name  =  [PLACEHOLDER-TYPE:STRING] AND t3.Event_Name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2057", "db_id": "party_people", "question": "Show all party names and the number of members in each party.", "rationale": ["Identify the tables needed: We need data from the 'party' table for party names and the 'member' table for member counts.", "Join the 'party' table with the 'member' table on the Party_ID to associate members with their respective parties.", "Use the COUNT() function to count the number of members for each party.", "Group the results by party name to get the count of members for each party."], "gold_sql": "SELECT T2.party_name ,  count(*) FROM Member AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id", "source_tables": ["party", "member"], "pred_sql": "SELECT p.Party_name, COUNT(m.Member_ID) AS Number_of_Members\nFROM party AS p\nJOIN member AS m ON p.Party_ID = m.Party_ID\nGROUP BY p.Party_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of party events that are associated with a specific region and event name. The placeholders in the WHERE clause represent the region's name and the event's name, allowing users to filter the results based on their input.\",\n        \"virtual_table\": \"SELECT count(*) FROM region AS t1 JOIN party AS t2 ON t1.region_id  =  t2.region_id JOIN party_events AS t3 ON t2.party_id  =  t3.party_id WHERE t1.region_name  =  [PLACEHOLDER-TYPE:STRING] AND t3.Event_Name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2072", "db_id": "party_people", "question": "How many events are there for each party?", "rationale": ["Identify the tables involved: We need data from the 'party' and 'party_events' tables.", "Determine the relationship: The 'party' table has a unique identifier 'Party_ID' which is also present in the 'party_events' table, allowing us to join these tables.", "Select the required fields: We want the party name and the count of events for each party.", "Use COUNT() function: To count the number of events associated with each party, we will use the COUNT() function on 'Event_ID'.", "Group the results: We need to group the results by 'Party_name' to get the count of events for each party."], "gold_sql": "SELECT T2.party_name ,  count(*) FROM party_events AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id", "source_tables": ["party", "party_events"], "pred_sql": "SELECT party.Party_name, COUNT(party_events.Event_ID) AS Event_Count \nFROM party \nLEFT JOIN party_events ON party.Party_ID = party_events.Party_ID \nGROUP BY party.Party_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of party events that are associated with a specific region and event name. The placeholders in the WHERE clause represent the region's name and the event's name, allowing users to filter the results based on their input.\",\n        \"virtual_table\": \"SELECT count(*) FROM region AS t1 JOIN party AS t2 ON t1.region_id  =  t2.region_id JOIN party_events AS t3 ON t2.party_id  =  t3.party_id WHERE t1.region_name  =  [PLACEHOLDER-TYPE:STRING] AND t3.Event_Name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2081", "db_id": "party_people", "question": "How many Annual Meeting events happened in the United Kingdom region?", "rationale": ["Identify the relevant tables: region, party, and party_events.", "Determine the relationship between the tables: region is linked to party via Region_ID, and party is linked to party_events via Party_ID.", "Filter the results based on the region name 'United Kingdom' and the event name 'Annual Meeting'.", "Use the COUNT function to count the number of events that match the criteria."], "gold_sql": "SELECT count(*) FROM region AS t1 JOIN party AS t2 ON t1.region_id  =  t2.region_id JOIN party_events AS t3 ON t2.party_id  =  t3.party_id WHERE t1.region_name  =  'United Kingdom' AND t3.Event_Name  =  'Annaual Meeting'", "source_tables": ["party", "party_events", "region"], "pred_sql": "SELECT count(*) FROM region AS t1 JOIN party AS t2 ON t1.Region_ID = t2.Region_ID JOIN party_events AS t3 ON t2.Party_ID = t3.Party_ID WHERE t1.Region_name = 'United Kingdom' AND t3.Event_Name = 'Annual Meeting'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of party events that are associated with a specific region and event name. The placeholders in the WHERE clause represent the region's name and the event's name, allowing users to filter the results based on their input.\",\n        \"virtual_table\": \"SELECT count(*) FROM region AS t1 JOIN party AS t2 ON t1.region_id  =  t2.region_id JOIN party_events AS t3 ON t2.party_id  =  t3.party_id WHERE t1.region_name  =  [PLACEHOLDER-TYPE:STRING] AND t3.Event_Name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2167", "db_id": "formula_1", "question": "What is the id and family name of the driver who has the longest laptime?", "rationale": ["We need to find the driver with the longest lap time.", "The relevant table for lap times is 'lapTimes', which contains the lap time data.", "We will join the 'lapTimes' table with the 'drivers' table to get the driver's ID and surname.", "To find the longest lap time, we will order the results by the 'time' column in descending order.", "Finally, we will limit the results to 1 to get the driver with the longest lap time."], "gold_sql": "SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT 1", "source_tables": ["laptimes", "drivers"], "pred_sql": "SELECT drivers.driverId, drivers.surname FROM lapTimes JOIN drivers ON lapTimes.driverId = drivers.driverId ORDER BY lapTimes.time DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and years of races in which a specific driver participated, identified by their first name. The placeholders in the WHERE clause allow for filtering based on the driver's first name.\",\n        \"virtual_table\": \"SELECT T2.name ,  T2.year FROM results AS T1 JOIN races AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T1.driverid = T3.driverid WHERE T3.forename = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2174", "db_id": "formula_1", "question": "How many drivers did not race in 2009?", "rationale": ["Identify the year in question, which is 2009.", "Use the provided hint to create a virtual table that selects drivers who raced in 2009.", "Use the EXCEPT clause to find drivers who did not race in 2009 by comparing with another race year (in this case, we can use a placeholder for any other year, but since we want to count those who did not race at all, we can just select all drivers).", "Count the number of drivers from the resulting set of the EXCEPT clause to get the total number of drivers who did not race in 2009."], "gold_sql": "SELECT count(DISTINCT driverId) FROM results WHERE raceId NOT IN( SELECT raceId FROM races WHERE YEAR != 2009 )", "source_tables": ["results", "races"], "pred_sql": "SELECT COUNT(*) FROM (SELECT T3.forename, T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceId = T2.raceId JOIN drivers AS T3 ON T2.driverId = T3.driverId WHERE T1.year = 2009 EXCEPT SELECT T3.forename, T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceId = T2.raceId JOIN drivers AS T3 ON T2.driverId = T3.driverId) AS NotRaced;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of drivers who participated in a specific race, excluding those who participated in another specified race. The placeholders in the WHERE clause represent the names of the races.\",\n        \"virtual_table\": \"SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2179", "db_id": "formula_1", "question": "Find the id and forenames of drivers who participated both the races with name Australian Grand Prix and the races with name Chinese Grand Prix?", "rationale": ["We need to find drivers who participated in both the Australian Grand Prix and the Chinese Grand Prix.", "To do this, we will join the results table with the races table to get the race names and the drivers table to get the driver information.", "We will filter the races by their names using a WHERE clause with the IN operator to specify both race names.", "To ensure that we only get drivers who participated in both races, we will group the results by driverId and forename.", "Finally, we will use the HAVING clause to count the distinct race names for each driver and ensure that it equals 2, indicating participation in both races."], "gold_sql": "SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = 'Australian Grand Prix' INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = 'Chinese Grand Prix'", "source_tables": ["races", "drivers", "results"], "pred_sql": "SELECT DISTINCT T3.driverId, T3.forename \nFROM results AS T1 \nJOIN races AS T2 ON T1.raceId = T2.raceId \nJOIN drivers AS T3 ON T1.driverId = T3.driverId \nWHERE T2.name IN ('Australian Grand Prix', 'Chinese Grand Prix') \nGROUP BY T3.driverId, T3.forename \nHAVING COUNT(DISTINCT T2.name) = 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and years of races in which a specific driver participated, identified by their first name. The placeholders in the WHERE clause allow for filtering based on the driver's first name.\",\n        \"virtual_table\": \"SELECT T2.name ,  T2.year FROM results AS T1 JOIN races AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T1.driverid = T3.driverid WHERE T3.forename = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2180", "db_id": "formula_1", "question": "What is the id and first name of all the drivers who participated in the Australian Grand Prix and the Chinese Grand Prix?", "rationale": ["We need to find the driver IDs and first names of drivers who participated in both the Australian Grand Prix and the Chinese Grand Prix.", "To do this, we will join the 'results' table with the 'races' table to get the race names and the 'drivers' table to get the driver information.", "We will filter the results based on the race names, specifically looking for 'Australian Grand Prix' and 'Chinese Grand Prix'.", "Using 'DISTINCT' ensures that we only get unique driver entries, as a driver may have participated in both races multiple times."], "gold_sql": "SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = 'Australian Grand Prix' INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = 'Chinese Grand Prix'", "source_tables": ["races", "drivers", "results"], "pred_sql": "SELECT DISTINCT T3.driverId, T3.forename \nFROM results AS T1 \nJOIN races AS T2 ON T1.raceId = T2.raceId \nJOIN drivers AS T3 ON T1.driverId = T3.driverId \nWHERE T2.name IN ('Australian Grand Prix', 'Chinese Grand Prix')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and years of races in which a specific driver participated, identified by their first name. The placeholders in the WHERE clause allow for filtering based on the driver's first name.\",\n        \"virtual_table\": \"SELECT T2.name ,  T2.year FROM results AS T1 JOIN races AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T1.driverid = T3.driverid WHERE T3.forename = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2182", "db_id": "formula_1", "question": "What are the first and last names of all drivers who participated in the Australian Grand Prix but not the Chinese Grand Prix?", "rationale": ["Identify the races of interest: Australian Grand Prix and Chinese Grand Prix.", "Use a JOIN to connect the races table with the results table to get the drivers for the Australian Grand Prix.", "Use another JOIN to connect the results table with the drivers table to get the first and last names of the drivers.", "Filter the results to only include drivers from the Australian Grand Prix using a WHERE clause.", "Use the EXCEPT clause to exclude drivers who participated in the Chinese Grand Prix by performing a similar JOIN operation for that race.", "Select the first and last names of the drivers who meet the criteria."], "gold_sql": "SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Australian Grand Prix' EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Chinese Grand Prix'", "source_tables": ["races", "drivers", "results"], "pred_sql": "SELECT T3.forename, T3.surname \nFROM races AS T1 \nJOIN results AS T2 ON T1.raceId = T2.raceId \nJOIN drivers AS T3 ON T2.driverId = T3.driverId \nWHERE T1.name = 'Australian Grand Prix' \nEXCEPT \nSELECT T3.forename, T3.surname \nFROM races AS T1 \nJOIN results AS T2 ON T1.raceId = T2.raceId \nJOIN drivers AS T3 ON T2.driverId = T3.driverId \nWHERE T1.name = 'Chinese Grand Prix'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of drivers who participated in a specific race, excluding those who participated in another specified race. The placeholders in the WHERE clause represent the names of the races.\",\n        \"virtual_table\": \"SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2190", "db_id": "formula_1", "question": "For each constructor id, how many races are there?", "rationale": ["We need to count the number of races for each constructor id.", "The relevant table for this information is 'constructorResults', which contains the 'raceId' and 'constructorId'.", "We will use the COUNT() function to count the occurrences of 'raceId' for each 'constructorId'.", "To group the results by each constructor, we will use the GROUP BY clause on 'constructorId'."], "gold_sql": "SELECT count(*) ,  constructorid FROM constructorStandings GROUP BY constructorid", "source_tables": ["constructorstandings"], "pred_sql": "SELECT constructorId, COUNT(raceId) AS race_count FROM constructorResults GROUP BY constructorId;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and years of races in which a specific driver participated, identified by their first name. The placeholders in the WHERE clause allow for filtering based on the driver's first name.\",\n        \"virtual_table\": \"SELECT T2.name ,  T2.year FROM results AS T1 JOIN races AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T1.driverid = T3.driverid WHERE T3.forename = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2194", "db_id": "formula_1", "question": "What are the names of all races held after 2000 in Spain?", "rationale": ["Identify the relevant tables: 'races' for race details and 'circuits' for circuit location.", "We need to find races held after the year 2000, so we will filter the 'year' column in the 'races' table.", "We also need to filter the races that took place in Spain, which requires joining the 'races' table with the 'circuits' table on 'circuitId'.", "Select the 'name' of the races that meet both conditions (year > 2000 and country = 'Spain')."], "gold_sql": "SELECT DISTINCT T1.name FROM races AS T1 JOIN circuits AS T2 ON T1.circuitid = T2.circuitid WHERE T2.country = 'Spain' AND T1.year > 2000", "source_tables": ["races", "circuits"], "pred_sql": "SELECT T1.name FROM races AS T1 JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T1.year > 2000 AND T2.country = 'Spain';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of drivers who participated in a specific race, excluding those who participated in another specified race. The placeholders in the WHERE clause represent the names of the races.\",\n        \"virtual_table\": \"SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2217", "db_id": "formula_1", "question": "Find the names of Japanese constructors that have once earned more than 5 points?", "rationale": ["Identify the relevant tables: constructors and constructorResults.", "We need to find constructors that are Japanese, so we will filter by nationality in the constructors table.", "We need to check the points earned by constructors, which is found in the constructorResults table.", "Join the constructors table with the constructorResults table on the constructorId to access both constructors' names and their points.", "Use a WHERE clause to filter for constructors with more than 5 points and who are Japanese.", "Select the distinct names of the constructors to avoid duplicates."], "gold_sql": "SELECT T1.name FROM constructors AS T1 JOIN constructorstandings AS T2 ON T1.constructorid = T2.constructorid WHERE T1.nationality = 'Japanese' AND T2.points > 5", "source_tables": ["constructorstandings", "constructors"], "pred_sql": "SELECT DISTINCT constructors.name \nFROM constructors \nJOIN constructorResults ON constructors.constructorId = constructorResults.constructorId \nWHERE constructorResults.points > 5 \nAND constructors.nationality = 'Japanese';", "hint": "\n"}
{"sample_id": "train.2218", "db_id": "formula_1", "question": "What are the names of all the Japanese constructors that have earned more than 5 points?", "rationale": ["Identify the relevant tables: constructors and constructorResults.", "We need to select the names of constructors, so we will select the 'name' column from the constructors table.", "To filter for Japanese constructors, we will add a WHERE clause that checks if the 'nationality' column in the constructors table is 'Japanese'.", "We also need to ensure that these constructors have earned more than 5 points, which requires joining the constructorResults table on the constructorId.", "The final SQL query will select the names of constructors from the constructors table, joining with the constructorResults table, and applying the necessary filters."], "gold_sql": "SELECT T1.name FROM constructors AS T1 JOIN constructorstandings AS T2 ON T1.constructorid = T2.constructorid WHERE T1.nationality = 'Japanese' AND T2.points > 5", "source_tables": ["constructorstandings", "constructors"], "pred_sql": "SELECT c.name \nFROM constructors AS c \nJOIN constructorResults AS cr ON c.constructorId = cr.constructorId \nWHERE c.nationality = 'Japanese' \nAND cr.points > 5;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and years of races in which a specific driver participated, identified by their first name. The placeholders in the WHERE clause allow for filtering based on the driver's first name.\",\n        \"virtual_table\": \"SELECT T2.name ,  T2.year FROM results AS T1 JOIN races AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T1.driverid = T3.driverid WHERE T3.forename = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2220", "db_id": "formula_1", "question": "What is the average fastest lap speed for the Monaco Grand Prix in 2008?", "rationale": ["Identify the relevant tables: lapTimes, results, and races are needed to find the average fastest lap speed for a specific race.", "The lapTimes table contains the fastest lap speed, while the results table links lap times to specific races.", "The races table provides the name and year of the race, which are necessary to filter for the Monaco Grand Prix in 2008.", "Join the lapTimes table with the results table on raceId to connect lap times to their respective races.", "Join the results table with the races table to filter for the specific race name and year.", "Use the AVG() function to calculate the average of the fastest lap speeds for the filtered results."], "gold_sql": "SELECT avg(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "pred_sql": "SELECT AVG(lapTimes.fastestLapSpeed) AS average_fastest_lap_speed \nFROM lapTimes \nJOIN results ON lapTimes.raceId = results.raceId \nJOIN races ON results.raceId = races.raceId \nWHERE races.name = 'Monaco Grand Prix' AND races.year = 2008;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and years of races in which a specific driver participated, identified by their first name. The placeholders in the WHERE clause allow for filtering based on the driver's first name.\",\n        \"virtual_table\": \"SELECT T2.name ,  T2.year FROM results AS T1 JOIN races AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T1.driverid = T3.driverid WHERE T3.forename = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2222", "db_id": "formula_1", "question": "What is the maximum fastest lap speed in the Monaco Grand Prix in 2008?", "rationale": ["Identify the relevant tables: lapTimes, results, and races are needed to find the fastest lap speed for the Monaco Grand Prix in 2008.", "We need to find the maximum fastest lap speed, so we will use the MAX() function on the fastestLapSpeed column from the lapTimes table.", "To link the lap times to the races, we will join the lapTimes table with the results table on raceId.", "Next, we will join the results table with the races table to filter for the specific race (Monaco Grand Prix) and year (2008).", "Finally, we will apply the WHERE clause to specify the race name and year, and select the maximum fastest lap speed."], "gold_sql": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "pred_sql": "SELECT MAX(lapTimes.fastestLapSpeed) AS max_fastest_lap_speed \nFROM lapTimes \nJOIN results ON lapTimes.raceId = results.raceId \nJOIN races ON results.raceId = races.raceId \nWHERE races.name = 'Monaco Grand Prix' AND races.year = 2008;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and years of races in which a specific driver participated, identified by their first name. The placeholders in the WHERE clause allow for filtering based on the driver's first name.\",\n        \"virtual_table\": \"SELECT T2.name ,  T2.year FROM results AS T1 JOIN races AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T1.driverid = T3.driverid WHERE T3.forename = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2223", "db_id": "formula_1", "question": "What are the maximum fastest lap speed in races held after 2004 grouped by race name and ordered by year?", "rationale": ["Identify the relevant tables: races, results, and lapTimes are needed to get race names, results, and fastest lap speeds.", "We need to filter races that occurred after 2004, so we will use a WHERE clause on the year column in the races table.", "To get the maximum fastest lap speed, we will use the MAX() function on the fastestLapSpeed column from the lapTimes table.", "We will group the results by race name and year to get the maximum speed for each race.", "Finally, we will order the results by year to present them in chronological order."], "gold_sql": "SELECT max(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "pred_sql": "SELECT r.name, r.year, MAX(l.fastestLapSpeed) AS max_fastest_lap_speed\nFROM races AS r\nJOIN results AS res ON r.raceId = res.raceId\nJOIN lapTimes AS l ON res.raceId = l.raceId AND res.driverId = l.driverId\nWHERE r.year > 2004\nGROUP BY r.name, r.year\nORDER BY r.year;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and years of races in which a specific driver participated, identified by their first name. The placeholders in the WHERE clause allow for filtering based on the driver's first name.\",\n        \"virtual_table\": \"SELECT T2.name ,  T2.year FROM results AS T1 JOIN races AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T1.driverid = T3.driverid WHERE T3.forename = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2224", "db_id": "formula_1", "question": "For each race name, What is the maximum fastest lap speed for races after 2004 ordered by year?", "rationale": ["Identify the relevant tables: races, results, and lapTimes are needed to get race names, results, and fastest lap speeds.", "We need to filter races that occurred after 2004, so we will use a WHERE clause on the year column in the races table.", "To get the maximum fastest lap speed for each race, we will use the MAX function on the fastestLapSpeed column from the lapTimes table.", "We will group the results by race name and year to ensure we get the maximum speed for each race.", "Finally, we will order the results by year to meet the requirement of the query."], "gold_sql": "SELECT max(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "pred_sql": "SELECT r.name, MAX(l.fastestLapSpeed) AS max_fastest_lap_speed\nFROM races AS r\nJOIN results AS res ON r.raceId = res.raceId\nJOIN lapTimes AS l ON res.raceId = l.raceId AND res.driverId = l.driverId\nWHERE r.year > 2004\nGROUP BY r.name, r.year\nORDER BY r.year;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and years of races in which a specific driver participated, identified by their first name. The placeholders in the WHERE clause allow for filtering based on the driver's first name.\",\n        \"virtual_table\": \"SELECT T2.name ,  T2.year FROM results AS T1 JOIN races AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T1.driverid = T3.driverid WHERE T3.forename = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2325", "db_id": "csu_1", "question": "What campuses are located in the county of Los Angeles?", "rationale": ["Identify the relevant table: The question asks about campuses, so we will focus on the 'Campuses' table.", "Determine the specific column needed: We need the 'Campus' column to list the campuses.", "Apply the filter: The question specifies that we are looking for campuses located in 'Los Angeles', which means we need to filter by the 'County' column.", "Construct the SQL query: Using the SELECT statement to retrieve the 'Campus' names from the 'Campuses' table where the 'County' is 'Los Angeles'."], "gold_sql": "SELECT campus FROM campuses WHERE county  =  'Los Angeles'", "source_tables": ["campuses"], "pred_sql": "SELECT Campus FROM Campuses WHERE County = 'Los Angeles';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to associate campuses with their respective faculty data and also joins the 'degrees' table to ensure that the faculty data corresponds to the same year as the degrees awarded. The placeholders in the WHERE clause represent the year of interest and the limit on the number of results to return.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2347", "db_id": "csu_1", "question": "In what year was the most degrees conferred?", "rationale": ["We need to find out in which year the most degrees were conferred.", "To do this, we will query the 'degrees' table.", "We will group the results by 'Year' to count the number of degrees awarded each year.", "We will order the results in descending order based on the count of degrees to get the year with the highest number of degrees conferred.", "Finally, we will limit the results to 1 to get only the year with the most degrees."], "gold_sql": "SELECT YEAR FROM degrees GROUP BY YEAR ORDER BY sum(degrees) DESC LIMIT 1", "source_tables": ["degrees"], "pred_sql": "SELECT Year FROM degrees GROUP BY Year ORDER BY COUNT(Degrees) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for campuses that have awarded degrees in a specific year. The query joins the 'campuses' table with the 'faculty' and 'degrees' tables based on the campus identifier and filters the results for a particular year. The placeholders in the WHERE clause represent the year of interest and the limit for the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2348", "db_id": "csu_1", "question": "Which campus has the most degrees conferred in all times?", "rationale": ["Identify the relevant table for degrees conferred, which is the 'degrees' table.", "We need to count the number of degrees awarded for each campus, so we will use the COUNT function.", "Group the results by 'Campus' to aggregate the degree counts for each campus.", "Order the results in descending order to find the campus with the most degrees conferred.", "Limit the results to 1 to get only the campus with the highest count."], "gold_sql": "SELECT campus FROM degrees GROUP BY campus ORDER BY sum(degrees) DESC LIMIT 1", "source_tables": ["degrees"], "pred_sql": "SELECT Campus, COUNT(Degrees) AS TotalDegrees FROM degrees GROUP BY Campus ORDER BY TotalDegrees DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for campuses that have awarded degrees in a specific year. The query joins the 'campuses' table with the 'faculty' and 'degrees' tables based on the campus identifier and filters the results for a particular year. The placeholders in the WHERE clause represent the year of interest and the limit for the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2349", "db_id": "csu_1", "question": "What campus has the most degrees  conferrred over its entire existence?", "rationale": ["Identify the relevant table for degrees awarded, which is the 'degrees' table.", "We need to count the total number of degrees awarded for each campus, so we will use the COUNT() function.", "Group the results by 'Campus' to aggregate the degree counts for each campus.", "Order the results in descending order to get the campus with the most degrees at the top.", "Limit the results to 1 to get only the campus with the highest count of degrees."], "gold_sql": "SELECT campus FROM degrees GROUP BY campus ORDER BY sum(degrees) DESC LIMIT 1", "source_tables": ["degrees"], "pred_sql": "SELECT Campus, COUNT(Degrees) AS TotalDegrees\nFROM degrees\nGROUP BY Campus\nORDER BY TotalDegrees DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for campuses that have awarded degrees in a specific year. The query joins the 'campuses' table with the 'faculty' and 'degrees' tables based on the campus identifier and filters the results for a particular year. The placeholders in the WHERE clause represent the year of interest and the limit for the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2351", "db_id": "csu_1", "question": "What campus has the most faculties in 2003?", "rationale": ["Identify the relevant tables: 'Campuses' and 'faculty'.", "We need to find the campus with the most faculty members in the year 2003.", "Join the 'Campuses' table with the 'faculty' table on the campus identifier.", "Filter the results to include only records from the year 2003.", "Order the results by the number of faculty members in descending order to get the campus with the most faculty at the top.", "Limit the results to 1 to get only the campus with the highest number of faculty."], "gold_sql": "SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  2003 ORDER BY T2.faculty DESC LIMIT 1", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT T1.Campus, T2.Faculty FROM Campuses AS T1 JOIN faculty AS T2 ON T1.Id = T2.Campus WHERE T2.Year = 2003 ORDER BY T2.Faculty DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for campuses that have awarded degrees in a specific year. The query joins the 'campuses' table with the 'faculty' and 'degrees' tables based on the campus identifier and filters the results for a particular year. The placeholders in the WHERE clause represent the year of interest and the limit for the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2358", "db_id": "csu_1", "question": "For each Orange county campus, report the number of degrees granted after 2000.", "rationale": ["Identify the relevant tables: Campuses and degrees.", "We need to filter campuses located in Orange County, so we will use the County column from the Campuses table.", "We need to count the number of degrees granted after the year 2000, so we will filter the degrees table for records where Year > 2000.", "We will join the Campuses table with the degrees table on the Campus identifier.", "Finally, we will group the results by campus to get the count of degrees for each campus."], "gold_sql": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  'Orange' AND T2.year  >=  2000 GROUP BY T1.campus", "source_tables": ["degrees", "campuses"], "pred_sql": "SELECT COUNT(T3.Degrees) AS DegreesGranted \nFROM Campuses AS T1 \nJOIN degrees AS T3 ON T1.Id = T3.Campus \nWHERE T1.County = 'Orange' AND T3.Year > '2000' \nGROUP BY T1.Campus;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for campuses that have awarded degrees in a specific year. The query joins the 'campuses' table with the 'faculty' and 'degrees' tables based on the campus identifier and filters the results for a particular year. The placeholders in the WHERE clause represent the year of interest and the limit for the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2359", "db_id": "csu_1", "question": "What is the total number of degrees granted after 2000 for each Orange county campus?", "rationale": ["Identify the relevant tables: Campuses and degrees.", "We need to count the total number of degrees granted after the year 2000, so we will filter the degrees table based on the year.", "We also need to filter the campuses to only include those located in Orange County.", "Join the Campuses table with the degrees table on the campus identifier.", "Group the results by campus to get the total count of degrees for each campus."], "gold_sql": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  'Orange' AND T2.year  >=  2000 GROUP BY T1.campus", "source_tables": ["degrees", "campuses"], "pred_sql": "SELECT C.Campus, COUNT(D.Degrees) AS TotalDegrees\nFROM Campuses AS C\nJOIN degrees AS D ON C.Id = D.Campus\nWHERE C.County = 'Orange' AND D.Year > '2000'\nGROUP BY C.Campus;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for campuses that have awarded degrees in a specific year. The query joins the 'campuses' table with the 'faculty' and 'degrees' tables based on the campus identifier and filters the results for a particular year. The placeholders in the WHERE clause represent the year of interest and the limit for the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2362", "db_id": "csu_1", "question": "What campus had more than 400 total enrollment but more than 200 full time enrollment in year 1956?", "rationale": ["Identify the relevant table for total enrollments, which is the 'enrollments' table.", "Filter the records for the year 1956 by using the condition 'Year = '1956' in the WHERE clause.", "Add conditions to filter campuses with more than 400 total enrollment and more than 200 full-time enrollment using 'TotalEnrollment_AY > 400' and 'FTE_AY > 200'.", "Select the 'Campus' column to get the names of the campuses that meet the criteria."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN enrollments AS t2 ON t1.id  =  t2.campus WHERE t2.year  =  1956 AND totalenrollment_ay  >  400 AND FTE_AY  >  200", "source_tables": ["enrollments", "campuses"], "pred_sql": "SELECT Campus FROM enrollments WHERE Year = '1956' AND TotalEnrollment_AY > 400 AND FTE_AY > 200;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for campuses that have awarded degrees in a specific year. The query joins the 'campuses' table with the 'faculty' and 'degrees' tables based on the campus identifier and filters the results for a particular year. The placeholders in the WHERE clause represent the year of interest and the limit for the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2367", "db_id": "csu_1", "question": "What campuses are in Los Angeles county?", "rationale": ["Identify the relevant table: The question asks about campuses, so we will use the 'Campuses' table.", "Determine the filtering criteria: The question specifies 'Los Angeles county', which means we need to filter the results based on the 'County' column.", "Construct the SQL query: We will select the 'Campus' column from the 'Campuses' table where the 'County' is 'Los Angeles'."], "gold_sql": "SELECT campus FROM campuses WHERE county  =  'Los Angeles'", "source_tables": ["campuses"], "pred_sql": "SELECT Campus FROM Campuses WHERE County = 'Los Angeles';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to associate campuses with their respective faculty data and also joins the 'degrees' table to ensure that the faculty data corresponds to the same year as the degrees awarded. The placeholders in the WHERE clause represent the year of interest and the limit on the number of results to return.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2368", "db_id": "csu_1", "question": "How many degrees were conferred in \"San Jose State University\" in 2000?", "rationale": ["Identify the relevant tables: 'Campuses' and 'degrees'.", "We need to count the number of degrees conferred, so we will use the COUNT function on the 'Degrees' column from the 'degrees' table.", "Join the 'Campuses' table with the 'degrees' table on the campus identifier (Id).", "Filter the results to only include records for 'San Jose State University' and the year 2000.", "Construct the SQL query to select the count of degrees for the specified campus and year."], "gold_sql": "SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  'San Jose State University' AND t2.year  =  2000", "source_tables": ["degrees", "campuses"], "pred_sql": "SELECT COUNT(T3.Degrees) FROM Campuses AS T1 JOIN degrees AS T3 ON T1.Id = T3.Campus WHERE T1.Campus = 'San Jose State University' AND T3.Year = '2000'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for campuses that have awarded degrees in a specific year. The query joins the 'campuses' table with the 'faculty' and 'degrees' tables based on the campus identifier and filters the results for a particular year. The placeholders in the WHERE clause represent the year of interest and the limit for the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2377", "db_id": "csu_1", "question": "How many faculty lines are there at San Francisco State University in 2004?", "rationale": ["Identify the relevant tables: 'Campuses' for campus information and 'faculty' for faculty data.", "Join the 'Campuses' table with the 'faculty' table on the campus identifier to get faculty data for each campus.", "Filter the results to only include the campus named 'San Francisco State University'.", "Further filter the results to only include the year 2004 for the faculty data.", "Select the number of faculty members from the joined tables."], "gold_sql": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  2004 AND T2.campus  =  'San Francisco State University'", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT T2.Faculty FROM Campuses AS T1 JOIN faculty AS T2 ON T1.Id = T2.Campus JOIN degrees AS T3 ON T1.Id = T3.Campus AND T2.Year = T3.Year WHERE T1.Campus = 'San Francisco State University' AND T2.Year = 2004", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to associate campuses with their respective faculty data and also joins the 'degrees' table to ensure that the faculty data corresponds to the same year as the degrees awarded. The placeholders in the WHERE clause represent the year of interest and the limit on the number of results to return.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2378", "db_id": "csu_1", "question": "List the campus that have between 600 and 1000 faculty lines in year 2004.", "rationale": ["Identify the relevant tables: Campuses and faculty.", "We need to filter the faculty data for the year 2004.", "We need to find campuses where the number of faculty members is between 600 and 1000.", "Join the Campuses table with the faculty table on the campus identifier.", "Select the Campus name from the Campuses table where the faculty count meets the specified criteria."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  600 AND t2.faculty  <=  1000 AND T1.year  =  2004", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT T1.Campus FROM Campuses AS T1 JOIN faculty AS T2 ON T1.Id = T2.Campus WHERE T2.Year = 2004 AND T2.Faculty BETWEEN 600 AND 1000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to associate campuses with their respective faculty data and also joins the 'degrees' table to ensure that the faculty data corresponds to the same year as the degrees awarded. The placeholders in the WHERE clause represent the year of interest and the limit on the number of results to return.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2379", "db_id": "csu_1", "question": "What are the campuses that had between 600 and 1000 faculty members in 2004?", "rationale": ["Identify the relevant tables: 'Campuses' and 'faculty'.", "We need to filter the faculty data for the year 2004, so we will use a WHERE clause to specify this year.", "We also need to filter the number of faculty members to be between 600 and 1000, which will be done using the BETWEEN clause in the WHERE condition.", "Join the 'Campuses' table with the 'faculty' table on the campus identifier to get the campus names along with their faculty counts.", "Select the 'Campus' from the 'Campuses' table where the conditions are met."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  600 AND t2.faculty  <=  1000 AND T1.year  =  2004", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT T1.Campus FROM Campuses AS T1 JOIN faculty AS T2 ON T1.Id = T2.Campus WHERE T2.Year = 2004 AND T2.Faculty BETWEEN 600 AND 1000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to associate campuses with their respective faculty data and also joins the 'degrees' table to ensure that the faculty data corresponds to the same year as the degrees awarded. The placeholders in the WHERE clause represent the year of interest and the limit on the number of results to return.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2380", "db_id": "csu_1", "question": "How many faculty lines are there in the university that conferred the most number of degrees in year 2002?", "rationale": ["Identify the year of interest, which is 2002.", "Join the 'Campuses' table with the 'faculty' and 'degrees' tables using the campus identifier.", "Filter the results to only include records from the year 2002 in the 'degrees' table.", "Group the results by campus to count the number of faculty members for each campus that awarded degrees in 2002.", "Order the campuses by the count of degrees awarded in descending order to find the campus with the most degrees conferred.", "Limit the results to 1 to get only the campus with the most degrees.", "Count the number of faculty lines for that campus."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2002 ORDER BY t3.degrees DESC LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "pred_sql": "SELECT COUNT(T2.Faculty) FROM Campuses AS T1 JOIN faculty AS T2 ON T1.Id = T2.Campus JOIN degrees AS T3 ON T1.Id = T3.Campus WHERE T3.Year = '2002' GROUP BY T1.Campus ORDER BY COUNT(T3.Degrees) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for campuses that have awarded degrees in a specific year. The query joins the 'campuses' table with the 'faculty' and 'degrees' tables based on the campus identifier and filters the results for a particular year. The placeholders in the WHERE clause represent the year of interest and the limit for the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2383", "db_id": "csu_1", "question": "How many faculty members are at the university that gave the least number of degrees in 2001?", "rationale": ["Identify the relevant tables: 'faculty' for faculty members and 'degrees' for the number of degrees awarded.", "Join the 'Campuses' table with 'faculty' and 'degrees' tables using the campus identifier.", "Filter the results for the year 2001 in the 'faculty' table.", "To find the university with the least number of degrees, we need to order the results based on the count of degrees awarded in 2001.", "Use a subquery to count the degrees for each campus and order by this count.", "Limit the results to 1 to get the campus with the least number of degrees."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2001 ORDER BY t3.degrees LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "pred_sql": "SELECT T2.Faculty FROM Campuses AS T1 JOIN faculty AS T2 ON T1.Id = T2.Campus JOIN degrees AS T3 ON T1.Id = T3.Campus AND T2.Year = T3.Year WHERE T2.Year = 2001 ORDER BY (SELECT COUNT(*) FROM degrees WHERE Year = 2001 AND Campus = T1.Id) LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for campuses that have awarded degrees in a specific year. The query joins the 'campuses' table with the 'faculty' and 'degrees' tables based on the campus identifier and filters the results for a particular year. The placeholders in the WHERE clause represent the year of interest and the limit for the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2385", "db_id": "csu_1", "question": "How many undergraduates are there at San Jose State", "rationale": ["Identify the relevant table for undergraduate enrollments, which is 'discipline_enrollments'.", "Determine the specific campus of interest, which is 'San Jose State'.", "Use a subquery to find the 'Id' of 'San Jose State' from the 'Campuses' table.", "Filter the 'discipline_enrollments' table by the campus 'Id' obtained from the subquery.", "Sum the 'Undergraduate' column to get the total number of undergraduates for 'San Jose State'."], "gold_sql": "SELECT sum(t1.undergraduate) FROM discipline_enrollments AS t1 JOIN campuses AS t2 ON t1.campus  =  t2.id WHERE t1.year  =  2004 AND t2.campus  =  'San Jose State University'", "source_tables": ["discipline_enrollments", "campuses"], "pred_sql": "SELECT SUM(Undergraduate) AS TotalUndergraduates \nFROM discipline_enrollments \nWHERE Campus = (SELECT Id FROM Campuses WHERE Campus = 'San Jose State') \nGROUP BY Campus;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for campuses that have awarded degrees in a specific year. The query joins the 'campuses' table with the 'faculty' and 'degrees' tables based on the campus identifier and filters the results for a particular year. The placeholders in the WHERE clause represent the year of interest and the limit for the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3131", "db_id": "assets_maintenance", "question": "Which engineer has visited the most times? Show the engineer id, first name and last name.", "rationale": ["Identify the relevant tables: Engineer_Visits and Maintenance_Engineers.", "We need to count the number of visits for each engineer, so we will use COUNT(*) to aggregate the visits.", "Join the Engineer_Visits table with the Maintenance_Engineers table on the engineer_id to get the first and last names of the engineers.", "Group the results by engineer_id, first_name, and last_name to get the count of visits for each engineer.", "Order the results by visit_count in descending order to find the engineer with the most visits.", "Limit the results to 1 to get only the engineer with the highest visit count."], "gold_sql": "SELECT T1.engineer_id ,  T1.first_name ,  T1.last_name FROM Maintenance_Engineers AS T1 JOIN Engineer_Visits AS T2 GROUP BY T1.engineer_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["maintenance_engineers", "engineer_visits"], "pred_sql": "SELECT engineer_id, first_name, last_name, COUNT(*) as visit_count\nFROM Engineer_Visits\nJOIN Maintenance_Engineers ON Engineer_Visits.engineer_id = Maintenance_Engineers.engineer_id\nGROUP BY engineer_id, first_name, last_name\nORDER BY visit_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3139", "db_id": "assets_maintenance", "question": "How many fault status codes are recorded in the fault log parts table?", "rationale": ["The question asks for the number of unique fault status codes recorded in the Fault_Log_Parts table.", "To find the unique fault status codes, we can use the COUNT function along with DISTINCT to count only unique values.", "The relevant column in the Fault_Log_Parts table is 'fault_status'.", "The SQL query will select the count of distinct fault status codes from the Fault_Log_Parts table."], "gold_sql": "SELECT DISTINCT fault_status FROM Fault_Log_Parts", "source_tables": ["fault_log_parts"], "pred_sql": "SELECT COUNT(DISTINCT fault_status) AS unique_fault_status_count FROM Fault_Log_Parts;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of fault short names along with their corresponding skill descriptions required to fix those faults. The data is sourced from the 'Part_Faults' table, which contains information about faults related to parts, and is joined with the 'Skills_Required_To_Fix' table to identify the necessary skills, and the 'Skills' table to get detailed descriptions of those skills.\",\n        \"virtual_table\": \"SELECT T1.fault_short_name ,  T3.skill_description FROM Part_Faults AS T1 JOIN Skills_Required_To_Fix AS T2 ON T1.part_fault_id  =  T2.part_fault_id JOIN Skills AS T3 ON T2.skill_id  =  T3.skill_id\"\n    }\n}\n"}
{"sample_id": "train.3143", "db_id": "assets_maintenance", "question": "Which part fault requires the most number of skills to fix? List part id and name.", "rationale": ["Identify the relevant tables: Part_Faults and Skills_Required_To_Fix.", "Join Part_Faults with Skills_Required_To_Fix to link part faults with the skills required to fix them.", "Group the results by part_id and part_name to count the number of skills associated with each part fault.", "Order the results by the count of skills in descending order to find the part fault that requires the most skills.", "Limit the results to 1 to get only the part fault with the highest count of required skills."], "gold_sql": "SELECT T1.part_id ,  T1.part_name FROM Parts AS T1 JOIN Part_Faults AS T2 ON T1.part_id  =  T2.part_id JOIN Skills_Required_To_Fix AS T3 ON T2.part_fault_id  =  T3.part_fault_id GROUP BY T1.part_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["part_faults", "parts", "skills_required_to_fix"], "pred_sql": "SELECT T1.part_id, T1.part_name FROM Part_Faults AS T1 JOIN Skills_Required_To_Fix AS T2 ON T1.part_fault_id = T2.part_fault_id GROUP BY T1.part_id, T1.part_name ORDER BY COUNT(T2.skill_id) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of fault short names along with their corresponding skill descriptions required to fix those faults. The data is sourced from the 'Part_Faults' table, which contains information about faults related to parts, and is joined with the 'Skills_Required_To_Fix' table to identify the necessary skills, and the 'Skills' table to get detailed descriptions of those skills.\",\n        \"virtual_table\": \"SELECT T1.fault_short_name ,  T3.skill_description FROM Part_Faults AS T1 JOIN Skills_Required_To_Fix AS T2 ON T1.part_fault_id  =  T2.part_fault_id JOIN Skills AS T3 ON T2.skill_id  =  T3.skill_id\"\n    }\n}\n"}
{"sample_id": "train.3176", "db_id": "college_1", "question": "How many professors teach a class with the code ACCT-211?", "rationale": ["Identify the relevant tables: CLASS and PROFESSOR.", "We need to count the number of distinct professors teaching a specific class, so we will use COUNT(DISTINCT p.EMP_NUM).", "Join the CLASS table with the PROFESSOR table on the common key PROF_NUM.", "Filter the results to only include the class with the code 'ACCT-211'.", "Construct the SQL query to select the count of distinct professors for the specified class."], "gold_sql": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["class"], "pred_sql": "SELECT COUNT(DISTINCT p.EMP_NUM) AS ProfessorCount\nFROM CLASS c\nJOIN PROFESSOR p ON c.PROF_NUM = p.EMP_NUM\nWHERE c.CLASS_CODE = 'ACCT-211';", "hint": "\n"}
{"sample_id": "train.3180", "db_id": "college_1", "question": "What are the first names and birthdates of the professors in charge of ACCT-211?", "rationale": ["Identify the relevant tables: CLASS, PROFESSOR, and EMPLOYEE are needed to get the first names and birthdates of professors.", "The CLASS table contains the course code (CRS_CODE) which we need to filter by 'ACCT-211'.", "The PROFESSOR table links the CLASS table to the EMPLOYEE table through the PROF_NUM field, allowing us to access the employee details of the professors.", "We need to select the EMP_FNAME (first name) and EMP_DOB (date of birth) from the EMPLOYEE table.", "Construct the SQL query using JOINs to connect these tables and apply the WHERE clause to filter by the specific course code 'ACCT-211'."], "gold_sql": "SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["employee", "class"], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME, EMPLOYEE.EMP_DOB \nFROM CLASS \nJOIN PROFESSOR ON CLASS.PROF_NUM = PROFESSOR.EMP_NUM \nJOIN EMPLOYEE ON PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM \nWHERE CLASS.CRS_CODE = 'ACCT-211';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of students enrolled in classes associated with a specific course code and who have received a particular grade. The placeholders in the WHERE clause represent the course code and the grade received by the students.\",\n        \"virtual_table\": \"SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  [PLACEHOLDER-TYPE:STRING] AND T2.enroll_grade  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3189", "db_id": "college_1", "question": "How many different locations does the school with code BUS has?", "rationale": ["Identify the table that contains the location information, which is the DEPARTMENT table.", "Determine the relevant column for location, which is DEPT_ADDRESS.", "We need to count the distinct addresses to find out how many different locations there are.", "Filter the results to only include departments that belong to the school with code 'BUS'.", "Construct the SQL query using COUNT and DISTINCT to get the desired result."], "gold_sql": "SELECT count(DISTINCT dept_address) FROM department WHERE school_code  =  'BUS'", "source_tables": ["department"], "pred_sql": "SELECT COUNT(DISTINCT DEPT_ADDRESS) AS different_locations\nFROM DEPARTMENT\nWHERE SCHOOL_CODE = 'BUS';", "hint": "\n"}
{"sample_id": "train.3190", "db_id": "college_1", "question": "What are the different locations of the school with the code BUS?", "rationale": ["Identify the table that contains the school locations, which is the DEPARTMENT table.", "Determine the relevant column for the school code, which is SCHOOL_CODE in the DEPARTMENT table.", "Use the DISTINCT keyword to ensure unique addresses are returned.", "Construct the SQL query to select DEPT_ADDRESS from DEPARTMENT where SCHOOL_CODE equals 'BUS'."], "gold_sql": "SELECT count(DISTINCT dept_address) FROM department WHERE school_code  =  'BUS'", "source_tables": ["department"], "pred_sql": "SELECT DISTINCT DEPT_ADDRESS FROM DEPARTMENT WHERE SCHOOL_CODE = 'BUS';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of students enrolled in classes associated with a specific course code and who have received a particular grade. The placeholders in the WHERE clause represent the course code and the grade received by the students.\",\n        \"virtual_table\": \"SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  [PLACEHOLDER-TYPE:STRING] AND T2.enroll_grade  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3206", "db_id": "college_1", "question": "How many classes are held in each department?", "rationale": ["Identify the tables needed: DEPARTMENT, COURSE, and CLASS.", "We need to count the number of classes in each department, so we will use the COUNT function on CLASS_CODE.", "Join the DEPARTMENT table with the COURSE table on DEPT_CODE to link departments to their courses.", "Then, join the resulting table with the CLASS table on CRS_CODE to link courses to their classes.", "Group the results by DEPT_NAME to get the count of classes per department."], "gold_sql": "SELECT count(*) ,  dept_code FROM CLASS AS T1 JOIN course AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY dept_code", "source_tables": ["course", "class"], "pred_sql": "SELECT D.DEPT_NAME, COUNT(C.CLASS_CODE) AS CLASS_COUNT \nFROM DEPARTMENT D \nJOIN COURSE C ON D.DEPT_CODE = C.DEPT_CODE \nJOIN CLASS CL ON C.CRS_CODE = CL.CRS_CODE \nGROUP BY D.DEPT_NAME;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department names from the 'DEPARTMENT' table, which are associated with courses from the 'COURSE' table. The query joins the 'COURSE' and 'CLASS' tables to link courses to their respective classes, and then joins the 'DEPARTMENT' table to retrieve the department names. The results are grouped by department code and ordered by the total sum of credit hours for the courses in descending order, with a limit on the number of departments returned as specified by a placeholder.\",\n        \"virtual_table\": \"SELECT T3.dept_name FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code JOIN department AS T3 ON T1.dept_code  =  T3.dept_code GROUP BY T1.dept_code ORDER BY sum(T1.crs_credit) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3209", "db_id": "college_1", "question": "What is the number of professors for different school?", "rationale": ["Identify the relevant tables: DEPARTMENT and PROFESSOR.", "We need to count the number of professors, so we will use the COUNT() function.", "To relate professors to their departments, we will join the DEPARTMENT table with the PROFESSOR table on the DEPT_CODE column.", "We need to group the results by SCHOOL_CODE to get the count of professors for each school.", "The final query will select the SCHOOL_CODE and the count of professors, using GROUP BY to aggregate the results."], "gold_sql": "SELECT count(*) ,  T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code", "source_tables": ["department", "professor"], "pred_sql": "SELECT SCHOOL_CODE, COUNT(*) AS NUMBER_OF_PROFESSORS\nFROM DEPARTMENT\nJOIN PROFESSOR ON DEPARTMENT.DEPT_CODE = PROFESSOR.DEPT_CODE\nGROUP BY SCHOOL_CODE;", "hint": "\n"}
{"sample_id": "train.3210", "db_id": "college_1", "question": "How many different professors are there for the different schools?", "rationale": ["Identify the relevant tables: PROFESSOR and DEPARTMENT are needed to find the professors and their associated schools.", "Count the distinct professors: Use COUNT(DISTINCT PROFESSOR.EMP_NUM) to get the number of unique professors.", "Join the tables: Join PROFESSOR with DEPARTMENT on DEPT_CODE to associate professors with their departments.", "The hint suggests a virtual table, which implies that we may need to consider the relationship between professors and schools through departments."], "gold_sql": "SELECT count(*) ,  T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code", "source_tables": ["department", "professor"], "pred_sql": "SELECT COUNT(DISTINCT PROFESSOR.EMP_NUM) AS different_professors\nFROM PROFESSOR\nJOIN DEPARTMENT ON PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE\nJOIN CLASS ON DEPARTMENT.DEPT_CODE = CLASS.CRS_CODE;", "hint": "\n"}
{"sample_id": "train.3217", "db_id": "college_1", "question": "Find the number of students for each department.", "rationale": ["We need to find the number of students for each department, which involves counting students grouped by their department.", "The relevant tables are DEPARTMENT and STUDENT, as we need to get department names and the count of students in each department.", "We will use a LEFT JOIN to connect the DEPARTMENT table with the STUDENT table on the DEPT_CODE, ensuring we include departments even if they have no students.", "We will use the COUNT function to count the number of students (STU_NUM) for each department.", "Finally, we will group the results by DEPARTMENT.DEPT_NAME to get the count for each department."], "gold_sql": "SELECT count(*) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME, COUNT(STUDENT.STU_NUM) AS NUM_STUDENTS\nFROM DEPARTMENT\nLEFT JOIN STUDENT ON DEPARTMENT.DEPT_CODE = STUDENT.DEPT_CODE\nGROUP BY DEPARTMENT.DEPT_NAME;", "hint": "\n"}
{"sample_id": "train.3218", "db_id": "college_1", "question": "How many students are in each department?", "rationale": ["We need to count the number of students in each department.", "To do this, we will join the DEPARTMENT table with the COURSE table to get the courses offered by each department.", "Next, we join the CLASS table to get the classes associated with those courses.", "Then, we join the ENROLL table to find out which students are enrolled in those classes.", "Finally, we join the STUDENT table to access student information and count the number of students per department.", "We will group the results by DEPT_NAME to get the count of students in each department."], "gold_sql": "SELECT count(*) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT DEPT_NAME, COUNT(STU_NUM) AS STUDENT_COUNT \nFROM DEPARTMENT \nJOIN COURSE ON DEPARTMENT.DEPT_CODE = COURSE.DEPT_CODE \nJOIN CLASS ON COURSE.CRS_CODE = CLASS.CRS_CODE \nJOIN ENROLL ON CLASS.CLASS_CODE = ENROLL.CLASS_CODE \nJOIN STUDENT ON ENROLL.STU_NUM = STUDENT.STU_NUM \nGROUP BY DEPT_NAME;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the name of the department.\",\n        \"virtual_table\": \"SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3220", "db_id": "college_1", "question": "How many hours do the students spend studying in each department?", "rationale": ["The question asks for the total hours students spend studying in each department, which can be interpreted as the total credit hours of courses taken by students in each department.", "To find this information, we need to join several tables: COURSE, CLASS, DEPARTMENT, STUDENT, and ENROLL.", "First, we join the COURSE table with the CLASS table on the CRS_CODE to link courses to their respective classes.", "Next, we join the DEPARTMENT table to get the department names associated with the courses.", "Then, we join the STUDENT table to get the students enrolled in those classes, and finally, we join the ENROLL table to link students to their respective classes and get the credit hours.", "We will group the results by department code to aggregate the total credit hours for each department.", "Finally, we will order the results by the total credit hours in descending order to see which department has the most hours spent studying."], "gold_sql": "SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT T3.DEPT_NAME, SUM(T1.CRS_CREDIT) AS TOTAL_CREDIT_HOURS\nFROM COURSE AS T1\nJOIN CLASS AS T2 ON T1.CRS_CODE = T2.CRS_CODE\nJOIN DEPARTMENT AS T3 ON T1.DEPT_CODE = T3.DEPT_CODE\nJOIN STUDENT AS T4 ON T3.DEPT_CODE = T4.DEPT_CODE\nJOIN ENROLL AS T5 ON T4.STU_NUM = T5.STU_NUM AND T2.CLASS_CODE = T5.CLASS_CODE\nGROUP BY T3.DEPT_CODE\nORDER BY TOTAL_CREDIT_HOURS DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department names from the 'DEPARTMENT' table, which are associated with courses from the 'COURSE' table. The query joins the 'COURSE' and 'CLASS' tables to link courses to their respective classes, and then joins the 'DEPARTMENT' table to retrieve the department names. The results are grouped by department code and ordered by the total sum of credit hours for the courses in descending order, with a limit on the number of departments returned as specified by a placeholder.\",\n        \"virtual_table\": \"SELECT T3.dept_name FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code JOIN department AS T3 ON T1.dept_code  =  T3.dept_code GROUP BY T1.dept_code ORDER BY sum(T1.crs_credit) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3222", "db_id": "college_1", "question": "What is the highest, lowest, and average student GPA for every department?", "rationale": ["Identify the required information: highest, lowest, and average GPA for students, grouped by department.", "Determine the relevant tables: DEPARTMENT and STUDENT are needed to access department names and student GPAs.", "Use JOIN to connect DEPARTMENT and STUDENT on the DEPT_CODE field, which is common to both tables.", "Use aggregate functions: MAX() for highest GPA, MIN() for lowest GPA, and AVG() for average GPA.", "Group the results by department name to get the statistics for each department."], "gold_sql": "SELECT max(stu_gpa) ,  avg(stu_gpa) ,  min(stu_gpa) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME, \n       MAX(STUDENT.STU_GPA) AS Highest_GPA, \n       MIN(STUDENT.STU_GPA) AS Lowest_GPA, \n       AVG(STUDENT.STU_GPA) AS Average_GPA \nFROM DEPARTMENT \nJOIN STUDENT ON DEPARTMENT.DEPT_CODE = STUDENT.DEPT_CODE \nGROUP BY DEPARTMENT.DEPT_NAME;", "hint": "\n"}
{"sample_id": "train.3234", "db_id": "college_1", "question": "How many courses does the department of Computer Information Systmes offer?", "rationale": ["Identify the department of interest: Computer Information Systems.", "Find the DEPT_CODE associated with the Computer Information Systems department from the DEPARTMENT table.", "Count the number of courses in the COURSE table that have the DEPT_CODE obtained in the previous step."], "gold_sql": "SELECT count(*) FROM department AS T1 JOIN course AS T2 ON T1.dept_code  =  T2.dept_code WHERE dept_name  =  'Computer Info. Systems'", "source_tables": ["course", "department"], "pred_sql": "SELECT COUNT(*) AS course_count FROM COURSE WHERE DEPT_CODE = (SELECT DEPT_CODE FROM DEPARTMENT WHERE DEPT_NAME = 'Computer Information Systems')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department names from the 'DEPARTMENT' table, which are associated with courses from the 'COURSE' table. The query joins the 'COURSE' and 'CLASS' tables to link courses to their respective classes, and then joins the 'DEPARTMENT' table to retrieve the department names. The results are grouped by department code and ordered by the total sum of credit hours for the courses in descending order, with a limit on the number of departments returned as specified by a placeholder.\",\n        \"virtual_table\": \"SELECT T3.dept_name FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code JOIN department AS T3 ON T1.dept_code  =  T3.dept_code GROUP BY T1.dept_code ORDER BY sum(T1.crs_credit) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3238", "db_id": "college_1", "question": "What are the total number of credits offered by each department?", "rationale": ["Identify the tables needed: COURSE, CLASS, and DEPARTMENT.", "Determine the relationships: CLASS is linked to COURSE via CRS_CODE, and COURSE is linked to DEPARTMENT via DEPT_CODE.", "Select the department name from the DEPARTMENT table and the sum of credits from the COURSE table.", "Group the results by department code to get the total credits per department.", "Order the results by the total credits in descending order to see which department offers the most credits."], "gold_sql": "SELECT sum(T1.crs_credit) ,  T1.dept_code FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY T1.dept_code", "source_tables": ["course", "class"], "pred_sql": "SELECT T3.DEPT_NAME, SUM(T1.CRS_CREDIT) AS TOTAL_CREDITS \nFROM COURSE AS T1 \nJOIN CLASS AS T2 ON T1.CRS_CODE = T2.CRS_CODE \nJOIN DEPARTMENT AS T3 ON T1.DEPT_CODE = T3.DEPT_CODE \nGROUP BY T1.DEPT_CODE \nORDER BY TOTAL_CREDITS DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department names from the 'DEPARTMENT' table, which are associated with courses from the 'COURSE' table. The query joins the 'COURSE' and 'CLASS' tables to link courses to their respective classes, and then joins the 'DEPARTMENT' table to retrieve the department names. The results are grouped by department code and ordered by the total sum of credit hours for the courses in descending order, with a limit on the number of departments returned as specified by a placeholder.\",\n        \"virtual_table\": \"SELECT T3.dept_name FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code JOIN department AS T3 ON T1.dept_code  =  T3.dept_code GROUP BY T1.dept_code ORDER BY sum(T1.crs_credit) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3243", "db_id": "college_1", "question": "What is the first name of each student enrolled in class ACCT-211?", "rationale": ["Identify the tables needed: CLASS, ENROLL, and STUDENT are required to get the first names of students enrolled in a specific class.", "Use JOIN to connect the CLASS table with the ENROLL table on CLASS_CODE, and then connect the ENROLL table with the STUDENT table on STU_NUM.", "Filter the results by the specific course code 'ACCT-211' to get only those students enrolled in that class."], "gold_sql": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  'ACCT-211'", "source_tables": ["student", "class", "enroll"], "pred_sql": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN ENROLL AS T2 ON T1.CLASS_CODE = T2.CLASS_CODE JOIN STUDENT AS T3 ON T2.STU_NUM = T3.STU_NUM WHERE T1.CRS_CODE = 'ACCT-211'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of students enrolled in classes associated with a specific course code and who have received a particular grade. The placeholders in the WHERE clause represent the course code and the grade received by the students.\",\n        \"virtual_table\": \"SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  [PLACEHOLDER-TYPE:STRING] AND T2.enroll_grade  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3253", "db_id": "college_1", "question": "What is the name of the department that has the largest number of students enrolled?", "rationale": ["Identify the department with the largest number of students enrolled.", "To do this, we need to count the number of students in each department.", "We can achieve this by grouping the students by their department code (DEPT_CODE) and counting the number of students (STU_NUM) in each group.", "Next, we will order these counts in descending order to find the department with the maximum count.", "Finally, we will limit the results to just one department and select its name from the DEPARTMENT table."], "gold_sql": "SELECT T4.dept_name FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code GROUP BY T3.dept_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["course", "department", "class", "enroll"], "pred_sql": "SELECT dept_name FROM department WHERE dept_code IN (SELECT dept_code FROM student GROUP BY dept_code ORDER BY COUNT(stu_num) DESC LIMIT 1);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the name of the department.\",\n        \"virtual_table\": \"SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3254", "db_id": "college_1", "question": "What is the name of the department with the most students enrolled?", "rationale": ["We need to find the department with the most students enrolled.", "To do this, we can count the number of students in each department by grouping the students by their department code.", "We will use the COUNT function to count the number of students (stu_num) for each department (dept_code).", "Next, we will order the results in descending order based on the count of students to get the department with the most students at the top.", "Finally, we will limit the results to just one department using LIMIT 1, and select the department name from the department table using a subquery."], "gold_sql": "SELECT T4.dept_name FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code GROUP BY T3.dept_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["course", "department", "class", "enroll"], "pred_sql": "SELECT dept_name FROM department WHERE dept_code IN (SELECT dept_code FROM student GROUP BY dept_code ORDER BY COUNT(stu_num) DESC LIMIT 1);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the name of the department.\",\n        \"virtual_table\": \"SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3258", "db_id": "college_1", "question": "What are the codes of all the courses that are located in room KLR209?", "rationale": ["Identify the relevant table: The CLASS table contains information about classes, including their room assignments.", "Determine the required columns: We need the CRS_CODE of the courses, which is present in the CLASS table.", "Specify the condition: We want to filter the results to only include classes held in room 'KLR209'.", "Use DISTINCT to ensure that we only get unique course codes, as multiple classes can be held in the same room."], "gold_sql": "SELECT class_code FROM CLASS WHERE class_room  =  'KLR209'", "source_tables": ["class"], "pred_sql": "SELECT DISTINCT CRS_CODE FROM CLASS WHERE CLASS_ROOM = 'KLR209';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of students enrolled in classes associated with a specific course code and who have received a particular grade. The placeholders in the WHERE clause represent the course code and the grade received by the students.\",\n        \"virtual_table\": \"SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  [PLACEHOLDER-TYPE:STRING] AND T2.enroll_grade  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3267", "db_id": "college_1", "question": "What is the first name of students who got grade C in any class?", "rationale": ["Identify the tables involved: CLASS, ENROLL, and STUDENT are needed to find the first names of students with a specific grade.", "Use JOIN to connect the CLASS table with the ENROLL table on CLASS_CODE, and then connect the ENROLL table with the STUDENT table on STU_NUM.", "Filter the results to only include students who received a grade of 'C' by adding a WHERE clause that specifies T2.ENROLL_GRADE = 'C'.", "Select the first names of the students from the STUDENT table, which is represented as T3.STU_FNAME."], "gold_sql": "SELECT DISTINCT stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE enroll_grade  =  'C'", "source_tables": ["enroll", "student"], "pred_sql": "SELECT T3.STU_FNAME FROM CLASS AS T1 JOIN ENROLL AS T2 ON T1.CLASS_CODE = T2.CLASS_CODE JOIN STUDENT AS T3 ON T2.STU_NUM = T3.STU_NUM WHERE T2.ENROLL_GRADE = 'C'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of students enrolled in classes associated with a specific course code and who have received a particular grade. The placeholders in the WHERE clause represent the course code and the grade received by the students.\",\n        \"virtual_table\": \"SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  [PLACEHOLDER-TYPE:STRING] AND T2.enroll_grade  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3273", "db_id": "college_1", "question": "What are the first names of the professors who do not teach a class.", "rationale": ["We need to find the first names of professors who do not teach a class.", "To do this, we will start by selecting the first names from the EMPLOYEE table.", "We will join the PROFESSOR table to link professors with their employee records.", "Next, we will perform a LEFT JOIN with the CLASS table to find any classes taught by the professors.", "To filter out professors who do not teach any class, we will check for NULL values in the CLASS_CODE from the CLASS table."], "gold_sql": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  'PROF' EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num", "source_tables": ["employee", "class"], "pred_sql": "SELECT EMP.EMP_FNAME \nFROM EMPLOYEE AS EMP \nLEFT JOIN PROFESSOR AS PROF ON EMP.EMP_NUM = PROF.EMP_NUM \nLEFT JOIN CLASS AS CLS ON PROF.EMP_NUM = CLS.PROF_NUM \nWHERE CLS.CLASS_CODE IS NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first names of employees and the office locations of professors from the 'employee' and 'professor' tables, respectively. It filters the results based on a specific department name and the highest degree obtained by the professors, both represented by placeholders for string values.\",\n        \"virtual_table\": \"SELECT T1.emp_fname ,  T2.prof_office FROM employee AS T1 JOIN professor AS T2 ON T1.emp_num  =  T2.emp_num JOIN department AS T3 ON T3.dept_code  =  T2.dept_code WHERE T3.dept_name  =  [PLACEHOLDER-TYPE:STRING] AND T2.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3274", "db_id": "college_1", "question": "What are the first names of all professors not teaching any classes?", "rationale": ["Identify the relevant tables: We need to find professors and their teaching status, so we will use the PROFESSOR and CLASS tables.", "We need the first names of professors, which are in the EMPLOYEE table, linked to the PROFESSOR table by EMP_NUM.", "To find professors not teaching any classes, we can use a subquery that selects PROF_NUM from the CLASS table.", "The main query will select EMP_FNAME from the EMPLOYEE table where EMP_NUM is not in the list of PROF_NUMs returned by the subquery."], "gold_sql": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  'PROF' EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num", "source_tables": ["employee", "class"], "pred_sql": "SELECT EMP_FNAME FROM EMPLOYEE WHERE EMP_NUM NOT IN (SELECT PROF_NUM FROM CLASS)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first names of employees and the office locations of professors from the 'employee' and 'professor' tables, respectively. It filters the results based on a specific department name and the highest degree obtained by the professors, both represented by placeholders for string values.\",\n        \"virtual_table\": \"SELECT T1.emp_fname ,  T2.prof_office FROM employee AS T1 JOIN professor AS T2 ON T1.emp_num  =  T2.emp_num JOIN department AS T3 ON T3.dept_code  =  T2.dept_code WHERE T3.dept_name  =  [PLACEHOLDER-TYPE:STRING] AND T2.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3288", "db_id": "college_1", "question": "How many professors attained either Ph.D. or Masters degrees?", "rationale": ["Identify the relevant table: The 'professor' table contains information about professors, including their highest degree obtained.", "Determine the condition: We need to count professors who have either a Ph.D. or a Masters degree.", "Use the COUNT function: To get the total number of professors meeting the criteria, we will use the COUNT(*) function.", "Construct the SQL query: The final SQL query will select the count of professors from the 'professor' table where the 'prof_high_degree' is either 'Ph.D.' or 'Masters'."], "gold_sql": "SELECT count(*) FROM professor WHERE prof_high_degree  =  'Ph.D.' OR prof_high_degree  =  'MA'", "source_tables": ["professor"], "pred_sql": "SELECT COUNT(*) FROM professor WHERE prof_high_degree IN ('Ph.D.', 'Masters')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first names of employees and the office locations of professors from the 'employee' and 'professor' tables, respectively. It filters the results based on a specific department name and the highest degree obtained by the professors, both represented by placeholders for string values.\",\n        \"virtual_table\": \"SELECT T1.emp_fname ,  T2.prof_office FROM employee AS T1 JOIN professor AS T2 ON T1.emp_num  =  T2.emp_num JOIN department AS T3 ON T3.dept_code  =  T2.dept_code WHERE T3.dept_name  =  [PLACEHOLDER-TYPE:STRING] AND T2.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3293", "db_id": "college_1", "question": "Find the first name of student who is taking classes from accounting and Computer Info. Systems departments", "rationale": ["Identify the departments of interest: Accounting and Computer Info. Systems.", "Use the provided virtual table structure to create a query that selects the first names of students enrolled in classes from these departments.", "Utilize the INTERSECT operation to ensure that only students enrolled in classes from both departments are returned.", "Replace the placeholders in the virtual table with the actual department names: 'Accounting' and 'Computer Info. Systems'.", "Construct the final SQL query using the JOINs and WHERE clauses as specified in the virtual table description."], "gold_sql": "SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Accounting' INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Computer Info. Systems'", "source_tables": ["course", "enroll", "department", "class", "student"], "pred_sql": "SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num = T2.stu_num JOIN CLASS AS T3 ON T2.class_code = T3.class_code JOIN course AS T4 ON T3.crs_code = T4.crs_code JOIN department AS T5 ON T5.dept_code = T4.dept_code WHERE T5.dept_name = 'Accounting' INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num = T2.stu_num JOIN CLASS AS T3 ON T2.class_code = T3.class_code JOIN course AS T4 ON T3.crs_code = T4.crs_code JOIN department AS T5 ON T5.dept_code = T4.dept_code WHERE T5.dept_name = 'Computer Info. Systems'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the name of the department.\",\n        \"virtual_table\": \"SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3300", "db_id": "college_1", "question": "What is the name of the department with the student that has the lowest GPA?", "rationale": ["Identify the relevant tables: DEPARTMENT and STUDENT are needed to find the department name and the student with the lowest GPA.", "Join the DEPARTMENT table with the STUDENT table on the DEPT_CODE to link students to their respective departments.", "Use a subquery to find the minimum GPA from the STUDENT table.", "Filter the results to only include the department of the student(s) with the lowest GPA."], "gold_sql": "SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT 1", "source_tables": ["department", "student"], "pred_sql": "SELECT D.DEPT_NAME \nFROM DEPARTMENT AS D \nJOIN STUDENT AS S ON D.DEPT_CODE = S.DEPT_CODE \nWHERE S.STU_GPA = (SELECT MIN(STU_GPA) FROM STUDENT)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the name of the department.\",\n        \"virtual_table\": \"SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3314", "db_id": "college_1", "question": "What are the first names, office locations of all lecturers who have taught some course?", "rationale": ["Identify the tables needed: EMPLOYEE and PROFESSOR, since we need first names and office locations.", "Join the EMPLOYEE table with the PROFESSOR table on the EMP_NUM field to get the relevant information.", "We don't need to filter by department name or highest degree, but we need to ensure that the professors have taught some course, which can be inferred by checking if their EMP_NUM exists in the PROFESSOR table.", "Select the first names (EMP_FNAME) from the EMPLOYEE table and the office locations (PROF_OFFICE) from the PROFESSOR table."], "gold_sql": "SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num", "source_tables": ["course", "employee", "professor", "class"], "pred_sql": "SELECT T1.EMP_FNAME, T2.PROF_OFFICE \nFROM EMPLOYEE AS T1 \nJOIN PROFESSOR AS T2 ON T1.EMP_NUM = T2.EMP_NUM \nJOIN DEPARTMENT AS T3 ON T3.DEPT_CODE = T2.DEPT_CODE \nWHERE T2.PROF_NUM IS NOT NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first names of employees and the office locations of professors from the 'employee' and 'professor' tables, respectively. It filters the results based on a specific department name and the highest degree obtained by the professors, both represented by placeholders for string values.\",\n        \"virtual_table\": \"SELECT T1.emp_fname ,  T2.prof_office FROM employee AS T1 JOIN professor AS T2 ON T1.emp_num  =  T2.emp_num JOIN department AS T3 ON T3.dept_code  =  T2.dept_code WHERE T3.dept_name  =  [PLACEHOLDER-TYPE:STRING] AND T2.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3315", "db_id": "college_1", "question": "Find the first names and offices of all instructors who have taught some course and the course description and the department name.", "rationale": ["Identify the required fields: first names of instructors (from EMPLOYEE), office locations (from PROFESSOR), course descriptions (from COURSE), and department names (from DEPARTMENT).", "Determine the relationships between the tables: EMPLOYEE is linked to PROFESSOR via EMP_NUM, PROFESSOR is linked to DEPARTMENT via DEPT_CODE, and CLASS is linked to PROFESSOR via PROF_NUM. Additionally, CLASS is linked to COURSE via CRS_CODE.", "Construct the SQL query by joining the necessary tables based on the identified relationships and selecting the required fields."], "gold_sql": "SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description ,  T5.dept_name FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num JOIN department AS T5 ON T4.dept_code  =  T5.dept_code", "source_tables": ["course", "department", "professor", "class", "employee"], "pred_sql": "SELECT E.EMP_FNAME, P.PROF_OFFICE, C.CRS_DESCRIPTION, D.DEPT_NAME \nFROM EMPLOYEE AS E \nJOIN PROFESSOR AS P ON E.EMP_NUM = P.EMP_NUM \nJOIN DEPARTMENT AS D ON P.DEPT_CODE = D.DEPT_CODE \nJOIN CLASS AS C ON P.EMP_NUM = C.PROF_NUM \nJOIN COURSE AS C2 ON C.CRS_CODE = C2.CRS_CODE;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first names of employees and the office locations of professors from the 'employee' and 'professor' tables, respectively. It filters the results based on a specific department name and the highest degree obtained by the professors, both represented by placeholders for string values.\",\n        \"virtual_table\": \"SELECT T1.emp_fname ,  T2.prof_office FROM employee AS T1 JOIN professor AS T2 ON T1.emp_num  =  T2.emp_num JOIN department AS T3 ON T3.dept_code  =  T2.dept_code WHERE T3.dept_name  =  [PLACEHOLDER-TYPE:STRING] AND T2.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3333", "db_id": "college_1", "question": "Find the name of department that offers the class whose description has the word \"Statistics\".", "rationale": ["Identify the relevant tables: COURSE, CLASS, and DEPARTMENT.", "We need to find the department name, which is in the DEPARTMENT table.", "The class description is in the COURSE table, and we need to filter for descriptions containing the word 'Statistics'.", "Join the COURSE table with the CLASS table on CRS_CODE to link courses to their classes.", "Join the resulting table with the DEPARTMENT table on DEPT_CODE to get the department names.", "Use a WHERE clause to filter the courses based on the description containing 'Statistics'.", "Select the DEPT_NAME from the DEPARTMENT table."], "gold_sql": "SELECT T2.dept_name FROM course AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.crs_description LIKE '%Statistics%'", "source_tables": ["course", "department"], "pred_sql": "SELECT D.DEPT_NAME \nFROM COURSE AS C \nJOIN CLASS AS CL ON C.CRS_CODE = CL.CRS_CODE \nJOIN DEPARTMENT AS D ON C.DEPT_CODE = D.DEPT_CODE \nWHERE C.CRS_DESCRIPTION LIKE '%Statistics%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department names from the 'DEPARTMENT' table, which are associated with courses from the 'COURSE' table. The query joins the 'COURSE' and 'CLASS' tables to link courses to their respective classes, and then joins the 'DEPARTMENT' table to retrieve the department names. The results are grouped by department code and ordered by the total sum of credit hours for the courses in descending order, with a limit on the number of departments returned as specified by a placeholder.\",\n        \"virtual_table\": \"SELECT T3.dept_name FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code JOIN department AS T3 ON T1.dept_code  =  T3.dept_code GROUP BY T1.dept_code ORDER BY sum(T1.crs_credit) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3417", "db_id": "hr_1", "question": "display the full name (first and last), hire date, salary, and department number for those employees whose first name does not containing the letter M.", "rationale": ["Identify the required fields: full name (first and last), hire date, salary, and department number.", "To get the full name, concatenate FIRST_NAME and LAST_NAME with a space in between.", "Filter employees whose first name does not contain the letter 'M'.", "Use the NOT LIKE operator with the pattern '%M%' to exclude those names.", "Select the relevant columns from the employees table."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%'", "source_tables": ["employees"], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, HIRE_DATE, SALARY, DEPARTMENT_ID FROM employees WHERE FIRST_NAME NOT LIKE '%M%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3418", "db_id": "hr_1", "question": "What are the full name, hire date, salary, and department id for employees without the letter M in their first name?", "rationale": ["Identify the required fields: full name (first and last), hire date, salary, and department id.", "To create the full name, concatenate the first and last names using '||'.", "Filter employees whose first name does not contain the letter 'M' using the NOT LIKE operator.", "Select the relevant fields from the 'employees' table, applying the necessary filters."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%'", "source_tables": ["employees"], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, HIRE_DATE, SALARY, DEPARTMENT_ID FROM employees WHERE FIRST_NAME NOT LIKE '%M%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3419", "db_id": "hr_1", "question": "display the full name (first and last), hire date, salary, and department number for those employees whose first name does not containing the letter M and make the result set in ascending order by department number.", "rationale": ["Identify the required fields: full name (first and last), hire date, salary, and department number.", "To get the full name, concatenate FIRST_NAME and LAST_NAME with a space in between.", "Filter employees whose first name does not contain the letter 'M'. This can be done using the NOT LIKE operator with a wildcard.", "Sort the results in ascending order by DEPARTMENT_ID.", "Construct the SQL query using the SELECT statement with the identified fields and conditions."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, HIRE_DATE, SALARY, DEPARTMENT_ID \nFROM employees \nWHERE FIRST_NAME NOT LIKE '%M%' \nORDER BY DEPARTMENT_ID ASC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3442", "db_id": "hr_1", "question": "Which job titles correspond to jobs with salaries over 9000?", "rationale": ["Identify the relevant table: The question pertains to job titles and salaries, so we will focus on the 'jobs' table.", "Determine the condition: We need to find jobs with salaries over 9000, which refers to the 'MAX_SALARY' column in the 'jobs' table.", "Construct the SQL query: We will select the 'JOB_TITLE' from the 'jobs' table where the 'MAX_SALARY' is greater than 9000."], "gold_sql": "SELECT job_title FROM jobs WHERE min_salary  >  9000", "source_tables": ["jobs"], "pred_sql": "SELECT JOB_TITLE FROM jobs WHERE MAX_SALARY > 9000;", "hint": "\n"}
{"sample_id": "train.3444", "db_id": "hr_1", "question": "What are the job titles, and range of salaries for jobs with maximum salary between 12000 and 18000?", "rationale": ["Identify the relevant table: The question asks about job titles and salary ranges, which are found in the 'jobs' table.", "Determine the columns needed: We need 'JOB_TITLE', 'MIN_SALARY', and 'MAX_SALARY' from the 'jobs' table.", "Apply the condition: The question specifies that we are interested in jobs with a maximum salary between 12000 and 18000, so we will use a WHERE clause to filter the results based on 'MAX_SALARY'.", "Construct the SQL query: Combine the SELECT statement with the FROM clause and the WHERE condition to form the complete SQL query."], "gold_sql": "SELECT job_title ,  max_salary - min_salary FROM jobs WHERE max_salary BETWEEN 12000 AND 18000", "source_tables": ["jobs"], "pred_sql": "SELECT JOB_TITLE, MIN_SALARY, MAX_SALARY \nFROM jobs \nWHERE MAX_SALARY BETWEEN 12000 AND 18000;", "hint": "\n"}
{"sample_id": "train.3448", "db_id": "hr_1", "question": "What are the employee ids for each employee and final dates of employment at their last job?", "rationale": ["We need to find the employee IDs and the final dates of employment at their last job.", "The relevant tables are 'employees' and 'job_history'.", "We will join the 'employees' table with the 'job_history' table on the EMPLOYEE_ID.", "To get the final date of employment, we need to find the maximum END_DATE for each employee in the job_history table.", "We can use a subquery to get the maximum END_DATE for each employee and filter the results accordingly."], "gold_sql": "SELECT employee_id ,  MAX(end_date) FROM job_history GROUP BY employee_id", "source_tables": ["job_history"], "pred_sql": "SELECT e.EMPLOYEE_ID, jh.END_DATE\nFROM employees e\nJOIN job_history jh ON e.EMPLOYEE_ID = jh.EMPLOYEE_ID\nWHERE jh.END_DATE = (SELECT MAX(END_DATE) FROM job_history WHERE EMPLOYEE_ID = e.EMPLOYEE_ID)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3451", "db_id": "hr_1", "question": "Find the ids of the departments where any manager is managing 4 or more employees.", "rationale": ["Identify the departments that have managers.", "To find managers who manage 4 or more employees, we need to group employees by their manager_id and count the number of employees for each manager.", "Use the HAVING clause to filter those managers who have 4 or more employees.", "Select the department_id from the departments table where the manager_id is in the list of managers identified in the previous step."], "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"], "pred_sql": "SELECT department_id FROM departments WHERE manager_id IN (SELECT manager_id FROM employees GROUP BY manager_id HAVING COUNT(employee_id) >= 4)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3457", "db_id": "hr_1", "question": "display job ID for those jobs that were done by two or more for more than 300 days.", "rationale": ["We need to find job IDs for jobs that were done by two or more employees for more than 300 days.", "To achieve this, we will use the 'job_history' table which contains records of jobs held by employees along with their start and end dates.", "We will group the results by 'job_id' to aggregate the data for each job.", "We will use the COUNT function to ensure that there are at least two employees for each job.", "We will calculate the total duration of each job by subtracting the start date from the end date using the julianday function, and then sum these durations for each job.", "Finally, we will filter the results using the HAVING clause to only include jobs where the count of employees is 2 or more and the total duration is greater than 300 days."], "gold_sql": "SELECT job_id FROM job_history WHERE end_date - start_date  > 300 GROUP BY job_id HAVING COUNT(*) >= 2", "source_tables": ["job_history"], "pred_sql": "SELECT job_id FROM job_history GROUP BY job_id HAVING COUNT(employee_id) >= 2 AND SUM(julianday(end_date) - julianday(start_date)) > 300;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3458", "db_id": "hr_1", "question": "What are the job ids for jobs done more than once for a period of more than 300 days?", "rationale": ["We need to find job ids for jobs that have been done more than once.", "To do this, we will use the job_history table, which records the job history of employees.", "We will group the results by job_id to count how many times each job has been done.", "We will use the HAVING clause to filter groups where the count of job_id is greater than 1.", "Additionally, we need to check that the total duration of these jobs is more than 300 days.", "To calculate the duration, we will subtract the start_date from the end_date using the julianday function, and sum these durations for each job_id."], "gold_sql": "SELECT job_id FROM job_history WHERE end_date - start_date  > 300 GROUP BY job_id HAVING COUNT(*) >= 2", "source_tables": ["job_history"], "pred_sql": "SELECT job_id FROM job_history GROUP BY job_id HAVING COUNT(*) > 1 AND SUM(julianday(end_date) - julianday(start_date)) > 300;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3463", "db_id": "hr_1", "question": "display the department name and number of employees in each of the department.", "rationale": ["We need to display the department name and the number of employees in each department.", "The relevant tables for this query are 'departments' and 'employees'.", "We will select the 'DEPARTMENT_NAME' from the 'departments' table.", "To count the number of employees in each department, we will use the COUNT function on 'EMPLOYEE_ID' from the 'employees' table.", "We will perform a LEFT JOIN between 'departments' and 'employees' on 'DEPARTMENT_ID' to ensure we include departments even if they have no employees.", "Finally, we will group the results by 'DEPARTMENT_NAME' to get the count of employees per department."], "gold_sql": "SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name", "source_tables": ["employees", "departments"], "pred_sql": "SELECT d.DEPARTMENT_NAME, COUNT(e.EMPLOYEE_ID) AS NUMBER_OF_EMPLOYEES \nFROM departments AS d \nLEFT JOIN employees AS e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID \nGROUP BY d.DEPARTMENT_NAME;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3470", "db_id": "hr_1", "question": "Provide the full names of employees earning more than the employee with id 163.", "rationale": ["We need to find the full names of employees earning more than the employee with ID 163.", "To do this, we first need to retrieve the salary of the employee with ID 163 using a subquery.", "The main query will select the first name and last name of employees from the 'employees' table.", "We will also join the 'departments', 'locations', and 'countries' tables to get the country name associated with each employee's department.", "The join conditions are based on the foreign key relationships defined in the schema.", "Finally, we will filter the results to include only those employees whose salary is greater than the salary retrieved from the subquery."], "gold_sql": "SELECT first_name ,  last_name FROM employees WHERE salary  >  (SELECT salary FROM employees WHERE employee_id = 163 )", "source_tables": ["employees"], "pred_sql": "SELECT T1.first_name, T1.last_name, T4.country_name \nFROM employees AS T1 \nJOIN departments AS T2 ON T1.department_id = T2.department_id \nJOIN locations AS T3 ON T2.location_id = T3.location_id \nJOIN countries AS T4 ON T3.country_id = T4.country_id \nWHERE T1.salary > (SELECT salary FROM employees WHERE employee_id = 163)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3471", "db_id": "hr_1", "question": "return the smallest salary for every departments.", "rationale": ["We need to find the smallest salary for every department.", "To do this, we will use the 'employees' table, which contains salary information and department IDs.", "We will use the MIN() function to get the smallest salary for each department.", "We will group the results by 'department_id' to ensure we get the minimum salary for each department."], "gold_sql": "SELECT MIN(salary) ,  department_id FROM employees GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT department_id, MIN(salary) AS smallest_salary FROM employees GROUP BY department_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3472", "db_id": "hr_1", "question": "What is the minimum salary in each department?", "rationale": ["We need to find the minimum salary in each department.", "To do this, we will select the department ID and the minimum salary from the employees table.", "We will join the employees table with the departments table on the DEPARTMENT_ID to associate employees with their respective departments.", "We will use the MIN() function to calculate the minimum salary for each department.", "Finally, we will group the results by DEPARTMENT_ID to get the minimum salary for each department."], "gold_sql": "SELECT MIN(salary) ,  department_id FROM employees GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT d.DEPARTMENT_ID, MIN(e.SALARY) AS MIN_SALARY\nFROM employees e\nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID\nGROUP BY d.DEPARTMENT_ID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3482", "db_id": "hr_1", "question": "What is all the information regarding employees who are managers?", "rationale": ["Identify the relevant tables: employees, departments, locations, and countries.", "We need to join these tables to get the required information about employees who are managers.", "The hint provides a virtual table that selects first name, last name, employee ID, and country name from the relevant tables.", "To find employees who are managers, we can use a subquery that selects distinct manager IDs from the employees table where manager_id is not null.", "We will filter the main query using this subquery to get only those employees who are managers."], "gold_sql": "SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T1.employee_id  =  T2.manager_id", "source_tables": ["employees", "departments"], "pred_sql": "SELECT T1.first_name, T1.last_name, T1.employee_id, T4.country_name \nFROM employees AS T1 \nJOIN departments AS T2 ON T1.department_id = T2.department_id \nJOIN locations AS T3 ON T2.location_id = T3.location_id \nJOIN countries AS T4 ON T3.country_id = T4.country_id \nWHERE T1.employee_id IN (SELECT DISTINCT manager_id FROM employees WHERE manager_id IS NOT NULL);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3488", "db_id": "hr_1", "question": "Give the distinct department ids of departments in which a manager is in charge of 4 or more employees?", "rationale": ["We need to find distinct department ids where a manager oversees 4 or more employees.", "To do this, we first need to identify managers who have 4 or more employees reporting to them. We can achieve this by grouping the employees by their manager_id and counting the number of employees for each manager.", "Using the HAVING clause, we can filter out those managers who have less than 4 employees.", "Once we have the list of manager_ids that meet this criterion, we can then select the department_ids from the employees table where the manager_id matches any of the identified managers."], "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"], "pred_sql": "SELECT department_id\nFROM employees\nWHERE manager_id IN (\n    SELECT manager_id\n    FROM employees\n    GROUP BY manager_id\n    HAVING COUNT(employee_id) >= 4\n)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3497", "db_id": "hr_1", "question": "Find the ids of the employees who does not work in those departments where some employees works whose manager id within the range 100 and 200.", "rationale": ["Identify the employees who do not work in certain departments.", "We need to find departments where employees have a manager ID in the range of 100 to 200.", "Use a subquery to select distinct department IDs from the employees table where the manager ID is within the specified range.", "The main query will select employee IDs from the employees table where their department ID is not in the list of department IDs returned by the subquery."], "gold_sql": "SELECT * FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN 100 AND 200)", "source_tables": ["employees", "departments"], "pred_sql": "SELECT EMPLOYEE_ID \nFROM employees \nWHERE DEPARTMENT_ID NOT IN (\n    SELECT DISTINCT DEPARTMENT_ID \n    FROM employees \n    WHERE MANAGER_ID BETWEEN '100' AND '200'\n);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3502", "db_id": "hr_1", "question": "What are the full names and hire dates for employees in the same department as someone with the first name Clara, not including Clara?", "rationale": ["Identify the requirement: We need the full names and hire dates of employees in the same department as Clara, excluding Clara herself.", "To get the full names, we will concatenate the first name and last name of the employees.", "We need to find the department ID of the employee named Clara. This requires a subquery that selects the DEPARTMENT_ID from the employees table where the FIRST_NAME is 'Clara'.", "We also need to ensure that we do not include Clara in the results. This can be done by adding a condition to exclude her EMPLOYEE_ID.", "The main query will select the full names and hire dates from the employees table where the DEPARTMENT_ID matches that of Clara's and the EMPLOYEE_ID is not Clara's."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  ( SELECT department_id FROM employees WHERE first_name  =  'Clara') AND first_name != 'Clara'", "source_tables": ["employees"], "pred_sql": "SELECT e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.HIRE_DATE \nFROM employees e \nWHERE e.DEPARTMENT_ID = (SELECT e2.DEPARTMENT_ID \n                         FROM employees e2 \n                         WHERE e2.FIRST_NAME = 'Clara') \nAND e.EMPLOYEE_ID != (SELECT e3.EMPLOYEE_ID \n                     FROM employees e3 \n                     WHERE e3.FIRST_NAME = 'Clara');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3506", "db_id": "hr_1", "question": "What are the ids, full names, and salaries for employees making more than average and who work in a department with employees who have the letter J in their first name?", "rationale": ["Identify the required fields: employee IDs, full names (first and last), and salaries.", "To get the full name, concatenate the first and last names using '||'.", "Filter employees whose salary is greater than the average salary. This requires a subquery to calculate the average salary from the employees table.", "Additionally, filter employees based on their department. We need to find departments that have at least one employee with a first name containing the letter 'J'.", "This requires another subquery that selects distinct department IDs from the employees table where the first name contains 'J'.", "Combine these conditions in the WHERE clause of the main query to get the desired results."], "gold_sql": "SELECT employee_id ,  first_name ,  last_name ,  salary FROM employees WHERE salary  >  ( SELECT AVG (salary) FROM employees ) AND department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE '%J%')", "source_tables": ["employees"], "pred_sql": "SELECT e.EMPLOYEE_ID, e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.SALARY \nFROM employees e \nWHERE e.SALARY > (SELECT AVG(SALARY) FROM employees) \nAND e.DEPARTMENT_ID IN (\n    SELECT DISTINCT d.DEPARTMENT_ID \n    FROM employees emp \n    JOIN departments d ON emp.DEPARTMENT_ID = d.DEPARTMENT_ID \n    WHERE emp.FIRST_NAME LIKE '%J%'\n);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3507", "db_id": "hr_1", "question": "display the employee number and job id for all employees whose salary is smaller than any salary of those employees whose job title is MK_MAN.", "rationale": ["Identify the main requirement: We need to display the employee number (EMPLOYEE_ID) and job id (JOB_ID) for employees whose salary is less than any salary of those employees whose job title is MK_MAN.", "To find the salaries of employees with the job title MK_MAN, we will use a subquery that selects the minimum salary from the employees table joined with the jobs table where the job title is MK_MAN.", "The main query will select EMPLOYEE_ID and JOB_ID from the employees table where the salary is less than the result of the subquery.", "The final SQL query combines these elements to achieve the desired output."], "gold_sql": "SELECT employee_id ,  job_id FROM employees WHERE salary  <  ( SELECT min(salary) FROM employees WHERE job_id  =  'MK_MAN' )", "source_tables": ["employees"], "pred_sql": "SELECT EMPLOYEE_ID, JOB_ID FROM employees WHERE SALARY < (SELECT MIN(SALARY) FROM employees AS e JOIN jobs AS j ON e.JOB_ID = j.JOB_ID WHERE j.JOB_TITLE = 'MK_MAN')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3510", "db_id": "hr_1", "question": "What are the employee ids, full names, and job ids for employees who make more than the highest earning employee with title PU_MAN?", "rationale": ["Identify the columns needed: employee_id, full names (first and last), and job_id.", "To get the full names, concatenate first_name and last_name with a space in between.", "Filter employees based on their salary being greater than the highest salary of employees with the job title 'PU_MAN'.", "Use a subquery to find the maximum salary of employees with the job title 'PU_MAN'.", "The final query selects the required columns from the employees table with the specified conditions."], "gold_sql": "SELECT employee_id ,  first_name ,  last_name ,  job_id FROM employees WHERE salary  >  ( SELECT max(salary) FROM employees WHERE job_id  =  'PU_MAN' )", "source_tables": ["employees"], "pred_sql": "SELECT employee_id, first_name || ' ' || last_name AS full_name, job_id \nFROM employees \nWHERE salary > (SELECT MAX(salary) \n                 FROM employees \n                 WHERE job_id = (SELECT job_id \n                                 FROM jobs \n                                 WHERE job_title = 'PU_MAN'));", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3512", "db_id": "hr_1", "question": "What are total salaries and department id for each department that has more than 2 employees?", "rationale": ["We need to find the total salaries and department IDs for departments with more than 2 employees.", "To do this, we will use the 'employees' table to get employee salaries and the 'departments' table to get department IDs.", "We will join the 'employees' table with the 'departments' table on the DEPARTMENT_ID column.", "Next, we will group the results by DEPARTMENT_ID to calculate the total salary for each department using SUM.", "We will also count the number of employees in each department using COUNT and filter the results using HAVING to include only those departments with more than 2 employees."], "gold_sql": "SELECT department_id ,  SUM(salary) FROM employees GROUP BY department_id HAVING count(*)  >=  2", "source_tables": ["employees"], "pred_sql": "SELECT d.DEPARTMENT_ID, SUM(e.SALARY) AS total_salaries \nFROM employees e \nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nGROUP BY d.DEPARTMENT_ID \nHAVING COUNT(e.EMPLOYEE_ID) > 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3515", "db_id": "hr_1", "question": "display the department ID, full name (first and last name), salary for those employees who is highest salary in every department.", "rationale": ["We need to display the department ID, full name (first and last name), and salary of employees with the highest salary in each department.", "To achieve this, we will first create a subquery that selects the maximum salary for each department by grouping the employees by department_id.", "The subquery will return the department_id and the maximum salary for that department.", "Next, we will join this subquery with the employees table to get the full names of the employees who have the maximum salary in their respective departments.", "We will concatenate the first name and last name to create the full name.", "Finally, we will select the department_id, the concatenated full name, and the salary from the joined tables."], "gold_sql": "SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT e.department_id, e.first_name || ' ' || e.last_name AS full_name, e.salary \nFROM employees e \nJOIN (\n    SELECT department_id, MAX(salary) AS max_salary \n    FROM employees \n    GROUP BY department_id\n) AS max_salaries \nON e.department_id = max_salaries.department_id AND e.salary = max_salaries.max_salary;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3516", "db_id": "hr_1", "question": "What are the department ids, full names, and salaries for employees who make the most in their departments?", "rationale": ["Identify the required fields: department ids, full names, and salaries of employees.", "To get the full names, concatenate the first name and last name of employees.", "Join the 'employees' table with the 'departments' table to get the department ids.", "Use a subquery to find the maximum salary for each department, ensuring we only select employees who earn that maximum salary."], "gold_sql": "SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT e.department_id, e.first_name || ' ' || e.last_name AS full_name, e.salary \nFROM employees e \nJOIN departments d ON e.department_id = d.department_id \nWHERE e.salary = (SELECT MAX(salary) FROM employees WHERE department_id = e.department_id)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3520", "db_id": "hr_1", "question": "What are the full names and cities of employees who have the letter Z in their first names?", "rationale": ["Identify the relevant tables: employees, departments, and locations are needed to get employee names and their corresponding cities.", "We need to select the first name and last name of employees, which can be concatenated to form the full name.", "The city information is required from the locations table.", "To find employees with the letter 'Z' in their first names, we will use the LIKE operator with a wildcard in the WHERE clause.", "Join the employees table with the departments table on department_id, and then join the resulting table with the locations table on location_id to access city information."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T3.city FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id WHERE T1.first_name LIKE '%z%'", "source_tables": ["employees", "departments", "locations"], "pred_sql": "SELECT first_name || ' ' || last_name AS full_name, city FROM employees AS T1 JOIN departments AS T2 ON T1.department_id = T2.department_id JOIN locations AS T3 ON T2.location_id = T3.location_id WHERE first_name LIKE '%Z%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3523", "db_id": "hr_1", "question": "display the full name (first and last name ) of employee with ID and name of the country presently where (s)he is working.", "rationale": ["Identify the tables needed: employees, departments, locations, and countries.", "Join the employees table with departments to get department information.", "Join the departments table with locations to get location information.", "Join the locations table with countries to get country information.", "Select the first name and last name from the employees table and the country name from the countries table.", "Add a WHERE clause to filter the results for a specific employee ID."], "gold_sql": "SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id", "source_tables": ["countries", "employees", "departments", "locations"], "pred_sql": "SELECT T1.first_name, T1.last_name, T4.country_name \nFROM employees AS T1 \nJOIN departments AS T2 ON T1.department_id = T2.department_id \nJOIN locations AS T3 ON T2.location_id = T3.location_id \nJOIN countries AS T4 ON T3.country_id = T4.country_id \nWHERE T1.employee_id = ?", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3525", "db_id": "hr_1", "question": "display the department name and number of employees in each of the department.", "rationale": ["We need to display the department name and the number of employees in each department.", "To get the department name, we will select it from the 'departments' table.", "To count the number of employees in each department, we will use the 'employees' table and count the 'EMPLOYEE_ID'.", "We will perform a LEFT JOIN between the 'departments' table and the 'employees' table on the 'DEPARTMENT_ID' to ensure we get all departments even if they have no employees.", "Finally, we will group the results by 'DEPARTMENT_NAME' to get the count of employees for each department."], "gold_sql": "SELECT department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY department_name", "source_tables": ["employees", "departments"], "pred_sql": "SELECT d.DEPARTMENT_NAME, COUNT(e.EMPLOYEE_ID) AS NUMBER_OF_EMPLOYEES \nFROM departments AS d \nLEFT JOIN employees AS e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID \nGROUP BY d.DEPARTMENT_NAME;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3526", "db_id": "hr_1", "question": "What are the department names and how many employees work in each of them?", "rationale": ["We need to retrieve the department names and the count of employees in each department.", "The relevant tables for this query are 'departments' and 'employees'.", "We will perform a LEFT JOIN between 'departments' and 'employees' on the 'DEPARTMENT_ID' to ensure we get all departments even if they have no employees.", "We will use the COUNT function to count the number of employees in each department.", "Finally, we will group the results by 'DEPARTMENT_NAME' to get the count for each department."], "gold_sql": "SELECT department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY department_name", "source_tables": ["employees", "departments"], "pred_sql": "SELECT d.DEPARTMENT_NAME, COUNT(e.EMPLOYEE_ID) AS EMPLOYEE_COUNT \nFROM departments AS d \nLEFT JOIN employees AS e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID \nGROUP BY d.DEPARTMENT_NAME;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3528", "db_id": "hr_1", "question": "What are full names and salaries of employees working in the city of London?", "rationale": ["Identify the required information: full names (first and last names) and salaries of employees.", "Determine the relevant tables: 'employees' for employee details, 'departments' for department information, and 'locations' for city details.", "Join the 'employees' table with the 'departments' table on 'department_id' to link employees to their respective departments.", "Join the resulting table with the 'locations' table on 'location_id' to filter by city.", "Use a WHERE clause to specify that the city must be 'London'.", "Select the first name, last name, and salary from the final joined table."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  'London'", "source_tables": ["employees", "departments", "locations"], "pred_sql": "SELECT first_name, last_name, salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id = T2.department_id JOIN locations AS T3 ON T2.location_id = T3.location_id WHERE T3.city = 'London'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3641", "db_id": "baseball_1", "question": "In 2014, what are the id and rank of the team that has the largest average number of attendance?", "rationale": ["Identify the relevant table: The 'home_game' table contains the attendance data for teams in different years.", "Filter for the year 2014: We need to focus on the records from the year 2014.", "Order by attendance: To find the team with the largest average attendance, we will order the results by the 'attendance' column in descending order.", "Select the team_id and rank: We need to retrieve the 'team_id' and 'rank' of the team with the highest attendance.", "Limit the results to 1: Since we only want the team with the largest attendance, we will limit the results to 1."], "gold_sql": "SELECT T2.team_id ,  T2.rank FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id WHERE T1.year  =  2014 GROUP BY T1.team_id ORDER BY avg(T1.attendance) DESC LIMIT 1;", "source_tables": ["team", "home_game"], "pred_sql": "SELECT team_id, rank FROM home_game WHERE year = 2014 ORDER BY attendance DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3647", "db_id": "baseball_1", "question": "Which 3 players won the most player awards? List their full name and id.", "rationale": ["We need to find the players who won the most player awards.", "The relevant table for player awards is 'player_award', which contains the player_id and award_id.", "We will join the 'player_award' table with the 'player' table to get the full names of the players.", "We will group the results by player_id to count the number of awards each player has won.", "We will order the results in descending order based on the count of awards to get the top players.", "Finally, we will limit the results to the top 3 players."], "gold_sql": "SELECT T1.name_first ,  T1.name_last ,  T1.player_id FROM player AS T1 JOIN player_award AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.player_id ORDER BY count(*) DESC LIMIT 3;", "source_tables": ["player_award", "player"], "pred_sql": "SELECT T2.name_first, T2.name_last, T2.player_id \nFROM player_award AS T1 \nJOIN player AS T2 ON T1.player_id = T2.player_id \nGROUP BY T2.player_id \nORDER BY COUNT(T1.award_id) DESC \nLIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3649", "db_id": "baseball_1", "question": "List three countries which are the origins of the least players.", "rationale": ["We need to find the countries with the least number of players.", "The relevant table for player information is the 'player' table, which includes the 'birth_country' column.", "We will count the number of players from each country using COUNT(player_id) and group the results by 'birth_country'.", "To get the countries with the least players, we will order the results in ascending order based on the count of players.", "Finally, we will limit the results to the top 3 countries with the least players."], "gold_sql": "SELECT birth_country FROM player GROUP BY birth_country ORDER BY count(*) ASC LIMIT 3;", "source_tables": ["player"], "pred_sql": "SELECT birth_country, COUNT(player_id) AS player_count \nFROM player \nGROUP BY birth_country \nORDER BY player_count ASC \nLIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3650", "db_id": "baseball_1", "question": "What are the three countries that the least players are from?", "rationale": ["Identify the relevant table: The 'player' table contains information about players, including their birth countries.", "Select the 'birth_country' column and count the number of players from each country using COUNT(player_id).", "Group the results by 'birth_country' to aggregate the player counts for each country.", "Order the results in ascending order based on the player count to find the countries with the least players.", "Limit the results to the top 3 countries with the least players."], "gold_sql": "SELECT birth_country FROM player GROUP BY birth_country ORDER BY count(*) ASC LIMIT 3;", "source_tables": ["player"], "pred_sql": "SELECT birth_country, COUNT(player_id) AS player_count\nFROM player\nGROUP BY birth_country\nORDER BY player_count ASC\nLIMIT 3;", "hint": "\n"}
{"sample_id": "train.3651", "db_id": "baseball_1", "question": "Find all the players' first name and last name who have empty death record.", "rationale": ["Identify the relevant table: The 'player' table contains the first and last names of players as well as their death records.", "Determine the condition for empty death records: A player has an empty death record if the 'death_year', 'death_month', and 'death_day' fields are all NULL.", "Construct the SQL query: Use a SELECT statement to retrieve 'name_first' and 'name_last' from the 'player' table where the death fields are NULL."], "gold_sql": "SELECT name_first ,  name_last FROM player WHERE death_year = '';", "source_tables": ["player"], "pred_sql": "SELECT name_first, name_last FROM player WHERE death_year IS NULL AND death_month IS NULL AND death_day IS NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3657", "db_id": "baseball_1", "question": "What is the highest salary among each team? List the team name, id and maximum salary.", "rationale": ["We need to find the highest salary for each team, which requires joining the salary table with the team table.", "The salary table contains the salary records, and the team table contains the team names and IDs.", "We will use a GROUP BY clause to group the results by team ID and name, allowing us to calculate the maximum salary for each team.", "The SQL query will select the team name, team ID, and the maximum salary using the MAX() function."], "gold_sql": "SELECT T1.name ,  T1.team_id ,  max(T2.salary) FROM team AS T1 JOIN salary AS T2 ON T1.team_id  =  T2.team_id GROUP BY T1.team_id;", "source_tables": ["team", "salary"], "pred_sql": "SELECT T3.name, T3.team_id, MAX(T1.salary) AS max_salary \nFROM salary AS T1 \nJOIN team AS T3 ON T1.team_id = T3.team_id \nGROUP BY T3.team_id, T3.name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3662", "db_id": "baseball_1", "question": "Which players won awards in both 1960 and 1961? Return their first names and last names.", "rationale": ["Identify the relevant table for player awards, which is 'player_award'.", "We need to find players who won awards in both 1960 and 1961, so we will filter the records by year using a WHERE clause.", "To ensure that we only get players who won awards in both years, we will group the results by 'player_id' and use HAVING to count distinct years, ensuring it equals 2 (for both 1960 and 1961).", "Finally, we will select the first and last names of these players from the 'player' table, joining it with 'player_award' on 'player_id' to get the names."], "gold_sql": "SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1960 INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1961", "source_tables": ["player_award", "player"], "pred_sql": "SELECT T1.name_first, T1.name_last \nFROM player_award AS T1 \nWHERE T1.year IN (1960, 1961) \nGROUP BY T1.player_id \nHAVING COUNT(DISTINCT T1.year) = 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3665", "db_id": "baseball_1", "question": "List the maximum scores of the team Boston Red Stockings when the team won in postseason?", "rationale": ["Identify the relevant tables: We need to look at the 'postseason' table for postseason results and the 'team' table for team information.", "Filter for the team: We will filter the 'team' table to find the 'Boston Red Stockings'.", "Join the tables: We will join the 'postseason' table with the 'team' table on the winning team ID.", "Select the maximum score: We will select the maximum wins from the 'postseason' table for the 'Boston Red Stockings'."], "gold_sql": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings';", "source_tables": ["postseason", "team"], "pred_sql": "SELECT MAX(p.wins) FROM postseason AS p JOIN team AS t ON p.team_id_winner = t.team_id WHERE t.name = 'Boston Red Stockings'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3666", "db_id": "baseball_1", "question": "What are the maximum scores the team Boston Red Stockings got when the team won in postseason?", "rationale": ["Identify the relevant tables: We need to look at the 'postseason' table to find the winning scores and the 'team' table to filter by the team name.", "Join the 'postseason' table with the 'team' table on the winning team ID to get the team name.", "Filter the results to only include the 'Boston Red Stockings'.", "Use the MAX function to get the maximum scores (wins) for the specified team."], "gold_sql": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings';", "source_tables": ["postseason", "team"], "pred_sql": "SELECT MAX(p.wins) FROM postseason AS p JOIN team AS t ON p.team_id_winner = t.team_id WHERE t.name = 'Boston Red Stockings'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3669", "db_id": "baseball_1", "question": "What are the name and id of the team with the most victories in 2008 postseason?", "rationale": ["Identify the relevant tables: postseason and team.", "We need to find the team with the most victories in the 2008 postseason, so we will focus on the postseason table to get the winning team.", "Join the postseason table with the team table using the winning team identifier (team_id_winner).", "Filter the results to only include records from the year 2008.", "Order the results by the number of wins in descending order to get the team with the most victories at the top.", "Limit the results to 1 to get only the top team."], "gold_sql": "SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  2008 GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["postseason", "team"], "pred_sql": "SELECT team.name, team.team_id FROM postseason JOIN team ON postseason.team_id_winner = team.team_id WHERE postseason.year = 2008 ORDER BY postseason.wins DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3673", "db_id": "baseball_1", "question": "What is the total number of postseason games that team Boston Red Stockings participated in?", "rationale": ["Identify the relevant table for postseason games, which is 'batting_postseason'.", "Determine the column that represents the total games played in postseason, which is 'g'.", "To find the total number of postseason games for the Boston Red Stockings, we need to filter the records by the team name.", "Use a subquery to get the 'team_id' for 'Boston Red Stockings' from the 'team' table.", "Sum the 'g' column for the filtered records to get the total number of postseason games."], "gold_sql": "SELECT count(*) FROM ( SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' UNION SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' );", "source_tables": ["postseason", "team"], "pred_sql": "SELECT SUM(g) AS total_postseason_games \nFROM batting_postseason \nWHERE team_id = (SELECT team_id FROM team WHERE name = 'Boston Red Stockings')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3678", "db_id": "baseball_1", "question": "What is the total salary expenses of team Boston Red Stockings in 2010?", "rationale": ["Identify the relevant tables: salary and team.", "We need to sum the salary expenses for a specific team in a specific year.", "Join the salary table with the team table on team_id to filter by team name.", "Use a WHERE clause to specify the year (2010) and the team name ('Boston Red Stockings').", "Select the sum of the salary column to get the total salary expenses."], "gold_sql": "SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings' AND T1.year  =  2010", "source_tables": ["team", "salary"], "pred_sql": "SELECT SUM(salary) AS total_salary_expenses \nFROM salary AS T1 \nJOIN team AS T2 ON T1.team_id = T2.team_id \nWHERE T1.year = 2010 AND T2.name = 'Boston Red Stockings';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3679", "db_id": "baseball_1", "question": "How many players were in the team Boston Red Stockings in 2000?", "rationale": ["Identify the relevant tables: salary, player, and team.", "We need to count the number of players in the team 'Boston Red Stockings' for the year 2000.", "Join the salary table with the player table to get player details, and then join with the team table to filter by team name.", "Use the COUNT function to count the number of players that meet the criteria."], "gold_sql": "SELECT count(*) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings' AND T1.year  =  2000", "source_tables": ["team", "salary"], "pred_sql": "SELECT COUNT(*) FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2000 AND T3.name = 'Boston Red Stockings'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3681", "db_id": "baseball_1", "question": "List the 3 highest salaries of the players in 2001?", "rationale": ["Identify the relevant tables: We need the 'salary' table to get salary information and the 'player' table to get player names.", "Join the 'salary' table with the 'player' table on 'player_id' to access player names along with their salaries.", "Filter the results to only include records from the year 2001 by adding a WHERE clause for T1.year = 2001.", "Order the results by salary in descending order to get the highest salaries first.", "Limit the results to the top 3 entries to get the three highest salaries."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2001 ORDER BY salary DESC LIMIT 3;", "source_tables": ["salary"], "pred_sql": "SELECT T2.name_first, T2.name_last, T1.salary FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id WHERE T1.year = 2001 ORDER BY T1.salary DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3684", "db_id": "baseball_1", "question": "List all the salary values players received in 2010 and 2001.", "rationale": ["Identify the relevant table for salary records, which is the 'salary' table.", "Determine the years of interest, which are 2010 and 2001.", "Construct a SQL query to select the 'salary' column from the 'salary' table where the 'year' is either 2010 or 2001 using the IN clause."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2010 UNION SELECT salary FROM salary WHERE YEAR  =  2001", "source_tables": ["salary"], "pred_sql": "SELECT salary FROM salary WHERE year IN (2010, 2001);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3685", "db_id": "baseball_1", "question": "In which year did the least people enter hall of fame?", "rationale": ["Identify the relevant table: The 'hall_of_fame' table contains information about players inducted into the Hall of Fame, including the year of induction.", "Count the number of players inducted each year: Use the COUNT function to count the number of entries for each year in the 'hall_of_fame' table.", "Group the results by year: Use GROUP BY to aggregate the counts by the 'yearid' column.", "Order the results to find the year with the least inductees: Use ORDER BY to sort the counts in ascending order.", "Limit the results to the top entry: Use LIMIT 1 to get only the year with the least number of inductees."], "gold_sql": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT 1;", "source_tables": ["hall_of_fame"], "pred_sql": "SELECT yearid, COUNT(*) as num_inducted FROM hall_of_fame GROUP BY yearid ORDER BY num_inducted ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3686", "db_id": "baseball_1", "question": "Find the year in which the least people enter hall of fame.", "rationale": ["To find the year in which the least number of players were inducted into the Hall of Fame, we need to count the number of players inducted for each year.", "The 'hall_of_fame' table contains the 'yearid' column which indicates the year of induction and the 'player_id' which identifies the players.", "We will use the COUNT function to count the number of players for each year and group the results by 'yearid'.", "To find the year with the least number of inductees, we will order the results in ascending order based on the count and limit the results to 1 to get the year with the least inductees."], "gold_sql": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT 1;", "source_tables": ["hall_of_fame"], "pred_sql": "SELECT yearid, COUNT(*) as num_inducted FROM hall_of_fame GROUP BY yearid ORDER BY num_inducted ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3689", "db_id": "baseball_1", "question": "How many games were played in park \"Columbia Park\" in 1907?", "rationale": ["Identify the relevant tables: 'home_game' for games played and 'park' for park details.", "We need to sum the total games played in a specific park and year, so we will use the SUM function on the 'games' column from the 'home_game' table.", "Join the 'home_game' table with the 'park' table on the 'park_id' to access the park name.", "Filter the results to only include records where the park name is 'Columbia Park' and the year is 1907."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 1907 AND T2.park_name = 'Columbia Park';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(games) AS total_games\nFROM home_game\nJOIN park ON home_game.park_id = park.park_id\nWHERE park.park_name = 'Columbia Park' AND home_game.year = 1907;", "hint": "\n"}
{"sample_id": "train.3690", "db_id": "baseball_1", "question": "Count the number of games taken place in park \"Columbia Park\" in 1907.", "rationale": ["Identify the relevant tables: 'home_game' for game statistics and 'park' for park details.", "We need to count the total number of games, so we will use the SUM function on the 'games' column from the 'home_game' table.", "To filter the results for 'Columbia Park', we will join the 'home_game' table with the 'park' table on the 'park_id' column.", "We will also filter the results for the year 1907 using a WHERE clause.", "The final query will select the sum of games from the joined tables with the specified conditions."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 1907 AND T2.park_name = 'Columbia Park';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(games) AS total_games\nFROM home_game\nJOIN park ON home_game.park_id = park.park_id\nWHERE park.park_name = 'Columbia Park' AND home_game.year = 1907;", "hint": "\n"}
{"sample_id": "train.3691", "db_id": "baseball_1", "question": "How many games were played in city Atlanta in 2000?", "rationale": ["Identify the relevant table: The 'home_game' table contains information about games played, including the year and city.", "Determine the columns needed: We need to sum the 'games' column to get the total number of games played.", "Apply the conditions: We need to filter the results for the year 2000 and the city of Atlanta.", "Construct the SQL query: Use the SUM function to aggregate the total games played in Atlanta for the specified year."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year  =  2000 AND T2.city  =  'Atlanta';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(games) AS total_games\nFROM home_game\nWHERE city = 'Atlanta' AND year = 2000;", "hint": "\n"}
{"sample_id": "train.3692", "db_id": "baseball_1", "question": "Find the number of games taken place in city Atlanta in 2000.", "rationale": ["Identify the relevant tables: 'home_game' for game statistics and 'park' for location details.", "We need to find the total number of games played in Atlanta in the year 2000.", "Join the 'home_game' table with the 'park' table on the park_id to access city information.", "Filter the results to include only those games that took place in Atlanta and in the year 2000.", "Use the SUM function to calculate the total number of games from the filtered results."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year  =  2000 AND T2.city  =  'Atlanta';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(games) AS total_games\nFROM home_game\nJOIN park ON home_game.park_id = park.park_id\nWHERE park.city = 'Atlanta' AND home_game.year = 2000;", "hint": "\n"}
{"sample_id": "train.3697", "db_id": "baseball_1", "question": "List players' first name and last name who received salary from team Washington Nationals in both 2005 and 2007.", "rationale": ["Identify the relevant tables: salary, player, and team.", "We need to join the salary table with the player table to get the first and last names of the players.", "We also need to join the salary table with the team table to filter by the team name 'Washington Nationals'.", "We will filter the records for the years 2005 and 2007 separately and then use INTERSECT to find players who appear in both years.", "Construct the SQL query using the identified tables and conditions."], "gold_sql": "SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2005 AND T3.name = 'Washington Nationals' INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2007 AND T3.name = 'Washington Nationals'", "source_tables": ["team", "player", "salary"], "pred_sql": "SELECT T2.name_first, T2.name_last \nFROM salary AS T1 \nJOIN player AS T2 ON T1.player_id = T2.player_id \nJOIN team AS T3 ON T3.team_id_br = T1.team_id \nWHERE T1.year = 2005 AND T3.name = 'Washington Nationals' \nINTERSECT \nSELECT T2.name_first, T2.name_last \nFROM salary AS T1 \nJOIN player AS T2 ON T1.player_id = T2.player_id \nJOIN team AS T3 ON T3.team_id_br = T1.team_id \nWHERE T1.year = 2007 AND T3.name = 'Washington Nationals'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3699", "db_id": "baseball_1", "question": "How many home games did the team Boston Red Stockings play from 1990 to 2000 in total?", "rationale": ["Identify the relevant table for home games, which is 'home_game'.", "Determine the columns needed: 'games' for total home games and 'year' for the specified range.", "Use a subquery to find the 'team_id' for 'Boston Red Stockings' from the 'team' table.", "Filter the results to include only the years from 1990 to 2000 using a WHERE clause.", "Sum the 'games' column to get the total number of home games played by the team in the specified years."], "gold_sql": "SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = 'Boston Red Stockings' AND T1.year BETWEEN 1990 AND 2000;", "source_tables": ["team", "home_game"], "pred_sql": "SELECT SUM(games) AS total_home_games \nFROM home_game \nWHERE team_id = (SELECT team_id FROM team WHERE name = 'Boston Red Stockings') \nAND year BETWEEN 1990 AND 2000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3702", "db_id": "baseball_1", "question": "Find the team that attended the least number of home games in 1980.", "rationale": ["Identify the relevant table: The 'home_game' table contains information about home games played by teams, including the year and the number of games.", "Filter for the year 1980: We need to focus on records from the year 1980.", "Group by team_id: To find the total number of home games for each team, we will group the results by 'team_id'.", "Select the minimum number of games: We want to find the team with the least number of home games, so we will use the MIN() function on the 'games' column.", "Order the results: We will order the results in ascending order to get the team with the least number of home games at the top.", "Limit the results: Since we only want the team with the least number of home games, we will limit the results to 1."], "gold_sql": "SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = 1980 ORDER BY T1.attendance ASC LIMIT 1;", "source_tables": ["team", "home_game"], "pred_sql": "SELECT team_id, MIN(games) AS min_home_games FROM home_game WHERE year = 1980 GROUP BY team_id ORDER BY min_home_games ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3710", "db_id": "baseball_1", "question": "Which park did the most people attend in 2008?", "rationale": ["Identify the relevant tables: 'home_game' for attendance data and 'park' for park names.", "We need to find the park with the highest attendance in the year 2008.", "Join the 'home_game' table with the 'park' table on the 'park_id' to get park names along with attendance.", "Filter the results to only include records from the year 2008.", "Order the results by attendance in descending order to get the park with the highest attendance at the top.", "Limit the results to 1 to get only the park with the most attendance."], "gold_sql": "SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 2008 ORDER BY T1.attendance DESC LIMIT 1;", "source_tables": ["park", "home_game"], "pred_sql": "SELECT park.park_name, home_game.attendance \nFROM home_game \nJOIN park ON home_game.park_id = park.park_id \nWHERE home_game.year = 2008 \nORDER BY home_game.attendance DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3898", "db_id": "hospital_1", "question": "Which department has the largest number of employees?", "rationale": ["Identify the relevant tables: Department and Physician.", "We need to count the number of employees in each department, which includes the head of the department (who is a physician).", "Use a LEFT JOIN to connect the Department table with the Physician table on the Head column.", "Group the results by department name to count the number of employees in each department.", "Order the results by the count of employees in descending order to find the department with the largest number of employees.", "Limit the results to 1 to get only the department with the largest number of employees."], "gold_sql": "SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT 1;", "source_tables": ["department"], "pred_sql": "SELECT d.Name, COUNT(p.EmployeeID) AS EmployeeCount\nFROM Department d\nLEFT JOIN Physician p ON d.Head = p.EmployeeID\nGROUP BY d.Name\nORDER BY EmployeeCount DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3899", "db_id": "hospital_1", "question": "Find the department with the most employees.", "rationale": ["To find the department with the most employees, we need to count the number of physicians affiliated with each department.", "We will join the Department table with the Affiliated_With table on the DepartmentID to get the list of physicians in each department.", "We will use the COUNT function to count the number of physicians for each department.", "We will group the results by the department name to get the count for each department.", "To find the department with the most employees, we will order the results by the count of employees in descending order.", "Finally, we will limit the results to 1 to get only the department with the highest count."], "gold_sql": "SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT 1;", "source_tables": ["department"], "pred_sql": "SELECT Department.Name, COUNT(Affiliated_With.Physician) AS EmployeeCount\nFROM Department\nJOIN Affiliated_With ON Department.DepartmentID = Affiliated_With.Department\nGROUP BY Department.Name\nORDER BY EmployeeCount DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3902", "db_id": "hospital_1", "question": "what is the name and position of the head whose department has least number of employees?", "rationale": ["Identify the head of each department by joining the Physician and Department tables on the Head column.", "To find the department with the least number of employees, we need to count the number of physicians affiliated with each department using the Affiliated_With table.", "Group the results by department and order them by the count of physicians in ascending order to find the department with the least number of employees.", "Use a subquery to get the DepartmentID of the department with the least number of employees.", "Finally, select the Name and Position of the physician who is the head of that department."], "gold_sql": "SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["physician", "department"], "pred_sql": "SELECT Physician.Name, Physician.Position \nFROM Physician \nJOIN Department ON Physician.EmployeeID = Department.Head \nWHERE Department.DepartmentID = \n  (SELECT Affiliated_With.Department \n   FROM Affiliated_With \n   GROUP BY Affiliated_With.Department \n   ORDER BY COUNT(Affiliated_With.Physician) ASC \n   LIMIT 1);", "hint": "\n"}
{"sample_id": "train.3904", "db_id": "hospital_1", "question": "What are names of patients who made an appointment?", "rationale": ["We need to find the names of patients who made an appointment.", "The relevant tables are 'Patient' and 'Appointment'.", "We will join these two tables on the common column, which is 'Patient.SSN' in the Patient table and 'Appointment.Patient' in the Appointment table.", "We will select the distinct names from the Patient table to avoid duplicates."], "gold_sql": "SELECT name FROM appointment AS T1 JOIN patient AS T2 ON T1.patient  =  T2.ssn", "source_tables": ["patient", "appointment"], "pred_sql": "SELECT DISTINCT P.Name \nFROM Patient AS P \nJOIN Appointment AS A ON P.SSN = A.Patient;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct names of physicians who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3905", "db_id": "hospital_1", "question": "List the names of patients who have made appointments.", "rationale": ["Identify the relevant tables: Patient and Appointment.", "Determine the relationship between patients and appointments: The Patient table contains patient information, and the Appointment table links patients to their appointments via the Patient.SSN column.", "Use a JOIN to connect the Patient table with the Appointment table on the Patient.SSN = Appointment.Patient condition.", "Select the distinct names of patients from the resulting joined table to avoid duplicates."], "gold_sql": "SELECT name FROM appointment AS T1 JOIN patient AS T2 ON T1.patient  =  T2.ssn", "source_tables": ["patient", "appointment"], "pred_sql": "SELECT DISTINCT Patient.Name FROM Patient JOIN Appointment ON Patient.SSN = Appointment.Patient;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct names of physicians who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3914", "db_id": "hospital_1", "question": "Find the names of all physicians and their primary affiliated departments' names.", "rationale": ["Identify the tables needed: Physician, Department, and Affiliated_With.", "We need to get the names of physicians and their affiliated departments, so we will join the Physician table with the Affiliated_With table on the EmployeeID and Physician columns respectively.", "Next, we will join the Department table with the Affiliated_With table on the DepartmentID and Department columns respectively.", "To ensure we are only getting the primary affiliations, we will add a WHERE clause to filter for primary affiliations."], "gold_sql": "SELECT T1.name ,  T3.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T2.PrimaryAffiliation  =  1", "source_tables": ["physician", "department", "affiliated_with"], "pred_sql": "SELECT Physician.Name, Department.Name \nFROM Physician \nJOIN Affiliated_With ON Physician.EmployeeID = Affiliated_With.Physician \nJOIN Department ON Affiliated_With.Department = Department.DepartmentID \nWHERE Affiliated_With.PrimaryAffiliation = 'Yes';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct names of physicians who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3915", "db_id": "hospital_1", "question": "What are the name and primarily affiliated department name of each physician?", "rationale": ["Identify the relevant tables: Physician, Department, and Affiliated_With.", "We need to retrieve the names of physicians and their primarily affiliated department names.", "Join the Physician table with the Affiliated_With table on the EmployeeID and Physician columns respectively.", "Join the resulting table with the Department table on the DepartmentID.", "Select the Name from Physician and Name from Department where the PrimaryAffiliation is marked as 'Yes'."], "gold_sql": "SELECT T1.name ,  T3.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T2.PrimaryAffiliation  =  1", "source_tables": ["physician", "department", "affiliated_with"], "pred_sql": "SELECT Physician.Name, Department.Name \nFROM Physician \nJOIN Affiliated_With ON Physician.EmployeeID = Affiliated_With.Physician \nJOIN Department ON Affiliated_With.Department = Department.DepartmentID \nWHERE Affiliated_With.PrimaryAffiliation = 'Yes';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct names of physicians who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3929", "db_id": "hospital_1", "question": "Return the name of each physician and the number of patients he or she treats.", "rationale": ["We need to return the names of physicians and the number of patients they treat.", "To get the names of physicians, we will select from the Physician table.", "To count the number of patients treated by each physician, we will join the Prescribes table, which links physicians to patients through their prescriptions.", "We will also join the Patient table to ensure we have access to the patient identifiers (SSN).", "We will use a LEFT JOIN to include physicians who may not have treated any patients, ensuring they still appear in the results with a count of zero.", "Finally, we will group the results by physician name to get the count of patients for each physician."], "gold_sql": "SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid", "source_tables": ["physician", "patient"], "pred_sql": "SELECT Physician.Name, COUNT(Patient.SSN) AS NumberOfPatients\nFROM Physician\nLEFT JOIN Prescribes ON Physician.EmployeeID = Prescribes.Physician\nLEFT JOIN Patient ON Prescribes.Patient = Patient.SSN\nGROUP BY Physician.Name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct names of physicians who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3930", "db_id": "hospital_1", "question": "Find the name of physicians who are in charge of more than one patient.", "rationale": ["We need to find physicians who are in charge of more than one patient.", "To do this, we will join the Physician table with the Prescribes table on the physician's identifier.", "We will group the results by the physician's EmployeeID to aggregate the data for each physician.", "Using the HAVING clause, we will filter the groups to only include those where the count of distinct patients is greater than one."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  1", "source_tables": ["physician", "patient"], "pred_sql": "SELECT P.Name\nFROM Physician P\nJOIN Prescribes Pr ON P.EmployeeID = Pr.Physician\nGROUP BY P.EmployeeID\nHAVING COUNT(DISTINCT Pr.Patient) > 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct names of physicians who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3931", "db_id": "hospital_1", "question": "Which physicians are in charge of more than one patient? Give me their names.", "rationale": ["Identify the relevant tables: Physician and Prescribes.", "We need to find physicians who have prescribed medications to patients.", "Join the Physician table with the Prescribes table on the physician's identifier (EmployeeID).", "Group the results by the physician's EmployeeID to aggregate the data.", "Use the COUNT function to count distinct patients for each physician.", "Filter the results using HAVING to only include physicians with more than one distinct patient."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  1", "source_tables": ["physician", "patient"], "pred_sql": "SELECT P.Name \nFROM Physician P \nJOIN Prescribes PR ON P.EmployeeID = PR.Physician \nGROUP BY P.EmployeeID \nHAVING COUNT(DISTINCT PR.Patient) > 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct names of physicians who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3934", "db_id": "hospital_1", "question": "Find the number of rooms for different block code?", "rationale": ["Identify the relevant table: The Room table contains information about rooms and their block codes.", "Determine the required information: We need to count the number of rooms for each block code.", "Use the COUNT() function to count the rooms and GROUP BY BlockCode to get the count for each unique block code.", "Construct the SQL query to select the BlockCode and the count of RoomNumber, grouping by BlockCode."], "gold_sql": "SELECT count(*) ,  T1.blockcode FROM BLOCK AS T1 JOIN room AS T2 ON T1.blockfloor  =  T2.blockfloor AND T1.blockcode  =  T2.blockcode GROUP BY T1.blockcode", "source_tables": ["block", "room"], "pred_sql": "SELECT BlockCode, COUNT(RoomNumber) AS NumberOfRooms\nFROM Room\nGROUP BY BlockCode;", "hint": "\n"}
{"sample_id": "train.3944", "db_id": "hospital_1", "question": "Find the number of medications prescribed for each brand.", "rationale": ["Identify the tables involved: Medication and Prescribes.", "We need to count the number of prescriptions for each brand of medication.", "Join the Medication table with the Prescribes table on the medication code.", "Group the results by the Brand column to get the count for each brand.", "Select the Brand and the count of prescriptions as NumberOfPrescriptions."], "gold_sql": "SELECT count(*) ,  T1.name FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand", "source_tables": ["prescribes", "medication"], "pred_sql": "SELECT Brand, COUNT(*) AS NumberOfPrescriptions \nFROM Medication AS M \nJOIN Prescribes AS P ON M.Code = P.Medication \nGROUP BY Brand;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct names of physicians who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3959", "db_id": "hospital_1", "question": "Find the physician who prescribed the highest dose. What is his or her name?", "rationale": ["Identify the relevant tables: Physician and Prescribes.", "Join the Physician table with the Prescribes table on the EmployeeID and Physician identifiers respectively.", "Order the results by the Dose in descending order to find the highest dose prescribed.", "Limit the results to 1 to get the physician who prescribed the highest dose."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT 1", "source_tables": ["physician", "prescribes"], "pred_sql": "SELECT P.Name\nFROM Physician P\nJOIN Prescribes Pr ON P.EmployeeID = Pr.Physician\nORDER BY Pr.Dose DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct names of physicians who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3960", "db_id": "hospital_1", "question": "List the physicians' employee ids together with their primary affiliation departments' ids.", "rationale": ["Identify the relevant tables: Physician and Affiliated_With.", "We need to select the EmployeeID from the Physician table and the Department from the Affiliated_With table.", "Join the Physician table with the Affiliated_With table on the EmployeeID and Physician columns respectively.", "Filter the results to only include primary affiliations, which can be indicated by a specific value in the PrimaryAffiliation column (assuming 'Yes' indicates primary)."], "gold_sql": "SELECT physician ,  department FROM affiliated_with WHERE primaryaffiliation  =  1", "source_tables": ["affiliated_with"], "pred_sql": "SELECT Physician.EmployeeID, Affiliated_With.Department FROM Physician JOIN Affiliated_With ON Physician.EmployeeID = Affiliated_With.Physician WHERE Affiliated_With.PrimaryAffiliation = 'Yes';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct names of physicians who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3961", "db_id": "hospital_1", "question": "What are each physician's employee id and department id primarily affiliated.", "rationale": ["Identify the required columns: EmployeeID from Physician and Department from Affiliated_With.", "Determine the relationship between the tables: Physician is linked to Affiliated_With through the EmployeeID and Physician columns.", "Filter the results to only include primary affiliations by checking the PrimaryAffiliation column in Affiliated_With.", "Construct the SQL query using JOIN to combine the relevant tables and SELECT to retrieve the desired columns."], "gold_sql": "SELECT physician ,  department FROM affiliated_with WHERE primaryaffiliation  =  1", "source_tables": ["affiliated_with"], "pred_sql": "SELECT Physician.EmployeeID, Affiliated_With.Department FROM Physician JOIN Affiliated_With ON Physician.EmployeeID = Affiliated_With.Physician WHERE Affiliated_With.PrimaryAffiliation = 'Yes';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct names of physicians who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3970", "db_id": "hospital_1", "question": "Find the three most expensive procedures.", "rationale": ["Identify the table that contains the procedures and their costs, which is the Procedures table.", "To find the most expensive procedures, we need to sort the procedures by their cost in descending order.", "We will limit the results to the top three entries to get the three most expensive procedures."], "gold_sql": "SELECT name FROM procedures ORDER BY cost LIMIT 3", "source_tables": ["procedures"], "pred_sql": "SELECT Name FROM Procedures ORDER BY Cost DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of medical procedures that either exceed a specified cost or are associated with a physician who has been trained in those procedures. The first part of the query retrieves procedure names based on a cost threshold, while the second part retrieves procedure names linked to a specific physician's training. The placeholders represent the cost limit and the physician's name, respectively.\",\n        \"virtual_table\": \"SELECT name FROM procedures WHERE cost  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3971", "db_id": "hospital_1", "question": "What are the three most costly procedures?", "rationale": ["Identify the table that contains the procedures and their costs, which is the Procedures table.", "To find the most costly procedures, we need to order the results by the Cost column in descending order.", "We want only the top three results, so we will use the LIMIT clause to restrict the output to three rows."], "gold_sql": "SELECT name FROM procedures ORDER BY cost LIMIT 3", "source_tables": ["procedures"], "pred_sql": "SELECT Name FROM Procedures ORDER BY Cost DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of medical procedures that either exceed a specified cost or are associated with a physician who has been trained in those procedures. The first part of the query retrieves procedure names based on a cost threshold, while the second part retrieves procedure names linked to a specific physician's training. The placeholders represent the cost limit and the physician's name, respectively.\",\n        \"virtual_table\": \"SELECT name FROM procedures WHERE cost  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3973", "db_id": "hospital_1", "question": "Which physicians are trained in procedures that are more expensive than 5000?", "rationale": ["Identify the tables involved: Physician, Trained_In, and Procedures.", "Join the Physician table with the Trained_In table on the EmployeeID and Physician columns.", "Join the resulting table with the Procedures table on the Code and Treatment columns.", "Filter the results to include only those procedures where the cost is greater than 5000.", "Select the Name of the physicians from the final result."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  5000", "source_tables": ["physician", "procedures", "trained_in"], "pred_sql": "SELECT T1.Name FROM Physician AS T1 JOIN Trained_In AS T2 ON T1.EmployeeID = T2.Physician JOIN Procedures AS T3 ON T3.Code = T2.Treatment WHERE T3.Cost > 5000", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of physicians who are trained in specific procedures that have a cost exceeding a certain amount. The placeholders in the WHERE clause represent the cost threshold for the procedures.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3974", "db_id": "hospital_1", "question": "Find the physician who was trained in the most expensive procedure?", "rationale": ["Identify the tables involved: Physician, Trained_In, and Procedures.", "We need to find physicians trained in procedures, so we will join Physician with Trained_In and then with Procedures.", "To find the most expensive procedure, we will use a subquery to get the maximum cost from the Procedures table.", "The final query will select the names of physicians who are trained in the procedure that has the maximum cost."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment ORDER BY T3.cost DESC LIMIT 1", "source_tables": ["physician", "procedures", "trained_in"], "pred_sql": "SELECT T1.Name \nFROM Physician AS T1 \nJOIN Trained_In AS T2 ON T1.EmployeeID = T2.Physician \nJOIN Procedures AS T3 ON T3.Code = T2.Treatment \nWHERE T3.Cost = (SELECT MAX(Cost) FROM Procedures)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of physicians who are trained in specific procedures that have a cost exceeding a certain amount. The placeholders in the WHERE clause represent the cost threshold for the procedures.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3985", "db_id": "hospital_1", "question": "What procedures cost less than 5000 and have John Wen as a trained physician?", "rationale": ["Identify the relevant tables: Procedures, Trained_In, and Physician.", "We need to find procedures that cost less than 5000, so we will filter the Procedures table based on the Cost column.", "We also need to check if John Wen is a trained physician for those procedures, which requires joining the Trained_In and Physician tables.", "Join Procedures with Trained_In on the procedure code, and then join Trained_In with Physician on the physician identifier.", "Apply the conditions in the WHERE clause: cost < 5000 and the physician's name is 'John Wen'.", "Select the procedure names from the Procedures table."], "gold_sql": "SELECT name FROM procedures WHERE cost  <  5000 INTERSECT SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  'John Wen'", "source_tables": ["procedures", "physician", "trained_in"], "pred_sql": "SELECT T3.Name \nFROM Procedures AS T3 \nJOIN Trained_In AS T2 ON T3.Code = T2.Treatment \nJOIN Physician AS T1 ON T2.Physician = T1.EmployeeID \nWHERE T3.Cost < 5000 AND T1.Name = 'John Wen';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of physicians who are trained in specific procedures that have a cost exceeding a certain amount. The placeholders in the WHERE clause represent the cost threshold for the procedures.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4321", "db_id": "tracking_grants_for_research", "question": "What are the different grant amounts for documents sent before '1986-08-26 20:49:27' and after the grant ended on '1989-03-16 18:27:16'?", "rationale": ["Identify the relevant tables: Documents and Grants are needed to get the grant amounts associated with the documents.", "We need to filter documents based on their sent date and the grant's end date.", "The condition specifies that we want documents sent before '1986-08-26 20:49:27' and grants that ended before '1989-03-16 18:27:16'.", "We will use a JOIN between Documents and Grants on the grant_id to access the grant amounts.", "We will select DISTINCT grant amounts to avoid duplicates in the results."], "gold_sql": "SELECT T1.grant_amount FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id WHERE T2.sent_date  <  '1986-08-26 20:49:27' INTERSECT SELECT grant_amount FROM grants WHERE grant_end_date  >  '1989-03-16 18:27:16'", "source_tables": ["grants", "documents"], "pred_sql": "SELECT DISTINCT Grants.grant_amount \nFROM Documents \nJOIN Grants ON Documents.grant_id = Grants.grant_id \nWHERE Documents.sent_date < '1986-08-26 20:49:27' \nAND Grants.grant_end_date < '1989-03-16 18:27:16';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the sent dates of documents from the 'Documents' table that are associated with grants exceeding a specified amount. The query joins multiple tables: 'Grants' to link grants with documents, 'Organisations' to connect grants to their respective organisations, and 'Organisation_Types' to filter organisations based on their type description. The placeholders in the WHERE clause represent the grant amount and the organisation type description.\",\n        \"virtual_table\": \"SELECT T1.sent_date FROM documents AS T1 JOIN Grants AS T2 ON T1.grant_id  =  T2.grant_id JOIN Organisations AS T3 ON T2.organisation_id  =  T3.organisation_id JOIN organisation_Types AS T4 ON T3.organisation_type  =  T4.organisation_type WHERE T2.grant_amount  >  [PLACEHOLDER-TYPE:NUMBER] AND T4.organisation_type_description  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4322", "db_id": "tracking_grants_for_research", "question": "List the project details of the project both producing patent and paper as outcomes.", "rationale": ["Identify the tables involved: Projects, Project_Outcomes, and Research_Outcomes.", "Determine the relationships: Projects are linked to Project_Outcomes via project_id, and Project_Outcomes are linked to Research_Outcomes via outcome_code.", "Select the project details from the Projects table.", "Filter the results based on the outcome descriptions, specifically looking for projects that have outcomes of both 'patent' and 'paper'.", "Use the IN clause to specify multiple outcome descriptions in the WHERE condition."], "gold_sql": "SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  'Paper' INTERSECT SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  'Patent'", "source_tables": ["project_outcomes", "projects"], "pred_sql": "SELECT T1.project_details FROM Projects AS T1 JOIN Project_Outcomes AS T2 ON T1.project_id = T2.project_id JOIN Research_Outcomes AS T3 ON T2.outcome_code = T3.outcome_code WHERE T3.outcome_description IN ('patent', 'paper')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the project details from the 'Projects' table that are associated with specific research outcomes. The query filters the results based on a description of the research outcome, represented by a placeholder for string values.\",\n        \"virtual_table\": \"SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id JOIN Research_outcomes AS T3 ON T2.outcome_code  =  T3.outcome_code WHERE T3.outcome_description LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4324", "db_id": "tracking_grants_for_research", "question": "What is the total grant amount of the organisations described as research?", "rationale": ["Identify the tables involved: Grants, Organisations, and Organisation_Types.", "Determine the relationship between these tables: Grants are linked to Organisations via organisation_id, and Organisations are linked to Organisation_Types via organisation_type.", "We need to filter the organisations based on their type description, which is 'research'.", "Use the SUM function to calculate the total grant amount from the Grants table for the filtered organisations.", "Construct the SQL query using JOINs to combine the necessary tables and apply the WHERE clause to filter by organisation type description."], "gold_sql": "SELECT sum(grant_amount) FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id JOIN organisation_Types AS T3 ON T2.organisation_type  =  T3.organisation_type WHERE T3.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations"], "pred_sql": "SELECT sum(grant_amount) FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id = T2.organisation_id JOIN Organisation_Types AS T3 ON T2.organisation_type = T3.organisation_type WHERE T3.organisation_type_description = 'research'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total grant amount from the 'Grants' table for organisations of a specific type. It joins the 'Grants' table with the 'Organisations' table to link grants to their respective organisations, and further joins with the 'Organisation_Types' table to filter based on the organisation type description. The placeholder in the WHERE clause represents the specific organisation type description being queried.\",\n        \"virtual_table\": \"SELECT sum(grant_amount) FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id JOIN organisation_Types AS T3 ON T2.organisation_type  =  T3.organisation_type WHERE T3.organisation_type_description  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4327", "db_id": "tracking_grants_for_research", "question": "From what date and to what date do the staff work on a project that has the most staff and has staff in a leader role?", "rationale": ["Identify the role code for the 'Leader' role from the Staff_Roles table.", "Find the project_id(s) that have staff members with the 'Leader' role by filtering on the role_code.", "Group the results by project_id and count the number of staff members for each project.", "Order the projects by the count of staff members in descending order to find the project with the most staff.", "Limit the results to the top project (the one with the most staff).", "Select the date_from and date_to for the staff members working on that project."], "gold_sql": "SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT 1 ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  'leader'", "source_tables": ["project_staff"], "pred_sql": "SELECT date_from, date_to \nFROM Project_Staff \nWHERE project_id = (\n    SELECT project_id \n    FROM Project_Staff \n    WHERE role_code = (SELECT role_code FROM Staff_Roles WHERE role_description = 'Leader') \n    GROUP BY project_id \n    ORDER BY COUNT(staff_id) DESC \n    LIMIT 1\n)", "hint": "\n"}
{"sample_id": "train.4330", "db_id": "tracking_grants_for_research", "question": "What is the organisation type and id of the organisation which has the most number of research staff?", "rationale": ["Identify the relevant tables: Organisations and Research_Staff.", "Join the Organisations table with the Research_Staff table on the organisation_id and employer_organisation_id fields.", "Group the results by organisation_id and organisation_type to count the number of research staff per organisation.", "Order the results by the count of research staff in descending order to find the organisation with the most research staff.", "Limit the results to 1 to get only the top organisation."], "gold_sql": "SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT o.organisation_type, o.organisation_id\nFROM Organisations o\nJOIN Research_Staff rs ON o.organisation_id = rs.employer_organisation_id\nGROUP BY o.organisation_id, o.organisation_type\nORDER BY COUNT(rs.staff_id) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.4334", "db_id": "tracking_grants_for_research", "question": "Find out the send dates of the documents with the grant amount of more than 5000 were granted by organisation type described", "rationale": ["Identify the relevant tables: Documents, Grants, Organisations, and Organisation_Types.", "Determine the relationships between these tables: Documents are linked to Grants via grant_id, Grants are linked to Organisations via organisation_id, and Organisations are linked to Organisation_Types via organisation_type.", "Select the 'sent_date' from the Documents table as the main output.", "Apply the necessary joins to connect the tables based on their foreign key relationships.", "Add a WHERE clause to filter grants with a grant_amount greater than 5000.", "Include a condition to filter by organisation type description, which will be provided as a parameter."], "gold_sql": "SELECT T1.sent_date FROM documents AS T1 JOIN Grants AS T2 ON T1.grant_id  =  T2.grant_id JOIN Organisations AS T3 ON T2.organisation_id  =  T3.organisation_id JOIN organisation_Types AS T4 ON T3.organisation_type  =  T4.organisation_type WHERE T2.grant_amount  >  5000 AND T4.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations", "documents"], "pred_sql": "SELECT T1.sent_date FROM Documents AS T1 JOIN Grants AS T2 ON T1.grant_id = T2.grant_id JOIN Organisations AS T3 ON T2.organisation_id = T3.organisation_id JOIN Organisation_Types AS T4 ON T3.organisation_type = T4.organisation_type WHERE T2.grant_amount > 5000 AND T4.organisation_type_description = ?", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the sent dates of documents from the 'Documents' table that are associated with grants exceeding a specified amount. The query joins multiple tables: 'Grants' to link grants with documents, 'Organisations' to connect grants to their respective organisations, and 'Organisation_Types' to filter organisations based on their type description. The placeholders in the WHERE clause represent the grant amount and the organisation type description.\",\n        \"virtual_table\": \"SELECT T1.sent_date FROM documents AS T1 JOIN Grants AS T2 ON T1.grant_id  =  T2.grant_id JOIN Organisations AS T3 ON T2.organisation_id  =  T3.organisation_id JOIN organisation_Types AS T4 ON T3.organisation_type  =  T4.organisation_type WHERE T2.grant_amount  >  [PLACEHOLDER-TYPE:NUMBER] AND T4.organisation_type_description  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4338", "db_id": "tracking_grants_for_research", "question": "List the project details of the projects which did not hire any staff for a researcher role.", "rationale": ["Identify the relevant tables: Projects and Project_Staff.", "We need to find projects that did not hire any staff for a researcher role, so we will use a LEFT JOIN between Projects and Project_Staff.", "The join condition will include a filter for the role_code corresponding to the researcher role, which we can get from the Staff_Roles table.", "In the WHERE clause, we check for NULL in the staff_id of Project_Staff to ensure that no staff members were hired for that role."], "gold_sql": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_Staff WHERE role_code  =  'researcher' )", "source_tables": ["project_staff", "projects"], "pred_sql": "SELECT P.project_details \nFROM Projects AS P \nLEFT JOIN Project_Staff AS PS ON P.project_id = PS.project_id AND PS.role_code = (SELECT role_code FROM Staff_Roles WHERE role_description = 'Researcher') \nWHERE PS.staff_id IS NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the project details from the 'Projects' table that are associated with specific research outcomes. The query filters the results based on a description of the research outcome, represented by a placeholder for string values.\",\n        \"virtual_table\": \"SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id JOIN Research_outcomes AS T3 ON T2.outcome_code  =  T3.outcome_code WHERE T3.outcome_description LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4339", "db_id": "tracking_grants_for_research", "question": "What are the details for all projects that did not hire any staff in a research role?", "rationale": ["We need to find projects that did not hire any staff in a research role.", "To do this, we will select all columns from the Projects table.", "We will perform a LEFT JOIN with the Project_Staff table on the project_id to include all projects and their associated staff.", "We will filter the results where the staff_id from the Project_Staff table is NULL, indicating that no staff were hired for that project."], "gold_sql": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_Staff WHERE role_code  =  'researcher' )", "source_tables": ["project_staff", "projects"], "pred_sql": "SELECT P.* FROM Projects AS P LEFT JOIN Project_Staff AS PS ON P.project_id = PS.project_id WHERE PS.staff_id IS NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the project details from the 'Projects' table that are associated with specific research outcomes. The query filters the results based on a description of the research outcome, represented by a placeholder for string values.\",\n        \"virtual_table\": \"SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id JOIN Research_outcomes AS T3 ON T2.outcome_code  =  T3.outcome_code WHERE T3.outcome_description LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4342", "db_id": "tracking_grants_for_research", "question": "When do all the researcher role staff start to work, and when do they stop working?", "rationale": ["Identify the relevant table: Project_Staff contains information about staff members, including their roles and dates of involvement.", "Determine the columns needed: We need the 'date_from' and 'date_to' columns to know when researchers start and stop working.", "Filter for researcher roles: Use a subquery to select role codes from the Staff_Roles table where the role description includes 'researcher'.", "Construct the SQL query to select the required dates from Project_Staff where the role code matches the researcher roles."], "gold_sql": "SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  'researcher'", "source_tables": ["project_staff"], "pred_sql": "SELECT date_from, date_to \nFROM Project_Staff \nWHERE role_code IN (SELECT role_code FROM Staff_Roles WHERE role_description LIKE '%researcher%');", "hint": "\n"}
{"sample_id": "train.4350", "db_id": "tracking_grants_for_research", "question": "How many staff does each project has? List the project id and the number in an ascending order.", "rationale": ["Identify the relevant table: The question asks about staff associated with projects, so we will use the Project_Staff table.", "Determine the required columns: We need the project_id and the count of staff members for each project.", "Use the COUNT() function: To count the number of staff members for each project, we will use the COUNT() function on staff_id.", "Group the results: We will group the results by project_id to get the count of staff for each project.", "Order the results: Finally, we will order the results in ascending order based on project_id."], "gold_sql": "SELECT T1.project_id ,  count(*) FROM Project_Staff AS T1 JOIN Projects AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) ASC", "source_tables": ["project_staff", "projects"], "pred_sql": "SELECT project_id, COUNT(staff_id) AS staff_count\nFROM Project_Staff\nGROUP BY project_id\nORDER BY project_id ASC;", "hint": "\n"}
{"sample_id": "train.4351", "db_id": "tracking_grants_for_research", "question": "For each project id, how many staff does it have? List them in increasing order.", "rationale": ["Identify the relevant table: The question asks about the number of staff associated with each project, so we will use the Project_Staff table.", "Count the number of staff members: We need to count the staff_id for each project_id, which can be done using the COUNT() function.", "Group the results by project_id: To get the count of staff for each project, we will use GROUP BY project_id.", "Order the results: The question specifies that the results should be listed in increasing order of project_id, so we will use ORDER BY project_id ASC."], "gold_sql": "SELECT T1.project_id ,  count(*) FROM Project_Staff AS T1 JOIN Projects AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) ASC", "source_tables": ["project_staff", "projects"], "pred_sql": "SELECT project_id, COUNT(staff_id) AS staff_count\nFROM Project_Staff\nGROUP BY project_id\nORDER BY project_id ASC;", "hint": "\n"}
{"sample_id": "train.4356", "db_id": "tracking_grants_for_research", "question": "Which project made the most number of outcomes? List the project details and the project id.", "rationale": ["Identify the tables involved: Projects and Project_Outcomes.", "We need to count the number of outcomes for each project, so we will join the Projects table with the Project_Outcomes table on the project_id.", "Use COUNT() to count the number of outcomes for each project.", "Group the results by project_id and project_details to get the count for each project.", "Order the results by the count of outcomes in descending order to find the project with the most outcomes.", "Limit the results to 1 to get only the project with the highest count."], "gold_sql": "SELECT T1.project_details ,  T1.project_id FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "projects"], "pred_sql": "SELECT P.project_id, P.project_details, COUNT(PO.outcome_code) AS outcome_count \nFROM Projects AS P \nJOIN Project_Outcomes AS PO ON P.project_id = PO.project_id \nGROUP BY P.project_id, P.project_details \nORDER BY outcome_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the project details from the 'Projects' table that are associated with specific research outcomes. The query filters the results based on a description of the research outcome, represented by a placeholder for string values.\",\n        \"virtual_table\": \"SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id JOIN Research_outcomes AS T3 ON T2.outcome_code  =  T3.outcome_code WHERE T3.outcome_description LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4359", "db_id": "tracking_grants_for_research", "question": "What are the details of the project with no outcomes?", "rationale": ["Identify the main table to query: Projects.", "Determine the requirement: details of projects with no outcomes.", "To find projects with no outcomes, we can use a subquery that selects project_ids from the Project_Outcomes table.", "Use the NOT IN clause to filter out projects that have outcomes, ensuring we only get those without any associated outcomes."], "gold_sql": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_outcomes )", "source_tables": ["project_outcomes", "projects"], "pred_sql": "SELECT * FROM Projects WHERE project_id NOT IN (SELECT project_id FROM Project_Outcomes)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the project details from the 'Projects' table that are associated with specific research outcomes. The query filters the results based on a description of the research outcome, represented by a placeholder for string values.\",\n        \"virtual_table\": \"SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id JOIN Research_outcomes AS T3 ON T2.outcome_code  =  T3.outcome_code WHERE T3.outcome_description LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4360", "db_id": "tracking_grants_for_research", "question": "Which organisation hired the most number of research staff? List the organisation id, type and detail.", "rationale": ["Identify the relevant tables: Organisations and Research_Staff.", "We need to find the organisation that hired the most research staff, so we will join the Organisations table with the Research_Staff table on the organisation_id.", "We will group the results by organisation_id, organisation_type, and organisation_details to count the number of research staff for each organisation.", "We will use the COUNT function to count the number of staff members for each organisation.", "To find the organisation with the most staff, we will order the results in descending order based on the count of staff members.", "Finally, we will limit the results to 1 to get only the organisation with the highest count."], "gold_sql": "SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT o.organisation_id, o.organisation_type, o.organisation_details\nFROM Organisations o\nJOIN Research_Staff rs ON o.organisation_id = rs.employer_organisation_id\nGROUP BY o.organisation_id, o.organisation_type, o.organisation_details\nORDER BY COUNT(rs.staff_id) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.4363", "db_id": "tracking_grants_for_research", "question": "For each staff id, what is the description of the role that is involved with the most number of projects?", "rationale": ["Identify the relevant tables: Project_Staff for staff involvement in projects and Staff_Roles for role descriptions.", "We need to find the role description for each staff member.", "To determine the role involved with the most number of projects, we will group by project_id in the Project_Staff table and count the number of staff members associated with each project.", "We will order the results by the count of staff members in descending order and limit the results to the top project.", "Join the Project_Staff table with the Staff_Roles table to get the role descriptions for the staff members.", "Select the staff_id and the corresponding role description for the staff involved in the project with the most staff."], "gold_sql": "SELECT T1.role_description ,  T2.staff_id FROM Staff_Roles AS T1 JOIN Project_Staff AS T2 ON T1.role_code  =  T2.role_code JOIN Project_outcomes AS T3 ON T2.project_id  =  T3.project_id GROUP BY T2.staff_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "project_staff", "staff_roles"], "pred_sql": "SELECT ps.staff_id, sr.role_description\nFROM Project_Staff ps\nJOIN Staff_Roles sr ON ps.role_code = sr.role_code\nWHERE ps.project_id IN (\n    SELECT project_id\n    FROM Project_Staff\n    GROUP BY project_id\n    ORDER BY COUNT(*) DESC\n    LIMIT 1\n)", "hint": "\n"}
{"sample_id": "train.4364", "db_id": "tracking_grants_for_research", "question": "Which document type is described with the prefix 'Initial'?", "rationale": ["Identify the relevant table: The question asks about document types, so we will focus on the Document_Types table.", "Determine the condition: The user is looking for document types that start with the prefix 'Initial'. This can be achieved using the LIKE operator in SQL.", "Construct the SQL query: We will select the document_description from the Document_Types table where the document_description matches the specified prefix using the LIKE operator."], "gold_sql": "SELECT document_type_code FROM Document_Types WHERE document_description LIKE 'Initial%'", "source_tables": ["document_types"], "pred_sql": "SELECT document_description FROM Document_Types WHERE document_description LIKE 'Initial%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the start dates of grants from the 'Grants' table that are associated with documents of a specific type. It uses joins to connect the 'Grants', 'Documents', and 'Document_Types' tables based on their foreign key relationships. The placeholder in the WHERE clause represents the description of the document type, allowing users to specify which document type they are interested in. The INTERSECT operation ensures that only the start dates of grants that meet the criteria in both queries are returned.\",\n        \"virtual_table\": \"SELECT T1.grant_start_date FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id JOIN Document_Types AS T3 ON T2.document_type_code  =  T3.document_type_code WHERE T3.document_description  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.grant_start_date FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id JOIN Document_Types AS T3 ON T2.document_type_code  =  T3.document_type_code WHERE T3.document_description  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4369", "db_id": "tracking_grants_for_research", "question": "For each grant id, how many documents does it have, and which one has the most?", "rationale": ["Identify the relevant tables: We need to work with the 'Documents' and 'Grants' tables to get the required information about documents associated with each grant.", "Count the number of documents for each grant: We can use the COUNT() function to count the number of documents for each grant by grouping the results by 'grant_id'.", "Select the grant_id and the count of documents: The SELECT statement will include the 'grant_id' and the count of documents as 'document_count'.", "Determine which grant has the most documents: We can order the results by 'document_count' in descending order to find the grant with the most documents.", "Limit the results to the top grant: Using LIMIT 1 will ensure we only get the grant with the highest document count."], "gold_sql": "SELECT grant_id ,  count(*) FROM Documents GROUP BY grant_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["documents"], "pred_sql": "SELECT d.grant_id, COUNT(d.document_id) AS document_count, d.document_id \nFROM Documents d \nJOIN Grants g ON d.grant_id = g.grant_id \nGROUP BY d.grant_id \nORDER BY document_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the sent dates of documents from the 'Documents' table that are associated with grants exceeding a specified amount. The query joins multiple tables: 'Grants' to link grants with documents, 'Organisations' to connect grants to their respective organisations, and 'Organisation_Types' to filter organisations based on their type description. The placeholders in the WHERE clause represent the grant amount and the organisation type description.\",\n        \"virtual_table\": \"SELECT T1.sent_date FROM documents AS T1 JOIN Grants AS T2 ON T1.grant_id  =  T2.grant_id JOIN Organisations AS T3 ON T2.organisation_id  =  T3.organisation_id JOIN organisation_Types AS T4 ON T3.organisation_type  =  T4.organisation_type WHERE T2.grant_amount  >  [PLACEHOLDER-TYPE:NUMBER] AND T4.organisation_type_description  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4374", "db_id": "tracking_grants_for_research", "question": "How many Patent outcomes are generated from all the projects?", "rationale": ["Identify the tables involved: Projects, Project_Outcomes, and Research_Outcomes.", "Determine the relationship between these tables: Projects are linked to Project_Outcomes via project_id, and Project_Outcomes are linked to Research_Outcomes via outcome_code.", "We need to count the number of outcomes that are specifically related to 'Patent'.", "Use a JOIN to combine the relevant tables and filter the results based on the outcome description containing 'Patent'.", "Use COUNT(*) to get the total number of patent outcomes."], "gold_sql": "SELECT count(*) FROM Project_outcomes WHERE outcome_code  =  'Patent'", "source_tables": ["project_outcomes"], "pred_sql": "SELECT COUNT(*) AS patent_outcome_count FROM Projects AS T1 JOIN Project_Outcomes AS T2 ON T1.project_id = T2.project_id JOIN Research_Outcomes AS T3 ON T2.outcome_code = T3.outcome_code WHERE T3.outcome_description LIKE '%Patent%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the project details from the 'Projects' table that are associated with specific research outcomes. The query filters the results based on a description of the research outcome, represented by a placeholder for string values.\",\n        \"virtual_table\": \"SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id JOIN Research_outcomes AS T3 ON T2.outcome_code  =  T3.outcome_code WHERE T3.outcome_description LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4376", "db_id": "tracking_grants_for_research", "question": "How many project staff worked as leaders or started working before '1989-04-24 23:51:54'?", "rationale": ["Identify the relevant table: Project_Staff contains information about staff members associated with projects.", "Determine the criteria for counting staff: We need to count staff who worked as leaders or started working before a specific date.", "Identify the role codes for leaders: Use the Staff_Roles table to find role codes where the role description includes 'leader'.", "Filter the Project_Staff table: Use a subquery to filter Project_Staff based on the role codes obtained from the previous step and the date condition.", "Count the number of records that meet these criteria."], "gold_sql": "SELECT count(*) FROM Project_Staff WHERE role_code  =  'leader' OR date_from  <  '1989-04-24 23:51:54'", "source_tables": ["project_staff"], "pred_sql": "SELECT COUNT(*) \nFROM Project_Staff \nWHERE role_code IN (SELECT role_code FROM Staff_Roles WHERE role_description LIKE '%leader%') \nAND date_from < '1989-04-24 23:51:54';", "hint": "\n"}
{"sample_id": "train.4380", "db_id": "tracking_grants_for_research", "question": "What are the result description of the project whose detail is 'sint'?", "rationale": ["Identify the relevant tables: Projects, Project_Outcomes, and Research_Outcomes.", "Determine the relationship between these tables: Projects is linked to Project_Outcomes via project_id, and Project_Outcomes is linked to Research_Outcomes via outcome_code.", "Formulate the SQL query to select project details from the Projects table where the project details match the specified condition ('sint').", "Use the LIKE operator to filter project details that contain the substring 'sint'."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code JOIN Projects AS T3 ON T2.project_id  =  T3.project_id WHERE T3.project_details  =  'sint'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "pred_sql": "SELECT T1.project_details FROM Projects AS T1 JOIN Project_Outcomes AS T2 ON T1.project_id = T2.project_id JOIN Research_Outcomes AS T3 ON T2.outcome_code = T3.outcome_code WHERE T1.project_details LIKE '%sint%'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the project details from the 'Projects' table that are associated with specific research outcomes. The query filters the results based on a description of the research outcome, represented by a placeholder for string values.\",\n        \"virtual_table\": \"SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id JOIN Research_outcomes AS T3 ON T2.outcome_code  =  T3.outcome_code WHERE T3.outcome_description LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4381", "db_id": "tracking_grants_for_research", "question": "What is the description for the results whose project detail is 'sint'?", "rationale": ["Identify the relevant tables: Projects, Project_Outcomes, and Research_Outcomes.", "Determine the relationship between these tables: Projects is linked to Project_Outcomes via project_id, and Project_Outcomes is linked to Research_Outcomes via outcome_code.", "Formulate the SQL query to select the outcome_description from Research_Outcomes where the project_details in Projects matches the specified condition ('sint').", "Use the LIKE operator to filter project_details for the exact match with 'sint'."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code JOIN Projects AS T3 ON T2.project_id  =  T3.project_id WHERE T3.project_details  =  'sint'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "pred_sql": "SELECT T3.outcome_description FROM Projects AS T1 JOIN Project_Outcomes AS T2 ON T1.project_id = T2.project_id JOIN Research_Outcomes AS T3 ON T2.outcome_code = T3.outcome_code WHERE T1.project_details LIKE 'sint'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the project details from the 'Projects' table that are associated with specific research outcomes. The query filters the results based on a description of the research outcome, represented by a placeholder for string values.\",\n        \"virtual_table\": \"SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id JOIN Research_outcomes AS T3 ON T2.outcome_code  =  T3.outcome_code WHERE T3.outcome_description LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4385", "db_id": "tracking_grants_for_research", "question": "What are the details for the projects which were launched by the organization with the most projects?", "rationale": ["Identify the organization with the most projects by grouping the Projects table by organisation_id and counting the number of projects for each organization.", "Order the results by the count of projects in descending order to get the organization with the highest number of projects at the top.", "Use a subquery to find the organisation_id of the organization with the most projects.", "Select all details from the Projects table where the organisation_id matches the one found in the subquery."], "gold_sql": "SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT 1 )", "source_tables": ["projects"], "pred_sql": "SELECT P.* FROM Projects AS P WHERE P.organisation_id = (SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY COUNT(project_id) DESC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the project details from the 'Projects' table that are associated with specific research outcomes. The query filters the results based on a description of the research outcome, represented by a placeholder for string values.\",\n        \"virtual_table\": \"SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id JOIN Research_outcomes AS T3 ON T2.outcome_code  =  T3.outcome_code WHERE T3.outcome_description LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4391", "db_id": "tracking_grants_for_research", "question": "For each project id, how many tasks are there?", "rationale": ["Identify the relevant tables: We need to count tasks associated with each project, so we will use the 'Tasks' table.", "Determine the grouping: We want to group the results by 'project_id' to get the count of tasks for each project.", "Use the COUNT function: We will use the COUNT function to count the number of tasks for each project.", "Construct the SQL query: Combine the SELECT statement with the COUNT function and GROUP BY clause to form the complete SQL query."], "gold_sql": "SELECT count(*) ,  T1.project_details FROM Projects AS T1 JOIN Tasks AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id", "source_tables": ["tasks", "projects"], "pred_sql": "SELECT project_id, COUNT(task_id) AS task_count FROM Tasks GROUP BY project_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the project details from the 'Projects' table that are associated with specific research outcomes. The query filters the results based on a description of the research outcome, represented by a placeholder for string values.\",\n        \"virtual_table\": \"SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id JOIN Research_outcomes AS T3 ON T2.outcome_code  =  T3.outcome_code WHERE T3.outcome_description LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4392", "db_id": "tracking_grants_for_research", "question": "What are the staff roles of the staff who", "rationale": ["Identify the relevant table for staff roles, which is 'Staff_Roles'.", "Select the columns 'role_code' and 'role_description' from the 'Staff_Roles' table to get the information about staff roles."], "gold_sql": "SELECT role_code FROM Project_Staff WHERE date_from  >  '2003-04-19 15:06:20' AND date_to  <  '2016-03-15 00:33:18'", "source_tables": ["project_staff"], "pred_sql": "SELECT role_code, role_description FROM Staff_Roles;", "hint": "\n"}
{"sample_id": "train.4397", "db_id": "tracking_grants_for_research", "question": "What is the most common role for the staff?", "rationale": ["Identify the relevant table: The question pertains to staff roles, so we will focus on the Project_Staff table.", "Determine the necessary columns: We need to count the occurrences of each role, so we will select the role_code and count the number of staff members for each role.", "Group the results: To find the most common role, we will group the results by role_code.", "Order the results: We will order the results in descending order based on the count of staff members to get the most common role at the top.", "Limit the results: Since we only want the most common role, we will limit the results to 1."], "gold_sql": "SELECT role_code FROM Project_Staff GROUP BY role_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_staff"], "pred_sql": "SELECT role_code, COUNT(*) as role_count \nFROM Project_Staff \nGROUP BY role_code \nORDER BY role_count DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5534", "db_id": "products_gen_characteristics", "question": "Find the number of products with category \"Spices\" and typically sold above 1000.", "rationale": ["Identify the relevant tables: Products and Ref_Product_Categories.", "We need to count the number of products, so we will use COUNT(*) in the SELECT statement.", "Join the Products table with the Ref_Product_Categories table on the product_category_code to filter by category.", "Add a WHERE clause to filter for products in the 'Spices' category and with a typical selling price greater than 1000."], "gold_sql": "SELECT count(*) FROM products WHERE product_category_code  =  'Spices' AND typical_buying_price  >  1000", "source_tables": ["products"], "pred_sql": "SELECT COUNT(*) FROM Products AS p JOIN Ref_Product_Categories AS c ON p.product_category_code = c.product_category_code WHERE c.product_category_description = 'Spices' AND p.typical_selling_price > 1000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n        \"virtual_table\": \"SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5543", "db_id": "products_gen_characteristics", "question": "What are the descriptions of the categories that products with product descriptions that contain the letter t are in?", "rationale": ["Identify the relevant tables: Products and Ref_Product_Categories.", "We need to retrieve product category descriptions, so we will select from Ref_Product_Categories.", "Join the Products table with Ref_Product_Categories on the product_category_code to link products to their categories.", "Filter the products based on their descriptions containing the letter 't' using the LIKE operator.", "Use DISTINCT to ensure that we only get unique category descriptions."], "gold_sql": "SELECT T1.product_category_description FROM ref_product_categories AS T1 JOIN products AS T2 ON T1.product_category_code  =  T2.product_category_code WHERE T2.product_description LIKE '%t%'", "source_tables": ["products", "ref_product_categories"], "pred_sql": "SELECT DISTINCT rpc.product_category_description \nFROM Products p \nJOIN Ref_Product_Categories rpc ON p.product_category_code = rpc.product_category_code \nWHERE p.product_description LIKE '%t%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of characteristics associated with a specific product from the 'Products' table. The query filters the results based on the product's name and the type of characteristic, using placeholders for both values.\",\n        \"virtual_table\": \"SELECT t3.characteristic_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING] AND t3.characteristic_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5576", "db_id": "products_gen_characteristics", "question": "Count the products that have the color description \"white\" or have the characteristic name \"hot\".", "rationale": ["Identify the tables involved: Products, Product_Characteristics, Characteristics, and Ref_Colors.", "Determine the relationships between the tables: Products links to Product_Characteristics via product_id, Product_Characteristics links to Characteristics via characteristic_id, and Products links to Ref_Colors via color_code.", "Use JOIN statements to combine these tables based on their relationships.", "Specify the conditions in the WHERE clause to filter products by color description 'white' or characteristic name 'hot'.", "Count the number of products that meet either of these conditions using the COUNT function."], "gold_sql": "SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  'white' OR t3.characteristic_name  =  'hot'", "source_tables": ["products", "ref_colors", "characteristics", "product_characteristics"], "pred_sql": "SELECT count(*) FROM Products AS t1 JOIN Product_Characteristics AS t2 ON t1.product_id = t2.product_id JOIN Characteristics AS t3 ON t2.characteristic_id = t3.characteristic_id JOIN Ref_Colors AS t4 ON t1.color_code = t4.color_code WHERE t4.color_description = 'white' OR t3.characteristic_name = 'hot'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of products that either match a specific color description or have a specific characteristic name. It combines data from multiple tables, including 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors', using joins based on their relationships. The placeholders in the WHERE clause represent the color description and characteristic name that the user can specify.\",\n        \"virtual_table\": \"SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  [PLACEHOLDER-TYPE:STRING] OR t3.characteristic_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5579", "db_id": "products_gen_characteristics", "question": "Return the unit of measure for 'Herb' products.", "rationale": ["Identify the relevant tables: We need to find the unit of measure for 'Herb' products, which involves the Products and Ref_Product_Categories tables.", "Determine the relationship: The Products table has a foreign key relationship with the Ref_Product_Categories table through the product_category_code.", "Find the product category code for 'Herb': We need to first find the product_category_code associated with the product_name 'Herb' in the Products table.", "Select the unit of measure: Once we have the product_category_code, we can query the Ref_Product_Categories table to get the unit_of_measure associated with that code."], "gold_sql": "SELECT unit_of_measure FROM ref_product_categories WHERE product_category_code  =  'Herbs'", "source_tables": ["ref_product_categories"], "pred_sql": "SELECT unit_of_measure FROM Ref_Product_Categories WHERE product_category_code = (SELECT product_category_code FROM Products WHERE product_name = 'Herb')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n        \"virtual_table\": \"SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5586", "db_id": "products_gen_characteristics", "question": "Find the unit of measurement and product category code of product named \"chervil\".", "rationale": ["Identify the relevant tables: Products and Ref_Product_Categories.", "Determine the columns needed: product_category_code and unit_of_measure from Ref_Product_Categories.", "Establish the relationship between Products and Ref_Product_Categories using the product_category_code foreign key.", "Filter the results based on the product name 'chervil'.", "Construct the SQL query using JOIN to combine the necessary tables and apply the WHERE clause for filtering."], "gold_sql": "SELECT t2.unit_of_measure ,  t2.product_category_code FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code WHERE t1.product_name  =  'chervil'", "source_tables": ["products", "ref_product_categories"], "pred_sql": "SELECT rpc.product_category_code, rpc.unit_of_measure FROM Products AS p JOIN Ref_Product_Categories AS rpc ON p.product_category_code = rpc.product_category_code WHERE p.product_name = 'chervil';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n        \"virtual_table\": \"SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5589", "db_id": "products_gen_characteristics", "question": "What are the names of products that are not 'white' in color and are not measured by the unit 'Handful'?", "rationale": ["Identify the relevant tables: Products, Ref_Colors, and Ref_Product_Categories.", "Join the Products table with the Ref_Colors table on the color_code to filter products based on color.", "Join the Products table with the Ref_Product_Categories table on the product_category_code to filter products based on the unit of measure.", "Use a WHERE clause to specify that the color_description should not be 'white' and the unit_of_measure should not be 'Handful'.", "Select the product_name from the resulting joined tables."], "gold_sql": "SELECT t1.product_name FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code JOIN ref_colors AS t3 ON t1.color_code  =  t3.color_code WHERE t3.color_description  =  'white' AND t2.unit_of_measure != 'Handful'", "source_tables": ["products", "ref_colors", "ref_product_categories"], "pred_sql": "SELECT product_name FROM Products AS p JOIN Ref_Colors AS c ON p.color_code = c.color_code JOIN Ref_Product_Categories AS pc ON p.product_category_code = pc.product_category_code WHERE c.color_description != 'white' AND pc.unit_of_measure != 'Handful';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of products that either match a specific color description or have a specific characteristic name. It combines data from multiple tables, including 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors', using joins based on their relationships. The placeholders in the WHERE clause represent the color description and characteristic name that the user can specify.\",\n        \"virtual_table\": \"SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  [PLACEHOLDER-TYPE:STRING] OR t3.characteristic_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5592", "db_id": "products_gen_characteristics", "question": "What is the description of the color used by least products?", "rationale": ["Identify the goal: We need to find the description of the color used by the least number of products.", "To achieve this, we will first need to count the number of products associated with each color.", "We can do this by grouping the Products table by color_code and counting the product_id for each color.", "Next, we will order these counts in ascending order to find the color with the least products.", "Finally, we will select the color_description from the Ref_Colors table for the color that has the least products."], "gold_sql": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) ASC LIMIT 1", "source_tables": ["products", "ref_colors"], "pred_sql": "SELECT color_description FROM Ref_Colors WHERE color_code IN (SELECT color_code FROM Products GROUP BY color_code ORDER BY COUNT(product_id) ASC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of products that either match a specific color description or have a specific characteristic name. It combines data from multiple tables, including 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors', using joins based on their relationships. The placeholders in the WHERE clause represent the color description and characteristic name that the user can specify.\",\n        \"virtual_table\": \"SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  [PLACEHOLDER-TYPE:STRING] OR t3.characteristic_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5599", "db_id": "products_gen_characteristics", "question": "Give the names of characteristics that are in two or more products?", "rationale": ["We need to find the names of characteristics that are associated with two or more products.", "To do this, we will join the Product_Characteristics table with the Characteristics table to access the characteristic names.", "We will group the results by the characteristic_id to count how many distinct products each characteristic is associated with.", "Using the HAVING clause, we will filter the groups to only include those with a count of distinct product_ids that is 2 or more."], "gold_sql": "SELECT t3.characteristic_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id GROUP BY t3.characteristic_name HAVING count(*)  >= 2", "source_tables": ["products", "characteristics", "product_characteristics"], "pred_sql": "SELECT characteristic_name FROM Product_Characteristics AS pc JOIN Characteristics AS c ON pc.characteristic_id = c.characteristic_id GROUP BY pc.characteristic_id HAVING COUNT(DISTINCT pc.product_id) >= 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of characteristics associated with a specific product from the 'Products' table. The query filters the results based on the product's name and the type of characteristic, using placeholders for both values.\",\n        \"virtual_table\": \"SELECT t3.characteristic_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING] AND t3.characteristic_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5669", "db_id": "dorm_1", "question": "What are the names of the all-female dorms?", "rationale": ["Identify the table that contains information about dormitories, which is the 'Dorm' table.", "Determine the relevant column that specifies the gender designation of the dormitory, which is the 'gender' column.", "Formulate a SQL query to select the 'dorm_name' from the 'Dorm' table where the 'gender' is 'female'."], "gold_sql": "SELECT dorm_name FROM dorm WHERE gender  =  'F'", "source_tables": ["dorm"], "pred_sql": "SELECT dorm_name FROM Dorm WHERE gender = 'female';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first names and ages of students who live in dormitories that do not offer a specific amenity. The placeholder in the subquery represents the name of the amenity being checked.\",\n        \"virtual_table\": \"SELECT T1.fname ,  T1.age FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid NOT IN (SELECT T3.dormid FROM has_amenity AS T3 JOIN dorm_amenity AS T4 ON T3.amenid  =  T4.amenid WHERE T4.amenity_name  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.5688", "db_id": "dorm_1", "question": "Find the average and total capacity of dorms for the students with gender X.", "rationale": ["Identify the tables needed: We need data from the Dorm table for capacity and the Student table for gender.", "We need to calculate the average and total capacity of dorms, so we will use the AVG() and SUM() functions.", "To get the capacity of dorms for students of a specific gender, we need to join the Dorm table with the Lives_in table and the Student table.", "The join condition will be based on the dormid in the Lives_in table and the StuID in the Student table.", "We will filter the results based on the gender of the students using a WHERE clause."], "gold_sql": "SELECT avg(student_capacity) ,  sum(student_capacity) FROM dorm WHERE gender  =  'X'", "source_tables": ["dorm"], "pred_sql": "SELECT AVG(D.student_capacity) AS average_capacity, SUM(D.student_capacity) AS total_capacity \nFROM Dorm D \nJOIN Lives_in L ON D.dormid = L.dormid \nJOIN Student S ON L.stuid = S.StuID \nWHERE S.Sex = 'X';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first names and ages of students who live in dormitories that do not offer a specific amenity. The placeholder in the subquery represents the name of the amenity being checked.\",\n        \"virtual_table\": \"SELECT T1.fname ,  T1.age FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid NOT IN (SELECT T3.dormid FROM has_amenity AS T3 JOIN dorm_amenity AS T4 ON T3.amenid  =  T4.amenid WHERE T4.amenity_name  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.5699", "db_id": "dorm_1", "question": "What are the names and types of the dorms that have a capacity greater than 300 or less than 100?", "rationale": ["Identify the relevant table: The question pertains to dormitories, so we will focus on the 'Dorm' table.", "Determine the required columns: We need the names and types of the dorms, which correspond to 'dorm_name' and 'student_capacity' in the 'Dorm' table.", "Establish the filtering criteria: The question specifies a capacity greater than 300 or less than 100, which will be used in the WHERE clause.", "Construct the SQL query: Combine the selected columns and the filtering criteria into a complete SQL statement."], "gold_sql": "SELECT dorm_name ,  gender FROM dorm WHERE student_capacity  >  300 OR student_capacity  <  100", "source_tables": ["dorm"], "pred_sql": "SELECT dorm_name, student_capacity FROM Dorm WHERE student_capacity > 300 OR student_capacity < 100;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of students who live in dormitories that have the most amenities. The query joins the 'Student' table with the 'Lives_in' table to find students residing in specific dorms. It filters the dorms based on a subquery that counts the number of amenities in each dorm, ordering them by the count and limiting the results to a specified number of dormitories. The placeholder in the LIMIT clause represents the maximum number of dormitories to consider.\",\n        \"virtual_table\": \"SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.5747", "db_id": "dorm_1", "question": "What are the total number of students who are living in a male dorm?", "rationale": ["Identify the tables needed: We need to count students, so we will use the 'Student' table and the 'Lives_in' table to find out where students live.", "Join the 'Student' table with the 'Lives_in' table on the student ID to link students with their dorms.", "Next, we need to join the 'Dorm' table to filter the dorms based on gender. We are specifically looking for male dorms.", "Use a WHERE clause to filter the results to only include dorms where the gender is 'male'.", "Finally, use COUNT(*) to get the total number of students living in male dorms."], "gold_sql": "SELECT count(*) FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T3.gender  =  'M'", "source_tables": ["student", "lives_in", "dorm"], "pred_sql": "SELECT COUNT(*) AS total_students FROM Student AS S JOIN Lives_in AS L ON S.StuID = L.stuid JOIN Dorm AS D ON L.dormid = D.dormid WHERE D.gender = 'male';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of students who live in dormitories that have the most amenities. The query joins the 'Student' table with the 'Lives_in' table to find students residing in specific dorms. It filters the dorms based on a subquery that counts the number of amenities in each dorm, ordering them by the count and limiting the results to a specified number of dormitories. The placeholder in the LIMIT clause represents the maximum number of dormitories to consider.\",\n        \"virtual_table\": \"SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.5755", "db_id": "dorm_1", "question": "What is the most common amenity in the dorms?", "rationale": ["To find the most common amenity in the dorms, we need to count how many times each amenity appears in the Has_amenity table.", "We will join the Has_amenity table with the Dorm_amenity table to get the names of the amenities.", "We will group the results by amenity name to count the occurrences of each amenity.", "We will order the results in descending order based on the count of amenities to get the most common one at the top.", "Finally, we will limit the results to just one record to get the most common amenity."], "gold_sql": "SELECT T1.amenity_name FROM dorm_amenity AS T1 JOIN has_amenity AS T2 ON T1.amenid  =  T2.amenid GROUP BY T2.amenid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["has_amenity", "dorm_amenity"], "pred_sql": "SELECT amenity_name, COUNT(*) as amenity_count \nFROM Has_amenity \nJOIN Dorm_amenity ON Has_amenity.amenid = Dorm_amenity.amenid \nGROUP BY amenity_name \nORDER BY amenity_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first names and ages of students who live in dormitories that do not offer a specific amenity. The placeholder in the subquery represents the name of the amenity being checked.\",\n        \"virtual_table\": \"SELECT T1.fname ,  T1.age FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid NOT IN (SELECT T3.dormid FROM has_amenity AS T3 JOIN dorm_amenity AS T4 ON T3.amenid  =  T4.amenid WHERE T4.amenity_name  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.5757", "db_id": "dorm_1", "question": "What are the first names of all students who live in the dorm with the most amenities?", "rationale": ["Identify the main goal: Retrieve the first names of students living in the dorm with the most amenities.", "Join the 'Student' table with the 'Lives_in' table to find students and their corresponding dorms.", "Use a subquery to determine which dorm has the most amenities.", "Join the 'Dorm' table with 'Has_amenity' and 'Dorm_amenity' to count the amenities for each dorm.", "Group the results by dorm ID and order them by the count of amenities in descending order.", "Limit the results of the subquery to 1 to get the dorm with the most amenities."], "gold_sql": "SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["has_amenity", "lives_in", "student", "dorm_amenity", "dorm"], "pred_sql": "SELECT T1.Fname FROM Student AS T1 JOIN Lives_in AS T2 ON T1.StuID = T2.stuid WHERE T2.dormid IN (SELECT T3.dormid FROM Dorm AS T3 JOIN Has_amenity AS T4 ON T3.dormid = T4.dormid JOIN Dorm_amenity AS T5 ON T4.amenid = T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of students who live in dormitories that have the most amenities. The query joins the 'Student' table with the 'Lives_in' table to find students residing in specific dorms. It filters the dorms based on a subquery that counts the number of amenities in each dorm, ordering them by the count and limiting the results to a specified number of dormitories. The placeholder in the LIMIT clause represents the maximum number of dormitories to consider.\",\n        \"virtual_table\": \"SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.5776", "db_id": "customer_complaints", "question": "Find the emails of customers who has filed a complaints of the product with the most complaints.", "rationale": ["Identify the main goal: Find the emails of customers who have filed complaints about the product with the most complaints.", "To achieve this, we need to join the Customers table with the Complaints table on the customer_id.", "Next, we need to determine which product has the most complaints. This can be done by grouping the Complaints table by product_id and counting the number of complaints for each product.", "We will order the results of this grouping in descending order and limit the results to 1 to get the product_id of the product with the most complaints.", "Finally, we will use this product_id in the main query to filter the customers who have filed complaints about that product and select their email addresses."], "gold_sql": "SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "customers"], "pred_sql": "SELECT c.email_address FROM Customers c JOIN Complaints comp ON c.customer_id = comp.customer_id WHERE comp.product_id = (SELECT product_id FROM Complaints GROUP BY product_id ORDER BY COUNT(*) DESC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct product names from the 'Products' table that have been associated with complaints. The query joins the 'Products' table with the 'Complaints' table based on the product identifier, and it groups the results by customer identifiers from the 'Customers' table. The results are ordered by the count of complaints for each customer, and a limit is applied to restrict the number of results returned based on a specified numeric value.\",\n        \"virtual_table\": \"SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5777", "db_id": "customer_complaints", "question": "What are the emails of customers who have filed complaints on the product which has had the greatest number of complaints?", "rationale": ["Identify the main goal: Retrieve the email addresses of customers who have filed complaints about the product with the greatest number of complaints.", "To find the product with the greatest number of complaints, we need to group the complaints by product_id and count them, ordering by this count in descending order.", "We will use a subquery to get the product_id that has the maximum count of complaints.", "Next, we need to join the Customers table with the Complaints table to get the email addresses of customers who filed complaints about that product.", "The final SQL query will select the email addresses from the Customers table where the customer_id matches those in the Complaints table for the product identified in the subquery."], "gold_sql": "SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "customers"], "pred_sql": "SELECT c.email_address \nFROM Customers AS c \nJOIN Complaints AS co ON c.customer_id = co.customer_id \nWHERE co.product_id = (\n    SELECT product_id \n    FROM Complaints \n    GROUP BY product_id \n    ORDER BY COUNT(*) DESC \n    LIMIT 1\n);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of last names of staff members who are handling complaints related to products, ordered by the price of those products. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5779", "db_id": "customer_complaints", "question": "Return the names of products that have had complaints filed by the customer who has filed the fewest complaints.", "rationale": ["Identify the need to find products associated with complaints from the customer who has filed the fewest complaints.", "Use the 'Products' table to get product names and the 'Complaints' table to link products to complaints.", "Join the 'Products' table with the 'Complaints' table on the product_id to get the relevant complaints for each product.", "Join the 'Complaints' table with the 'Customers' table to associate complaints with customers.", "Group the results by customer_id to count the number of complaints filed by each customer.", "Order the results by the count of complaints in ascending order to find the customer with the fewest complaints.", "Limit the results to 1 to get only the product names associated with the customer who has filed the fewest complaints."], "gold_sql": "SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "products", "customers"], "pred_sql": "SELECT DISTINCT t1.product_name FROM Products AS t1 JOIN Complaints AS t2 ON t1.product_id = t2.product_id JOIN Customers AS t3 ON t2.customer_id = t3.customer_id GROUP BY t3.customer_id ORDER BY COUNT(*) LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct product names from the 'Products' table that have been associated with complaints. The query joins the 'Products' table with the 'Complaints' table based on the product identifier, and it groups the results by customer identifiers from the 'Customers' table. The results are ordered by the count of complaints for each customer, and a limit is applied to restrict the number of results returned based on a specified numeric value.\",\n        \"virtual_table\": \"SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5795", "db_id": "customer_complaints", "question": "What is the last name of the staff member in charge of the complaint on the product with the lowest price?", "rationale": ["Identify the tables involved: Staff, Complaints, and Products.", "We need to find the last name of the staff member handling a complaint related to the product with the lowest price.", "Join the Staff table with the Complaints table on staff_id to link staff members to their complaints.", "Join the Complaints table with the Products table on product_id to link complaints to the products.", "Order the results by product price in ascending order to get the lowest priced product first.", "Limit the results to 1 to get only the last name of the staff member handling the complaint for the lowest priced product."], "gold_sql": "SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT 1", "source_tables": ["complaints", "products", "staff"], "pred_sql": "SELECT t1.last_name FROM Staff AS t1 JOIN Complaints AS t2 ON t1.staff_id = t2.staff_id JOIN Products AS t3 ON t2.product_id = t3.product_id ORDER BY t3.product_price LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of last names of staff members who are handling complaints related to products, ordered by the price of those products. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5800", "db_id": "customer_complaints", "question": "How many customers are there in the customer type with the most customers?", "rationale": ["Identify the relevant table: The question pertains to customers, so we will focus on the 'Customers' table.", "Determine the required information: We need to count the number of customers for each customer type.", "Group the results: We will group the results by 'customer_type_code' to get the count for each type.", "Order the results: To find the customer type with the most customers, we will order the results in descending order based on the count.", "Limit the results: We will limit the results to 1 to get only the top customer type."], "gold_sql": "SELECT count(*) FROM customers GROUP BY customer_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers"], "pred_sql": "SELECT customer_type_code, COUNT(customer_id) AS customer_count \nFROM Customers \nGROUP BY customer_type_code \nORDER BY customer_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct product names from the 'Products' table that have been associated with complaints. The query joins the 'Products' table with the 'Complaints' table based on the product identifier, and it groups the results by customer identifiers from the 'Customers' table. The results are ordered by the count of complaints for each customer, and a limit is applied to restrict the number of results returned based on a specified numeric value.\",\n        \"virtual_table\": \"SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5810", "db_id": "customer_complaints", "question": "What is first names of the top 5 staff who have handled the greatest number of complaints?", "rationale": ["Identify the relevant tables: Staff and Complaints.", "We need to find the first names of staff members, so we will select 'first_name' from the Staff table.", "To determine how many complaints each staff member has handled, we will join the Staff table with the Complaints table on 'staff_id'.", "We will group the results by 'staff_id' to aggregate the number of complaints handled by each staff member.", "We will use COUNT() to count the number of complaints for each staff member.", "To get the top 5 staff members who handled the greatest number of complaints, we will order the results in descending order based on the count of complaints and limit the results to 5."], "gold_sql": "SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT 5", "source_tables": ["complaints", "staff"], "pred_sql": "SELECT t1.first_name FROM Staff AS t1 JOIN Complaints AS t2 ON t1.staff_id = t2.staff_id GROUP BY t1.staff_id ORDER BY COUNT(t2.complaint_id) DESC LIMIT 5;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of last names of staff members who are handling complaints related to products, ordered by the price of those products. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5812", "db_id": "customer_complaints", "question": "Which state has the most customers?", "rationale": ["Identify the table that contains customer information, which is the 'Customers' table.", "To find out which state has the most customers, we need to count the number of customers in each state.", "We will use the COUNT() function to count the number of customer IDs grouped by state.", "We will group the results by the 'state' column to aggregate the counts for each state.", "To get the state with the most customers, we will order the results in descending order based on the count of customers.", "Finally, we will limit the results to 1 to get only the state with the highest count."], "gold_sql": "SELECT state FROM customers GROUP BY state ORDER BY count(*) LIMIT 1", "source_tables": ["customers"], "pred_sql": "SELECT state, COUNT(customer_id) AS customer_count \nFROM Customers \nGROUP BY state \nORDER BY customer_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of last names of staff members who are handling complaints related to products, ordered by the price of those products. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5813", "db_id": "customer_complaints", "question": "Give the state that has the most customers.", "rationale": ["The task is to find the state with the most customers.", "To achieve this, we need to count the number of customers in each state.", "We will use the COUNT function to count the customer_id for each state.", "We will group the results by the state column to get the count per state.", "To find the state with the most customers, we will order the results in descending order based on the count of customers.", "Finally, we will limit the results to 1 to get only the state with the highest count."], "gold_sql": "SELECT state FROM customers GROUP BY state ORDER BY count(*) LIMIT 1", "source_tables": ["customers"], "pred_sql": "SELECT state, COUNT(customer_id) AS customer_count \nFROM Customers \nGROUP BY state \nORDER BY customer_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of last names of staff members who are handling complaints related to products, ordered by the price of those products. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5865", "db_id": "tracking_share_transactions", "question": "What are the lot details of lots associated with transactions whose share count is bigger than 100 and whose type code is \"PUR\"?", "rationale": ["Identify the tables involved: Lots, Transactions, and Transactions_Lots.", "We need to retrieve lot details, so we will select 'lot_details' from the Lots table.", "We need to join the Lots table with the Transactions_Lots table to link lots with transactions.", "Next, we join the Transactions table to access transaction details related to the lots.", "We apply the condition that the share count must be greater than 100.", "We also need to filter transactions by the type code 'PUR'.", "Construct the SQL query using the selected columns and the necessary joins with the specified conditions."], "gold_sql": "SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON  T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  >  100 AND T3.transaction_type_code  =  'PUR'", "source_tables": ["lots", "transactions_lots", "transactions"], "pred_sql": "SELECT L.lot_details \nFROM Lots AS L \nJOIN Transactions_Lots AS TL ON L.lot_id = TL.lot_id \nJOIN Transactions AS T ON TL.transaction_id = T.transaction_id \nWHERE T.share_count > 100 \nAND T.transaction_type_code = 'PUR';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the details of lots associated with transactions where the number of shares involved in the transaction is less than a specified amount. The placeholders in the WHERE clause represent the numeric value for the share count.\",\n        \"virtual_table\": \"SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5866", "db_id": "tracking_share_transactions", "question": "Show the average transaction amount for different transaction types.", "rationale": ["Identify the tables involved: We need the Transactions table for transaction amounts and the Ref_Transaction_Types table for transaction type descriptions.", "Determine the columns needed: We need the transaction type description from Ref_Transaction_Types and the amount of transaction from Transactions.", "Join the tables: We will join Transactions and Ref_Transaction_Types on the transaction_type_code to link transaction amounts with their respective types.", "Calculate the average: We will use the AVG() function to calculate the average transaction amount for each transaction type.", "Group the results: We will group the results by transaction type description to get the average for each type."], "gold_sql": "SELECT transaction_type_code ,  avg(amount_of_transaction) FROM TRANSACTIONS GROUP BY transaction_type_code", "source_tables": ["transactions"], "pred_sql": "SELECT rt.transaction_type_description, AVG(t.amount_of_transaction) AS average_transaction_amount\nFROM Transactions t\nJOIN Ref_Transaction_Types rt ON t.transaction_type_code = rt.transaction_type_code\nGROUP BY rt.transaction_type_description;", "hint": "\n"}
{"sample_id": "train.5873", "db_id": "tracking_share_transactions", "question": "Show the number of transactions with transaction type code \"SALE\" for different investors if it is larger than 0.", "rationale": ["Identify the relevant tables: Investors and Transactions are needed to get investor details and transaction counts.", "Join the Investors table with the Transactions table on the investor_id to link investors with their transactions.", "Filter the transactions to only include those with the transaction type code 'SALE'.", "Group the results by investor_id to count the number of transactions for each investor.", "Use the HAVING clause to filter out investors with a transaction count of 0."], "gold_sql": "SELECT investor_id ,  COUNT(*) FROM TRANSACTIONS WHERE transaction_type_code  =  'SALE' GROUP BY investor_id", "source_tables": ["transactions"], "pred_sql": "SELECT Investors.investor_id, COUNT(Transactions.transaction_id) AS transaction_count\nFROM Investors\nJOIN Transactions ON Investors.investor_id = Transactions.investor_id\nWHERE Transactions.transaction_type_code = 'SALE'\nGROUP BY Investors.investor_id\nHAVING COUNT(Transactions.transaction_id) > 0;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the details of lots associated with transactions where the number of shares involved in the transaction is less than a specified amount. The placeholders in the WHERE clause represent the numeric value for the share count.\",\n        \"virtual_table\": \"SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5876", "db_id": "tracking_share_transactions", "question": "Show the transaction type code that occurs the most frequently.", "rationale": ["We need to find the transaction type code that occurs the most frequently in the Transactions table.", "To do this, we will use the COUNT function to count the occurrences of each transaction_type_code.", "We will group the results by transaction_type_code to aggregate the counts for each type.", "Next, we will order the results in descending order based on the count of occurrences.", "Finally, we will limit the results to 1 to get the most frequently occurring transaction type code."], "gold_sql": "SELECT transaction_type_code FROM TRANSACTIONS GROUP BY transaction_type_code ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["transactions"], "pred_sql": "SELECT transaction_type_code\nFROM Transactions\nGROUP BY transaction_type_code\nORDER BY COUNT(*) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5884", "db_id": "tracking_share_transactions", "question": "What are the details of the lots which are not used in any transactions?", "rationale": ["We need to find details of lots that are not used in any transactions.", "To achieve this, we can use a LEFT JOIN between the Lots table and the Transactions_Lots table on the lot_id.", "Next, we will also LEFT JOIN the Transactions table to ensure we can check if there are any associated transactions for those lots.", "In the WHERE clause, we will filter for cases where the transaction_id from the Transactions table is NULL, indicating that there are no transactions associated with those lots."], "gold_sql": "SELECT lot_details FROM Lots EXCEPT SELECT T1.lot_details FROM Lots AS T1 JOIN transactions_lots AS T2 ON T1.lot_id  =  T2.lot_id", "source_tables": ["lots", "transactions_lots"], "pred_sql": "SELECT L.lot_details \nFROM Lots AS L \nLEFT JOIN Transactions_Lots AS TL ON L.lot_id = TL.lot_id \nLEFT JOIN Transactions AS T ON TL.transaction_id = T.transaction_id \nWHERE T.transaction_id IS NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the details of lots associated with transactions where the number of shares involved in the transaction is less than a specified amount. The placeholders in the WHERE clause represent the numeric value for the share count.\",\n        \"virtual_table\": \"SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5893", "db_id": "cre_Theme_park", "question": "Show details of all visitors.", "rationale": ["The task is to show details of all visitors, which means we need to select all columns from the Visitors table.", "The SQL query to retrieve all records from a table is done using the SELECT statement followed by the asterisk (*) to indicate all columns.", "The table we are interested in is Visitors, so we will specify 'FROM Visitors' in the query."], "gold_sql": "SELECT Tourist_Details FROM VISITORS", "source_tables": ["visitors"], "pred_sql": "SELECT * FROM Visitors;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, excluding those that have been visited by another specified tourist. The placeholders in the WHERE clause represent the details of the tourists.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5901", "db_id": "cre_Theme_park", "question": "What is the detail of the location UK Gallery?", "rationale": ["Identify the relevant table for location details, which is the 'Locations' table.", "Determine the specific column to filter by, which is 'Location_Name'.", "Use the provided location name 'UK Gallery' to construct the WHERE clause.", "Formulate the SQL query to select all columns from the 'Locations' table where the 'Location_Name' matches 'UK Gallery'."], "gold_sql": "SELECT Other_Details FROM LOCATIONS WHERE Location_Name  =  'UK Gallery'", "source_tables": ["locations"], "pred_sql": "SELECT * FROM Locations WHERE Location_Name = 'UK Gallery';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5902", "db_id": "cre_Theme_park", "question": "Return the detail of the location named \"UK Gallery\".", "rationale": ["Identify the table that contains location details, which is the 'Locations' table.", "Determine the columns needed: 'Location_Name', 'Address', and 'Other_Details'.", "Formulate the SQL query to select these columns from the 'Locations' table.", "Add a WHERE clause to filter the results to only include the location named 'UK Gallery'."], "gold_sql": "SELECT Other_Details FROM LOCATIONS WHERE Location_Name  =  'UK Gallery'", "source_tables": ["locations"], "pred_sql": "SELECT Location_Name, Address, Other_Details FROM Locations WHERE Location_Name = 'UK Gallery';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5914", "db_id": "cre_Theme_park", "question": "Give me the star rating descriptions of the hotels that cost more than 10000.", "rationale": ["Identify the relevant tables: Hotels and Ref_Hotel_Star_Ratings.", "Determine the columns needed: star_rating_description from Ref_Hotel_Star_Ratings and price_range from Hotels.", "Establish the relationship between the tables using the foreign key: Hotels.star_rating_code = Ref_Hotel_Star_Ratings.star_rating_code.", "Filter the hotels based on the price range condition: cost more than 10000.", "Construct the SQL query to select the star rating descriptions of the filtered hotels."], "gold_sql": "SELECT T2.star_rating_description FROM HOTELS AS T1 JOIN Ref_Hotel_Star_Ratings AS T2 ON T1.star_rating_code  =  T2.star_rating_code WHERE T1.price_range  >  10000", "source_tables": ["ref_hotel_star_ratings", "hotels"], "pred_sql": "SELECT R.star_rating_description FROM Hotels AS H JOIN Ref_Hotel_Star_Ratings AS R ON H.star_rating_code = R.star_rating_code WHERE H.price_range = 'More than 10000';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5915", "db_id": "cre_Theme_park", "question": "What are the details and opening hours of the museums?", "rationale": ["Identify the relevant tables: Museums and Tourist_Attractions.", "Determine the columns needed: Museum_Details from Museums and Opening_Hours from Tourist_Attractions.", "Establish the relationship between the tables: Museums are linked to Tourist_Attractions through the Museum_ID and Tourist_Attraction_ID.", "Construct the SQL query to select the required details from the joined tables."], "gold_sql": "SELECT T1.Museum_Details ,  T2.Opening_Hours FROM MUSEUMS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Museum_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["tourist_attractions", "museums"], "pred_sql": "SELECT M.Museum_Details, T.Opening_Hours \nFROM Museums AS M \nJOIN Tourist_Attractions AS T ON M.Museum_ID = T.Tourist_Attraction_ID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5922", "db_id": "cre_Theme_park", "question": "Which tourist attractions are related to royal family? Tell me their details and how we can get there.", "rationale": ["Identify the relevant tables: Tourist_Attractions and Royal_Family.", "Determine the relationship between the tables: Tourist_Attractions has a foreign key linking to Royal_Family.", "Select the desired columns: Name, Description, and How_to_Get_There from Tourist_Attractions.", "Construct the SQL query using JOIN to combine the two tables based on the relationship."], "gold_sql": "SELECT T1.Royal_Family_Details ,  T2.How_to_Get_There FROM ROYAL_FAMILY AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Royal_Family_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["royal_family", "tourist_attractions"], "pred_sql": "SELECT TA.Name, TA.Description, TA.How_to_Get_There \nFROM Tourist_Attractions AS TA \nJOIN Royal_Family AS RF ON TA.Tourist_Attraction_ID = RF.Royal_Family_ID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5924", "db_id": "cre_Theme_park", "question": "Find the details of the shops that can be reached by walk.", "rationale": ["Identify the relevant tables: Shops and Tourist_Attractions.", "Determine the relationship between Shops and Tourist_Attractions using the Shop_ID and Tourist_Attraction_ID.", "Filter the results based on the condition that the shops can be reached by walking, which is indicated in the How_to_Get_There column of the Tourist_Attractions table.", "Construct the SQL query to select the Shop_ID and Shop_Details from the Shops table, joining it with the Tourist_Attractions table and applying the filter for walking."], "gold_sql": "SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  'walk'", "source_tables": ["shops", "tourist_attractions"], "pred_sql": "SELECT Shops.Shop_ID, Shops.Shop_Details \nFROM Shops \nJOIN Tourist_Attractions ON Shops.Shop_ID = Tourist_Attractions.Tourist_Attraction_ID \nWHERE Tourist_Attractions.How_to_Get_There LIKE '%walk%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5927", "db_id": "cre_Theme_park", "question": "What are the details of the markets that can be accessed by walk or bus?", "rationale": ["Identify the relevant table for street markets, which is 'Street_Markets'.", "Determine the columns needed: 'Market_ID' and 'Market_Details'.", "Identify the relationship between street markets and tourist attractions, which is through the 'Tourist_Attraction_ID'.", "Find the 'Tourist_Attractions' table to filter attractions based on the 'How_to_Get_There' column.", "Use a subquery to select 'Tourist_Attraction_ID' from 'Tourist_Attractions' where 'How_to_Get_There' includes 'walk' or 'bus'.", "Combine the results to get the details of the markets that can be accessed by walking or by bus."], "gold_sql": "SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  'walk' OR  T2.How_to_Get_There  =  'bus'", "source_tables": ["street_markets", "tourist_attractions"], "pred_sql": "SELECT Market_ID, Market_Details FROM Street_Markets WHERE Market_ID IN (SELECT Tourist_Attraction_ID FROM Tourist_Attractions WHERE How_to_Get_There LIKE '%walk%' OR How_to_Get_There LIKE '%bus%');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5928", "db_id": "cre_Theme_park", "question": "Find the details of all the markets that are accessible by walk or bus.", "rationale": ["Identify the relevant table for street markets, which is 'Street_Markets'.", "Determine the columns needed: 'Market_ID' and 'Market_Details'.", "Identify the condition for accessibility: markets that can be accessed by walking or bus.", "Find the relevant tourist attractions that meet the accessibility criteria by checking the 'How_to_Get_There' column in the 'Tourist_Attractions' table.", "Use a subquery to filter 'Street_Markets' based on the 'Tourist_Attraction_ID' from 'Tourist_Attractions' that match the accessibility criteria.", "Construct the final SQL query to select the required details from 'Street_Markets' using the results of the subquery."], "gold_sql": "SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  'walk' OR  T2.How_to_Get_There  =  'bus'", "source_tables": ["street_markets", "tourist_attractions"], "pred_sql": "SELECT Market_ID, Market_Details FROM Street_Markets WHERE Market_ID IN (SELECT Tourist_Attraction_ID FROM Tourist_Attractions WHERE How_to_Get_There LIKE '%walk%' OR How_to_Get_There LIKE '%bus%');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5942", "db_id": "cre_Theme_park", "question": "What are the details of the three most expensive hotels?", "rationale": ["Identify the table that contains hotel details, which is the 'Hotels' table.", "Determine the relevant columns needed to retrieve the details of the hotels, which are all columns in this case.", "To find the most expensive hotels, we need to sort the hotels by their price range in descending order.", "Use the ORDER BY clause to sort the results by 'price_range' in descending order.", "Limit the results to the top three entries using the LIMIT clause."], "gold_sql": "SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT 3", "source_tables": ["hotels"], "pred_sql": "SELECT * FROM Hotels ORDER BY price_range DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5943", "db_id": "cre_Theme_park", "question": "Show the details and star ratings of the 3 least expensive hotels.", "rationale": ["Identify the relevant tables: Hotels and Ref_Hotel_Star_Ratings.", "We need to select hotel details and their star ratings, so we will select columns from both tables: hotel_id and price_range from Hotels, and star_rating_description from Ref_Hotel_Star_Ratings.", "Join the Hotels table with Ref_Hotel_Star_Ratings on the star_rating_code to get the star rating descriptions for each hotel.", "Order the results by price_range in ascending order to get the least expensive hotels first.", "Limit the results to 3 to get only the 3 least expensive hotels."], "gold_sql": "SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT 3", "source_tables": ["hotels"], "pred_sql": "SELECT H.hotel_id, H.price_range, R.star_rating_description \nFROM Hotels AS H \nJOIN Ref_Hotel_Star_Ratings AS R ON H.star_rating_code = R.star_rating_code \nORDER BY H.price_range ASC \nLIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5945", "db_id": "cre_Theme_park", "question": "Show the transportation method most people choose to get to tourist attractions.", "rationale": ["The question asks for the most popular transportation method to tourist attractions.", "The relevant information is stored in the 'Tourist_Attractions' table, specifically in the 'How_to_Get_There' column.", "We need to count how many visits correspond to each transportation method, which can be done by joining the 'Tourist_Attractions' table with the 'Visits' table on 'Tourist_Attraction_ID'.", "We will group the results by the 'How_to_Get_There' column to aggregate the visit counts for each transportation method.", "Finally, we will order the results by the count of visits in descending order and limit the output to the top result."], "gold_sql": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["tourist_attractions"], "pred_sql": "SELECT T1.How_to_Get_There, COUNT(*) as Visit_Count \nFROM Tourist_Attractions AS T1 \nJOIN Visits AS T2 ON T1.Tourist_Attraction_ID = T2.Tourist_Attraction_ID \nGROUP BY T1.How_to_Get_There \nORDER BY Visit_Count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5946", "db_id": "cre_Theme_park", "question": "Which transportation method is used the most often to get to tourist attractions?", "rationale": ["Identify the relevant tables: Tourist_Attractions and Visits are needed to determine how tourists get to attractions.", "The 'How_to_Get_There' column in the Tourist_Attractions table contains the transportation methods.", "Join the Tourist_Attractions table with the Visits table on the Tourist_Attraction_ID to link visits to their respective attractions.", "Group the results by the 'How_to_Get_There' column to count how many times each transportation method was used.", "Order the results by the count of visits in descending order to find the most frequently used transportation method.", "Limit the results to 1 to get the top transportation method."], "gold_sql": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["tourist_attractions"], "pred_sql": "SELECT How_to_Get_There, COUNT(*) as Visit_Count \nFROM Tourist_Attractions AS TA \nJOIN Visits AS V ON TA.Tourist_Attraction_ID = V.Tourist_Attraction_ID \nGROUP BY How_to_Get_There \nORDER BY Visit_Count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5951", "db_id": "cre_Theme_park", "question": "Show different tourist attractions' names, ids, and the corresponding number of visits.", "rationale": ["Identify the relevant tables: Tourist_Attractions and Visits are needed to get the names and visit counts of tourist attractions.", "Select the columns needed: Tourist_Attraction_ID and Name from Tourist_Attractions, and count the number of visits from Visits.", "Use a LEFT JOIN to connect Tourist_Attractions with Visits on the Tourist_Attraction_ID to ensure all attractions are included, even those with zero visits.", "Group the results by Tourist_Attraction_ID and Name to aggregate the visit counts correctly."], "gold_sql": "SELECT T1.Name ,  T2.Tourist_Attraction_ID ,   COUNT(*) FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID", "source_tables": ["visits", "tourist_attractions"], "pred_sql": "SELECT Tourist_Attraction_ID, Name, COUNT(Visit_ID) AS Number_of_Visits \nFROM Tourist_Attractions \nLEFT JOIN Visits ON Tourist_Attractions.Tourist_Attraction_ID = Visits.Tourist_Attraction_ID \nGROUP BY Tourist_Attraction_ID, Name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5959", "db_id": "cre_Theme_park", "question": "What are the names of the tourist attractions that have parking or shopping as their feature details?", "rationale": ["Identify the relevant tables: Tourist_Attractions, Tourist_Attraction_Features, and Features.", "We need to find the names of tourist attractions that have specific features (parking or shopping).", "Join the Tourist_Attractions table with the Tourist_Attraction_Features table to link attractions with their features.", "Then, join the Features table to get the details of those features.", "Use a WHERE clause to filter the results to only include features that are either 'parking' or 'shopping'.", "Select the Name of the tourist attractions that meet these criteria."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'park' UNION SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'shopping'", "source_tables": ["features", "tourist_attractions", "tourist_attraction_features"], "pred_sql": "SELECT T.Name \nFROM Tourist_Attractions AS T \nJOIN Tourist_Attraction_Features AS F ON T.Tourist_Attraction_ID = F.Tourist_Attraction_ID \nJOIN Features AS D ON F.Feature_ID = D.Feature_ID \nWHERE D.Feature_Details IN ('parking', 'shopping');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5960", "db_id": "cre_Theme_park", "question": "Find the tourist attractions that have parking or shopping as their feature details. What are the names of the attractions?", "rationale": ["Identify the relevant tables: Tourist_Attractions, Tourist_Attraction_Features, and Features.", "We need to find the names of tourist attractions that have specific features (parking or shopping).", "Join the Tourist_Attractions table with the Tourist_Attraction_Features table to link attractions with their features.", "Then, join the Features table to get the details of those features.", "Use a WHERE clause to filter the features to only include 'parking' or 'shopping'.", "Select the Name of the tourist attractions that meet the criteria."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'park' UNION SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'shopping'", "source_tables": ["features", "tourist_attractions", "tourist_attraction_features"], "pred_sql": "SELECT T.Name \nFROM Tourist_Attractions AS T \nJOIN Tourist_Attraction_Features AS F ON T.Tourist_Attraction_ID = F.Tourist_Attraction_ID \nJOIN Features AS D ON F.Feature_ID = D.Feature_ID \nWHERE D.Feature_Details IN ('parking', 'shopping');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5964", "db_id": "cre_Theme_park", "question": "Which tourist attractions do the tourists Vincent and Marcelle visit? Tell me the names of the attractions.", "rationale": ["Identify the tables involved: Tourist_Attractions, Visitors, and Visits.", "We need to find the names of tourist attractions visited by two specific tourists, Vincent and Marcelle.", "Use JOIN to connect the Tourist_Attractions table with the Visits and Visitors tables based on their relationships.", "The WHERE clause will filter the results for each tourist separately.", "To find attractions visited by both tourists, we can use the INTERSECT operator to get common results from two SELECT statements, one for each tourist."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  'Vincent' INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  'Marcelle'", "source_tables": ["visits", "visitors", "tourist_attractions"], "pred_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Visitors AS T2 JOIN Visits AS T3 ON T1.Tourist_Attraction_ID = T3.Tourist_Attraction_ID AND T2.Tourist_ID = T3.Tourist_ID WHERE T2.Tourist_Details = 'Vincent' INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Visitors AS T2 JOIN Visits AS T3 ON T1.Tourist_Attraction_ID = T3.Tourist_Attraction_ID AND T2.Tourist_ID = T3.Tourist_ID WHERE T2.Tourist_Details = 'Marcelle'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6059", "db_id": "customers_and_addresses", "question": "What is the average amount of items ordered in each order?", "rationale": ["To find the average amount of items ordered in each order, we need to focus on the 'Order_Items' table, which contains the 'order_quantity' for each product in an order.", "We will use the AVG() function to calculate the average of 'order_quantity'.", "Since we want the average per order, we will group the results by 'order_id' to ensure we get the average for each individual order.", "The final SQL query will select the average quantity of items ordered, grouped by each order."], "gold_sql": "SELECT avg(order_quantity) FROM order_items", "source_tables": ["order_items"], "pred_sql": "SELECT AVG(order_quantity) AS average_items_ordered FROM Order_Items GROUP BY order_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of customers who have placed orders containing the maximum quantity of any product. It joins the 'Customers' table with the 'Customer_Orders' table to link customers to their orders, and then further joins with the 'Order_Items' table to access the order quantities. The placeholder in the WHERE clause is used to filter for the maximum order quantity across all orders.\",\n        \"virtual_table\": \"SELECT t1.customer_name FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id JOIN order_items AS t3 ON t2.order_id  =  t3.order_id WHERE t3.order_quantity  =  ( SELECT max(order_quantity) FROM order_items)\"\n    }\n}\n"}
{"sample_id": "train.6066", "db_id": "customers_and_addresses", "question": "Find the payment method that is used most frequently.", "rationale": ["Identify the relevant table: The question asks about payment methods, which are stored in the Customers table.", "Count the occurrences of each payment method: We need to count how many times each payment method appears in the Customers table.", "Group the results by payment method: This allows us to aggregate the counts for each unique payment method.", "Order the results by frequency: We want to sort the payment methods by their count in descending order to find the most frequently used one.", "Limit the results to the top entry: Since we only want the most frequently used payment method, we limit the results to 1."], "gold_sql": "SELECT payment_method FROM customers GROUP BY payment_method ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers"], "pred_sql": "SELECT payment_method, COUNT(payment_method) AS frequency\nFROM Customers\nGROUP BY payment_method\nORDER BY frequency DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6085", "db_id": "customers_and_addresses", "question": "Which city has the most customers living in?", "rationale": ["Identify the relevant tables: Customers, Customer_Addresses, and Addresses.", "Join the Customers table with Customer_Addresses on customer_id to link customers to their addresses.", "Join the resulting table with Addresses on address_id to get the city information.", "Group the results by city to count the number of customers in each city.", "Order the results in descending order based on the count of customers to find the city with the most customers.", "Limit the results to 1 to get only the city with the highest count."], "gold_sql": "SELECT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id GROUP BY t3.city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "customers", "customer_addresses"], "pred_sql": "SELECT t3.city FROM Customers AS t1 JOIN Customer_Addresses AS t2 ON t1.customer_id = t2.customer_id JOIN Addresses AS t3 ON t2.address_id = t3.address_id GROUP BY t3.city ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of cities where customers are located, derived from the 'Customers', 'Customer_Addresses', and 'Addresses' tables. The results are grouped by city and ordered by the number of customers in each city, with a limit on the number of cities returned based on a specified number.\",\n        \"virtual_table\": \"SELECT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id GROUP BY t3.city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6098", "db_id": "customers_and_addresses", "question": "Find the contact channel code that was used by the customer named \"Tillman Ernser\".", "rationale": ["Identify the relevant tables: Customers and Customer_Contact_Channels.", "We need to find the contact channel code for a specific customer, so we will join the Customers table with the Customer_Contact_Channels table on the customer_id.", "Filter the results to only include the customer named 'Tillman Ernser'.", "Select the channel_code from the joined tables."], "gold_sql": "SELECT DISTINCT channel_code FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  'Tillman Ernser'", "source_tables": ["customer_contact_channels", "customers"], "pred_sql": "SELECT Customer_Contact_Channels.channel_code \nFROM Customers \nJOIN Customer_Contact_Channels ON Customers.customer_id = Customer_Contact_Channels.customer_id \nWHERE Customers.customer_name = 'Tillman Ernser';", "hint": "\n"}
{"sample_id": "train.6099", "db_id": "customers_and_addresses", "question": "What is the \"active to date\" of the latest contact channel used by \"Tillman Ernser\"?", "rationale": ["Identify the relevant tables: We need to access the Customer_Contact_Channels table to find the 'active to date' and the Customers table to filter by customer name.", "Join the tables: We will join Customer_Contact_Channels with Customers on the customer_id to link contact channels to the specific customer.", "Filter by customer name: We will add a WHERE clause to filter the results to only include the customer named 'Tillman Ernser'.", "Order the results: To find the latest contact channel, we will order the results by 'active_from_date' in descending order.", "Limit the results: Since we only need the latest contact channel, we will limit the results to 1."], "gold_sql": "SELECT max(t2.active_to_date) FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  'Tillman Ernser'", "source_tables": ["customer_contact_channels", "customers"], "pred_sql": "SELECT Customer_Contact_Channels.active_to_date \nFROM Customer_Contact_Channels \nJOIN Customers ON Customer_Contact_Channels.customer_id = Customers.customer_id \nWHERE Customers.customer_name = 'Tillman Ernser' \nORDER BY Customer_Contact_Channels.active_from_date DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6100", "db_id": "customers_and_addresses", "question": "Return the the \"active to date\" of the latest contact channel used by the customer named \"Tillman Ernser\".", "rationale": ["Identify the customer ID for 'Tillman Ernser' from the Customers table.", "Use the identified customer ID to find the contact channels in the Customer_Contact_Channels table.", "Sort the contact channels by 'active_from_date' in descending order to get the latest one.", "Select the 'active_to_date' of the latest contact channel and limit the result to 1."], "gold_sql": "SELECT max(t2.active_to_date) FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  'Tillman Ernser'", "source_tables": ["customer_contact_channels", "customers"], "pred_sql": "SELECT active_to_date \nFROM Customer_Contact_Channels \nWHERE customer_id = (\n    SELECT customer_id \n    FROM Customers \n    WHERE customer_name = 'Tillman Ernser'\n) \nORDER BY active_from_date DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6101", "db_id": "customers_and_addresses", "question": "What is the average time span of contact channels in the database?", "rationale": ["Identify the relevant table: The question pertains to contact channels, which are stored in the 'Customer_Contact_Channels' table.", "Determine the time span: The time span for each contact channel can be calculated by subtracting 'active_from_date' from 'active_to_date'.", "Use the JULIANDAY function: This function converts date strings into a format that allows for arithmetic operations, making it suitable for calculating the difference in days between two dates.", "Calculate the average: To find the average time span, we can use the AVG() function on the calculated time spans.", "Filter out inactive channels: We should only consider channels that have an 'active_to_date' to ensure we are calculating the time span for channels that were active."], "gold_sql": "SELECT avg(active_to_date - active_from_date) FROM customer_contact_channels", "source_tables": ["customer_contact_channels"], "pred_sql": "SELECT AVG(julianday(active_to_date) - julianday(active_from_date)) AS average_time_span\nFROM Customer_Contact_Channels\nWHERE active_to_date IS NOT NULL;", "hint": "\n"}
{"sample_id": "train.6102", "db_id": "customers_and_addresses", "question": "Compute the average active time span of contact channels.", "rationale": ["Identify the relevant table: The question pertains to contact channels, so we will use the Customer_Contact_Channels table.", "Determine the columns needed: We need the active_from_date and active_to_date to calculate the active time span.", "Calculate the time span: The time span can be calculated by subtracting active_from_date from active_to_date. In SQLite, we can use julianday() to convert dates to a format that allows for subtraction.", "Compute the average: We will use the AVG() function to compute the average of the calculated time spans.", "Filter out inactive channels: We will include a condition to ensure that we only consider channels that have an active_to_date (i.e., they have been deactivated)."], "gold_sql": "SELECT avg(active_to_date - active_from_date) FROM customer_contact_channels", "source_tables": ["customer_contact_channels"], "pred_sql": "SELECT AVG(julianday(active_to_date) - julianday(active_from_date)) AS average_active_time_span\nFROM Customer_Contact_Channels\nWHERE active_to_date IS NOT NULL;", "hint": "\n"}
{"sample_id": "train.6104", "db_id": "customers_and_addresses", "question": "Return the channel code and contact number of the customer contact channel whose active duration was the longest.", "rationale": ["Identify the relevant table: Customer_Contact_Channels contains the channel code and contact number.", "Determine the duration of activity for each contact channel by calculating the difference between active_to_date and active_from_date using julianday function.", "Use a subquery to find the maximum duration of activity across all contact channels.", "Select the channel_code and contact_number where the duration equals the maximum duration found in the subquery."], "gold_sql": "SELECT channel_code ,  contact_number FROM customer_contact_channels WHERE active_to_date - active_from_date  =  (SELECT active_to_date - active_from_date FROM customer_contact_channels ORDER BY (active_to_date - active_from_date) DESC LIMIT 1)", "source_tables": ["customer_contact_channels"], "pred_sql": "SELECT channel_code, contact_number FROM Customer_Contact_Channels WHERE (julianday(active_to_date) - julianday(active_from_date)) = (SELECT max(julianday(active_to_date) - julianday(active_from_date)) FROM Customer_Contact_Channels)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of customers who have placed orders containing the maximum quantity of any product. It joins the 'Customers' table with the 'Customer_Orders' table to link customers to their orders, and then further joins with the 'Order_Items' table to access the order quantities. The placeholder in the WHERE clause is used to filter for the maximum order quantity across all orders.\",\n        \"virtual_table\": \"SELECT t1.customer_name FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id JOIN order_items AS t3 ON t2.order_id  =  t3.order_id WHERE t3.order_quantity  =  ( SELECT max(order_quantity) FROM order_items)\"\n    }\n}\n"}
{"sample_id": "train.6105", "db_id": "customers_and_addresses", "question": "Find the name and active date of the customer that use email as the contact channel.", "rationale": ["Identify the relevant tables: Customers and Customer_Contact_Channels.", "We need to retrieve the customer name and the active date of the contact channel.", "Join the Customers table with the Customer_Contact_Channels table on the customer_id field.", "Filter the results to include only those records where the channel_code is 'email'.", "Additionally, check that the contact channel is currently active by ensuring active_to_date is NULL."], "gold_sql": "SELECT t1.customer_name ,  t2.active_from_date FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t2.channel_code  =  'Email'", "source_tables": ["customer_contact_channels", "customers"], "pred_sql": "SELECT c.customer_name, cc.active_from_date \nFROM Customers c \nJOIN Customer_Contact_Channels cc ON c.customer_id = cc.customer_id \nWHERE cc.channel_code = 'email' AND cc.active_to_date IS NULL;", "hint": "\n"}
{"sample_id": "train.6127", "db_id": "customers_and_addresses", "question": "Who made the latest order?", "rationale": ["Identify the relevant tables: Customers, Customer_Orders, and Order_Items are needed to find out who made the latest order.", "Join the Customers table with Customer_Orders to link customers to their orders using customer_id.", "Join the resulting table with Order_Items to access the order details and quantities.", "To find the latest order, we need to filter the Customer_Orders by the maximum order_date.", "The final query selects the customer_name from the Customers table where the order_date matches the latest order date."], "gold_sql": "SELECT t1.customer_name FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id ORDER BY t2.order_date DESC LIMIT 1", "source_tables": ["customer_orders", "customers"], "pred_sql": "SELECT t1.customer_name FROM Customers AS t1 JOIN Customer_Orders AS t2 ON t1.customer_id = t2.customer_id JOIN Order_Items AS t3 ON t2.order_id = t3.order_id WHERE t2.order_date = (SELECT max(order_date) FROM Customer_Orders)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of customers who have placed orders containing the maximum quantity of any product. It joins the 'Customers' table with the 'Customer_Orders' table to link customers to their orders, and then further joins with the 'Order_Items' table to access the order quantities. The placeholder in the WHERE clause is used to filter for the maximum order quantity across all orders.\",\n        \"virtual_table\": \"SELECT t1.customer_name FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id JOIN order_items AS t3 ON t2.order_id  =  t3.order_id WHERE t3.order_quantity  =  ( SELECT max(order_quantity) FROM order_items)\"\n    }\n}\n"}
{"sample_id": "train.6131", "db_id": "customers_and_addresses", "question": "Find the name and ID of the product whose total order quantity is the largest.", "rationale": ["Identify the tables involved: Products and Order_Items.", "We need to find the product with the maximum order quantity, so we will join the Products table with the Order_Items table on product_id.", "We will use a subquery to find the maximum order quantity from the Order_Items table.", "The main query will select the product_id and product_details from the Products table where the order quantity matches the maximum found in the subquery."], "gold_sql": "SELECT t2.product_details ,  t2.product_id FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY sum(t1.order_quantity) LIMIT 1", "source_tables": ["products", "order_items"], "pred_sql": "SELECT p.product_id, p.product_details FROM Products AS p JOIN Order_Items AS oi ON p.product_id = oi.product_id WHERE oi.order_quantity = (SELECT MAX(order_quantity) FROM Order_Items)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of customers who have placed orders containing the maximum quantity of any product. It joins the 'Customers' table with the 'Customer_Orders' table to link customers to their orders, and then further joins with the 'Order_Items' table to access the order quantities. The placeholder in the WHERE clause is used to filter for the maximum order quantity across all orders.\",\n        \"virtual_table\": \"SELECT t1.customer_name FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id JOIN order_items AS t3 ON t2.order_id  =  t3.order_id WHERE t3.order_quantity  =  ( SELECT max(order_quantity) FROM order_items)\"\n    }\n}\n"}
{"sample_id": "train.6133", "db_id": "customers_and_addresses", "question": "Find all the addresses in East Julianaside, Texas or in Gleasonmouth, Arizona.", "rationale": ["Identify the relevant table: The Addresses table contains the information about addresses, including city and state.", "Determine the conditions: We need to find addresses in two specific cities (East Julianaside and Gleasonmouth) and their corresponding states (Texas and Arizona).", "Construct the SQL query: Use a SELECT statement to retrieve all columns from the Addresses table where the city and state match the specified criteria.", "Combine the conditions using OR to ensure that either of the two sets of conditions can be satisfied."], "gold_sql": "SELECT address_content FROM addresses WHERE city  =  'East Julianaside' AND state_province_county  =  'Texas' UNION SELECT address_content FROM addresses WHERE city  =  'Gleasonmouth' AND state_province_county  =  'Arizona'", "source_tables": ["addresses"], "pred_sql": "SELECT * FROM Addresses WHERE (city = 'East Julianaside' AND state_province_county = 'Texas') OR (city = 'Gleasonmouth' AND state_province_county = 'Arizona');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of cities where customers are located, derived from the 'Customers', 'Customer_Addresses', and 'Addresses' tables. The results are grouped by city and ordered by the number of customers in each city, with a limit on the number of cities returned based on a specified number.\",\n        \"virtual_table\": \"SELECT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id GROUP BY t3.city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6134", "db_id": "customers_and_addresses", "question": "What are all the addresses in East Julianaside, Texas or in Gleasonmouth, Arizona.", "rationale": ["Identify the relevant tables: We need to query the Addresses table to get the addresses based on city and state.", "Determine the conditions: We are looking for addresses in two specific cities (East Julianaside and Gleasonmouth) and their respective states (Texas and Arizona).", "Construct the SQL query: Use a SELECT statement to retrieve all columns from the Addresses table where the city and state match the specified criteria.", "Combine the conditions using OR to ensure that either of the city-state pairs can be returned."], "gold_sql": "SELECT address_content FROM addresses WHERE city  =  'East Julianaside' AND state_province_county  =  'Texas' UNION SELECT address_content FROM addresses WHERE city  =  'Gleasonmouth' AND state_province_county  =  'Arizona'", "source_tables": ["addresses"], "pred_sql": "SELECT * FROM Addresses WHERE (city = 'East Julianaside' AND state_province_county = 'Texas') OR (city = 'Gleasonmouth' AND state_province_county = 'Arizona');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of cities where customers are located, derived from the 'Customers', 'Customer_Addresses', and 'Addresses' tables. The results are grouped by city and ordered by the number of customers in each city, with a limit on the number of cities returned based on a specified number.\",\n        \"virtual_table\": \"SELECT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id GROUP BY t3.city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6271", "db_id": "city_record", "question": "What is the match id of the competition called \"1994 FIFA World Cup qualification\"?", "rationale": ["Identify the relevant tables: We need to find the match ID related to a specific competition.", "The 'match' table contains the match details including the competition.", "The 'hosting_city' table links matches to the cities that hosted them.", "We need to filter the matches based on the competition name '1994 FIFA World Cup qualification'.", "We will use a subquery to find the City_ID associated with the competition name.", "Finally, we will select the Match_ID from the match table where the competition matches the specified name."], "gold_sql": "SELECT match_id FROM MATCH WHERE competition = '1994 FIFA World Cup qualification'", "source_tables": ["match"], "pred_sql": "SELECT match.Match_ID FROM match JOIN hosting_city ON match.Match_ID = hosting_city.Match_ID WHERE hosting_city.Host_City = (SELECT City_ID FROM city WHERE City = '1994 FIFA World Cup qualification')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the venue information for matches hosted in a specific city during a particular competition. The placeholders in the WHERE clause represent the city name and the competition identifier.\",\n        \"virtual_table\": \"SELECT T3.venue FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id = T2.host_city JOIN MATCH AS T3 ON T2.match_id = T3.match_id WHERE T1.city = [PLACEHOLDER-TYPE:STRING] AND T3.competition = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6275", "db_id": "city_record", "question": "Find the city that hosted the most events.", "rationale": ["To find the city that hosted the most events, we need to count the number of matches hosted by each city.", "The 'hosting_city' table contains the information about which city hosted which match, so we will use this table to group by 'Host_City'.", "We will use the COUNT function to count the number of matches for each city.", "To get the city with the most events, we will order the results by the count in descending order and limit the results to 1."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["hosting_city", "city"], "pred_sql": "SELECT Host_City, COUNT(*) AS Event_Count FROM hosting_city GROUP BY Host_City ORDER BY Event_Count DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the venue information for matches hosted in a specific city during a particular competition. The placeholders in the WHERE clause represent the city name and the competition identifier.\",\n        \"virtual_table\": \"SELECT T3.venue FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id = T2.host_city JOIN MATCH AS T3 ON T2.match_id = T3.match_id WHERE T1.city = [PLACEHOLDER-TYPE:STRING] AND T3.competition = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6282", "db_id": "city_record", "question": "Which three cities have the largest regional population?", "rationale": ["Identify the relevant table: The 'city' table contains the 'Regional_Population' column which is needed to answer the question.", "Select the 'City' and 'Regional_Population' columns from the 'city' table.", "Order the results by 'Regional_Population' in descending order to get the largest populations first.", "Limit the results to 3 to get only the top three cities."], "gold_sql": "SELECT city FROM city ORDER BY regional_population DESC LIMIT 3", "source_tables": ["city"], "pred_sql": "SELECT City, Regional_Population FROM city ORDER BY Regional_Population DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul INTERSECT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city\"\n    }\n}\n"}
{"sample_id": "train.6283", "db_id": "city_record", "question": "What are the three largest cities in terms of regional population?", "rationale": ["Identify the relevant table: The 'city' table contains the information about cities and their populations.", "Select the columns needed: We need the 'City' and 'Regional_Population' columns.", "Order the results: To find the largest cities, we will order the results by 'Regional_Population' in descending order.", "Limit the results: We only want the top three cities, so we will use 'LIMIT 3' to restrict the output."], "gold_sql": "SELECT city FROM city ORDER BY regional_population DESC LIMIT 3", "source_tables": ["city"], "pred_sql": "SELECT City, Regional_Population FROM city ORDER BY Regional_Population DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul INTERSECT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city\"\n    }\n}\n"}
{"sample_id": "train.6286", "db_id": "city_record", "question": "Which city has the highest temperature in February?", "rationale": ["Identify the relevant tables: We need data from the 'city' table for city names and the 'temperature' table for February temperatures.", "Join the 'city' table with the 'temperature' table on 'City_ID' to access both city names and their corresponding February temperatures.", "Order the results by the February temperature in descending order to get the city with the highest temperature at the top.", "Limit the results to 1 to retrieve only the city with the highest temperature in February."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id ORDER BY T2.Feb DESC LIMIT 1", "source_tables": ["city", "temperature"], "pred_sql": "SELECT T1.City FROM city AS T1 JOIN temperature AS T2 ON T1.City_ID = T2.City_ID ORDER BY T2.Feb DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies cities that have a higher average temperature in March compared to December, excluding those cities that have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city\"\n    }\n}\n"}
{"sample_id": "train.6288", "db_id": "city_record", "question": "Give me a list of cities whose temperature in March is lower than that in July or higher than that in Oct?", "rationale": ["Identify the relevant tables: We need data from the 'city' and 'temperature' tables.", "Determine the conditions: We want cities where the temperature in March is lower than in July or higher than in October.", "Construct the SQL query: Use a SELECT statement to get the city names from the 'city' table, joining it with the 'temperature' table on 'City_ID'.", "Apply the conditions using the WHERE clause to filter the results based on the temperature comparisons."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul OR T2.Mar  >  T2.Oct", "source_tables": ["city", "temperature"], "pred_sql": "SELECT T1.City FROM city AS T1 JOIN temperature AS T2 ON T1.City_ID = T2.City_ID WHERE T2.Mar < T2.Jul OR T2.Mar > T2.Oct", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul INTERSECT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city\"\n    }\n}\n"}
{"sample_id": "train.6290", "db_id": "city_record", "question": "Give me a list of cities whose temperature in Mar is lower than that in July and which have also served as host cities?", "rationale": ["Identify the cities from the 'city' table that have a corresponding entry in the 'temperature' table.", "Join the 'city' table with the 'temperature' table on 'City_ID' to access temperature data.", "Filter the results to include only those cities where the average temperature in March (T2.Mar) is lower than in July (T2.Jul).", "Next, identify the cities that have hosted a match by joining the 'city' table with the 'hosting_city' table on 'City_ID' and 'Host_City'.", "Use the INTERSECT operator to find cities that meet both conditions: lower temperature in March compared to July and have hosted a match."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul INTERSECT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "pred_sql": "SELECT T1.City FROM city AS T1 JOIN temperature AS T2 ON T1.City_ID = T2.City_ID WHERE T2.Mar < T2.Jul INTERSECT SELECT T3.City FROM city AS T3 JOIN hosting_city AS T4 ON T3.City_ID = T4.Host_City", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul INTERSECT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city\"\n    }\n}\n"}
{"sample_id": "train.6293", "db_id": "city_record", "question": "Which cities have lower temperature in March than in Dec and have never served as host cities?", "rationale": ["Identify the relevant tables: city, temperature, and hosting_city.", "We need to compare the average temperatures in March and December, so we will join the city table with the temperature table on City_ID.", "The condition for lower temperature in March than in December is T.Mar < T.Dec.", "We also need to ensure that the cities have never served as host cities, which means we need to exclude any city that appears in the hosting_city table.", "To exclude host cities, we can use a NOT IN clause with a subquery that selects all Host_City from the hosting_city table.", "Finally, we select the City names from the city table that meet both conditions."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "pred_sql": "SELECT C.City FROM city AS C JOIN temperature AS T ON C.City_ID = T.City_ID WHERE T.Mar < T.Dec AND C.City_ID NOT IN (SELECT Host_City FROM hosting_city)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul INTERSECT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city\"\n    }\n}\n"}
{"sample_id": "train.6295", "db_id": "city_record", "question": "Which cities have higher temperature in Feb than in Jun or have once served as host cities?", "rationale": ["Identify the cities from the 'city' table that have temperature data in the 'temperature' table.", "Join the 'city' table with the 'temperature' table on 'City_ID' to access temperature data for each city.", "Filter the results to find cities where the average temperature in February (Feb) is greater than in June (Jun).", "Additionally, identify cities that have hosted matches by joining the 'city' table with the 'hosting_city' table on 'City_ID' and 'Host_City'.", "Use a UNION to combine the results of cities with higher temperatures in February than June and those that have hosted matches."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Feb  >  T2.Jun UNION SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "pred_sql": "SELECT T1.City FROM city AS T1 JOIN temperature AS T2 ON T1.City_ID = T2.City_ID WHERE T2.Feb > T2.Jun UNION SELECT T3.City FROM city AS T3 JOIN hosting_city AS T4 ON T3.City_ID = T4.Host_City", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul INTERSECT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city\"\n    }\n}\n"}
{"sample_id": "train.6324", "db_id": "e_government", "question": "Find the last name of the first ever contact person of the organization with the highest UK Vat number.", "rationale": ["Identify the organization with the highest UK VAT number by ordering the Organizations table by 'uk_vat_number' in descending order and limiting the result to 1.", "Use the organization_id of the identified organization to find the contact individuals associated with it by joining the Organization_Contact_Individuals table.", "Join the Individuals table to retrieve the last names of the contact individuals.", "Order the results by the end date of the contact period (date_contact_to) in ascending order to get the first contact person.", "Limit the final result to 1 to get only the first contact person's last name."], "gold_sql": "SELECT t3.individual_last_name FROM organizations AS t1 JOIN organization_contact_individuals AS t2 ON t1.organization_id  =  t2.organization_id JOIN individuals AS t3 ON t2.individual_id  =  t3.individual_id WHERE t1.uk_vat_number  =  (SELECT max(uk_vat_number) FROM organizations) ORDER BY t2.date_contact_to ASC LIMIT 1", "source_tables": ["organizations", "organization_contact_individuals", "individuals"], "pred_sql": "SELECT t3.individual_last_name FROM Organizations AS t1 JOIN Organization_Contact_Individuals AS t2 ON t1.organization_id = t2.organization_id JOIN Individuals AS t3 ON t2.individual_id = t3.individual_id WHERE t1.organization_id = (SELECT organization_id FROM Organizations ORDER BY uk_vat_number DESC LIMIT 1) ORDER BY t2.date_contact_to ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the last names of individuals who have contacted a specific organization. It retrieves data from the 'Organizations', 'Organization_Contact_Individuals', and 'Individuals' tables, filtering based on the organization's name. The results are ordered by the end date of the contact period, and a limit is applied to the number of results returned.\",\n        \"virtual_table\": \"SELECT t3.individual_last_name FROM organizations AS t1 JOIN organization_contact_individuals AS t2 ON t1.organization_id  =  t2.organization_id JOIN individuals AS t3 ON t2.individual_id  =  t3.individual_id WHERE t1.organization_name  =  [PLACEHOLDER-TYPE:STRING] ORDER BY t2.date_contact_to DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6328", "db_id": "e_government", "question": "Find name of the services that has never been used.", "rationale": ["Identify the table that contains the service names, which is the Services table.", "We need to find services that have never been used, which means we need to check against the Party_Services table where service bookings are recorded.", "To find services that have never been used, we can select service names from the Services table where the service_id is not present in the Party_Services table.", "Construct the SQL query using a subquery to filter out the used services from the Services table."], "gold_sql": "SELECT service_name FROM services EXCEPT SELECT t1.service_name FROM services AS t1 JOIN party_services AS t2 ON t1.service_id  =  t2.service_id", "source_tables": ["services", "party_services"], "pred_sql": "SELECT service_name \nFROM Services \nWHERE service_id NOT IN (SELECT service_id FROM Party_Services);", "hint": "\n"}
{"sample_id": "train.6330", "db_id": "e_government", "question": "Find the name of all the cities and states.", "rationale": ["Identify the relevant table: The question asks for cities and states, which are found in the Addresses table.", "Select the appropriate columns: We need to select 'town_city' for cities and 'state_province_county' for states.", "Use DISTINCT to avoid duplicate entries: Since we want the names of all cities and states, using DISTINCT ensures that we only get unique combinations.", "Construct the SQL query: Combine the selected columns and the table name in a SELECT statement."], "gold_sql": "SELECT town_city FROM addresses UNION SELECT state_province_county FROM addresses", "source_tables": ["addresses"], "pred_sql": "SELECT DISTINCT town_city, state_province_county FROM Addresses;", "hint": "\n"}
{"sample_id": "train.6331", "db_id": "e_government", "question": "What are the names of all cities and states?", "rationale": ["Identify the relevant table: The question asks for city and state names, which are found in the Addresses table.", "Select the appropriate columns: We need to select 'town_city' and 'state_province_county' from the Addresses table.", "Use DISTINCT to avoid duplicate entries: Since cities and states may repeat, we use DISTINCT to get unique combinations.", "Construct the SQL query: Combine the selected columns and table into a SQL SELECT statement."], "gold_sql": "SELECT town_city FROM addresses UNION SELECT state_province_county FROM addresses", "source_tables": ["addresses"], "pred_sql": "SELECT DISTINCT town_city, state_province_county FROM Addresses;", "hint": "\n"}
{"sample_id": "train.6346", "db_id": "e_government", "question": "Find the last name of the individuals that have been contact individuals of an organization.", "rationale": ["Identify the tables involved: Organizations, Organization_Contact_Individuals, and Individuals.", "Determine the relationship between the tables: Organization_Contact_Individuals links individuals to organizations, and Individuals contains the last names of individuals.", "Select the last names of individuals from the Individuals table (t3).", "Join the Organizations table (t1) with Organization_Contact_Individuals (t2) on organization_id.", "Join Organization_Contact_Individuals (t2) with Individuals (t3) on individual_id.", "The query should retrieve the last names of individuals who have contacted organizations, without filtering by a specific organization name or limiting the results."], "gold_sql": "SELECT DISTINCT t1.individual_last_name FROM individuals AS t1 JOIN organization_contact_individuals AS t2 ON t1.individual_id  =  t2.individual_id", "source_tables": ["organization_contact_individuals", "individuals"], "pred_sql": "SELECT t3.individual_last_name FROM Organizations AS t1 JOIN Organization_Contact_Individuals AS t2 ON t1.organization_id = t2.organization_id JOIN Individuals AS t3 ON t2.individual_id = t3.individual_id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the last names of individuals who have contacted a specific organization. It retrieves data from the 'Organizations', 'Organization_Contact_Individuals', and 'Individuals' tables, filtering based on the organization's name. The results are ordered by the end date of the contact period, and a limit is applied to the number of results returned.\",\n        \"virtual_table\": \"SELECT t3.individual_last_name FROM organizations AS t1 JOIN organization_contact_individuals AS t2 ON t1.organization_id  =  t2.organization_id JOIN individuals AS t3 ON t2.individual_id  =  t3.individual_id WHERE t1.organization_name  =  [PLACEHOLDER-TYPE:STRING] ORDER BY t2.date_contact_to DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6723", "db_id": "activity_1", "question": "Show the first name, last name, and phone number for all female faculty members.", "rationale": ["Identify the table that contains faculty information, which is the Faculty table.", "Select the columns needed: first name (Fname), last name (Lname), and phone number (Phone).", "Filter the results to include only female faculty members by using the condition F.Sex = 'Female'.", "Construct the SQL query using the SELECT statement to retrieve the specified columns from the Faculty table with the appropriate WHERE clause."], "gold_sql": "SELECT Fname ,  Lname ,  phone FROM Faculty WHERE Sex  =  'F'", "source_tables": ["faculty"], "pred_sql": "SELECT F.Fname, F.Lname, F.Phone \nFROM Faculty AS F \nWHERE F.Sex = 'Female';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of activities in which a specific faculty member participates. The placeholders in the WHERE clause represent the first and last names of the faculty member.\",\n        \"virtual_table\": \"SELECT T3.activity_name FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN Activity AS T3 ON T3.actid  =  T2.actid WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6725", "db_id": "activity_1", "question": "Show ids for all the male faculty.", "rationale": ["Identify the table that contains faculty information, which is the Faculty table.", "Determine the relevant column for gender, which is 'Sex' in the Faculty table.", "Formulate a query to select the 'FacID' of faculty members where 'Sex' is equal to 'Male'."], "gold_sql": "SELECT FacID FROM Faculty WHERE Sex  =  'M'", "source_tables": ["faculty"], "pred_sql": "SELECT FacID FROM Faculty WHERE Sex = 'Male';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the last names of faculty members who hold a specific academic rank but do not participate in certain activities. The placeholders in the query represent the rank of the faculty and the names of the activities they do not participate in.\",\n        \"virtual_table\": \"SELECT lname FROM faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6738", "db_id": "activity_1", "question": "Find the building that has the largest number of faculty members.", "rationale": ["To find the building with the largest number of faculty members, we need to count the number of faculty members in each building.", "We will use the COUNT function to count the number of unique FacID in each building.", "We will group the results by the Building column to get the count for each building.", "To get the building with the largest number of faculty members, we will order the results in descending order based on the count.", "Finally, we will limit the results to 1 to get only the building with the highest count."], "gold_sql": "SELECT building FROM Faculty GROUP BY building ORDER BY count(*) DESC LIMIT 1", "source_tables": ["faculty"], "pred_sql": "SELECT Building, COUNT(FacID) AS FacultyCount \nFROM Faculty \nGROUP BY Building \nORDER BY FacultyCount DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the last names of faculty members who hold a specific academic rank but do not participate in certain activities. The placeholders in the query represent the rank of the faculty and the names of the activities they do not participate in.\",\n        \"virtual_table\": \"SELECT lname FROM faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6740", "db_id": "activity_1", "question": "In which buildings are there at least ten professors?", "rationale": ["We need to find buildings with at least ten professors.", "To do this, we will count the number of faculty members (FacID) in each building.", "We will group the results by the Building column to get the count of professors in each building.", "Finally, we will use the HAVING clause to filter the groups to only include those with a count of 10 or more professors."], "gold_sql": "SELECT building FROM Faculty WHERE rank  =  'Professor' GROUP BY building HAVING count(*)  >=  10", "source_tables": ["faculty"], "pred_sql": "SELECT Building, COUNT(FacID) AS ProfessorCount \nFROM Faculty \nGROUP BY Building \nHAVING COUNT(FacID) >= 10;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the last names of faculty members who hold a specific academic rank but do not participate in certain activities. The placeholders in the query represent the rank of the faculty and the names of the activities they do not participate in.\",\n        \"virtual_table\": \"SELECT lname FROM faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6747", "db_id": "activity_1", "question": "Show the number of male and female assistant professors.", "rationale": ["Identify the relevant table: Faculty, which contains information about faculty members including their rank and gender.", "We need to filter the faculty members to only include those with the rank of 'Assistant Professor'.", "Next, we need to group the results by the 'Sex' column to count the number of male and female assistant professors.", "Finally, we will use the COUNT function to get the number of faculty members for each gender."], "gold_sql": "SELECT sex ,  count(*) FROM Faculty WHERE rank  =  'AsstProf' GROUP BY sex", "source_tables": ["faculty"], "pred_sql": "SELECT Sex, COUNT(*) as count FROM Faculty WHERE Rank = 'Assistant Professor' GROUP BY Sex;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the last names of faculty members who hold a specific academic rank but do not participate in certain activities. The placeholders in the query represent the rank of the faculty and the names of the activities they do not participate in.\",\n        \"virtual_table\": \"SELECT lname FROM faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6750", "db_id": "activity_1", "question": "Who is the advisor of Linda Smith? Give me the first name and last name.", "rationale": ["Identify the relevant table: The Student table contains information about students, including their advisors.", "Determine the columns needed: We need the Advisor column to find out who Linda Smith's advisor is.", "Filter the results: We need to specify the first name and last name of the student to get the correct advisor.", "Construct the SQL query: Use a SELECT statement to retrieve the Advisor for the student with the specified first and last name."], "gold_sql": "SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T2.fname  =  'Linda' AND T2.lname  =  'Smith'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT Advisor FROM Student WHERE Fname = 'Linda' AND LName = 'Smith';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the last names of faculty members who hold a specific academic rank but do not participate in certain activities. The placeholders in the query represent the rank of the faculty and the names of the activities they do not participate in.\",\n        \"virtual_table\": \"SELECT lname FROM faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6751", "db_id": "activity_1", "question": "Show the ids of students whose advisors are professors.", "rationale": ["Identify the relevant tables: We need to find students and their advisors, which involves the Student and Faculty tables.", "Determine the relationship: The Student table has a column 'Advisor' that references 'FacID' in the Faculty table, indicating which faculty member is the advisor for each student.", "Construct the SQL query: We will select the distinct student IDs (StuID) from the Student table where the Advisor matches the FacID in the Faculty table."], "gold_sql": "SELECT T2.StuID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.rank  =  'Professor'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT DISTINCT Student.StuID \nFROM Student \nJOIN Faculty ON Student.Advisor = Faculty.FacID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the last names of faculty members who hold a specific academic rank but do not participate in certain activities. The placeholders in the query represent the rank of the faculty and the names of the activities they do not participate in.\",\n        \"virtual_table\": \"SELECT lname FROM faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6753", "db_id": "activity_1", "question": "Show first name and last name for all the students advised by Michael Goodrich.", "rationale": ["Identify the relevant tables: We need to retrieve student information, which is in the 'Student' table, and we need to filter based on the advisor, which is linked to the 'Faculty' table.", "Determine the relationship: The 'Advisor' column in the 'Student' table corresponds to the 'FacID' in the 'Faculty' table. We need to find the 'FacID' for Michael Goodrich.", "Construct a subquery: We will create a subquery to find the 'FacID' of Michael Goodrich using his first and last name.", "Use the subquery in the main query: The main query will select the first name and last name of students whose 'Advisor' matches the 'FacID' obtained from the subquery."], "gold_sql": "SELECT T2.fname ,  T2.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.fname  =  'Michael' AND T1.lname  =  'Goodrich'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT Fname, LName FROM Student WHERE Advisor = (SELECT StuID FROM Faculty WHERE Fname = 'Michael' AND Lname = 'Goodrich')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the last names of faculty members who hold a specific academic rank but do not participate in certain activities. The placeholders in the query represent the rank of the faculty and the names of the activities they do not participate in.\",\n        \"virtual_table\": \"SELECT lname FROM faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6759", "db_id": "activity_1", "question": "What are the first and last name of the faculty who has the most students?", "rationale": ["Identify the tables involved: Faculty, Faculty_Participates_in, and Participates_in.", "We need to find the faculty members and the number of students they have, which requires joining the Faculty table with the Faculty_Participates_in table and then with the Participates_in table.", "Use GROUP BY to group the results by faculty member (using FacID) to count the number of students associated with each faculty member.", "Order the results by the count of students in descending order to find the faculty member with the most students.", "Limit the results to 1 to get only the faculty member with the highest count."], "gold_sql": "SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID ORDER BY count(*) DESC LIMIT 1", "source_tables": ["faculty", "student"], "pred_sql": "SELECT F.Fname, F.Lname \nFROM Faculty AS F \nJOIN Faculty_Participates_in AS FP ON F.FacID = FP.FacID \nJOIN Participates_in AS P ON FP.actid = P.actid \nGROUP BY F.FacID \nORDER BY COUNT(P.stuid) DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the last names of faculty members who hold a specific academic rank but do not participate in certain activities. The placeholders in the query represent the rank of the faculty and the names of the activities they do not participate in.\",\n        \"virtual_table\": \"SELECT lname FROM faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6765", "db_id": "activity_1", "question": "What activities do we have?", "rationale": ["The question asks for a list of activities, which corresponds to the 'activity_name' column in the 'Activity' table.", "To retrieve the names of all activities, we need to select the 'activity_name' from the 'Activity' table without any conditions or joins, as we are not filtering by any specific criteria."], "gold_sql": "SELECT activity_name FROM Activity", "source_tables": ["activity"], "pred_sql": "SELECT activity_name FROM Activity;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of activities in which a specific faculty member participates. The placeholders in the WHERE clause represent the first and last names of the faculty member.\",\n        \"virtual_table\": \"SELECT T3.activity_name FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN Activity AS T3 ON T3.actid  =  T2.actid WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6766", "db_id": "activity_1", "question": "List all the activities we have.", "rationale": ["The task is to list all the activities available in the database.", "To achieve this, we need to select the 'activity_name' column from the 'Activity' table.", "Since we want all activities, we do not need any filtering or joining with other tables.", "The SQL query will simply be: SELECT activity_name FROM Activity."], "gold_sql": "SELECT activity_name FROM Activity", "source_tables": ["activity"], "pred_sql": "SELECT activity_name FROM Activity;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of activities in which a specific faculty member participates. The placeholders in the WHERE clause represent the first and last names of the faculty member.\",\n        \"virtual_table\": \"SELECT T3.activity_name FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN Activity AS T3 ON T3.actid  =  T2.actid WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6780", "db_id": "activity_1", "question": "What is the first and last name of the faculty members who participated in at least one activity? For each of them, also show the number of activities they participated in.", "rationale": ["Identify the relevant tables: Faculty and Faculty_Participates_in.", "We need to select the first name (Fname) and last name (Lname) of faculty members from the Faculty table.", "We also need to count the number of activities each faculty member participated in, which is represented by the actid in the Faculty_Participates_in table.", "Join the Faculty table with the Faculty_Participates_in table on the FacID to link faculty members with their activities.", "Group the results by the faculty member's ID (FacID) to aggregate the count of activities.", "Use the COUNT function to count the number of activities for each faculty member.", "Use HAVING clause to filter out faculty members who have participated in at least one activity."], "gold_sql": "SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID", "source_tables": ["faculty", "faculty_participates_in"], "pred_sql": "SELECT F.Fname, F.Lname, COUNT(FPI.actid) AS activity_count\nFROM Faculty AS F\nJOIN Faculty_Participates_in AS FPI ON F.FacID = FPI.FacID\nGROUP BY F.FacID\nHAVING COUNT(FPI.actid) > 0;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of activities in which a specific faculty member participates. The placeholders in the WHERE clause represent the first and last names of the faculty member.\",\n        \"virtual_table\": \"SELECT T3.activity_name FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN Activity AS T3 ON T3.actid  =  T2.actid WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6781", "db_id": "activity_1", "question": "Show all the activity names and the number of faculty involved in each activity.", "rationale": ["We need to show all activity names and the number of faculty involved in each activity.", "To achieve this, we will select the 'activity_name' from the 'Activity' table.", "We will also need to count the number of faculty members participating in each activity, which can be done using the COUNT function on the 'FacID' from the 'Faculty_Participates_in' table.", "To link the two tables, we will perform a LEFT JOIN between 'Activity' and 'Faculty_Participates_in' on the 'actid' column.", "Finally, we will group the results by 'activity_name' to get the count of faculty for each activity."], "gold_sql": "SELECT T1.activity_name ,  count(*) FROM Activity AS T1 JOIN Faculty_participates_in AS T2 ON T1.actID  =  T2.actID GROUP BY T1.actID", "source_tables": ["activity", "faculty_participates_in"], "pred_sql": "SELECT A.activity_name, COUNT(FP.FacID) AS faculty_count\nFROM Activity AS A\nLEFT JOIN Faculty_Participates_in AS FP ON A.actid = FP.actid\nGROUP BY A.activity_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of activities in which a specific faculty member participates. The placeholders in the WHERE clause represent the first and last names of the faculty member.\",\n        \"virtual_table\": \"SELECT T3.activity_name FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN Activity AS T3 ON T3.actid  =  T2.actid WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6782", "db_id": "activity_1", "question": "How many faculty members participate in each activity? Return the activity names and the number of faculty members.", "rationale": ["Identify the tables needed: We need the Activity table for activity names and the Faculty_Participates_in table to count faculty participation.", "Join the Activity table with the Faculty_Participates_in table on the activity ID (actid) to link activities with their participating faculty members.", "Use a LEFT JOIN to ensure we include all activities, even those with no faculty participation.", "Group the results by activity name to count the number of faculty members participating in each activity.", "Select the activity name and the count of faculty members as the final output."], "gold_sql": "SELECT T1.activity_name ,  count(*) FROM Activity AS T1 JOIN Faculty_participates_in AS T2 ON T1.actID  =  T2.actID GROUP BY T1.actID", "source_tables": ["activity", "faculty_participates_in"], "pred_sql": "SELECT A.activity_name, COUNT(FP.FacID) AS faculty_count\nFROM Activity AS A\nLEFT JOIN Faculty_Participates_in AS FP ON A.actid = FP.actid\nGROUP BY A.activity_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of activities in which a specific faculty member participates. The placeholders in the WHERE clause represent the first and last names of the faculty member.\",\n        \"virtual_table\": \"SELECT T3.activity_name FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN Activity AS T3 ON T3.actid  =  T2.actid WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6789", "db_id": "activity_1", "question": "Show the ids for all the students who participate in an activity and are under 20.", "rationale": ["Identify the relevant tables: We need to find students who participate in activities, so we will use the 'Participates_in' table to get student IDs and the 'Student' table to filter by age.", "Join the 'Participates_in' table with the 'Student' table on the student ID to access student details while keeping the participation records.", "Filter the results to include only those students whose age is less than 20.", "Select the student IDs from the filtered results."], "gold_sql": "SELECT StuID FROM Participates_in INTERSECT SELECT StuID FROM Student WHERE age  <  20", "source_tables": ["student", "participates_in"], "pred_sql": "SELECT P.stuid FROM Participates_in AS P JOIN Student AS S ON P.stuid = S.StuID WHERE S.Age < 20;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of activities in which a specific faculty member participates. The placeholders in the WHERE clause represent the first and last names of the faculty member.\",\n        \"virtual_table\": \"SELECT T3.activity_name FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN Activity AS T3 ON T3.actid  =  T2.actid WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6795", "db_id": "activity_1", "question": "Find the first names of the faculty members who are playing Canoeing or Kayaking.", "rationale": ["Identify the tables involved: Faculty, Faculty_Participates_in, and Activity.", "We need to find faculty members, so we start with the Faculty table.", "Join Faculty with Faculty_Participates_in on FacID to link faculty members to their activities.", "Join the result with Activity on actid to get the names of the activities.", "Filter the results to include only those activities that are either 'Canoeing' or 'Kayaking'.", "Select the first names of the faculty members from the filtered results."], "gold_sql": "SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT F.Fname FROM Faculty AS F JOIN Faculty_Participates_in AS FP ON F.FacID = FP.FacID JOIN Activity AS A ON A.actid = FP.actid WHERE A.activity_name IN ('Canoeing', 'Kayaking')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of activities in which a specific faculty member participates. The placeholders in the WHERE clause represent the first and last names of the faculty member.\",\n        \"virtual_table\": \"SELECT T3.activity_name FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN Activity AS T3 ON T3.actid  =  T2.actid WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6796", "db_id": "activity_1", "question": "Which faculty members are playing either Canoeing or Kayaking? Tell me their first names.", "rationale": ["Identify the relevant tables: Faculty, Faculty_Participates_in, and Activity.", "We need to join these tables to find faculty members participating in specific activities.", "The join condition will be based on the foreign keys: Faculty.FacID with Faculty_Participates_in.FacID and Activity.actid with Faculty_Participates_in.actid.", "We are interested in the first names of faculty members, so we will select F.Fname.", "The WHERE clause will filter the activities to only include 'Canoeing' or 'Kayaking' using the IN operator."], "gold_sql": "SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT F.Fname FROM Faculty AS F JOIN Faculty_Participates_in AS FP ON F.FacID = FP.FacID JOIN Activity AS A ON A.actid = FP.actid WHERE A.activity_name IN ('Canoeing', 'Kayaking')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of activities in which a specific faculty member participates. The placeholders in the WHERE clause represent the first and last names of the faculty member.\",\n        \"virtual_table\": \"SELECT T3.activity_name FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN Activity AS T3 ON T3.actid  =  T2.actid WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6798", "db_id": "activity_1", "question": "What are the first names of the professors who do not play Canoeing or Kayaking as activities?", "rationale": ["Identify the main goal: to find the first names of professors who do not participate in Canoeing or Kayaking.", "Use the Faculty table to get the first names of all faculty members.", "Use the Faculty_Participates_in table to find faculty members who participate in specific activities.", "Join the Faculty table with the Faculty_Participates_in table and the Activity table to filter out those who participate in Canoeing or Kayaking.", "Use the EXCEPT clause to subtract the list of faculty members who participate in Canoeing or Kayaking from the list of all faculty members."], "gold_sql": "SELECT lname FROM faculty WHERE rank  =  'Professor' EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT F.Fname FROM Faculty AS F EXCEPT SELECT DISTINCT F1.Fname FROM Faculty AS F1 JOIN Faculty_Participates_in AS FP ON F1.FacID = FP.FacID JOIN Activity AS A ON FP.actid = A.actid WHERE A.activity_name = 'Canoeing' OR A.activity_name = 'Kayaking';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the last names of faculty members who hold a specific academic rank but do not participate in certain activities. The placeholders in the query represent the rank of the faculty and the names of the activities they do not participate in.\",\n        \"virtual_table\": \"SELECT lname FROM faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6801", "db_id": "activity_1", "question": "Find the ids of the students who participate in Canoeing and Kayaking.", "rationale": ["Identify the relevant tables: We need to find students participating in specific activities, so we will use the 'Participates_in' and 'Activity' tables.", "Determine the relationship: The 'Participates_in' table contains student IDs and activity IDs, while the 'Activity' table contains activity names and IDs. We will join these tables on the 'actid' column.", "Specify the activities: We are interested in students who participate in 'Canoeing' and 'Kayaking'.", "Construct the SQL query: We will select the student IDs from the 'Participates_in' table where the corresponding activity name in the 'Activity' table matches either 'Canoeing' or 'Kayaking'."], "gold_sql": "SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  'Canoeing' INTERSECT SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  'Kayaking'", "source_tables": ["activity", "participates_in"], "pred_sql": "SELECT P.stuid FROM Participates_in AS P JOIN Activity AS A ON P.actid = A.actid WHERE A.activity_name IN ('Canoeing', 'Kayaking');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of activities in which a specific faculty member participates. The placeholders in the WHERE clause represent the first and last names of the faculty member.\",\n        \"virtual_table\": \"SELECT T3.activity_name FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN Activity AS T3 ON T3.actid  =  T2.actid WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.95", "db_id": "car_1", "question": "Which model of the car has the minimum horsepower?", "rationale": ["Identify the relevant tables: model_list, car_names, and cars_data are needed to find car models and their horsepower.", "Join the model_list table with the car_names table to get the model names associated with each car maker.", "Join the resulting table with the cars_data table to access the horsepower of each car model.", "Use the ORDER BY clause to sort the results by horsepower in ascending order.", "Limit the results to 1 to get the model with the minimum horsepower."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT T2.Model FROM model_list AS T1 JOIN car_names AS T2 ON T1.Model = T2.Model JOIN cars_data AS T3 ON T2.MakeId = T3.Id ORDER BY T3.Horsepower ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.97", "db_id": "car_1", "question": "Find the model of the car whose weight is below the average weight.", "rationale": ["Identify the relevant tables: model_list, car_names, and cars_data are needed to find car models and their weights.", "Join the model_list table with the car_names table to get the model names associated with each car maker.", "Join the resulting table with the cars_data table to access the weight of each car model.", "Use a subquery to calculate the average weight of all cars in the cars_data table.", "Filter the results to include only those car models whose weight is below the average weight calculated in the subquery."], "gold_sql": "SELECT T1.model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Weight  <  (SELECT avg(Weight) FROM CARS_DATA)", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT DISTINCT T2.Model FROM model_list AS T1 JOIN car_names AS T2 ON T1.Model = T2.Model JOIN cars_data AS T3 ON T2.MakeId = T3.Id WHERE T3.Weight < (SELECT AVG(Weight) FROM cars_data);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.111", "db_id": "car_1", "question": "What is the accelerate of the car make amc hornet sportabout (sw)?", "rationale": ["Identify the relevant tables: model_list, car_names, and cars_data are needed to find the accelerate of the specified car make.", "Join the model_list table with the car_names table on the Model column to link car models with their makes.", "Join the resulting table with the cars_data table on the MakeId to access the accelerate data.", "Filter the results by specifying the car make 'amc hornet sportabout (sw)' in the WHERE clause."], "gold_sql": "SELECT T1.Accelerate FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Make  =  'amc hornet sportabout (sw)';", "source_tables": ["cars_data", "car_names"], "pred_sql": "SELECT T3.Accelerate FROM model_list AS T1 JOIN car_names AS T2 ON T1.Model = T2.Model JOIN cars_data AS T3 ON T2.MakeId = T3.Id WHERE T2.Make = 'amc hornet sportabout (sw)';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.112", "db_id": "car_1", "question": "How much does the car accelerate that makes amc hornet sportabout (sw)?", "rationale": ["Identify the car model 'amc hornet sportabout (sw)' from the car_names table.", "Join the car_names table with the model_list table to get the corresponding model details.", "Join the resulting table with the cars_data table to access the acceleration data.", "Filter the results to only include the specific car model 'amc hornet sportabout (sw)'.", "Select the 'Accelerate' column from the cars_data table to get the acceleration time."], "gold_sql": "SELECT T1.Accelerate FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Make  =  'amc hornet sportabout (sw)';", "source_tables": ["cars_data", "car_names"], "pred_sql": "SELECT T3.Accelerate FROM model_list AS T1 JOIN car_names AS T2 ON T1.Model = T2.Model JOIN cars_data AS T3 ON T2.MakeId = T3.Id WHERE T2.Make = 'amc hornet sportabout (sw)';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.113", "db_id": "car_1", "question": "How many car makers are there in france?", "rationale": ["Identify the relevant tables: car_makers and countries.", "We need to count the number of car makers in France, so we will filter the countries table for France.", "Join the car_makers table with the countries table on the country identifier.", "Use the COUNT function to count the number of car makers where the country is France."], "gold_sql": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  'france';", "source_tables": ["car_makers", "countries"], "pred_sql": "SELECT COUNT(*) FROM car_makers AS T3 JOIN countries AS T2 ON T3.Country = T2.CountryId WHERE T2.CountryName = 'France';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of car makers associated with each continent by joining the 'continents', 'countries', and 'car_makers' tables. The placeholder in the SELECT statement represents the continent's name, and the count function aggregates the number of car makers per continent.\",\n        \"virtual_table\": \"SELECT T1.Continent ,  count(*) FROM CONTINENTS AS T1 JOIN COUNTRIES AS T2 ON T1.ContId  =  T2.continent JOIN car_makers AS T3 ON T2.CountryId  =  T3.Country GROUP BY T1.Continent;\"\n    }\n}\n"}
{"sample_id": "dev.121", "db_id": "car_1", "question": "What are all the makers and models?", "rationale": ["The user wants to retrieve all car makers and their respective models.", "To get the makers and models, we need to join the 'model_list' table with the 'car_names' table to link models with their makers.", "We also need to ensure that we are selecting distinct combinations of makers and models to avoid duplicates.", "The final SQL query will select the distinct 'Make' from 'car_names' and 'Model' from 'model_list' after performing the necessary joins."], "gold_sql": "SELECT Maker ,  Model FROM MODEL_LIST;", "source_tables": ["model_list"], "pred_sql": "SELECT DISTINCT T2.Make, T1.Model FROM model_list AS T1 JOIN car_names AS T2 ON T1.Model = T2.Model JOIN cars_data AS T3 ON T2.MakeId = T3.Id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.129", "db_id": "car_1", "question": "Which countries in europe have at least 3 car manufacturers?", "rationale": ["Identify the relevant tables: countries and car_makers.", "We need to filter countries that belong to Europe, so we will join the countries table with the continents table.", "Count the number of car manufacturers for each country by joining the car_makers table.", "Group the results by country name to aggregate the count of car manufacturers.", "Use the HAVING clause to filter countries that have at least 3 car manufacturers."], "gold_sql": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  'europe' GROUP BY T1.CountryName HAVING count(*)  >=  3;", "source_tables": ["continents", "car_makers", "countries"], "pred_sql": "SELECT T2.CountryName FROM COUNTRIES AS T2 JOIN car_makers AS T3 ON T2.CountryId = T3.Country JOIN CONTINENTS AS T1 ON T2.Continent = T1.ContId WHERE T1.Continent = 'Europe' GROUP BY T2.CountryName HAVING COUNT(T3.Id) >= 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of car makers associated with each continent by joining the 'continents', 'countries', and 'car_makers' tables. The placeholder in the SELECT statement represents the continent's name, and the count function aggregates the number of car makers per continent.\",\n        \"virtual_table\": \"SELECT T1.Continent ,  count(*) FROM CONTINENTS AS T1 JOIN COUNTRIES AS T2 ON T1.ContId  =  T2.continent JOIN car_makers AS T3 ON T2.CountryId  =  T3.Country GROUP BY T1.Continent;\"\n    }\n}\n"}
{"sample_id": "dev.130", "db_id": "car_1", "question": "What are the names of all European countries with at least 3 manufacturers?", "rationale": ["Identify the relevant tables: countries, car_makers, and continents.", "We need to filter for European countries, so we will join the continents table to get the continent name.", "Count the number of car manufacturers for each country by joining the countries and car_makers tables.", "Group the results by country and use the HAVING clause to filter for countries with at least 3 manufacturers.", "Select the country names from the countries table based on the filtered results."], "gold_sql": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  'europe' GROUP BY T1.CountryName HAVING count(*)  >=  3;", "source_tables": ["continents", "car_makers", "countries"], "pred_sql": "SELECT T2.CountryName FROM COUNTRIES AS T2 JOIN (SELECT T2.Country, COUNT(*) AS MakerCount FROM COUNTRIES AS T2 JOIN car_makers AS T3 ON T2.CountryId = T3.Country JOIN continents AS T1 ON T2.Continent = T1.ContId WHERE T1.Continent = 'Europe' GROUP BY T2.Country HAVING COUNT(*) >= 3) AS T1 ON T2.CountryId = T1.Country;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of car makers associated with each continent by joining the 'continents', 'countries', and 'car_makers' tables. The placeholder in the SELECT statement represents the continent's name, and the count function aggregates the number of car makers per continent.\",\n        \"virtual_table\": \"SELECT T1.Continent ,  count(*) FROM CONTINENTS AS T1 JOIN COUNTRIES AS T2 ON T1.ContId  =  T2.continent JOIN car_makers AS T3 ON T2.CountryId  =  T3.Country GROUP BY T1.Continent;\"\n    }\n}\n"}
{"sample_id": "dev.131", "db_id": "car_1", "question": "What is the maximum horsepower and the make of the car models with 3 cylinders?", "rationale": ["Identify the relevant tables: 'cars_data', 'car_names', and 'model_list' are needed to get horsepower, make, and filter by cylinders.", "We need to find the maximum horsepower, so we will use the MAX() function on the 'Horsepower' column from the 'cars_data' table.", "We will join 'cars_data' with 'car_names' on the 'Id' and 'MakeId' columns to get the make of the car.", "Next, we will join 'car_names' with 'model_list' to ensure we are working with the correct models.", "We will filter the results to include only those cars that have 3 cylinders by adding a WHERE clause.", "Finally, we will select the maximum horsepower and the make of the car models."], "gold_sql": "SELECT T2.horsepower ,  T1.Make FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.cylinders  =  3 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT MAX(cars_data.Horsepower) AS MaxHorsepower, car_names.Make \nFROM cars_data \nJOIN car_names ON cars_data.Id = car_names.MakeId \nJOIN model_list ON car_names.Model = model_list.Model \nWHERE cars_data.Cylinders = 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.141", "db_id": "car_1", "question": "Which model has the most version(make) of cars?", "rationale": ["We need to find the car model that has the most versions (makes) of cars.", "To do this, we will join the 'model_list' table with the 'car_names' table to get the makes associated with each model.", "Next, we will join with the 'cars_data' table to ensure we are counting the versions of cars for each model.", "We will group the results by the car model and count the number of distinct makes for each model.", "Finally, we will order the results in descending order based on the count of makes and limit the result to 1 to get the model with the most versions."], "gold_sql": "SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["car_names"], "pred_sql": "SELECT T1.Model, COUNT(T2.Make) AS VersionCount\nFROM model_list AS T1\nJOIN car_names AS T2 ON T1.Model = T2.Model\nJOIN cars_data AS T3 ON T2.MakeId = T3.Id\nGROUP BY T1.Model\nORDER BY VersionCount DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.142", "db_id": "car_1", "question": "What model has the most different versions?", "rationale": ["We need to find the car model that has the most different versions.", "To do this, we will join the 'model_list' table with the 'car_names' table to get the models and their respective makes.", "Next, we will join with the 'cars_data' table to count the number of entries for each model, which represents the different versions.", "We will group the results by the model name to aggregate the counts.", "Finally, we will order the results in descending order based on the count of versions and limit the output to 1 to get the model with the most versions."], "gold_sql": "SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["car_names"], "pred_sql": "SELECT T1.Model, COUNT(*) AS VersionCount\nFROM model_list AS T1\nJOIN car_names AS T2 ON T1.Model = T2.Model\nJOIN cars_data AS T3 ON T2.MakeId = T3.Id\nGROUP BY T1.Model\nORDER BY VersionCount DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.150", "db_id": "car_1", "question": "What are the names and ids of all makers with more than 3 models?", "rationale": ["We need to find the names and ids of car makers with more than 3 models.", "To do this, we will join the 'car_makers' table with the 'model_list' table on the car maker's ID.", "We will group the results by the car maker's ID and name to aggregate the models associated with each maker.", "Using the HAVING clause, we will filter the groups to include only those with a count of models greater than 3."], "gold_sql": "SELECT T1.FullName ,  T1.Id FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >  3;", "source_tables": ["car_makers", "model_list"], "pred_sql": "SELECT car_makers.Id, car_makers.Maker \nFROM car_makers \nJOIN model_list ON car_makers.Id = model_list.Maker \nGROUP BY car_makers.Id, car_makers.Maker \nHAVING COUNT(model_list.ModelId) > 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.161", "db_id": "car_1", "question": "How many countries has more than 2 car makers ?", "rationale": ["We need to find the number of countries that have more than 2 car makers.", "To do this, we will join the 'countries' table with the 'car_makers' table on the country identifier.", "We will group the results by country and count the number of car makers for each country.", "Using the HAVING clause, we will filter the groups to include only those countries that have more than 2 car makers.", "Finally, we will count the number of countries that meet this criterion."], "gold_sql": "select count(*) from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  2", "source_tables": ["car_makers", "countries"], "pred_sql": "SELECT COUNT(*) FROM (SELECT T2.Country, COUNT(*) as MakerCount FROM countries AS T2 JOIN car_makers AS T3 ON T2.CountryId = T3.Country GROUP BY T2.Country HAVING MakerCount > 2);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of car makers associated with each continent by joining the 'continents', 'countries', and 'car_makers' tables. The placeholder in the SELECT statement represents the continent's name, and the count function aggregates the number of car makers per continent.\",\n        \"virtual_table\": \"SELECT T1.Continent ,  count(*) FROM CONTINENTS AS T1 JOIN COUNTRIES AS T2 ON T1.ContId  =  T2.continent JOIN car_makers AS T3 ON T2.CountryId  =  T3.Country GROUP BY T1.Continent;\"\n    }\n}\n"}
{"sample_id": "dev.165", "db_id": "car_1", "question": "For the cars with 4 cylinders, which model has the largest horsepower?", "rationale": ["Identify the relevant tables: cars_data, car_names, model_list, and car_makers.", "We need to filter cars based on the number of cylinders, specifically those with 4 cylinders.", "We want to find the model with the largest horsepower, so we will order the results by horsepower in descending order.", "To get the model name, we will join the cars_data table with the car_names table using the MakeId.", "Next, we join the model_list table to get the model associated with the car maker.", "Finally, we will limit the results to 1 to get the model with the highest horsepower."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  4 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT Model, Horsepower FROM cars_data AS CD JOIN car_names AS CN ON CD.Id = CN.MakeId JOIN model_list AS ML ON CN.Model = ML.Model JOIN car_makers AS CM ON ML.Maker = CM.Id WHERE CD.Cylinders = 4 ORDER BY CD.Horsepower DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of car models from the 'model_list' table that are associated with car makers from a specific country. The placeholders in the WHERE clause represent the name of the country being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "dev.171", "db_id": "car_1", "question": "Which models are lighter than 3500 but not built by the 'Ford Motor Company'?", "rationale": ["Identify the relevant tables: model_list, car_names, cars_data, and car_makers are needed to get the car models, their makes, and their weights.", "Join the model_list table with the car_names table to get the model names associated with each maker.", "Join the resulting table with the cars_data table to access the weight of each car model.", "Join with the car_makers table to filter out models made by 'Ford Motor Company'.", "Use a WHERE clause to filter for models that are lighter than 3500 pounds and not made by 'Ford Motor Company'.", "Select distinct models to avoid duplicates in the results."], "gold_sql": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.Model  =  T2.Model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.Id JOIN CAR_MAKERS AS T4 ON T1.Maker  =  T4.Id WHERE T3.weight  <  3500 AND T4.FullName != 'Ford Motor Company';", "source_tables": ["car_makers", "model_list", "car_names", "cars_data"], "pred_sql": "SELECT DISTINCT T2.Model \nFROM model_list AS T1 \nJOIN car_names AS T2 ON T1.Model = T2.Model \nJOIN cars_data AS T3 ON T2.MakeId = T3.Id \nJOIN car_makers AS T4 ON T1.Maker = T4.Id \nWHERE T3.Weight < 3500 \nAND T4.FullName != 'Ford Motor Company';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.175", "db_id": "car_1", "question": "Which are the car makers which produce at least 2 models and more than 3 car makers ? List the id and the maker .", "rationale": ["Identify the requirement to find car makers that produce at least 2 models.", "Use the 'model_list' table to group by 'Maker' and count the number of models for each maker, applying a HAVING clause to filter those with at least 2 models.", "Next, identify the requirement to find car makers that have more than 3 car makers in total.", "Use the 'car_makers' table to group by 'Id' and count the number of makers, applying a HAVING clause to filter those with more than 3.", "Combine these two conditions using an IN clause to filter the 'car_makers' table for those that meet both criteria."], "gold_sql": "select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker group by t1.id having count(*)  >=  2 intersect select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker join car_names as t3 on t2.model  =  t3.model group by t1.id having count(*)  >  3;", "source_tables": ["car_makers", "car_names", "model_list"], "pred_sql": "SELECT Id, Maker FROM car_makers WHERE Id IN (SELECT Maker FROM model_list GROUP BY Maker HAVING COUNT(ModelId) >= 2) AND Id IN (SELECT Id FROM car_makers GROUP BY Id HAVING COUNT(Id) > 3);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of car makers associated with each continent by joining the 'continents', 'countries', and 'car_makers' tables. The placeholder in the SELECT statement represents the continent's name, and the count function aggregates the number of car makers per continent.\",\n        \"virtual_table\": \"SELECT T1.Continent ,  count(*) FROM CONTINENTS AS T1 JOIN COUNTRIES AS T2 ON T1.ContId  =  T2.continent JOIN car_makers AS T3 ON T2.CountryId  =  T3.Country GROUP BY T1.Continent;\"\n    }\n}\n"}
{"sample_id": "dev.176", "db_id": "car_1", "question": "What are the ids and makers of all car makers that produce at least 2 models and make more than 3 cars?", "rationale": ["Identify the relevant tables: car_makers, model_list, car_names, and cars_data.", "We need to find car makers that produce at least 2 models, so we will join car_makers with model_list on the Maker ID.", "Next, we will join model_list with car_names to get the MakeId for each model.", "Then, we will join car_names with cars_data to count the number of cars produced by each maker.", "We will group the results by car maker's ID and name to aggregate the counts.", "Use the HAVING clause to filter for car makers that have at least 2 distinct models and more than 3 cars."], "gold_sql": "SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >=  2 INTERSECT SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker JOIN CAR_NAMES AS T3 ON T2.model  =  T3.model GROUP BY T1.Id HAVING count(*)  >  3;", "source_tables": ["car_makers", "car_names", "model_list"], "pred_sql": "SELECT cm.Id, cm.Maker \nFROM car_makers AS cm \nJOIN model_list AS ml ON cm.Id = ml.Maker \nJOIN car_names AS cn ON ml.Model = cn.Model \nJOIN cars_data AS cd ON cn.MakeId = cd.Id \nGROUP BY cm.Id, cm.Maker \nHAVING COUNT(DISTINCT ml.Model) >= 2 AND COUNT(cd.Id) > 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of car makers associated with each continent by joining the 'continents', 'countries', and 'car_makers' tables. The placeholder in the SELECT statement represents the continent's name, and the count function aggregates the number of car makers per continent.\",\n        \"virtual_table\": \"SELECT T1.Continent ,  count(*) FROM CONTINENTS AS T1 JOIN COUNTRIES AS T2 ON T1.ContId  =  T2.continent JOIN car_makers AS T3 ON T2.CountryId  =  T3.Country GROUP BY T1.Continent;\"\n    }\n}\n"}
{"sample_id": "dev.526", "db_id": "student_transcripts_tracking", "question": "What are the names and ids of every course with less than 2 sections?", "rationale": ["Identify the relevant tables: Courses and Sections.", "We need to find courses that have less than 2 sections, so we will join the Courses table with the Sections table on the course_id.", "Use a LEFT JOIN to ensure we include courses that may not have any sections at all.", "Group the results by course_id to aggregate the sections for each course.", "Use the HAVING clause to filter groups where the count of sections is less than 2."], "gold_sql": "SELECT T1.course_name ,  T1.course_id FROM Courses AS T1 JOIN Sections AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_id HAVING count(*)  <=  2", "source_tables": ["courses", "sections"], "pred_sql": "SELECT Courses.course_id, Courses.course_name\nFROM Courses\nLEFT JOIN Sections ON Courses.course_id = Sections.course_id\nGROUP BY Courses.course_id\nHAVING COUNT(Sections.section_id) < 2;", "hint": "\n"}
{"sample_id": "dev.534", "db_id": "student_transcripts_tracking", "question": "What are the first, middle, and last names, along with the ids, of all students who enrolled in 2 degree programs in one semester?", "rationale": ["Identify the relevant tables: Students, Student_Enrolment, and Degree_Programs are needed to get student names and their degree program enrollments.", "Join the Students table with the Student_Enrolment table to link students with their enrollments.", "Join the Student_Enrolment table with the Degree_Programs table to ensure we can filter by degree programs if needed.", "Use a subquery to find students who are enrolled in exactly 2 distinct degree programs within the same semester.", "The subquery groups by student_id and semester_id and counts the distinct degree_program_id, filtering for those with a count of 2.", "Select the student_id, first_name, middle_name, and last_name from the main query based on the results of the subquery."], "gold_sql": "SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  2", "source_tables": ["student_enrolment", "students"], "pred_sql": "SELECT S.student_id, S.first_name, S.middle_name, S.last_name \nFROM Students AS S \nJOIN Student_Enrolment AS SE ON S.student_id = SE.student_id \nJOIN Degree_Programs AS DP ON SE.degree_program_id = DP.degree_program_id \nWHERE SE.semester_id IN (\n    SELECT semester_id \n    FROM Student_Enrolment \n    GROUP BY student_id, semester_id \n    HAVING COUNT(DISTINCT degree_program_id) = 2\n)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholder in the WHERE clause represents the name of the degree program.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.535", "db_id": "student_transcripts_tracking", "question": "Who is enrolled in a Bachelor degree program? List the first name, middle name, last name.", "rationale": ["Identify the tables needed: Students, Student_Enrolment, and Degree_Programs.", "Determine the columns to select: first_name, middle_name, last_name from Students.", "Establish the relationships between the tables using JOINs: Students to Student_Enrolment on student_id, and Student_Enrolment to Degree_Programs on degree_program_id.", "Filter the results to only include students enrolled in a Bachelor degree program using a WHERE clause."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  'Bachelor'", "source_tables": ["student_enrolment", "degree_programs", "students"], "pred_sql": "SELECT DISTINCT T1.first_name, T1.middle_name, T1.last_name \nFROM Students AS T1 \nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id \nJOIN Degree_Programs AS T3 ON T2.degree_program_id = T3.degree_program_id \nWHERE T3.degree_summary_name = 'Bachelor'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholder in the WHERE clause represents the name of the degree program.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.539", "db_id": "student_transcripts_tracking", "question": "Find the program which most number of students are enrolled in. List both the id and the summary.", "rationale": ["Identify the relevant tables: Degree_Programs and Student_Enrolment are needed to find the degree programs and their enrolled students.", "Join the Degree_Programs table with the Student_Enrolment table on the degree_program_id to associate students with their respective programs.", "Use COUNT() to count the number of students enrolled in each degree program.", "Group the results by degree_program_id and degree_summary_name to aggregate the student counts for each program.", "Order the results by the student count in descending order to find the program with the most students.", "Limit the results to 1 to get only the program with the highest enrollment."], "gold_sql": "SELECT T1.degree_program_id ,  T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_program_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "degree_programs"], "pred_sql": "SELECT dp.degree_program_id, dp.degree_summary_name, COUNT(se.student_enrolment_id) AS student_count\nFROM Degree_Programs AS dp\nJOIN Student_Enrolment AS se ON dp.degree_program_id = se.degree_program_id\nGROUP BY dp.degree_program_id, dp.degree_summary_name\nORDER BY student_count DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholder in the WHERE clause represents the name of the degree program.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.541", "db_id": "student_transcripts_tracking", "question": "Which student has enrolled for the most times in any program? List the id, first name, middle name, last name, the number of enrollments and student id.", "rationale": ["Identify the relevant tables: Students and Student_Enrolment are needed to find student details and their enrollment counts.", "Join the Students table with the Student_Enrolment table on the student_id to link students with their enrollments.", "Use COUNT() to count the number of enrollments for each student.", "Group the results by student_id to aggregate the enrollment counts for each student.", "Order the results by the count of enrollments in descending order to find the student with the most enrollments.", "Limit the results to 1 to get only the student with the highest enrollment count."], "gold_sql": "SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "students"], "pred_sql": "SELECT S.student_id, S.first_name, S.middle_name, S.last_name, COUNT(SE.student_enrolment_id) AS number_of_enrollments\nFROM Students AS S\nJOIN Student_Enrolment AS SE ON S.student_id = SE.student_id\nGROUP BY S.student_id\nORDER BY number_of_enrollments DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholder in the WHERE clause represents the name of the degree program.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.547", "db_id": "student_transcripts_tracking", "question": "What's the name of the course with most number of enrollments?", "rationale": ["Identify the relevant tables: Courses and Student_Enrolment_Courses are needed to find course names and their enrollments.", "Join the Courses table with the Student_Enrolment_Courses table on the course_id to link courses with their enrollments.", "Group the results by course_id to aggregate the number of enrollments for each course.", "Use COUNT to count the number of enrollments for each course.", "Order the results in descending order based on the count of enrollments to get the course with the most enrollments at the top.", "Limit the results to 1 to get only the course with the highest number of enrollments."], "gold_sql": "SELECT  T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["courses", "student_enrolment_courses"], "pred_sql": "SELECT C.course_name\nFROM Courses AS C\nJOIN Student_Enrolment_Courses AS SEC ON C.course_id = SEC.course_id\nGROUP BY C.course_id\nORDER BY COUNT(SEC.student_course_id) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholder in the WHERE clause represents the name of the degree program.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.548", "db_id": "student_transcripts_tracking", "question": "What is the name of the course with the most students enrolled?", "rationale": ["Identify the relevant tables: Courses and Student_Enrolment_Courses are needed to find the course names and their enrollments.", "Join the Courses table with the Student_Enrolment_Courses table on the course_id to link courses with their enrollments.", "Group the results by course_id to aggregate the number of students enrolled in each course.", "Count the number of student_course_id entries for each course to determine the number of students enrolled.", "Order the results in descending order based on the count of students enrolled to find the course with the most students.", "Limit the results to 1 to get only the course with the highest enrollment."], "gold_sql": "SELECT  T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["courses", "student_enrolment_courses"], "pred_sql": "SELECT C.course_name\nFROM Courses AS C\nJOIN Student_Enrolment_Courses AS SEC ON C.course_id = SEC.course_id\nGROUP BY C.course_id\nORDER BY COUNT(SEC.student_course_id) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholder in the WHERE clause represents the name of the degree program.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.550", "db_id": "student_transcripts_tracking", "question": "What are the last name of the students who live in North Carolina but have not registered in any degree programs?", "rationale": ["Identify the relevant tables: Students and Addresses for student information and their current addresses, and Student_Enrolment for enrollment information.", "Join the Students table with the Addresses table on the current_address_id to access the state information.", "Filter the results to include only those students whose current address is in 'North Carolina'.", "Use the EXCEPT clause to exclude students who are found in the Student_Enrolment table, indicating they are registered in a degree program.", "Select the last names of the students who meet the criteria."], "gold_sql": "SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  'NorthCarolina' EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id", "source_tables": ["addresses", "student_enrolment", "students"], "pred_sql": "SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id = T2.address_id WHERE T2.state_province_county = 'North Carolina' EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id = T4.student_id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the last names of students who currently reside in a specific state, excluding those who are enrolled in any degree program. The query joins the 'Students' table with the 'Addresses' table to filter by the current address's state, and uses an EXCEPT clause to remove students who are found in the 'Student_Enrolment' table.\",\n        \"virtual_table\": \"SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id\"\n    }\n}\n"}
{"sample_id": "dev.554", "db_id": "student_transcripts_tracking", "question": "What is the mobile phone number of the student named Timmothy Ward ?", "rationale": ["Identify the relevant table: The 'Students' table contains the mobile phone numbers and names of students.", "Determine the columns needed: We need the 'cell_mobile_number' column for the mobile phone number.", "Filter the records: We need to filter the records based on the first name 'Timmothy' and last name 'Ward'.", "Construct the SQL query: Using the SELECT statement to retrieve the mobile number from the 'Students' table with the specified conditions."], "gold_sql": "select cell_mobile_number from students where first_name  =  'timmothy' and last_name  =  'ward'", "source_tables": ["students"], "pred_sql": "SELECT cell_mobile_number FROM Students WHERE first_name = 'Timmothy' AND last_name = 'Ward';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholder in the WHERE clause represents the name of the degree program.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.561", "db_id": "student_transcripts_tracking", "question": "Which address holds the most number of students currently? List the address id and all lines.", "rationale": ["We need to find the address that holds the most number of students currently.", "To do this, we will join the 'Addresses' table with the 'Students' table on the 'current_address_id'.", "We will group the results by the address fields (address_id, line_1, line_2, line_3) to count the number of students at each address.", "We will use the COUNT function to count the number of students associated with each address.", "To find the address with the most students, we will order the results in descending order based on the count of students.", "Finally, we will limit the results to 1 to get the address with the highest count."], "gold_sql": "SELECT T1.address_id ,  T1.line_1 ,  T1.line_2 FROM Addresses AS T1 JOIN Students AS T2 ON T1.address_id  =  T2.current_address_id GROUP BY T1.address_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "students"], "pred_sql": "SELECT A.address_id, A.line_1, A.line_2, A.line_3\nFROM Addresses AS A\nJOIN Students AS S ON A.address_id = S.current_address_id\nGROUP BY A.address_id, A.line_1, A.line_2, A.line_3\nORDER BY COUNT(S.student_id) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the last names of students who currently reside in a specific state, excluding those who are enrolled in any degree program. The query joins the 'Students' table with the 'Addresses' table to filter by the current address's state, and uses an EXCEPT clause to remove students who are found in the 'Student_Enrolment' table.\",\n        \"virtual_table\": \"SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id\"\n    }\n}\n"}
{"sample_id": "dev.578", "db_id": "student_transcripts_tracking", "question": "What are the different addresses that have students living there?", "rationale": ["The question asks for different addresses where students live, which implies we need to retrieve unique addresses from the Addresses table.", "We will join the Students table with the Addresses table using the current_address_id to get the addresses of students.", "We need to select distinct addresses to avoid duplicates, so we will use the DISTINCT keyword in our SELECT statement.", "The relevant columns to retrieve from the Addresses table include line_1, line_2, line_3, city, zip_postcode, state_province_county, and country."], "gold_sql": "SELECT count(DISTINCT current_address_id) FROM Students", "source_tables": ["students"], "pred_sql": "SELECT DISTINCT T2.line_1, T2.line_2, T2.line_3, T2.city, T2.zip_postcode, T2.state_province_county, T2.country \nFROM Students AS T1 \nJOIN Addresses AS T2 ON T1.current_address_id = T2.address_id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the last names of students who currently reside in a specific state, excluding those who are enrolled in any degree program. The query joins the 'Students' table with the 'Addresses' table to filter by the current address's state, and uses an EXCEPT clause to remove students who are found in the 'Student_Enrolment' table.\",\n        \"virtual_table\": \"SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id\"\n    }\n}\n"}
{"sample_id": "dev.581", "db_id": "student_transcripts_tracking", "question": "Describe the section h.", "rationale": ["The user wants to describe a specific section identified by the name 'h'.", "To retrieve information about a section, we need to select all columns from the Sections table.", "We will use a WHERE clause to filter the results to only include the section with the name 'h'."], "gold_sql": "SELECT section_description FROM Sections WHERE section_name  =  'h'", "source_tables": ["sections"], "pred_sql": "SELECT * FROM Sections WHERE section_name = 'h';", "hint": "\n"}
{"sample_id": "dev.705", "db_id": "world_1", "question": "How many countries have governments that are republics?", "rationale": ["Identify the relevant table: The question pertains to countries and their government forms, so we will use the 'country' table.", "Determine the condition: We need to count the number of countries where the government form includes the word 'Republic'.", "Construct the SQL query: We will use the COUNT function to count the rows that meet the condition, and we will filter the results using a WHERE clause that checks if the GovernmentForm contains 'Republic'."], "gold_sql": "SELECT count(*) FROM country WHERE GovernmentForm  =  'Republic'", "source_tables": ["country"], "pred_sql": "SELECT COUNT(*) FROM country WHERE GovernmentForm LIKE '%Republic%';", "hint": "\n"}
{"sample_id": "dev.723", "db_id": "world_1", "question": "How many people live in Asia, and what is the largest GNP among them?", "rationale": ["Identify the relevant tables: 'country' for GNP and continent, and 'city' for population.", "We need to sum the population of cities in Asia, so we will use the SUM function on the 'Population' column from the 'city' table.", "We also need to find the maximum GNP among countries in Asia, so we will use the MAX function on the 'GNP' column from the 'country' table.", "To link the cities to their respective countries, we will join the 'city' table with the 'country' table on the 'CountryCode' field.", "We will filter the results to only include countries in the continent of Asia using a WHERE clause."], "gold_sql": "SELECT sum(Population) ,  max(GNP) FROM country WHERE Continent  =  'Asia'", "source_tables": ["country"], "pred_sql": "SELECT SUM(c.Population) AS TotalPopulation, MAX(co.GNP) AS LargestGNP\nFROM country AS co\nJOIN city AS ci ON co.Code = ci.CountryCode\nWHERE co.Continent = 'Asia';", "hint": "\n"}
{"sample_id": "dev.724", "db_id": "world_1", "question": "What is the average life expectancy in African countries that are republics?", "rationale": ["Identify the relevant table: The 'country' table contains the 'LifeExpectancy' and 'GovernmentForm' columns, which are needed for this query.", "Filter for African countries: Use the 'Continent' column to filter for countries in Africa.", "Filter for republics: Use the 'GovernmentForm' column to include only those countries that have 'Republic' in their government form.", "Calculate the average life expectancy: Use the AVG() function on the 'LifeExpectancy' column to get the average for the filtered results."], "gold_sql": "SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  'Africa' AND GovernmentForm  =  'Republic'", "source_tables": ["country"], "pred_sql": "SELECT AVG(LifeExpectancy) AS AverageLifeExpectancy\nFROM country\nWHERE Continent = 'Africa' AND GovernmentForm LIKE '%Republic%';", "hint": "\n"}
{"sample_id": "dev.725", "db_id": "world_1", "question": "Give the average life expectancy for countries in Africa which are republics?", "rationale": ["Identify the relevant table: The 'country' table contains the information about countries, including life expectancy and government form.", "Determine the columns needed: We need the 'LifeExpectancy' column to calculate the average and the 'GovernmentForm' column to filter for republics.", "Set the conditions for the query: We want countries that are in the continent of Africa and have a government form that includes 'Republic'.", "Use the AVG() function to calculate the average life expectancy for the filtered results."], "gold_sql": "SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  'Africa' AND GovernmentForm  =  'Republic'", "source_tables": ["country"], "pred_sql": "SELECT AVG(LifeExpectancy) AS AverageLifeExpectancy \nFROM country \nWHERE Continent = 'Africa' \nAND GovernmentForm LIKE '%Republic%';", "hint": "\n"}
{"sample_id": "dev.731", "db_id": "world_1", "question": "Give the mean GNP and total population of nations which are considered US territory.", "rationale": ["Identify the countries that are considered US territories.", "The known US territories include Puerto Rico, Guam, American Samoa, U.S. Virgin Islands, and Northern Mariana Islands.", "To find the mean GNP and total population, we need to use the AVG() function for GNP and SUM() function for Population.", "We will select these values from the 'country' table where the country name matches the identified US territories."], "gold_sql": "SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  'US Territory'", "source_tables": ["country"], "pred_sql": "SELECT AVG(GNP) AS Mean_GNP, SUM(Population) AS Total_Population \nFROM country \nWHERE Name IN ('Puerto Rico', 'Guam', 'American Samoa', 'U.S. Virgin Islands', 'Northern Mariana Islands');", "hint": "\n"}
{"sample_id": "dev.735", "db_id": "world_1", "question": "How many different forms of governments are there in Africa?", "rationale": ["Identify the relevant table: The 'country' table contains information about countries, including their government forms and continent.", "Determine the specific continent: We are interested in countries located in Africa.", "Select distinct government forms: We want to know how many different forms of government exist, so we will use the DISTINCT keyword to avoid duplicates.", "Construct the SQL query: Combine the elements identified to form the complete SQL query."], "gold_sql": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  'Africa'", "source_tables": ["country"], "pred_sql": "SELECT DISTINCT GovernmentForm FROM country WHERE Continent = 'Africa'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  [PLACEHOLDER-TYPE:STRING] AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  [PLACEHOLDER-TYPE:STRING] AND T4.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.754", "db_id": "world_1", "question": "What are the countries where either English or Dutch is the official language ?", "rationale": ["Identify the relevant tables: We need to look at the 'country' and 'countrylanguage' tables to find countries with specific official languages.", "Determine the criteria: We are interested in countries where either English or Dutch is an official language.", "Use a JOIN operation: We will join the 'country' table with the 'countrylanguage' table on the 'Code' and 'CountryCode' fields to filter the results based on the language criteria.", "Select distinct country names: We will select the distinct names of the countries that meet the criteria of having English or Dutch as an official language."], "gold_sql": "select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  'english' and isofficial  =  't' union select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  'dutch' and isofficial  =  't'", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT DISTINCT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode WHERE T2.IsOfficial = 'T' AND (T2.Language = 'English' OR T2.Language = 'Dutch')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  [PLACEHOLDER-TYPE:STRING] AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  [PLACEHOLDER-TYPE:STRING] AND T4.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.755", "db_id": "world_1", "question": "Which countries have either English or Dutch as an official language?", "rationale": ["Identify the relevant tables: We need to look at the 'country' and 'countrylanguage' tables to find countries with specific official languages.", "Determine the criteria: We are interested in countries where either English or Dutch is an official language.", "Construct the SQL query: We will select distinct country names from the 'country' table, joining it with the 'countrylanguage' table on the country code, and filter for official languages that are either English or Dutch."], "gold_sql": "SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English' AND IsOfficial  =  'T' UNION SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'Dutch' AND IsOfficial  =  'T'", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT DISTINCT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode WHERE T2.IsOfficial = 'T' AND (T2.Language = 'English' OR T2.Language = 'Dutch')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  [PLACEHOLDER-TYPE:STRING] AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  [PLACEHOLDER-TYPE:STRING] AND T4.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.758", "db_id": "world_1", "question": "Which languages are spoken by only one country in republic governments?", "rationale": ["Identify the languages spoken in countries with a republican form of government.", "Filter the countries to only include those with a republican government using the 'country' table.", "Group the results by language to count how many countries speak each language.", "Use the HAVING clause to filter for languages that are spoken in only one country."], "gold_sql": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.GovernmentForm  =  'Republic' GROUP BY T2.Language HAVING COUNT(*)  =  1", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT DISTINCT Language FROM countrylanguage WHERE CountryCode IN (SELECT Code FROM country WHERE GovernmentForm = 'Republic') GROUP BY Language HAVING COUNT(DISTINCT CountryCode) = 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  [PLACEHOLDER-TYPE:STRING] AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  [PLACEHOLDER-TYPE:STRING] AND T4.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.759", "db_id": "world_1", "question": "What languages are only used by a single country with a republic government?", "rationale": ["Identify the relevant tables: We need to use the 'countrylanguage' table to find languages and the 'country' table to check the government form.", "Join the 'countrylanguage' table with the 'country' table on the CountryCode to access both languages and their corresponding countries.", "Filter the results to include only official languages by checking 'IsOfficial' column for 'T'.", "Group the results by language to count how many distinct countries speak each language.", "Use the HAVING clause to filter for languages that are spoken in exactly one country (COUNT(DISTINCT c.Code) = 1).", "Additionally, filter for countries that have a government form that includes 'Republic' in the 'GovernmentForm' column."], "gold_sql": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.GovernmentForm  =  'Republic' GROUP BY T2.Language HAVING COUNT(*)  =  1", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT cl.Language FROM countrylanguage AS cl JOIN country AS c ON cl.CountryCode = c.Code WHERE cl.IsOfficial = 'T' GROUP BY cl.Language HAVING COUNT(DISTINCT c.Code) = 1 AND c.GovernmentForm LIKE '%Republic%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  [PLACEHOLDER-TYPE:STRING] AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  [PLACEHOLDER-TYPE:STRING] AND T4.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.760", "db_id": "world_1", "question": "Find the city with the largest population that uses English.", "rationale": ["Identify the requirement to find the city with the largest population that uses English.", "To find cities that use English, we need to look at the 'countrylanguage' table to filter countries where English is an official language.", "Next, we need to get the country codes from the 'country' table that correspond to these countries.", "Then, we will filter the 'city' table to find cities that belong to these countries.", "Finally, we will find the city with the maximum population from the filtered list of cities."], "gold_sql": "SELECT T1.Name ,  T1.Population FROM city AS T1 JOIN countrylanguage AS T2 ON T1.CountryCode  =  T2.CountryCode WHERE T2.Language  =  'English' ORDER BY T1.Population DESC LIMIT 1", "source_tables": ["city", "countrylanguage"], "pred_sql": "SELECT Name FROM city WHERE Population = (SELECT MAX(Population) FROM city WHERE CountryCode IN (SELECT Code FROM country WHERE Code IN (SELECT CountryCode FROM countrylanguage WHERE Language = 'English' AND IsOfficial = 'T')));", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  [PLACEHOLDER-TYPE:STRING] AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  [PLACEHOLDER-TYPE:STRING] AND T4.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.766", "db_id": "world_1", "question": "What is the total number of people living in the nations that do not use English?", "rationale": ["Identify the countries that do not use English as an official language.", "To find these countries, we need to look at the 'countrylanguage' table where 'IsOfficial' is 'T' and 'Language' is 'English'.", "We will create a subquery to get the 'CountryCode' of countries that have English as an official language.", "Next, we will use this subquery to filter out these countries from the 'country' table.", "Finally, we will sum the 'Population' of the remaining countries to get the total number of people living in nations that do not use English."], "gold_sql": "SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English')", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT SUM(Population) FROM country WHERE Code NOT IN (SELECT CountryCode FROM countrylanguage WHERE IsOfficial = 'T' AND Language = 'English')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  [PLACEHOLDER-TYPE:STRING] AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  [PLACEHOLDER-TYPE:STRING] AND T4.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.774", "db_id": "world_1", "question": "What are the African countries that have a  population less than any country in Asia?", "rationale": ["Identify the countries in Africa by filtering the 'country' table for the continent 'Africa'.", "Determine the maximum population of countries in Asia by using a subquery that selects the maximum population from the 'country' table where the continent is 'Asia'.", "Combine these two criteria to find African countries whose population is less than the maximum population found in Asia."], "gold_sql": "SELECT Name FROM country WHERE Continent  =  'Africa'  AND population  <  (SELECT max(population) FROM country WHERE Continent  =  'Asia')", "source_tables": ["country"], "pred_sql": "SELECT Name FROM country WHERE Continent = 'Africa' AND Population < (SELECT MAX(Population) FROM country WHERE Continent = 'Asia')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  [PLACEHOLDER-TYPE:STRING] AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  [PLACEHOLDER-TYPE:STRING] AND T4.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.777", "db_id": "world_1", "question": "What are the Asian countries which have a population larger than that of any country in Africa?", "rationale": ["Identify the countries in Asia by filtering the 'country' table for the continent 'Asia'.", "Determine the population of these Asian countries by selecting the 'Population' column from the 'country' table.", "To find countries in Asia with a population larger than any country in Africa, we need to compare the populations.", "Use a subquery to find the maximum population of countries in Africa by filtering the 'country' table for the continent 'Africa' and selecting the maximum 'Population'.", "Combine the conditions to select distinct country names from Asia where their population is greater than the maximum population found in Africa."], "gold_sql": "SELECT Name FROM country WHERE Continent  =  'Asia'  AND population  >  (SELECT min(population) FROM country WHERE Continent  =  'Africa')", "source_tables": ["country"], "pred_sql": "SELECT DISTINCT T1.Name FROM country AS T1 WHERE T1.Continent = 'Asia' AND T1.Population > (SELECT MAX(T2.Population) FROM country AS T2 WHERE T2.Continent = 'Africa')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  [PLACEHOLDER-TYPE:STRING] AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  [PLACEHOLDER-TYPE:STRING] AND T4.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.778", "db_id": "world_1", "question": "What are the country codes for countries that do not speak English?", "rationale": ["Identify the requirement: We need country codes for countries that do not speak English.", "Understand the schema: The 'country' table contains country codes, and the 'countrylanguage' table indicates which languages are spoken in which countries.", "Use a subquery to find country codes where English is an official language: This involves selecting CountryCode from the 'countrylanguage' table where IsOfficial is 'T' and Language is 'English'.", "Use the NOT IN clause to filter out these country codes from the main query that selects from the 'country' table.", "The final query selects distinct country codes from the 'country' table that are not in the list of country codes that speak English."], "gold_sql": "SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  'English'", "source_tables": ["countrylanguage"], "pred_sql": "SELECT DISTINCT Code FROM country WHERE Code NOT IN (SELECT CountryCode FROM countrylanguage WHERE IsOfficial = 'T' AND Language = 'English')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  [PLACEHOLDER-TYPE:STRING] AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  [PLACEHOLDER-TYPE:STRING] AND T4.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.786", "db_id": "world_1", "question": "Which unique cities are in Asian countries where Chinese is the official language ?", "rationale": ["Identify the relevant tables: 'city', 'country', and 'countrylanguage'.", "We need to find unique city names, so we will use SELECT DISTINCT on the city names.", "We will join the 'city' table with the 'country' table on the CountryCode to filter cities based on their countries.", "We need to filter for countries that are in Asia, so we will add a condition for the continent in the WHERE clause.", "Next, we need to ensure that the countries we are considering have Chinese as an official language. We will do this by using a subquery that selects country codes from the 'countrylanguage' table where the language is 'Chinese' and is marked as official (IsOfficial = 'T').", "Finally, we will combine these conditions to form the complete SQL query."], "gold_sql": "select distinct t3.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode join city as t3 on t1.code  =  t3.countrycode where t2.isofficial  =  't' and t2.language  =  'chinese' and t1.continent  =  'asia'", "source_tables": ["country", "city", "countrylanguage"], "pred_sql": "SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode = T1.Code WHERE T1.Continent = 'Asia' AND T1.Code IN (SELECT T3.Code FROM countrylanguage AS T4 JOIN country AS T3 ON T4.CountryCode = T3.Code WHERE T4.IsOfficial = 'T' AND T4.Language = 'Chinese')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  [PLACEHOLDER-TYPE:STRING] AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  [PLACEHOLDER-TYPE:STRING] AND T4.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.789", "db_id": "world_1", "question": "Give the name, year of independence, and surface area of the country that has the lowest population.", "rationale": ["Identify the columns needed: Name, IndepYear, and SurfaceArea from the country table.", "Determine the condition to find the country with the lowest population: use a subquery to find the minimum population.", "Construct the main query to select the required columns from the country table where the population matches the minimum population found in the subquery."], "gold_sql": "SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT 1", "source_tables": ["country"], "pred_sql": "SELECT Name, IndepYear, SurfaceArea FROM country WHERE Population = (SELECT MIN(Population) FROM country);", "hint": "\n"}
{"sample_id": "dev.793", "db_id": "world_1", "question": "What are the names of countries that speak more than 2 languages, as well as how many languages they speak?", "rationale": ["Identify the relevant tables: We need to use the 'country' and 'countrylanguage' tables to find countries and the languages they speak.", "Count the number of languages spoken in each country: We can use the COUNT function on the 'Language' column from the 'countrylanguage' table.", "Group the results by country: We will group by 'CountryCode' to aggregate the language counts for each country.", "Filter countries that speak more than 2 languages: We will use the HAVING clause to filter the results to only include countries where the count of languages is greater than 2.", "Select the country name and the count of languages: We will select the country name from the 'country' table and the count of languages from the aggregation."], "gold_sql": "SELECT COUNT(T2.Language) ,  T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Name HAVING COUNT(*)  >  2", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT cl.CountryCode, c.Name, COUNT(cl.Language) AS LanguageCount \nFROM countrylanguage AS cl \nJOIN country AS c ON cl.CountryCode = c.Code \nGROUP BY cl.CountryCode \nHAVING COUNT(cl.Language) > 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  [PLACEHOLDER-TYPE:STRING] AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  [PLACEHOLDER-TYPE:STRING] AND T4.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.797", "db_id": "world_1", "question": "What are the different government forms and what is the total population of each for government forms that have an average life expectancy greater than 72?", "rationale": ["Identify the relevant table: The question pertains to government forms and population, which are found in the 'country' table.", "Select the columns needed: We need 'GovernmentForm' and the total population, so we will select 'GovernmentForm' and use SUM() on 'Population'.", "Apply the condition: We need to filter for countries with an average life expectancy greater than 72, so we will add a WHERE clause for 'LifeExpectancy > 72'.", "Group the results: Since we want the total population for each government form, we will use GROUP BY on 'GovernmentForm'.", "Construct the SQL query: Combine all the elements into a complete SQL query."], "gold_sql": "SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  72", "source_tables": ["country"], "pred_sql": "SELECT GovernmentForm, SUM(Population) AS TotalPopulation\nFROM country\nWHERE LifeExpectancy > 72\nGROUP BY GovernmentForm;", "hint": "\n"}
{"sample_id": "dev.812", "db_id": "world_1", "question": "What are the cities whose population is between 160000 and 900000?", "rationale": ["Identify the relevant table: The 'city' table contains the population data.", "Determine the condition for population: We need to find cities with a population between 160000 and 900000.", "Construct the SQL query: Use the SELECT statement to retrieve the 'Name' of the cities from the 'city' table where the 'Population' falls within the specified range."], "gold_sql": "SELECT name FROM city WHERE Population BETWEEN 160000 AND 900000", "source_tables": ["city"], "pred_sql": "SELECT Name FROM city WHERE Population BETWEEN '160000' AND '900000';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  [PLACEHOLDER-TYPE:STRING] AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  [PLACEHOLDER-TYPE:STRING] AND T4.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.820", "db_id": "world_1", "question": "What are the codes of countries where Spanish is spoken by the largest percentage of people?", "rationale": ["Identify the relevant table: We need to look at the 'countrylanguage' table to find information about languages spoken in countries.", "Filter for Spanish: We will filter the results to only include rows where the Language is 'Spanish'.", "Order by percentage: To find the countries where Spanish is spoken by the largest percentage of people, we will order the results by the Percentage column in descending order.", "Select the country codes: Finally, we will select the CountryCode from the filtered and ordered results."], "gold_sql": "SELECT CountryCode ,  max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  'Spanish' GROUP BY CountryCode", "source_tables": ["countrylanguage"], "pred_sql": "SELECT CountryCode FROM countrylanguage WHERE Language = 'Spanish' ORDER BY Percentage DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  [PLACEHOLDER-TYPE:STRING] AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  [PLACEHOLDER-TYPE:STRING] AND T4.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.821", "db_id": "world_1", "question": "Return the codes of countries for which Spanish is the predominantly spoken language.", "rationale": ["Identify the relevant tables: We need to look at the 'country' and 'countrylanguage' tables to find the country codes based on the language spoken.", "Determine the condition for the language: We are interested in countries where Spanish is predominantly spoken, which typically means it should be an official language and spoken by a significant percentage of the population.", "Construct the SQL query: We will join the 'country' table with the 'countrylanguage' table on the country code, filter for Spanish as the language, and check that it is an official language with a high percentage of speakers."], "gold_sql": "SELECT CountryCode ,  max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  'Spanish' GROUP BY CountryCode", "source_tables": ["countrylanguage"], "pred_sql": "SELECT DISTINCT T1.Code FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode WHERE T2.Language = 'Spanish' AND T2.Percentage > 50;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  [PLACEHOLDER-TYPE:STRING] AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  [PLACEHOLDER-TYPE:STRING] AND T4.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.920", "db_id": "dog_kennels", "question": "What is the average age of the dogs who have gone through any treatments?", "rationale": ["Identify the relevant tables: Dogs and Treatments.", "We need to find the average age of dogs that have undergone treatments, so we will join the Dogs table with the Treatments table on the dog_id.", "Use the AVG() function to calculate the average age of the dogs from the Dogs table after the join."], "gold_sql": "SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )", "source_tables": ["dogs", "treatments"], "pred_sql": "SELECT AVG(D.age) AS average_age FROM Dogs AS D JOIN Treatments AS T ON D.dog_id = T.dog_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of owners along with their last names who have had dogs treated, sorted by the number of treatments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of owners to display.\",\n        \"virtual_table\": \"SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.936", "db_id": "dog_kennels", "question": "Which owner has paid for the most treatments on his or her dogs? List the owner id and last name.", "rationale": ["Identify the relevant tables: Owners, Dogs, and Treatments.", "Join the Owners table with the Dogs table on owner_id to link owners to their dogs.", "Join the resulting table with the Treatments table on dog_id to link dogs to their treatments.", "Group the results by owner_id to aggregate the number of treatments per owner.", "Order the results by the count of treatments in descending order to find the owner with the most treatments.", "Limit the results to 1 to get only the top owner."], "gold_sql": "SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["owners", "dogs", "treatments"], "pred_sql": "SELECT T1.owner_id, T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id = T2.owner_id JOIN Treatments AS T3 ON T2.dog_id = T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of owners along with their last names who have had dogs treated, sorted by the number of treatments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of owners to display.\",\n        \"virtual_table\": \"SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.942", "db_id": "dog_kennels", "question": "Which professionals have done at least two types of treatments? List the professional id and cell phone.", "rationale": ["Identify the relevant tables: Professionals and Treatments.", "Join the Professionals table with the Treatments table on the professional_id.", "Group the results by professional_id to aggregate the treatments administered by each professional.", "Use the COUNT function to count the distinct treatment types for each professional.", "Filter the results using HAVING to include only those professionals who have administered at least two different types of treatments."], "gold_sql": "SELECT T1.professional_id ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  2", "source_tables": ["professionals", "treatments"], "pred_sql": "SELECT professional_id, cell_number \nFROM Professionals AS P \nJOIN Treatments AS T ON P.professional_id = T.professional_id \nGROUP BY P.professional_id \nHAVING COUNT(DISTINCT T.treatment_type_code) >= 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique first names of professionals along with the descriptions of the treatment types they have administered. The data is sourced from the 'Professionals', 'Treatments', and 'Treatment_Types' tables, ensuring that only distinct combinations of professional names and treatment descriptions are displayed.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code\"\n    }\n}\n"}
{"sample_id": "dev.944", "db_id": "dog_kennels", "question": "What are the first name and last name of the professionals who have done treatment with cost below average?", "rationale": ["Identify the tables needed: Professionals and Treatments.", "We need to join the Professionals table with the Treatments table to get the names of professionals who have administered treatments.", "We need to filter the treatments based on their cost being below average.", "To find the average cost, we will use a subquery that calculates the average of the cost_of_treatment from the Treatments table.", "Select the distinct first and last names of the professionals who meet the criteria."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T1.last_name FROM Professionals AS T1 JOIN Treatments AS T2 WHERE cost_of_treatment  <  ( SELECT avg(cost_of_treatment) FROM Treatments )", "source_tables": ["professionals", "treatments"], "pred_sql": "SELECT DISTINCT T1.first_name, T1.last_name \nFROM Professionals AS T1 \nJOIN Treatments AS T2 ON T1.professional_id = T2.professional_id \nWHERE T2.cost_of_treatment < (SELECT AVG(cost_of_treatment) FROM Treatments)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique first names of professionals along with the descriptions of the treatment types they have administered. The data is sourced from the 'Professionals', 'Treatments', and 'Treatment_Types' tables, ensuring that only distinct combinations of professional names and treatment descriptions are displayed.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code\"\n    }\n}\n"}
{"sample_id": "dev.950", "db_id": "dog_kennels", "question": "List each owner's first name, last name, and the size of his for her dog.", "rationale": ["Identify the tables needed: Owners, Dogs, and Sizes.", "We need to select the first name and last name from the Owners table.", "We also need the size of the dog, which is in the Sizes table.", "Join the Owners table with the Dogs table on owner_id to link owners to their dogs.", "Join the Dogs table with the Sizes table on size_code to get the size description of each dog.", "Select the required fields: owner's first name, last name, and the size description."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id", "source_tables": ["owners", "dogs"], "pred_sql": "SELECT O.first_name, O.last_name, S.size_description \nFROM Owners AS O \nJOIN Dogs AS D ON O.owner_id = D.owner_id \nJOIN Sizes AS S ON D.size_code = S.size_code;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of owners along with their last names who have had dogs treated, sorted by the number of treatments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of owners to display.\",\n        \"virtual_table\": \"SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.951", "db_id": "dog_kennels", "question": "What are each owner's first name, last name, and the size of their dog?", "rationale": ["Identify the required information: owner's first name, last name, and dog's size.", "Determine the relevant tables: Owners, Dogs, and Sizes.", "Establish the relationships between the tables: Owners are linked to Dogs via owner_id, and Dogs are linked to Sizes via size_code.", "Construct the SQL query to select the desired columns from the Owners table and the Sizes table, joining them through the Dogs table."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id", "source_tables": ["owners", "dogs"], "pred_sql": "SELECT Owners.first_name, Owners.last_name, Sizes.size_description \nFROM Owners \nJOIN Dogs ON Owners.owner_id = Dogs.owner_id \nJOIN Sizes ON Dogs.size_code = Sizes.size_code;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of owners along with their last names who have had dogs treated, sorted by the number of treatments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of owners to display.\",\n        \"virtual_table\": \"SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.958", "db_id": "dog_kennels", "question": "What are the arriving date and the departing date of the dogs who have gone through a treatment?", "rationale": ["Identify the relevant tables: Dogs and Treatments.", "Determine the columns needed: arriving date (date_arrived) and departing date (date_departed) from Dogs.", "Establish the relationship between Dogs and Treatments using the dog_id.", "Construct the SQL query to select the required columns from Dogs while joining with Treatments."], "gold_sql": "SELECT DISTINCT T1.date_arrived ,  T1.date_departed FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id", "source_tables": ["dogs", "treatments"], "pred_sql": "SELECT D.date_arrived, D.date_departed \nFROM Dogs AS D \nJOIN Treatments AS T ON D.dog_id = T.dog_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of owners along with their last names who have had dogs treated, sorted by the number of treatments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of owners to display.\",\n        \"virtual_table\": \"SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.961", "db_id": "dog_kennels", "question": "Who owns the youngest dog? Give me his or her last name.", "rationale": ["Identify the relevant tables: Owners and Dogs.", "We need to find the youngest dog, so we will order the Dogs table by age in ascending order.", "We will join the Owners table with the Dogs table on the owner_id to get the owner's last name associated with the youngest dog.", "Finally, we will limit the result to 1 to get only the youngest dog owner."], "gold_sql": "SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )", "source_tables": ["owners", "dogs"], "pred_sql": "SELECT O.last_name FROM Owners AS O JOIN Dogs AS D ON O.owner_id = D.owner_id ORDER BY D.age ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of owners along with their last names who have had dogs treated, sorted by the number of treatments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of owners to display.\",\n        \"virtual_table\": \"SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.997", "db_id": "dog_kennels", "question": "Find the distinct breed type and size type combinations for dogs.", "rationale": ["Identify the tables needed: Dogs, Breeds, and Sizes are required to get breed and size information.", "Use JOIN to connect the Dogs table with the Breeds table on the breed_code and with the Sizes table on the size_code.", "Select distinct combinations of breed names and size descriptions to avoid duplicates."], "gold_sql": "SELECT DISTINCT breed_code ,  size_code FROM dogs", "source_tables": ["dogs"], "pred_sql": "SELECT DISTINCT B.breed_name, S.size_description \nFROM Dogs AS D \nJOIN Breeds AS B ON D.breed_code = B.breed_code \nJOIN Sizes AS S ON D.size_code = S.size_code;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of owners along with their last names who have had dogs treated, sorted by the number of treatments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of owners to display.\",\n        \"virtual_table\": \"SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.999", "db_id": "dog_kennels", "question": "What are each professional's first name and description of the treatment they have performed?", "rationale": ["Identify the tables involved: Professionals, Treatments, and Treatment_Types.", "Determine the columns needed: first_name from Professionals and treatment_type_description from Treatment_Types.", "Establish the relationships between the tables using JOINs: Professionals to Treatments on professional_id, and Treatments to Treatment_Types on treatment_type_code.", "Use DISTINCT to ensure unique combinations of first names and treatment descriptions are returned."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code", "source_tables": ["professionals", "treatments", "treatment_types"], "pred_sql": "SELECT DISTINCT T1.first_name, T3.treatment_type_description \nFROM Professionals AS T1 \nJOIN Treatments AS T2 ON T1.professional_id = T2.professional_id \nJOIN Treatment_Types AS T3 ON T2.treatment_type_code = T3.treatment_type_code;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique first names of professionals along with the descriptions of the treatment types they have administered. The data is sourced from the 'Professionals', 'Treatments', and 'Treatment_Types' tables, ensuring that only distinct combinations of professional names and treatment descriptions are displayed.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code\"\n    }\n}\n"}
