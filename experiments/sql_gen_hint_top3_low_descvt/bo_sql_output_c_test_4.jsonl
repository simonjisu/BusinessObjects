{"sample_id": "train.4750", "db_id": "department_store", "question": "What is the id and name of the staff who has been assigned for the least amount of time?", "rationale": ["Identify the relevant tables: Staff and Staff_Department_Assignments are needed to get staff details and their assignment dates.", "Join the Staff table with the Staff_Department_Assignments table on staff_id to link staff members with their assignments.", "Order the results by the date_assigned_from in ascending order to find the staff member who has been assigned for the least amount of time.", "Limit the results to 1 to get only the staff member with the least assignment duration."], "gold_sql": "SELECT T1.staff_id ,  T1.staff_name FROM staff AS T1 JOIN Staff_Department_Assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY date_assigned_to - date_assigned_from LIMIT 1", "source_tables": ["staff_department_assignments", "staff"], "pred_sql": "SELECT T1.staff_id, T1.staff_name FROM Staff AS T1 JOIN Staff_Department_Assignments AS T2 ON T1.staff_id = T2.staff_id ORDER BY T2.date_assigned_from ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of staff members along with their job titles from the 'Staff' and 'Staff_Department_Assignments' tables. The results are ordered by the end date of their assignments, allowing users to see the most recently assigned staff members first. The placeholder in the LIMIT clause represents the maximum number of records to return.\",\n        \"virtual_table\": \"SELECT T1.staff_name ,  T2.job_title_code FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY T2.date_assigned_to DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of staff members along with their job titles from the 'Staff' and 'Staff_Department_Assignments' tables. The results are ordered by the end date of their assignments, allowing users to see the most recently assigned staff members first. The placeholder in the LIMIT clause represents the maximum number of records to return.\",\n        \"virtual_table\": \"SELECT T1.staff_name ,  T2.job_title_code FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY T2.date_assigned_to DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4753", "db_id": "department_store", "question": "Find the ids of all distinct customers who made order after some orders that were Cancelled.", "rationale": ["Identify the main table to query: Customer_Orders, as we need customer ids related to orders.", "We need to find distinct customer ids, so we will use SELECT DISTINCT on customer_id.", "We need to filter customers who made orders after some orders that were cancelled. This requires a subquery.", "The subquery will select order_ids from Customer_Orders where the order_status_code is 'Cancelled' and the order_date is before the order_date of the outer query.", "The outer query will then check if the order_id is in the result of the subquery, ensuring we only get customers who made orders after a cancelled order."], "gold_sql": "SELECT DISTINCT customer_id FROM Customer_Orders WHERE order_date  >  (SELECT min(order_date) FROM Customer_Orders WHERE order_status_code  =  'Cancelled')", "source_tables": ["customer_orders"], "pred_sql": "SELECT DISTINCT co.customer_id\nFROM Customer_Orders co\nWHERE co.order_id IN (\n    SELECT co2.order_id\n    FROM Customer_Orders co2\n    WHERE co2.order_status_code = 'Cancelled'\n    AND co2.order_date < co.order_date\n)", "hint": "\n"}
{"sample_id": "train.4755", "db_id": "department_store", "question": "What is id of the staff who had a Staff Department Assignment earlier than any Clerical Staff?", "rationale": ["Identify the relevant tables: We need to look at the Staff and Staff_Department_Assignments tables to find staff members and their assignments.", "Determine the condition: We want to find staff who had an assignment earlier than any Clerical Staff. This means we need to find the earliest assignment date of Clerical Staff.", "Use a subquery: We will use a subquery to find the minimum assignment date for Clerical Staff by joining Staff_Department_Assignments with Staff on staff_id and filtering by job_title_code.", "Select staff_id: Finally, we will select the staff_id from Staff_Department_Assignments where the date_assigned_from is less than the result of the subquery."], "gold_sql": "SELECT staff_id FROM Staff_Department_Assignments WHERE date_assigned_to  <  (SELECT max(date_assigned_to) FROM Staff_Department_Assignments WHERE job_title_code  =  'Clerical Staff')", "source_tables": ["staff_department_assignments"], "pred_sql": "SELECT staff_id FROM Staff_Department_Assignments AS T1 WHERE date_assigned_from < (SELECT MIN(date_assigned_from) FROM Staff_Department_Assignments AS T2 JOIN Staff AS T3 ON T2.staff_id = T3.staff_id WHERE T3.job_title_code = 'Clerical')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of staff members along with their job titles from the 'Staff' and 'Staff_Department_Assignments' tables. The results are ordered by the end date of their assignments, allowing users to see the most recently assigned staff members first. The placeholder in the LIMIT clause represents the maximum number of records to return.\",\n        \"virtual_table\": \"SELECT T1.staff_name ,  T2.job_title_code FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY T2.date_assigned_to DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of staff members along with their job titles from the 'Staff' and 'Staff_Department_Assignments' tables. The results are ordered by the end date of their assignments, allowing users to see the most recently assigned staff members first. The placeholder in the LIMIT clause represents the maximum number of records to return.\",\n        \"virtual_table\": \"SELECT T1.staff_name ,  T2.job_title_code FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY T2.date_assigned_to DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4758", "db_id": "department_store", "question": "Return the names and ids of customers who have TN in their address.", "rationale": ["Identify the relevant tables: Customers, Customer_Addresses, and Addresses.", "We need to retrieve customer names and IDs, so we will select 'customer_name' and 'customer_id' from the Customers table.", "To find customers with 'TN' in their address, we need to join the Customers table with the Customer_Addresses table on 'customer_id'.", "Next, we join the Customer_Addresses table with the Addresses table on 'address_id' to access the address details.", "Finally, we filter the results using a WHERE clause to check if 'address_details' contains 'TN' using the LIKE operator."], "gold_sql": "SELECT customer_name ,  customer_id FROM customers WHERE customer_address LIKE '%TN%'", "source_tables": ["customers"], "pred_sql": "SELECT Customers.customer_name, Customers.customer_id \nFROM Customers \nJOIN Customer_Addresses ON Customers.customer_id = Customer_Addresses.customer_id \nJOIN Addresses ON Customer_Addresses.address_id = Addresses.address_id \nWHERE Addresses.address_details LIKE '%TN%';", "hint": "\n"}
{"sample_id": "train.4760", "db_id": "department_store", "question": "What are the names and genders of staff who were assigned in 2016?", "rationale": ["Identify the relevant tables: Staff and Staff_Department_Assignments.", "We need to retrieve staff names and genders, so we will select 'staff_name' and 'staff_gender' from the Staff table.", "To find out which staff were assigned in 2016, we will join the Staff table with the Staff_Department_Assignments table on 'staff_id'.", "We will filter the results using a WHERE clause to check if the year of 'date_assigned_from' is 2016 using the strftime function.", "Construct the SQL query with the selected fields, join condition, and the date filter."], "gold_sql": "SELECT T1.staff_name ,  T1.staff_gender FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.date_assigned_from LIKE '2016%'", "source_tables": ["staff_department_assignments", "staff"], "pred_sql": "SELECT S.staff_name, S.staff_gender \nFROM Staff AS S \nJOIN Staff_Department_Assignments AS A ON S.staff_id = A.staff_id \nWHERE strftime('%Y', A.date_assigned_from) = '2016';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of staff members along with their job titles from the 'Staff' and 'Staff_Department_Assignments' tables. The results are ordered by the end date of their assignments, allowing users to see the most recently assigned staff members first. The placeholder in the LIMIT clause represents the maximum number of records to return.\",\n        \"virtual_table\": \"SELECT T1.staff_name ,  T2.job_title_code FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY T2.date_assigned_to DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of staff members along with their job titles from the 'Staff' and 'Staff_Department_Assignments' tables. The results are ordered by the end date of their assignments, allowing users to see the most recently assigned staff members first. The placeholder in the LIMIT clause represents the maximum number of records to return.\",\n        \"virtual_table\": \"SELECT T1.staff_name ,  T2.job_title_code FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY T2.date_assigned_to DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4762", "db_id": "department_store", "question": "What are the names of staff who have been assigned multiple jobs?", "rationale": ["We need to find the names of staff members who have been assigned multiple jobs.", "To do this, we will use the Staff table to get the staff names.", "We will also use the Staff_Department_Assignments table to count the number of distinct job titles assigned to each staff member.", "We will group the results by staff_id and use the HAVING clause to filter those who have more than one distinct job title.", "Finally, we will select the staff_name from the Staff table where the staff_id matches those who have multiple job assignments."], "gold_sql": "SELECT T1.staff_name FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id GROUP BY T2.staff_id HAVING COUNT (*)  >  1", "source_tables": ["staff_department_assignments", "staff"], "pred_sql": "SELECT staff_name FROM Staff WHERE staff_id IN (SELECT staff_id FROM Staff_Department_Assignments GROUP BY staff_id HAVING COUNT(DISTINCT job_title_code) > 1);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of staff members along with their job titles from the 'Staff' and 'Staff_Department_Assignments' tables. The results are ordered by the end date of their assignments, allowing users to see the most recently assigned staff members first. The placeholder in the LIMIT clause represents the maximum number of records to return.\",\n        \"virtual_table\": \"SELECT T1.staff_name ,  T2.job_title_code FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY T2.date_assigned_to DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of staff members along with their job titles from the 'Staff' and 'Staff_Department_Assignments' tables. The results are ordered by the end date of their assignments, allowing users to see the most recently assigned staff members first. The placeholder in the LIMIT clause represents the maximum number of records to return.\",\n        \"virtual_table\": \"SELECT T1.staff_name ,  T2.job_title_code FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY T2.date_assigned_to DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4792", "db_id": "department_store", "question": "What are the ids and names of customers with addressed that contain WY and who do not use a credit card for payment?", "rationale": ["Identify the relevant table: Customers, which contains customer_id, customer_name, customer_address, and payment_method_code.", "Filter customers based on their address containing 'WY'. This can be done using the LIKE operator with wildcards.", "Exclude customers who use a credit card for payment by checking that payment_method_code is not equal to 'CREDIT_CARD'.", "Combine these conditions in the WHERE clause of the SQL query to retrieve the desired information."], "gold_sql": "SELECT customer_id ,  customer_name FROM customers WHERE customer_address LIKE '%WY%' AND payment_method_code != 'Credit Card'", "source_tables": ["customers"], "pred_sql": "SELECT customer_id, customer_name \nFROM Customers \nWHERE customer_address LIKE '%WY%' \nAND payment_method_code != 'CREDIT_CARD';", "hint": "\n"}
{"sample_id": "train.4793", "db_id": "department_store", "question": "Find the average price of all product clothes.", "rationale": ["Identify the table needed: Products table contains product information including price and type.", "Determine the required calculation: We need to calculate the average price of products.", "Use the provided hint to form the SQL query: The hint suggests using the avg function on product_price with a WHERE clause for product_type_code.", "Replace the placeholder in the hint with 'clothes' to specify the type of product we are interested in."], "gold_sql": "SELECT avg(product_price) FROM products WHERE product_type_code  =  'Clothes'", "source_tables": ["products"], "pred_sql": "SELECT avg(product_price) FROM Products WHERE product_type_code = 'clothes'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average price of products from the 'Products' table that belong to a specific product type. The placeholder in the WHERE clause represents the product type code.\",\n        \"virtual_table\": \"SELECT avg(product_price) FROM products WHERE product_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4795", "db_id": "department_store", "question": "Find the name of the most expensive hardware product.", "rationale": ["Identify the relevant table: Products, which contains product details including name and price.", "Filter the products to only include those of type 'hardware' using the product_type_code column.", "Sort the filtered products by price in descending order to get the most expensive one at the top.", "Limit the results to 1 to get only the most expensive hardware product."], "gold_sql": "SELECT product_name FROM products WHERE product_type_code  =  'Hardware' ORDER BY product_price DESC LIMIT 1", "source_tables": ["products"], "pred_sql": "SELECT product_name FROM Products WHERE product_type_code = 'hardware' ORDER BY product_price DESC LIMIT 1;", "hint": "\n"}
{"sample_id": "train.4902", "db_id": "store_product", "question": "Find the list of page size which have more than 3 product listed", "rationale": ["We need to find the list of page sizes that have more than 3 products listed.", "To do this, we will join the 'store_product' table with the 'product' table using the product_id.", "We will select the 'max_page_size' from the 'product' table.", "We will group the results by 'max_page_size' to aggregate the products that share the same page size.", "Finally, we will use the HAVING clause to filter those groups where the count of products is greater than 3."], "gold_sql": "SELECT max_page_size FROM product GROUP BY max_page_size HAVING count(*)  >  3", "source_tables": ["product"], "pred_sql": "SELECT max_page_size FROM store_product AS sp JOIN product AS p ON sp.Product_ID = p.product_id GROUP BY max_page_size HAVING COUNT(sp.Product_ID) > 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the products from the 'product' table that match a specific search criterion. The placeholder in the WHERE clause represents a pattern for the product name or description.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE product LIKE [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the products available in a specific store. The placeholder in the WHERE clause represents the name of the store for which the products are being queried.\",\n        \"virtual_table\": \"SELECT t1.product FROM product AS t1 JOIN store_product AS t2 ON t1.product_id  =  t2.product_id JOIN store AS t3 ON t2.store_id  =  t3.store_id WHERE t3.store_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4903", "db_id": "store_product", "question": "What is the maximum page size for everything that has more than 3 products listed?", "rationale": ["Identify the relevant tables: product, store_product, and store are needed to get the maximum page size for products in stores.", "Join the product table with the store_product table to link products to their respective stores.", "Join the resulting table with the store table to access store information.", "Group the results by store to aggregate data for each store.", "Use the COUNT function to count the number of products per store and filter those with more than 3 products using HAVING clause.", "Select the maximum page size from the product table for those stores that meet the criteria."], "gold_sql": "SELECT max_page_size FROM product GROUP BY max_page_size HAVING count(*)  >  3", "source_tables": ["product"], "pred_sql": "SELECT MAX(p.max_page_size) \nFROM product AS p \nJOIN store_product AS sp ON p.product_id = sp.product_id \nJOIN store AS s ON sp.store_id = s.store_id \nGROUP BY s.store_id \nHAVING COUNT(sp.product_id) > 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the products available in a specific store. The placeholder in the WHERE clause represents the name of the store for which the products are being queried.\",\n        \"virtual_table\": \"SELECT t1.product FROM product AS t1 JOIN store_product AS t2 ON t1.product_id  =  t2.product_id JOIN store AS t3 ON t2.store_id  =  t3.store_id WHERE t3.store_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the products from the 'product' table that match a specific search criterion. The placeholder in the WHERE clause represents a pattern for the product name or description.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE product LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4913", "db_id": "store_product", "question": "What is the total number of residents for the districts with the 3 largest areas?", "rationale": ["Identify the relevant table: The question pertains to districts and their populations, so we will use the 'district' table.", "Determine the required information: We need to find the total number of residents, which corresponds to the 'City_Population' column.", "Find the districts with the largest areas: We will order the districts by 'City_Area' in descending order and limit the results to the top 3 districts.", "Use a subquery to get the District_IDs of the top 3 largest areas and then sum their populations in the main query."], "gold_sql": "SELECT sum(city_population) FROM district ORDER BY city_area DESC LIMIT 3", "source_tables": ["district"], "pred_sql": "SELECT SUM(City_Population) AS Total_Residents\nFROM district\nWHERE District_ID IN (\n    SELECT District_ID\n    FROM district\n    ORDER BY City_Area DESC\n    LIMIT 3\n);", "hint": "\n"}
{"sample_id": "train.4917", "db_id": "store_product", "question": "What are the names of all the stores located in Khanewal District?", "rationale": ["Identify the tables involved: store, store_district, and district.", "Determine the relationship between these tables: store is linked to store_district via Store_ID, and store_district is linked to district via District_ID.", "Select the Store_Name from the store table (aliased as t1).", "Join the store table with store_district (aliased as t2) on Store_ID.", "Join the result with the district table (aliased as t3) on District_ID.", "Filter the results where the District_name in the district table equals 'Khanewal'."], "gold_sql": "SELECT t1.store_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t3.district_name  =  'Khanewal District'", "source_tables": ["store_district", "store", "district"], "pred_sql": "SELECT t1.Store_Name FROM store AS t1 JOIN store_district AS t2 ON t1.Store_ID = t2.Store_ID JOIN district AS t3 ON t2.District_ID = t3.District_ID WHERE t3.District_name = 'Khanewal'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of stores located in a specific district. The query joins the 'store', 'store_district', and 'district' tables to filter stores based on the district's name provided as a placeholder.\",\n        \"virtual_table\": \"SELECT t1.store_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t3.district_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the products available in a specific store. The placeholder in the WHERE clause represents the name of the store for which the products are being queried.\",\n        \"virtual_table\": \"SELECT t1.product FROM product AS t1 JOIN store_product AS t2 ON t1.product_id  =  t2.product_id JOIN store AS t3 ON t2.store_id  =  t3.store_id WHERE t3.store_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4924", "db_id": "store_product", "question": "Find the city with the most number of stores.", "rationale": ["To find the city with the most number of stores, we need to count the number of stores in each city.", "We will join the 'store' table with the 'store_district' table to associate each store with its district.", "Next, we will join the 'district' table to get the city information for each district.", "We will use the COUNT function to count the number of stores for each city and group the results by the city name.", "Finally, we will order the results in descending order based on the count of stores and limit the result to 1 to get the city with the most stores."], "gold_sql": "SELECT t3.headquartered_city FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id GROUP BY t3.headquartered_city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["store_district", "store", "district"], "pred_sql": "SELECT d.Headquartered_City, COUNT(s.Store_ID) AS Number_of_Stores\nFROM store AS s\nJOIN store_district AS sd ON s.Store_ID = sd.Store_ID\nJOIN district AS d ON sd.District_ID = d.District_ID\nGROUP BY d.Headquartered_City\nORDER BY Number_of_Stores DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of stores located in a specific district. The query joins the 'store', 'store_district', and 'district' tables to filter stores based on the district's name provided as a placeholder.\",\n        \"virtual_table\": \"SELECT t1.store_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t3.district_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the products available in a specific store. The placeholder in the WHERE clause represents the name of the store for which the products are being queried.\",\n        \"virtual_table\": \"SELECT t1.product FROM product AS t1 JOIN store_product AS t2 ON t1.product_id  =  t2.product_id JOIN store AS t3 ON t2.store_id  =  t3.store_id WHERE t3.store_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4930", "db_id": "store_product", "question": "Find products with max page size as \"A4\" and pages per minute color smaller than 5.", "rationale": ["Identify the relevant table: The 'product' table contains the columns we need for the query.", "Determine the conditions: We need to filter products based on 'max_page_size' being 'A4' and 'pages_per_minute_color' being less than 5.", "Construct the SQL query: Use a SELECT statement to retrieve all columns from the 'product' table where the specified conditions are met."], "gold_sql": "SELECT product FROM product WHERE max_page_size  =  'A4' AND pages_per_minute_color  <  5", "source_tables": ["product"], "pred_sql": "SELECT * FROM product WHERE max_page_size = 'A4' AND pages_per_minute_color < '5';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the products from the 'product' table that match a specific search criterion. The placeholder in the WHERE clause represents a pattern for the product name or description.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE product LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4932", "db_id": "store_product", "question": "Find products with max page size as \"A4\" or pages per minute color smaller than 5.", "rationale": ["Identify the relevant table: The 'product' table contains the columns we need to filter by, specifically 'max_page_size' and 'pages_per_minute_color'.", "Determine the filtering criteria: We need to find products where the 'max_page_size' is 'A4' or the 'pages_per_minute_color' is less than 5.", "Construct the SQL query: Use a SELECT statement to retrieve all columns from the 'product' table, applying the WHERE clause to filter based on the specified conditions."], "gold_sql": "SELECT product FROM product WHERE max_page_size  =  'A4' OR pages_per_minute_color  <  5", "source_tables": ["product"], "pred_sql": "SELECT * FROM product WHERE max_page_size = 'A4' OR pages_per_minute_color < '5';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the products from the 'product' table that match a specific search criterion. The placeholder in the WHERE clause represents a pattern for the product name or description.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE product LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4935", "db_id": "store_product", "question": "What are all of the products whose name includes the substring \"Scanner\"?", "rationale": ["Identify the relevant table: The 'product' table contains the product names.", "Determine the search criterion: We need to find products whose names include the substring 'Scanner'.", "Use the SQL LIKE operator with wildcards: The pattern '%Scanner%' will match any product name that contains 'Scanner' anywhere in it.", "Construct the SQL query: Combine the SELECT statement with the WHERE clause to filter the products accordingly."], "gold_sql": "SELECT product FROM product WHERE product LIKE '%Scanner%'", "source_tables": ["product"], "pred_sql": "SELECT product FROM product WHERE product LIKE '%Scanner%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the products from the 'product' table that match a specific search criterion. The placeholder in the WHERE clause represents a pattern for the product name or description.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE product LIKE [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the products available in a specific store. The placeholder in the WHERE clause represents the name of the store for which the products are being queried.\",\n        \"virtual_table\": \"SELECT t1.product FROM product AS t1 JOIN store_product AS t2 ON t1.product_id  =  t2.product_id JOIN store AS t3 ON t2.store_id  =  t3.store_id WHERE t3.store_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4937", "db_id": "store_product", "question": "What is the most common maximum page size?", "rationale": ["Identify the relevant table: The question pertains to the maximum page size of products, which is found in the 'product' table.", "Determine the required information: We need to find the most common maximum page size, which implies counting occurrences of each maximum page size.", "Construct the SQL query: Use a SELECT statement to retrieve the 'max_page_size' and count how many times each appears in the 'product' table.", "Group the results by 'max_page_size' to aggregate counts for each unique size.", "Order the results by the count in descending order to get the most common size at the top.", "Limit the results to 1 to get only the most common maximum page size."], "gold_sql": "SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT 1", "source_tables": ["product"], "pred_sql": "SELECT max_page_size, COUNT(*) as count\nFROM product\nGROUP BY max_page_size\nORDER BY count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.4938", "db_id": "store_product", "question": "Find the name of the products that are not using the most frequently-used max page size.", "rationale": ["Identify the column of interest: 'max_page_size' from the 'product' table.", "Determine the most frequently used 'max_page_size' by grouping the products by 'max_page_size' and counting occurrences.", "Order the results by count in descending order to find the most common 'max_page_size'.", "Use a subquery to get the most frequently used 'max_page_size'.", "Select product names from the 'product' table where the 'max_page_size' is not equal to the most frequently used one."], "gold_sql": "SELECT product FROM product WHERE product != (SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["product"], "pred_sql": "SELECT product.product \nFROM product \nWHERE product.max_page_size != (SELECT max_page_size \n                                 FROM product \n                                 GROUP BY max_page_size \n                                 ORDER BY COUNT(*) DESC \n                                 LIMIT 1);", "hint": "\n"}
{"sample_id": "train.4947", "db_id": "soccer_2", "question": "How many students, on average, does each college have enrolled?", "rationale": ["Identify the goal: Calculate the average enrollment number of students at each college.", "Determine the relevant table: The 'College' table contains the 'enr' column which represents enrollment numbers.", "Use the AVG() function to compute the average of the 'enr' column.", "Construct the SQL query to select the average enrollment from the 'College' table."], "gold_sql": "SELECT avg(enr) FROM College", "source_tables": ["college"], "pred_sql": "SELECT AVG(enr) AS average_enrollment FROM College;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average enrollment number of colleges located in a specific state. The placeholder in the WHERE clause represents the name of the state.\",\n        \"virtual_table\": \"SELECT avg(enr) FROM College WHERE state  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the number of players from the 'Player' table who attended high schools with an enrollment number greater than a specified value. The placeholder in the WHERE clause represents the enrollment number of students at the high school.\",\n        \"virtual_table\": \"SELECT count(*) FROM Player WHERE HS  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4955", "db_id": "soccer_2", "question": "How many hours do the players train on average?", "rationale": ["The question asks for the average hours players train, which implies we need to calculate an average from a relevant column.", "Since the schema provided does not include a direct column for training hours, we assume there is a column named 'training_hours' in the Player table (or it could be a derived value).", "To find the average, we use the AVG() function in SQL, which calculates the average of a numeric column.", "The final SQL query selects the average of the 'training_hours' column from the Player table."], "gold_sql": "SELECT avg(HS) FROM Player", "source_tables": ["player"], "pred_sql": "SELECT AVG(training_hours) FROM Player", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average high school attended by players from the 'Player' table. The placeholder in the SELECT clause represents the high school data that will be averaged.\",\n        \"virtual_table\": \"SELECT avg(HS) FROM Player\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average high school identifier of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT avg(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4956", "db_id": "soccer_2", "question": "Find the name and training hours of players whose hours are below 1500.", "rationale": ["The query needs to find players whose training hours are below 1500.", "We need to join the 'Player' table with the 'Tryout' table to access player names and their training hours.", "The 'Player' table contains player names and IDs, while the 'Tryout' table contains the training hours and player IDs.", "We will use a JOIN operation on the 'pID' column to combine these tables.", "We will filter the results using a WHERE clause to only include players with hours less than 1500.", "Finally, we will order the results alphabetically by player name."], "gold_sql": "SELECT pName ,  HS FROM Player WHERE HS  <  1500", "source_tables": ["player"], "pred_sql": "SELECT T1.pName FROM Player AS T1 JOIN Tryout AS T2 ON T1.pID = T2.pID WHERE T2.hours < 1500 ORDER BY T1.pName", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n        \"virtual_table\": \"SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n        \"virtual_table\": \"SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.4961", "db_id": "soccer_2", "question": "What are the different types of player positions?", "rationale": ["The question asks for the different types of player positions.", "To find the distinct player positions, we need to select from the 'Tryout' table.", "Using the DISTINCT keyword will ensure that we only get unique positions.", "The final SQL query will be 'SELECT DISTINCT pPos FROM Tryout'."], "gold_sql": "SELECT count(DISTINCT pPos) FROM tryout", "source_tables": ["tryout"], "pred_sql": "SELECT DISTINCT pPos FROM Tryout", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of distinct positions that players are trying out for in the 'Tryout' table. The result will give an overview of the variety of positions available for players during tryouts.\",\n        \"virtual_table\": \"SELECT count(DISTINCT pPos) FROM tryout\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n        \"virtual_table\": \"SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName\"\n    }\n}\n"}
{"sample_id": "train.4962", "db_id": "soccer_2", "question": "How many students got accepted after the tryout?", "rationale": ["Identify the relevant table: The 'Tryout' table contains the information about players and their decisions after tryouts.", "Determine the condition for acceptance: We need to count the number of players whose decision is 'accepted'.", "Construct the SQL query: Use the COUNT function to count the number of rows in the 'Tryout' table where the decision is 'accepted'."], "gold_sql": "SELECT count(*) FROM tryout WHERE decision  =  'yes'", "source_tables": ["tryout"], "pred_sql": "SELECT COUNT(*) FROM tryout WHERE decision = 'accepted'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n        \"virtual_table\": \"SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n        \"virtual_table\": \"SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName\"\n    }\n}\n"}
{"sample_id": "train.4966", "db_id": "soccer_2", "question": "Find the max, average and min training hours of all players.", "rationale": ["The task is to find the maximum, average, and minimum training hours of all players.", "We need to select the maximum, average, and minimum values from a column that represents training hours.", "Since the schema does not explicitly mention a column for training hours, we assume it is a part of the Player table or needs to be calculated based on other data.", "The SQL query will use aggregate functions MAX(), AVG(), and MIN() to compute the required values from the appropriate column."], "gold_sql": "SELECT avg(HS) ,  max(HS) ,  min(HS) FROM Player", "source_tables": ["player"], "pred_sql": "SELECT MAX(training_hours) AS max_hours, AVG(training_hours) AS avg_hours, MIN(training_hours) AS min_hours FROM Player", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average high school attended by players from the 'Player' table. The placeholder in the SELECT clause represents the high school data that will be averaged.\",\n        \"virtual_table\": \"SELECT avg(HS) FROM Player\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average high school identifier of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT avg(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of distinct positions that players are trying out for in the 'Tryout' table. The result will give an overview of the variety of positions available for players during tryouts.\",\n        \"virtual_table\": \"SELECT count(DISTINCT pPos) FROM tryout\"\n    }\n}\n"}
{"sample_id": "train.4967", "db_id": "soccer_2", "question": "What is the average, maximum, and minimum for the number of hours spent training?", "rationale": ["The question asks for the average, maximum, and minimum number of hours spent training.", "To calculate these statistics, we need to use aggregate functions: AVG() for average, MAX() for maximum, and MIN() for minimum.", "Assuming there is a table named 'Training' that contains a column 'training_hours' which records the hours spent training by players.", "The SQL query will select the average, maximum, and minimum values from the 'training_hours' column in the 'Training' table."], "gold_sql": "SELECT avg(HS) ,  max(HS) ,  min(HS) FROM Player", "source_tables": ["player"], "pred_sql": "SELECT AVG(training_hours) AS average_hours, MAX(training_hours) AS max_hours, MIN(training_hours) AS min_hours FROM Training;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average high school attended by players from the 'Player' table. The placeholder in the SELECT clause represents the high school data that will be averaged.\",\n        \"virtual_table\": \"SELECT avg(HS) FROM Player\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of distinct positions that players are trying out for in the 'Tryout' table. The result will give an overview of the variety of positions available for players during tryouts.\",\n        \"virtual_table\": \"SELECT count(DISTINCT pPos) FROM tryout\"\n    }\n}\n"}
{"sample_id": "train.4970", "db_id": "soccer_2", "question": "What are the names of players whose training hours is between 500 and 1500?", "rationale": ["Identify the relevant tables: We need to find player names, which are in the 'Player' table.", "Determine the condition: We are looking for players whose training hours are between 500 and 1500.", "Since the hint does not provide information about a 'training_hours' column, we assume it exists in the 'Player' table or is derived from the context of the question.", "Construct the SQL query to select player names from the 'Player' table where their training hours fall within the specified range."], "gold_sql": "SELECT pName FROM Player WHERE HS BETWEEN 500 AND 1500", "source_tables": ["player"], "pred_sql": "SELECT pName FROM Player WHERE pID IN (SELECT pID FROM Tryout) AND training_hours BETWEEN 500 AND 1500;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n        \"virtual_table\": \"SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n        \"virtual_table\": \"SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.4971", "db_id": "soccer_2", "question": "What are the names of players who train between 500 and 1500 hours?", "rationale": ["Identify the relevant tables: Player and Tryout.", "Join the Player table with the Tryout table on the player ID (pID).", "Filter the results to include only those players who have trained between 500 and 1500 hours.", "Select the names of the players (pName) from the Player table.", "Order the results alphabetically by player name."], "gold_sql": "SELECT pName FROM Player WHERE HS BETWEEN 500 AND 1500", "source_tables": ["player"], "pred_sql": "SELECT T1.pName FROM Player AS T1 JOIN Tryout AS T2 ON T1.pID = T2.pID WHERE T2.hours BETWEEN 500 AND 1500 ORDER BY T1.pName", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n        \"virtual_table\": \"SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n        \"virtual_table\": \"SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.4975", "db_id": "soccer_2", "question": "What are the names and enrollment numbers for colleges that have more than 10000 enrolled and are located in Louisiana?", "rationale": ["Identify the relevant table: The question pertains to colleges, so we will use the 'College' table.", "Determine the columns needed: We need the names of the colleges ('cName') and their enrollment numbers ('enr').", "Set the conditions for the query: We need colleges with an enrollment number greater than 10000 and located in Louisiana.", "Construct the SQL query: Using the SELECT statement to retrieve 'cName' and 'enr' from the 'College' table with the specified conditions."], "gold_sql": "SELECT cName ,  enr FROM College WHERE enr  >  10000 AND state = 'LA'", "source_tables": ["college"], "pred_sql": "SELECT cName, enr FROM College WHERE enr > 10000 AND state = 'Louisiana';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average enrollment number of colleges located in a specific state. The placeholder in the WHERE clause represents the name of the state.\",\n        \"virtual_table\": \"SELECT avg(enr) FROM College WHERE state  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the number of players from the 'Player' table who attended high schools with an enrollment number greater than a specified value. The placeholder in the WHERE clause represents the enrollment number of students at the high school.\",\n        \"virtual_table\": \"SELECT count(*) FROM Player WHERE HS  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of players from the 'Player' table who attended high schools with an enrollment number greater than a specified value. The placeholder in the WHERE clause represents the minimum enrollment number of students at the high school.\",\n        \"virtual_table\": \"SELECT count(*) FROM Player WHERE HS  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4981", "db_id": "soccer_2", "question": "What are the name of the players who received a card in descending order of the hours of training?", "rationale": ["The question asks for the names of players who received a card, which implies we need to look at the Player table for player names.", "We need to join the Player table with the Tryout table to get the relevant information about the players' tryouts.", "The ordering is specified as descending, but it is unclear what specific column to order by since 'hours of training' is not a column in the provided schema.", "However, since 'decision' is mentioned in the hint, we can assume it might relate to the outcome of their tryouts, so we will order by 'decision' in descending order."], "gold_sql": "SELECT pName FROM Player WHERE yCard  =  'yes' ORDER BY HS DESC", "source_tables": ["player"], "pred_sql": "SELECT T1.pName FROM Player AS T1 JOIN Tryout AS T2 ON T1.pID = T2.pID ORDER BY T2.decision DESC", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n        \"virtual_table\": \"SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n        \"virtual_table\": \"SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.4984", "db_id": "soccer_2", "question": "Which position is most popular among players in the tryout?", "rationale": ["To find the most popular position among players in the tryout, we need to count how many players are trying out for each position.", "We will use the 'Tryout' table, which contains the 'pPos' column representing the position players are trying out for.", "We will group the results by 'pPos' to get the count of players for each position.", "Next, we will order the results in descending order based on the count of players for each position.", "Finally, we will limit the results to 1 to get only the most popular position."], "gold_sql": "SELECT pPos FROM tryout GROUP BY pPos ORDER BY count(*) DESC LIMIT 1", "source_tables": ["tryout"], "pred_sql": "SELECT pPos, COUNT(*) as position_count \nFROM Tryout \nGROUP BY pPos \nORDER BY position_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of distinct positions that players are trying out for in the 'Tryout' table. The result will give an overview of the variety of positions available for players during tryouts.\",\n        \"virtual_table\": \"SELECT count(DISTINCT pPos) FROM tryout\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n        \"virtual_table\": \"SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName\"\n    }\n}\n"}
{"sample_id": "train.4985", "db_id": "soccer_2", "question": "What was the most popular position at tryouts?", "rationale": ["To find the most popular position at tryouts, we need to count how many players are trying out for each position.", "We can achieve this by selecting the position (pPos) from the Tryout table and counting the occurrences of each position.", "We will group the results by the position to get the count for each one.", "To determine which position is the most popular, we will order the results in descending order based on the count.", "Finally, we will limit the results to just one entry to get the most popular position."], "gold_sql": "SELECT pPos FROM tryout GROUP BY pPos ORDER BY count(*) DESC LIMIT 1", "source_tables": ["tryout"], "pred_sql": "SELECT pPos, COUNT(*) as position_count \nFROM Tryout \nGROUP BY pPos \nORDER BY position_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of distinct positions that players are trying out for in the 'Tryout' table. The result will give an overview of the variety of positions available for players during tryouts.\",\n        \"virtual_table\": \"SELECT count(DISTINCT pPos) FROM tryout\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n        \"virtual_table\": \"SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName\"\n    }\n}\n"}
{"sample_id": "train.4988", "db_id": "soccer_2", "question": "What is minimum hours of the students playing in different position?", "rationale": ["Identify the relevant table: The 'Tryout' table contains the information about players and their positions.", "Determine the required information: We need to find the minimum hours of students playing in different positions, which implies counting the number of players for each position.", "Use the COUNT function to count the number of players for each position in the 'Tryout' table.", "Group the results by position using GROUP BY to get the count for each position."], "gold_sql": "SELECT min(T2.HS) ,   T1.pPos FROM tryout AS T1 JOIN player AS T2 ON T1.pID  =  T2.pID GROUP BY T1.pPos", "source_tables": ["player", "tryout"], "pred_sql": "SELECT pPos, COUNT(*) AS min_hours FROM Tryout GROUP BY pPos", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of distinct positions that players are trying out for in the 'Tryout' table. The result will give an overview of the variety of positions available for players during tryouts.\",\n        \"virtual_table\": \"SELECT count(DISTINCT pPos) FROM tryout\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the total number of players who are trying out for a specific position from the 'Tryout' table. The placeholder in the WHERE clause represents the position for which the count is being calculated.\",\n        \"virtual_table\": \"SELECT count(*) FROM tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4989", "db_id": "soccer_2", "question": "For each position, what is the minimum time students spent practicing?", "rationale": ["Identify the relevant tables: We need to find the minimum time students spent practicing for each position, which suggests we need a table that records practice sessions and their durations.", "Assume there is a table named 'practice_sessions' that records practice times for players, including columns for 'pID', 'pPos', and 'practice_time'.", "We need to group the results by 'pPos' to get the minimum practice time for each position.", "Use the MIN() function to find the minimum practice time for each position.", "Construct the SQL query to select the position and the minimum practice time, grouping by position."], "gold_sql": "SELECT min(T2.HS) ,   T1.pPos FROM tryout AS T1 JOIN player AS T2 ON T1.pID  =  T2.pID GROUP BY T1.pPos", "source_tables": ["player", "tryout"], "pred_sql": "SELECT pPos, MIN(practice_time) AS min_practice_time\nFROM practice_sessions\nGROUP BY pPos;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of distinct positions that players are trying out for in the 'Tryout' table. The result will give an overview of the variety of positions available for players during tryouts.\",\n        \"virtual_table\": \"SELECT count(DISTINCT pPos) FROM tryout\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the total number of players who are trying out for a specific position from the 'Tryout' table. The placeholder in the WHERE clause represents the position for which the count is being calculated.\",\n        \"virtual_table\": \"SELECT count(*) FROM tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5003", "db_id": "soccer_2", "question": "What are the names and hours spent practicing of every student who received a yes at tryouts?", "rationale": ["Identify the relevant tables: Player and Tryout.", "We need the names of players, which are in the Player table under the column pName.", "We also need to know the hours spent practicing, which is assumed to be a column in the Tryout table (though not explicitly mentioned in the schema).", "We need to join the Player table with the Tryout table on the pID column to link players with their tryout decisions.", "We filter the results to include only those players whose decision was 'yes'.", "Finally, we select the player's name and their hours spent practicing."], "gold_sql": "SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes'", "source_tables": ["player", "tryout"], "pred_sql": "SELECT P.pName, T.hours_spent_practicing FROM Player AS P JOIN Tryout AS T ON P.pID = T.pID WHERE T.decision = 'yes'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n        \"virtual_table\": \"SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n        \"virtual_table\": \"SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.5007", "db_id": "soccer_2", "question": "What are the names of all students who successfully tried out for the position of striker?", "rationale": ["Identify the relevant tables: Player and Tryout.", "We need to find players who tried out for the position of 'striker'.", "We will join the Player table with the Tryout table on the player ID (pID).", "We need to filter the results to include only those players whose tryout decision was 'successful'.", "Select the names of these players and order the results alphabetically by player name."], "gold_sql": "SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes' AND T2.pPos  =  'striker'", "source_tables": ["player", "tryout"], "pred_sql": "SELECT T1.pName \nFROM Player AS T1 \nJOIN Tryout AS T2 ON T1.pID = T2.pID \nWHERE T2.pPos = 'striker' AND T2.decision = 'successful' \nORDER BY T1.pName;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n        \"virtual_table\": \"SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n        \"virtual_table\": \"SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.5013", "db_id": "soccer_2", "question": "What is the average number of hours spent practicing for students who got rejected?", "rationale": ["Identify the relevant tables: Player and Tryout.", "We need to find players who got rejected, so we will filter the Tryout table based on the decision column.", "Join the Player table with the Tryout table on the player ID (pID) to access player information for those who tried out.", "Calculate the average of the high school identifier (HS) for players who were rejected by using the AVG function in SQL.", "Construct the SQL query using the identified conditions and calculations."], "gold_sql": "SELECT avg(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'no'", "source_tables": ["player", "tryout"], "pred_sql": "SELECT avg(T1.HS) FROM Player AS T1 JOIN Tryout AS T2 ON T1.pID = T2.pID WHERE T2.decision = 'rejected'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average high school identifier of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT avg(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average high school attended by players from the 'Player' table. The placeholder in the SELECT clause represents the high school data that will be averaged.\",\n        \"virtual_table\": \"SELECT avg(HS) FROM Player\"\n    }\n}\n"}
{"sample_id": "train.5018", "db_id": "soccer_2", "question": "Which college has any student who is a goalie and succeeded in the tryout.", "rationale": ["Identify the relevant tables: College, Player, and Tryout.", "We need to find colleges that have students who are goalies and succeeded in their tryouts.", "Join the College table with the Tryout table on the college name (cName).", "Join the resulting table with the Player table on the player ID (pID).", "Filter the results where the position (pPos) is 'goalie' and the decision is 'succeeded'.", "Select distinct college names (cName) to avoid duplicates."], "gold_sql": "SELECT cName FROM  tryout WHERE decision  =  'yes' AND pPos  =  'goalie'", "source_tables": ["tryout"], "pred_sql": "SELECT DISTINCT C.cName \nFROM College AS C \nJOIN Tryout AS T ON C.cName = T.cName \nJOIN Player AS P ON T.pID = P.pID \nWHERE T.pPos = 'goalie' AND T.decision = 'succeeded';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the states of colleges where a specific player has participated in tryouts. The placeholder in the WHERE clause represents the player's name.\",\n        \"virtual_table\": \"SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName JOIN player AS T3 ON T2.pID  =  T3.pID WHERE T3.pName  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n        \"virtual_table\": \"SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName\"\n    }\n}\n"}
{"sample_id": "train.5022", "db_id": "soccer_2", "question": "What is the state and enrollment of the colleges where have any students who got accepted in the tryout decision.", "rationale": ["Identify the relevant tables: College and Tryout.", "We need to find the state and enrollment of colleges where students got accepted in the tryout decision.", "Join the College table with the Tryout table on the college name (cName).", "Filter the results to include only those records where the decision in the Tryout table is 'accepted'.", "Select the state and enrollment number from the resulting joined table."], "gold_sql": "SELECT DISTINCT T1.state ,  T1.enr FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  'yes'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT C.state, C.enr FROM College AS C JOIN Tryout AS T ON C.cName = T.cName WHERE T.decision = 'accepted';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the states of colleges where a specific player has participated in tryouts. The placeholder in the WHERE clause represents the player's name.\",\n        \"virtual_table\": \"SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName JOIN player AS T3 ON T2.pID  =  T3.pID WHERE T3.pName  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average enrollment number of colleges located in a specific state. The placeholder in the WHERE clause represents the name of the state.\",\n        \"virtual_table\": \"SELECT avg(enr) FROM College WHERE state  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5023", "db_id": "soccer_2", "question": "How many students are enrolled in colleges that have student accepted during tryouts, and in which states are those colleges?", "rationale": ["Identify the colleges that have accepted students during tryouts by filtering the Tryout table for accepted decisions.", "Join the College table to get the enrollment numbers and states of these colleges.", "Use the IN clause to filter the College table based on the names of colleges from the Tryout table that have accepted players.", "Sum the enrollment numbers of these colleges to get the total number of students enrolled.", "Use GROUP_CONCAT to list the distinct states of these colleges."], "gold_sql": "SELECT DISTINCT T1.state ,  T1.enr FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  'yes'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT SUM(CAST(enr AS INTEGER)) AS total_enrollment, GROUP_CONCAT(DISTINCT state) AS states FROM College WHERE cName IN (SELECT DISTINCT cName FROM Tryout WHERE decision = 'accepted')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the states of colleges where a specific player has participated in tryouts. The placeholder in the WHERE clause represents the player's name.\",\n        \"virtual_table\": \"SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName JOIN player AS T3 ON T2.pID  =  T3.pID WHERE T3.pName  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n        \"virtual_table\": \"SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName\"\n    }\n}\n"}
{"sample_id": "train.5026", "db_id": "soccer_2", "question": "Find the names of schools that have some students playing in goalie and mid positions.", "rationale": ["Identify the relevant table: The Tryout table contains information about player positions and the colleges where they are trying out.", "We need to find colleges (cName) where players are trying out for both 'goalie' and 'mid' positions.", "Use the IN clause to filter for the two positions: 'goalie' and 'mid'.", "To ensure that we only get colleges with players in both positions, we can group by cName and use HAVING to count distinct positions.", "The HAVING clause checks that the count of distinct positions is equal to 2, meaning both positions are represented."], "gold_sql": "SELECT cName FROM  tryout WHERE pPos  =  'goalie' INTERSECT SELECT cName FROM  tryout WHERE pPos  =  'mid'", "source_tables": ["tryout"], "pred_sql": "SELECT DISTINCT cName FROM Tryout WHERE pPos IN ('goalie', 'mid') GROUP BY cName HAVING COUNT(DISTINCT pPos) = 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the states of colleges where a specific player has participated in tryouts. The placeholder in the WHERE clause represents the player's name.\",\n        \"virtual_table\": \"SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName JOIN player AS T3 ON T2.pID  =  T3.pID WHERE T3.pName  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n        \"virtual_table\": \"SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName\"\n    }\n}\n"}
{"sample_id": "train.5028", "db_id": "soccer_2", "question": "Find the names of states that have some college students playing in goalie and mid positions.", "rationale": ["Identify the relevant tables: College, Player, and Tryout.", "We need to find states of colleges where players are trying out for specific positions (goalie and mid).", "Join the College table with the Tryout table on the college name (cName).", "Filter the results to include only those tryouts where the position (pPos) is either 'goalie' or 'mid'.", "Select distinct states from the resulting dataset to avoid duplicates."], "gold_sql": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'goalie' INTERSECT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'mid'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT DISTINCT C.state \nFROM College AS C \nJOIN Tryout AS T ON C.cName = T.cName \nWHERE T.pPos IN ('goalie', 'mid')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the states of colleges where a specific player has participated in tryouts. The placeholder in the WHERE clause represents the player's name.\",\n        \"virtual_table\": \"SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName JOIN player AS T3 ON T2.pID  =  T3.pID WHERE T3.pName  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.5029", "db_id": "soccer_2", "question": "What are the names of the states that have some college students playing in the positions of goalie and mid-field?", "rationale": ["Identify the states of colleges where players are trying out for specific positions.", "Use the Tryout table to find colleges where players are trying out for the positions 'goalie' and 'mid-field'.", "Use a subquery to get the list of college names (cName) from the Tryout table for the specified positions.", "Select distinct states from the College table where the college names match those found in the subquery."], "gold_sql": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'goalie' INTERSECT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'mid'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT DISTINCT state FROM College WHERE cName IN (SELECT cName FROM Tryout WHERE pPos IN ('goalie', 'mid-field'))", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the states of colleges where a specific player has participated in tryouts. The placeholder in the WHERE clause represents the player's name.\",\n        \"virtual_table\": \"SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName JOIN player AS T3 ON T2.pID  =  T3.pID WHERE T3.pName  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n        \"virtual_table\": \"SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName\"\n    }\n}\n"}
{"sample_id": "train.5030", "db_id": "soccer_2", "question": "How many schools have some students playing in goalie and mid positions.", "rationale": ["Identify the positions of interest: goalie and mid.", "Use the INTERSECT operator to find colleges where players are trying out for both positions.", "Count the number of distinct colleges that meet this criterion using COUNT(*) in the outer query."], "gold_sql": "SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  'goalie' INTERSECT SELECT cName FROM  tryout WHERE pPos  =  'mid')", "source_tables": ["tryout"], "pred_sql": "SELECT COUNT(*) FROM (SELECT cName FROM tryout WHERE pPos = 'goalie' INTERSECT SELECT cName FROM tryout WHERE pPos = 'mid')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of distinct positions that players are trying out for in the 'Tryout' table. The result will give an overview of the variety of positions available for players during tryouts.\",\n        \"virtual_table\": \"SELECT count(DISTINCT pPos) FROM tryout\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the states of colleges where a specific player has participated in tryouts. The placeholder in the WHERE clause represents the player's name.\",\n        \"virtual_table\": \"SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName JOIN player AS T3 ON T2.pID  =  T3.pID WHERE T3.pName  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5037", "db_id": "soccer_2", "question": "What is the count of states with college students playing in the mid position but not as goalies?", "rationale": ["Identify the states of colleges where players are trying out for the 'mid' position.", "Exclude players who are trying out for the 'goalie' position.", "Use a subquery to find colleges where players are trying out for 'mid' but not 'goalie'.", "Count the distinct states from the colleges identified in the previous step."], "gold_sql": "SELECT COUNT(*) FROM (SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'mid' EXCEPT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'goalie')", "source_tables": ["tryout", "college"], "pred_sql": "SELECT COUNT(DISTINCT state) FROM College WHERE cName IN (SELECT cName FROM Tryout WHERE pPos = 'mid' AND pID NOT IN (SELECT pID FROM Tryout WHERE pPos = 'goalie'))", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the states of colleges where a specific player has participated in tryouts. The placeholder in the WHERE clause represents the player's name.\",\n        \"virtual_table\": \"SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName JOIN player AS T3 ON T2.pID  =  T3.pID WHERE T3.pName  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of distinct positions that players are trying out for in the 'Tryout' table. The result will give an overview of the variety of positions available for players during tryouts.\",\n        \"virtual_table\": \"SELECT count(DISTINCT pPos) FROM tryout\"\n    }\n}\n"}
{"sample_id": "train.5039", "db_id": "soccer_2", "question": "What are the states with colleges that have enrollments less than the some other college?", "rationale": ["Identify the requirement to find states with colleges that have enrollments less than some other college.", "To achieve this, we need to compare the enrollment numbers of colleges in different states.", "We can use a subquery to find the maximum enrollment number from the College table, which represents the enrollment of the college we are comparing against.", "The main query will select distinct states from the College table where the enrollment number is less than the maximum enrollment found in the subquery."], "gold_sql": "SELECT DISTINCT state FROM college WHERE enr  <  (SELECT max(enr) FROM college)", "source_tables": ["college"], "pred_sql": "SELECT DISTINCT state FROM College WHERE enr < (SELECT MAX(enr) FROM College)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average enrollment number of colleges located in a specific state. The placeholder in the WHERE clause represents the name of the state.\",\n        \"virtual_table\": \"SELECT avg(enr) FROM College WHERE state  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the states of colleges where a specific player has participated in tryouts. The placeholder in the WHERE clause represents the player's name.\",\n        \"virtual_table\": \"SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName JOIN player AS T3 ON T2.pID  =  T3.pID WHERE T3.pName  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5102", "db_id": "cre_Drama_Workshop_Groups", "question": "Show the minimum, average, maximum order quantity of all invoices.", "rationale": ["The task requires calculating the minimum, average, and maximum order quantities from the 'Invoices' table.", "The hint provides a virtual table that summarizes these values using the SQL aggregate functions min(), avg(), and max().", "The virtual table is structured as 'SELECT min(Order_Quantity), avg(Order_Quantity), max(Order_Quantity) FROM Invoices', which directly addresses the requirement of the query.", "Thus, the final SQL query is constructed based on the provided virtual table."], "gold_sql": "SELECT min(Order_Quantity) ,  avg(Order_Quantity) ,  max(Order_Quantity) FROM INVOICES", "source_tables": ["invoices"], "pred_sql": "SELECT min(Order_Quantity), avg(Order_Quantity), max(Order_Quantity) FROM Invoices", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the minimum, average, and maximum quantities of products ordered as recorded in the 'Invoices' table. The placeholders in the SELECT statement represent the aggregated values of the order quantities.\",\n        \"virtual_table\": \"SELECT min(Order_Quantity) ,  avg(Order_Quantity) ,  max(Order_Quantity) FROM INVOICES\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average quantity of products ordered from the 'Invoices' table for a specific payment method. The placeholder in the WHERE clause represents the payment method code used for filtering the results.\",\n        \"virtual_table\": \"SELECT avg(Order_Quantity) FROM Invoices WHERE payment_method_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average quantity of products ordered from the 'Invoices' table for a specific payment method. The placeholder in the WHERE clause represents the payment method code used for filtering the results.\",\n        \"virtual_table\": \"SELECT avg(Order_Quantity) FROM Invoices WHERE payment_method_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5118", "db_id": "cre_Drama_Workshop_Groups", "question": "What is the payment method code used by the most orders?", "rationale": ["To find the payment method code used by the most orders, we need to count the number of orders associated with each payment method code in the Invoices table.", "We will use the COUNT function to count the number of occurrences of each payment_method_code.", "We will group the results by payment_method_code to aggregate the counts for each method.", "To get the payment method with the highest count, we will order the results in descending order based on the count.", "Finally, we will limit the results to just one record to get the payment method code used by the most orders."], "gold_sql": "SELECT payment_method_code FROM INVOICES GROUP BY payment_method_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["invoices"], "pred_sql": "SELECT payment_method_code, COUNT(*) as order_count \nFROM Invoices \nGROUP BY payment_method_code \nORDER BY order_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average quantity of products ordered from the 'Invoices' table for a specific payment method. The placeholder in the WHERE clause represents the payment method code used for filtering the results.\",\n        \"virtual_table\": \"SELECT avg(Order_Quantity) FROM Invoices WHERE payment_method_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average quantity of products ordered from the 'Invoices' table for a specific payment method. The placeholder in the WHERE clause represents the payment method code used for filtering the results.\",\n        \"virtual_table\": \"SELECT avg(Order_Quantity) FROM Invoices WHERE payment_method_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the minimum, average, and maximum quantities of products ordered as recorded in the 'Invoices' table. The placeholders in the SELECT statement represent the aggregated values of the order quantities.\",\n        \"virtual_table\": \"SELECT min(Order_Quantity) ,  avg(Order_Quantity) ,  max(Order_Quantity) FROM INVOICES\"\n    }\n}\n"}
{"sample_id": "train.5127", "db_id": "cre_Drama_Workshop_Groups", "question": "Give me the descriptions of the service types that cost more than 100.", "rationale": ["Identify the relevant tables: Ref_Service_Types for service type descriptions and Services for product prices.", "Join the Ref_Service_Types table with the Services table on the Service_Type_Code to link service descriptions with their corresponding prices.", "Filter the results to include only those services where the Product_Price is greater than 100.", "Construct the SQL query using the identified tables, join condition, and filter condition."], "gold_sql": "SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Price  >  100", "source_tables": ["services", "ref_service_types"], "pred_sql": "SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code = T2.Service_Type_Code WHERE T2.Product_Price > 100", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of service type descriptions from the 'Ref_Service_Types' table that are associated with services having a product price greater than a specified amount. The placeholder in the WHERE clause represents the minimum product price to filter the results.\",\n        \"virtual_table\": \"SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Price  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5134", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the names of workshop groups in which services with product name \"film\" are performed?", "rationale": ["Identify the relevant tables: 'Drama_Workshop_Groups' for workshop group names and 'Services' for product names.", "Determine the relationship between the tables: 'Drama_Workshop_Groups' is linked to 'Services' through 'Workshop_Group_ID'.", "Formulate the SQL query to select the 'Store_Name' from 'Drama_Workshop_Groups'.", "Add a JOIN clause to connect 'Drama_Workshop_Groups' with 'Services' on 'Workshop_Group_ID'.", "Include a WHERE clause to filter services where the 'Product_Name' is 'film'."], "gold_sql": "SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T2.Product_Name  =  'film'", "source_tables": ["services", "drama_workshop_groups"], "pred_sql": "SELECT DWG.Store_Name \nFROM Drama_Workshop_Groups AS DWG \nJOIN Services AS S ON DWG.Workshop_Group_ID = S.Workshop_Group_ID \nWHERE S.Product_Name = 'film';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the phone numbers and email addresses of stores associated with specific drama workshop groups. The data is retrieved by joining the 'Drama_Workshop_Groups' table with the 'Services' table based on the workshop group identifier, allowing for the extraction of relevant contact information for each store linked to the workshop groups.\",\n        \"virtual_table\": \"SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the phone numbers and email addresses of stores associated with specific drama workshop groups. The data is retrieved by joining the 'Drama_Workshop_Groups' table with the 'Services' table based on the workshop group identifier, allowing for the extraction of relevant contact information for each store linked to the workshop groups.\",\n        \"virtual_table\": \"SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID\"\n    }\n}\n"}
{"sample_id": "train.5142", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the order details of the products with price higher than 2000?", "rationale": ["Identify the relevant table for order details, which is the 'Invoices' table.", "Determine the necessary columns to retrieve: Order_ID, Order_Quantity, and Product_ID from the 'Invoices' table.", "Filter the products based on the price condition (greater than 2000) by using a subquery on the 'Products' table.", "The subquery selects Product_IDs from the 'Products' table where Product_Price is greater than 2000.", "Combine the main query and subquery to get the order details for products that meet the price condition."], "gold_sql": "SELECT T1.Other_Item_Details FROM ORDER_ITEMS AS T1 JOIN Products AS T2 ON T1.Product_ID  =  T2.Product_ID WHERE T2.Product_price  >  2000", "source_tables": ["products", "order_items"], "pred_sql": "SELECT Order_ID, Order_Quantity, Product_ID FROM Invoices WHERE Product_ID IN (SELECT Product_ID FROM Products WHERE Product_Price > 2000)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of service type descriptions from the 'Ref_Service_Types' table that are associated with services having a product price greater than a specified amount. The placeholder in the WHERE clause represents the minimum product price to filter the results.\",\n        \"virtual_table\": \"SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Price  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the minimum, average, and maximum quantities of products ordered as recorded in the 'Invoices' table. The placeholders in the SELECT statement represent the aggregated values of the order quantities.\",\n        \"virtual_table\": \"SELECT min(Order_Quantity) ,  avg(Order_Quantity) ,  max(Order_Quantity) FROM INVOICES\"\n    }\n}\n"}
{"sample_id": "train.5143", "db_id": "cre_Drama_Workshop_Groups", "question": "Find the order detail for the products with price above 2000.", "rationale": ["Identify the relevant tables: We need to retrieve order details and product information, so we will use the 'Order_Items' and 'Products' tables.", "Determine the columns to select: We want to include order item ID, order ID, product ID, order quantity, product name, and product price.", "Establish the join condition: We need to join 'Order_Items' with 'Products' on the 'Product_ID' column to get product details for each order item.", "Add the filtering condition: We need to filter the results to include only those products with a price greater than 2000."], "gold_sql": "SELECT T1.Other_Item_Details FROM ORDER_ITEMS AS T1 JOIN Products AS T2 ON T1.Product_ID  =  T2.Product_ID WHERE T2.Product_price  >  2000", "source_tables": ["products", "order_items"], "pred_sql": "SELECT Order_Items.Order_Item_ID, Order_Items.Order_ID, Order_Items.Product_ID, Order_Items.Order_Quantity, Products.Product_Name, Products.Product_Price \nFROM Order_Items \nJOIN Products ON Order_Items.Product_ID = Products.Product_ID \nWHERE Products.Product_Price > 2000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of service type descriptions from the 'Ref_Service_Types' table that are associated with services having a product price greater than a specified amount. The placeholder in the WHERE clause represents the minimum product price to filter the results.\",\n        \"virtual_table\": \"SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Price  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5160", "db_id": "cre_Drama_Workshop_Groups", "question": "What is the most frequent status of bookings?", "rationale": ["Identify the relevant table: The question pertains to bookings, so we will use the 'Bookings' table.", "Determine the required information: We need to find the most frequent status of bookings, which means we need to count occurrences of each status code.", "Use the COUNT function: We will count how many times each 'Status_Code' appears in the 'Bookings' table.", "Group the results: We will group the results by 'Status_Code' to aggregate the counts for each status.", "Order the results: To find the most frequent status, we will order the results in descending order based on the count.", "Limit the results: Since we only want the most frequent status, we will limit the results to 1."], "gold_sql": "SELECT Status_Code FROM BOOKINGS GROUP BY Status_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["bookings"], "pred_sql": "SELECT Status_Code, COUNT(*) as Frequency\nFROM Bookings\nGROUP BY Status_Code\nORDER BY Frequency DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5161", "db_id": "cre_Drama_Workshop_Groups", "question": "Which status code is the most common of all the bookings?", "rationale": ["Identify the relevant table: The question pertains to bookings, so we will use the 'Bookings' table.", "Determine the required information: We need to find the most common status code, which implies counting occurrences of each status code.", "Use the COUNT function: We will count how many times each status code appears in the 'Bookings' table.", "Group the results: We will group the results by 'Status_Code' to aggregate the counts for each unique status code.", "Order the results: To find the most common status code, we will order the results in descending order based on the count.", "Limit the results: Since we only want the most common status code, we will limit the results to 1."], "gold_sql": "SELECT Status_Code FROM BOOKINGS GROUP BY Status_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["bookings"], "pred_sql": "SELECT Status_Code, COUNT(*) as Count\nFROM Bookings\nGROUP BY Status_Code\nORDER BY Count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5162", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the names of the workshop groups that have bookings with status code \"stop\"?", "rationale": ["Identify the relevant tables: 'Drama_Workshop_Groups' for workshop group names and 'Bookings' for booking status.", "Join the 'Drama_Workshop_Groups' table with the 'Bookings' table on the 'Workshop_Group_ID' to link workshop groups with their bookings.", "Filter the results to include only those bookings where the status code is 'stop'.", "Select the 'Store_Name' from the 'Drama_Workshop_Groups' table as the final output."], "gold_sql": "SELECT T2.Store_Name FROM Bookings AS T1 JOIN Drama_Workshop_Groups AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T1.Status_Code  =  'stop'", "source_tables": ["drama_workshop_groups", "bookings"], "pred_sql": "SELECT DWG.Store_Name \nFROM Drama_Workshop_Groups AS DWG \nJOIN Bookings AS B ON DWG.Workshop_Group_ID = B.Workshop_Group_ID \nWHERE B.Status_Code = 'stop';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the phone numbers and email addresses of stores associated with specific drama workshop groups. The data is retrieved by joining the 'Drama_Workshop_Groups' table with the 'Services' table based on the workshop group identifier, allowing for the extraction of relevant contact information for each store linked to the workshop groups.\",\n        \"virtual_table\": \"SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the phone numbers and email addresses of stores associated with specific drama workshop groups. The data is retrieved by joining the 'Drama_Workshop_Groups' table with the 'Services' table based on the workshop group identifier, allowing for the extraction of relevant contact information for each store linked to the workshop groups.\",\n        \"virtual_table\": \"SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID\"\n    }\n}\n"}
{"sample_id": "train.5171", "db_id": "cre_Drama_Workshop_Groups", "question": "Give me the description of the service type that offers not only the photo product but also the film product.", "rationale": ["Identify the relevant tables: Ref_Service_Types for service descriptions, Services for linking services to products, and Products for product names.", "Join Ref_Service_Types with Services to get the service type descriptions associated with each service.", "Join Services with Order_Items to link services to their respective products.", "Use a subquery to filter products that are both 'photo' and 'film'. This subquery counts distinct product names and ensures both are present.", "Select distinct service type descriptions that meet the criteria."], "gold_sql": "SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  'photo' INTERSECT SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  'film'", "source_tables": ["services", "ref_service_types"], "pred_sql": "SELECT DISTINCT T1.Service_Type_Description \nFROM Ref_Service_Types AS T1 \nJOIN Services AS T2 ON T1.Service_Type_Code = T2.Service_Type_Code \nJOIN Order_Items AS T3 ON T2.Product_ID = T3.Product_ID \nWHERE T3.Product_ID IN (\n    SELECT Product_ID FROM Products WHERE Product_Name IN ('photo', 'film')\n    GROUP BY Product_ID\n    HAVING COUNT(DISTINCT Product_Name) = 2\n);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of service type descriptions from the 'Ref_Service_Types' table that are associated with services having a product price greater than a specified amount. The placeholder in the WHERE clause represents the minimum product price to filter the results.\",\n        \"virtual_table\": \"SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Price  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the phone numbers and email addresses of stores associated with specific drama workshop groups. The data is retrieved by joining the 'Drama_Workshop_Groups' table with the 'Services' table based on the workshop group identifier, allowing for the extraction of relevant contact information for each store linked to the workshop groups.\",\n        \"virtual_table\": \"SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the phone numbers and email addresses of stores associated with specific drama workshop groups. The data is retrieved by joining the 'Drama_Workshop_Groups' table with the 'Services' table based on the workshop group identifier, allowing for the extraction of relevant contact information for each store linked to the workshop groups.\",\n        \"virtual_table\": \"SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID\"\n    }\n}\n"}
{"sample_id": "train.5459", "db_id": "voter_2", "question": "Find the average age of female students.", "rationale": ["Identify the table that contains the relevant data: the 'Student' table has the 'Age' and 'Sex' columns.", "To find the average age of female students, we need to filter the records where 'Sex' is 'Female'.", "Use the AVG() function to calculate the average of the 'Age' column for the filtered records.", "Construct the SQL query using SELECT to retrieve the average age, applying the WHERE clause for filtering."], "gold_sql": "SELECT avg(Age) FROM STUDENT WHERE Sex  =  'F'", "source_tables": ["student"], "pred_sql": "SELECT AVG(Age) AS Average_Age FROM Student WHERE Sex = 'Female';", "hint": "\n"}
{"sample_id": "train.5466", "db_id": "voter_2", "question": "What are the distinct president votes on 08/30/2015?", "rationale": ["Identify the relevant table for the query, which is 'Voting_record' since we are interested in president votes.", "We need to select distinct values of the 'President_Vote' column.", "We need to filter the records based on the 'Registration_Date' to only include those from '08/30/2015'.", "The date format in SQL should be 'YYYY-MM-DD', so '08/30/2015' will be converted to '2015-08-30'.", "Construct the SQL query using SELECT DISTINCT, specifying the column and the WHERE clause for the date."], "gold_sql": "SELECT DISTINCT PRESIDENT_Vote FROM VOTING_RECORD WHERE Registration_Date  =  '08/30/2015'", "source_tables": ["voting_record"], "pred_sql": "SELECT DISTINCT President_Vote FROM Voting_record WHERE Registration_Date = '2015-08-30'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the distinct first names of students who have voted for the class senator. The query joins the 'Student' table with the 'Voting_record' table based on the student identifier, ensuring that only those students who participated in the voting for class senator are included.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.CLASS_Senator_VOTE\"\n    }\n}\n"}
{"sample_id": "train.5467", "db_id": "voter_2", "question": "Show all the distinct president votes made on 08/30/2015.", "rationale": ["Identify the relevant table: We need to look at the Voting_record table since we are interested in the president votes.", "Select distinct values: We want to show all distinct president votes, so we will use the DISTINCT keyword.", "Filter by date: We need to filter the records to only include those registered on '08/30/2015'.", "Construct the SQL query: Combine all the elements into a complete SQL query."], "gold_sql": "SELECT DISTINCT PRESIDENT_Vote FROM VOTING_RECORD WHERE Registration_Date  =  '08/30/2015'", "source_tables": ["voting_record"], "pred_sql": "SELECT DISTINCT President_Vote FROM Voting_record WHERE Registration_Date = '08/30/2015'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the distinct first names of students who have voted for the class senator. The query joins the 'Student' table with the 'Voting_record' table based on the student identifier, ensuring that only those students who participated in the voting for class senator are included.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.CLASS_Senator_VOTE\"\n    }\n}\n"}
{"sample_id": "train.5476", "db_id": "voter_2", "question": "Find the distinct ages of students who have secretary votes in the fall election cycle.", "rationale": ["Identify the relevant tables: 'Student' and 'Voting_record'.", "We need to find distinct ages of students, so we will select the 'Age' column from the 'Student' table.", "To find students who have voted for secretary, we will join the 'Student' table with the 'Voting_record' table on the 'StuID'.", "We need to filter the results to include only those records where the 'Election_Cycle' is 'fall' and where there is a vote recorded for the secretary (i.e., 'Secretary_Vote' is not null).", "Use DISTINCT to ensure that we only get unique ages."], "gold_sql": "SELECT DISTINCT T1.Age FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Secretary_Vote WHERE T2.Election_Cycle  =  'Fall'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT S.Age \nFROM Student AS S \nJOIN Voting_record AS V ON S.StuID = V.StuID \nWHERE V.Election_Cycle = 'fall' AND V.Secretary_Vote IS NOT NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the distinct first names of students who have voted for the class senator. The query joins the 'Student' table with the 'Voting_record' table based on the student identifier, ensuring that only those students who participated in the voting for class senator are included.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.CLASS_Senator_VOTE\"\n    }\n}\n"}
{"sample_id": "train.5479", "db_id": "voter_2", "question": "Who served as an advisor for students who have treasurer votes in the spring election cycle?", "rationale": ["Identify the relevant tables: 'Student' and 'Voting_record'.", "We need to find advisors for students who have voted for treasurer, so we will join these two tables on the StuID.", "We will filter the results to include only those records where the Treasurer_Vote is not null, indicating that the student voted.", "Additionally, we will filter for the specific election cycle, which is 'spring'.", "Finally, we will select distinct advisors to avoid duplicates in the results."], "gold_sql": "SELECT DISTINCT T1.Advisor FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Treasurer_Vote WHERE T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT S.Advisor \nFROM Student AS S \nJOIN Voting_record AS V ON S.StuID = V.StuID \nWHERE V.Treasurer_Vote IS NOT NULL \nAND V.Election_Cycle = 'spring';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the distinct first names of students who have voted for the class senator. The query joins the 'Student' table with the 'Voting_record' table based on the student identifier, ensuring that only those students who participated in the voting for class senator are included.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.CLASS_Senator_VOTE\"\n    }\n}\n"}
{"sample_id": "train.5486", "db_id": "voter_2", "question": "How many male (sex is M) students have class senator votes in the fall election cycle?", "rationale": ["Identify the tables involved: We need to use the 'Student' table and the 'Voting_record' table.", "Determine the relationship: We will join the 'Student' table with the 'Voting_record' table on the StuID, which is common in both tables.", "Filter for male students: We need to add a condition to filter students where Sex is 'M'.", "Focus on class senator votes: We will specifically look for records in the Voting_record where Class_Senator_Vote corresponds to the students.", "Specify the election cycle: We need to ensure that we are only counting votes from the fall election cycle.", "Count the results: Finally, we will count the number of records that meet all these criteria."], "gold_sql": "SELECT count(*) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  Class_Senator_Vote WHERE T1.Sex  =  'M' AND T2.Election_Cycle  =  'Fall'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT COUNT(*) FROM Student AS S JOIN Voting_record AS V ON S.StuID = V.Class_Senator_Vote WHERE S.Sex = 'M' AND V.Election_Cycle = 'fall';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the distinct first names of students who have voted for the class senator. The query joins the 'Student' table with the 'Voting_record' table based on the student identifier, ensuring that only those students who participated in the voting for class senator are included.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.CLASS_Senator_VOTE\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the field of study (Major) of students from the 'Student' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the students.\",\n        \"virtual_table\": \"SELECT Major FROM STUDENT WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5491", "db_id": "voter_2", "question": "What is the average age of students who have city code \"NYC\" and have secretary votes for the spring election cycle?", "rationale": ["Identify the tables involved: We need data from the 'Student' table for student details and the 'Voting_record' table for voting details.", "Determine the conditions: We are looking for students with a city code of 'NYC' and who have cast a vote for the secretary in the spring election cycle.", "Join the tables: We will join the 'Student' table and the 'Voting_record' table on the StuID to correlate students with their voting records.", "Select the average age: We will use the AVG function to calculate the average age of the filtered students."], "gold_sql": "SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.city_code  =  'NYC' AND T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT AVG(Age) FROM Student AS S JOIN Voting_record AS V ON S.StuID = V.StuID WHERE S.city_code = 'NYC' AND V.Secretary_Vote IS NOT NULL AND V.Election_Cycle = 'spring';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the distinct first names of students who have voted for the class senator. The query joins the 'Student' table with the 'Voting_record' table based on the student identifier, ensuring that only those students who participated in the voting for class senator are included.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.CLASS_Senator_VOTE\"\n    }\n}\n"}
{"sample_id": "train.5492", "db_id": "voter_2", "question": "Find the average age of female (sex is F) students who have secretary votes in the spring election cycle.", "rationale": ["Identify the tables involved: We need to use the 'Student' table to get the age and sex of students, and the 'Voting_record' table to check for secretary votes and the election cycle.", "Determine the conditions: We are looking for female students (Sex = 'F') who have voted in the spring election cycle and have a non-null value for Secretary_Vote.", "Join the tables: We will join the 'Student' table with the 'Voting_record' table on the StuID to correlate students with their voting records.", "Calculate the average age: We will use the AVG function on the Age column, ensuring to cast it to an integer since it is stored as text."], "gold_sql": "SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.Sex  =  'F' AND T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT AVG(CAST(Age AS INTEGER)) AS Average_Age \nFROM Student AS S \nJOIN Voting_record AS V ON S.StuID = V.StuID \nWHERE S.Sex = 'F' \nAND V.Election_Cycle = 'spring' \nAND V.Secretary_Vote IS NOT NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the distinct first names of students who have voted for the class senator. The query joins the 'Student' table with the 'Voting_record' table based on the student identifier, ensuring that only those students who participated in the voting for class senator are included.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.CLASS_Senator_VOTE\"\n    }\n}\n"}
{"sample_id": "train.5494", "db_id": "voter_2", "question": "Find the distinct first names of all the students who have vice president votes and whose city code is not PIT.", "rationale": ["Identify the tables involved: 'Student' and 'Voting_record'.", "We need to find distinct first names of students, so we will use SELECT DISTINCT on the 'Fname' column from the 'Student' table.", "We need to join the 'Student' table with the 'Voting_record' table on the 'StuID' column to link students with their voting records.", "We need to filter for students who have cast a vote for vice president, which means we check if 'Vice_President_Vote' is not null.", "Additionally, we need to ensure that the city code of the student is not 'PIT', so we add a condition for 'city_code'.", "Combine all these elements into a complete SQL query."], "gold_sql": "SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_PRESIDENT_Vote EXCEPT SELECT DISTINCT Fname FROM STUDENT WHERE city_code  =  'PIT'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT S.Fname \nFROM Student AS S \nJOIN Voting_record AS V ON S.StuID = V.StuID \nWHERE V.Vice_President_Vote IS NOT NULL \nAND S.city_code != 'PIT';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the distinct first names of students who have voted for the class senator. The query joins the 'Student' table with the 'Voting_record' table based on the student identifier, ensuring that only those students who participated in the voting for class senator are included.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.CLASS_Senator_VOTE\"\n    }\n}\n"}
{"sample_id": "train.5495", "db_id": "voter_2", "question": "What are the distinct first names of the students who have vice president votes and reside in a city whose city code is not PIT?", "rationale": ["Identify the relevant tables: 'Student' and 'Voting_record'.", "We need to find distinct first names of students, so we will use SELECT DISTINCT on the 'Fname' column from the 'Student' table.", "We need to join the 'Student' table with the 'Voting_record' table based on the student identifier (StuID).", "The condition specifies that we are interested in students who have voted for the vice president, which corresponds to the 'Vice_President_Vote' column in the 'Voting_record' table.", "Additionally, we need to filter out students whose city code is 'PIT', so we will add a WHERE clause for that condition."], "gold_sql": "SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_PRESIDENT_Vote EXCEPT SELECT DISTINCT Fname FROM STUDENT WHERE city_code  =  'PIT'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT S.Fname FROM Student AS S JOIN Voting_record AS V ON S.StuID = V.Vice_President_Vote WHERE S.city_code != 'PIT'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the distinct first names of students who have voted for the class senator. The query joins the 'Student' table with the 'Voting_record' table based on the student identifier, ensuring that only those students who participated in the voting for class senator are included.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.CLASS_Senator_VOTE\"\n    }\n}\n"}
{"sample_id": "train.5496", "db_id": "voter_2", "question": "Find the distinct last names of all the students who have president votes and whose advisor is not 2192.", "rationale": ["Identify the tables involved: 'Student' and 'Voting_record'.", "We need to find distinct last names, so we will use SELECT DISTINCT on the 'LName' column from the 'Student' table.", "We need to join the 'Student' table with the 'Voting_record' table based on the student identifier, which is 'StuID'.", "We are interested in students who have cast a vote for president, so we will filter on the 'President_Vote' column in the 'Voting_record' table.", "Additionally, we need to ensure that the advisor is not equal to '2192', so we will add a WHERE clause for that condition."], "gold_sql": "SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote EXCEPT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  '2192'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT LName FROM Student JOIN Voting_record ON Student.StuID = Voting_record.President_Vote WHERE Advisor != '2192';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the distinct first names of students who have voted for the class senator. The query joins the 'Student' table with the 'Voting_record' table based on the student identifier, ensuring that only those students who participated in the voting for class senator are included.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.CLASS_Senator_VOTE\"\n    }\n}\n"}
{"sample_id": "train.5499", "db_id": "voter_2", "question": "What are the distinct last names of the students who have president votes and have 8741 as the advisor?", "rationale": ["Identify the relevant tables: We need to look at the 'Student' table for last names and the 'Voting_record' table for president votes.", "Determine the condition for president votes: We need to find students who have cast a vote for president, which means we will check for non-null values in the 'President_Vote' column.", "Filter by advisor: We need to include only those students whose advisor is '8741'.", "Combine the conditions: We will use a subquery to find the student IDs from the 'Voting_record' table where there are president votes and then filter the 'Student' table based on these IDs and the advisor condition.", "Select distinct last names: Finally, we will select distinct last names from the filtered results."], "gold_sql": "SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote INTERSECT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  '8741'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT LName FROM Student WHERE StuID IN (SELECT StuID FROM Voting_record WHERE President_Vote IS NOT NULL) AND Advisor = '8741';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the distinct first names of students who have voted for the class senator. The query joins the 'Student' table with the 'Voting_record' table based on the student identifier, ensuring that only those students who participated in the voting for class senator are included.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.CLASS_Senator_VOTE\"\n    }\n}\n"}
{"sample_id": "train.5510", "db_id": "voter_2", "question": "What is the most common major among female (sex is F) students?", "rationale": ["Identify the relevant table: The 'Student' table contains information about students, including their major and gender.", "Filter for female students: We need to filter the records where the 'Sex' column is 'F'.", "Group by major: To find the most common major, we will group the results by the 'Major' column.", "Count occurrences: We will count the number of students in each major using COUNT(*).", "Order by count: To find the most common major, we will order the results in descending order based on the count of students in each major.", "Limit the results: Since we only want the most common major, we will limit the results to 1."], "gold_sql": "SELECT Major FROM STUDENT WHERE Sex  =  'F' GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Major, COUNT(*) as MajorCount \nFROM Student \nWHERE Sex = 'F' \nGROUP BY Major \nORDER BY MajorCount DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the field of study (Major) of students from the 'Student' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the students.\",\n        \"virtual_table\": \"SELECT Major FROM STUDENT WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5511", "db_id": "voter_2", "question": "Find the major that is studied by the most female students.", "rationale": ["We need to find the major studied by the most female students.", "To do this, we will select the 'Major' from the 'Student' table where the 'Sex' is 'Female'.", "We will count the number of female students for each major using COUNT(*) and alias it as 'Female_Count'.", "To get the major with the most female students, we will group the results by 'Major'.", "Finally, we will order the results in descending order based on 'Female_Count' and limit the output to 1 to get the major with the highest count."], "gold_sql": "SELECT Major FROM STUDENT WHERE Sex  =  'F' GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Major, COUNT(*) as Female_Count \nFROM Student \nWHERE Sex = 'Female' \nGROUP BY Major \nORDER BY Female_Count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the field of study (Major) of students from the 'Student' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the students.\",\n        \"virtual_table\": \"SELECT Major FROM STUDENT WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5534", "db_id": "products_gen_characteristics", "question": "Find the number of products with category \"Spices\" and typically sold above 1000.", "rationale": ["Identify the relevant tables: Products and Ref_Product_Categories.", "Determine the relationship between the tables: Products has a foreign key product_category_code that links to Ref_Product_Categories.", "We need to filter products based on the category description 'Spices' and a selling price greater than 1000.", "Use COUNT(*) to get the number of products that meet these criteria.", "Construct the SQL query using JOIN to combine the two tables and apply the WHERE clause for filtering."], "gold_sql": "SELECT count(*) FROM products WHERE product_category_code  =  'Spices' AND typical_buying_price  >  1000", "source_tables": ["products"], "pred_sql": "SELECT COUNT(*) AS product_count\nFROM Products p\nJOIN Ref_Product_Categories c ON p.product_category_code = c.product_category_code\nWHERE c.product_category_description = 'Spices' AND p.typical_selling_price > 1000;", "hint": "\n"}
{"sample_id": "train.5543", "db_id": "products_gen_characteristics", "question": "What are the descriptions of the categories that products with product descriptions that contain the letter t are in?", "rationale": ["Identify the tables involved: We need to get product category descriptions from the Ref_Product_Categories table and filter products based on their descriptions from the Products table.", "Determine the relationship: The Products table is linked to the Ref_Product_Categories table through the product_category_code.", "Formulate the SQL query: We will select the product_category_description from Ref_Product_Categories and join it with Products on product_category_code.", "Add the filtering condition: We need to filter products where the product_description contains the letter 't', which can be done using the LIKE operator with '%t%'."], "gold_sql": "SELECT T1.product_category_description FROM ref_product_categories AS T1 JOIN products AS T2 ON T1.product_category_code  =  T2.product_category_code WHERE T2.product_description LIKE '%t%'", "source_tables": ["products", "ref_product_categories"], "pred_sql": "SELECT T1.product_category_description FROM Ref_Product_Categories AS T1 JOIN Products AS T2 ON T1.product_category_code = T2.product_category_code WHERE T2.product_description LIKE '%t%'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the descriptions of product categories from the 'Ref_Product_Categories' table for products that have a specific description. The placeholder in the WHERE clause allows for filtering products based on their description.\",\n        \"virtual_table\": \"SELECT T1.product_category_description FROM ref_product_categories AS T1 JOIN products AS T2 ON T1.product_category_code  =  T2.product_category_code WHERE T2.product_description LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5556", "db_id": "products_gen_characteristics", "question": "How many distinct characteristic names does the product \"cumin\" have?", "rationale": ["Identify the product 'cumin' in the Products table.", "Join the Products table with the Product_Characteristics table to link products with their characteristics.", "Join the resulting table with the Characteristics table to access characteristic names.", "Use COUNT(DISTINCT characteristic_name) to count unique characteristic names for the product 'cumin'.", "Filter the results to only include the product where product_name is 'cumin'."], "gold_sql": "SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  'sesame'", "source_tables": ["products", "characteristics", "product_characteristics"], "pred_sql": "SELECT COUNT(DISTINCT c.characteristic_name) \nFROM Products p \nJOIN Product_Characteristics pc ON p.product_id = pc.product_id \nJOIN Characteristics c ON pc.characteristic_id = c.characteristic_id \nWHERE p.product_name = 'cumin';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the distinct names of characteristics from the 'Characteristics' table. This allows users to retrieve unique characteristic names without duplicates.\",\n        \"virtual_table\": \"SELECT DISTINCT characteristic_name FROM CHARACTERISTICS\"\n    }\n}\n"}
{"sample_id": "train.5577", "db_id": "products_gen_characteristics", "question": "How many products have their color described as 'white' or have a characteristic with the name 'hot'?", "rationale": ["Identify the tables involved: Products, Ref_Colors, Product_Characteristics, and Characteristics.", "We need to count the number of products that either have a color described as 'white' or have a characteristic with the name 'hot'.", "Join the Products table with the Ref_Colors table to filter by color description.", "Join the Products table with the Product_Characteristics table to access the characteristics of each product.", "Join the Product_Characteristics table with the Characteristics table to filter by characteristic name.", "Use a WHERE clause to specify the conditions for color description and characteristic name.", "Use COUNT(DISTINCT p.product_id) to ensure we count each product only once, regardless of how many characteristics it has."], "gold_sql": "SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  'white' OR t3.characteristic_name  =  'hot'", "source_tables": ["products", "ref_colors", "characteristics", "product_characteristics"], "pred_sql": "SELECT COUNT(DISTINCT p.product_id) \nFROM Products p \nLEFT JOIN Ref_Colors c ON p.color_code = c.color_code \nLEFT JOIN Product_Characteristics pc ON p.product_id = pc.product_id \nLEFT JOIN Characteristics ch ON pc.characteristic_id = ch.characteristic_id \nWHERE c.color_description = 'white' OR ch.characteristic_name = 'hot';", "hint": "\n"}
{"sample_id": "train.5579", "db_id": "products_gen_characteristics", "question": "Return the unit of measure for 'Herb' products.", "rationale": ["Identify the relevant tables: We need to get the unit of measure for 'Herb' products, which involves the Products and Ref_Product_Categories tables.", "Determine the relationship: The Products table has a foreign key that links to the Ref_Product_Categories table through the product_category_code.", "Formulate the query: We will select the unit_of_measure from Ref_Product_Categories, joining it with Products on product_category_code.", "Add the condition: We need to filter the products to only those whose name contains 'Herb', using a LIKE clause."], "gold_sql": "SELECT unit_of_measure FROM ref_product_categories WHERE product_category_code  =  'Herbs'", "source_tables": ["ref_product_categories"], "pred_sql": "SELECT Ref_Product_Categories.unit_of_measure \nFROM Products \nJOIN Ref_Product_Categories ON Products.product_category_code = Ref_Product_Categories.product_category_code \nWHERE Products.product_name LIKE '%Herb%';", "hint": "\n"}
{"sample_id": "train.5586", "db_id": "products_gen_characteristics", "question": "Find the unit of measurement and product category code of product named \"chervil\".", "rationale": ["Identify the tables involved: We need to get the unit of measurement and product category code, which are in the 'Ref_Product_Categories' table, and we need to filter based on the product name from the 'Products' table.", "Determine the relationship between tables: The 'Ref_Product_Categories' table is linked to the 'Products' table through the 'product_category_code'.", "Use the provided hint: The hint gives a template for selecting product category descriptions based on product descriptions. We will modify this to select the unit of measure and product category code instead.", "Construct the SQL query: We will select 'unit_of_measure' and 'product_category_code' from 'Ref_Product_Categories', joining it with 'Products' on 'product_category_code', and filter where 'product_name' is 'chervil'."], "gold_sql": "SELECT t2.unit_of_measure ,  t2.product_category_code FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code WHERE t1.product_name  =  'chervil'", "source_tables": ["products", "ref_product_categories"], "pred_sql": "SELECT T1.unit_of_measure, T1.product_category_code FROM ref_product_categories AS T1 JOIN products AS T2 ON T1.product_category_code = T2.product_category_code WHERE T2.product_name = 'chervil'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the descriptions of product categories from the 'Ref_Product_Categories' table for products that have a specific description. The placeholder in the WHERE clause allows for filtering products based on their description.\",\n        \"virtual_table\": \"SELECT T1.product_category_description FROM ref_product_categories AS T1 JOIN products AS T2 ON T1.product_category_code  =  T2.product_category_code WHERE T2.product_description LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5590", "db_id": "products_gen_characteristics", "question": "What is the description of the color for most products?", "rationale": ["We need to find the description of the color for most products.", "To do this, we will join the 'Ref_Colors' table with the 'Products' table on the 'color_code'.", "We will count the number of products for each color description using COUNT(P.product_id).", "We will group the results by color description to aggregate the counts.", "To find the color with the most products, we will order the results in descending order by the count of products.", "Finally, we will limit the results to 1 to get only the top color description."], "gold_sql": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) DESC LIMIT 1", "source_tables": ["products", "ref_colors"], "pred_sql": "SELECT R.color_description, COUNT(P.product_id) AS product_count \nFROM Ref_Colors AS R \nJOIN Products AS P ON R.color_code = P.color_code \nGROUP BY R.color_description \nORDER BY product_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the descriptions of product categories from the 'Ref_Product_Categories' table for products that have a specific description. The placeholder in the WHERE clause allows for filtering products based on their description.\",\n        \"virtual_table\": \"SELECT T1.product_category_description FROM ref_product_categories AS T1 JOIN products AS T2 ON T1.product_category_code  =  T2.product_category_code WHERE T2.product_description LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5592", "db_id": "products_gen_characteristics", "question": "What is the description of the color used by least products?", "rationale": ["We need to find the color description used by the least number of products.", "To do this, we will join the Ref_Colors table with the Products table on the color_code.", "We will group the results by color_code to count how many products are associated with each color.", "Next, we will order the results by the count of products in ascending order to get the color with the least products first.", "Finally, we will limit the results to 1 to get only the top result, which is the color used by the least products."], "gold_sql": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) ASC LIMIT 1", "source_tables": ["products", "ref_colors"], "pred_sql": "SELECT R.color_description FROM Ref_Colors AS R JOIN Products AS P ON R.color_code = P.color_code GROUP BY R.color_code ORDER BY COUNT(P.product_id) ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the descriptions of product categories from the 'Ref_Product_Categories' table for products that have a specific description. The placeholder in the WHERE clause allows for filtering products based on their description.\",\n        \"virtual_table\": \"SELECT T1.product_category_description FROM ref_product_categories AS T1 JOIN products AS T2 ON T1.product_category_code  =  T2.product_category_code WHERE T2.product_description LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5599", "db_id": "products_gen_characteristics", "question": "Give the names of characteristics that are in two or more products?", "rationale": ["We need to find the names of characteristics that are associated with two or more products.", "To do this, we will first identify the characteristic IDs that are linked to two or more products. This can be achieved by grouping the 'Product_Characteristics' table by 'characteristic_id' and counting the distinct 'product_id'.", "We will use the HAVING clause to filter these groups to only include those with a count of 2 or more.", "Once we have the relevant characteristic IDs, we can then select the corresponding characteristic names from the 'Characteristics' table using these IDs."], "gold_sql": "SELECT t3.characteristic_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id GROUP BY t3.characteristic_name HAVING count(*)  >= 2", "source_tables": ["products", "characteristics", "product_characteristics"], "pred_sql": "SELECT characteristic_name FROM Characteristics WHERE characteristic_id IN (SELECT characteristic_id FROM Product_Characteristics GROUP BY characteristic_id HAVING COUNT(DISTINCT product_id) >= 2)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the distinct names of characteristics from the 'Characteristics' table. This allows users to retrieve unique characteristic names without duplicates.\",\n        \"virtual_table\": \"SELECT DISTINCT characteristic_name FROM CHARACTERISTICS\"\n    }\n}\n"}
{"sample_id": "train.5633", "db_id": "railway", "question": "List the builders of railways in ascending alphabetical order.", "rationale": ["Identify the relevant table: The 'railway' table contains the 'Builder' column which we need to query.", "Select the 'Builder' column: We want to list the builders, so we will select this column.", "Use DISTINCT to avoid duplicate entries: Since multiple railways can have the same builder, we will use DISTINCT to ensure each builder is listed only once.", "Order the results: We need the results in ascending alphabetical order, so we will use ORDER BY Builder ASC.", "Construct the SQL query: Combine all these elements into a complete SQL query."], "gold_sql": "SELECT Builder FROM railway ORDER BY Builder ASC", "source_tables": ["railway"], "pred_sql": "SELECT DISTINCT Builder FROM railway ORDER BY Builder ASC;", "hint": "\n"}
{"sample_id": "train.5643", "db_id": "railway", "question": "Show the id and builder of the railway that are associated with the most trains.", "rationale": ["Identify the relevant tables: 'railway' and 'train'.", "We need to find the railway associated with the most trains, so we will join the 'railway' table with the 'train' table on 'Railway_ID'.", "We will group the results by 'Railway_ID' and 'Builder' to count the number of trains associated with each railway.", "Use COUNT(train.Train_ID) to count the number of trains for each railway.", "Order the results in descending order based on the count of trains to get the railway with the most trains at the top.", "Limit the results to 1 to get only the railway associated with the most trains."], "gold_sql": "SELECT T2.Railway_ID ,  T1.Builder FROM railway AS T1 JOIN train AS T2 ON T1.Railway_ID  =  T2.Railway_ID GROUP BY T2.Railway_ID ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["train", "railway"], "pred_sql": "SELECT railway.Railway_ID, railway.Builder \nFROM railway \nJOIN train ON railway.Railway_ID = train.Railway_ID \nGROUP BY railway.Railway_ID, railway.Builder \nORDER BY COUNT(train.Train_ID) DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5645", "db_id": "railway", "question": "Show the most common builder of railways.", "rationale": ["Identify the relevant table: The 'railway' table contains the 'Builder' column which we need to analyze.", "Count the occurrences of each builder: We will use the COUNT() function to count how many railways each builder has constructed.", "Group the results by builder: We will use GROUP BY to aggregate the results based on the 'Builder' column.", "Order the results: To find the most common builder, we will order the results in descending order based on the count of railways.", "Limit the results to one: Since we only want the most common builder, we will use LIMIT 1 to get the top result."], "gold_sql": "SELECT Builder FROM railway GROUP BY Builder ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["railway"], "pred_sql": "SELECT Builder, COUNT(*) as Count FROM railway GROUP BY Builder ORDER BY Count DESC LIMIT 1;", "hint": "\n"}
{"sample_id": "train.5707", "db_id": "dorm_1", "question": "What is the last name of every student who is either female or living in a city with the code BAL or male and under 20?", "rationale": ["Identify the columns needed: We need the last names of students, so we will select 'LName' from the 'Student' table.", "Determine the conditions: We need students who are either female, live in a city with the code 'BAL', or are male and under 20 years old.", "Construct the WHERE clause: The conditions can be combined using OR. The first condition checks if the student is female, the second checks if the city code is 'BAL', and the third checks if the student is male and under 20.", "Combine the SELECT statement with the WHERE clause to form the complete SQL query."], "gold_sql": "SELECT lname FROM student WHERE sex  =  'F' AND city_code  =  'BAL' UNION SELECT lname FROM student WHERE sex  =  'M' AND age  <  20", "source_tables": ["student"], "pred_sql": "SELECT LName FROM Student WHERE (Sex = 'Female') OR (city_code = 'BAL') OR (Sex = 'Male' AND Age < '20');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of dormitories from the 'Dorm' table that are designated for a specific gender. The placeholder in the WHERE clause represents the gender designation for the dormitory.\",\n        \"virtual_table\": \"SELECT dorm_name FROM dorm WHERE gender  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5738", "db_id": "dorm_1", "question": "Find the number of amenities for each of the dorms that can accommodate more than 100 students.", "rationale": ["Identify the relevant tables: We need to use the Dorm table to filter dorms based on their capacity and the Has_amenity table to count the amenities.", "Join the Dorm and Has_amenity tables: We will join these tables on the dormid to link each dorm with its amenities.", "Filter dorms with a capacity greater than 100: We will add a WHERE clause to only include dorms that can accommodate more than 100 students.", "Count the amenities: We will use COUNT() to count the number of amenities associated with each dorm.", "Group the results: We will group the results by dormid and dorm_name to get the count of amenities for each dorm."], "gold_sql": "SELECT count(*) ,  T1.dormid FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid WHERE T1.student_capacity  >  100 GROUP BY T1.dormid", "source_tables": ["has_amenity", "dorm"], "pred_sql": "SELECT d.dorm_name, COUNT(ha.amenid) AS number_of_amenities\nFROM Dorm d\nJOIN Has_amenity ha ON d.dormid = ha.dormid\nWHERE d.student_capacity > 100\nGROUP BY d.dormid, d.dorm_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the average and total student capacity of dormitories filtered by a specific gender designation. The placeholder in the WHERE clause represents the gender of the dormitory.\",\n        \"virtual_table\": \"SELECT avg(student_capacity) ,  sum(student_capacity) FROM dorm WHERE gender  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of dormitories from the 'Dorm' table that are designated for a specific gender. The placeholder in the WHERE clause represents the gender designation for the dormitory.\",\n        \"virtual_table\": \"SELECT dorm_name FROM dorm WHERE gender  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5747", "db_id": "dorm_1", "question": "What are the total number of students who are living in a male dorm?", "rationale": ["The question asks for the total number of students living in a male dormitory.", "To find this, we need to count the number of students in the 'Lives_in' table.", "We will join the 'Lives_in' table with the 'Dorm' table on the dormid to access the gender information of the dorms.", "We will filter the results to only include dorms where the gender is 'male'.", "Finally, we will use COUNT to get the total number of students in these male dorms."], "gold_sql": "SELECT count(*) FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T3.gender  =  'M'", "source_tables": ["student", "lives_in", "dorm"], "pred_sql": "SELECT COUNT(Lives_in.stuid) AS total_students\nFROM Lives_in\nJOIN Dorm ON Lives_in.dormid = Dorm.dormid\nWHERE Dorm.gender = 'male';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the average and total student capacity of dormitories filtered by a specific gender designation. The placeholder in the WHERE clause represents the gender of the dormitory.\",\n        \"virtual_table\": \"SELECT avg(student_capacity) ,  sum(student_capacity) FROM dorm WHERE gender  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of dormitories from the 'Dorm' table that are designated for a specific gender. The placeholder in the WHERE clause represents the gender designation for the dormitory.\",\n        \"virtual_table\": \"SELECT dorm_name FROM dorm WHERE gender  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5756", "db_id": "dorm_1", "question": "Find the first name of students who are living in the dorm that has most number of amenities.", "rationale": ["Identify the dormitory with the most amenities by counting the number of amenities for each dormitory using the Has_amenity table.", "Use a subquery to select the dormid from the Has_amenity table, grouping by dormid and ordering by the count of amenid in descending order, limiting the result to the top one.", "Next, find the students who live in that dormitory by using the Lives_in table to match the dormid from the previous step.", "Finally, select the first names of those students from the Student table using their StuID."], "gold_sql": "SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["has_amenity", "lives_in", "student", "dorm_amenity", "dorm"], "pred_sql": "SELECT Fname FROM Student WHERE StuID IN (SELECT stuid FROM Lives_in WHERE dormid IN (SELECT dormid FROM Has_amenity GROUP BY dormid ORDER BY COUNT(amenid) DESC LIMIT 1));", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the average and total student capacity of dormitories filtered by a specific gender designation. The placeholder in the WHERE clause represents the gender of the dormitory.\",\n        \"virtual_table\": \"SELECT avg(student_capacity) ,  sum(student_capacity) FROM dorm WHERE gender  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of dormitories from the 'Dorm' table that are designated for a specific gender. The placeholder in the WHERE clause represents the gender designation for the dormitory.\",\n        \"virtual_table\": \"SELECT dorm_name FROM dorm WHERE gender  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5765", "db_id": "dorm_1", "question": "What is the first name and age of every student who lives in a dorm with a TV Lounge?", "rationale": ["Identify the required fields: first name (Fname) and age (Age) of students.", "Determine the relationships between tables: Students live in dorms, and dorms have amenities.", "Use JOIN clauses to connect the Student table with Lives_in, Dorm, Has_amenity, and Dorm_amenity tables based on their relationships.", "Filter the results to include only those dorms that have a 'TV Lounge' amenity by using a WHERE clause."], "gold_sql": "SELECT T1.fname ,  T1.age FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid NOT IN (SELECT T3.dormid FROM has_amenity AS T3 JOIN dorm_amenity AS T4 ON T3.amenid  =  T4.amenid WHERE T4.amenity_name  =  'TV Lounge')", "source_tables": ["has_amenity", "student", "lives_in", "dorm_amenity"], "pred_sql": "SELECT Fname, Age \nFROM Student \nJOIN Lives_in ON Student.StuID = Lives_in.stuid \nJOIN Dorm ON Lives_in.dormid = Dorm.dormid \nJOIN Has_amenity ON Dorm.dormid = Has_amenity.dormid \nJOIN Dorm_amenity ON Has_amenity.amenid = Dorm_amenity.amenid \nWHERE Dorm_amenity.amenity_name = 'TV Lounge';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of dormitories from the 'Dorm' table that are designated for a specific gender. The placeholder in the WHERE clause represents the gender designation for the dormitory.\",\n        \"virtual_table\": \"SELECT dorm_name FROM dorm WHERE gender  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the average and total student capacity of dormitories filtered by a specific gender designation. The placeholder in the WHERE clause represents the gender of the dormitory.\",\n        \"virtual_table\": \"SELECT avg(student_capacity) ,  sum(student_capacity) FROM dorm WHERE gender  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5777", "db_id": "customer_complaints", "question": "What are the emails of customers who have filed complaints on the product which has had the greatest number of complaints?", "rationale": ["Identify the main goal: Retrieve the emails of customers who filed complaints on the product with the greatest number of complaints.", "To find the product with the greatest number of complaints, we need to group the complaints by product_id and count them, ordering by this count in descending order.", "We will use a subquery to get the product_id that has the highest count of complaints.", "Next, we will join the Customers table with the Complaints table to get the email addresses of customers who filed complaints for that specific product.", "Finally, we will select the email_address from the Customers table where the customer_id matches those in the Complaints table for the identified product."], "gold_sql": "SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "customers"], "pred_sql": "SELECT c.email_address \nFROM Customers AS c \nJOIN Complaints AS comp ON c.customer_id = comp.customer_id \nWHERE comp.product_id = (\n    SELECT product_id \n    FROM Complaints \n    GROUP BY product_id \n    ORDER BY COUNT(*) DESC \n    LIMIT 1\n)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of last names of staff members who are handling complaints related to products, ordered by the price of those products. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the last names of staff members who are handling complaints, ordered by the date the complaints were raised. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id ORDER BY t2.date_complaint_raised LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5778", "db_id": "customer_complaints", "question": "Which products has been complained by the customer who has filed least amount of complaints?", "rationale": ["Identify the products that have been complained about by customers.", "To find the customer who has filed the least amount of complaints, we need to group the complaints by customer_id and count them.", "We will order the results by the count of complaints in ascending order and limit the results to 1 to get the customer with the least complaints.", "Using the customer_id from the previous step, we will join the Complaints table with the Products table to get the product names that correspond to the complaints made by that customer."], "gold_sql": "SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "products", "customers"], "pred_sql": "SELECT p.product_name \nFROM Products p \nJOIN Complaints c ON p.product_id = c.product_id \nWHERE c.customer_id = (\n    SELECT customer_id \n    FROM Complaints \n    GROUP BY customer_id \n    ORDER BY COUNT(complaint_id) ASC \n    LIMIT 1\n)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of last names of staff members who are handling complaints related to products, ordered by the price of those products. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the last names of staff members who are handling complaints, ordered by the date the complaints were raised. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id ORDER BY t2.date_complaint_raised LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5795", "db_id": "customer_complaints", "question": "What is the last name of the staff member in charge of the complaint on the product with the lowest price?", "rationale": ["Identify the relevant tables: Staff, Complaints, and Products.", "We need to find the last name of the staff member handling a complaint related to the product with the lowest price.", "Join the Staff table with the Complaints table on staff_id to link staff members to their complaints.", "Join the Complaints table with the Products table on product_id to link complaints to the products.", "Order the results by product price in ascending order to get the product with the lowest price at the top.", "Limit the results to 1 to get only the last name of the staff member handling that complaint."], "gold_sql": "SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT 1", "source_tables": ["complaints", "products", "staff"], "pred_sql": "SELECT t1.last_name FROM Staff AS t1 JOIN Complaints AS t2 ON t1.staff_id = t2.staff_id JOIN Products AS t3 ON t2.product_id = t3.product_id ORDER BY t3.product_price LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of last names of staff members who are handling complaints related to products, ordered by the price of those products. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the last names of staff members who are handling complaints, ordered by the date the complaints were raised. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id ORDER BY t2.date_complaint_raised LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5796", "db_id": "customer_complaints", "question": "Which complaint status has more than 3 records on file?", "rationale": ["Identify the table that contains the complaint status, which is the 'Complaints' table.", "We need to count the number of records for each complaint status, so we will use the COUNT() function.", "To group the results by complaint status, we will use the GROUP BY clause on 'complaint_status_code'.", "To filter the results to only include statuses with more than 3 records, we will use the HAVING clause with COUNT(*) > 3."], "gold_sql": "SELECT complaint_status_code FROM complaints GROUP BY complaint_status_code HAVING count(*)  >  3", "source_tables": ["complaints"], "pred_sql": "SELECT complaint_status_code, COUNT(*) as record_count \nFROM Complaints \nGROUP BY complaint_status_code \nHAVING COUNT(*) > 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the last names of staff members who are handling complaints, ordered by the date the complaints were raised. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id ORDER BY t2.date_complaint_raised LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of last names of staff members who are handling complaints related to products, ordered by the price of those products. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5801", "db_id": "customer_complaints", "question": "Count the number of customers that have the customer type that is most common.", "rationale": ["Identify the table that contains customer information, which is the 'Customers' table.", "To find the most common customer type, we need to group the customers by 'customer_type_code' and count how many customers belong to each type.", "We will order the results by the count in descending order to get the most common type at the top.", "We will limit the results to 1 to get only the most common customer type code.", "Finally, we will count the number of customers that have this most common customer type code."], "gold_sql": "SELECT count(*) FROM customers GROUP BY customer_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers"], "pred_sql": "SELECT COUNT(*) AS customer_count\nFROM Customers\nWHERE customer_type_code = (\n    SELECT customer_type_code\n    FROM Customers\n    GROUP BY customer_type_code\n    ORDER BY COUNT(*) DESC\n    LIMIT 1\n);", "hint": "\n"}
{"sample_id": "train.5810", "db_id": "customer_complaints", "question": "What is first names of the top 5 staff who have handled the greatest number of complaints?", "rationale": ["Identify the relevant tables: Staff and Complaints.", "We need to find the first names of staff members, so we will select 'first_name' from the Staff table.", "To determine how many complaints each staff member has handled, we will join the Staff table with the Complaints table on 'staff_id'.", "We will group the results by 'staff_id' to aggregate the number of complaints handled by each staff member.", "We will use COUNT() to count the number of complaints for each staff member.", "To get the top 5 staff members who handled the most complaints, we will order the results in descending order based on the count of complaints and limit the results to 5."], "gold_sql": "SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT 5", "source_tables": ["complaints", "staff"], "pred_sql": "SELECT first_name FROM Staff AS t1 JOIN Complaints AS t2 ON t1.staff_id = t2.staff_id GROUP BY t1.staff_id ORDER BY COUNT(t2.complaint_id) DESC LIMIT 5;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the last names of staff members who are handling complaints, ordered by the date the complaints were raised. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id ORDER BY t2.date_complaint_raised LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of last names of staff members who are handling complaints related to products, ordered by the price of those products. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5811", "db_id": "customer_complaints", "question": "Return the first names of the 5 staff members who have handled the most complaints.", "rationale": ["We need to return the first names of staff members who have handled the most complaints.", "To achieve this, we will join the Staff table with the Complaints table on the staff_id column.", "We will group the results by staff_id to aggregate the number of complaints handled by each staff member.", "Next, we will order the results in descending order based on the count of complaints (using COUNT(t2.complaint_id)).", "Finally, we will limit the results to the top 5 staff members with the most complaints."], "gold_sql": "SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT 5", "source_tables": ["complaints", "staff"], "pred_sql": "SELECT t1.first_name FROM Staff AS t1 JOIN Complaints AS t2 ON t1.staff_id = t2.staff_id GROUP BY t1.staff_id ORDER BY COUNT(t2.complaint_id) DESC LIMIT 5;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the last names of staff members who are handling complaints, ordered by the date the complaints were raised. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id ORDER BY t2.date_complaint_raised LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of last names of staff members who are handling complaints related to products, ordered by the price of those products. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5845", "db_id": "tracking_share_transactions", "question": "Show all investor details.", "rationale": ["The user wants to see all investor details.", "To retrieve all details from the Investors table, we use the SELECT statement.", "Using '*' allows us to select all columns from the Investors table."], "gold_sql": "SELECT Investor_details FROM INVESTORS", "source_tables": ["investors"], "pred_sql": "SELECT * FROM Investors;", "hint": "\n"}
{"sample_id": "train.5858", "db_id": "tracking_share_transactions", "question": "Show details of all investors if they make any transaction with share count greater than 100.", "rationale": ["Identify the tables involved: Investors and Transactions.", "We need to show details of all investors, so we will select columns from the Investors table.", "We need to filter investors based on their transactions, specifically those with a share count greater than 100.", "To link the Investors table with the Transactions table, we will use a JOIN on the investor_id column.", "The WHERE clause will be used to filter transactions where share_count is greater than 100."], "gold_sql": "SELECT T1.Investor_details FROM  INVESTORS AS T1 JOIN TRANSACTIONS AS T2 ON T1.investor_id  =  T2.investor_id WHERE T2.share_count  >  100", "source_tables": ["transactions", "investors"], "pred_sql": "SELECT Investors.investor_id, Investors.Investor_details \nFROM Investors \nJOIN Transactions ON Investors.investor_id = Transactions.investor_id \nWHERE Transactions.share_count > 100;", "hint": "\n"}
{"sample_id": "train.5864", "db_id": "tracking_share_transactions", "question": "What are the lot details of lots associated with transactions with share count smaller than 50?", "rationale": ["We need to retrieve lot details from the Lots table.", "We will join the Lots table with the Transactions_Lots table to link lots with their corresponding transactions.", "Next, we will join the Transactions table to access the share count of each transaction.", "Finally, we will filter the results to include only those transactions where the share count is smaller than 50."], "gold_sql": "SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  <  50", "source_tables": ["lots", "transactions_lots", "transactions"], "pred_sql": "SELECT L.lot_details \nFROM Lots AS L \nJOIN Transactions_Lots AS TL ON L.lot_id = TL.lot_id \nJOIN Transactions AS T ON TL.transaction_id = T.transaction_id \nWHERE T.share_count < 50;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the details of lots from the 'Lots' table that are not associated with any transactions. The query uses an EXCEPT clause to filter out lot details that are linked to transactions through the 'Transactions_Lots' table.\",\n        \"virtual_table\": \"SELECT lot_details FROM Lots EXCEPT SELECT T1.lot_details FROM Lots AS T1 JOIN transactions_lots AS T2 ON T1.lot_id  =  T2.lot_id\"\n    }\n}\n"}
{"sample_id": "train.5866", "db_id": "tracking_share_transactions", "question": "Show the average transaction amount for different transaction types.", "rationale": ["Identify the tables involved: We need data from the Transactions table for transaction amounts and the Ref_Transaction_Types table for transaction descriptions.", "Determine the relationship between the tables: The Transactions table has a foreign key that links to the Ref_Transaction_Types table via transaction_type_code.", "Select the necessary columns: We need the transaction type description and the average of the transaction amounts.", "Use the AVG() function to calculate the average transaction amount for each transaction type.", "Group the results by transaction type description to get the average for each type."], "gold_sql": "SELECT transaction_type_code ,  avg(amount_of_transaction) FROM TRANSACTIONS GROUP BY transaction_type_code", "source_tables": ["transactions"], "pred_sql": "SELECT rt.transaction_type_description, AVG(t.amount_of_transaction) AS average_transaction_amount\nFROM Transactions t\nJOIN Ref_Transaction_Types rt ON t.transaction_type_code = rt.transaction_type_code\nGROUP BY rt.transaction_type_description;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates of transactions from the 'Transactions' table that correspond to a specific type of transaction. The placeholder in the WHERE clause represents the transaction type code.\",\n        \"virtual_table\": \"SELECT date_of_transaction FROM TRANSACTIONS WHERE transaction_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5867", "db_id": "tracking_share_transactions", "question": "Show the maximum and minimum share count of different transaction types.", "rationale": ["Identify the relevant tables: We need to use the Transactions table for share counts and the Ref_Transaction_Types table for transaction type descriptions.", "Join the Transactions table with the Ref_Transaction_Types table on the transaction_type_code to get descriptions of each transaction type.", "Use aggregate functions MAX() and MIN() to find the maximum and minimum share counts for each transaction type.", "Group the results by transaction type description to get the desired output for each type."], "gold_sql": "SELECT transaction_type_code ,  max(share_count) ,  min(share_count) FROM TRANSACTIONS GROUP BY transaction_type_code", "source_tables": ["transactions"], "pred_sql": "SELECT rt.transaction_type_description, MAX(t.share_count) AS max_share_count, MIN(t.share_count) AS min_share_count\nFROM Transactions t\nJOIN Ref_Transaction_Types rt ON t.transaction_type_code = rt.transaction_type_code\nGROUP BY rt.transaction_type_description;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates of transactions from the 'Transactions' table that correspond to a specific type of transaction. The placeholder in the WHERE clause represents the transaction type code.\",\n        \"virtual_table\": \"SELECT date_of_transaction FROM TRANSACTIONS WHERE transaction_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5883", "db_id": "tracking_share_transactions", "question": "What are the details of all sales and purchases?", "rationale": ["Identify the tables needed: Sales and Purchases.", "Determine the columns to select: sales_details from Sales and purchase_details from Purchases.", "Since we want details from both tables, a FULL OUTER JOIN is appropriate to include all records from both tables, even if there are no matches.", "Construct the SQL query using the selected columns and the join condition."], "gold_sql": "SELECT sales_details FROM sales UNION SELECT purchase_details FROM purchases", "source_tables": ["sales", "purchases"], "pred_sql": "SELECT Sales.sales_details, Purchases.purchase_details \nFROM Sales \nFULL OUTER JOIN Purchases ON Sales.sales_transaction_id = Purchases.purchase_transaction_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the details of lots from the 'Lots' table that are not associated with any transactions. The query uses an EXCEPT clause to filter out lot details that are linked to transactions through the 'Transactions_Lots' table.\",\n        \"virtual_table\": \"SELECT lot_details FROM Lots EXCEPT SELECT T1.lot_details FROM Lots AS T1 JOIN transactions_lots AS T2 ON T1.lot_id  =  T2.lot_id\"\n    }\n}\n"}
