{"sample_id": "train.56", "db_id": "student_assessment", "question": "which course has most number of registered students?", "rationale": ["Identify the relevant tables: We need to look at the 'Student_Course_Registrations' table to find out how many students are registered for each course.", "Count the number of students for each course: We can use the COUNT() function to count the number of student IDs associated with each course ID.", "Group the results by course: We will use GROUP BY to aggregate the counts for each course.", "Order the results: To find the course with the most registered students, we will order the results in descending order based on the count of students.", "Limit the results to one: Since we only want the course with the most students, we will use LIMIT 1 to get the top result."], "gold_sql": "SELECT T1.course_name FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_Id GROUP BY T1.course_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["courses", "student_course_registrations"], "pred_sql": "SELECT course_id, COUNT(student_id) AS number_of_students \nFROM Student_Course_Registrations \nGROUP BY course_id \nORDER BY number_of_students DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of all course registrations for students who have not attended any courses. The query retrieves all columns from the 'student_course_registrations' table, filtering out students based on their attendance records.\",\n        \"virtual_table\": \"SELECT * FROM student_course_registrations WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)\"\n    }\n}\n"}
{"sample_id": "train.64", "db_id": "student_assessment", "question": "List the id of students who attended some courses?", "rationale": ["The question asks for the IDs of students who attended some courses.", "To find students who attended courses, we need to look at the 'Student_Course_Attendance' table, which records attendance by student ID and course ID.", "We can select the distinct student IDs from the 'Student_Course_Attendance' table to ensure we only get unique IDs of students who have attended at least one course."], "gold_sql": "SELECT student_id FROM student_course_attendance", "source_tables": ["student_course_attendance"], "pred_sql": "SELECT DISTINCT student_id FROM Student_Course_Attendance;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of all course registrations for students who have not attended any courses. The query retrieves all columns from the 'student_course_registrations' table, filtering out students based on their attendance records.\",\n        \"virtual_table\": \"SELECT * FROM student_course_registrations WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)\"\n    }\n}\n"}
{"sample_id": "train.65", "db_id": "student_assessment", "question": "What are the ids of all students who have attended at least one course?", "rationale": ["We need to find the IDs of all students who have attended at least one course.", "To do this, we will query the 'Student_Course_Attendance' table, which records attendance for students in courses.", "We will select the 'student_id' from the 'Student_Course_Attendance' table.", "Using DISTINCT ensures that we only get unique student IDs, as a student may have attended multiple courses."], "gold_sql": "SELECT student_id FROM student_course_attendance", "source_tables": ["student_course_attendance"], "pred_sql": "SELECT DISTINCT student_id FROM Student_Course_Attendance;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of all course registrations for students who have not attended any courses. The query retrieves all columns from the 'student_course_registrations' table, filtering out students based on their attendance records.\",\n        \"virtual_table\": \"SELECT * FROM student_course_registrations WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)\"\n    }\n}\n"}
{"sample_id": "train.76", "db_id": "student_assessment", "question": "What is the id of the candidate who most recently accessed the course?", "rationale": ["Identify the relevant tables: Candidates, Student_Course_Attendance, and Student_Course_Registrations.", "We need to find the candidate who accessed a course, which means we need to join Candidates with Student_Course_Attendance.", "The join condition will be based on the candidate_id matching the student_id in Student_Course_Attendance.", "We also need to ensure that we are considering the correct course, so we will join with Student_Course_Registrations on student_id and course_id.", "To find the most recent access, we will order the results by date_of_attendance in descending order.", "Finally, we will limit the results to 1 to get the most recent candidate."], "gold_sql": "SELECT candidate_id FROM candidate_assessments ORDER BY assessment_date DESC LIMIT 1", "source_tables": ["candidate_assessments"], "pred_sql": "SELECT c.candidate_id\nFROM Candidates c\nJOIN Student_Course_Attendance sca ON c.candidate_id = sca.student_id\nJOIN Student_Course_Registrations scr ON sca.student_id = scr.student_id AND sca.course_id = scr.course_id\nORDER BY sca.date_of_attendance DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.77", "db_id": "student_assessment", "question": "What is detail of the student who registered the most number of courses?", "rationale": ["We need to find the student who registered for the most number of courses.", "To do this, we will join the 'Student_Course_Registrations' table with the 'Students' table using the student_id.", "We will group the results by student_id to count the number of courses each student has registered for.", "We will order the results in descending order based on the count of course registrations.", "Finally, we will limit the results to 1 to get the student with the highest number of registrations."], "gold_sql": "SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_course_registrations", "students"], "pred_sql": "SELECT T2.student_details \nFROM Student_Course_Registrations AS T1 \nJOIN Students AS T2 ON T1.student_id = T2.student_id \nGROUP BY T1.student_id \nORDER BY COUNT(T1.course_id) DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of all course registrations for students who have not attended any courses. The query retrieves all columns from the 'student_course_registrations' table, filtering out students based on their attendance records.\",\n        \"virtual_table\": \"SELECT * FROM student_course_registrations WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)\"\n    }\n}\n"}
{"sample_id": "train.82", "db_id": "student_assessment", "question": "For each course id, how many students are registered and what are the course names?", "rationale": ["We need to retrieve the course ID and course names along with the count of registered students for each course.", "To achieve this, we will join the 'Student_Course_Registrations' table with the 'Courses' table using the course_id as the common key.", "We will use the COUNT() function to count the number of students registered for each course.", "We will group the results by course_id and course_name to get the count for each course."], "gold_sql": "SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id", "source_tables": ["courses", "student_course_registrations", "students"], "pred_sql": "SELECT SC.course_id, C.course_name, COUNT(SC.student_id) AS student_count \nFROM Student_Course_Registrations AS SC \nJOIN Courses AS C ON SC.course_id = C.course_id \nGROUP BY SC.course_id, C.course_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of all course registrations for students who have not attended any courses. The query retrieves all columns from the 'student_course_registrations' table, filtering out students based on their attendance records.\",\n        \"virtual_table\": \"SELECT * FROM student_course_registrations WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)\"\n    }\n}\n"}
{"sample_id": "train.90", "db_id": "student_assessment", "question": "What are the ids of the students who registered for course 301 most recently?", "rationale": ["Identify the relevant tables: We need to look at the 'Student_Course_Registrations' table to find students registered for a specific course.", "Filter by course_id: We will filter the results to only include registrations for course 301.", "Order by registration_date: To find the most recent registration, we will order the results by the 'registration_date' in descending order.", "Limit the results: Since we only want the most recent registration, we will limit the results to 1."], "gold_sql": "SELECT student_id FROM student_course_attendance WHERE course_id = 301 ORDER BY date_of_attendance DESC LIMIT 1", "source_tables": ["student_course_attendance"], "pred_sql": "SELECT student_id FROM Student_Course_Registrations WHERE course_id = '301' ORDER BY registration_date DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.93", "db_id": "student_assessment", "question": "Find distinct cities of address of students?", "rationale": ["We need to find distinct cities of addresses associated with students.", "The 'Addresses' table contains the city information.", "The 'People_Addresses' table links people to their addresses.", "The 'Students' table contains the student information and links to the 'People' table via the 'person_id'.", "To get the distinct cities of addresses for students, we will join the 'Addresses', 'People_Addresses', and 'Students' tables.", "The SQL query will select distinct cities from the 'Addresses' table where the addresses are linked to students through the 'People_Addresses' table."], "gold_sql": "SELECT DISTINCT T1.city FROM addresses AS T1 JOIN people_addresses AS T2 ON T1.address_id = T2.address_id JOIN students AS T3 ON T2.person_id = T3.student_id", "source_tables": ["addresses", "people_addresses", "students"], "pred_sql": "SELECT DISTINCT T1.city FROM Addresses AS T1 JOIN People_Addresses AS T2 ON T1.address_id = T2.address_id JOIN Students AS T3 ON T2.person_id = T3.student_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique cities from the 'Addresses' table that are associated with people through the 'People_Addresses' table. The placeholder in the JOIN clause represents the relationship between addresses and people.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.city FROM addresses AS T1 JOIN people_addresses AS T2 ON T1.address_id = T2.address_id\"\n    }\n}\n"}
{"sample_id": "train.104", "db_id": "student_assessment", "question": "What are all details of the students who registered but did not attend any course?", "rationale": ["We need to find all details of students who registered for courses but did not attend any courses.", "First, we identify students who registered for courses by querying the 'Student_Course_Registrations' table.", "Next, we need to filter out those students who have attended any courses by checking against the 'Student_Course_Attendance' table.", "We can use a subquery to get the list of student IDs from 'Student_Course_Attendance' and exclude them from our main query.", "Finally, we join this information with the 'Students' table to get all details of the students who meet the criteria."], "gold_sql": "SELECT * FROM student_course_registrations WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)", "source_tables": ["student_course_attendance", "student_course_registrations"], "pred_sql": "SELECT S.* FROM Students AS S WHERE S.student_id IN (SELECT SCR.student_id FROM Student_Course_Registrations AS SCR WHERE SCR.student_id NOT IN (SELECT SCA.student_id FROM Student_Course_Attendance AS SCA))", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of all course registrations for students who have not attended any courses. The query retrieves all columns from the 'student_course_registrations' table, filtering out students based on their attendance records.\",\n        \"virtual_table\": \"SELECT * FROM student_course_registrations WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.105", "db_id": "student_assessment", "question": "List the id of students who registered course statistics in the order of registration date.", "rationale": ["Identify the relevant tables: We need to look at the 'Student_Course_Registrations' table to find students who registered for courses, and the 'Courses' table to filter for the course named 'Statistics'.", "Join the 'Student_Course_Registrations' table with the 'Courses' table to filter registrations specifically for the course 'Statistics'.", "Select the 'student_id' from the filtered results to get the IDs of students who registered for the course.", "Order the results by 'registration_date' to meet the requirement of listing them in the order of registration."], "gold_sql": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = 'statistics' ORDER BY T2.registration_date", "source_tables": ["courses", "student_course_registrations"], "pred_sql": "SELECT student_id FROM Student_Course_Registrations WHERE course_id = (SELECT course_id FROM Courses WHERE course_name = 'Statistics') ORDER BY registration_date;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of all course registrations for students who have not attended any courses. The query retrieves all columns from the 'student_course_registrations' table, filtering out students based on their attendance records.\",\n        \"virtual_table\": \"SELECT * FROM student_course_registrations WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)\"\n    }\n}\n"}
{"sample_id": "train.106", "db_id": "student_assessment", "question": "What are the ids of the students who registered course statistics by order of registration date?", "rationale": ["Identify the relevant tables: We need to use the 'Student_Course_Registrations' table to find students who registered for courses and the 'Students' table to get student details.", "Filter for the specific course: We need to filter the registrations to only include those for the course 'Statistics'.", "Join the tables: We will join 'Student_Course_Registrations' with 'Students' on the student_id to get the student details along with their registration information.", "Order by registration date: We will order the results by the registration date to get the ids in the order they registered.", "Select the student ids: Finally, we will select the student ids from the joined result."], "gold_sql": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = 'statistics' ORDER BY T2.registration_date", "source_tables": ["courses", "student_course_registrations"], "pred_sql": "SELECT T1.student_id FROM Student_Course_Registrations AS T1 JOIN Students AS T2 ON T1.student_id = T2.student_id WHERE T1.course_id = (SELECT course_id FROM Courses WHERE course_name = 'Statistics') ORDER BY T1.registration_date;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of all course registrations for students who have not attended any courses. The query retrieves all columns from the 'student_course_registrations' table, filtering out students based on their attendance records.\",\n        \"virtual_table\": \"SELECT * FROM student_course_registrations WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)\"\n    }\n}\n"}
{"sample_id": "train.123", "db_id": "bike_1", "question": "For each zip code, return the average mean temperature of August there.", "rationale": ["Identify the relevant table: The 'weather' table contains the temperature data and zip codes.", "Determine the required fields: We need the 'zip_code' and the average of 'mean_temperature_f'.", "Filter the data for August: We will filter the records to include only those from August (assuming the year is 2023 for this example).", "Group the results by zip code: To get the average temperature for each zip code, we will use the GROUP BY clause.", "Construct the SQL query: Combine all the elements into a complete SQL query."], "gold_sql": "SELECT zip_code  ,  avg(mean_temperature_f) FROM weather WHERE date LIKE '8/%' GROUP BY zip_code", "source_tables": ["weather"], "pred_sql": "SELECT zip_code, AVG(mean_temperature_f) AS average_mean_temperature\nFROM weather\nWHERE date BETWEEN '2023-08-01' AND '2023-08-31'\nGROUP BY zip_code;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates and zip codes of weather reports where the maximum temperature reached a specified threshold. The placeholder in the WHERE clause represents the minimum temperature value to filter the results.\",\n        \"virtual_table\": \"SELECT date ,  zip_code FROM weather WHERE max_temperature_f  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the dates and zip codes of weather reports where the maximum temperature reached a specified threshold. The placeholder in the WHERE clause represents the minimum temperature value to filter the results.\",\n        \"virtual_table\": \"SELECT date ,  zip_code FROM weather WHERE max_temperature_f  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average latitude and longitude of bike stations from the 'station' table where trips have started. The placeholders in the query allow for further filtering or modifications based on specific criteria.\",\n        \"virtual_table\": \"SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id\"\n    }\n}\n"}
{"sample_id": "train.135", "db_id": "bike_1", "question": "Which bike traveled the most often in zip code 94002?", "rationale": ["Identify the relevant table: The 'trip' table contains information about bike trips, including the bike ID and zip code.", "Filter trips by zip code: We need to focus on trips that started in the zip code 94002, so we will add a WHERE clause to filter by zip_code.", "Count the number of trips for each bike: We will use the COUNT function to count how many times each bike_id appears in the filtered results.", "Group the results by bike_id: To get the count of trips for each bike, we will use the GROUP BY clause on bike_id.", "Order the results: We want to find the bike that traveled the most often, so we will order the results in descending order based on the trip count.", "Limit the results to one: Since we only want the bike that traveled the most often, we will use the LIMIT clause to return only the top result."], "gold_sql": "SELECT bike_id FROM trip WHERE zip_code  =  94002 GROUP BY bike_id ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["trip"], "pred_sql": "SELECT bike_id, COUNT(*) as trip_count \nFROM trip \nWHERE zip_code = '94002' \nGROUP BY bike_id \nORDER BY trip_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the unique identifiers of trips from the 'trip' table, specifically focusing on those that started at various bike stations. The results are ordered by the number of docks available at each station in descending order, allowing users to see which stations with the most docks are associated with the trips. The placeholder in the LIMIT clause represents the maximum number of trip IDs to return.\",\n        \"virtual_table\": \"SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average latitude and longitude of bike stations from the 'station' table where trips have started. The placeholders in the query allow for further filtering or modifications based on specific criteria.\",\n        \"virtual_table\": \"SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average latitude and longitude of bike stations from the 'station' table where trips have started. The placeholders in the query allow for further filtering or modifications based on specific criteria.\",\n        \"virtual_table\": \"SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id\"\n    }\n}\n"}
{"sample_id": "train.136", "db_id": "bike_1", "question": "What is the id of the bike that traveled the most in 94002?", "rationale": ["Identify the relevant table: The 'trip' table contains information about bike trips, including the bike ID and duration.", "Filter trips by zip code: We need to focus on trips that started in the zip code '94002'.", "Order the results: To find the bike that traveled the most, we will order the trips by their duration in descending order.", "Limit the results: We only need the bike ID of the trip with the maximum duration, so we will limit the results to 1."], "gold_sql": "SELECT bike_id FROM trip WHERE zip_code  =  94002 GROUP BY bike_id ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["trip"], "pred_sql": "SELECT bike_id FROM trip WHERE zip_code = '94002' ORDER BY duration DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the unique identifiers of trips from the 'trip' table, specifically focusing on those that started at various bike stations. The results are ordered by the number of docks available at each station in descending order, allowing users to see which stations with the most docks are associated with the trips. The placeholder in the LIMIT clause represents the maximum number of trip IDs to return.\",\n        \"virtual_table\": \"SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average latitude and longitude of bike stations from the 'station' table where trips have started. The placeholders in the query allow for further filtering or modifications based on specific criteria.\",\n        \"virtual_table\": \"SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average latitude and longitude of bike stations from the 'station' table where trips have started. The placeholders in the query allow for further filtering or modifications based on specific criteria.\",\n        \"virtual_table\": \"SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id\"\n    }\n}\n"}
{"sample_id": "train.143", "db_id": "bike_1", "question": "What are the names and ids of stations that had more than 14 bikes available on average or were installed in December?", "rationale": ["We need to select the names and ids of stations.", "The relevant tables are 'station' and 'status' because we need bike availability and station details.", "We will join the 'station' table with the 'status' table on the station id.", "We need to calculate the average number of bikes available for each station, so we will use GROUP BY on the station id.", "We will use HAVING to filter the results where the average bikes available is greater than 14 or the installation date is in December.", "To check the month of the installation date, we can use the strftime function to extract the month from the installation_date."], "gold_sql": "SELECT T1.name ,  T1.id FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(T2.bikes_available)  >  14 UNION SELECT name ,  id FROM station WHERE installation_date LIKE '12/%'", "source_tables": ["status", "station"], "pred_sql": "SELECT s.name, s.id \nFROM station s \nJOIN status st ON s.id = st.station_id \nGROUP BY s.id \nHAVING AVG(st.bikes_available) > 14 OR strftime('%m', s.installation_date) = '12';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the unique identifiers of trips from the 'trip' table, specifically focusing on those that started at various bike stations. The results are ordered by the number of docks available at each station in descending order, allowing users to see which stations with the most docks are associated with the trips. The placeholder in the LIMIT clause represents the maximum number of trip IDs to return.\",\n        \"virtual_table\": \"SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average latitude and longitude of bike stations from the 'station' table where trips have started. The placeholders in the query allow for further filtering or modifications based on specific criteria.\",\n        \"virtual_table\": \"SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average latitude and longitude of bike stations from the 'station' table where trips have started. The placeholders in the query allow for further filtering or modifications based on specific criteria.\",\n        \"virtual_table\": \"SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id\"\n    }\n}\n"}
{"sample_id": "train.144", "db_id": "bike_1", "question": "What are the names and ids of all stations that have more than 14 bikes available on average or had bikes installed in December?", "rationale": ["We need to find the names and ids of all stations that meet two criteria: (1) have more than 14 bikes available on average, and (2) had bikes installed in December.", "To achieve this, we will join the 'station' table with the 'status' table on the station id.", "We will group the results by station id to calculate the average number of bikes available for each station.", "We will use the HAVING clause to filter the results based on the average number of bikes available being greater than 14.", "Additionally, we will check if the installation date of the station falls in December using the LIKE operator with a pattern that matches December dates."], "gold_sql": "SELECT T1.name ,  T1.id FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(T2.bikes_available)  >  14 UNION SELECT name ,  id FROM station WHERE installation_date LIKE '12/%'", "source_tables": ["status", "station"], "pred_sql": "SELECT s.name, s.id \nFROM station s \nJOIN status st ON s.id = st.station_id \nGROUP BY s.id \nHAVING AVG(st.bikes_available) > 14 \n   OR s.installation_date LIKE '____-12-%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the unique identifiers of trips from the 'trip' table, specifically focusing on those that started at various bike stations. The results are ordered by the number of docks available at each station in descending order, allowing users to see which stations with the most docks are associated with the trips. The placeholder in the LIMIT clause represents the maximum number of trip IDs to return.\",\n        \"virtual_table\": \"SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average latitude and longitude of bike stations from the 'station' table where trips have started. The placeholders in the query allow for further filtering or modifications based on specific criteria.\",\n        \"virtual_table\": \"SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average latitude and longitude of bike stations from the 'station' table where trips have started. The placeholders in the query allow for further filtering or modifications based on specific criteria.\",\n        \"virtual_table\": \"SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id\"\n    }\n}\n"}
{"sample_id": "train.145", "db_id": "bike_1", "question": "What is the 3 most common cloud cover rates in the region of zip code 94107?", "rationale": ["Identify the relevant table: The question pertains to cloud cover rates, which are found in the 'weather' table.", "Filter by zip code: We need to filter the results to only include records where the zip code is 94107.", "Group by cloud cover: To find the most common cloud cover rates, we will group the results by the 'cloud_cover' column.", "Count occurrences: We will count the occurrences of each cloud cover rate using COUNT(cloud_cover).", "Order by count: To get the most common rates, we will order the results in descending order based on the count.", "Limit the results: Finally, we will limit the results to the top 3 most common cloud cover rates."], "gold_sql": "SELECT cloud_cover FROM weather WHERE zip_code  =  94107 GROUP BY cloud_cover ORDER BY COUNT (*) DESC LIMIT 3", "source_tables": ["weather"], "pred_sql": "SELECT cloud_cover, COUNT(cloud_cover) as count FROM weather WHERE zip_code = 94107 GROUP BY cloud_cover ORDER BY count DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates and zip codes of weather reports where the maximum temperature reached a specified threshold. The placeholder in the WHERE clause represents the minimum temperature value to filter the results.\",\n        \"virtual_table\": \"SELECT date ,  zip_code FROM weather WHERE max_temperature_f  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the dates and zip codes of weather reports where the maximum temperature reached a specified threshold. The placeholder in the WHERE clause represents the minimum temperature value to filter the results.\",\n        \"virtual_table\": \"SELECT date ,  zip_code FROM weather WHERE max_temperature_f  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.161", "db_id": "bike_1", "question": "For each trip, return its ending station's installation date.", "rationale": ["Identify the relevant tables: We need to use the 'trip' table to get the trips and the 'station' table to get the installation dates of the ending stations.", "Join the 'trip' table with the 'station' table on the ending station ID to access the installation date.", "Select the ending station ID and the installation date from the joined tables."], "gold_sql": "SELECT T1.id ,  T2.installation_date FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id", "source_tables": ["trip", "station"], "pred_sql": "SELECT T1.end_station_id, S.installation_date FROM trip AS T1 JOIN station AS S ON T1.end_station_id = S.id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the unique identifiers of trips from the 'trip' table, specifically focusing on those that started at various bike stations. The results are ordered by the number of docks available at each station in descending order, allowing users to see which stations with the most docks are associated with the trips. The placeholder in the LIMIT clause represents the maximum number of trip IDs to return.\",\n        \"virtual_table\": \"SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average latitude and longitude of bike stations from the 'station' table where trips have started. The placeholders in the query allow for further filtering or modifications based on specific criteria.\",\n        \"virtual_table\": \"SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average latitude and longitude of bike stations from the 'station' table where trips have started. The placeholders in the query allow for further filtering or modifications based on specific criteria.\",\n        \"virtual_table\": \"SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id\"\n    }\n}\n"}
{"sample_id": "train.162", "db_id": "bike_1", "question": "What is the installation date for each ending station on all the trips?", "rationale": ["Identify the relevant tables: We need information from the 'station' table for installation dates and the 'trip' table to link trips to their ending stations.", "Determine the relationship: The 'trip' table has 'end_station_id' which corresponds to 'id' in the 'station' table.", "Construct the SQL query: We will join the 'station' table with the 'trip' table on the condition that the 'id' of the station matches the 'end_station_id' of the trip.", "Select the distinct installation dates from the 'station' table for each ending station involved in the trips."], "gold_sql": "SELECT T1.id ,  T2.installation_date FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id", "source_tables": ["trip", "station"], "pred_sql": "SELECT DISTINCT S.installation_date FROM station AS S JOIN trip AS T ON S.id = T.end_station_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the unique identifiers of trips from the 'trip' table, specifically focusing on those that started at various bike stations. The results are ordered by the number of docks available at each station in descending order, allowing users to see which stations with the most docks are associated with the trips. The placeholder in the LIMIT clause represents the maximum number of trip IDs to return.\",\n        \"virtual_table\": \"SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average latitude and longitude of bike stations from the 'station' table where trips have started. The placeholders in the query allow for further filtering or modifications based on specific criteria.\",\n        \"virtual_table\": \"SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average latitude and longitude of bike stations from the 'station' table where trips have started. The placeholders in the query allow for further filtering or modifications based on specific criteria.\",\n        \"virtual_table\": \"SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id\"\n    }\n}\n"}
{"sample_id": "train.163", "db_id": "bike_1", "question": "Which trip started from the station with the largest dock count? Give me the trip id.", "rationale": ["Identify the relevant tables: 'trip' for trip details and 'station' for station details.", "Join the 'trip' table with the 'station' table on the condition that the start_station_id in 'trip' matches the id in 'station'.", "Select the trip id from the 'trip' table (aliased as T1).", "Order the results by the dock_count from the 'station' table (aliased as T2) in descending order to get the station with the largest dock count first.", "Limit the results to 1 to get only the trip that started from the station with the largest dock count."], "gold_sql": "SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT 1", "source_tables": ["trip", "station"], "pred_sql": "SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id = T2.id ORDER BY T2.dock_count DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the unique identifiers of trips from the 'trip' table, specifically focusing on those that started at various bike stations. The results are ordered by the number of docks available at each station in descending order, allowing users to see which stations with the most docks are associated with the trips. The placeholder in the LIMIT clause represents the maximum number of trip IDs to return.\",\n        \"virtual_table\": \"SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of trip identifiers and their corresponding durations from the 'trip' table, sorted in descending order by duration. The placeholder in the LIMIT clause allows the user to specify the maximum number of records to return.\",\n        \"virtual_table\": \"SELECT id ,  duration FROM trip ORDER BY duration DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average latitude and longitude of bike stations from the 'station' table where trips have started. The placeholders in the query allow for further filtering or modifications based on specific criteria.\",\n        \"virtual_table\": \"SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id\"\n    }\n}\n"}
{"sample_id": "train.165", "db_id": "bike_1", "question": "Count the number of trips that did not end in San Francisco city.", "rationale": ["Identify the relevant tables: We need to count trips from the 'trip' table and filter based on the 'station' table for the city.", "Join the 'trip' table with the 'station' table on the end station ID to access the city information.", "Use a WHERE clause to filter out trips that ended in 'San Francisco'.", "Count the remaining trips that do not meet the criteria."], "gold_sql": "SELECT count(*) FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id WHERE T2.city !=  'San Francisco'", "source_tables": ["trip", "station"], "pred_sql": "SELECT COUNT(*) FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id = T2.id WHERE T2.city != 'San Francisco';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the unique identifiers of trips from the 'trip' table, specifically focusing on those that started at various bike stations. The results are ordered by the number of docks available at each station in descending order, allowing users to see which stations with the most docks are associated with the trips. The placeholder in the LIMIT clause represents the maximum number of trip IDs to return.\",\n        \"virtual_table\": \"SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.166", "db_id": "bike_1", "question": "How many trips did not end in San Francisco?", "rationale": ["Identify the relevant table: The 'trip' table contains information about trips, including the end station name.", "Determine the condition: We need to count trips that did not end in San Francisco, which means we will filter the results where the 'end_station_name' is not equal to 'San Francisco'.", "Construct the SQL query: We will use the COUNT function to count the number of trips that meet the condition. The final query will select the count from the 'trip' table with the specified condition."], "gold_sql": "SELECT count(*) FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id WHERE T2.city != 'San Francisco'", "source_tables": ["trip", "station"], "pred_sql": "SELECT COUNT(*) FROM trip WHERE end_station_name != 'San Francisco';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the unique identifiers of trips from the 'trip' table, specifically focusing on those that started at various bike stations. The results are ordered by the number of docks available at each station in descending order, allowing users to see which stations with the most docks are associated with the trips. The placeholder in the LIMIT clause represents the maximum number of trip IDs to return.\",\n        \"virtual_table\": \"SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.167", "db_id": "bike_1", "question": "In zip code 94107, on which day neither Fog nor Rain was not observed?", "rationale": ["Identify the relevant table: The question pertains to weather conditions, so we will use the 'weather' table.", "Filter by zip code: We need to focus on records where the zip code is 94107.", "Exclude specific weather events: We need to ensure that the events do not include 'Fog' or 'Rain'.", "Construct the SQL query: We will select the 'date' from the 'weather' table where the zip code is 94107 and the events do not include 'Fog' or 'Rain'."], "gold_sql": "SELECT date FROM weather WHERE zip_code  =  94107 AND EVENTS != 'Fog' AND EVENTS != 'Rain'", "source_tables": ["weather"], "pred_sql": "SELECT date FROM weather WHERE zip_code = 94107 AND events NOT LIKE '%Fog%' AND events NOT LIKE '%Rain%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates and zip codes of weather reports where the maximum temperature reached a specified threshold. The placeholder in the WHERE clause represents the minimum temperature value to filter the results.\",\n        \"virtual_table\": \"SELECT date ,  zip_code FROM weather WHERE max_temperature_f  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the dates and zip codes of weather reports where the maximum temperature reached a specified threshold. The placeholder in the WHERE clause represents the minimum temperature value to filter the results.\",\n        \"virtual_table\": \"SELECT date ,  zip_code FROM weather WHERE max_temperature_f  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.168", "db_id": "bike_1", "question": "On which day has it neither been foggy nor rained in the zip code of 94107?", "rationale": ["Identify the relevant table: The 'weather' table contains the necessary information about weather events and precipitation.", "Filter by zip code: We need to focus on the zip code 94107, so we will include a WHERE clause for this zip code.", "Check for no fog or rain: We need to ensure that there are no weather events (fog or rain), which can be checked by ensuring the 'events' column is NULL, and also check that 'precipitation_inches' is 0 to confirm no rain occurred.", "Select the date: Finally, we want to retrieve the date(s) that meet these criteria."], "gold_sql": "SELECT date FROM weather WHERE zip_code  =  94107 AND EVENTS != 'Fog' AND EVENTS != 'Rain'", "source_tables": ["weather"], "pred_sql": "SELECT date FROM weather WHERE zip_code = 94107 AND events IS NULL AND precipitation_inches = 0;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates and zip codes of weather reports where the maximum temperature reached a specified threshold. The placeholder in the WHERE clause represents the minimum temperature value to filter the results.\",\n        \"virtual_table\": \"SELECT date ,  zip_code FROM weather WHERE max_temperature_f  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the dates and zip codes of weather reports where the maximum temperature reached a specified threshold. The placeholder in the WHERE clause represents the minimum temperature value to filter the results.\",\n        \"virtual_table\": \"SELECT date ,  zip_code FROM weather WHERE max_temperature_f  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.183", "db_id": "bike_1", "question": "List all the cities in a decreasing order of each city's stations' highest latitude.", "rationale": ["We need to list all the cities from the station table.", "To find the highest latitude for each city, we can use the MAX function on the 'lat' column.", "We will group the results by 'city' to ensure we get the highest latitude for each city.", "Finally, we will order the results in descending order based on the highest latitude."], "gold_sql": "SELECT city FROM station GROUP BY city ORDER BY max(lat) DESC", "source_tables": ["station"], "pred_sql": "SELECT city, MAX(lat) AS highest_latitude \nFROM station \nGROUP BY city \nORDER BY highest_latitude DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average latitude and longitude of bike stations from the 'station' table where trips have started. The placeholders in the query allow for further filtering or modifications based on specific criteria.\",\n        \"virtual_table\": \"SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average latitude and longitude of bike stations from the 'station' table where trips have started. The placeholders in the query allow for further filtering or modifications based on specific criteria.\",\n        \"virtual_table\": \"SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the unique identifiers of trips from the 'trip' table, specifically focusing on those that started at various bike stations. The results are ordered by the number of docks available at each station in descending order, allowing users to see which stations with the most docks are associated with the trips. The placeholder in the LIMIT clause represents the maximum number of trip IDs to return.\",\n        \"virtual_table\": \"SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.184", "db_id": "bike_1", "question": "For each city, list their names in decreasing order by their highest station latitude.", "rationale": ["We need to list the names of bike stations for each city ordered by their highest latitude.", "To find the highest latitude for each city, we can use a subquery that selects the maximum latitude from the station table, grouped by city.", "We will then join this result back to the station table to get the names of the stations that correspond to these maximum latitudes.", "Finally, we will order the results by latitude in descending order to meet the requirement of the query."], "gold_sql": "SELECT city FROM station GROUP BY city ORDER BY max(lat) DESC", "source_tables": ["station"], "pred_sql": "SELECT city, name FROM station WHERE lat = (SELECT MAX(lat) FROM station GROUP BY city) ORDER BY lat DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average latitude and longitude of bike stations from the 'station' table where trips have started. The placeholders in the query allow for further filtering or modifications based on specific criteria.\",\n        \"virtual_table\": \"SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average latitude and longitude of bike stations from the 'station' table where trips have started. The placeholders in the query allow for further filtering or modifications based on specific criteria.\",\n        \"virtual_table\": \"SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the unique identifiers of trips from the 'trip' table, specifically focusing on those that started at various bike stations. The results are ordered by the number of docks available at each station in descending order, allowing users to see which stations with the most docks are associated with the trips. The placeholder in the LIMIT clause represents the maximum number of trip IDs to return.\",\n        \"virtual_table\": \"SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.189", "db_id": "bike_1", "question": "For each station, return its longitude and the average duration of trips that started from the station.", "rationale": ["We need to select the longitude of each station and the average duration of trips that started from that station.", "To get the longitude, we will select the 'long' column from the 'station' table.", "To calculate the average duration of trips, we will use the 'duration' column from the 'trip' table.", "We will join the 'station' table with the 'trip' table on the condition that the station's id matches the start_station_id in the trip table.", "We will group the results by the station id to ensure we get the average duration for each station."], "gold_sql": "SELECT T1.name ,  T1.long ,  avg(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id GROUP BY T2.start_station_id", "source_tables": ["trip", "station"], "pred_sql": "SELECT S.long, AVG(T.duration) AS average_duration\nFROM station AS S\nJOIN trip AS T ON S.id = T.start_station_id\nGROUP BY S.id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average latitude and longitude of bike stations from the 'station' table where trips have started. The placeholders in the query allow for further filtering or modifications based on specific criteria.\",\n        \"virtual_table\": \"SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average latitude and longitude of bike stations from the 'station' table where trips have started. The placeholders in the query allow for further filtering or modifications based on specific criteria.\",\n        \"virtual_table\": \"SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the unique identifiers of trips from the 'trip' table, specifically focusing on those that started at various bike stations. The results are ordered by the number of docks available at each station in descending order, allowing users to see which stations with the most docks are associated with the trips. The placeholder in the LIMIT clause represents the maximum number of trip IDs to return.\",\n        \"virtual_table\": \"SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.190", "db_id": "bike_1", "question": "For each start station id, what is its name, longitude and average duration of trips started there?", "rationale": ["We need to retrieve the start station id, name, longitude, and average duration of trips for each start station.", "The 'station' table contains the station details including id, name, and longitude.", "The 'trip' table contains the trip details including start_station_id and duration.", "To get the average duration of trips for each station, we will join the 'station' table with the 'trip' table on the station id and start station id.", "We will use the AVG() function to calculate the average duration of trips for each station.", "Finally, we will group the results by station id, name, and longitude to ensure we get one result per station."], "gold_sql": "SELECT T1.name ,  T1.long ,  avg(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id GROUP BY T2.start_station_id", "source_tables": ["trip", "station"], "pred_sql": "SELECT T1.id, T1.name, T1.long, AVG(T2.duration) AS average_duration\nFROM station AS T1\nJOIN trip AS T2 ON T1.id = T2.start_station_id\nGROUP BY T1.id, T1.name, T1.long;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average latitude and longitude of bike stations from the 'station' table where trips have started. The placeholders in the query allow for further filtering or modifications based on specific criteria.\",\n        \"virtual_table\": \"SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average latitude and longitude of bike stations from the 'station' table where trips have started. The placeholders in the query allow for further filtering or modifications based on specific criteria.\",\n        \"virtual_table\": \"SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the unique identifiers of trips from the 'trip' table, specifically focusing on those that started at various bike stations. The results are ordered by the number of docks available at each station in descending order, allowing users to see which stations with the most docks are associated with the trips. The placeholder in the LIMIT clause represents the maximum number of trip IDs to return.\",\n        \"virtual_table\": \"SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.192", "db_id": "bike_1", "question": "For each end station id, what is its name, latitude, and minimum duration for trips ended there?", "rationale": ["Identify the relevant tables: We need to gather information from the 'trip' and 'station' tables.", "Determine the required fields: We need the end station id, name, latitude, and minimum duration for trips that ended at each station.", "Join the tables: We will join the 'trip' table with the 'station' table on the end station id to get the station details.", "Group the results: We will group by the end station id to calculate the minimum duration for trips ending at each station.", "Select the minimum duration: Use the MIN() function to get the minimum duration for trips that ended at each station."], "gold_sql": "SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id", "source_tables": ["trip", "station"], "pred_sql": "SELECT T3.end_station_id, T2.name, T2.lat, MIN(T1.duration) AS min_duration\nFROM trip AS T1\nJOIN station AS T2 ON T1.end_station_id = T2.id\nGROUP BY T3.end_station_id, T2.name, T2.lat;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the unique identifiers of trips from the 'trip' table, specifically focusing on those that started at various bike stations. The results are ordered by the number of docks available at each station in descending order, allowing users to see which stations with the most docks are associated with the trips. The placeholder in the LIMIT clause represents the maximum number of trip IDs to return.\",\n        \"virtual_table\": \"SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average latitude and longitude of bike stations from the 'station' table where trips have started. The placeholders in the query allow for further filtering or modifications based on specific criteria.\",\n        \"virtual_table\": \"SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average latitude and longitude of bike stations from the 'station' table where trips have started. The placeholders in the query allow for further filtering or modifications based on specific criteria.\",\n        \"virtual_table\": \"SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id\"\n    }\n}\n"}
{"sample_id": "train.196", "db_id": "bike_1", "question": "What are all the different zip codes that have a maximum dew point that was always below 70?", "rationale": ["Identify the requirement to find distinct zip codes.", "Focus on the weather table since it contains the relevant data about dew points and zip codes.", "Use the condition that the maximum dew point must be below 70 degrees.", "Select distinct zip codes to ensure that each zip code is listed only once."], "gold_sql": "SELECT DISTINCT zip_code FROM weather EXCEPT SELECT DISTINCT zip_code FROM weather WHERE max_dew_point_f  >=  70", "source_tables": ["weather"], "pred_sql": "SELECT DISTINCT zip_code FROM weather WHERE max_dew_point_f < 70", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates and zip codes of weather reports where the maximum temperature reached a specified threshold. The placeholder in the WHERE clause represents the minimum temperature value to filter the results.\",\n        \"virtual_table\": \"SELECT date ,  zip_code FROM weather WHERE max_temperature_f  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the dates and zip codes of weather reports where the maximum temperature reached a specified threshold. The placeholder in the WHERE clause represents the minimum temperature value to filter the results.\",\n        \"virtual_table\": \"SELECT date ,  zip_code FROM weather WHERE max_temperature_f  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.205", "db_id": "bike_1", "question": "Give me the zip code where the average mean humidity is below 70 and at least 100 trips took place.", "rationale": ["We need to find zip codes where the average mean humidity is below 70 and at least 100 trips took place.", "To achieve this, we will join the 'weather' table with the 'trip' table on the zip code column.", "We will group the results by zip code to calculate the average mean humidity and count the number of trips for each zip code.", "The HAVING clause will filter the results to only include those zip codes where the average mean humidity is less than 70 and the count of trips is at least 100."], "gold_sql": "SELECT zip_code FROM weather GROUP BY zip_code HAVING avg(mean_humidity)  <  70 INTERSECT SELECT zip_code FROM trip GROUP BY zip_code HAVING count(*)  >=  100", "source_tables": ["weather", "trip"], "pred_sql": "SELECT zip_code \nFROM weather \nJOIN trip ON weather.zip_code = trip.zip_code \nGROUP BY zip_code \nHAVING AVG(mean_humidity) < 70 AND COUNT(trip.id) >= 100;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates and zip codes of weather reports where the maximum temperature reached a specified threshold. The placeholder in the WHERE clause represents the minimum temperature value to filter the results.\",\n        \"virtual_table\": \"SELECT date ,  zip_code FROM weather WHERE max_temperature_f  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the dates and zip codes of weather reports where the maximum temperature reached a specified threshold. The placeholder in the WHERE clause represents the minimum temperature value to filter the results.\",\n        \"virtual_table\": \"SELECT date ,  zip_code FROM weather WHERE max_temperature_f  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.206", "db_id": "bike_1", "question": "What are the zip codes that have an average mean humidity below 70 and had at least 100 trips come through there?", "rationale": ["Identify the requirement to find zip codes with average mean humidity below 70 and at least 100 trips.", "To achieve this, we need to use the 'weather' table to filter zip codes based on average mean humidity.", "We will group the weather data by zip code and calculate the average mean humidity, applying the condition that it must be below 70.", "Next, we will use the 'trip' table to count the number of trips associated with each zip code.", "We will group the trips by zip code and apply the condition that the count of trips must be at least 100.", "Finally, we will combine these two conditions using a subquery to filter the zip codes accordingly."], "gold_sql": "SELECT zip_code FROM weather GROUP BY zip_code HAVING avg(mean_humidity)  <  70 INTERSECT SELECT zip_code FROM trip GROUP BY zip_code HAVING count(*)  >=  100", "source_tables": ["weather", "trip"], "pred_sql": "SELECT zip_code \nFROM trip \nWHERE zip_code IN (\n    SELECT zip_code \n    FROM weather \n    GROUP BY zip_code \n    HAVING AVG(mean_humidity) < 70\n) \nGROUP BY zip_code \nHAVING COUNT(id) >= 100;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates and zip codes of weather reports where the maximum temperature reached a specified threshold. The placeholder in the WHERE clause represents the minimum temperature value to filter the results.\",\n        \"virtual_table\": \"SELECT date ,  zip_code FROM weather WHERE max_temperature_f  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the dates and zip codes of weather reports where the maximum temperature reached a specified threshold. The placeholder in the WHERE clause represents the minimum temperature value to filter the results.\",\n        \"virtual_table\": \"SELECT date ,  zip_code FROM weather WHERE max_temperature_f  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.304", "db_id": "product_catalog", "question": "What are the attribute data types with more than 3 attribute definitions?", "rationale": ["Identify the table that contains the attribute data types, which is 'Attribute_Definitions'.", "We need to group the results by 'attribute_data_type' to count how many definitions exist for each type.", "Use the COUNT function to count the number of 'attribute_id' for each 'attribute_data_type'.", "Apply the HAVING clause to filter the groups where the count is greater than 3."], "gold_sql": "SELECT attribute_data_type FROM Attribute_Definitions GROUP BY attribute_data_type HAVING count(*)  >  3", "source_tables": ["attribute_definitions"], "pred_sql": "SELECT attribute_data_type\nFROM Attribute_Definitions\nGROUP BY attribute_data_type\nHAVING COUNT(attribute_id) > 3;", "hint": "\n"}
{"sample_id": "train.316", "db_id": "product_catalog", "question": "Find the entry names of the catalog with the attribute that have the most entries.", "rationale": ["Identify the relevant tables: Catalog_Contents for entry names and Catalog_Contents_Additional_Attributes for attributes associated with those entries.", "Join Catalog_Contents with Catalog_Contents_Additional_Attributes on catalog_entry_id to link entries with their attributes.", "Group the results by catalog_entry_id to count the number of attributes associated with each entry.", "Order the results by the count of attributes in descending order to find the entry with the most attributes.", "Limit the results to 1 to get only the entry name with the most attributes."], "gold_sql": "SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.attribute_value  =  (SELECT attribute_value FROM Catalog_Contents_Additional_Attributes GROUP BY attribute_value ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["catalog_contents", "catalog_contents_additional_attributes"], "pred_sql": "SELECT cc.catalog_entry_name\nFROM Catalog_Contents cc\nJOIN Catalog_Contents_Additional_Attributes cca ON cc.catalog_entry_id = cca.catalog_entry_id\nGROUP BY cc.catalog_entry_id\nORDER BY COUNT(cca.attribute_id) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the names of catalog levels from the 'Catalog_Structure' table that are associated with entries in the 'Catalog_Contents' table. The results are ordered by the price in dollars of the catalog entries, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t2.catalog_level_name FROM catalog_contents AS t1 JOIN catalog_structure AS t2 ON t1.catalog_level_number  =  t2.catalog_level_number ORDER BY t1.price_in_dollars LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table describes the names of catalog levels from the 'Catalog_Structure' table that are associated with entries in the 'Catalog_Contents' table. The results are ordered by the price in dollars of the catalog entries, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t2.catalog_level_name FROM catalog_contents AS t1 JOIN catalog_structure AS t2 ON t1.catalog_level_number  =  t2.catalog_level_number ORDER BY t1.price_in_dollars LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.317", "db_id": "product_catalog", "question": "What is the entry name of the most expensive catalog (in USD)?", "rationale": ["Identify the table that contains the entry names and prices, which is 'Catalog_Contents'.", "To find the most expensive catalog entry, we need to order the results by 'price_in_dollars' in descending order.", "We will limit the results to 1 to get only the most expensive entry.", "The final SQL query selects the 'catalog_entry_name' from 'Catalog_Contents', orders by 'price_in_dollars' in descending order, and limits the result to 1."], "gold_sql": "SELECT catalog_entry_name FROM catalog_contents ORDER BY price_in_dollars DESC LIMIT 1", "source_tables": ["catalog_contents"], "pred_sql": "SELECT catalog_entry_name FROM Catalog_Contents ORDER BY price_in_dollars DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the names of catalog levels from the 'Catalog_Structure' table that are associated with entries in the 'Catalog_Contents' table. The results are ordered by the price in dollars of the catalog entries, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t2.catalog_level_name FROM catalog_contents AS t1 JOIN catalog_structure AS t2 ON t1.catalog_level_number  =  t2.catalog_level_number ORDER BY t1.price_in_dollars LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table describes the names of catalog levels from the 'Catalog_Structure' table that are associated with entries in the 'Catalog_Contents' table. The results are ordered by the price in dollars of the catalog entries, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t2.catalog_level_name FROM catalog_contents AS t1 JOIN catalog_structure AS t2 ON t1.catalog_level_number  =  t2.catalog_level_number ORDER BY t1.price_in_dollars LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.330", "db_id": "product_catalog", "question": "What are the names of catalog entries with level number 8?", "rationale": ["Identify the relevant table: Catalog_Contents contains the catalog entries.", "Determine the condition: We need entries with a specific level number, which is '8'.", "Construct the SQL query to select the catalog_entry_name from Catalog_Contents where catalog_level_number is '8'."], "gold_sql": "SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.catalog_level_number  =  '8'", "source_tables": ["catalog_contents", "catalog_contents_additional_attributes"], "pred_sql": "SELECT catalog_entry_name FROM Catalog_Contents WHERE catalog_level_number = '8'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the names of catalog levels from the 'Catalog_Structure' table that are associated with entries in the 'Catalog_Contents' table. The results are ordered by the price in dollars of the catalog entries, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t2.catalog_level_name FROM catalog_contents AS t1 JOIN catalog_structure AS t2 ON t1.catalog_level_number  =  t2.catalog_level_number ORDER BY t1.price_in_dollars LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table describes the names of catalog levels from the 'Catalog_Structure' table that are associated with entries in the 'Catalog_Contents' table. The results are ordered by the price in dollars of the catalog entries, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t2.catalog_level_name FROM catalog_contents AS t1 JOIN catalog_structure AS t2 ON t1.catalog_level_number  =  t2.catalog_level_number ORDER BY t1.price_in_dollars LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.331", "db_id": "product_catalog", "question": "Find the names of the products with length smaller than 3 or height greater than 5.", "rationale": ["Identify the table that contains product information, which is the Catalog_Contents table.", "Determine the relevant columns needed for the query: catalog_entry_name for product names, length for the length condition, and height for the height condition.", "Construct the SELECT statement to retrieve the catalog_entry_name from the Catalog_Contents table.", "Add the WHERE clause to filter products based on the conditions: length smaller than 3 or height greater than 5."], "gold_sql": "SELECT catalog_entry_name FROM catalog_contents WHERE LENGTH  <  3 OR width  >  5", "source_tables": ["catalog_contents"], "pred_sql": "SELECT catalog_entry_name \nFROM Catalog_Contents \nWHERE length < 3 OR height > 5;", "hint": "\n"}
{"sample_id": "train.332", "db_id": "product_catalog", "question": "Which catalog contents have length below 3 or above 5? Find the catalog entry names.", "rationale": ["Identify the relevant table: Catalog_Contents contains the catalog entry names and their lengths.", "Determine the condition: We need to find entries where the length is below 3 or above 5.", "Construct the SQL query: Use a SELECT statement to retrieve catalog_entry_name from Catalog_Contents where the length meets the specified conditions."], "gold_sql": "SELECT catalog_entry_name FROM catalog_contents WHERE LENGTH  <  3 OR width  >  5", "source_tables": ["catalog_contents"], "pred_sql": "SELECT catalog_entry_name FROM Catalog_Contents WHERE length < 3 OR length > 5;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the names of catalog levels from the 'Catalog_Structure' table that are associated with entries in the 'Catalog_Contents' table. The results are ordered by the price in dollars of the catalog entries, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t2.catalog_level_name FROM catalog_contents AS t1 JOIN catalog_structure AS t2 ON t1.catalog_level_number  =  t2.catalog_level_number ORDER BY t1.price_in_dollars LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table describes the names of catalog levels from the 'Catalog_Structure' table that are associated with entries in the 'Catalog_Contents' table. The results are ordered by the price in dollars of the catalog entries, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t2.catalog_level_name FROM catalog_contents AS t1 JOIN catalog_structure AS t2 ON t1.catalog_level_number  =  t2.catalog_level_number ORDER BY t1.price_in_dollars LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.338", "db_id": "product_catalog", "question": "On which days more than one revisions were made on catalogs.", "rationale": ["Identify the relevant table: The question pertains to revisions of catalogs, so we will focus on the 'Catalogs' table.", "Determine the relevant columns: We need the 'date_of_latest_revision' to group by the revision dates and count the number of revisions.", "Group the results: We will group the results by 'date_of_latest_revision' to count how many revisions occurred on each date.", "Filter the results: We will use the HAVING clause to filter out dates where the count of revisions is more than one."], "gold_sql": "SELECT date_of_latest_revision FROM Catalogs GROUP BY date_of_latest_revision HAVING count(*)  >  1", "source_tables": ["catalogs"], "pred_sql": "SELECT date_of_latest_revision, COUNT(*) as revision_count \nFROM Catalogs \nGROUP BY date_of_latest_revision \nHAVING COUNT(*) > 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the names of catalog levels from the 'Catalog_Structure' table that are associated with entries in the 'Catalog_Contents' table. The results are ordered by the price in dollars of the catalog entries, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t2.catalog_level_name FROM catalog_contents AS t1 JOIN catalog_structure AS t2 ON t1.catalog_level_number  =  t2.catalog_level_number ORDER BY t1.price_in_dollars LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table describes the names of catalog levels from the 'Catalog_Structure' table that are associated with entries in the 'Catalog_Contents' table. The results are ordered by the price in dollars of the catalog entries, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t2.catalog_level_name FROM catalog_contents AS t1 JOIN catalog_structure AS t2 ON t1.catalog_level_number  =  t2.catalog_level_number ORDER BY t1.price_in_dollars LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.388", "db_id": "flight_1", "question": "What are the origins of all flights that are headed to Honolulu?", "rationale": ["Identify the relevant table: The 'flight' table contains information about flight origins and destinations.", "Determine the required information: We need the origins of flights that are headed to Honolulu.", "Construct the SQL query: Use a SELECT statement to retrieve the 'origin' column from the 'flight' table where the 'destination' is 'Honolulu'."], "gold_sql": "SELECT origin FROM Flight WHERE destination  =  'Honolulu'", "source_tables": ["flight"], "pred_sql": "SELECT origin FROM flight WHERE destination = 'Honolulu'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the origins of flights from the 'Flight' table that are headed to a specific destination. The placeholder in the WHERE clause represents the destination's name.\",\n        \"virtual_table\": \"SELECT origin FROM Flight WHERE destination  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the flight numbers from the 'Flight' table, ordered by the distance of each flight in ascending order. The placeholder in the LIMIT clause represents the maximum number of flight numbers to be returned.\",\n        \"virtual_table\": \"SELECT flno FROM Flight ORDER BY distance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.390", "db_id": "flight_1", "question": "What are the departure and arrival dates of all flights from LA to Honolulu?", "rationale": ["Identify the relevant table: The 'flight' table contains the information about flights, including departure and arrival dates.", "Determine the required columns: We need the 'departure_date' and 'arrival_date' for the flights.", "Specify the conditions: We are interested in flights that originate from 'LA' and have 'Honolulu' as their destination.", "Construct the SQL query: Using the SELECT statement to retrieve the specified columns from the 'flight' table with the appropriate WHERE clause."], "gold_sql": "SELECT departure_date ,  arrival_date FROM Flight WHERE origin  =  'Los Angeles' AND destination  =  'Honolulu'", "source_tables": ["flight"], "pred_sql": "SELECT departure_date, arrival_date FROM flight WHERE origin = 'LA' AND destination = 'Honolulu';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the origins of flights from the 'Flight' table that are headed to a specific destination. The placeholder in the WHERE clause represents the destination's name.\",\n        \"virtual_table\": \"SELECT origin FROM Flight WHERE destination  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the flight numbers from the 'Flight' table, ordered by the distance of each flight in ascending order. The placeholder in the LIMIT clause represents the maximum number of flight numbers to be returned.\",\n        \"virtual_table\": \"SELECT flno FROM Flight ORDER BY distance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.394", "db_id": "flight_1", "question": "What is the average price for flights from LA to Honolulu?", "rationale": ["Identify the relevant table: The 'flight' table contains the necessary information about flights, including their prices and routes.", "Determine the columns needed: We need the 'price' column to calculate the average price and the 'origin' and 'destination' columns to filter the flights from LA to Honolulu.", "Construct the SQL query: Use the AVG() function to calculate the average price, and include a WHERE clause to filter for flights originating from LA and heading to Honolulu."], "gold_sql": "SELECT avg(price) FROM Flight WHERE origin  =  'Los Angeles' AND destination  =  'Honolulu'", "source_tables": ["flight"], "pred_sql": "SELECT AVG(price) AS average_price FROM flight WHERE origin = 'LA' AND destination = 'Honolulu';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the origins of flights from the 'Flight' table that are headed to a specific destination. The placeholder in the WHERE clause represents the destination's name.\",\n        \"virtual_table\": \"SELECT origin FROM Flight WHERE destination  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the flight numbers from the 'Flight' table, ordered by the distance of each flight in ascending order. The placeholder in the LIMIT clause represents the maximum number of flight numbers to be returned.\",\n        \"virtual_table\": \"SELECT flno FROM Flight ORDER BY distance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.415", "db_id": "flight_1", "question": "Show aircraft names and number of flights for each aircraft.", "rationale": ["We need to retrieve the names of the aircraft and the number of flights associated with each aircraft.", "To do this, we will select the 'name' column from the 'aircraft' table.", "We will also count the number of flight numbers ('flno') from the 'flight' table to get the number of flights for each aircraft.", "To connect the two tables, we will use a LEFT JOIN on the 'aid' column, which is the common key between 'aircraft' and 'flight'.", "Finally, we will group the results by the aircraft ID ('aid') and name to ensure we get the count of flights for each aircraft."], "gold_sql": "SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid", "source_tables": ["aircraft", "flight"], "pred_sql": "SELECT a.name, COUNT(f.flno) AS number_of_flights\nFROM aircraft a\nLEFT JOIN flight f ON a.aid = f.aid\nGROUP BY a.aid, a.name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the flight numbers from the 'Flight' table, ordered by the distance of each flight in ascending order. The placeholder in the LIMIT clause represents the maximum number of flight numbers to be returned.\",\n        \"virtual_table\": \"SELECT flno FROM Flight ORDER BY distance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.416", "db_id": "flight_1", "question": "What is the name of each aircraft and how many flights does each one complete?", "rationale": ["Identify the tables needed: 'aircraft' for aircraft names and 'flight' for flight information.", "We need to count the number of flights for each aircraft, so we will use a COUNT function on the flight numbers (flno).", "To associate flights with their respective aircraft, we will perform a LEFT JOIN between the 'aircraft' table and the 'flight' table on the aircraft ID (aid).", "We will group the results by the aircraft name to get the count of flights for each aircraft.", "The final SQL query will select the aircraft name and the count of flights, using the appropriate SQL syntax."], "gold_sql": "SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid", "source_tables": ["aircraft", "flight"], "pred_sql": "SELECT aircraft.name, COUNT(flight.flno) AS flight_count \nFROM aircraft \nLEFT JOIN flight ON aircraft.aid = flight.aid \nGROUP BY aircraft.name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the origins of flights from the 'Flight' table that are headed to a specific destination. The placeholder in the WHERE clause represents the destination's name.\",\n        \"virtual_table\": \"SELECT origin FROM Flight WHERE destination  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the flight numbers from the 'Flight' table, ordered by the distance of each flight in ascending order. The placeholder in the LIMIT clause represents the maximum number of flight numbers to be returned.\",\n        \"virtual_table\": \"SELECT flno FROM Flight ORDER BY distance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.430", "db_id": "flight_1", "question": "What are the names of all employees who are not certified to fly Boeing 737-800s?", "rationale": ["Identify the main table to query from, which is the 'employee' table to get employee names.", "We need to find employees who are not certified to fly a specific aircraft, in this case, the 'Boeing 737-800'.", "To find certified employees, we will use the 'certificate' table and join it with the 'aircraft' table to filter by aircraft name.", "The subquery will select employee IDs (eid) from the 'certificate' table where the associated aircraft is 'Boeing 737-800'.", "The main query will select names from the 'employee' table where the employee ID is not in the list of IDs returned by the subquery."], "gold_sql": "SELECT name FROM Employee EXCEPT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  'Boeing 737-800'", "source_tables": ["employee", "certificate", "aircraft"], "pred_sql": "SELECT e.name \nFROM employee e \nWHERE e.eid NOT IN (\n    SELECT c.eid \n    FROM certificate c \n    JOIN aircraft a ON c.aid = a.aid \n    WHERE a.name = 'Boeing 737-800'\n);", "hint": "\n"}
{"sample_id": "train.431", "db_id": "flight_1", "question": "Show the name of aircraft which fewest people have its certificate.", "rationale": ["We need to find the name of the aircraft that has the fewest people holding its certificate.", "To do this, we will join the 'aircraft' table with the 'certificate' table on the aircraft ID (aid).", "We will group the results by the aircraft ID to count how many certificates each aircraft has.", "We will then order the results by the count of certificates in ascending order to get the aircraft with the fewest certificates at the top.", "Finally, we will limit the results to just one entry to get the aircraft with the fewest certificates."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["aircraft", "certificate"], "pred_sql": "SELECT a.name\nFROM aircraft a\nJOIN certificate c ON a.aid = c.aid\nGROUP BY a.aid\nORDER BY COUNT(c.eid) ASC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.432", "db_id": "flight_1", "question": "What are the names of the aircraft that the least people are certified to fly?", "rationale": ["Identify the relevant tables: We need to find aircraft names and the number of employees certified to fly each aircraft, so we will use the 'aircraft' and 'certificate' tables.", "Join the tables: We will join the 'aircraft' table with the 'certificate' table on the aircraft ID (aid) to associate each aircraft with its certified employees.", "Group by aircraft: We will group the results by the aircraft ID to count the number of certifications for each aircraft.", "Count certifications: Use COUNT(c.eid) to count the number of employees certified for each aircraft.", "Order by count: We will order the results in ascending order based on the count of certifications to find the aircraft with the least certifications.", "Limit the results: Finally, we will limit the results to 1 to get the aircraft with the least number of certified employees."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["aircraft", "certificate"], "pred_sql": "SELECT a.name\nFROM aircraft a\nJOIN certificate c ON a.aid = c.aid\nGROUP BY a.aid\nORDER BY COUNT(c.eid) ASC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.438", "db_id": "flight_1", "question": "What is the salaray and name of the employee with the most certificates to fly planes more than 5000?", "rationale": ["Identify the relevant tables: employee, certificate, and aircraft.", "We need to find employees who have certificates to fly aircraft with a maximum distance greater than 5000.", "Join the employee table with the certificate table on employee ID (eid) and then join with the aircraft table on aircraft ID (aid).", "Filter the results to include only those aircraft where the distance is greater than 5000.", "Group the results by employee ID to count the number of certificates each employee has.", "Order the results by the count of certificates in descending order to find the employee with the most certificates.", "Limit the results to 1 to get only the top employee."], "gold_sql": "SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  5000 GROUP BY T1.eid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employee", "certificate", "aircraft"], "pred_sql": "SELECT e.salary, e.name \nFROM employee e \nJOIN certificate c ON e.eid = c.eid \nJOIN aircraft a ON c.aid = a.aid \nWHERE a.distance > 5000 \nGROUP BY e.eid \nORDER BY COUNT(c.aid) DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.448", "db_id": "allergy_1", "question": "What are all the different food allergies?", "rationale": ["The question asks for all the different food allergies, which implies we need to retrieve unique allergy names.", "We will use the 'Allergy_Type' table since it contains the names of the allergies.", "To get distinct allergy names, we will use the SELECT DISTINCT statement on the 'Allergy' column from the 'Allergy_Type' table."], "gold_sql": "SELECT DISTINCT allergy FROM Allergy_type WHERE allergytype  =  'food'", "source_tables": ["allergy_type"], "pred_sql": "SELECT DISTINCT Allergy FROM Allergy_Type", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the type or category of a specific allergy from the 'Allergy_Type' table. The placeholder in the WHERE clause represents the name of the allergy being queried.\",\n        \"virtual_table\": \"SELECT allergytype FROM Allergy_type WHERE allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of distinct allergy types from the 'Allergy_Type' table. The result will indicate how many unique categories of allergies are present in the database.\",\n        \"virtual_table\": \"SELECT count(DISTINCT allergytype) FROM Allergy_type\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.452", "db_id": "allergy_1", "question": "How many animal type allergies exist?", "rationale": ["The question asks for the number of distinct animal type allergies.", "To find this, we need to count the unique entries in the 'AllergyType' column of the 'Allergy_Type' table.", "The provided hint suggests using a virtual table that counts distinct allergy types, which aligns with our goal.", "Thus, the SQL query will be: SELECT count(DISTINCT AllergyType) FROM Allergy_Type."], "gold_sql": "SELECT count(*) FROM Allergy_type WHERE allergytype  =  'animal'", "source_tables": ["allergy_type"], "pred_sql": "SELECT count(DISTINCT AllergyType) FROM Allergy_Type", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of distinct allergy types from the 'Allergy_Type' table. The result will indicate how many unique categories of allergies are present in the database.\",\n        \"virtual_table\": \"SELECT count(DISTINCT allergytype) FROM Allergy_type\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.455", "db_id": "allergy_1", "question": "Which allergy type has most number of allergies?", "rationale": ["We need to find out which allergy type has the most number of allergies.", "To do this, we will join the 'Has_Allergy' table with the 'Allergy_Type' table on the Allergy column.", "We will group the results by the AllergyType to count how many allergies fall under each type.", "We will use COUNT(*) to count the number of allergies for each type.", "To find the type with the most allergies, we will order the results in descending order based on the count.", "Finally, we will limit the results to just one entry to get the allergy type with the highest count."], "gold_sql": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT 1", "source_tables": ["allergy_type"], "pred_sql": "SELECT T2.AllergyType, COUNT(*) AS AllergyCount \nFROM Has_Allergy AS T1 \nJOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy \nGROUP BY T2.AllergyType \nORDER BY AllergyCount DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of distinct allergy types from the 'Allergy_Type' table. The result will indicate how many unique categories of allergies are present in the database.\",\n        \"virtual_table\": \"SELECT count(DISTINCT allergytype) FROM Allergy_type\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.458", "db_id": "allergy_1", "question": "Which allergy type is the least common?", "rationale": ["To find the least common allergy type, we need to count how many students have each type of allergy.", "We will join the 'Has_Allergy' table with the 'Allergy_Type' table to get the allergy types associated with each student.", "We will group the results by the allergy type to get the count of students for each type.", "Next, we will order the results by the count in ascending order to find the least common allergy type.", "Finally, we will limit the results to 1 to get only the least common allergy type."], "gold_sql": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) ASC LIMIT 1", "source_tables": ["allergy_type"], "pred_sql": "SELECT T2.allergytype, COUNT(*) AS allergy_count \nFROM Has_Allergy AS T1 \nJOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy \nGROUP BY T2.allergytype \nORDER BY allergy_count ASC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the type or category of a specific allergy from the 'Allergy_Type' table. The placeholder in the WHERE clause represents the name of the allergy being queried.\",\n        \"virtual_table\": \"SELECT allergytype FROM Allergy_type WHERE allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of distinct allergy types from the 'Allergy_Type' table. The result will indicate how many unique categories of allergies are present in the database.\",\n        \"virtual_table\": \"SELECT count(DISTINCT allergytype) FROM Allergy_type\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.462", "db_id": "allergy_1", "question": "What are the full names of all students", "rationale": ["Identify the table that contains student names, which is the 'Student' table.", "To get the full names, we need to concatenate the 'Fname' and 'LName' columns.", "Use the SQL SELECT statement to retrieve the concatenated names as 'FullName'."], "gold_sql": "SELECT Fname ,  Lname FROM Student", "source_tables": ["student"], "pred_sql": "SELECT Fname || ' ' || LName AS FullName FROM Student;", "hint": "\n"}
{"sample_id": "train.472", "db_id": "allergy_1", "question": "What are the student ids for all male students?", "rationale": ["Identify the relevant table: The 'Student' table contains the information about students, including their gender.", "Determine the required information: We need the student IDs (StuID) for all male students.", "Use the provided hint: The hint suggests a virtual table that selects StuID from the Student table where Sex matches a specific value.", "Replace the placeholder in the hint with 'Male' to filter for male students."], "gold_sql": "SELECT StuID FROM Student WHERE Sex  =  'M'", "source_tables": ["student"], "pred_sql": "SELECT StuID FROM Student WHERE Sex = 'Male'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the unique identifiers of students from the 'Student' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the students.\",\n        \"virtual_table\": \"SELECT StuID FROM Student WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.492", "db_id": "allergy_1", "question": "What is the largest major?", "rationale": ["Identify the table that contains the major information, which is the 'Student' table.", "To find the largest major, we need to count the number of students in each major.", "We will use the COUNT function to count the number of students for each major.", "We will group the results by the 'Major' column to get the count for each major.", "To find the largest major, we will order the results in descending order based on the count of students.", "Finally, we will limit the results to 1 to get only the largest major."], "gold_sql": "SELECT major FROM Student GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Major FROM Student GROUP BY Major ORDER BY COUNT(*) DESC LIMIT 1;", "hint": "\n"}
{"sample_id": "train.502", "db_id": "allergy_1", "question": "Give the advisor with the most students.", "rationale": ["Identify the relevant table: The 'Student' table contains the 'Advisor' and 'StuID' columns.", "Count the number of students for each advisor: Use COUNT(StuID) to count the number of students associated with each advisor.", "Group the results by advisor: Use GROUP BY Advisor to aggregate the counts for each advisor.", "Order the results: Use ORDER BY StudentCount DESC to sort the advisors by the number of students in descending order.", "Limit the results to the top advisor: Use LIMIT 1 to get only the advisor with the most students."], "gold_sql": "SELECT advisor FROM Student GROUP BY advisor ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Advisor, COUNT(StuID) AS StudentCount\nFROM Student\nGROUP BY Advisor\nORDER BY StudentCount DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.503", "db_id": "allergy_1", "question": "How many students have cat allergies?", "rationale": ["The question asks for the number of students with cat allergies.", "We need to count the number of students who have a specific allergy, which is 'cat'.", "To do this, we will join the 'Has_Allergy' table with the 'Allergy_Type' table on the Allergy column.", "We will then filter the results to only include those records where the AllergyType is 'cat'.", "Finally, we will use the COUNT function to get the total number of students with cat allergies."], "gold_sql": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  'Cat'", "source_tables": ["has_allergy"], "pred_sql": "SELECT count(*) FROM Has_Allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.AllergyType = 'cat'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies students from the 'Student' table who do not have any allergies recorded in the 'Has_Allergy' table. The query uses the EXCEPT clause to exclude students with allergies from the list of all students.\",\n        \"virtual_table\": \"SELECT StuID FROM Student EXCEPT SELECT StuID FROM Has_allergy\"\n    }\n}\n"}
{"sample_id": "train.504", "db_id": "allergy_1", "question": "How many students are affected by cat allergies?", "rationale": ["Identify the tables involved: Has_Allergy and Allergy_Type.", "Determine the relationship: Has_Allergy links students to their allergies, and Allergy_Type categorizes those allergies.", "We need to count the number of students affected by cat allergies, which means we need to filter the results based on the allergy type 'cat'.", "Use a JOIN to combine the two tables on the Allergy column.", "Use the COUNT function to count the number of records that match the criteria.", "Construct the SQL query using the identified elements."], "gold_sql": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  'Cat'", "source_tables": ["has_allergy"], "pred_sql": "SELECT count(*) FROM Has_Allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.AllergyType = 'cat'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of distinct allergy types from the 'Allergy_Type' table. The result will indicate how many unique categories of allergies are present in the database.\",\n        \"virtual_table\": \"SELECT count(DISTINCT allergytype) FROM Allergy_type\"\n    }\n}\n"}
{"sample_id": "train.510", "db_id": "allergy_1", "question": "How many students who are female are allergic to milk or eggs?", "rationale": ["Identify the tables needed: We need to access the Student table to filter by gender, the Has_Allergy table to link students to their allergies, and the Allergy_Type table to specify the allergies (milk and eggs).", "Join the tables: We will join the Student table with the Has_Allergy table on StuID, and then join the result with the Allergy_Type table on the Allergy column.", "Filter by gender: We need to filter the results to include only female students, which is done by adding a WHERE clause for S.Sex = 'Female'.", "Filter by allergies: We also need to filter the allergies to include only those that are either 'Milk' or 'Eggs'. This is done using an OR condition in the WHERE clause.", "Count distinct students: Since we want the number of unique female students with these allergies, we will use COUNT(DISTINCT S.StuID) to ensure we do not double count any students."], "gold_sql": "SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  'F' AND T1.allergy  =  'Milk' OR T1.allergy  =  'Eggs'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT COUNT(DISTINCT S.StuID) \nFROM Student AS S \nJOIN Has_Allergy AS HA ON S.StuID = HA.StuID \nJOIN Allergy_Type AS AT ON HA.Allergy = AT.Allergy \nWHERE S.Sex = 'Female' AND (AT.Allergy = 'Milk' OR AT.Allergy = 'Eggs');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies students from the 'Student' table who do not have any allergies recorded in the 'Has_Allergy' table. The query uses the EXCEPT clause to exclude students with allergies from the list of all students.\",\n        \"virtual_table\": \"SELECT StuID FROM Student EXCEPT SELECT StuID FROM Has_allergy\"\n    }\n}\n"}
{"sample_id": "train.514", "db_id": "allergy_1", "question": "Which allergy is the most common?", "rationale": ["To find the most common allergy, we need to count how many students have each allergy.", "We will join the 'Has_Allergy' table with the 'Allergy_Type' table to get the names of the allergies along with their counts.", "We will use the COUNT function to count the number of occurrences of each allergy.", "We will group the results by the allergy name to get the count for each allergy.", "To find the most common allergy, we will order the results by the count in descending order.", "Finally, we will limit the results to 1 to get only the most common allergy."], "gold_sql": "SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT 1", "source_tables": ["has_allergy"], "pred_sql": "SELECT T2.Allergy, COUNT(*) as AllergyCount \nFROM Has_Allergy AS T1 \nJOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy \nGROUP BY T2.Allergy \nORDER BY AllergyCount DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of distinct allergy types from the 'Allergy_Type' table. The result will indicate how many unique categories of allergies are present in the database.\",\n        \"virtual_table\": \"SELECT count(DISTINCT allergytype) FROM Allergy_type\"\n    }\n}\n"}
{"sample_id": "train.519", "db_id": "allergy_1", "question": "Find the last name and age of the student who has allergy to both milk and cat.", "rationale": ["Identify the tables needed: We need to get student information (last name and age) from the Student table and the allergies from the Has_Allergy table.", "We need to find students who have both 'milk' and 'cat' allergies. This requires joining the Has_Allergy table twice: once for each allergy.", "Join the Student table with the Has_Allergy table twice, once for each allergy, using the student ID (StuID) as the key.", "In the WHERE clause, specify the conditions that the first instance of Has_Allergy must have 'milk' and the second instance must have 'cat'.", "Select the last name (LName) and age (Age) of the students who meet these criteria."], "gold_sql": "SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT S.LName, S.Age \nFROM Student S \nJOIN Has_Allergy HA1 ON S.StuID = HA1.StuID \nJOIN Has_Allergy HA2 ON S.StuID = HA2.StuID \nWHERE HA1.Allergy = 'milk' AND HA2.Allergy = 'cat';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies students from the 'Student' table who do not have any allergies recorded in the 'Has_Allergy' table. The query uses the EXCEPT clause to exclude students with allergies from the list of all students.\",\n        \"virtual_table\": \"SELECT StuID FROM Student EXCEPT SELECT StuID FROM Has_allergy\"\n    }\n}\n"}
{"sample_id": "train.520", "db_id": "allergy_1", "question": "What are the last names and ages of the students who are allergic to milk and cat?", "rationale": ["Identify the tables needed: We need to retrieve student information (last names and ages) from the 'Student' table and their allergies from the 'Has_Allergy' table.", "Determine the relationship: The 'Has_Allergy' table links students to their allergies using the 'StuID' column.", "Specify the allergies of interest: We are looking for students who are allergic to both 'milk' and 'cat'.", "Join the 'Student' table with the 'Has_Allergy' table on 'StuID' to get the relevant student data along with their allergies.", "Use a WHERE clause to filter the results to only include students with allergies to 'milk' and 'cat'.", "Group the results by 'StuID' to ensure we can count the distinct allergies for each student.", "Use HAVING to ensure that we only select students who have both allergies (count of distinct allergies should be 2)."], "gold_sql": "SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT S.LName, S.Age \nFROM Student S \nJOIN Has_Allergy HA ON S.StuID = HA.StuID \nWHERE HA.Allergy IN ('milk', 'cat') \nGROUP BY S.StuID \nHAVING COUNT(DISTINCT HA.Allergy) = 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies students from the 'Student' table who do not have any allergies recorded in the 'Has_Allergy' table. The query uses the EXCEPT clause to exclude students with allergies from the list of all students.\",\n        \"virtual_table\": \"SELECT StuID FROM Student EXCEPT SELECT StuID FROM Has_allergy\"\n    }\n}\n"}
{"sample_id": "train.523", "db_id": "allergy_1", "question": "Find the first name and gender of the student who has allergy to milk but not cat.", "rationale": ["Identify the columns needed: first name (Fname) and gender (Sex) of the student.", "We need to filter students based on their allergies: specifically, those who have an allergy to milk and do not have an allergy to cat.", "To find students with an allergy to milk, we can use a subquery that selects StuID from the Has_Allergy table where Allergy is 'milk'.", "To find students without an allergy to cat, we can use another subquery that selects StuID from the Has_Allergy table where Allergy is 'cat'.", "We can combine these conditions using the IN and NOT IN clauses in the WHERE statement of the main query, which selects from the Student table."], "gold_sql": "SELECT fname ,  sex FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' EXCEPT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT Fname, Sex FROM Student WHERE StuID IN (SELECT StuID FROM Has_Allergy WHERE Allergy = 'milk') AND StuID NOT IN (SELECT StuID FROM Has_Allergy WHERE Allergy = 'cat')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies students from the 'Student' table who do not have any allergies recorded in the 'Has_Allergy' table. The query uses the EXCEPT clause to exclude students with allergies from the list of all students.\",\n        \"virtual_table\": \"SELECT StuID FROM Student EXCEPT SELECT StuID FROM Has_allergy\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.524", "db_id": "allergy_1", "question": "What are the first name and gender of the students who have allergy to milk but can put up with cats?", "rationale": ["Identify the information needed: first name and gender of students with specific allergies.", "Determine the allergies of interest: students who have an allergy to 'milk' and do not have an allergy to 'cats'.", "Use a subquery to find students with an allergy to 'milk' by selecting their StuID from the Has_Allergy table.", "Use another subquery to find students with an allergy to 'cats' to exclude them from the results.", "Combine the results using the IN and NOT IN clauses to filter the students accordingly.", "Select the first name (Fname) and gender (Sex) from the Student table where the StuID matches the criteria from the subqueries."], "gold_sql": "SELECT fname ,  sex FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' EXCEPT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT Fname, Sex FROM Student WHERE StuID IN (SELECT StuID FROM Has_Allergy WHERE Allergy = 'milk') AND StuID NOT IN (SELECT StuID FROM Has_Allergy WHERE Allergy = 'cats')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies students from the 'Student' table who do not have any allergies recorded in the 'Has_Allergy' table. The query uses the EXCEPT clause to exclude students with allergies from the list of all students.\",\n        \"virtual_table\": \"SELECT StuID FROM Student EXCEPT SELECT StuID FROM Has_allergy\"\n    }\n}\n"}
{"sample_id": "train.525", "db_id": "allergy_1", "question": "Find the average age of the students who have allergies with food and animal types.", "rationale": ["Identify the tables needed: We need to get student ages from the 'Student' table and filter based on allergies from the 'Has_Allergy' and 'Allergy_Type' tables.", "Join the 'Student' table with the 'Has_Allergy' table on 'StuID' to link students with their allergies.", "Join the result with the 'Allergy_Type' table on 'Allergy' to categorize the allergies.", "Filter the results to include only those students who have allergies of type 'food' or 'animal'.", "Calculate the average age of the filtered students using the AVG() function, ensuring to cast the 'Age' column to an integer for accurate calculation."], "gold_sql": "SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food' INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'animal')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT AVG(CAST(Age AS INTEGER)) FROM Student AS S JOIN Has_Allergy AS HA ON S.StuID = HA.StuID JOIN Allergy_Type AS AT ON HA.Allergy = AT.Allergy WHERE AT.AllergyType IN ('food', 'animal')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of distinct allergy types from the 'Allergy_Type' table. The result will indicate how many unique categories of allergies are present in the database.\",\n        \"virtual_table\": \"SELECT count(DISTINCT allergytype) FROM Allergy_type\"\n    }\n}\n"}
{"sample_id": "train.528", "db_id": "allergy_1", "question": "What is the full name of each student who is not allergic to any type of food.", "rationale": ["Identify the main goal: to find the full names of students who are not allergic to any type of food.", "Understand that we need to select the first name (Fname) and last name (LName) from the Student table.", "To find students without allergies, we can use a subquery that selects StuID from the Has_Allergy table.", "The subquery will be used in a NOT IN clause to filter out students who have allergies from the main query.", "The final SQL query combines these elements to retrieve the desired information."], "gold_sql": "SELECT fname ,  lname FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT Fname, LName FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_Allergy)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies students from the 'Student' table who do not have any allergies recorded in the 'Has_Allergy' table. The query uses the EXCEPT clause to exclude students with allergies from the list of all students.\",\n        \"virtual_table\": \"SELECT StuID FROM Student EXCEPT SELECT StuID FROM Has_allergy\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.530", "db_id": "allergy_1", "question": "How many male students (sex is 'M') are allergic to any type of food?", "rationale": ["We need to count the number of male students who are allergic to any type of food.", "To do this, we will join the 'Has_Allergy' table with the 'Allergy_Type' table to filter allergies by type.", "We also need to join the 'Student' table to filter by gender (male).", "The WHERE clause will specify that the allergy type is 'Food' and the student's sex is 'M'.", "Finally, we will use the COUNT function to get the total number of male students with food allergies."], "gold_sql": "SELECT count(*) FROM Student WHERE sex  =  'M' AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT count(*) FROM Has_Allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy JOIN Student AS S ON T1.StuID = S.StuID WHERE T2.AllergyType = 'Food' AND S.Sex = 'M'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies students from the 'Student' table who do not have any allergies recorded in the 'Has_Allergy' table. The query uses the EXCEPT clause to exclude students with allergies from the list of all students.\",\n        \"virtual_table\": \"SELECT StuID FROM Student EXCEPT SELECT StuID FROM Has_allergy\"\n    }\n}\n"}
{"sample_id": "train.531", "db_id": "allergy_1", "question": "Find the different first names and cities of the students who have allergy to milk or cat.", "rationale": ["Identify the tables involved: We need to get student information from the 'Student' table and allergy information from the 'Has_Allergy' table.", "We need to find students who have allergies to either 'milk' or 'cat'.", "To do this, we will join the 'Student' table with the 'Has_Allergy' table on the 'StuID' column.", "We will select distinct first names and city codes of students who have the specified allergies.", "The final SQL query will include a WHERE clause to filter for allergies 'milk' and 'cat'."], "gold_sql": "SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  'Milk' OR T2.Allergy  =  'Cat'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT DISTINCT S.Fname, S.city_code \nFROM Student S \nJOIN Has_Allergy HA ON S.StuID = HA.StuID \nWHERE HA.Allergy IN ('milk', 'cat');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies students from the 'Student' table who do not have any allergies recorded in the 'Has_Allergy' table. The query uses the EXCEPT clause to exclude students with allergies from the list of all students.\",\n        \"virtual_table\": \"SELECT StuID FROM Student EXCEPT SELECT StuID FROM Has_allergy\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.532", "db_id": "allergy_1", "question": "What are the distinct first names and cities of the students who have allergy either to milk or to cat?", "rationale": ["Identify the tables needed: We need data from the 'Student' table for first names and city codes, and the 'Has_Allergy' table to filter students based on their allergies.", "We need to join the 'Student' table with the 'Has_Allergy' table on the 'StuID' column to link students with their allergies.", "We want to filter the results to include only those students who have allergies to either 'milk' or 'cat'.", "We will use the DISTINCT keyword to ensure that we only get unique combinations of first names and city codes in the result set."], "gold_sql": "SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  'Milk' OR T2.Allergy  =  'Cat'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT DISTINCT S.Fname, S.city_code \nFROM Student S \nJOIN Has_Allergy HA ON S.StuID = HA.StuID \nWHERE HA.Allergy IN ('milk', 'cat');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies students from the 'Student' table who do not have any allergies recorded in the 'Has_Allergy' table. The query uses the EXCEPT clause to exclude students with allergies from the list of all students.\",\n        \"virtual_table\": \"SELECT StuID FROM Student EXCEPT SELECT StuID FROM Has_allergy\"\n    }\n}\n"}
{"sample_id": "train.542", "db_id": "store_1", "question": "What are the names of the countries and average invoice size of the top countries by size?", "rationale": ["Identify the relevant table: The invoices table contains the billing country and total amount of each invoice.", "Select the columns needed: We need the billing_country and the average of the total column.", "Use the AVG() function to calculate the average invoice size for each country.", "Group the results by billing_country to get the average for each country.", "Order the results by average_invoice_size in descending order to get the top countries by size.", "Limit the results to the top 10 countries."], "gold_sql": "SELECT billing_country ,  AVG(total) FROM invoices GROUP BY billing_country ORDER BY AVG(total) DESC LIMIT 10;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_country, AVG(total) AS average_invoice_size\nFROM invoices\nGROUP BY billing_country\nORDER BY average_invoice_size DESC\nLIMIT 10;", "hint": "\n"}
{"sample_id": "train.564", "db_id": "store_1", "question": "How many invoices were billed from each state?", "rationale": ["Identify the relevant table: The invoices table contains the billing information including the state.", "Determine the required information: We need to count the number of invoices for each state.", "Use the COUNT() function to count invoices and GROUP BY to group the results by billing_state.", "Construct the SQL query to select the billing_state and the count of invoices, grouping by billing_state."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_state, COUNT(*) AS invoice_count\nFROM invoices\nGROUP BY billing_state;", "hint": "\n"}
{"sample_id": "train.566", "db_id": "store_1", "question": "What are the states with the most invoices?", "rationale": ["Identify the relevant table: The 'invoices' table contains the billing information including the state.", "Determine the required information: We need to count the number of invoices per state.", "Use the COUNT() function to count invoices grouped by 'billing_state'.", "Group the results by 'billing_state' to aggregate the counts for each state.", "Order the results in descending order to find the states with the most invoices."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT 1;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_state, COUNT(*) AS invoice_count\nFROM invoices\nGROUP BY billing_state\nORDER BY invoice_count DESC;", "hint": "\n"}
{"sample_id": "train.568", "db_id": "store_1", "question": "What is the number of invoices and total money billed in them from CA?", "rationale": ["Identify the relevant tables: invoices and customers.", "We need to count the number of invoices and sum the total billed amount.", "Join the invoices table with the customers table on the customer_id to access customer information.", "Filter the results to include only those customers who are located in California (CA).", "Select the count of invoices and the sum of the total amount billed."], "gold_sql": "SELECT billing_state ,  COUNT(*) ,  SUM(total) FROM invoices WHERE billing_state  =  'CA';", "source_tables": ["invoices"], "pred_sql": "SELECT COUNT(*) AS number_of_invoices, SUM(total) AS total_billed\nFROM invoices\nJOIN customers ON invoices.customer_id = customers.id\nWHERE customers.state = 'CA';", "hint": "\n"}
{"sample_id": "train.575", "db_id": "store_1", "question": "What is Astrid Gruber's email and phone number?", "rationale": ["Identify the table that contains the information needed: the 'employees' table has the email and phone number.", "Determine the specific columns to select: 'email' and 'phone'.", "Filter the results to find the specific employee by their first and last name: 'Astrid Gruber'.", "Construct the SQL query using the SELECT statement with the appropriate WHERE clause."], "gold_sql": "SELECT email ,  phone FROM customers WHERE first_name = 'Astrid' AND last_name = 'Gruber';", "source_tables": ["customers"], "pred_sql": "SELECT email, phone FROM employees WHERE first_name = 'Astrid' AND last_name = 'Gruber';", "hint": "\n"}
{"sample_id": "train.580", "db_id": "store_1", "question": "How many customers are from California?", "rationale": ["Identify the relevant table: The question asks about customers, so we will use the 'customers' table.", "Determine the required information: We need to count the number of customers from California.", "Formulate the SQL query: We will use the COUNT() function to count the number of rows where the state is 'California'.", "Construct the SELECT statement: We will select the count from the customers table with the appropriate WHERE clause."], "gold_sql": "SELECT count(*) FROM customers WHERE state = 'CA';", "source_tables": ["customers"], "pred_sql": "SELECT COUNT(*) AS customer_count FROM customers WHERE state = 'California';", "hint": "\n"}
{"sample_id": "train.593", "db_id": "store_1", "question": "Find the full name of employee who supported the most number of customers.", "rationale": ["Identify the relevant tables: employees and customers.", "We need to find the employee who has supported the most customers, which means we need to join the employees table with the customers table on the support_rep_id.", "Use GROUP BY to group the results by employee ID to count the number of customers each employee supports.", "Use COUNT to count the number of customers for each employee.", "Order the results in descending order based on the count of customers supported.", "Limit the results to 1 to get the employee with the highest count."], "gold_sql": "SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employees", "customers"], "pred_sql": "SELECT e.first_name || ' ' || e.last_name AS full_name\nFROM employees e\nJOIN customers c ON e.id = c.support_rep_id\nGROUP BY e.id\nORDER BY COUNT(c.id) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.608", "db_id": "store_1", "question": "How many orders does Luca Mancini have in his invoices?", "rationale": ["Identify the relevant tables: invoices and customers.", "We need to count the number of invoices associated with a specific customer, Luca Mancini.", "Join the invoices table with the customers table on the customer_id field.", "Filter the results to only include invoices for the customer with first name 'Luca' and last name 'Mancini'.", "Use the COUNT() function to count the number of invoices that match the criteria."], "gold_sql": "SELECT count(*) FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id WHERE T1.first_name = 'Lucas' AND T1.last_name = 'Mancini';", "source_tables": ["customers", "invoices"], "pred_sql": "SELECT COUNT(*) AS order_count \nFROM invoices \nJOIN customers ON invoices.customer_id = customers.id \nWHERE customers.first_name = 'Luca' AND customers.last_name = 'Mancini';", "hint": "\n"}
{"sample_id": "train.623", "db_id": "store_1", "question": "What is title of album which track Balls to the Wall belongs to?", "rationale": ["Identify the relevant tables: We need to find the album title from the 'albums' table and the track name from the 'tracks' table.", "Determine the relationship: The 'tracks' table has a foreign key 'album_id' that links to the 'albums' table's 'id'.", "Use a JOIN operation: We will join the 'albums' table with the 'tracks' table on the condition that 'albums.id' matches 'tracks.album_id'.", "Filter by track name: We need to filter the results to only include the track named 'Balls to the Wall'.", "Construct the SQL query: Based on the above steps, the SQL query is constructed to select the album title where the track name matches 'Balls to the Wall'."], "gold_sql": "SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T2.name = 'Balls to the Wall';", "source_tables": ["albums", "tracks"], "pred_sql": "SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.album_id WHERE T2.name = 'Balls to the Wall';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of tracks from the 'tracks' table that belong to a specific album title in the 'albums' table. The placeholder in the WHERE clause represents the title of the album.\",\n        \"virtual_table\": \"SELECT T2.name FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T1.title = [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the titles of albums from the 'albums' table that contain tracks of a specific name. The placeholder in the WHERE clause represents the name of the track.\",\n        \"virtual_table\": \"SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T2.name = [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the titles of all albums from the 'albums' table, sorted in alphabetical order. The query retrieves the 'title' column and orders the results by the album title.\",\n        \"virtual_table\": \"SELECT title FROM albums ORDER BY title;\"\n    }\n}\n"}
{"sample_id": "train.626", "db_id": "store_1", "question": "What is the name of all tracks in the album named Balls to the Wall?", "rationale": ["Identify the relevant tables: 'albums' for album titles and 'tracks' for track names.", "Join the 'albums' table with the 'tracks' table using the foreign key relationship (albums.id = tracks.album_id).", "Filter the results to only include tracks from the album titled 'Balls to the Wall'.", "Select the track names from the joined tables."], "gold_sql": "SELECT T2.name FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T1.title = 'Balls to the Wall';", "source_tables": ["albums", "tracks"], "pred_sql": "SELECT T2.name FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.album_id WHERE T1.title = 'Balls to the Wall';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of tracks from the 'tracks' table that belong to a specific album title in the 'albums' table. The placeholder in the WHERE clause represents the title of the album.\",\n        \"virtual_table\": \"SELECT T2.name FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T1.title = [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the titles of albums from the 'albums' table that contain tracks of a specific name. The placeholder in the WHERE clause represents the name of the track.\",\n        \"virtual_table\": \"SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T2.name = [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the titles of all albums from the 'albums' table, sorted in alphabetical order. The query retrieves the 'title' column and orders the results by the album title.\",\n        \"virtual_table\": \"SELECT title FROM albums ORDER BY title;\"\n    }\n}\n"}
{"sample_id": "train.630", "db_id": "store_1", "question": "What are the names of all Rock tracks that are stored on MPEG audio files?", "rationale": ["Identify the relevant tables: We need to find track names, which are in the 'tracks' table, and we need to filter by genre and media type.", "Join the 'tracks' table with the 'genres' table to filter for Rock tracks. The 'genre_id' in the 'tracks' table corresponds to the 'id' in the 'genres' table.", "Join the 'tracks' table with the 'media_types' table to filter for MPEG audio files. The 'media_type_id' in the 'tracks' table corresponds to the 'id' in the 'media_types' table.", "Construct the SQL query to select the names of tracks where the genre is 'Rock' and the media type is 'MPEG audio'."], "gold_sql": "SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = 'Rock' AND T3.name = 'MPEG audio file';", "source_tables": ["tracks", "genres", "media_types"], "pred_sql": "SELECT T2.name \nFROM tracks AS T2 \nJOIN media_types AS T3 ON T2.media_type_id = T3.id \nJOIN genres AS T1 ON T2.genre_id = T1.id \nWHERE T1.name = 'Rock' AND T3.name = 'MPEG audio';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of tracks from the 'tracks' table that belong to a specific album title in the 'albums' table. The placeholder in the WHERE clause represents the title of the album.\",\n        \"virtual_table\": \"SELECT T2.name FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T1.title = [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the titles of albums from the 'albums' table that contain tracks of a specific name. The placeholder in the WHERE clause represents the name of the track.\",\n        \"virtual_table\": \"SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T2.name = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.632", "db_id": "store_1", "question": "What are the names of all tracks that belong to the Rock genre and whose media type is MPEG?", "rationale": ["Identify the relevant tables: tracks, media_types, and genres.", "We need to join these tables to access the track names, media types, and genre names.", "The tracks table contains the track names and has foreign keys to both media_types and genres.", "Join the tracks table (T1) with media_types (T2) on media_type_id and with genres (T3) on genre_id.", "Filter the results where the genre name is 'Rock' and the media type name is 'MPEG'.", "Select the name of the tracks that meet these criteria."], "gold_sql": "SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = 'Rock' OR T3.name = 'MPEG audio file';", "source_tables": ["tracks", "genres", "media_types"], "pred_sql": "SELECT T1.name \nFROM tracks AS T1 \nJOIN media_types AS T2 ON T1.media_type_id = T2.id \nJOIN genres AS T3 ON T1.genre_id = T3.id \nWHERE T3.name = 'Rock' AND T2.name = 'MPEG';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of different media types from the 'media_types' table. The query retrieves all media type names without any filtering conditions.\",\n        \"virtual_table\": \"SELECT name FROM media_types;\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of tracks from the 'tracks' table that belong to a specific album title in the 'albums' table. The placeholder in the WHERE clause represents the title of the album.\",\n        \"virtual_table\": \"SELECT T2.name FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T1.title = [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the titles of albums from the 'albums' table that contain tracks of a specific name. The placeholder in the WHERE clause represents the name of the track.\",\n        \"virtual_table\": \"SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T2.name = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.640", "db_id": "store_1", "question": "What are the tracks that Dean Peeters bought?", "rationale": ["Identify the customer by the name 'Dean Peeters'.", "Join the 'customers' table with the 'invoices' table to find invoices associated with Dean Peeters.", "Join the 'invoices' table with the 'invoice_lines' table to find the specific tracks purchased in those invoices.", "Join the 'invoice_lines' table with the 'tracks' table to get the names of the tracks that were purchased.", "Filter the results to only include tracks purchased by Dean Peeters."], "gold_sql": "SELECT T1.name FROM tracks AS T1 JOIN invoice_lines AS T2 ON T1.id = T2.track_id JOIN invoices AS T3 ON T3.id = T2.invoice_id JOIN customers AS T4 ON T4.id = T3.customer_id WHERE T4.first_name = 'Daan' AND T4.last_name = 'Peeters';", "source_tables": ["tracks", "invoice_lines", "customers", "invoices"], "pred_sql": "SELECT T3.name FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id JOIN invoice_lines AS T4 ON T2.id = T4.invoice_id JOIN tracks AS T3 ON T4.track_id = T3.id WHERE T1.first_name = 'Dean' AND T1.last_name = 'Peeters';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of tracks from the 'tracks' table that belong to a specific album title in the 'albums' table. The placeholder in the WHERE clause represents the title of the album.\",\n        \"virtual_table\": \"SELECT T2.name FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T1.title = [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the titles of albums from the 'albums' table that contain tracks of a specific name. The placeholder in the WHERE clause represents the name of the track.\",\n        \"virtual_table\": \"SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T2.name = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.686", "db_id": "customers_card_transactions", "question": "What are the full names of customers who do not have any accounts?", "rationale": ["Identify the information needed: full names of customers without accounts.", "To get the full names, we need to concatenate the first and last names from the Customers table.", "We need to filter customers who do not have any accounts, which requires checking the Accounts table.", "Use a subquery to find customer_ids that exist in the Accounts table and exclude them from the main query.", "The final SQL query selects the concatenated full names of customers whose customer_id is not in the list of customer_ids from the Accounts table."], "gold_sql": "SELECT customer_first_name ,  customer_last_name FROM Customers EXCEPT SELECT T1.customer_first_name ,  T1.customer_last_name FROM Customers AS T1 JOIN Accounts AS T2 ON T1.customer_id  =  T2.customer_id", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT customer_first_name || ' ' || customer_last_name AS full_name\nFROM Customers\nWHERE customer_id NOT IN (\n    SELECT customer_id\n    FROM Accounts\n);", "hint": "\n"}
{"sample_id": "train.688", "db_id": "customers_card_transactions", "question": "What are the full names of customers who have accounts?", "rationale": ["Identify the tables involved: Customers and Accounts.", "Determine the relationship: Customers have a one-to-many relationship with Accounts (one customer can have multiple accounts).", "Select the required fields: We need the full names of customers, which can be constructed by concatenating the first and last names.", "Use a JOIN clause to combine the Customers and Accounts tables based on the customer_id field, which is common to both tables.", "Construct the SQL query to select the concatenated full name from the Customers table where there is a corresponding account in the Accounts table."], "gold_sql": "SELECT DISTINCT T1.customer_first_name ,  T1.customer_last_name FROM Customers AS T1 JOIN Accounts AS T2 ON T1.customer_id  =  T2.customer_id", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT Customers.customer_first_name || ' ' || Customers.customer_last_name AS full_name\nFROM Customers\nJOIN Accounts ON Customers.customer_id = Accounts.customer_id;", "hint": "\n"}
{"sample_id": "train.704", "db_id": "customers_card_transactions", "question": "Return the full name and phone of the customer who has card number 4560596484842.", "rationale": ["Identify the required information: full name and phone number of the customer.", "The full name can be constructed by concatenating the first name and last name of the customer.", "The phone number is directly available in the Customers table.", "To find the customer associated with a specific card number, we need to join the Customers table with the Customers_Cards table on the customer_id.", "The WHERE clause will filter the results to only include the customer with the specified card number."], "gold_sql": "SELECT T2.customer_first_name ,  T2.customer_last_name ,  T2.customer_phone FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T1.card_number  =  '4560596484842'", "source_tables": ["customers", "customers_cards"], "pred_sql": "SELECT Customers.customer_first_name || ' ' || Customers.customer_last_name AS full_name, Customers.customer_phone \nFROM Customers \nJOIN Customers_Cards ON Customers.customer_id = Customers_Cards.customer_id \nWHERE Customers_Cards.card_number = '4560596484842';", "hint": "\n"}
{"sample_id": "train.717", "db_id": "customers_card_transactions", "question": "What is the customer id, first and last name with least number of accounts.", "rationale": ["Identify the relevant tables: Customers and Accounts.", "We need to find the customer with the least number of accounts, so we will join the Customers table with the Accounts table on the customer_id.", "Group the results by customer_id, customer_first_name, and customer_last_name to count the number of accounts per customer.", "Use COUNT(a.account_id) to count the number of accounts for each customer.", "Order the results by the count of accounts in ascending order to get the customer with the least number of accounts at the top.", "Limit the results to 1 to get only the customer with the least number of accounts."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) ASC LIMIT 1", "source_tables": ["customers", "customers_cards"], "pred_sql": "SELECT c.customer_id, c.customer_first_name, c.customer_last_name\nFROM Customers c\nJOIN Accounts a ON c.customer_id = a.customer_id\nGROUP BY c.customer_id, c.customer_first_name, c.customer_last_name\nORDER BY COUNT(a.account_id) ASC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.718", "db_id": "customers_card_transactions", "question": "Return the id and full name of the customer who has the fewest accounts.", "rationale": ["Identify the relevant tables: Customers and Accounts.", "We need to join these tables on the customer_id to link customers with their accounts.", "Group the results by customer_id to count the number of accounts each customer has.", "Order the results by the count of accounts in ascending order to find the customer with the fewest accounts.", "Limit the results to 1 to get only the customer with the fewest accounts.", "Select the customer_id and concatenate the first and last name to get the full name."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) ASC LIMIT 1", "source_tables": ["customers", "customers_cards"], "pred_sql": "SELECT c.customer_id, c.customer_first_name || ' ' || c.customer_last_name AS full_name\nFROM Customers c\nJOIN Accounts a ON c.customer_id = a.customer_id\nGROUP BY c.customer_id\nORDER BY COUNT(a.account_id) ASC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.721", "db_id": "customers_card_transactions", "question": "What is the card type code with most number of cards?", "rationale": ["We need to find the card type code with the most number of cards.", "First, we will group the records in the Customers_Cards table by card_type_code to aggregate the counts of each type.", "Next, we will count the number of card_id entries for each card_type_code using COUNT(card_id).", "To find the card type code with the highest count, we will order the results in descending order based on the count.", "Finally, we will limit the results to just one entry to get the card type code with the most cards."], "gold_sql": "SELECT card_type_code FROM Customers_cards GROUP BY card_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers_cards"], "pred_sql": "SELECT card_type_code FROM Customers_Cards GROUP BY card_type_code ORDER BY COUNT(card_id) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique card type codes from the 'Customers_Cards' table. The placeholder in the SELECT statement allows for the retrieval of distinct card types without any filtering conditions.\",\n        \"virtual_table\": \"SELECT DISTINCT card_type_code FROM Customers_Cards\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of customer cards from the 'Customers_Cards' table that match a specific card type. The placeholder in the WHERE clause represents the card type code being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Customers_cards WHERE card_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.735", "db_id": "customers_card_transactions", "question": "Show the number of transaction types.", "rationale": ["The user wants to know the number of transaction types.", "To achieve this, we need to count the occurrences of each transaction type in the Financial_Transactions table.", "We will use the COUNT() function to count the number of transactions for each type.", "We will group the results by transaction_type to get the count for each distinct type."], "gold_sql": "SELECT count(DISTINCT transaction_type) FROM Financial_Transactions", "source_tables": ["financial_transactions"], "pred_sql": "SELECT transaction_type, COUNT(*) as transaction_count FROM Financial_Transactions GROUP BY transaction_type;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of customer cards from the 'Customers_Cards' table that match a specific card type. The placeholder in the WHERE clause represents the card type code being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Customers_cards WHERE card_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.743", "db_id": "customers_card_transactions", "question": "What is the transaction type that has processed the greatest total amount in transactions?", "rationale": ["Identify the relevant table: Financial_Transactions contains the transaction details including transaction type and amount.", "We need to group the results by transaction type to calculate the total amount for each type.", "Use the SUM function to calculate the total amount for each transaction type.", "Order the results in descending order based on the total amount to find the highest one.", "Limit the results to 1 to get only the transaction type with the greatest total amount."], "gold_sql": "SELECT transaction_type FROM Financial_transactions GROUP BY transaction_type ORDER BY sum(transaction_amount) DESC LIMIT 1", "source_tables": ["financial_transactions"], "pred_sql": "SELECT transaction_type, SUM(transaction_amount) AS total_amount\nFROM Financial_Transactions\nGROUP BY transaction_type\nORDER BY total_amount DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.893", "db_id": "insurance_fnol", "question": "What are the customer phone numbers under the policy \"Life Insurance\"?", "rationale": ["Identify the relevant table: Available_Policies contains the customer phone numbers and policy types.", "Determine the specific policy type we are interested in: 'Life Insurance'.", "Construct the SQL query to select the Customer_Phone from Available_Policies where the policy_type_code matches 'Life Insurance'."], "gold_sql": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  'Life Insurance'", "source_tables": ["available_policies"], "pred_sql": "SELECT Customer_Phone FROM Available_Policies WHERE policy_type_code = 'Life Insurance'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the contact phone numbers of customers from the 'Available_Policies' table who have a specific type of insurance policy. The placeholder in the WHERE clause represents the policy type code.\",\n        \"virtual_table\": \"SELECT customer_phone FROM available_policies WHERE policy_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.895", "db_id": "insurance_fnol", "question": "Which policy type has the most records in the database?", "rationale": ["To find out which policy type has the most records, we need to count the number of records for each policy type in the Available_Policies table.", "We will use the COUNT() function to count the records and GROUP BY policy_type_code to group the results by each policy type.", "To get the policy type with the highest count, we will order the results in descending order using ORDER BY record_count DESC.", "Finally, we will limit the results to just one record using LIMIT 1 to get the policy type with the most records."], "gold_sql": "SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["available_policies"], "pred_sql": "SELECT policy_type_code, COUNT(*) as record_count \nFROM Available_Policies \nGROUP BY policy_type_code \nORDER BY record_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the contact phone numbers of customers from the 'Available_Policies' table who have a specific type of insurance policy. The placeholder in the WHERE clause represents the policy type code.\",\n        \"virtual_table\": \"SELECT customer_phone FROM available_policies WHERE policy_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.897", "db_id": "insurance_fnol", "question": "What are all the customer phone numbers under the most popular policy type?", "rationale": ["Identify the need to find customer phone numbers associated with the most popular policy type.", "Determine that the most popular policy type can be found by grouping the policies and counting their occurrences.", "Use a subquery to select the policy type code that has the highest count of occurrences in the Available_Policies table.", "Incorporate this subquery into the main query to filter customer phone numbers from the Available_Policies table based on the most popular policy type."], "gold_sql": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  (SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["available_policies"], "pred_sql": "SELECT Customer_Phone FROM Available_Policies WHERE policy_type_code = (SELECT policy_type_code FROM Available_Policies GROUP BY policy_type_code ORDER BY COUNT(*) DESC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the contact phone numbers of customers from the 'Available_Policies' table who have a specific type of insurance policy. The placeholder in the WHERE clause represents the policy type code.\",\n        \"virtual_table\": \"SELECT customer_phone FROM available_policies WHERE policy_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.898", "db_id": "insurance_fnol", "question": "Find the phone numbers of customers using the most common policy type among the available policies.", "rationale": ["Identify the most common policy type among the available policies by grouping the policies and counting their occurrences.", "Use a subquery to find the policy type code that has the highest count.", "Select the customer phone numbers from the Available_Policies table where the policy type code matches the most common one."], "gold_sql": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  (SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["available_policies"], "pred_sql": "SELECT Customer_Phone FROM Available_Policies WHERE policy_type_code = (SELECT policy_type_code FROM Available_Policies GROUP BY policy_type_code ORDER BY COUNT(*) DESC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the contact phone numbers of customers from the 'Available_Policies' table who have a specific type of insurance policy. The placeholder in the WHERE clause represents the policy type code.\",\n        \"virtual_table\": \"SELECT customer_phone FROM available_policies WHERE policy_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.1060", "db_id": "match_season", "question": "Show the players from college UCLA.", "rationale": ["Identify the relevant table: The 'match_season' table contains information about players and their colleges.", "Determine the filtering condition: We need to filter players who attended UCLA.", "Construct the SQL query: Use a SELECT statement to get the 'Player' column from the 'match_season' table where the 'College' is 'UCLA'.", "Include an ORDER BY clause to sort the results by college name, even though in this case we are filtering for a specific college."], "gold_sql": "SELECT Player FROM match_season WHERE College  =  'UCLA'", "source_tables": ["match_season"], "pred_sql": "SELECT Player FROM match_season WHERE College = 'UCLA' ORDER BY College ASC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of players from the 'match_season' table, ordered by their college names in ascending order. The placeholder in the ORDER BY clause represents the college names.\",\n        \"virtual_table\": \"SELECT player FROM match_season ORDER BY College ASC\"\n    }\n}\n"}
{"sample_id": "train.1082", "db_id": "match_season", "question": "Show the season, the player, and the name of the team that players belong to.", "rationale": ["Identify the required columns: Season, Player, and Team.", "These columns are available in the match_season table.", "Construct the SELECT statement to retrieve these columns from the match_season table."], "gold_sql": "SELECT T1.Season ,  T1.Player ,  T2.Name FROM match_season AS T1 JOIN team AS T2 ON T1.Team  =  T2.Team_id", "source_tables": ["team", "match_season"], "pred_sql": "SELECT match_season.Season, match_season.Player, match_season.Team FROM match_season", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of players from the 'match_season' table, ordered by their college names in ascending order. The placeholder in the ORDER BY clause represents the college names.\",\n        \"virtual_table\": \"SELECT player FROM match_season ORDER BY College ASC\"\n    }\n}\n"}
{"sample_id": "train.1092", "db_id": "match_season", "question": "Show the country names and the corresponding number of players.", "rationale": ["Identify the tables needed: We need the 'country' table for country names and the 'player' table to count the players.", "We will use a LEFT JOIN to connect the 'country' table with the 'match_season' table on the 'Country_id' and 'Country' columns, respectively, to get the players associated with each country.", "Next, we will join the 'match_season' table with the 'player' table to access player information.", "We will use COUNT() to count the number of players for each country.", "Finally, we will group the results by 'Country_name' to get the count of players for each country."], "gold_sql": "SELECT Country_name ,  COUNT(*) FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country GROUP BY T1.Country_name", "source_tables": ["country", "match_season"], "pred_sql": "SELECT c.Country_name, COUNT(p.Player_ID) AS Number_of_Players\nFROM country c\nLEFT JOIN match_season ms ON c.Country_id = ms.Country\nLEFT JOIN player p ON ms.Player = p.Player\nGROUP BY c.Country_name;", "hint": "\n"}
{"sample_id": "train.1098", "db_id": "match_season", "question": "Show the top 3 most common colleges of players in match seasons.", "rationale": ["We need to find the most common colleges of players in match seasons.", "To do this, we will select the 'College' column from the 'match_season' table.", "We will count the occurrences of each college using COUNT(*) and alias it as 'College_Count'.", "To get the most common colleges, we will group the results by 'College'.", "We will then order the results in descending order based on 'College_Count' to get the most common colleges at the top.", "Finally, we will limit the results to the top 3 colleges using LIMIT 3."], "gold_sql": "SELECT College FROM match_season GROUP BY College ORDER BY count(*) DESC LIMIT 3", "source_tables": ["match_season"], "pred_sql": "SELECT College, COUNT(*) as College_Count FROM match_season GROUP BY College ORDER BY College_Count DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of players from the 'match_season' table, ordered by their college names in ascending order. The placeholder in the ORDER BY clause represents the college names.\",\n        \"virtual_table\": \"SELECT player FROM match_season ORDER BY College ASC\"\n    }\n}\n"}
{"sample_id": "train.1099", "db_id": "match_season", "question": "What are the three colleges from which the most players are from?", "rationale": ["We need to find the colleges with the most players.", "To do this, we will count the number of players associated with each college in the 'match_season' table.", "We will use the COUNT function to count the players for each college.", "We will group the results by the 'College' column to aggregate the counts for each college.", "To get the top three colleges, we will order the results by the count of players in descending order.", "Finally, we will limit the results to the top three using the LIMIT clause."], "gold_sql": "SELECT College FROM match_season GROUP BY College ORDER BY count(*) DESC LIMIT 3", "source_tables": ["match_season"], "pred_sql": "SELECT College, COUNT(*) as Player_Count\nFROM match_season\nGROUP BY College\nORDER BY Player_Count DESC\nLIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of players from the 'match_season' table, ordered by their college names in ascending order. The placeholder in the ORDER BY clause represents the college names.\",\n        \"virtual_table\": \"SELECT player FROM match_season ORDER BY College ASC\"\n    }\n}\n"}
{"sample_id": "train.1107", "db_id": "match_season", "question": "Return the names of countries that have players that play the Forward position, as well as players who play the Defender position.", "rationale": ["Identify the relevant tables: We need to use the 'country' and 'match_season' tables to get the required information.", "Determine the relationship: The 'match_season' table has a foreign key 'Country' that links to 'Country_id' in the 'country' table.", "Select the necessary columns: We need the 'Country_name' from the 'country' table.", "Filter the results: We want countries that have players in either the 'Forward' or 'Defender' positions, so we will use a WHERE clause with an IN condition.", "Use DISTINCT to avoid duplicate country names in the result."], "gold_sql": "SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  'Forward' INTERSECT SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  'Defender'", "source_tables": ["country", "match_season"], "pred_sql": "SELECT DISTINCT c.Country_name \nFROM country c \nJOIN match_season ms ON c.Country_id = ms.Country \nWHERE ms.Position IN ('Forward', 'Defender');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of players from the 'match_season' table, ordered by their college names in ascending order. The placeholder in the ORDER BY clause represents the college names.\",\n        \"virtual_table\": \"SELECT player FROM match_season ORDER BY College ASC\"\n    }\n}\n"}
