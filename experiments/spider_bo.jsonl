{"sample_id": "train.6723", "db_id": "activity_1", "question": "Show the first name, last name, and phone number for all female faculty members.", "rationale": ["The query is identifying the relevant table, which is 'Faculty'.", "Select the columns to display, 'Fname', 'Lname', and 'phone'.", "Add a condition to filter the 'Sex' column for the specified gender using a placeholder for string values."], "gold_sql": "SELECT Fname ,  Lname ,  phone FROM Faculty WHERE Sex  =  'F'", "source_tables": ["faculty"], "description": "This virtual table provides the first names, last names, and contact phone numbers of faculty members from the 'Faculty' table who belong to a specific gender category. The placeholder in the WHERE clause represents the gender of the faculty members.", "virtual_table": "SELECT Fname ,  Lname ,  phone FROM Faculty WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6739", "db_id": "activity_1", "question": "Show all the buildings that have at least 10 professors.", "rationale": ["The query identifies the relevant table, which is 'Faculty'.", "Select the column to display, 'building'.", "Add a condition to filter the 'rank' column for the specified academic rank using a placeholder for string values.", "Group the results by 'building' to aggregate the data.", "Use the HAVING clause to filter groups that have a count of faculty members greater than or equal to a specified number, using a placeholder for numeric values."], "gold_sql": "SELECT building FROM Faculty WHERE rank  =  'Professor' GROUP BY building HAVING count(*)  >=  10", "source_tables": ["faculty"], "description": "This virtual table provides information about the buildings where faculty members with a specific academic rank are located. The query groups the results by building and filters to include only those buildings that have a certain number of faculty members, as indicated by the placeholders.", "virtual_table": "SELECT building FROM Faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] GROUP BY building HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6724", "db_id": "activity_1", "question": "What are the first name, last name, and phone number of all the female faculty members?", "rationale": ["The query is identifying the relevant table, which is 'Faculty'.", "Select the columns to display, 'Fname', 'Lname', and 'phone'.", "Add a condition to filter the 'Sex' column for the specified gender using a placeholder for string values."], "gold_sql": "SELECT Fname ,  Lname ,  phone FROM Faculty WHERE Sex  =  'F'", "source_tables": ["faculty"], "description": "This virtual table provides the first names, last names, and contact phone numbers of faculty members from the 'Faculty' table who belong to a specific gender category. The placeholder in the WHERE clause represents the gender of the faculty members.", "virtual_table": "SELECT Fname ,  Lname ,  phone FROM Faculty WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6802", "db_id": "activity_1", "question": "Which students participate in both Canoeing and Kayaking as their activities? Tell me their student ids.", "rationale": ["The query is identifying the relevant tables, which are 'Participates_in' and 'Activity'.", "It selects the 'stuid' column from the 'Participates_in' table.", "The query uses a JOIN to connect 'Participates_in' with 'Activity' based on the 'actid'.", "It filters the results based on the 'activity_name' for two different activities using placeholders.", "The INTERSECT operator is used to find students who participate in both activities."], "gold_sql": "SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  'Canoeing' INTERSECT SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  'Kayaking'", "source_tables": ["activity", "participates_in"], "description": "This virtual table identifies students who participate in two specific activities from the 'Activity' table. The placeholders in the WHERE clauses represent the names of the activities being queried.", "virtual_table": "SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6740", "db_id": "activity_1", "question": "In which buildings are there at least ten professors?", "rationale": ["The query identifies the relevant table, which is 'Faculty'.", "Select the column to display, 'building'.", "Add a condition to filter the 'rank' column for the specified academic rank using a placeholder for string values.", "Group the results by 'building' to aggregate the data.", "Use the HAVING clause to filter groups that have a count of faculty members greater than or equal to a specified number, using a placeholder for numeric values."], "gold_sql": "SELECT building FROM Faculty WHERE rank  =  'Professor' GROUP BY building HAVING count(*)  >=  10", "source_tables": ["faculty"], "description": "This virtual table provides information about the buildings where faculty members with a specific academic rank are located. The query groups the results by building and filters to include only those buildings that have a certain number of faculty members, as indicated by the placeholders.", "virtual_table": "SELECT building FROM Faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] GROUP BY building HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6780", "db_id": "activity_1", "question": "What is the first and last name of the faculty members who participated in at least one activity? For each of them, also show the number of activities they participated in.", "rationale": ["The query identifies the relevant tables, which are 'Faculty' and 'Faculty_Participates_in'.", "It selects the first name and last name of faculty members from the 'Faculty' table.", "It counts the number of activities each faculty member participates in by using the COUNT function.", "The JOIN operation connects the 'Faculty' table with the 'Faculty_Participates_in' table based on the faculty identifier.", "The GROUP BY clause is used to aggregate the results by each faculty member's unique identifier."], "gold_sql": "SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID", "source_tables": ["faculty", "faculty_participates_in"], "description": "This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The placeholder in the SELECT clause represents the faculty member's first and last names, while the GROUP BY clause groups the results by the unique identifier of each faculty member.", "virtual_table": "SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID"}
{"sample_id": "train.6759", "db_id": "activity_1", "question": "What are the first and last name of the faculty who has the most students?", "rationale": ["The query identifies the relevant tables, which are 'Faculty' and 'Student'.", "It selects the first and last names of faculty members (T1.fname, T1.lname).", "A JOIN operation is performed between the Faculty and Student tables on the condition that the Faculty ID matches the advisor field in the Student table.", "The results are grouped by the Faculty ID to aggregate the number of students each faculty member advises.", "The results are ordered in descending order based on the count of students advised, and a limit is applied to restrict the number of faculty members returned using a placeholder for numeric values."], "gold_sql": "SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID ORDER BY count(*) DESC LIMIT 1", "source_tables": ["faculty", "student"], "description": "This virtual table provides the first and last names of faculty members who serve as academic advisors to students. The results are grouped by faculty ID and ordered by the number of students they advise, with a limit on the number of faculty members returned based on a specified number.", "virtual_table": "SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6800", "db_id": "activity_1", "question": "What are the first names of the faculty members playing both Canoeing and Kayaking?", "rationale": ["The query identifies the relevant tables, which are 'Faculty', 'Faculty_Participates_in', and 'Activity'.", "It selects the 'lname' column from the 'Faculty' table.", "The query uses JOINs to connect 'Faculty' with 'Faculty_Participates_in' and 'Activity' based on their identifiers.", "It filters the results based on the 'activity_name' for two different activities using placeholders for string values.", "The INTERSECT operator is used to find faculty members who participate in both activities."], "gold_sql": "SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' INTERSECT SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "description": "This virtual table describes the last names of faculty members who participate in two specific activities from the 'Activity' table. The placeholders in the WHERE clause represent the names of the activities that the faculty members are involved in.", "virtual_table": "SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6755", "db_id": "activity_1", "question": "Show the faculty id of each faculty member, along with the number of students he or she advises.", "rationale": ["The query identifies the relevant tables, which are 'Faculty' and 'Student'.", "It selects the 'FacID' from the 'Faculty' table and counts the number of students associated with each faculty member.", "A JOIN operation is performed between 'Faculty' and 'Student' on the advisor relationship, linking 'FacID' to the 'advisor' field in the 'Student' table.", "The results are grouped by 'FacID' to aggregate the count of students for each faculty member."], "gold_sql": "SELECT T1.FacID ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID", "source_tables": ["faculty", "student"], "description": "This virtual table summarizes the count of students assigned to each faculty member as their advisor from the 'Faculty' and 'Student' tables. The placeholder in the SELECT statement represents the faculty member's unique identifier, while the count reflects the number of students associated with that advisor.", "virtual_table": "SELECT T1.FacID ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID"}
{"sample_id": "train.6796", "db_id": "activity_1", "question": "Which faculty members are playing either Canoeing or Kayaking? Tell me their first names.", "rationale": ["The query identifies the relevant tables: 'Faculty', 'Faculty_participates_in', and 'Activity'.", "It selects distinct last names from the 'Faculty' table.", "The JOIN operations link faculty members to their respective activities through the 'Faculty_participates_in' table and the 'Activity' table.", "The WHERE clause filters the activities based on their names, using placeholders for the activity names."], "gold_sql": "SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "description": "This virtual table provides a list of distinct last names of faculty members who participate in specific activities. The activities are filtered based on their names, which are represented by placeholders in the WHERE clause.", "virtual_table": "SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6738", "db_id": "activity_1", "question": "Find the building that has the largest number of faculty members.", "rationale": ["The query identifies the relevant table, which is 'Faculty'.", "It selects the 'building' column to display the names of the buildings.", "The GROUP BY clause is used to group the results by the 'building' column.", "The ORDER BY clause sorts the buildings based on the count of faculty members in each building in descending order.", "The LIMIT clause uses a placeholder to allow the user to specify how many buildings to return."], "gold_sql": "SELECT building FROM Faculty GROUP BY building ORDER BY count(*) DESC LIMIT 1", "source_tables": ["faculty"], "description": "This virtual table provides a list of buildings where faculty members have their offices, grouped by building name. The placeholder in the LIMIT clause allows the user to specify the maximum number of buildings to return, based on the number of faculty members in each building.", "virtual_table": "SELECT building FROM Faculty GROUP BY building ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6795", "db_id": "activity_1", "question": "Find the first names of the faculty members who are playing Canoeing or Kayaking.", "rationale": ["The query identifies the relevant tables: 'Faculty', 'Faculty_Participates_in', and 'Activity'.", "It selects distinct last names from the 'Faculty' table.", "The JOIN operations link faculty members to their respective activities through the 'Faculty_Participates_in' table and the 'Activity' table.", "The WHERE clause filters the activities based on their names using placeholders for string values."], "gold_sql": "SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "description": "This virtual table provides a list of distinct last names of faculty members who participate in specific activities. The activities are filtered based on their names, which are represented by placeholders in the WHERE clause.", "virtual_table": "SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6757", "db_id": "activity_1", "question": "Show all the faculty ranks and the number of students advised by each rank.", "rationale": ["The query identifies the relevant tables, which are 'Faculty' and 'Student'.", "It selects the 'rank' from the 'Faculty' table and counts the number of students associated with each faculty member.", "A JOIN operation is performed between 'Faculty' and 'Student' on the advisor relationship, linking 'FacID' from 'Faculty' to 'Advisor' in 'Student'.", "The results are grouped by the faculty rank to provide a count of students for each rank."], "gold_sql": "SELECT T1.rank ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.rank", "source_tables": ["faculty", "student"], "description": "This virtual table summarizes the count of students assigned to each faculty member's rank, based on the advisory relationships. The placeholders represent the faculty rank and the count of students associated with that rank.", "virtual_table": "SELECT T1.rank ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.rank"}
{"sample_id": "train.6733", "db_id": "activity_1", "question": "Show the first name and last name for all the instructors.", "rationale": ["The query identifies the relevant table, which is 'Faculty'.", "Select the columns to display, 'fname' and 'lname'.", "Add a condition to filter the 'Rank' column for the specified rank using a placeholder for string values."], "gold_sql": "SELECT fname ,  lname FROM Faculty WHERE Rank  =  'Instructor'", "source_tables": ["faculty"], "description": "This virtual table provides the first and last names of faculty members from the 'Faculty' table who hold a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.", "virtual_table": "SELECT fname ,  lname FROM Faculty WHERE Rank  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6782", "db_id": "activity_1", "question": "How many faculty members participate in each activity? Return the activity names and the number of faculty members.", "rationale": ["The query identifies the relevant tables, which are 'Activity' and 'Faculty_Participates_in'.", "It selects the 'activity_name' from the 'Activity' table and counts the number of faculty members participating in each activity.", "A JOIN operation is performed between 'Activity' and 'Faculty_Participates_in' on the activity identifier to link the two tables.", "The results are grouped by the activity identifier to aggregate the count of faculty members for each activity."], "gold_sql": "SELECT T1.activity_name ,  count(*) FROM Activity AS T1 JOIN Faculty_participates_in AS T2 ON T1.actID  =  T2.actID GROUP BY T1.actID", "source_tables": ["activity", "faculty_participates_in"], "description": "This virtual table summarizes the number of faculty members participating in each activity from the 'Activity' table. The placeholder in the SELECT statement allows for the retrieval of the activity name along with the count of faculty members involved in that activity.", "virtual_table": "SELECT T1.activity_name ,  count(*) FROM Activity AS T1 JOIN Faculty_participates_in AS T2 ON T1.actID  =  T2.actID GROUP BY T1.actID"}
{"sample_id": "train.6781", "db_id": "activity_1", "question": "Show all the activity names and the number of faculty involved in each activity.", "rationale": ["The query identifies the relevant tables, which are 'Activity' and 'Faculty_Participates_in'.", "It selects the 'activity_name' from the 'Activity' table and counts the number of faculty members participating in each activity.", "A JOIN operation is performed between 'Activity' and 'Faculty_Participates_in' on the activity identifier to link activities with their participants.", "The results are grouped by the activity identifier to aggregate the count of faculty members for each activity."], "gold_sql": "SELECT T1.activity_name ,  count(*) FROM Activity AS T1 JOIN Faculty_participates_in AS T2 ON T1.actID  =  T2.actID GROUP BY T1.actID", "source_tables": ["activity", "faculty_participates_in"], "description": "This virtual table summarizes the number of faculty members participating in each activity from the 'Activity' table. The placeholder in the SELECT statement allows for the retrieval of the activity name along with the count of faculty members involved in that activity.", "virtual_table": "SELECT T1.activity_name ,  count(*) FROM Activity AS T1 JOIN Faculty_participates_in AS T2 ON T1.actID  =  T2.actID GROUP BY T1.actID"}
{"sample_id": "train.6766", "db_id": "activity_1", "question": "List all the activities we have.", "rationale": ["The query is identifying the relevant table, which is 'Activity'.", "Select the column to display, 'activity_name'.", "No filtering conditions are applied, so it retrieves all activity names from the table."], "gold_sql": "SELECT activity_name FROM Activity", "source_tables": ["activity"], "description": "The virtual table provides a list of activity names from the 'Activity' table. This table serves as a reference for all activities available, allowing users to identify specific activities by their names.", "virtual_table": "SELECT activity_name FROM Activity"}
{"sample_id": "train.6726", "db_id": "activity_1", "question": "What are the faculty ids of all the male faculty members?", "rationale": ["The query is identifying the relevant table, which is 'Faculty'.", "Select the column to display, 'FacID'.", "Add a condition to filter the 'Sex' column for the specified gender using a placeholder for string values."], "gold_sql": "SELECT FacID FROM Faculty WHERE Sex  =  'M'", "source_tables": ["faculty"], "description": "This virtual table provides the unique identifiers of faculty members from the 'Faculty' table based on their gender. The placeholder in the WHERE clause represents the gender of the faculty members being queried.", "virtual_table": "SELECT FacID FROM Faculty WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6776", "db_id": "activity_1", "question": "Find the number of activities Mark Giuliano is involved in.", "rationale": ["The query identifies the relevant tables, which are 'Faculty' and 'Faculty_Participates_in'.", "It uses a JOIN operation to combine these tables based on the faculty ID.", "The SELECT statement counts the number of records that match the specified conditions.", "The WHERE clause filters the results based on the first and last names of the faculty members using placeholders for string values."], "gold_sql": "SELECT count(*) FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID WHERE T1.fname  =  'Mark' AND T1.lname  =  'Giuliano'", "source_tables": ["faculty", "faculty_participates_in"], "description": "The virtual table provides a count of faculty members who participate in activities, filtered by their first and last names. The placeholders in the WHERE clause represent the specific first and last names of the faculty members being queried.", "virtual_table": "SELECT count(*) FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6765", "db_id": "activity_1", "question": "What activities do we have?", "rationale": ["The query is identifying the relevant table, which is 'Activity'.", "Select the column to display, 'activity_name'.", "No filtering conditions are applied, so it retrieves all activity names from the table."], "gold_sql": "SELECT activity_name FROM Activity", "source_tables": ["activity"], "description": "The virtual table provides a list of activity names from the 'Activity' table. This table serves as a reference for all activities available, allowing users to identify specific activities by their names.", "virtual_table": "SELECT activity_name FROM Activity"}
{"sample_id": "train.534", "db_id": "allergy_1", "question": "How many students are over 18 and do not have allergy to food type or animal type?", "rationale": ["The query identifies the relevant table, which is 'Student'.", "It counts the total number of students that meet the specified criteria.", "A condition is added to filter students based on their age using a placeholder for numeric values.", "A subquery is used to exclude students who have allergies of specified types by joining 'Has_Allergy' and 'Allergy_Type' tables, with placeholders for the allergy types."], "gold_sql": "SELECT count(*) FROM Student WHERE age  >  18 AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food' OR T2.allergytype  =  'animal')", "source_tables": ["has_allergy", "allergy_type", "student"], "description": "This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the types of allergies to exclude.", "virtual_table": "SELECT count(*) FROM Student WHERE age  >  [PLACEHOLDER-TYPE:NUMBER] AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] OR T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.522", "db_id": "allergy_1", "question": "What are the allergies the girl named Lisa has? And what are the types of them? Order the result by allergy names.", "rationale": ["The query identifies the relevant tables: 'Allergy_Type', 'Has_Allergy', and 'Student'.", "It selects the columns 'Allergy' and 'AllergyType' from the 'Allergy_Type' table.", "The JOIN operations link the 'Has_Allergy' table to the 'Allergy_Type' table and the 'Student' table based on the common keys.", "A condition is added to filter results by the student's first name using a placeholder for string values."], "gold_sql": "SELECT T1.Allergy ,  T1.AllergyType FROM Allergy_type AS T1 JOIN Has_allergy AS T2 ON T1.Allergy  =  T2.Allergy JOIN Student AS T3 ON T3.StuID  =  T2.StuID WHERE T3.Fname  =  'Lisa' ORDER BY T1.Allergy", "source_tables": ["has_allergy", "allergy_type", "student"], "description": "This virtual table provides a list of allergies and their corresponding types for students based on their first name. The placeholders in the WHERE clause allow for filtering by a specific student's first name.", "virtual_table": "SELECT T1.Allergy ,  T1.AllergyType FROM Allergy_type AS T1 JOIN Has_allergy AS T2 ON T1.Allergy  =  T2.Allergy JOIN Student AS T3 ON T3.StuID  =  T2.StuID WHERE T3.Fname  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.Allergy"}
{"sample_id": "train.529", "db_id": "allergy_1", "question": "Find the number of male (sex is 'M') students who have some food type allery.", "rationale": ["The query identifies the relevant table, which is 'Student'.", "It counts the number of students based on the specified gender using a placeholder for string values.", "It includes a subquery that filters students who have allergies by joining 'Has_Allergy' and 'Allergy_Type' tables, using a placeholder for the allergy type."], "gold_sql": "SELECT count(*) FROM Student WHERE sex  =  'M' AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "description": "This virtual table provides a count of students based on their gender who have a specific type of allergy. The placeholders in the query allow for filtering by the student's gender and the allergy type.", "virtual_table": "SELECT count(*) FROM Student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.527", "db_id": "allergy_1", "question": "List the first and last name of the students who do not have any food type allergy.", "rationale": ["The query identifies the relevant table, which is 'Student'.", "Select the columns to display, 'fname' and 'lname'.", "Add a condition to filter out students whose IDs are in a subquery.", "The subquery selects student IDs from 'Has_Allergy' joined with 'Allergy_Type' where the allergy type matches the specified placeholder."], "gold_sql": "SELECT fname ,  lname FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "description": "This virtual table provides the first and last names of students from the 'Student' table who do not have a specific type of allergy. The placeholder in the subquery represents the allergy type that is being filtered out.", "virtual_table": "SELECT fname ,  lname FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.533", "db_id": "allergy_1", "question": "Find the number of students who are older than 18 and do not have allergy to either food or animal.", "rationale": ["The query identifies the relevant table, which is 'Student'.", "It counts the total number of students that meet the specified criteria.", "A condition is added to filter students based on their age using a placeholder for numeric values.", "A subquery is used to exclude students who have allergies of specified types by joining 'Has_Allergy' and 'Allergy_Type' tables, with placeholders for the allergy types."], "gold_sql": "SELECT count(*) FROM Student WHERE age  >  18 AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food' OR T2.allergytype  =  'animal')", "source_tables": ["has_allergy", "allergy_type", "student"], "description": "This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age threshold and the allergy types to be excluded.", "virtual_table": "SELECT count(*) FROM Student WHERE age  >  [PLACEHOLDER-TYPE:NUMBER] AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] OR T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.526", "db_id": "allergy_1", "question": "How old are the students with allergies to food and animal types on average?", "rationale": ["The query identifies the relevant table, which is 'Student', to calculate the average age.", "It uses a subquery to find students who have allergies of two specified types by joining 'Has_Allergy' and 'Allergy_Type' tables.", "The INTERSECT operator is used to ensure that only students with both allergy types are considered.", "The placeholders in the WHERE clause represent the allergy types to filter the results accordingly."], "gold_sql": "SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food' INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'animal')", "source_tables": ["has_allergy", "allergy_type", "student"], "description": "This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.", "virtual_table": "SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.535", "db_id": "allergy_1", "question": "Find the first name and major of the students who are not allegry to soy.", "rationale": ["The query identifies the relevant table, which is 'Student'.", "Select the columns to display, 'fname' and 'major'.", "Add a condition to filter out students whose IDs are present in the 'Has_Allergy' table for a specific allergy using a placeholder for string values."], "gold_sql": "SELECT fname ,  major FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Soy')", "source_tables": ["has_allergy", "student"], "description": "This virtual table provides the first names and majors of students from the 'Student' table who do not have a specific allergy. The placeholder in the subquery represents the name of the allergy that is being checked against the students' allergies.", "virtual_table": "SELECT fname ,  major FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.470", "db_id": "allergy_1", "question": "What are the full names and ages for all female students whose sex is F?", "rationale": ["The query identifies the relevant table, which is 'Student'.", "Select the columns to display: 'Fname', 'Lname', and 'Age'.", "Add a condition to filter the 'Sex' column for the specified gender using a placeholder for string values."], "gold_sql": "SELECT Fname ,  Lname ,  Age FROM Student WHERE Sex  =  'F'", "source_tables": ["student"], "description": "The virtual table provides information about students, including their first names, last names, and ages, filtered by a specific gender. The placeholder in the WHERE clause represents the gender of the students being queried.", "virtual_table": "SELECT Fname ,  Lname ,  Age FROM Student WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.536", "db_id": "allergy_1", "question": "What are the first name and major of the students who are able to consume soy?", "rationale": ["The query identifies the relevant table, which is 'Student'.", "Select the columns to display, 'fname' and 'major'.", "Add a condition to filter out students whose IDs are in the 'Has_allergy' table for a specific allergy using a placeholder for string values."], "gold_sql": "SELECT fname ,  major FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Soy')", "source_tables": ["has_allergy", "student"], "description": "This virtual table provides the first names and majors of students from the 'Student' table who do not have a specific allergy. The placeholder in the subquery represents the name of the allergy that is being checked against the students' allergies.", "virtual_table": "SELECT fname ,  major FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.513", "db_id": "allergy_1", "question": "Which allergy has most number of students affected?", "rationale": ["The query identifies the relevant table, which is 'Has_Allergy'.", "It selects the 'Allergy' column to display the names of allergies.", "The GROUP BY clause is used to group the results by the 'Allergy' name.", "The ORDER BY clause sorts the allergies based on their count in descending order, showing the most common allergies first.", "The LIMIT clause restricts the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT 1", "source_tables": ["has_allergy"], "description": "This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name. The results are ordered by the frequency of each allergy occurrence, allowing users to see the most common allergies among students. The placeholder in the LIMIT clause represents the maximum number of allergies to return.", "virtual_table": "SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.501", "db_id": "allergy_1", "question": "Which advisor has most number of students?", "rationale": ["The query identifies the relevant table, which is 'Student'.", "Select the column to display, 'advisor'.", "Group the results by the 'advisor' column to aggregate the data.", "Order the results by the count of students associated with each advisor in descending order.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT advisor FROM Student GROUP BY advisor ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "description": "This virtual table provides a list of academic advisors from the 'Student' table, grouped by the advisor's name. The results are ordered by the number of students assigned to each advisor in descending order, with a limit on the number of advisors returned, specified by a placeholder for numeric values.", "virtual_table": "SELECT advisor FROM Student GROUP BY advisor ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.491", "db_id": "allergy_1", "question": "Which major has most number of students?", "rationale": ["The query identifies the relevant table, which is 'Student'.", "It selects the 'major' column to display the academic majors of students.", "The GROUP BY clause is used to group the results by the 'major' column to count the number of students in each major.", "The ORDER BY clause sorts the results in descending order based on the count of students in each major.", "The LIMIT clause uses a placeholder to specify how many of the top majors to return."], "gold_sql": "SELECT major FROM Student GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "description": "The virtual table summarizes the academic majors of students from the 'Student' table, grouping them to count the number of students in each major. The placeholder in the LIMIT clause allows for specifying the maximum number of majors to return, based on the highest student counts.", "virtual_table": "SELECT major FROM Student GROUP BY major ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.509", "db_id": "allergy_1", "question": "How many female students have milk or egg allergies?", "rationale": ["The query identifies the relevant tables, which are 'Has_Allergy' and 'Student'.", "It uses a JOIN operation to combine data from both tables based on the student identifier (StuID).", "The SELECT statement counts the number of records that meet the specified conditions.", "The WHERE clause filters the results based on the gender of the students and the specific allergies, using placeholders for these values."], "gold_sql": "SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  'F' AND T1.allergy  =  'Milk' OR T1.allergy  =  'Eggs'", "source_tables": ["has_allergy", "student"], "description": "This virtual table provides a count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies being queried.", "virtual_table": "SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  [PLACEHOLDER-TYPE:STRING] AND T1.allergy  =  [PLACEHOLDER-TYPE:STRING] OR T1.allergy  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.456", "db_id": "allergy_1", "question": "Which allergy type is most common?", "rationale": ["The query identifies the relevant table, which is 'Allergy_Type'.", "It selects the 'allergytype' column to display the types of allergies.", "The query groups the results by 'allergytype' to aggregate the data.", "It orders the results by the count of occurrences in descending order to show the most common types first.", "The LIMIT clause uses a placeholder to specify how many allergy types to return."], "gold_sql": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT 1", "source_tables": ["allergy_type"], "description": "This virtual table summarizes the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them based on their frequency, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.", "virtual_table": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.518", "db_id": "allergy_1", "question": "How many students are affected by each allergy type?", "rationale": ["The query identifies the relevant tables, which are 'Has_Allergy' and 'Allergy_Type'.", "It performs a JOIN operation on the 'Allergy' column to combine data from both tables.", "The SELECT statement retrieves the 'allergytype' from the 'Allergy_Type' table and counts the number of occurrences from the 'Has_Allergy' table.", "The GROUP BY clause is used to aggregate the results by 'allergytype', allowing us to see how many students have each type of allergy."], "gold_sql": "SELECT T2.allergytype ,  count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy GROUP BY T2.allergytype", "source_tables": ["has_allergy", "allergy_type"], "description": "This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each type.", "virtual_table": "SELECT T2.allergytype ,  count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy GROUP BY T2.allergytype"}
{"sample_id": "train.442", "db_id": "allergy_1", "question": "How many distinct allergies are there?", "rationale": ["The query is identifying the relevant table, which is 'Allergy_Type'.", "It selects a count of distinct values from the 'AllergyType' column to determine the number of unique allergy types.", "The use of the DISTINCT keyword ensures that only unique allergy types are counted."], "gold_sql": "SELECT count(DISTINCT allergytype) FROM Allergy_type", "source_tables": ["allergy_type"], "description": "This virtual table provides a count of distinct allergy types from the 'Allergy_Type' table. The query focuses on the unique categories of allergies available in the database.", "virtual_table": "SELECT count(DISTINCT allergytype) FROM Allergy_type"}
{"sample_id": "train.512", "db_id": "allergy_1", "question": "How many students are affected by food related allergies?", "rationale": ["The query identifies the relevant tables, 'Has_Allergy' and 'Allergy_Type'.", "It uses a JOIN operation to connect these tables based on the allergy name.", "The SELECT statement counts the number of records that match the specified allergy type, using a placeholder for the allergy type in the WHERE clause."], "gold_sql": "SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  'food'", "source_tables": ["has_allergy", "allergy_type"], "description": "The virtual table provides a count of students who have a specific type of allergy. It combines data from the 'Has_Allergy' table, which links students to their allergies, and the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.", "virtual_table": "SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.511", "db_id": "allergy_1", "question": "How many students have a food allergy?", "rationale": ["The query identifies the relevant tables, 'Has_Allergy' and 'Allergy_Type'.", "It uses a JOIN operation to connect these tables based on the allergy name.", "The SELECT statement counts the number of records that match the specified allergy type, using a placeholder for the allergy type in the WHERE clause."], "gold_sql": "SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  'food'", "source_tables": ["has_allergy", "allergy_type"], "description": "This virtual table provides a count of students who have a specific type of allergy. It combines data from the 'Has_Allergy' table, which links students to their allergies, and the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the type of allergy being queried.", "virtual_table": "SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.508", "db_id": "allergy_1", "question": "Which students are unaffected by allergies?", "rationale": ["The query identifies the relevant table, which is 'Student', to select the unique identifiers of students.", "The EXCEPT clause is used to filter out students who have allergies by selecting their identifiers from the 'Has_Allergy' table.", "This results in a list of students who do not have any allergies, as indicated by the absence of their identifiers in the 'Has_Allergy' table."], "gold_sql": "SELECT StuID FROM Student EXCEPT SELECT StuID FROM Has_allergy", "source_tables": ["has_allergy", "student"], "description": "This virtual table lists the unique identifiers of students from the 'Student' table who do not have any allergies recorded in the 'Has_Allergy' table. The query uses the EXCEPT clause to exclude students who have allergies, ensuring that only those without allergies are included.", "virtual_table": "SELECT StuID FROM Student EXCEPT SELECT StuID FROM Has_allergy"}
{"sample_id": "train.450", "db_id": "allergy_1", "question": "What is allergy type of a cat allergy?", "rationale": ["The query is identifying the relevant table, which is 'Allergy_Type'.", "Select the column to display, 'allergytype'.", "Add a condition to filter the 'allergy' column for the specified allergy using a placeholder for string values."], "gold_sql": "SELECT allergytype FROM Allergy_type WHERE allergy  =  'Cat'", "source_tables": ["allergy_type"], "description": "This virtual table provides information about the type or category of a specific allergy from the 'Allergy_Type' table. The placeholder in the WHERE clause represents the name of the allergy being queried.", "virtual_table": "SELECT allergytype FROM Allergy_type WHERE allergy  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.471", "db_id": "allergy_1", "question": "Show student ids for all male students.", "rationale": ["The query is identifying the relevant table, which is 'Student'.", "Select the column to display, 'StuID', which is the unique identifier for each student.", "Add a condition to filter the 'Sex' column for the specified gender using a placeholder for string values."], "gold_sql": "SELECT StuID FROM Student WHERE Sex  =  'M'", "source_tables": ["student"], "description": "The virtual table provides a list of unique student identifiers from the 'Student' table based on a specified gender. The placeholder in the WHERE clause represents the gender of the students being queried.", "virtual_table": "SELECT StuID FROM Student WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1263", "db_id": "apartment_rentals", "question": "Which apartment type code is the most common among apartments with more than one bathroom?", "rationale": ["The query identifies the relevant table, which is 'Apartments'.", "It selects the 'apt_type_code' to display the types of apartments.", "A condition is added to filter apartments based on the number of bathrooms, using a placeholder for numeric values.", "The results are grouped by 'apt_type_code' to aggregate the counts of each type.", "The results are ordered by the count of each apartment type in descending order to show the most common types first.", "A limit is applied to restrict the number of results returned, using another placeholder for numeric values."], "gold_sql": "SELECT apt_type_code FROM Apartments WHERE bathroom_count  >  1 GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["apartments"], "description": "This virtual table provides a summary of the types of apartments available in the 'Apartments' table, specifically focusing on those that have a number of bathrooms exceeding a specified threshold. The results are grouped by the apartment type code and ordered by the frequency of each type in descending order, with a limit on the number of results returned based on a placeholder value.", "virtual_table": "SELECT apt_type_code FROM Apartments WHERE bathroom_count  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1259", "db_id": "apartment_rentals", "question": "Which apartment type has the largest number of total rooms? Return the apartment type code, its number of bathrooms and number of bedrooms.", "rationale": ["The query identifies the relevant table, which is 'Apartments'.", "Select the columns to display: 'apt_type_code', 'bathroom_count', and 'bedroom_count'.", "Group the results by 'apt_type_code' to aggregate the data based on apartment types.", "Order the results by the sum of 'room_count' in descending order to prioritize types with more rooms.", "Limit the number of results returned based on a placeholder for numeric values."], "gold_sql": "SELECT apt_type_code ,  bathroom_count ,  bedroom_count FROM Apartments GROUP BY apt_type_code ORDER BY sum(room_count) DESC LIMIT 1", "source_tables": ["apartments"], "description": "This virtual table summarizes the types of apartments available in the 'Apartments' table, along with the count of bathrooms and bedrooms for each type. The results are grouped by the apartment type code and ordered by the total number of rooms in descending order, with a limit on the number of results returned based on a specified number.", "virtual_table": "SELECT apt_type_code ,  bathroom_count ,  bedroom_count FROM Apartments GROUP BY apt_type_code ORDER BY sum(room_count) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1260", "db_id": "apartment_rentals", "question": "Show the most common apartment type code.", "rationale": ["The query identifies the relevant table, which is 'Apartments'.", "It selects the 'apt_type_code' to display the different types of apartments.", "The GROUP BY clause is used to group the results by 'apt_type_code'.", "The ORDER BY clause sorts the results based on the count of each apartment type in descending order.", "The LIMIT clause uses a placeholder to allow the user to specify how many types to return."], "gold_sql": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["apartments"], "description": "This virtual table summarizes the types of apartments available in the 'Apartments' table, grouped by their type code. The placeholder in the LIMIT clause allows the user to specify the maximum number of apartment types to retrieve, sorted by the most frequently occurring types.", "virtual_table": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1257", "db_id": "apartment_rentals", "question": "What are the top three apartment types in terms of the average room count? Give me the", "rationale": ["The query identifies the relevant table, which is 'Apartments'.", "It selects the 'apt_type_code' to display the different types of apartments.", "The results are grouped by 'apt_type_code' to aggregate the data based on apartment types.", "The query orders the results by the average of 'room_count' in descending order to prioritize apartment types with more rooms.", "The LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY avg(room_count) DESC LIMIT 3", "source_tables": ["apartments"], "description": "This virtual table summarizes the types of apartments available in the 'Apartments' table, grouped by their type code. It orders the results based on the average number of rooms in descending order, allowing users to see which apartment types have the most rooms on average. The placeholder in the LIMIT clause represents the maximum number of results to return.", "virtual_table": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY avg(room_count) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1220", "db_id": "apartment_rentals", "question": "Show the apartment numbers, start dates, and end dates of all the apartment bookings.", "rationale": ["The query identifies the relevant tables, 'Apartment_Bookings' and 'Apartments'.", "It selects the 'apt_number' from the 'Apartments' table and 'booking_start_date' from the 'Apartment_Bookings' table.", "A JOIN operation is performed to link the two tables based on the 'apt_id' to ensure that the correct apartment number corresponds to each booking."], "gold_sql": "SELECT T2.apt_number ,  T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id", "source_tables": ["apartment_bookings", "apartments"], "description": "The virtual table provides information about apartment bookings, specifically displaying the apartment number and the start date of the booking. The placeholders in the query allow for dynamic filtering based on specific apartment IDs.", "virtual_table": "SELECT T2.apt_number ,  T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id"}
{"sample_id": "train.1239", "db_id": "apartment_rentals", "question": "What are the facility codes of the apartments with more than four bedrooms?", "rationale": ["The query identifies the relevant tables, which are 'Apartment_Facilities' and 'Apartments'.", "It selects the 'facility_code' from the 'Apartment_Facilities' table.", "A JOIN operation is performed to link 'Apartment_Facilities' with 'Apartments' based on the apartment ID.", "A condition is added to filter the results based on the 'bedroom_count' in the 'Apartments' table using a placeholder for numeric values."], "gold_sql": "SELECT T1.facility_code FROM Apartment_Facilities AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  4", "source_tables": ["apartments", "apartment_facilities"], "description": "This virtual table provides a list of facility codes associated with apartments that have a specified number of bedrooms. The placeholder in the WHERE clause represents the minimum number of bedrooms required to filter the results.", "virtual_table": "SELECT T1.facility_code FROM Apartment_Facilities AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1233", "db_id": "apartment_rentals", "question": "What are the guest first name, start date, and end date of each apartment booking?", "rationale": ["The query identifies the relevant tables, which are 'Apartment_Bookings' and 'Guests'.", "It selects the 'guest_first_name' from the 'Guests' table and 'booking_start_date' from the 'Apartment_Bookings' table.", "A JOIN operation is performed on the 'guest_id' to link the two tables, allowing access to guest information related to their bookings."], "gold_sql": "SELECT T2.guest_first_name ,  T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id", "source_tables": ["apartment_bookings", "guests"], "description": "This virtual table provides the first names of guests along with their corresponding booking start dates from the 'Apartment_Bookings' and 'Guests' tables. The placeholders in the SELECT statement represent the guest's first name and the booking start date.", "virtual_table": "SELECT T2.guest_first_name ,  T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id"}
{"sample_id": "train.1221", "db_id": "apartment_rentals", "question": "What are the apartment number, start date, and end date of each apartment booking?", "rationale": ["The query identifies the relevant tables, 'Apartment_Bookings' and 'Apartments'.", "It selects the 'apt_number' from the 'Apartments' table and 'booking_start_date' from the 'Apartment_Bookings' table.", "A JOIN operation is performed to link the two tables based on the 'apt_id' to ensure that the booking information corresponds to the correct apartment."], "gold_sql": "SELECT T2.apt_number ,  T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id", "source_tables": ["apartment_bookings", "apartments"], "description": "The virtual table provides information about apartment bookings, specifically displaying the apartment number and the start date of the booking. The placeholders in the query allow for dynamic filtering based on specific apartment IDs.", "virtual_table": "SELECT T2.apt_number ,  T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id"}
{"sample_id": "train.1223", "db_id": "apartment_rentals", "question": "Return the booking start date and end date for the apartments that have type code \"Duplex\".", "rationale": ["The query identifies the relevant tables, 'Apartment_Bookings' and 'Apartments'.", "It selects the 'booking_start_date' from the 'Apartment_Bookings' table.", "A JOIN is performed on the 'apt_id' to link bookings to their respective apartments.", "A condition is added to filter the results based on the 'apt_type_code' using a placeholder for string values."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.apt_type_code  =  'Duplex'", "source_tables": ["apartment_bookings", "apartments"], "description": "This virtual table provides the start dates of apartment bookings from the 'Apartment_Bookings' table, specifically for apartments of a certain type. The placeholder in the WHERE clause represents the apartment type code that is used to filter the results.", "virtual_table": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.apt_type_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1235", "db_id": "apartment_rentals", "question": "What are the start date and end date of the apartment bookings made by female guests (gender code \"Female\")?", "rationale": ["The query identifies the relevant tables, which are 'Apartment_Bookings' and 'Guests'.", "It selects the columns 'booking_start_date' and 'booking_end_date' from the 'Apartment_Bookings' table.", "A JOIN operation is performed between 'Apartment_Bookings' and 'Guests' on the 'guest_id' to link bookings to guests.", "A condition is added to filter the results based on the 'gender_code' of the guests using a placeholder for string values."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id WHERE T2.gender_code  =  'Female'", "source_tables": ["apartment_bookings", "guests"], "description": "This virtual table provides the start dates of apartment bookings along with the corresponding booking end dates for guests filtered by a specific gender. The placeholders in the WHERE clause represent the gender code of the guests.", "virtual_table": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id WHERE T2.gender_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3669", "db_id": "baseball_1", "question": "What are the name and id of the team with the most victories in 2008 postseason?", "rationale": ["The query identifies the relevant tables, 'postseason' and 'team'.", "It selects the team name from the 'team' table and the winning team identifier from the 'postseason' table.", "A JOIN operation is performed to link the winning team identifier with the corresponding team name.", "A WHERE clause filters the results for a specific postseason year using a placeholder for numeric values.", "The results are grouped by the winning team identifier to aggregate the counts of wins.", "An ORDER BY clause sorts the results in descending order based on the count of wins.", "A LIMIT clause restricts the number of results returned based on a specified maximum."], "gold_sql": "SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  2008 GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["postseason", "team"], "description": "This virtual table provides a list of team names and their corresponding winning team identifiers from the 'postseason' table for a specific year. The results are grouped by the winning team identifier and ordered by the count of wins in descending order, with a limit on the number of results returned. The placeholders represent the year of the postseason and the maximum number of results to display.", "virtual_table": "SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3671", "db_id": "baseball_1", "question": "What is the number of wins the team Boston Red Stockings got in the postseasons each year in history?", "rationale": ["The query identifies the relevant tables, 'postseason' and 'team'.", "It selects the count of postseason wins and the year from the 'postseason' table.", "A JOIN is performed between 'postseason' and 'team' on the winning team identifier to filter results based on the team name.", "The WHERE clause uses a placeholder to specify the team name, allowing for dynamic querying.", "The results are grouped by year to provide a count of wins for each year."], "gold_sql": "SELECT count(*) ,  T1.year FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' GROUP BY T1.year", "source_tables": ["postseason", "team"], "description": "This virtual table summarizes the total number of postseason wins for a specific team over the years. The placeholder in the WHERE clause represents the name of the team for which the postseason wins are being counted.", "virtual_table": "SELECT count(*) ,  T1.year FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.year"}
{"sample_id": "train.3684", "db_id": "baseball_1", "question": "List all the salary values players received in 2010 and 2001.", "rationale": ["The query is identifying the relevant table, which is 'salary'.", "Select the 'salary' column to display the salary information.", "Use a UNION to combine results from two different years, with placeholders for the specific years being queried."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2010 UNION SELECT salary FROM salary WHERE YEAR  =  2001", "source_tables": ["salary"], "description": "This virtual table provides a combined view of player salaries for two specific years from the 'salary' table. The placeholders represent the years for which the salary data is being queried.", "virtual_table": "SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3641", "db_id": "baseball_1", "question": "In 2014, what are the id and rank of the team that has the largest average number of attendance?", "rationale": ["The query identifies the relevant tables, 'home_game' and 'team'.", "It selects the 'team_id' and 'rank' columns from the 'team' table.", "A JOIN operation is performed to combine data from 'home_game' and 'team' based on the 'team_id'.", "A condition is added to filter the results for a specific year using a placeholder for numeric values.", "The results are grouped by 'team_id' to aggregate attendance data.", "The results are ordered by the average attendance in descending order, and a limit is set for the number of results to return."], "gold_sql": "SELECT T2.team_id ,  T2.rank FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id WHERE T1.year  =  2014 GROUP BY T1.team_id ORDER BY avg(T1.attendance) DESC LIMIT 1;", "source_tables": ["team", "home_game"], "description": "This virtual table provides information about teams and their ranks based on home game attendance for a specific year. The placeholders in the WHERE clause represent the year of the home games and the limit for the number of teams to display.", "virtual_table": "SELECT T2.team_id ,  T2.rank FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id ORDER BY avg(T1.attendance) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3670", "db_id": "baseball_1", "question": "Find the name and id of the team that won the most times in 2008 postseason.", "rationale": ["The query identifies the relevant tables, 'postseason' and 'team'.", "It selects the team names and the winning team identifiers from the 'postseason' table.", "A JOIN operation is performed to link the winning team identifiers with their names in the 'team' table.", "A condition is added to filter the results by the specified year using a placeholder for numeric values.", "The results are grouped by the winning team identifier to count the number of wins and ordered in descending order to show the most successful teams first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  2008 GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["postseason", "team"], "description": "This virtual table provides a summary of the winning teams in the postseason for a specific year. It includes the names of the teams and their corresponding identifiers, allowing users to see which teams won the postseason and how many times they won. The placeholders in the query represent the year of the postseason and the limit on the number of results to return.", "virtual_table": "SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3647", "db_id": "baseball_1", "question": "Which 3 players won the most player awards? List their full name and id.", "rationale": ["The query identifies the relevant tables, 'player' and 'player_award', to gather player information and their awards.", "It selects the first name, last name, and player ID from the 'player' table.", "A JOIN operation is performed between the 'player' table and the 'player_award' table on the player ID to link players with their awards.", "The results are grouped by player ID to count the number of awards each player has received.", "The results are ordered in descending order based on the count of awards to prioritize players with the most awards.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for the user to specify the desired number."], "gold_sql": "SELECT T1.name_first ,  T1.name_last ,  T1.player_id FROM player AS T1 JOIN player_award AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.player_id ORDER BY count(*) DESC LIMIT 3;", "source_tables": ["player_award", "player"], "description": "This virtual table provides a list of players along with their first and last names, identified by their unique player IDs, who have received awards. The results are grouped by player ID to count the number of awards each player has received, sorted in descending order to highlight the players with the most awards. The placeholder in the LIMIT clause allows for specifying the maximum number of players to return in the result set.", "virtual_table": "SELECT T1.name_first ,  T1.name_last ,  T1.player_id FROM player AS T1 JOIN player_award AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.player_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3662", "db_id": "baseball_1", "question": "Which players won awards in both 1960 and 1961? Return their first names and last names.", "rationale": ["The query identifies the relevant table, which is 'player' for player details and 'player_award' for award information.", "It selects the columns to display, 'name_first' and 'name_last' from the 'player' table.", "The query uses a JOIN to connect the 'player' table with the 'player_award' table based on the player ID.", "It includes a condition to filter the results for two specific years using placeholders for numeric values.", "The INTERSECT operator is used to find players who received awards in both specified years."], "gold_sql": "SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1960 INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1961", "source_tables": ["player_award", "player"], "description": "This virtual table provides the first and last names of players who received awards in two different years. The placeholders in the WHERE clauses represent the specific years for which the awards were given.", "virtual_table": "SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3697", "db_id": "baseball_1", "question": "List players' first name and last name who received salary from team Washington Nationals in both 2005 and 2007.", "rationale": ["The query identifies the relevant tables: 'salary', 'player', and 'team'.", "It selects the 'name_first' and 'name_last' columns from the 'player' table.", "The query joins the 'salary' table with the 'player' table on 'player_id' and with the 'team' table on 'team_id_br'.", "It filters the results based on the specified year and team name using placeholders for dynamic input.", "The INTERSECT operator is used to ensure that the results from both parts of the query are the same, which is useful for ensuring consistency in the results."], "gold_sql": "SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2005 AND T3.name = 'Washington Nationals' INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2007 AND T3.name = 'Washington Nationals'", "source_tables": ["team", "player", "salary"], "description": "This virtual table provides the first and last names of players who received a specific salary in a given year while playing for a particular team. The placeholders in the WHERE clause represent the year and the team's name.", "virtual_table": "SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3700", "db_id": "baseball_1", "question": "Count the total number of games the team Boston Red Stockings attended from 1990 to 2000.", "rationale": ["The query identifies the relevant tables, 'home_game' and 'team'.", "It selects the sum of the 'games' column from the 'home_game' table.", "A join is performed between 'home_game' and 'team' on the 'team_id' to link the games to the specific team.", "Conditions are added to filter by the team's name and the range of years using placeholders for string and numeric values."], "gold_sql": "SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = 'Boston Red Stockings' AND T1.year BETWEEN 1990 AND 2000;", "source_tables": ["team", "home_game"], "description": "This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.", "virtual_table": "SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3707", "db_id": "baseball_1", "question": "Which cities have 2 to 4 parks?", "rationale": ["The query identifies the relevant table, which is 'park'.", "It selects the 'city' column to display the cities where parks are located.", "The GROUP BY clause is used to group the results by city.", "The HAVING clause filters the grouped results to include only those cities that have a count of parks within a specified range, using placeholders for numeric values."], "gold_sql": "SELECT city FROM park GROUP BY city HAVING count(*) BETWEEN 2 AND 4;", "source_tables": ["park"], "description": "This virtual table provides a list of cities where parks are located, grouped by city. The placeholders in the HAVING clause represent the range of counts for the number of parks in those cities, allowing users to filter cities based on the number of parks present.", "virtual_table": "SELECT city FROM park GROUP BY city HAVING count(*) BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3638", "db_id": "baseball_1", "question": "Count the number of players who enter hall of fame for each year.", "rationale": ["The query identifies the relevant table, which is 'hall_of_fame'.", "It selects the 'yearid' column to group the results by year.", "The count function is used to aggregate the number of players inducted for each year, and the GROUP BY clause organizes the results accordingly."], "gold_sql": "SELECT yearid ,  count(*) FROM hall_of_fame GROUP BY yearid;", "source_tables": ["hall_of_fame"], "description": "This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.", "virtual_table": "SELECT yearid ,  count(*) FROM hall_of_fame GROUP BY yearid;"}
{"sample_id": "train.3694", "db_id": "baseball_1", "question": "How many games in total did team Boston Red Stockings attend from 2000 to 2010?", "rationale": ["The query identifies the relevant tables, 'home_game' and 'team'.", "It selects the sum of the 'attendance' column from the 'home_game' table.", "A JOIN is performed between 'home_game' and 'team' on the 'team_id_br' to link the attendance data with the specific team.", "The WHERE clause filters the results based on the team's name and the specified year range using placeholders for string and numeric values."], "gold_sql": "SELECT sum(T1.attendance) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' AND T1.year BETWEEN 2000 AND 2010;", "source_tables": ["team", "home_game"], "description": "This virtual table summarizes the total attendance for home games played by a specific team over a range of years. The placeholders in the WHERE clause represent the team's name and the year range for which the attendance is being calculated.", "virtual_table": "SELECT sum(T1.attendance) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3701", "db_id": "baseball_1", "question": "Which team had the least number of attendances in home games in 1980?", "rationale": ["The query identifies the relevant tables, 'home_game' and 'team'.", "It selects the 'name' column from the 'team' table, which contains the names of the teams.", "A JOIN operation is performed between 'home_game' and 'team' on the 'team_id' to link home games with their respective teams.", "A condition is added to filter the results based on the specified year using a placeholder for numeric values.", "The results are ordered by attendance in ascending order and limited to a specified number using placeholders."], "gold_sql": "SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = 1980 ORDER BY T1.attendance ASC LIMIT 1;", "source_tables": ["team", "home_game"], "description": "This virtual table provides the names of teams that hosted home games in a specific year, sorted by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to return.", "virtual_table": "SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3710", "db_id": "baseball_1", "question": "Which park did the most people attend in 2008?", "rationale": ["The query identifies the relevant tables, 'home_game' and 'park'.", "It selects the 'park_name' from the 'park' table.", "A JOIN operation is performed to link 'home_game' and 'park' based on the 'park_id'.", "A condition is added to filter results for a specific year using a placeholder for numeric values.", "The results are ordered by attendance in descending order to show the most attended parks first.", "A limit is applied to restrict the number of results returned, using another placeholder for numeric values."], "gold_sql": "SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 2008 ORDER BY T1.attendance DESC LIMIT 1;", "source_tables": ["park", "home_game"], "description": "This virtual table provides a list of park names where home games were played in a specific year. The results are ordered by attendance, allowing users to see which parks had the highest attendance for home games during that year. The placeholders in the WHERE clause represent the year of interest and the limit on the number of results to return.", "virtual_table": "SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3699", "db_id": "baseball_1", "question": "How many home games did the team Boston Red Stockings play from 1990 to 2000 in total?", "rationale": ["The query identifies the relevant tables, 'home_game' and 'team'.", "It selects the sum of the 'games' column from the 'home_game' table.", "A JOIN is performed between 'home_game' and 'team' on the 'team_id' to link the games to the specific team.", "The WHERE clause filters the results based on the team's name and the specified year range using placeholders."], "gold_sql": "SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = 'Boston Red Stockings' AND T1.year BETWEEN 1990 AND 2000;", "source_tables": ["team", "home_game"], "description": "This virtual table summarizes the total number of home games played by a specific team over a range of years. The placeholders in the WHERE clause represent the team's name and the start and end years for the query.", "virtual_table": "SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3649", "db_id": "baseball_1", "question": "List three countries which are the origins of the least players.", "rationale": ["The query identifies the relevant table, which is 'player'.", "It selects the 'birth_country' column to display the countries of birth.", "The results are grouped by 'birth_country' to aggregate players from the same country.", "The results are ordered by the count of players in ascending order to show the least represented countries first.", "A limit is applied to restrict the number of countries returned, using a placeholder for numeric values."], "gold_sql": "SELECT birth_country FROM player GROUP BY birth_country ORDER BY count(*) ASC LIMIT 3;", "source_tables": ["player"], "description": "This virtual table provides a list of countries where players were born, grouped by the country name. The results are ordered by the number of players from each country in ascending order, with a limit on the number of countries returned based on a specified placeholder value.", "virtual_table": "SELECT birth_country FROM player GROUP BY birth_country ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3652", "db_id": "baseball_1", "question": "What are the first name and last name of the players whose death record is empty?", "rationale": ["The query identifies the relevant table, which is 'player'.", "Select the columns to display, 'name_first' and 'name_last'.", "Add a condition to filter the 'death_year' column for the specified year using a placeholder for string values."], "gold_sql": "SELECT name_first ,  name_last FROM player WHERE death_year = '';", "source_tables": ["player"], "description": "This virtual table provides the first and last names of players from the 'player' table who have a specified year of death. The placeholder in the WHERE clause represents the year of death being queried.", "virtual_table": "SELECT name_first ,  name_last FROM player WHERE death_year = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.3651", "db_id": "baseball_1", "question": "Find all the players' first name and last name who have empty death record.", "rationale": ["The query identifies the relevant table, which is 'player'.", "Select the columns to display, 'name_first' and 'name_last'.", "Add a condition to filter the 'death_year' column for the specified year using a placeholder for string values."], "gold_sql": "SELECT name_first ,  name_last FROM player WHERE death_year = '';", "source_tables": ["player"], "description": "This virtual table provides the first and last names of players from the 'player' table who have a specified year of death. The placeholder in the WHERE clause represents the year of death being queried.", "virtual_table": "SELECT name_first ,  name_last FROM player WHERE death_year = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.3678", "db_id": "baseball_1", "question": "What is the total salary expenses of team Boston Red Stockings in 2010?", "rationale": ["The query identifies the relevant tables, which are 'salary' and 'team'.", "It selects the sum of salaries from the 'salary' table, which is aliased as T1.", "A join is performed between the 'salary' table and the 'team' table on the team_id to link salary records to the respective teams.", "Conditions are added to filter the results based on the specified team name and year using placeholders for string and numeric values."], "gold_sql": "SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings' AND T1.year  =  2010", "source_tables": ["team", "salary"], "description": "This virtual table summarizes the total salary of players from a specific team for a given year. The placeholders in the query represent the team's name and the year for which the salary data is being queried.", "virtual_table": "SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3632", "db_id": "baseball_1", "question": "Compute the average salary of the players in the team called 'Boston Red Stockings'.", "rationale": ["The query identifies the relevant tables, which are 'salary' and 'team'.", "It selects the average salary from the 'salary' table, aliased as T1.", "A JOIN operation is performed between the 'salary' table and the 'team' table based on the team identifier.", "A condition is added to filter the results based on the specified team name using a placeholder for string values."], "gold_sql": "SELECT avg(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings'", "source_tables": ["team", "salary"], "description": "This virtual table calculates the average salary of players from a specific team in the salary records. The placeholder in the WHERE clause represents the name of the team for which the average salary is being calculated.", "virtual_table": "SELECT avg(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3667", "db_id": "baseball_1", "question": "How many times did Boston Red Stockings lose in 2009 postseason?", "rationale": ["The query identifies the relevant tables, 'postseason' and 'team'.", "It counts the total number of losses by joining the 'postseason' table with the 'team' table based on the team identifier.", "The WHERE clause filters the results to include only the specified team name and year using placeholders for string and numeric values."], "gold_sql": "SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' AND T1.year = 2009;", "source_tables": ["postseason", "team"], "description": "This virtual table provides the count of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.", "virtual_table": "SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3668", "db_id": "baseball_1", "question": "Count the number of times the team \"Boston Red Stockings\" lost in 2009 postseason.", "rationale": ["The query identifies the relevant tables, 'postseason' and 'team'.", "It uses a JOIN operation to connect the 'postseason' table with the 'team' table based on the losing team's identifier.", "The SELECT statement counts the number of records that match the specified team name and year, using placeholders for these values."], "gold_sql": "SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' AND T1.year = 2009;", "source_tables": ["postseason", "team"], "description": "This virtual table provides the count of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.", "virtual_table": "SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3679", "db_id": "baseball_1", "question": "How many players were in the team Boston Red Stockings in 2000?", "rationale": ["The query identifies the relevant tables, 'salary' and 'team'.", "It uses a JOIN operation to connect the salary records with the corresponding team based on the team identifier.", "The SELECT statement counts the number of salary records that match the specified team name and year, using placeholders for these values."], "gold_sql": "SELECT count(*) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings' AND T1.year  =  2000", "source_tables": ["team", "salary"], "description": "This virtual table provides the total count of salary records for a specific team in a given year. The placeholders represent the team's name and the year for which the salary data is being queried.", "virtual_table": "SELECT count(*) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3674", "db_id": "baseball_1", "question": "How many times in total did the team Boston Red Stockings participate in postseason games?", "rationale": ["The query identifies the relevant tables, which are 'postseason' and 'team'.", "It uses a UNION to combine results from two SELECT statements: one for winning teams and one for losing teams.", "The JOIN operation links the 'postseason' table with the 'team' table based on the winning and losing team identifiers.", "The WHERE clause filters the results based on the specified team name using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM ( SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' UNION SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' );", "source_tables": ["postseason", "team"], "description": "This virtual table counts the total number of postseason appearances for a specific team, including both wins and losses. It combines data from the 'postseason' table and the 'team' table, filtering by the team's name to identify both winning and losing records in the postseason.", "virtual_table": "SELECT count(*) FROM ( SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] );"}
{"sample_id": "train.3673", "db_id": "baseball_1", "question": "What is the total number of postseason games that team Boston Red Stockings participated in?", "rationale": ["The query identifies the relevant tables, which are 'postseason' and 'team'.", "It uses a UNION to combine results from two SELECT statements: one for winning teams and one for losing teams.", "The JOIN condition links the 'team_id_winner' and 'team_id_loser' from the 'postseason' table to the 'team_id_br' in the 'team' table.", "The WHERE clause filters the results based on the specified team name using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM ( SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' UNION SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' );", "source_tables": ["postseason", "team"], "description": "This virtual table counts the total number of postseason appearances for a specific team, including both wins and losses. It combines data from the 'postseason' table and the 'team' table, filtering by the team's name to include both winning and losing records.", "virtual_table": "SELECT count(*) FROM ( SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] );"}
{"sample_id": "train.3680", "db_id": "baseball_1", "question": "How many players did Boston Red Stockings have in 2000?", "rationale": ["The query identifies the relevant tables, 'salary' and 'team'.", "It uses a JOIN operation to connect the salary records with the corresponding team based on the team identifier.", "The SELECT statement counts the total number of salary records for the specified team and year, using placeholders for the team name and year."], "gold_sql": "SELECT count(*) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings' AND T1.year  =  2000", "source_tables": ["team", "salary"], "description": "This virtual table provides the total count of salary records for a specific team in a given year. The placeholders represent the team's name and the year for which the salary data is being queried.", "virtual_table": "SELECT count(*) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.142", "db_id": "bike_1", "question": "What are the ids of the stations in San Francisco that normally have more than 10 bikes available?", "rationale": ["The query is identifying the relevant tables, which are 'station' and 'status'.", "Select the 'id' from the 'station' table where the 'city' matches a specified value using a placeholder for string values.", "Use the INTERSECT operator to find common station IDs from the 'status' table that meet the condition of having an average number of available bikes greater than a specified number.", "The GROUP BY clause is used to group the results by 'station_id' and the HAVING clause filters these groups based on the average number of bikes available."], "gold_sql": "SELECT id FROM station WHERE city  =  'San Francisco' INTERSECT SELECT station_id FROM status GROUP BY station_id HAVING avg(bikes_available)  >  10", "source_tables": ["status", "station"], "description": "This virtual table identifies the unique station identifiers from the 'station' table located in a specific city, which also have an average number of available bikes greater than a specified threshold. The placeholders in the WHERE and HAVING clauses represent the city name and the minimum average bikes available, respectively.", "virtual_table": "SELECT id FROM station WHERE city  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT station_id FROM status GROUP BY station_id HAVING avg(bikes_available)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.195", "db_id": "bike_1", "question": "Find all the zip codes in which the max dew point have never reached 70.", "rationale": ["The query is identifying the relevant table, which is 'weather'.", "It selects distinct zip codes from the 'weather' table.", "The EXCEPT clause is used to exclude zip codes that have a maximum dew point above a certain value, which is represented by a placeholder for numeric values."], "gold_sql": "SELECT DISTINCT zip_code FROM weather EXCEPT SELECT DISTINCT zip_code FROM weather WHERE max_dew_point_f  >=  70", "source_tables": ["weather"], "description": "The virtual table provides a list of unique zip codes from the 'weather' table that do not have any recorded maximum dew point above a specified threshold. The placeholder in the query allows users to specify the maximum dew point value to filter the results accordingly.", "virtual_table": "SELECT DISTINCT zip_code FROM weather EXCEPT SELECT DISTINCT zip_code FROM weather WHERE max_dew_point_f  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.208", "db_id": "bike_1", "question": "What are the names of the stations that are located in Palo Alto but have never been the ending point of the trips", "rationale": ["The query identifies the relevant table, which is 'station', to retrieve the names of bike stations.", "It filters the results based on the specified city using a placeholder for string values.", "The EXCEPT clause is used to exclude end station names from the 'trip' table that have been used more than a specified number of times, using a placeholder for numeric values."], "gold_sql": "SELECT name FROM station WHERE city  =  'Palo Alto' EXCEPT SELECT end_station_name FROM trip GROUP BY end_station_name HAVING count(*)  >  100", "source_tables": ["trip", "station"], "description": "This virtual table lists the names of bike stations located in a specific city, excluding those stations that have been used as end stations for a number of trips exceeding a specified threshold. The placeholders in the WHERE clause represent the city name and the trip count limit.", "virtual_table": "SELECT name FROM station WHERE city  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT end_station_name FROM trip GROUP BY end_station_name HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.134", "db_id": "bike_1", "question": "What are the start station's name and id for the one that had the most start trips in August?", "rationale": ["The query identifies the relevant table, which is 'trip'.", "Select the columns to display, 'start_station_name' and 'start_station_id'.", "Add a condition to filter the 'start_date' column for the specified date using a placeholder for string values.", "Group the results by 'start_station_name' to aggregate the trip counts for each station.", "Order the results by the count of trips in descending order to highlight the most active stations.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE '8/%' GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["trip"], "description": "This virtual table provides a summary of bike trips, specifically focusing on the starting station names and their corresponding identifiers. The query filters trips based on a specified start date, grouping the results by the starting station name to count the number of trips from each station. The results are then ordered by the trip count in descending order, allowing users to see which stations had the most trips on that date, with a limit on the number of results returned.", "virtual_table": "SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE [PLACEHOLDER-TYPE:STRING] GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.155", "db_id": "bike_1", "question": "Give me ids for all the trip that took place in a zip code area with average mean temperature above 60.", "rationale": ["The query identifies the relevant tables, which are 'trip' and 'weather'.", "It selects the unique trip identifiers from the 'trip' table.", "A JOIN operation is performed on the 'zip_code' column to link trips with their corresponding weather reports.", "The results are grouped by 'zip_code' to aggregate the weather data for each zip code.", "The HAVING clause filters the groups to include only those with an average mean temperature greater than a specified number, using a placeholder for numeric values."], "gold_sql": "SELECT T1.id FROM trip AS T1 JOIN weather AS T2 ON T1.zip_code  =  T2.zip_code GROUP BY T2.zip_code HAVING avg(T2.mean_temperature_f)  >  60", "source_tables": ["weather", "trip"], "description": "The virtual table provides a list of unique trip identifiers from the 'trip' table for users whose starting zip code corresponds to weather reports with an average mean temperature exceeding a specified threshold. The placeholder in the HAVING clause represents the temperature limit that needs to be surpassed.", "virtual_table": "SELECT T1.id FROM trip AS T1 JOIN weather AS T2 ON T1.zip_code  =  T2.zip_code GROUP BY T2.zip_code HAVING avg(T2.mean_temperature_f)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.133", "db_id": "bike_1", "question": "Which start station had the most trips starting from August? Give me the name and id of the station.", "rationale": ["The query identifies the relevant table, which is 'trip'.", "Select the columns to display, 'start_station_name' and 'start_station_id'.", "Add a condition to filter the 'start_date' column for the specified date using a placeholder for string values.", "Group the results by 'start_station_name' to aggregate the trip counts for each station.", "Order the results by the count of trips in descending order to highlight the most active stations.", "Limit the number of results returned to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE '8/%' GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["trip"], "description": "This virtual table provides a summary of bike trips, specifically focusing on the starting station's name and its identifier. The query filters trips based on a specified start date, grouping the results by the starting station name to count the number of trips originating from each station. The results are then ordered by the trip count in descending order, allowing users to see which stations had the most trips on that date, with a limit on the number of results returned.", "virtual_table": "SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE [PLACEHOLDER-TYPE:STRING] GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.172", "db_id": "bike_1", "question": "What are the names of all stations that have more than 10 bikes available and are not located in San Jose?", "rationale": ["The query identifies the relevant tables, which are 'station' and 'status'.", "It selects the 'name' column from the 'station' table.", "A JOIN operation is performed between 'station' and 'status' on the station ID to combine relevant data.", "The results are grouped by 'station_id' to calculate the average number of bikes available at each station.", "The HAVING clause filters the results to include only those stations where the average number of available bikes exceeds a specified number using a placeholder.", "The EXCEPT clause is used to exclude any stations that are located in a specified city, with the city name represented as a placeholder."], "gold_sql": "SELECT T1.name FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(bikes_available)  >  10 EXCEPT SELECT name FROM station WHERE city  =  'San Jose'", "source_tables": ["status", "station"], "description": "The virtual table provides a list of bike station names that have an average number of available bikes exceeding a specified threshold. It excludes stations located in a specific city. The placeholders in the HAVING clause and the EXCEPT clause represent the average number of bikes and the city name, respectively.", "virtual_table": "SELECT T1.name FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(bikes_available)  >  [PLACEHOLDER-TYPE:NUMBER] EXCEPT SELECT name FROM station WHERE city  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.156", "db_id": "bike_1", "question": "For each zip code, find the ids of all trips that have a higher average mean temperature above 60?", "rationale": ["The query identifies the relevant tables, which are 'trip' and 'weather'.", "It selects the unique trip identifiers from the 'trip' table (aliased as T1).", "A JOIN operation is performed between 'trip' and 'weather' on the zip code to correlate trips with weather data.", "The results are grouped by zip code to aggregate the weather data for each area.", "The HAVING clause filters the groups to include only those with an average mean temperature above a specified numeric threshold using a placeholder."], "gold_sql": "SELECT T1.id FROM trip AS T1 JOIN weather AS T2 ON T1.zip_code  =  T2.zip_code GROUP BY T2.zip_code HAVING avg(T2.mean_temperature_f)  >  60", "source_tables": ["weather", "trip"], "description": "The virtual table provides a list of unique trip identifiers from the 'trip' table for users whose starting zip code corresponds to weather reports with an average mean temperature exceeding a specified threshold. The placeholder in the HAVING clause represents the temperature limit that needs to be surpassed.", "virtual_table": "SELECT T1.id FROM trip AS T1 JOIN weather AS T2 ON T1.zip_code  =  T2.zip_code GROUP BY T2.zip_code HAVING avg(T2.mean_temperature_f)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.146", "db_id": "bike_1", "question": "What are the 3 most common cloud covers in the zip code of 94107?", "rationale": ["The query identifies the relevant table, which is 'weather'.", "Select the column to display, 'cloud_cover'.", "Add a condition to filter the 'zip_code' column for the specified zip code using a placeholder for numeric values.", "Group the results by 'cloud_cover' to aggregate the data.", "Order the results by the count of occurrences of each cloud cover value in descending order.", "Limit the number of results returned based on the specified limit using a placeholder for numeric values."], "gold_sql": "SELECT cloud_cover FROM weather WHERE zip_code  =  94107 GROUP BY cloud_cover ORDER BY COUNT (*) DESC LIMIT 3", "source_tables": ["weather"], "description": "The virtual table provides information about the cloud cover recorded in weather reports for a specific zip code. The placeholder in the WHERE clause represents the zip code of interest, while the LIMIT placeholder allows the user to specify the maximum number of results to return, sorted by the frequency of each cloud cover value.", "virtual_table": "SELECT cloud_cover FROM weather WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY cloud_cover ORDER BY COUNT (*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.198", "db_id": "bike_1", "question": "What are the ids of all trips that had a duration as long as the average trip duration in the zip code 94103?", "rationale": ["The query identifies the relevant table, which is 'trip'.", "It selects the 'id' column to display the unique identifiers of the trips.", "A subquery is used to calculate the average duration of trips filtered by a specific zip code, using a placeholder for numeric values in the WHERE clause."], "gold_sql": "SELECT id FROM trip WHERE duration  >=  (SELECT avg(duration) FROM trip WHERE zip_code  =  94103)", "source_tables": ["trip"], "description": "This virtual table lists the unique identifiers of trips from the 'trip' table that have a duration greater than or equal to the average duration of trips associated with a specific zip code. The placeholder in the subquery represents the zip code for which the average trip duration is calculated.", "virtual_table": "SELECT id FROM trip WHERE duration  >=  (SELECT avg(duration) FROM trip WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.204", "db_id": "bike_1", "question": "What are the different ids and names of the stations that have had more than 12 bikes available?", "rationale": ["The query identifies the relevant tables, which are 'station' and 'status'.", "It selects distinct columns to display, specifically the 'id' and 'name' of the stations.", "A JOIN operation is performed on the 'station' table and the 'status' table using the station's unique identifier.", "A condition is added to filter the results based on the number of bikes available, using a placeholder for numeric values."], "gold_sql": "SELECT DISTINCT T1.id ,  T1.name FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id WHERE T2.bikes_available  >  12", "source_tables": ["status", "station"], "description": "The virtual table provides a list of unique bike stations that currently have a specified number of bikes available. It combines data from the 'station' table, which includes details about each station such as its unique identifier and name, with the 'status' table that tracks the availability of bikes at each station. The placeholder in the WHERE clause represents the minimum number of bikes that must be available for the station to be included in the results.", "virtual_table": "SELECT DISTINCT T1.id ,  T1.name FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id WHERE T2.bikes_available  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.191", "db_id": "bike_1", "question": "For each station, find its latitude and the minimum duration of trips that ended at the station.", "rationale": ["The query identifies the relevant tables, which are 'station' and 'trip'.", "It selects the 'name' and 'lat' columns from the 'station' table (aliased as T1).", "It calculates the minimum trip duration from the 'trip' table (aliased as T2) for trips that ended at each station.", "The JOIN operation links the two tables based on the station ID, ensuring that only trips ending at the corresponding stations are considered.", "The GROUP BY clause groups the results by the end station ID, allowing for the aggregation of trip durations for each station."], "gold_sql": "SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id", "source_tables": ["trip", "station"], "description": "This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The placeholder in the SELECT statement allows for the retrieval of specific station details and trip durations based on the relationships defined in the schema.", "virtual_table": "SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id"}
{"sample_id": "train.160", "db_id": "bike_1", "question": "Which days had a minimum dew point smaller than any day in zip code 94107, and in which zip codes were those measurements taken?", "rationale": ["The query identifies the relevant table, which is 'weather'.", "Select the columns to display, 'date' and 'zip_code'.", "Add a condition to filter the 'min_dew_point_f' column to be less than a subquery result.", "The subquery selects the minimum 'min_dew_point_f' from the 'weather' table for a specified zip code using a placeholder for numeric values."], "gold_sql": "SELECT date ,  zip_code FROM weather WHERE min_dew_point_f  <  (SELECT min(min_dew_point_f) FROM weather WHERE zip_code  =  94107)", "source_tables": ["weather"], "description": "This virtual table provides the dates and zip codes of weather reports where the minimum dew point is less than the minimum dew point recorded for a specific zip code. The placeholder in the subquery represents the zip code for which the minimum dew point is being compared.", "virtual_table": "SELECT date ,  zip_code FROM weather WHERE min_dew_point_f  <  (SELECT min(min_dew_point_f) FROM weather WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.137", "db_id": "bike_1", "question": "How many days had both mean humidity above 50 and mean visibility above 8?", "rationale": ["The query identifies the relevant table, which is 'weather'.", "It counts the total number of records that meet specific conditions.", "The conditions filter the records based on mean humidity and mean visibility, using placeholders for numeric values."], "gold_sql": "SELECT COUNT(*) FROM weather WHERE mean_humidity  >  50 AND mean_visibility_miles  >  8", "source_tables": ["weather"], "description": "This virtual table provides the count of weather reports from the 'weather' table where the mean humidity exceeds a specified threshold and the mean visibility in miles is also above a certain level. The placeholders in the WHERE clause represent the numeric values for mean humidity and mean visibility that the user can define.", "virtual_table": "SELECT COUNT(*) FROM weather WHERE mean_humidity  >  [PLACEHOLDER-TYPE:NUMBER] AND mean_visibility_miles  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.211", "db_id": "bike_1", "question": "What is the average latitude and longitude of the starting points of all trips?", "rationale": ["The query identifies the relevant tables, which are 'station' and 'trip'.", "It selects the average latitude and longitude from the 'station' table.", "A JOIN operation is performed to link the 'station' table with the 'trip' table based on the station ID, specifically focusing on trips that have started at those stations."], "gold_sql": "SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id", "source_tables": ["trip", "station"], "description": "This virtual table calculates the average latitude and longitude of bike stations from the 'station' table where trips have started. The placeholders represent the necessary identifiers for the stations involved in the trips.", "virtual_table": "SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id"}
{"sample_id": "train.188", "db_id": "bike_1", "question": "What are the ids of the trips that lasted the longest and how long did they last?", "rationale": ["The query identifies the relevant table, which is 'trip'.", "Select the columns to display, 'id' and 'duration'.", "Order the results by the 'duration' column in descending order to show the longest trips first.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT id ,  duration FROM trip ORDER BY duration DESC LIMIT 3", "source_tables": ["trip"], "description": "This virtual table provides a list of trips, displaying their unique identifiers and durations. The results are ordered by the duration of the trips in descending order, with a limit set by a placeholder for the number of trips to return.", "virtual_table": "SELECT id ,  duration FROM trip ORDER BY duration DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.164", "db_id": "bike_1", "question": "What is the id of the trip that started from the station with the highest dock count?", "rationale": ["The query identifies the relevant tables, which are 'trip' and 'station'.", "It selects the 'id' column from the 'trip' table, which represents unique trip identifiers.", "A JOIN operation is performed between the 'trip' table and the 'station' table based on the matching 'start_station_id' and 'id' columns.", "The results are ordered by the 'dock_count' column from the 'station' table in descending order to prioritize stations with more docks.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT 1", "source_tables": ["trip", "station"], "description": "The virtual table provides a list of trip identifiers from the 'trip' table, specifically for trips that started at various bike stations. The results are ordered by the number of docks available at each station in descending order, allowing users to see which stations have the most docks available. The placeholder in the LIMIT clause indicates the maximum number of trip IDs to return.", "virtual_table": "SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.153", "db_id": "bike_1", "question": "When and in what zip code did max temperature reach 80?", "rationale": ["The query identifies the relevant table, which is 'weather'.", "Select the columns to display, 'date' and 'zip_code'.", "Add a condition to filter the 'max_temperature_f' column for values greater than or equal to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT date ,  zip_code FROM weather WHERE max_temperature_f  >=  80", "source_tables": ["weather"], "description": "This virtual table provides the dates and zip codes of weather reports where the maximum temperature recorded is above a specified threshold. The placeholder in the WHERE clause represents the minimum temperature value to filter the results.", "virtual_table": "SELECT date ,  zip_code FROM weather WHERE max_temperature_f  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.212", "db_id": "bike_1", "question": "What is the average latitude and longitude of all starting stations for the trips?", "rationale": ["The query identifies the relevant tables, which are 'station' and 'trip'.", "It selects the average latitude and longitude from the 'station' table.", "A JOIN operation is performed between the 'station' and 'trip' tables based on the condition that the station's ID matches the start station ID in the trip table."], "gold_sql": "SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id", "source_tables": ["trip", "station"], "description": "This virtual table calculates the average latitude and longitude of bike stations from the 'station' table where trips have started. The placeholders in the JOIN clause represent the relationship between the station and trip tables based on the station's unique identifier.", "virtual_table": "SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id"}
{"sample_id": "train.154", "db_id": "bike_1", "question": "What zip codes have a station with a max temperature greater than or equal to 80 and when did it reach that temperature?", "rationale": ["The query identifies the relevant table, which is 'weather'.", "Select the columns to display, 'date' and 'zip_code'.", "Add a condition to filter the 'max_temperature_f' column for values greater than or equal to the specified temperature using a placeholder for numeric values."], "gold_sql": "SELECT date ,  zip_code FROM weather WHERE max_temperature_f  >=  80", "source_tables": ["weather"], "description": "This virtual table provides the dates and zip codes of weather reports where the maximum temperature reached a specified threshold. The placeholder in the WHERE clause represents the minimum temperature value to filter the results.", "virtual_table": "SELECT date ,  zip_code FROM weather WHERE max_temperature_f  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2402", "db_id": "candidate_poll", "question": "Please list support, consider, and oppose rates for each candidate in ascending order by unsure rate.", "rationale": ["The query identifies the relevant table, which is 'candidate'.", "Select the columns to display: 'Support_rate', 'Consider_rate', and 'Oppose_rate'.", "Add an ORDER BY clause to sort the results based on the 'Unsure_rate' column, using a placeholder for the sorting criteria."], "gold_sql": "SELECT Support_rate ,  Consider_rate ,  Oppose_rate FROM candidate ORDER BY unsure_rate", "source_tables": ["candidate"], "description": "This virtual table provides the support, consideration, and opposition rates of candidates from the 'candidate' table. The results are ordered by the rate of respondents who are unsure about the candidates, represented by a placeholder in the ORDER BY clause.", "virtual_table": "SELECT Support_rate ,  Consider_rate ,  Oppose_rate FROM candidate ORDER BY unsure_rate"}
{"sample_id": "train.2403", "db_id": "candidate_poll", "question": "What are the support, consider, and oppose rates of each candidate, ordered ascending by their unsure rate?", "rationale": ["The query identifies the relevant table, which is 'candidate'.", "Select the columns to display: 'Support_rate', 'Consider_rate', and 'Oppose_rate'.", "Add an ORDER BY clause to sort the results based on the 'Unsure_rate' column, which is also included as a placeholder for clarity."], "gold_sql": "SELECT Support_rate ,  Consider_rate ,  Oppose_rate FROM candidate ORDER BY unsure_rate", "source_tables": ["candidate"], "description": "This virtual table provides the support, consideration, and opposition rates of candidates from the 'candidate' table, ordered by the rate of respondents who are unsure about the candidates. The placeholders in the SELECT clause represent the respective rates of support, consideration, and opposition.", "virtual_table": "SELECT Support_rate ,  Consider_rate ,  Oppose_rate FROM candidate ORDER BY unsure_rate"}
{"sample_id": "train.2396", "db_id": "candidate_poll", "question": "Which poll resource provided the most number of candidate information?", "rationale": ["The query identifies the relevant table, which is 'candidate'.", "It selects the 'poll_source' column to display the different sources of poll data.", "The GROUP BY clause is used to group the results by 'poll_source' to aggregate the data.", "The ORDER BY clause sorts the grouped results by the count of occurrences in descending order.", "The LIMIT clause uses a placeholder to allow the user to specify how many poll sources they want to retrieve."], "gold_sql": "SELECT poll_source FROM candidate GROUP BY poll_source ORDER BY count(*) DESC LIMIT 1", "source_tables": ["candidate"], "description": "This virtual table summarizes the various sources of poll data for candidates, grouped by the source name. The placeholder in the LIMIT clause allows the user to specify the maximum number of poll sources to retrieve, based on their preference.", "virtual_table": "SELECT poll_source FROM candidate GROUP BY poll_source ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2418", "db_id": "candidate_poll", "question": "which gender got the highest average uncertain ratio.", "rationale": ["The query identifies the relevant tables, 'people' and 'candidate', and establishes a join condition based on the 'People_ID'.", "It selects the 'sex' column from the 'people' table to analyze the gender distribution.", "The query groups the results by 'sex' to aggregate the data accordingly.", "It orders the results by the average of the 'unsure_rate' from the 'candidate' table in descending order to prioritize the most uncertain groups.", "The LIMIT clause uses a placeholder to allow the user to specify how many gender groups to return."], "gold_sql": "SELECT t1.sex FROM people AS t1 JOIN candidate AS t2 ON t1.people_id  =  t2.people_id GROUP BY t1.sex ORDER BY avg(t2.unsure_rate) DESC LIMIT 1", "source_tables": ["candidate", "people"], "description": "This virtual table provides the gender distribution of candidates based on the poll data. It joins the 'people' and 'candidate' tables to analyze the support rates, specifically focusing on the average unsure rate of respondents. The placeholder in the LIMIT clause allows for specifying the number of gender groups to return.", "virtual_table": "SELECT t1.sex FROM people AS t1 JOIN candidate AS t2 ON t1.people_id  =  t2.people_id GROUP BY t1.sex ORDER BY avg(t2.unsure_rate) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2398", "db_id": "candidate_poll", "question": "what are the top 3 highest support rates?", "rationale": ["The query identifies the relevant table, which is 'candidate'.", "It selects the 'support_rate' column to display the support rates of candidates.", "The results are ordered by 'support_rate' in descending order to show the highest rates first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT support_rate FROM candidate ORDER BY support_rate DESC LIMIT 3", "source_tables": ["candidate"], "description": "This virtual table provides the support rates of candidates from the 'candidate' table, sorted in descending order. The placeholder in the LIMIT clause indicates the maximum number of support rates to retrieve.", "virtual_table": "SELECT support_rate FROM candidate ORDER BY support_rate DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.161", "db_id": "car_1", "question": "How many countries has more than 2 car makers ?", "rationale": ["The query identifies the relevant tables, which are 'countries' and 'car_makers'.", "It performs a join operation on the 'countryid' from 'countries' and 'country' from 'car_makers' to associate car makers with their countries.", "The count of car makers is calculated for each country using the COUNT function.", "The results are grouped by 'countryid' to aggregate the counts per country.", "A HAVING clause is added to filter the results, ensuring only countries with a count of car makers greater than a specified number are included, using a placeholder for numeric values."], "gold_sql": "select count(*) from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  2", "source_tables": ["car_makers", "countries"], "description": "This virtual table provides a count of car makers grouped by their respective countries from the 'countries' and 'car_makers' tables. The placeholder in the HAVING clause represents the minimum number of car makers that must be present in a country for it to be included in the results.", "virtual_table": "select count(*) from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.162", "db_id": "car_1", "question": "What is the number of countries with more than 2 car makers ?", "rationale": ["The query identifies the relevant tables, which are 'countries' and 'car_makers'.", "It performs a join operation on the 'countryid' from 'countries' and 'country' from 'car_makers' to associate car makers with their respective countries.", "The count of car makers is calculated for each country using the COUNT function.", "The results are grouped by 'countryid' to aggregate the counts per country.", "A HAVING clause is added to filter the results, ensuring only countries with a count of car makers greater than a specified numeric threshold are included, using a placeholder for the threshold."], "gold_sql": "select count(*) from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  2", "source_tables": ["car_makers", "countries"], "description": "This virtual table provides a count of car makers grouped by their respective countries from the 'countries' and 'car_makers' tables. The placeholder in the HAVING clause represents a numeric threshold for the minimum number of car makers that must be present in a country for it to be included in the results.", "virtual_table": "select count(*) from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.175", "db_id": "car_1", "question": "Which are the car makers which produce at least 2 models and more than 3 car makers ? List the id and the maker .", "rationale": ["The query identifies the relevant tables, which are 'car_makers', 'model_list', and 'car_names'.", "It selects the 'id' and 'maker' columns from the 'car_makers' table.", "The first part of the query groups the results by 'id' and filters car makers based on the count of their models using a placeholder for numeric values.", "The second part of the query intersects with another selection that counts distinct car names associated with the models, again filtering by a numeric placeholder.", "The use of 'HAVING' ensures that only car makers meeting the specified counts are included in the final result."], "gold_sql": "select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker group by t1.id having count(*)  >=  2 intersect select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker join car_names as t3 on t2.model  =  t3.model group by t1.id having count(*)  >  3;", "source_tables": ["car_makers", "car_names", "model_list"], "description": "This virtual table provides a list of car makers who have produced a significant number of car models, as well as those who have a specific number of distinct car names associated with their models. The placeholders in the HAVING clauses represent the minimum counts of models and names required for inclusion in the results.", "virtual_table": "select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker group by t1.id having count(*)  >=  [PLACEHOLDER-TYPE:NUMBER] intersect select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker join car_names as t3 on t2.model  =  t3.model group by t1.id having count(*)  >  [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.102", "db_id": "car_1", "question": "What is the maker of the carr produced in the earliest year and what year was it?", "rationale": ["The query identifies the relevant tables, which are 'cars_data' and 'car_names'.", "It selects the 'Make' from 'car_names' and 'Year' from 'cars_data'.", "A JOIN operation is performed on the 'Id' from 'cars_data' and 'MakeId' from 'car_names' to link the two tables.", "A subquery is used to find the minimum year from the 'cars_data' table, ensuring that only the earliest manufactured cars are included in the results."], "gold_sql": "SELECT T2.Make ,  T1.Year FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T1.Year  =  (SELECT min(YEAR) FROM CARS_DATA);", "source_tables": ["cars_data", "car_names"], "description": "The virtual table provides the make of cars and their manufacturing year from the 'cars_data' and 'car_names' tables. The query filters the results to show only the car models that were manufactured in the earliest year recorded in the database.", "virtual_table": "SELECT T2.Make ,  T1.Year FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T1.Year  =  (SELECT min(YEAR) FROM CARS_DATA);"}
{"sample_id": "dev.171", "db_id": "car_1", "question": "Which models are lighter than 3500 but not built by the 'Ford Motor Company'?", "rationale": ["The query identifies the relevant tables: 'model_list', 'car_names', 'cars_data', and 'car_makers'.", "It selects distinct car models from the 'model_list' table.", "The JOIN operations link the tables based on their relationships, ensuring that the correct data is combined.", "A condition is added to filter the results based on the weight of the cars, using a placeholder for numeric values.", "Another condition is included to exclude car makers based on their full name, using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.Model  =  T2.Model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.Id JOIN CAR_MAKERS AS T4 ON T1.Maker  =  T4.Id WHERE T3.weight  <  3500 AND T4.FullName != 'Ford Motor Company';", "source_tables": ["car_makers", "model_list", "car_names", "cars_data"], "description": "This virtual table provides a list of distinct car models from the 'model_list' table that meet specific criteria. It filters the results based on the weight of the cars from the 'cars_data' table, ensuring that only cars lighter than a specified weight are included. Additionally, it excludes car makers based on their full name from the 'car_makers' table, allowing for a focused selection of models that do not belong to certain manufacturers. The placeholders in the WHERE clause represent the maximum weight and the name of the car maker to be excluded.", "virtual_table": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.Model  =  T2.Model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.Id JOIN CAR_MAKERS AS T4 ON T1.Maker  =  T4.Id WHERE T3.weight  <  [PLACEHOLDER-TYPE:NUMBER] AND T4.FullName != [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "dev.130", "db_id": "car_1", "question": "What are the names of all European countries with at least 3 manufacturers?", "rationale": ["The query identifies the relevant tables: 'countries', 'continents', and 'car_makers'.", "It selects the 'CountryName' from the 'countries' table.", "The JOIN operations link the 'countries' table to the 'continents' table based on the continent identifier and to the 'car_makers' table based on the country identifier.", "A condition is added to filter the results by a specific continent using a placeholder for string values.", "The GROUP BY clause is used to group the results by 'CountryName'.", "The HAVING clause filters the grouped results to include only those countries that have a count of car makers greater than or equal to a specified number, using a placeholder for numeric values."], "gold_sql": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  'europe' GROUP BY T1.CountryName HAVING count(*)  >=  3;", "source_tables": ["continents", "car_makers", "countries"], "description": "This virtual table provides a list of country names from the 'countries' table that belong to a specific continent. It joins the 'continents' table to filter countries by continent and the 'car_makers' table to ensure that only countries with a certain number of car makers are included. The placeholders in the HAVING clause represent the continent's name and the minimum count of car makers required.", "virtual_table": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.CountryName HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.141", "db_id": "car_1", "question": "Which model has the most version(make) of cars?", "rationale": ["The query identifies the relevant table, which is 'car_names'.", "It selects the 'Model' column to display the names of car models.", "The GROUP BY clause is used to group the results by the 'Model' column, allowing for aggregation.", "The ORDER BY clause sorts the grouped results by the count of each model in descending order, ensuring the most common models appear first.", "The LIMIT clause includes a placeholder for a numeric value, allowing the user to specify how many of the top models they wish to retrieve."], "gold_sql": "SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["car_names"], "description": "The virtual table provides a list of car models from the 'car_names' table, grouped by model name. The results are ordered by the frequency of each model, showing the most common models at the top. The placeholder in the LIMIT clause allows the user to specify the maximum number of models to return.", "virtual_table": "SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.142", "db_id": "car_1", "question": "What model has the most different versions?", "rationale": ["The query identifies the relevant table, which is 'car_names'.", "Select the 'Model' column to display the car models.", "Group the results by 'Model' to aggregate the data based on model names.", "Order the results by the count of occurrences of each model in descending order to highlight the most common models.", "Limit the number of results returned using a placeholder for numeric values, allowing users to specify how many top models they want to see."], "gold_sql": "SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["car_names"], "description": "The virtual table presents a list of car models from the 'car_names' table, grouped by model name. The results are ordered by the frequency of each model's occurrence, allowing users to identify the most common car models. The placeholder in the LIMIT clause specifies the maximum number of results to return, which can be adjusted as needed.", "virtual_table": "SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.104", "db_id": "car_1", "question": "What are the different models for the cards produced after 1980?", "rationale": ["The query identifies the relevant tables: 'model_list', 'car_names', and 'cars_data'.", "It selects distinct car models from the 'model_list' table.", "The JOIN operations link the 'model_list' to 'car_names' based on the model name, and then to 'cars_data' based on the MakeId.", "A condition is added to filter the results to only include models manufactured after a specified year using a placeholder for numeric values."], "gold_sql": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  1980;", "source_tables": ["model_list", "car_names", "cars_data"], "description": "The virtual table lists distinct car models from the 'model_list' table that are associated with car names in the 'car_names' table and have been manufactured after a specific year. The placeholder in the WHERE clause represents the year of manufacture.", "virtual_table": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.157", "db_id": "car_1", "question": "For model volvo, how many cylinders does the car with the least accelerate have?", "rationale": ["The query identifies the relevant tables, 'cars_data' and 'car_names', and establishes a join between them based on the matching identifiers.", "It selects the 'cylinders' column from the 'cars_data' table.", "A condition is added to filter results based on the specified car model using a placeholder for string values.", "The results are ordered by the 'accelerate' column in ascending order to show the fastest accelerating cars first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  'volvo' ORDER BY T1.accelerate ASC LIMIT 1;", "source_tables": ["cars_data", "car_names"], "description": "This virtual table provides information about the number of cylinders in cars from the 'cars_data' table, specifically for a given car model. The placeholder in the WHERE clause represents the name of the car model, while the placeholder in the LIMIT clause indicates the maximum number of results to return, allowing for a sorted list based on acceleration time.", "virtual_table": "SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.accelerate ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.97", "db_id": "car_1", "question": "Find the model of the car whose weight is below the average weight.", "rationale": ["The query identifies the relevant tables, which are 'car_names' and 'cars_data'.", "It selects the 'model' column from the 'car_names' table.", "A JOIN operation is performed between 'car_names' and 'cars_data' on the 'MakeId' and 'Id' columns to link car models with their respective data.", "A condition is added to filter the results where the weight of the cars is less than the average weight calculated from the 'cars_data' table."], "gold_sql": "SELECT T1.model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Weight  <  (SELECT avg(Weight) FROM CARS_DATA)", "source_tables": ["car_names", "cars_data"], "description": "The virtual table lists car models from the 'car_names' table that have a weight less than the average weight of all cars in the 'cars_data' table. The placeholder in the WHERE clause represents the condition for filtering based on the average weight.", "virtual_table": "SELECT T1.model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Weight  <  (SELECT avg(Weight) FROM CARS_DATA)"}
{"sample_id": "dev.121", "db_id": "car_1", "question": "What are all the makers and models?", "rationale": ["The query identifies the relevant table, which is 'model_list'.", "Select the columns to display, 'Maker' and 'Model'.", "No filtering conditions are applied, so all records from the 'model_list' table will be retrieved."], "gold_sql": "SELECT Maker ,  Model FROM MODEL_LIST;", "source_tables": ["model_list"], "description": "The virtual table provides a list of car makers along with their corresponding car models from the 'model_list' table. The placeholders in the SELECT statement represent the columns to be retrieved, specifically the maker's name and the model name.", "virtual_table": "SELECT Maker ,  Model FROM MODEL_LIST;"}
{"sample_id": "dev.122", "db_id": "car_1", "question": "What are the makers and models?", "rationale": ["The query identifies the relevant table, which is 'model_list'.", "Select the columns to display, 'Maker' and 'Model'.", "This query retrieves all car makers and their models without any filtering conditions, allowing for a comprehensive view of the data."], "gold_sql": "SELECT Maker ,  Model FROM MODEL_LIST;", "source_tables": ["model_list"], "description": "The virtual table provides a list of car makers along with their corresponding car models from the 'model_list' table. The placeholders in the SELECT statement can be modified to filter or sort the results based on specific criteria.", "virtual_table": "SELECT Maker ,  Model FROM MODEL_LIST;"}
{"sample_id": "dev.112", "db_id": "car_1", "question": "How much does the car accelerate that makes amc hornet sportabout (sw)?", "rationale": ["The query identifies the relevant tables, which are 'cars_data' and 'car_names'.", "It selects the 'Accelerate' column from the 'cars_data' table.", "A JOIN operation is performed to link 'cars_data' with 'car_names' based on the matching 'Id' and 'MakeId'.", "A condition is added to filter the results by the car make using a placeholder for string values."], "gold_sql": "SELECT T1.Accelerate FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Make  =  'amc hornet sportabout (sw)';", "source_tables": ["cars_data", "car_names"], "description": "The virtual table provides information about the acceleration times of cars from the 'cars_data' table, specifically focusing on the time taken to accelerate from 0 to 60 mph. The placeholder in the WHERE clause represents the name of the car make, allowing users to filter results based on a specific car manufacturer.", "virtual_table": "SELECT T1.Accelerate FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Make  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "dev.134", "db_id": "car_1", "question": "What is the car model with the highest mpg ?", "rationale": ["The query identifies the relevant tables, 'car_names' and 'cars_data'.", "It selects the 'model' column from the 'car_names' table.", "A join is performed between 'car_names' and 'cars_data' on the condition that 'makeid' from 'car_names' matches 'id' from 'cars_data'.", "The results are ordered by the 'mpg' column from 'cars_data' in descending order to show the most fuel-efficient models first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "select t1.model from car_names as t1 join cars_data as t2 on t1.makeid  =  t2.id order by t2.mpg desc limit 1;", "source_tables": ["car_names", "cars_data"], "description": "The virtual table lists car models from the 'car_names' table, joined with the 'cars_data' table to include their fuel efficiency (MPG). The results are ordered by MPG in descending order, and the number of results returned is limited by a placeholder for numeric values.", "virtual_table": "select t1.model from car_names as t1 join cars_data as t2 on t1.makeid  =  t2.id order by t2.mpg desc limit [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.96", "db_id": "car_1", "question": "What is the model of the car with the smallest amount of horsepower?", "rationale": ["The query identifies the relevant tables, 'car_names' and 'cars_data'.", "It selects the 'Model' column from the 'car_names' table.", "A JOIN operation is performed to connect 'car_names' with 'cars_data' based on the matching 'MakeId' and 'Id'.", "The results are ordered by the 'horsepower' column from the 'cars_data' table in ascending order.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "description": "The virtual table lists car models from the 'car_names' table, ordered by their horsepower in ascending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of results to return.", "virtual_table": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.116", "db_id": "car_1", "question": "What is the count of the car models produced in the United States?", "rationale": ["The query identifies the relevant tables: 'model_list', 'car_makers', and 'countries'.", "It uses a JOIN operation to connect 'model_list' with 'car_makers' based on the 'Maker' identifier.", "Another JOIN is performed to connect 'car_makers' with 'countries' using the 'Country' identifier.", "The query counts the number of records that match the specified country name, using a placeholder for the country name in the WHERE clause."], "gold_sql": "SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  'usa';", "source_tables": ["car_makers", "model_list", "countries"], "description": "This virtual table provides a count of car models from the 'model_list' table that are associated with car makers from a specific country. The placeholders in the WHERE clause represent the name of the country being queried.", "virtual_table": "SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.6290", "db_id": "city_record", "question": "Give me a list of cities whose temperature in Mar is lower than that in July and which have also served as host cities?", "rationale": ["The query is identifying the relevant tables, which are 'city', 'temperature', and 'hosting_city'.", "It selects the 'city' from the 'city' table where the average temperature in March is less than that in July, using a join with the 'temperature' table.", "The INTERSECT clause is used to find cities that also appear in the 'hosting_city' table, indicating they have hosted a match."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul INTERSECT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "description": "This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.", "virtual_table": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul INTERSECT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city"}
{"sample_id": "train.6291", "db_id": "city_record", "question": "Which cities have lower temperature in March than in July and have been once host cities?", "rationale": ["The query is identifying the relevant tables, which are 'city', 'temperature', and 'hosting_city'.", "It selects the 'city' from the 'city' table where the average temperature in March is less than that in July, using a join with the 'temperature' table.", "The INTERSECT clause is used to find cities that also appear in the 'hosting_city' table, indicating they have hosted a match."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul INTERSECT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "description": "This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.", "virtual_table": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul INTERSECT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city"}
{"sample_id": "train.6299", "db_id": "city_record", "question": "Which cities have regional population above 8000000 or below 5000000?", "rationale": ["The query identifies the relevant table, which is 'city'.", "It selects the 'city' column to display the names of the cities.", "The first part of the query filters cities with a regional population greater than a specified number using a placeholder.", "The second part of the query filters cities with a regional population less than a specified number using another placeholder.", "The UNION operator combines the results of both queries to provide a comprehensive list of cities based on the population criteria."], "gold_sql": "SELECT city FROM city WHERE regional_population  >  10000000 UNION SELECT city FROM city WHERE regional_population  <  5000000", "source_tables": ["city"], "description": "This virtual table provides a list of cities from the 'city' table that have a regional population either greater than or less than specified numeric values. The placeholders in the WHERE clauses represent the population thresholds for filtering the cities.", "virtual_table": "SELECT city FROM city WHERE regional_population  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT city FROM city WHERE regional_population  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6295", "db_id": "city_record", "question": "Which cities have higher temperature in Feb than in Jun or have once served as host cities?", "rationale": ["The query identifies the relevant tables, which are 'city', 'temperature', and 'hosting_city'.", "It selects the 'city' column from the 'city' table.", "The first part of the query joins 'city' and 'temperature' to filter cities based on the condition that the average temperature in February is greater than in June.", "The second part of the query joins 'city' and 'hosting_city' to include cities that have hosted matches.", "The use of UNION combines the results from both conditions, ensuring unique city names are returned."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Feb  >  T2.Jun UNION SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "description": "This virtual table provides a list of cities based on temperature comparisons and hosting information. It includes cities where the average temperature in February is greater than in June, as well as cities that have hosted matches. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.", "virtual_table": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Feb  >  T2.Jun UNION SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city"}
{"sample_id": "train.6275", "db_id": "city_record", "question": "Find the city that hosted the most events.", "rationale": ["The query identifies the relevant tables, which are 'city' and 'hosting_city'.", "It selects the 'city' column from the 'city' table, aliased as T1.", "A JOIN operation is performed between 'city' (T1) and 'hosting_city' (T2) on the condition that the city ID matches the host city ID.", "The results are grouped by the host city to aggregate the number of matches hosted in each city.", "The results are ordered in descending order based on the count of matches hosted.", "A limit is applied to restrict the number of cities returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["hosting_city", "city"], "description": "This virtual table provides a list of cities that have hosted matches, derived from the 'city' and 'hosting_city' tables. The results are grouped by the host city and ordered by the number of matches hosted, with a limit on the number of cities returned as specified by the placeholder.", "virtual_table": "SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6276", "db_id": "city_record", "question": "What is the venue of the competition \"1994 FIFA World Cup qualification\" hosted by \"Nanjing ( Jiangsu )\"?", "rationale": ["The query identifies the relevant tables: 'city', 'hosting_city', and 'match'.", "It selects the 'venue' column from the 'match' table.", "The JOIN operations link the 'city' table to the 'hosting_city' table using the 'city_id' and 'host_city' columns, and then link the 'hosting_city' table to the 'match' table using the 'match_id'.", "The WHERE clause filters results based on the specified city name and competition type using placeholders for string values."], "gold_sql": "SELECT T3.venue FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id = T2.host_city JOIN MATCH AS T3 ON T2.match_id = T3.match_id WHERE T1.city = 'Nanjing ( Jiangsu )' AND T3.competition = '1994 FIFA World Cup qualification'", "source_tables": ["hosting_city", "city", "match"], "description": "This virtual table provides information about the venues of matches hosted in a specific city. It combines data from the 'city', 'hosting_city', and 'match' tables. The placeholders in the WHERE clause represent the name of the city and the competition type.", "virtual_table": "SELECT T3.venue FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id = T2.host_city JOIN MATCH AS T3 ON T2.match_id = T3.match_id WHERE T1.city = [PLACEHOLDER-TYPE:STRING] AND T3.competition = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6282", "db_id": "city_record", "question": "Which three cities have the largest regional population?", "rationale": ["The query identifies the relevant table, which is 'city'.", "Select the column to display, 'city'.", "Order the results by 'regional_population' in descending order to show the most populated cities first.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT city FROM city ORDER BY regional_population DESC LIMIT 3", "source_tables": ["city"], "description": "This virtual table provides a list of cities from the 'city' table, ordered by their regional population in descending order. The placeholder in the LIMIT clause indicates the maximum number of cities to return.", "virtual_table": "SELECT city FROM city ORDER BY regional_population DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6283", "db_id": "city_record", "question": "What are the three largest cities in terms of regional population?", "rationale": ["The query identifies the relevant table, which is 'city'.", "Select the column to display, 'city'.", "Order the results by 'regional_population' in descending order to show the most populated cities first.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT city FROM city ORDER BY regional_population DESC LIMIT 3", "source_tables": ["city"], "description": "This virtual table provides a list of cities from the 'city' table, ordered by their regional population in descending order. The placeholder in the LIMIT clause indicates the maximum number of cities to return.", "virtual_table": "SELECT city FROM city ORDER BY regional_population DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4270", "db_id": "club_1", "question": "Find all the female members of club \"Bootup Baltimore\". Show the first name and last name.", "rationale": ["The query identifies the relevant tables: 'Club', 'Member_of_club', and 'Student'.", "It selects the columns to display, which are 'fname' and 'lname' from the 'Student' table.", "The JOIN operations link the 'Club' table to the 'Member_of_club' table and then to the 'Student' table based on their respective identifiers.", "Conditions are added to filter the results based on the specified club name and the gender of the students using placeholders for string values."], "gold_sql": "SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  'Bootup Baltimore' AND t3.sex  =  'F'", "source_tables": ["club", "member_of_club", "student"], "description": "The virtual table describes the first and last names of students who are members of a specific club and belong to a certain gender. The placeholders in the WHERE clause represent the club's name and the student's gender.", "virtual_table": "SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  [PLACEHOLDER-TYPE:STRING] AND t3.sex  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4276", "db_id": "club_1", "question": "Which club has the most members majoring in \"600\"?", "rationale": ["The query identifies the relevant tables: 'Club', 'Member_of_club', and 'Student'.", "It selects the 'clubname' from the 'Club' table.", "The JOIN operations link the 'Member_of_club' table to the 'Club' and 'Student' tables based on their respective IDs.", "A WHERE clause filters the results to include only those students whose major matches the specified placeholder.", "The results are grouped by 'clubname' and ordered by the count of members in descending order, with a limit on the number of results specified by a placeholder."], "gold_sql": "SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.major  =  '600' GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT 1", "source_tables": ["club", "member_of_club", "student"], "description": "This virtual table provides a list of club names that students, majoring in a specific field of study, are members of. The query joins the 'Club', 'Member_of_club', and 'Student' tables to filter clubs based on the students' major. The placeholders represent the major of study and the limit on the number of results returned.", "virtual_table": "SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.major  =  [PLACEHOLDER-TYPE:STRING] GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4279", "db_id": "club_1", "question": "Which club has the most female students as their members? Give me the name of the club.", "rationale": ["The query identifies the relevant tables: 'Club', 'Member_of_club', and 'Student'.", "It selects the 'clubname' from the 'Club' table.", "The JOIN operations link the 'Member_of_club' table to the 'Club' table and the 'Student' table to filter based on the specified gender.", "The WHERE clause uses a placeholder for the gender of the students.", "The GROUP BY clause groups the results by club name, and the ORDER BY clause sorts the results by the count of members in descending order.", "The LIMIT clause restricts the number of results returned based on a specified number."], "gold_sql": "SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.sex  =  'F' GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT 1", "source_tables": ["club", "member_of_club", "student"], "description": "This virtual table provides a list of club names from the 'Club' table that are associated with students of a specific gender. The query joins the 'Club', 'Member_of_club', and 'Student' tables to filter clubs based on the gender of the students. The placeholders in the WHERE clause represent the gender of the students, and the LIMIT clause allows for specifying the maximum number of clubs to return, sorted by the number of members in descending order.", "virtual_table": "SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.sex  =  [PLACEHOLDER-TYPE:STRING] GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4267", "db_id": "club_1", "question": "How many clubs does \"Linda Smith\" have membership for?", "rationale": ["The query identifies the relevant tables: 'club', 'member_of_club', and 'student'.", "It uses a JOIN operation to connect these tables based on the foreign key relationships.", "The SELECT statement counts the number of clubs associated with the specified student.", "The WHERE clause filters the results to match the student's first and last names using placeholders for string values."], "gold_sql": "SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.fname  =  'Linda' AND t3.lname  =  'Smith'", "source_tables": ["club", "member_of_club", "student"], "description": "The virtual table provides a count of clubs that a specific student is a member of, based on their first and last names. The placeholders in the WHERE clause represent the student's first and last names.", "virtual_table": "SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.fname  =  [PLACEHOLDER-TYPE:STRING] AND t3.lname  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4257", "db_id": "club_1", "question": "Find each student's first name.", "rationale": ["The query is identifying the relevant table, which is 'Student'.", "Select the column to display, 'Fname', ensuring that only distinct values are retrieved.", "Using the DISTINCT keyword ensures that duplicate first names are not included in the results."], "gold_sql": "SELECT DISTINCT fname FROM student", "source_tables": ["student"], "description": "This virtual table provides a list of distinct first names of students from the 'Student' table. The query is designed to retrieve unique entries, ensuring that no duplicate first names are included in the result set.", "virtual_table": "SELECT DISTINCT fname FROM student"}
{"sample_id": "train.3221", "db_id": "college_1", "question": "Find the max, average, and minimum gpa of all students in each department.", "rationale": ["The query identifies the relevant table, which is 'student'.", "It selects the maximum, average, and minimum GPA from the 'stu_gpa' column.", "The query groups the results by 'dept_code' to provide a summary for each department."], "gold_sql": "SELECT max(stu_gpa) ,  avg(stu_gpa) ,  min(stu_gpa) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "description": "This virtual table summarizes the academic performance of students by department. It provides the maximum, average, and minimum GPA of students grouped by their respective department codes. The placeholders in the SELECT statement represent the GPA metrics and department code.", "virtual_table": "SELECT max(stu_gpa) ,  avg(stu_gpa) ,  min(stu_gpa) ,  dept_code FROM student GROUP BY dept_code"}
{"sample_id": "train.3294", "db_id": "college_1", "question": "What are the first names of all students taking accoutning and Computer Information Systems classes?", "rationale": ["The query identifies the relevant tables: 'student', 'enroll', 'class', 'course', and 'department'.", "It selects the 'stu_fname' column from the 'student' table.", "The JOIN operations link the tables based on their foreign key relationships to ensure that only students enrolled in classes from the specified department are selected.", "The WHERE clause filters the results based on the department's name, using a placeholder for string values.", "The INTERSECT operation is used to find students who meet the criteria in both instances of the department query."], "gold_sql": "SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Accounting' INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Computer Info. Systems'", "source_tables": ["course", "enroll", "department", "class", "student"], "description": "This virtual table provides the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, represented by a placeholder for the department's name in the WHERE clause.", "virtual_table": "SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3271", "db_id": "college_1", "question": "What is the name of department where has the largest number of professors with a Ph.D. degree?", "rationale": ["The query identifies the relevant tables, which are 'professor' and 'department'.", "It selects the 'dept_name' from the 'department' table and 'dept_code' from the 'professor' table.", "A JOIN operation is performed on the 'dept_code' to link professors to their respective departments.", "A condition is added to filter professors based on their highest degree using a placeholder for string values.", "The results are grouped by 'dept_code' to aggregate the data by department.", "The results are ordered by the count of professors in each department in descending order.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  'Ph.D.' GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["department", "professor"], "description": "This virtual table provides a summary of departments along with their unique codes, specifically focusing on professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree type, while the LIMIT placeholder allows for specifying the maximum number of departments to return based on the count of professors in each department.", "virtual_table": "SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3272", "db_id": "college_1", "question": "Which department has the most professors with a Ph.D.?", "rationale": ["The query identifies the relevant tables, which are 'professor' and 'department'.", "It selects the department name and department code from the respective tables.", "A JOIN operation is performed on the department code to link professors to their departments.", "A condition is added to filter professors based on their highest degree using a placeholder for string values.", "The results are grouped by department code to aggregate the data.", "The results are ordered by the count of professors in descending order and limited to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  'Ph.D.' GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["department", "professor"], "description": "This virtual table provides a summary of departments along with their names that have professors with a specific highest degree. The placeholders in the WHERE clause represent the degree type and the limit on the number of results to return.", "virtual_table": "SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3216", "db_id": "college_1", "question": "How many professors have a Ph.D. in each department?", "rationale": ["The query identifies the relevant table, which is 'professor'.", "It selects a count of professors and groups the results by department code.", "A condition is added to filter the results based on the highest degree held by the professors using a placeholder for string values."], "gold_sql": "SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  'Ph.D.' GROUP BY dept_code", "source_tables": ["professor"], "description": "This virtual table summarizes the number of professors in each department who hold a specific highest degree. The placeholder in the WHERE clause represents the degree type being queried.", "virtual_table": "SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY dept_code"}
{"sample_id": "train.3323", "db_id": "college_1", "question": "Find the first names and degree of all professors who are teaching some class in Computer Info. Systems department.", "rationale": ["The query identifies the relevant tables: 'CLASS', 'EMPLOYEE', 'PROFESSOR', and 'DEPARTMENT'.", "It selects distinct first names from the 'EMPLOYEE' table and the highest degree from the 'PROFESSOR' table.", "The JOIN operations link the tables based on their foreign key relationships, ensuring that the correct employee and professor data is associated with each class.", "A WHERE clause is added to filter the results by the specified department name using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T2.emp_fname ,  T3.prof_high_degree FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN professor AS T3 ON T2.emp_num  =  T3.emp_num JOIN department AS T4 ON T4.dept_code  =  T3.dept_code WHERE T4.dept_name  =  'Computer Info. Systems'", "source_tables": ["employee", "professor", "class", "department"], "description": "The virtual table provides a list of distinct first names of employees and their highest degrees from the 'CLASS', 'EMPLOYEE', 'PROFESSOR', and 'DEPARTMENT' tables. It filters the results based on a specific department name, represented by a placeholder.", "virtual_table": "SELECT DISTINCT T2.emp_fname ,  T3.prof_high_degree FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN professor AS T3 ON T2.emp_num  =  T3.emp_num JOIN department AS T4 ON T4.dept_code  =  T3.dept_code WHERE T4.dept_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3222", "db_id": "college_1", "question": "What is the highest, lowest, and average student GPA for every department?", "rationale": ["The query identifies the relevant table, which is 'student'.", "It selects the maximum, average, and minimum GPA from the 'stu_gpa' column.", "The query groups the results by 'dept_code' to provide a summary for each department."], "gold_sql": "SELECT max(stu_gpa) ,  avg(stu_gpa) ,  min(stu_gpa) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "description": "This virtual table summarizes the academic performance of students by department. It provides the maximum, average, and minimum GPA of students grouped by their respective department codes. The placeholders in the SELECT statement represent the GPA metrics and department code.", "virtual_table": "SELECT max(stu_gpa) ,  avg(stu_gpa) ,  min(stu_gpa) ,  dept_code FROM student GROUP BY dept_code"}
{"sample_id": "train.3180", "db_id": "college_1", "question": "What are the first names and birthdates of the professors in charge of ACCT-211?", "rationale": ["The query identifies the relevant tables, which are 'employee' and 'CLASS'.", "It selects the columns to display, 'EMP_FNAME' and 'EMP_DOB' from the 'employee' table.", "A JOIN operation is performed between 'employee' and 'CLASS' on the condition that 'EMP_NUM' from 'employee' matches 'PROF_NUM' from 'CLASS'.", "A condition is added to filter the results based on the 'CRS_CODE' using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["employee", "class"], "description": "The virtual table provides the first names and dates of birth of professors who teach a specific course. The data is retrieved from the 'employee' table, which contains information about professors, and is joined with the 'CLASS' table to filter by the course code. The placeholder in the WHERE clause represents the course code for which the professors are being queried.", "virtual_table": "SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3189", "db_id": "college_1", "question": "How many different locations does the school with code BUS has?", "rationale": ["The query identifies the relevant table, which is 'DEPARTMENT'.", "It counts the distinct values in the 'dept_address' column to ensure unique addresses are considered.", "A condition is added to filter the results based on the 'school_code' using a placeholder for string values."], "gold_sql": "SELECT count(DISTINCT dept_address) FROM department WHERE school_code  =  'BUS'", "source_tables": ["department"], "description": "This virtual table provides the count of distinct department addresses from the 'DEPARTMENT' table that are associated with a specific school. The placeholder in the WHERE clause represents the school code being queried.", "virtual_table": "SELECT count(DISTINCT dept_address) FROM department WHERE school_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3210", "db_id": "college_1", "question": "How many different professors are there for the different schools?", "rationale": ["The query identifies the relevant tables, which are 'Department' and 'Professor'.", "It selects a count of professors and groups the results by the school code from the 'Department' table.", "The JOIN condition links the 'Department' and 'Professor' tables based on the department code, ensuring that the count reflects the correct association between professors and their respective departments."], "gold_sql": "SELECT count(*) ,  T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code", "source_tables": ["department", "professor"], "description": "This virtual table provides a count of professors grouped by the school code from the 'Department' table. The placeholder in the SELECT statement represents the count of professors, while the school code is derived from the department they belong to.", "virtual_table": "SELECT count(*) ,  T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code"}
{"sample_id": "train.3237", "db_id": "college_1", "question": "Find the total credits of all classes offered by each department.", "rationale": ["The query identifies the relevant tables, which are 'COURSE' and 'CLASS'.", "It selects the sum of credit hours from the 'COURSE' table and groups the results by department code.", "The JOIN operation connects the 'COURSE' and 'CLASS' tables based on the course code, allowing for aggregation of credit hours by department."], "gold_sql": "SELECT sum(T1.crs_credit) ,  T1.dept_code FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY T1.dept_code", "source_tables": ["course", "class"], "description": "The virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables. The placeholder in the SELECT clause represents the total credit hours, while the GROUP BY clause organizes the results by department code.", "virtual_table": "SELECT sum(T1.crs_credit) ,  T1.dept_code FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY T1.dept_code"}
{"sample_id": "train.3253", "db_id": "college_1", "question": "What is the name of the department that has the largest number of students enrolled?", "rationale": ["The query identifies the relevant tables: 'CLASS', 'ENROLL', 'COURSE', and 'DEPARTMENT'.", "It joins these tables based on their foreign key relationships to connect classes with their respective departments.", "The SELECT statement retrieves the 'dept_name' from the 'DEPARTMENT' table.", "The GROUP BY clause groups the results by department code to count the number of classes per department.", "The ORDER BY clause sorts the results in descending order based on the count of classes, allowing the most populated departments to appear first.", "The LIMIT clause restricts the number of results returned, using a placeholder for the user to specify how many department names they want."], "gold_sql": "SELECT T4.dept_name FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code GROUP BY T3.dept_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["course", "department", "class", "enroll"], "description": "The virtual table provides a list of department names from the 'DEPARTMENT' table that are associated with classes in which students are enrolled. It aggregates the data by counting the number of classes per department, allowing users to see which departments have the most classes offered. The placeholder in the LIMIT clause represents the maximum number of department names to return.", "virtual_table": "SELECT T4.dept_name FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code GROUP BY T3.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3206", "db_id": "college_1", "question": "How many classes are held in each department?", "rationale": ["The query identifies the relevant tables, which are 'CLASS' and 'COURSE'.", "It uses a JOIN operation to connect these tables based on the 'CRS_CODE' column.", "The SELECT statement counts the number of classes and groups the results by 'DEPT_CODE' to show how many classes each department offers."], "gold_sql": "SELECT count(*) ,  dept_code FROM CLASS AS T1 JOIN course AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY dept_code", "source_tables": ["course", "class"], "description": "This virtual table summarizes the number of classes offered by each department. It combines data from the 'CLASS' and 'COURSE' tables, using the course code to link them. The placeholder in the SELECT statement represents the department code, which is used to group the results and count the classes associated with each department.", "virtual_table": "SELECT count(*) ,  dept_code FROM CLASS AS T1 JOIN course AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY dept_code"}
{"sample_id": "train.3238", "db_id": "college_1", "question": "What are the total number of credits offered by each department?", "rationale": ["The query identifies the relevant tables, which are 'COURSE' and 'CLASS'.", "It selects the sum of credit hours from the 'COURSE' table and groups the results by department code.", "The JOIN operation connects the 'COURSE' and 'CLASS' tables using the course code, allowing for aggregation of credit hours by department."], "gold_sql": "SELECT sum(T1.crs_credit) ,  T1.dept_code FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY T1.dept_code", "source_tables": ["course", "class"], "description": "The virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables. The placeholder in the SELECT clause represents the total credit hours, while the GROUP BY clause organizes the results by department code.", "virtual_table": "SELECT sum(T1.crs_credit) ,  T1.dept_code FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY T1.dept_code"}
{"sample_id": "train.3205", "db_id": "college_1", "question": "Find the number of classes in each department.", "rationale": ["The query identifies the relevant tables, which are 'CLASS' and 'COURSE'.", "It uses a JOIN operation to connect these tables based on the 'CRS_CODE' column.", "The SELECT statement counts the number of classes and groups the results by 'DEPT_CODE' to show how many classes each department offers."], "gold_sql": "SELECT count(*) ,  dept_code FROM CLASS AS T1 JOIN course AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY dept_code", "source_tables": ["course", "class"], "description": "This virtual table summarizes the number of classes offered by each department. It combines data from the 'CLASS' and 'COURSE' tables, using the course code to link them. The placeholder in the SELECT statement represents the department code, which is used to group the results and count the classes associated with each department.", "virtual_table": "SELECT count(*) ,  dept_code FROM CLASS AS T1 JOIN course AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY dept_code"}
{"sample_id": "train.3315", "db_id": "college_1", "question": "Find the first names and offices of all instructors who have taught some course and the course description and the department name.", "rationale": ["The query identifies the relevant tables: CLASS, EMPLOYEE, COURSE, PROFESSOR, and DEPARTMENT.", "It selects the professor's first name from the EMPLOYEE table, the professor's office from the PROFESSOR table, the course description from the COURSE table, and the department name from the DEPARTMENT table.", "The JOIN operations link these tables based on their foreign key relationships, ensuring that the data retrieved is related and accurate."], "gold_sql": "SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description ,  T5.dept_name FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num JOIN department AS T5 ON T4.dept_code  =  T5.dept_code", "source_tables": ["course", "department", "professor", "class", "employee"], "description": "The virtual table provides a comprehensive view of the relationship between classes, professors, courses, and departments. It includes the first name of the professor, the office location of the professor, the description of the course, and the name of the department offering the course. The data is sourced from multiple tables, linking professors to their respective classes and courses, and associating those courses with their departments.", "virtual_table": "SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description ,  T5.dept_name FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num JOIN department AS T5 ON T4.dept_code  =  T5.dept_code"}
{"sample_id": "train.3220", "db_id": "college_1", "question": "How many hours do the students spend studying in each department?", "rationale": ["The query identifies the relevant table, which is 'STUDENT'.", "It selects the sum of 'STU_HRS' to calculate the total credit hours for each department.", "The 'DEPT_CODE' is included to group the results by department, allowing for a summary of credit hours per department."], "gold_sql": "SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "description": "This virtual table summarizes the total credit hours completed by students, grouped by their respective department codes. The placeholder in the SELECT statement represents the total credit hours, while the GROUP BY clause organizes the results by department code.", "virtual_table": "SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code"}
{"sample_id": "train.3218", "db_id": "college_1", "question": "How many students are in each department?", "rationale": ["The query identifies the relevant table, which is 'student'.", "It selects a count of students and groups the results by 'dept_code'.", "The use of count(*) allows for the aggregation of student records per department, providing a total for each department code."], "gold_sql": "SELECT count(*) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "description": "This virtual table summarizes the number of students enrolled in each department by counting the total students associated with each department code. The placeholder in the SELECT statement represents the department code, which is used to group the student records accordingly.", "virtual_table": "SELECT count(*) ,  dept_code FROM student GROUP BY dept_code"}
{"sample_id": "train.3214", "db_id": "college_1", "question": "Which school has the fewest professors?", "rationale": ["The query identifies the relevant tables, which are 'department' and 'professor'.", "It selects the 'school_code' from the 'department' table.", "A JOIN operation is performed between 'department' and 'professor' on the 'dept_code' to associate professors with their respective departments.", "The results are grouped by 'school_code' to count the number of professors in each school.", "The ORDER BY clause sorts the results based on the count of professors, and the LIMIT clause uses a placeholder to restrict the number of results returned."], "gold_sql": "SELECT T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code ORDER BY count(*) LIMIT 1", "source_tables": ["department", "professor"], "description": "The virtual table provides a list of school codes from the 'department' table, grouped by the number of professors associated with each school. The placeholder in the LIMIT clause allows the user to specify the maximum number of school codes to retrieve.", "virtual_table": "SELECT T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3209", "db_id": "college_1", "question": "What is the number of professors for different school?", "rationale": ["The query identifies the relevant tables, which are 'Department' and 'Professor'.", "It selects the count of professors and the school code from the 'Department' table.", "A JOIN operation is performed on the 'dept_code' to link professors to their respective departments.", "The results are grouped by 'school_code' to aggregate the count of professors for each school."], "gold_sql": "SELECT count(*) ,  T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code", "source_tables": ["department", "professor"], "description": "This virtual table summarizes the number of professors associated with each school in the 'Department' table. The placeholder in the SELECT clause represents the count of professors, while the school code is grouped to show the total per school.", "virtual_table": "SELECT count(*) ,  T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code"}
{"sample_id": "train.3300", "db_id": "college_1", "question": "What is the name of the department with the student that has the lowest GPA?", "rationale": ["The query identifies the relevant tables, which are 'student' and 'department'.", "It selects the 'dept_name' column from the 'department' table.", "A JOIN operation is performed on the 'dept_code' to link students with their respective departments.", "The results are ordered by the 'stu_gpa' column to prioritize departments based on student performance.", "The LIMIT clause includes a placeholder to specify how many department names to return."], "gold_sql": "SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT 1", "source_tables": ["department", "student"], "description": "This virtual table provides a list of department names associated with students, ordered by their GPA. The placeholder in the LIMIT clause allows for specifying the maximum number of department names to retrieve.", "virtual_table": "SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3241", "db_id": "college_1", "question": "How many students enrolled in class ACCT-211?", "rationale": ["The query identifies the relevant tables, which are 'CLASS' and 'ENROLL'.", "It uses a JOIN operation to combine these tables based on the 'class_code' column, which is common to both tables.", "The SELECT statement counts the number of records, indicating the total number of students enrolled in the specified class.", "A condition is added to filter the results based on the 'crs_code' column from the 'CLASS' table, using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code WHERE T1.crs_code  =  'ACCT-211'", "source_tables": ["class", "enroll"], "description": "This virtual table provides the count of students enrolled in classes associated with a specific course code from the 'CLASS' and 'ENROLL' tables. The placeholder in the WHERE clause represents the course code for which the enrollment count is being queried.", "virtual_table": "SELECT count(*) FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code WHERE T1.crs_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3314", "db_id": "college_1", "question": "What are the first names, office locations of all lecturers who have taught some course?", "rationale": ["The query identifies the relevant tables: 'CLASS', 'EMPLOYEE', 'COURSE', and 'PROFESSOR'.", "It selects the first name of the professor from the 'EMPLOYEE' table, the office location from the 'PROFESSOR' table, and the course description from the 'COURSE' table.", "Joins are used to connect these tables based on the professor's identifier and course codes, ensuring the correct relationships are maintained."], "gold_sql": "SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num", "source_tables": ["course", "employee", "professor", "class"], "description": "This virtual table provides a view of the first names of professors, their office locations, and descriptions of the courses they teach. The data is sourced from the 'CLASS', 'EMPLOYEE', 'COURSE', and 'PROFESSOR' tables, with relationships established through the professor's identifier and course codes.", "virtual_table": "SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num"}
{"sample_id": "train.3299", "db_id": "college_1", "question": "What is the department name of the students with lowest gpa belongs to?", "rationale": ["The query identifies the relevant tables, which are 'student' and 'department'.", "It selects the 'dept_name' column from the 'department' table.", "A JOIN operation is performed on the 'dept_code' to link students with their respective departments.", "The results are ordered by the students' GPA to prioritize higher-performing students.", "The LIMIT clause includes a placeholder to specify how many department names to return."], "gold_sql": "SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT 1", "source_tables": ["department", "student"], "description": "This virtual table provides a list of department names associated with students, ordered by their GPA. The placeholder in the LIMIT clause allows for specifying the maximum number of department names to retrieve.", "virtual_table": "SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3234", "db_id": "college_1", "question": "How many courses does the department of Computer Information Systmes offer?", "rationale": ["The query identifies the relevant tables, which are 'department' and 'course'.", "It uses a JOIN operation to connect these tables based on the 'dept_code' column.", "The SELECT statement counts the number of courses associated with the specified department.", "A WHERE clause is added to filter the results based on the department name using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM department AS T1 JOIN course AS T2 ON T1.dept_code  =  T2.dept_code WHERE dept_name  =  'Computer Info. Systems'", "source_tables": ["course", "department"], "description": "This virtual table provides the count of courses offered by a specific department. It joins the 'department' table with the 'course' table based on the department code, and filters the results to include only the specified department name.", "virtual_table": "SELECT count(*) FROM department AS T1 JOIN course AS T2 ON T1.dept_code  =  T2.dept_code WHERE dept_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3309", "db_id": "college_1", "question": "Find the first names of all instructors who have taught some course and the course code.", "rationale": ["The query identifies the relevant tables, which are 'CLASS' and 'EMPLOYEE'.", "It selects the 'crs_code' from the 'CLASS' table and 'emp_fname' from the 'EMPLOYEE' table.", "A JOIN operation is performed to connect the two tables based on the professor's identifier, ensuring that the correct professor's name is associated with each class."], "gold_sql": "SELECT T2.emp_fname ,  T1.crs_code FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num", "source_tables": ["employee", "class"], "description": "The virtual table provides a list of course codes along with the first names of professors who are teaching those courses. It combines data from the 'CLASS' table, which contains information about the classes and their associated professors, and the 'EMPLOYEE' table, which holds details about the professors. The join condition links the professor's identifier in the 'CLASS' table to the corresponding entry in the 'EMPLOYEE' table.", "virtual_table": "SELECT T2.emp_fname ,  T1.crs_code FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num"}
{"sample_id": "dev.370", "db_id": "cre_Doc_Template_Mgt", "question": "What are the ids and names of each document, as well as the number of paragraphs in each?", "rationale": ["The query identifies the relevant tables, which are 'Paragraphs' and 'Documents'.", "It selects the 'document_id' from the 'Paragraphs' table and 'document_name' from the 'Documents' table.", "A JOIN operation is performed on the 'document_id' to link paragraphs to their respective documents.", "The query uses GROUP BY to aggregate the results by 'document_id', allowing for a count of paragraphs for each document."], "gold_sql": "SELECT T1.document_id ,  T2.document_name ,  count(*) FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id GROUP BY T1.document_id", "source_tables": ["paragraphs", "documents"], "description": "This virtual table provides a summary of documents along with the count of paragraphs associated with each document. It combines data from the 'Paragraphs' and 'Documents' tables, where each document is identified by its unique ID and name. The count represents the total number of paragraphs linked to each document, allowing users to see how many paragraphs are contained within each document.", "virtual_table": "SELECT T1.document_id ,  T2.document_name ,  count(*) FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id GROUP BY T1.document_id"}
{"sample_id": "dev.369", "db_id": "cre_Doc_Template_Mgt", "question": "Show all document ids, names and the number of paragraphs in each document.", "rationale": ["The query identifies the relevant tables, which are 'Paragraphs' and 'Documents'.", "It selects the 'document_id' from the 'Paragraphs' table and 'document_name' from the 'Documents' table.", "The JOIN operation links the two tables on the 'document_id' to associate paragraphs with their respective documents.", "The COUNT function is used to count the number of paragraphs for each document, and the results are grouped by 'document_id' to ensure each document's paragraph count is aggregated correctly."], "gold_sql": "SELECT T1.document_id ,  T2.document_name ,  count(*) FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id GROUP BY T1.document_id", "source_tables": ["paragraphs", "documents"], "description": "This virtual table provides a summary of documents along with the count of paragraphs associated with each document. It combines data from the 'Paragraphs' and 'Documents' tables, where each document's unique identifier is linked to its corresponding paragraphs. The placeholders in the SELECT statement represent the document ID and document name, while the count reflects the number of paragraphs for each document.", "virtual_table": "SELECT T1.document_id ,  T2.document_name ,  count(*) FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id GROUP BY T1.document_id"}
{"sample_id": "dev.368", "db_id": "cre_Doc_Template_Mgt", "question": "Return the different document ids along with the number of paragraphs corresponding to each, ordered by id.", "rationale": ["The query identifies the relevant table, which is 'Paragraphs'.", "It selects the 'document_id' and counts the number of paragraphs associated with each document using the COUNT function.", "The results are grouped by 'document_id' to aggregate the paragraph counts for each document.", "Finally, the results are ordered by 'document_id' to present the data in a structured manner."], "gold_sql": "SELECT document_id ,  count(*) FROM Paragraphs GROUP BY document_id ORDER BY document_id", "source_tables": ["paragraphs"], "description": "This virtual table summarizes the number of paragraphs associated with each document from the 'Paragraphs' table. The result is grouped by the document identifier, allowing users to see how many paragraphs belong to each document, sorted by the document ID.", "virtual_table": "SELECT document_id ,  count(*) FROM Paragraphs GROUP BY document_id ORDER BY document_id"}
{"sample_id": "dev.342", "db_id": "cre_Doc_Template_Mgt", "question": "What are the different template type codes, and how many documents use each type?", "rationale": ["The query identifies the relevant tables, which are 'Templates' and 'Documents'.", "It selects the 'template_type_code' from the 'Templates' table and counts the number of documents associated with each template type.", "A JOIN operation is performed between 'Templates' and 'Documents' on the 'template_id' to link templates with their corresponding documents.", "The results are grouped by 'template_type_code' to provide a count of documents for each template type."], "gold_sql": "SELECT T1.template_type_code ,  count(*) FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_type_code", "source_tables": ["templates", "documents"], "description": "This virtual table summarizes the count of documents associated with each template type from the 'Templates' and 'Documents' tables. The placeholder in the SELECT statement represents the template type code, and the count reflects the number of documents linked to each template type.", "virtual_table": "SELECT T1.template_type_code ,  count(*) FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_type_code"}
{"sample_id": "dev.309", "db_id": "cre_Doc_Template_Mgt", "question": "Show all template ids and number of documents using each template.", "rationale": ["The query identifies the relevant table, which is 'Documents'.", "It selects the 'template_id' column to display the unique identifier of each template.", "The count function is used to aggregate the number of documents for each template.", "The GROUP BY clause is applied to group the results by 'template_id', allowing us to see how many documents are linked to each template."], "gold_sql": "SELECT template_id ,  count(*) FROM Documents GROUP BY template_id", "source_tables": ["documents"], "description": "This virtual table summarizes the count of documents associated with each template from the 'Documents' table, grouped by the template identifier. The placeholder in the SELECT clause represents the unique identifier of the template.", "virtual_table": "SELECT template_id ,  count(*) FROM Documents GROUP BY template_id"}
{"sample_id": "dev.362", "db_id": "cre_Doc_Template_Mgt", "question": "What are the details for the paragraph that includes the text 'Korea ' ?", "rationale": ["The query identifies the relevant table, which is 'Paragraphs'.", "Select the column to display, 'Other_Details'.", "Add a condition to filter the 'Paragraph_Text' column for the specified text pattern using a placeholder for string values."], "gold_sql": "select other_details from paragraphs where paragraph_text like 'korea'", "source_tables": ["paragraphs"], "description": "This virtual table provides access to the additional details of paragraphs from the 'Paragraphs' table that contain specific text. The placeholder in the WHERE clause represents the text pattern to search for within the paragraph content.", "virtual_table": "select other_details from paragraphs where paragraph_text like [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.336", "db_id": "cre_Doc_Template_Mgt", "question": "Return the lowest version number, along with its corresponding template type code.", "rationale": ["The query is identifying the relevant table, which is 'Templates'.", "Select the minimum version number of the templates using the aggregate function min().", "Group the results by 'Template_Type_Code' to categorize the templates based on their type."], "gold_sql": "SELECT min(Version_Number) ,  template_type_code FROM Templates", "source_tables": ["templates"], "description": "This virtual table provides the minimum version number of templates grouped by their type code from the 'Templates' table. The placeholder in the SELECT clause represents the version number, while the template type code is used to categorize the templates.", "virtual_table": "SELECT min(Version_Number) ,  template_type_code FROM Templates"}
{"sample_id": "dev.345", "db_id": "cre_Doc_Template_Mgt", "question": "Show all template type codes that are not used by any document.", "rationale": ["The query starts by selecting the 'template_type_code' from the 'Templates' table.", "It uses the EXCEPT clause to exclude any 'template_type_code' that appears in the result of a JOIN between 'Templates' and 'Documents'.", "The JOIN condition links the two tables based on the 'template_id', ensuring that only template types associated with documents are filtered out."], "gold_sql": "SELECT template_type_code FROM Templates EXCEPT SELECT template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id", "source_tables": ["templates", "documents"], "description": "This virtual table identifies the unique template type codes from the 'Templates' table that are not associated with any documents in the 'Documents' table. The query uses an EXCEPT clause to filter out template types that have been linked to documents, ensuring that only those template types without any corresponding documents are displayed.", "virtual_table": "SELECT template_type_code FROM Templates EXCEPT SELECT template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id"}
{"sample_id": "dev.335", "db_id": "cre_Doc_Template_Mgt", "question": "What the smallest version number and its template type code?", "rationale": ["The query is identifying the relevant table, which is 'Templates'.", "Select the minimum version number of the templates using the aggregate function min().", "Group the results by 'Template_Type_Code' to categorize the minimum version numbers according to their respective template types."], "gold_sql": "SELECT min(Version_Number) ,  template_type_code FROM Templates", "source_tables": ["templates"], "description": "This virtual table provides the minimum version number of templates grouped by their type code from the 'Templates' table. The placeholder in the SELECT clause represents the version number, while the template type code is used to categorize the templates.", "virtual_table": "SELECT min(Version_Number) ,  template_type_code FROM Templates"}
{"sample_id": "train.5170", "db_id": "cre_Drama_Workshop_Groups", "question": "What is the description of the service type which offers both the photo product and the film product?", "rationale": ["The query identifies the relevant tables, which are 'Ref_Service_Types' and 'Services'.", "It selects the 'Service_Type_Description' from 'Ref_Service_Types'.", "The JOIN operation links 'Ref_Service_Types' and 'Services' based on the 'Service_Type_Code'.", "The WHERE clause filters the results based on the 'Product_Name' using a placeholder for string values.", "The INTERSECT operation is used to find common service type descriptions for two instances of the same product name."], "gold_sql": "SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  'photo' INTERSECT SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  'film'", "source_tables": ["services", "ref_service_types"], "description": "The virtual table provides a list of service type descriptions from the 'Ref_Service_Types' table that are associated with a specific product name in the 'Services' table. The query uses an INTERSECT operation to find common service types related to two different instances of the same product name.", "virtual_table": "SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5135", "db_id": "cre_Drama_Workshop_Groups", "question": "Find the names of the workshop groups where services with product name \"film\" are performed.", "rationale": ["The query identifies the relevant tables, 'Drama_Workshop_Groups' and 'Services'.", "It selects the columns to display, which are 'Store_Phone' and 'Store_Email_Address' from the 'Drama_Workshop_Groups' table.", "A JOIN operation is performed between 'Drama_Workshop_Groups' and 'Services' on the 'Workshop_Group_ID' to link the two tables based on the workshop group.", "A condition is added to filter the results based on the 'Product_Name' from the 'Services' table using a placeholder for string values."], "gold_sql": "SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T2.Product_Name  =  'film'", "source_tables": ["services", "drama_workshop_groups"], "description": "The virtual table provides the phone number and email address of stores associated with specific drama workshop groups that offer a particular service. The placeholder in the WHERE clause represents the name of the product related to the service.", "virtual_table": "SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T2.Product_Name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5168", "db_id": "cre_Drama_Workshop_Groups", "question": "What is the product ID of the most frequently ordered item on invoices?", "rationale": ["The query identifies the relevant table, which is 'Invoices'.", "It selects the 'Product_ID' column to display unique product identifiers.", "The results are grouped by 'Product_ID' to aggregate the data based on each product.", "The query orders the results by the count of occurrences of each product, in descending order, to highlight the most frequently invoiced products.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT Product_ID FROM INVOICES GROUP BY Product_ID ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["invoices"], "description": "The virtual table summarizes the unique product identifiers from the 'Invoices' table, grouped by product ID. It orders the results based on the frequency of each product in the invoices, allowing users to identify the most frequently invoiced products. The placeholder in the LIMIT clause represents the maximum number of product IDs to return.", "virtual_table": "SELECT Product_ID FROM INVOICES GROUP BY Product_ID ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5169", "db_id": "cre_Drama_Workshop_Groups", "question": "Find the id of the product ordered the most often on invoices.", "rationale": ["The query identifies the relevant table, which is 'Invoices'.", "It selects the 'Product_ID' column to display unique product identifiers.", "The results are grouped by 'Product_ID' to aggregate the data based on each product.", "The query orders the results by the count of occurrences of each product, in descending order, to highlight the most frequently invoiced products.", "The LIMIT clause is used to restrict the number of results returned, with a placeholder for the maximum number of products to display."], "gold_sql": "SELECT Product_ID FROM INVOICES GROUP BY Product_ID ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["invoices"], "description": "The virtual table summarizes the unique product identifiers from the 'Invoices' table, grouped by product ID. It orders the results based on the frequency of each product in the invoices, allowing users to identify the most frequently invoiced products. The placeholder in the LIMIT clause represents the maximum number of product IDs to return.", "virtual_table": "SELECT Product_ID FROM INVOICES GROUP BY Product_ID ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5126", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the descriptions of the service types with product price above 100?", "rationale": ["The query identifies the relevant tables, which are 'Ref_Service_Types' and 'Services'.", "It selects the 'Service_Type_Description' from 'Ref_Service_Types'.", "A JOIN is performed between 'Ref_Service_Types' and 'Services' on the 'Service_Type_Code' to link the service types with their corresponding services.", "A condition is added to filter the services based on their 'Product_Price', using a placeholder for numeric values."], "gold_sql": "SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Price  >  100", "source_tables": ["services", "ref_service_types"], "description": "The virtual table provides a list of service type descriptions from the 'Ref_Service_Types' table that are associated with services having a product price above a specified threshold. The placeholder in the WHERE clause represents the minimum product price to filter the results.", "virtual_table": "SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Price  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5132", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the phones and emails of workshop groups in which services are performed?", "rationale": ["The query identifies the relevant tables, which are 'Drama_Workshop_Groups' and 'Services'.", "It selects the columns to display, specifically 'Store_Phone' and 'Store_Email_Address' from the 'Drama_Workshop_Groups' table.", "A join condition is applied to link the 'Drama_Workshop_Groups' table with the 'Services' table based on the 'Workshop_Group_ID' to ensure that only relevant store information related to the workshop groups is retrieved."], "gold_sql": "SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID", "source_tables": ["services", "drama_workshop_groups"], "description": "The virtual table provides the phone numbers and email addresses of stores associated with specific drama workshop groups. The join between the 'Drama_Workshop_Groups' and 'Services' tables allows for the retrieval of contact information for stores linked to the workshop groups.", "virtual_table": "SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID"}
{"sample_id": "train.5166", "db_id": "cre_Drama_Workshop_Groups", "question": "What is the average quantities ordered with payment method code \"MasterCard\" on invoices?", "rationale": ["The query identifies the relevant table, which is 'Invoices'.", "It selects the average of the 'Order_Quantity' column to calculate the average quantity of products ordered.", "A condition is added to filter the results based on the 'payment_method_code' using a placeholder for string values."], "gold_sql": "SELECT avg(Order_Quantity) FROM Invoices WHERE payment_method_code  =  'MasterCard'", "source_tables": ["invoices"], "description": "This virtual table calculates the average quantity of products ordered from the 'Invoices' table, filtered by a specific payment method. The placeholder in the WHERE clause represents the unique code for the payment method used in the invoices.", "virtual_table": "SELECT avg(Order_Quantity) FROM Invoices WHERE payment_method_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5167", "db_id": "cre_Drama_Workshop_Groups", "question": "Check the invoices record and compute the average quantities ordered with the payment method \"MasterCard\".", "rationale": ["The query identifies the relevant table, which is 'Invoices'.", "It calculates the average of the 'Order_Quantity' column to determine the average quantity of products ordered.", "A condition is added to filter the results based on the 'payment_method_code' using a placeholder for string values."], "gold_sql": "SELECT avg(Order_Quantity) FROM Invoices WHERE payment_method_code  =  'MasterCard'", "source_tables": ["invoices"], "description": "This virtual table provides the average quantity of products ordered from the 'Invoices' table, filtered by a specific payment method. The placeholder in the WHERE clause represents the unique code for the payment method used in the invoices.", "virtual_table": "SELECT avg(Order_Quantity) FROM Invoices WHERE payment_method_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5133", "db_id": "cre_Drama_Workshop_Groups", "question": "Give me all the phone numbers and email addresses of the workshop groups where services are performed.", "rationale": ["The query identifies the relevant tables, which are 'Drama_Workshop_Groups' and 'Services'.", "It selects the columns to display, specifically 'Store_Phone' and 'Store_Email_Address' from the 'Drama_Workshop_Groups' table.", "A join condition is applied to link the 'Drama_Workshop_Groups' table with the 'Services' table based on the 'Workshop_Group_ID' to ensure that only relevant store information related to the workshop groups is retrieved."], "gold_sql": "SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID", "source_tables": ["services", "drama_workshop_groups"], "description": "The virtual table provides the phone number and email address of stores associated with specific drama workshop groups. The join between the 'Drama_Workshop_Groups' and 'Services' tables allows for the retrieval of contact information for stores linked to the workshop groups offering services.", "virtual_table": "SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID"}
{"sample_id": "train.5103", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the minimum, average, and maximum quantities ordered? Check all the invoices.", "rationale": ["The query identifies the relevant table, which is 'Invoices'.", "It selects the minimum, average, and maximum values of the 'Order_Quantity' column.", "The use of aggregate functions (min, avg, max) allows for a summary of the order quantities across all invoices."], "gold_sql": "SELECT min(Order_Quantity) ,  avg(Order_Quantity) ,  max(Order_Quantity) FROM INVOICES", "source_tables": ["invoices"], "description": "This virtual table summarizes the minimum, average, and maximum quantities of products ordered as recorded in the 'Invoices' table. The placeholders in the SELECT statement represent the aggregated values of the order quantities.", "virtual_table": "SELECT min(Order_Quantity) ,  avg(Order_Quantity) ,  max(Order_Quantity) FROM INVOICES"}
{"sample_id": "train.5965", "db_id": "cre_Theme_park", "question": "What are the names of tourist attraction that Alison visited but Rosalind did not visit?", "rationale": ["The query identifies the relevant tables: 'Tourist_Attractions', 'Visitors', and 'Visits'.", "It selects the 'Name' of the tourist attractions from 'Tourist_Attractions'.", "The JOIN operations link the tables based on the tourist attraction and tourist IDs to filter the results accordingly.", "The WHERE clause filters the results based on the details of the first tourist using a placeholder for string values.", "The EXCEPT clause is used to exclude the names of attractions visited by a second tourist, again using a placeholder for string values."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  'Alison' EXCEPT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  'Rosalind'", "source_tables": ["visits", "visitors", "tourist_attractions"], "description": "This virtual table lists the names of tourist attractions that have been visited by a specific tourist, excluding those that have also been visited by another specified tourist. The placeholders in the WHERE clause represent the details of the tourists.", "virtual_table": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5964", "db_id": "cre_Theme_park", "question": "Which tourist attractions do the tourists Vincent and Marcelle visit? Tell me the names of the attractions.", "rationale": ["The query identifies the relevant tables: 'Tourist_Attractions', 'Visitors', and 'Visits'.", "It selects the 'Name' of the tourist attractions from 'Tourist_Attractions' table.", "The JOIN operations link the 'Tourist_Attraction_ID' from 'Tourist_Attractions' with 'Visits' and 'Tourist_ID' from 'Visitors' with 'Visits'.", "The WHERE clause filters the results based on the details of the tourists using placeholders for string values.", "The INTERSECT operator is used to find common attractions visited by both tourists based on their details."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  'Vincent' INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  'Marcelle'", "source_tables": ["visits", "visitors", "tourist_attractions"], "description": "This virtual table lists the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.", "virtual_table": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5951", "db_id": "cre_Theme_park", "question": "Show different tourist attractions' names, ids, and the corresponding number of visits.", "rationale": ["The query identifies the relevant tables, 'Tourist_Attractions' and 'Visits'.", "It selects the 'Name' of the attraction from 'Tourist_Attractions' and the 'Tourist_Attraction_ID' from 'Visits'.", "The COUNT function is used to count the number of visits for each attraction.", "The JOIN operation links the two tables on the 'Tourist_Attraction_ID' to correlate visits with their respective attractions.", "The GROUP BY clause is used to group the results by 'Tourist_Attraction_ID' to aggregate the visit counts for each attraction."], "gold_sql": "SELECT T1.Name ,  T2.Tourist_Attraction_ID ,   COUNT(*) FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID", "source_tables": ["visits", "tourist_attractions"], "description": "This virtual table provides a summary of tourist attractions along with the count of visits for each attraction. It combines data from the 'Tourist_Attractions' table, which includes the name of the attraction, and the 'Visits' table, which records each visit to these attractions. The placeholder in the SELECT statement allows for the dynamic retrieval of the attraction's name and the associated visit count.", "virtual_table": "SELECT T1.Name ,  T2.Tourist_Attraction_ID ,   COUNT(*) FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID"}
{"sample_id": "train.5952", "db_id": "cre_Theme_park", "question": "What are the name, id and the corresponding number of visits for each  tourist attraction?", "rationale": ["The query identifies the relevant tables, 'Tourist_Attractions' and 'Visits'.", "It selects the 'Name' of the tourist attraction from 'Tourist_Attractions' and the 'Tourist_Attraction_ID' from 'Visits'.", "The COUNT function is used to count the number of visits for each attraction.", "The JOIN operation links the two tables based on the 'Tourist_Attraction_ID'.", "The GROUP BY clause is used to group the results by 'Tourist_Attraction_ID' to get the count of visits for each attraction."], "gold_sql": "SELECT T1.Name ,  T2.Tourist_Attraction_ID ,   COUNT(*) FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID", "source_tables": ["visits", "tourist_attractions"], "description": "This virtual table provides a summary of tourist attractions along with the count of visits for each attraction. It combines data from the 'Tourist_Attractions' table, which includes the names of the attractions, and the 'Visits' table, which records each visit to these attractions. The placeholder in the SELECT statement represents the unique identifier for each tourist attraction, while the COUNT function aggregates the number of visits for each attraction.", "virtual_table": "SELECT T1.Name ,  T2.Tourist_Attraction_ID ,   COUNT(*) FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID"}
{"sample_id": "train.5943", "db_id": "cre_Theme_park", "question": "Show the details and star ratings of the 3 least expensive hotels.", "rationale": ["The query identifies the relevant table, which is 'Hotels'.", "Selects the columns to display, 'other_hotel_details' and 'star_rating_code'.", "Orders the results by 'price_range' in ascending order to show cheaper hotels first.", "Limits the number of records returned based on a placeholder for numeric values."], "gold_sql": "SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT 3", "source_tables": ["hotels"], "description": "The virtual table provides details about hotels, specifically focusing on additional information about each hotel and its star rating code. The results are sorted by the price range of the hotels in ascending order, and the number of records returned is limited by a specified placeholder value.", "virtual_table": "SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5927", "db_id": "cre_Theme_park", "question": "What are the details of the markets that can be accessed by walk or bus?", "rationale": ["The query identifies the relevant tables, 'Street_Markets' and 'Tourist_Attractions'.", "It selects the 'Market_Details' column from the 'Street_Markets' table.", "A JOIN operation is performed to link 'Street_Markets' with 'Tourist_Attractions' based on the matching 'Market_ID' and 'Tourist_Attraction_ID'.", "Conditions are added to filter the results based on the 'How_to_Get_There' column from 'Tourist_Attractions', using placeholders for the different instructions."], "gold_sql": "SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  'walk' OR  T2.How_to_Get_There  =  'bus'", "source_tables": ["street_markets", "tourist_attractions"], "description": "The virtual table describes the details of street markets that are linked to tourist attractions based on specific instructions on how to reach those attractions. The placeholders in the WHERE clause represent the different ways to get to the attractions.", "virtual_table": "SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING] OR  T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5897", "db_id": "cre_Theme_park", "question": "Show the average price range of hotels that have 5 star ratings and allow pets.", "rationale": ["The query identifies the relevant table, which is 'Hotels'.", "It calculates the average of the 'price_range' column.", "Conditions are added to filter the results based on 'star_rating_code' and 'pets_allowed_yn', using placeholders for string and numeric values."], "gold_sql": "SELECT avg(price_range) FROM HOTELS WHERE star_rating_code  =  '5' AND pets_allowed_yn  =  1", "source_tables": ["hotels"], "description": "This virtual table provides the average price range of hotels from the 'Hotels' table that meet specific criteria. The placeholders in the WHERE clause represent the star rating code and whether pets are allowed, allowing users to filter the results based on their preferences.", "virtual_table": "SELECT avg(price_range) FROM HOTELS WHERE star_rating_code  =  [PLACEHOLDER-TYPE:STRING] AND pets_allowed_yn  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5928", "db_id": "cre_Theme_park", "question": "Find the details of all the markets that are accessible by walk or bus.", "rationale": ["The query identifies the relevant tables, 'Street_Markets' and 'Tourist_Attractions'.", "It selects the 'Market_Details' from the 'Street_Markets' table.", "A JOIN operation is performed to link 'Street_Markets' with 'Tourist_Attractions' using the 'Market_ID' and 'Tourist_Attraction_ID'.", "The WHERE clause filters the results based on the 'How_to_Get_There' column, allowing for two different sets of instructions using placeholders for string values."], "gold_sql": "SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  'walk' OR  T2.How_to_Get_There  =  'bus'", "source_tables": ["street_markets", "tourist_attractions"], "description": "The virtual table provides details about street markets that are linked to tourist attractions based on specific directions on how to reach them. The placeholders in the WHERE clause represent the different sets of instructions for accessing the attractions.", "virtual_table": "SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING] OR  T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5894", "db_id": "cre_Theme_park", "question": "What is the detail of each visitor?", "rationale": ["The query identifies the relevant table, which is 'Visitors'.", "Select the column to display, 'Tourist_Details'."], "gold_sql": "SELECT Tourist_Details FROM VISITORS", "source_tables": ["visitors"], "description": "The virtual table provides details about tourists from the 'Visitors' table. The placeholder represents the specific details related to each tourist.", "virtual_table": "SELECT Tourist_Details FROM VISITORS"}
{"sample_id": "train.5893", "db_id": "cre_Theme_park", "question": "Show details of all visitors.", "rationale": ["The query identifies the relevant table, which is 'Visitors'.", "Select the column to display, 'Tourist_Details'."], "gold_sql": "SELECT Tourist_Details FROM VISITORS", "source_tables": ["visitors"], "description": "The virtual table provides details about tourists from the 'Visitors' table. The placeholder in the SELECT clause represents the specific details related to each tourist.", "virtual_table": "SELECT Tourist_Details FROM VISITORS"}
{"sample_id": "train.5921", "db_id": "cre_Theme_park", "question": "What are the details and ways to get to tourist attractions related to royal family?", "rationale": ["The query identifies the relevant tables, 'Royal_Family' and 'Tourist_Attractions'.", "It selects the 'Royal_Family_Details' from the 'Royal_Family' table and 'How_to_Get_There' from the 'Tourist_Attractions' table.", "A JOIN operation is performed on the 'Royal_Family_ID' and 'Tourist_Attraction_ID' to link the two tables based on their relationship."], "gold_sql": "SELECT T1.Royal_Family_Details ,  T2.How_to_Get_There FROM ROYAL_FAMILY AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Royal_Family_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["royal_family", "tourist_attractions"], "description": "This virtual table provides details about royal families and the corresponding instructions on how to reach the associated tourist attractions. The placeholders represent the unique identifiers linking the royal family entries to the tourist attractions.", "virtual_table": "SELECT T1.Royal_Family_Details ,  T2.How_to_Get_There FROM ROYAL_FAMILY AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Royal_Family_ID  =  T2.Tourist_Attraction_ID"}
{"sample_id": "train.5914", "db_id": "cre_Theme_park", "question": "Give me the star rating descriptions of the hotels that cost more than 10000.", "rationale": ["The query identifies the relevant tables, which are 'Hotels' and 'Ref_Hotel_Star_Ratings'.", "It selects the 'star_rating_description' from the 'Ref_Hotel_Star_Ratings' table.", "A JOIN operation is performed on the 'star_rating_code' to link hotels with their respective star ratings.", "A condition is added to filter hotels based on their price range using a placeholder for numeric values."], "gold_sql": "SELECT T2.star_rating_description FROM HOTELS AS T1 JOIN Ref_Hotel_Star_Ratings AS T2 ON T1.star_rating_code  =  T2.star_rating_code WHERE T1.price_range  >  10000", "source_tables": ["ref_hotel_star_ratings", "hotels"], "description": "This virtual table provides the descriptions of star ratings for hotels that fall within a specified price range. The placeholder in the WHERE clause represents the minimum price range for filtering the hotels.", "virtual_table": "SELECT T2.star_rating_description FROM HOTELS AS T1 JOIN Ref_Hotel_Star_Ratings AS T2 ON T1.star_rating_code  =  T2.star_rating_code WHERE T1.price_range  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5902", "db_id": "cre_Theme_park", "question": "Return the detail of the location named \"UK Gallery\".", "rationale": ["The query identifies the relevant table, which is 'Locations'.", "Select the column to display, 'Other_Details'.", "Add a condition to filter the 'Location_Name' column for the specified location using a placeholder for string values."], "gold_sql": "SELECT Other_Details FROM LOCATIONS WHERE Location_Name  =  'UK Gallery'", "source_tables": ["locations"], "description": "This virtual table provides additional details about specific locations from the 'Locations' table based on the name of the location. The placeholder in the WHERE clause represents the name of the location being queried.", "virtual_table": "SELECT Other_Details FROM LOCATIONS WHERE Location_Name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5924", "db_id": "cre_Theme_park", "question": "Find the details of the shops that can be reached by walk.", "rationale": ["The query identifies the relevant tables, which are 'Shops' and 'Tourist Attractions'.", "It selects the 'Shop_Details' column from the 'Shops' table.", "A JOIN operation is performed to link 'Shops' with 'Tourist Attractions' based on the matching 'Shop_ID' and 'Tourist_Attraction_ID'.", "A condition is added to filter the results based on the 'How_to_Get_There' column from the 'Tourist Attractions' table using a placeholder for string values."], "gold_sql": "SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  'walk'", "source_tables": ["shops", "tourist_attractions"], "description": "This virtual table provides details about shops that are associated with specific tourist attractions. The placeholder in the WHERE clause represents the instructions on how to reach the attraction, allowing users to filter shops based on accessibility information.", "virtual_table": "SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5887", "db_id": "cre_Theme_park", "question": "What are the price ranges of hotels?", "rationale": ["The query identifies the relevant table, which is 'Hotels'.", "Select the column to display, 'price_range'.", "The query is straightforward as it retrieves the price range of hotels without any filtering conditions."], "gold_sql": "SELECT price_range FROM HOTELS", "source_tables": ["hotels"], "description": "The virtual table provides the price range of hotels from the 'Hotels' table. The placeholder in the SELECT statement allows for filtering or further specification of the query if needed.", "virtual_table": "SELECT price_range FROM HOTELS"}
{"sample_id": "train.5901", "db_id": "cre_Theme_park", "question": "What is the detail of the location UK Gallery?", "rationale": ["The query identifies the relevant table, which is 'Locations'.", "Select the column to display, 'Other_Details'.", "Add a condition to filter the 'Location_Name' column for the specified location using a placeholder for string values."], "gold_sql": "SELECT Other_Details FROM LOCATIONS WHERE Location_Name  =  'UK Gallery'", "source_tables": ["locations"], "description": "This virtual table provides additional details about specific locations from the 'Locations' table based on the name of the location. The placeholder in the WHERE clause represents the name of the location being queried.", "virtual_table": "SELECT Other_Details FROM LOCATIONS WHERE Location_Name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5888", "db_id": "cre_Theme_park", "question": "Tell me the price ranges for all the hotels.", "rationale": ["The query identifies the relevant table, which is 'Hotels'.", "Select the column to display, 'price_range'.", "The query is straightforward as it retrieves the price range of hotels without any filtering conditions."], "gold_sql": "SELECT price_range FROM HOTELS", "source_tables": ["hotels"], "description": "The virtual table provides the price range of hotels from the 'Hotels' table. The placeholder in the SELECT statement allows for filtering or further specification of the query if needed.", "virtual_table": "SELECT price_range FROM HOTELS"}
{"sample_id": "train.2335", "db_id": "csu_1", "question": "What campuses are located in Northridge, Los Angeles or in San Francisco, San Francisco?", "rationale": ["The query identifies the relevant table, which is 'Campuses'.", "It selects the 'campus' column to display the names of the campuses.", "The query includes a condition to filter campuses based on their 'Location' and 'County' using placeholders for string values.", "The UNION operator is used to combine results from two identical queries, ensuring that campuses meeting the criteria from both queries are included."], "gold_sql": "SELECT campus FROM campuses WHERE LOCATION  =  'Northridge' AND county  =  'Los Angeles' UNION SELECT campus FROM campuses WHERE LOCATION  =  'San Francisco' AND county  =  'San Francisco'", "source_tables": ["campuses"], "description": "This virtual table provides a list of campuses from the 'Campuses' table that are located in a specific geographical location and county. The placeholders in the WHERE clause represent the location and county names, allowing users to filter the results based on their criteria.", "virtual_table": "SELECT campus FROM campuses WHERE LOCATION  =  [PLACEHOLDER-TYPE:STRING] AND county  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT campus FROM campuses WHERE LOCATION  =  [PLACEHOLDER-TYPE:STRING] AND county  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2357", "db_id": "csu_1", "question": "how many degrees were conferred between 1998 and 2002?", "rationale": ["The query identifies the relevant tables, 'Campuses' and 'degrees'.", "It selects the 'campus' from the 'Campuses' table and sums the 'degrees' from the 'degrees' table.", "A JOIN operation is performed on the campus identifiers to link the two tables.", "The WHERE clause filters the results based on a specified range of years using placeholders for numeric values.", "The results are grouped by campus to provide a total count of degrees awarded per campus."], "gold_sql": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  1998 AND T2.year  <=  2002 GROUP BY T1.campus", "source_tables": ["degrees", "campuses"], "description": "This virtual table summarizes the total number of degrees awarded at each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.", "virtual_table": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.year  <=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus"}
{"sample_id": "train.2378", "db_id": "csu_1", "question": "List the campus that have between 600 and 1000 faculty lines in year 2004.", "rationale": ["The query identifies the relevant tables, 'Campuses' and 'faculty'.", "It selects the 'campus' column from the 'Campuses' table.", "A JOIN operation is performed between 'Campuses' and 'faculty' on the campus identifier.", "Conditions are added to filter the faculty count to be within a specified range using placeholders for numeric values.", "Another condition is included to filter the results based on the specified year using a placeholder for numeric values."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  600 AND t2.faculty  <=  1000 AND T1.year  =  2004", "source_tables": ["faculty", "campuses"], "description": "This virtual table provides a list of campuses from the 'Campuses' table that have a number of faculty members within a specified range. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of the data record.", "virtual_table": "SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  [PLACEHOLDER-TYPE:NUMBER] AND t2.faculty  <=  [PLACEHOLDER-TYPE:NUMBER] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2379", "db_id": "csu_1", "question": "What are the campuses that had between 600 and 1000 faculty members in 2004?", "rationale": ["The query identifies the relevant tables, 'Campuses' and 'faculty'.", "It selects the 'campus' column from the 'Campuses' table.", "A JOIN operation is performed between 'Campuses' and 'faculty' on the campus identifier.", "Conditions are added to filter the faculty count within a specified range using placeholders for numeric values.", "Another condition is included to filter the results based on a specific year using a placeholder for numeric values."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  600 AND t2.faculty  <=  1000 AND T1.year  =  2004", "source_tables": ["faculty", "campuses"], "description": "This virtual table provides a list of campuses from the 'Campuses' table that have a specific range of faculty members. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of the data record.", "virtual_table": "SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  [PLACEHOLDER-TYPE:NUMBER] AND t2.faculty  <=  [PLACEHOLDER-TYPE:NUMBER] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2358", "db_id": "csu_1", "question": "For each Orange county campus, report the number of degrees granted after 2000.", "rationale": ["The query identifies the relevant tables, 'Campuses' and 'degrees'.", "It selects the 'campus' from the 'Campuses' table and sums the 'degrees' from the 'degrees' table.", "A JOIN operation is performed on the 'Id' of 'Campuses' and 'Campus' of 'degrees' to link the two tables.", "Conditions are added to filter the results based on the specified county and year using placeholders for string and numeric values.", "The results are grouped by 'campus' to aggregate the total degrees awarded."], "gold_sql": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  'Orange' AND T2.year  >=  2000 GROUP BY T1.campus", "source_tables": ["degrees", "campuses"], "description": "This virtual table summarizes the total number of degrees awarded at campuses located in a specific county, filtered by a minimum year. The placeholders in the WHERE clause represent the county name and the year threshold.", "virtual_table": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  [PLACEHOLDER-TYPE:STRING] AND T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus"}
{"sample_id": "train.2349", "db_id": "csu_1", "question": "What campus has the most degrees  conferrred over its entire existence?", "rationale": ["The query identifies the relevant table, which is 'degrees'.", "It selects the 'campus' column to group the results by campus name.", "The results are ordered by the sum of degrees awarded, ensuring that campuses with the highest number of degrees appear first.", "A limit is applied to restrict the number of campuses returned, using a placeholder for numeric values."], "gold_sql": "SELECT campus FROM degrees GROUP BY campus ORDER BY sum(degrees) DESC LIMIT 1", "source_tables": ["degrees"], "description": "This virtual table summarizes the campuses that have awarded degrees, grouped by campus name. The results are ordered by the total number of degrees awarded in descending order, with a limit on the number of campuses returned. The placeholder in the LIMIT clause represents the maximum number of campuses to display.", "virtual_table": "SELECT campus FROM degrees GROUP BY campus ORDER BY sum(degrees) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2380", "db_id": "csu_1", "question": "How many faculty lines are there in the university that conferred the most number of degrees in year 2002?", "rationale": ["The query identifies the relevant tables, which are 'campuses', 'faculty', and 'degrees'.", "It selects the 'faculty' column from the 'faculty' table.", "The query joins the 'campuses' table with the 'faculty' table on the campus identifier, ensuring that the data corresponds to the correct campus.", "It also joins the 'degrees' table to filter the results based on the year when degrees were awarded, ensuring consistency in the data.", "A condition is added to filter the results for a specific year using a placeholder for numeric values.", "The results are ordered by the number of degrees awarded in descending order and limited to a specified number of results using placeholders."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2002 ORDER BY t3.degrees DESC LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "description": "This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It also joins with the 'degrees' table to ensure that the faculty data corresponds to the same year when degrees were awarded. The placeholders in the WHERE clause represent the year of interest and the limit on the number of results to return.", "virtual_table": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2351", "db_id": "csu_1", "question": "What campus has the most faculties in 2003?", "rationale": ["The query identifies the relevant tables, 'Campuses' and 'faculty'.", "It selects the 'campus' column from the 'Campuses' table.", "A JOIN operation is performed to link 'Campuses' with 'faculty' based on the campus identifier.", "A condition is added to filter the results for a specific year using a placeholder for numeric values.", "The results are ordered by the number of faculty members in descending order, and a limit is applied to control the number of results returned."], "gold_sql": "SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  2003 ORDER BY T2.faculty DESC LIMIT 1", "source_tables": ["faculty", "campuses"], "description": "This virtual table provides a list of campuses from the 'Campuses' table that have faculty data for a specific year. The results are ordered by the number of faculty members in descending order, and the placeholders allow for specifying the year and the limit on the number of campuses returned.", "virtual_table": "SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY T2.faculty DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2348", "db_id": "csu_1", "question": "Which campus has the most degrees conferred in all times?", "rationale": ["The query identifies the relevant table, which is 'degrees'.", "It selects the 'campus' column to display the campuses that awarded degrees.", "The results are grouped by 'campus' to aggregate the data for each campus.", "The ordering is done by the sum of degrees awarded, in descending order, to show the campuses with the highest number of degrees first.", "A limit is applied to restrict the number of campuses returned, using a placeholder for numeric values."], "gold_sql": "SELECT campus FROM degrees GROUP BY campus ORDER BY sum(degrees) DESC LIMIT 1", "source_tables": ["degrees"], "description": "This virtual table summarizes the campuses that have awarded degrees, grouped by campus name. The results are ordered by the total number of degrees awarded in descending order, with a limit on the number of campuses returned. The placeholder in the LIMIT clause represents the maximum number of campuses to display.", "virtual_table": "SELECT campus FROM degrees GROUP BY campus ORDER BY sum(degrees) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2327", "db_id": "csu_1", "question": "What campuses are located in Chico?", "rationale": ["The query is identifying the relevant table, which is 'Campuses'.", "Select the column to display, 'campus'.", "Add a condition to filter the 'Location' column for the specified location using a placeholder for string values."], "gold_sql": "SELECT campus FROM campuses WHERE LOCATION  =  'Chico'", "source_tables": ["campuses"], "description": "This virtual table describes the campuses from the 'Campuses' table that are located in a specific geographical location. The placeholder in the WHERE clause represents the location of the campus.", "virtual_table": "SELECT campus FROM campuses WHERE LOCATION  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2347", "db_id": "csu_1", "question": "In what year was the most degrees conferred?", "rationale": ["The query is identifying the relevant table, which is 'degrees'.", "Select the 'Year' column to display.", "Group the results by 'Year' to aggregate the data.", "Order the results by the sum of degrees awarded in descending order to show the years with the most degrees first.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT YEAR FROM degrees GROUP BY YEAR ORDER BY sum(degrees) DESC LIMIT 1", "source_tables": ["degrees"], "description": "This virtual table summarizes the years in which degrees were awarded, grouped by year, and ordered by the total number of degrees awarded in descending order. The placeholder in the LIMIT clause represents the maximum number of years to return.", "virtual_table": "SELECT YEAR FROM degrees GROUP BY YEAR ORDER BY sum(degrees) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2325", "db_id": "csu_1", "question": "What campuses are located in the county of Los Angeles?", "rationale": ["The query identifies the relevant table, which is 'Campuses'.", "Select the column to display, 'campus'.", "Add a condition to filter the 'county' column for the specified county using a placeholder for string values."], "gold_sql": "SELECT campus FROM campuses WHERE county  =  'Los Angeles'", "source_tables": ["campuses"], "description": "This virtual table provides a list of campuses from the 'Campuses' table that are located in a specific county. The placeholder in the WHERE clause represents the name of the county.", "virtual_table": "SELECT campus FROM campuses WHERE county  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2369", "db_id": "csu_1", "question": "How many degrees were conferred at San Jose State University in 2000?", "rationale": ["The query identifies the relevant tables, 'Campuses' and 'degrees'.", "It selects the 'degrees' column from the 'degrees' table.", "A JOIN operation is performed to link the 'Campuses' table with the 'degrees' table based on the campus identifier.", "Conditions are added to filter results for a specific campus and year using placeholders for string and numeric values."], "gold_sql": "SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  'San Jose State University' AND t2.year  =  2000", "source_tables": ["degrees", "campuses"], "description": "This virtual table provides information about the types of degrees awarded at a specific campus during a particular year. The placeholders in the WHERE clause represent the campus name and the year for which the degree data is being queried.", "virtual_table": "SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  [PLACEHOLDER-TYPE:STRING] AND t2.year  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2365", "db_id": "csu_1", "question": "How many campuses exist are in the county of LA?", "rationale": ["The query is identifying the relevant table, which is 'Campuses'.", "The count function is used to determine the number of campuses.", "A condition is added to filter the 'county' column for the specified county using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM campuses WHERE county  =  'Los Angeles'", "source_tables": ["campuses"], "description": "This virtual table provides a count of campuses located in a specific county from the 'Campuses' table. The placeholder in the WHERE clause represents the name of the county.", "virtual_table": "SELECT count(*) FROM campuses WHERE county  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2367", "db_id": "csu_1", "question": "What campuses are in Los Angeles county?", "rationale": ["The query is identifying the relevant table, which is 'Campuses'.", "Select the column to display, 'campus'.", "Add a condition to filter the 'county' column for the specified county using a placeholder for string values."], "gold_sql": "SELECT campus FROM campuses WHERE county  =  'Los Angeles'", "source_tables": ["campuses"], "description": "This virtual table provides a list of campuses from the 'Campuses' table that are located in a specific county. The placeholder in the WHERE clause represents the name of the county.", "virtual_table": "SELECT campus FROM campuses WHERE county  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2387", "db_id": "csu_1", "question": "How many people graduated from San Francisco State University in 2004?", "rationale": ["The query identifies the relevant tables, 'discipline_enrollments' and 'campuses'.", "It selects the sum of graduate enrollments from 'discipline_enrollments'.", "A JOIN operation is performed to link 'discipline_enrollments' with 'campuses' based on the campus identifier.", "Conditions are added to filter the results by a specific year and campus name using placeholders for numeric and string values."], "gold_sql": "SELECT sum(t1.graduate) FROM discipline_enrollments AS t1 JOIN campuses AS t2 ON t1.campus  =  t2.id WHERE t1.year  =  2004 AND t2.campus  =  'San Francisco State University'", "source_tables": ["discipline_enrollments", "campuses"], "description": "This virtual table summarizes the total number of graduate enrollments from the 'discipline_enrollments' table for a specific campus and year. The placeholders in the WHERE clause represent the year of enrollment and the name of the campus.", "virtual_table": "SELECT sum(t1.graduate) FROM discipline_enrollments AS t1 JOIN campuses AS t2 ON t1.campus  =  t2.id WHERE t1.year  =  [PLACEHOLDER-TYPE:NUMBER] AND t2.campus  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6981", "db_id": "culture_company", "question": "Which publishers did not publish a book in 1989?", "rationale": ["The query is identifying the relevant table, which is 'book_club'.", "Select the column to display, 'publisher'.", "Use the EXCEPT clause to exclude publishers from the results based on a specific year using a placeholder for numeric values."], "gold_sql": "SELECT publisher FROM book_club EXCEPT SELECT publisher FROM book_club WHERE YEAR  =  1989", "source_tables": ["book_club"], "description": "This virtual table identifies publishers of books discussed in the 'book_club' table, excluding those that were published in a specific year. The placeholder in the WHERE clause represents the year to be excluded from the results.", "virtual_table": "SELECT publisher FROM book_club EXCEPT SELECT publisher FROM book_club WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6972", "db_id": "culture_company", "question": "What is the publisher with most number of books?", "rationale": ["The query identifies the relevant table, which is 'book_club'.", "It selects the 'publisher' column to display.", "The results are grouped by 'publisher' to aggregate the data.", "The results are ordered by the count of discussions for each publisher in descending order.", "A limit is applied to restrict the number of publishers returned, using a placeholder for numeric values."], "gold_sql": "SELECT publisher FROM book_club GROUP BY publisher ORDER BY count(*) DESC LIMIT 1", "source_tables": ["book_club"], "description": "This virtual table summarizes the publishers of books discussed in the 'book_club' table. It groups the results by publisher and orders them by the number of discussions, allowing users to see the most frequently mentioned publishers. The placeholder in the LIMIT clause represents the maximum number of publishers to return.", "virtual_table": "SELECT publisher FROM book_club GROUP BY publisher ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6995", "db_id": "culture_company", "question": "What are all the company names that have a book published by Alyson?", "rationale": ["The query identifies the relevant tables, which are 'culture_company' and 'book_club'.", "It selects the 'company_name' column from the 'culture_company' table.", "A JOIN operation is performed to link 'culture_company' with 'book_club' using the foreign key 'book_club_id'.", "A condition is added to filter the results based on the 'publisher' column from the 'book_club' table, using a placeholder for string values."], "gold_sql": "SELECT T1.company_name FROM culture_company AS T1 JOIN book_club AS T2 ON T1.book_club_id  =  T2.book_club_id WHERE T2.publisher  =  'Alyson'", "source_tables": ["culture_company", "book_club"], "description": "This virtual table provides the names of cultural companies that are associated with book clubs, specifically filtering for those book clubs that have a particular publisher. The placeholder in the WHERE clause represents the name of the publisher.", "virtual_table": "SELECT T1.company_name FROM culture_company AS T1 JOIN book_club AS T2 ON T1.book_club_id  =  T2.book_club_id WHERE T2.publisher  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6994", "db_id": "culture_company", "question": "List all company names with a book published by Alyson.", "rationale": ["The query identifies the relevant tables, which are 'culture_company' and 'book_club'.", "It selects the 'company_name' column from the 'culture_company' table.", "A JOIN operation is performed to link 'culture_company' with 'book_club' using the foreign key 'book_club_id'.", "A condition is added to filter the results based on the 'publisher' column from the 'book_club' table, using a placeholder for string values."], "gold_sql": "SELECT T1.company_name FROM culture_company AS T1 JOIN book_club AS T2 ON T1.book_club_id  =  T2.book_club_id WHERE T2.publisher  =  'Alyson'", "source_tables": ["culture_company", "book_club"], "description": "This virtual table provides the names of cultural companies that are associated with book clubs, specifically filtering for those book clubs that have a particular publisher. The placeholder in the WHERE clause represents the name of the publisher.", "virtual_table": "SELECT T1.company_name FROM culture_company AS T1 JOIN book_club AS T2 ON T1.book_club_id  =  T2.book_club_id WHERE T2.publisher  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5779", "db_id": "customer_complaints", "question": "Return the names of products that have had complaints filed by the customer who has filed the fewest complaints.", "rationale": ["The query identifies the relevant tables: 'Products', 'Complaints', and 'Customers'.", "It selects distinct product names from the 'Products' table.", "The JOIN operation links the 'Products' table with the 'Complaints' table based on the product ID, ensuring that only products with complaints are considered.", "Another JOIN links the 'Complaints' table with the 'Customers' table, allowing for grouping by customer ID.", "The GROUP BY clause is used to aggregate the results based on customer ID, which helps in counting the number of complaints per product.", "The ORDER BY count(*) sorts the results based on the number of complaints, ensuring that the most complained about products are listed first.", "The LIMIT clause, with a placeholder, allows the user to specify how many product names to return."], "gold_sql": "SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "products", "customers"], "description": "This virtual table provides a list of distinct product names from the 'Products' table that have been associated with complaints. The results are filtered based on the number of complaints per customer, ensuring that only the most frequently complained about products are displayed. The placeholder in the LIMIT clause allows for specifying the maximum number of product names to return.", "virtual_table": "SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5772", "db_id": "customer_complaints", "question": "Which city has the least number of customers whose type code is \"Good Credit Rating\"?", "rationale": ["The query identifies the relevant table, which is 'Customers'.", "Select the column to display, 'town_city'.", "Add a condition to filter the 'customer_type_code' column for the specified customer type using a placeholder for string values.", "Group the results by 'town_city' to aggregate the data.", "Order the results by the count of occurrences to prioritize the most common towns or cities.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT town_city FROM customers WHERE customer_type_code  =  'Good Credit Rating' GROUP BY town_city ORDER BY count(*) LIMIT 1", "source_tables": ["customers"], "description": "This virtual table provides a list of town or city names from the 'Customers' table, filtered by a specific customer type code. The results are grouped by town or city and ordered by the count of occurrences, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the customer type code and the maximum number of results to display.", "virtual_table": "SELECT town_city FROM customers WHERE customer_type_code  =  [PLACEHOLDER-TYPE:STRING] GROUP BY town_city ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5776", "db_id": "customer_complaints", "question": "Find the emails of customers who has filed a complaints of the product with the most complaints.", "rationale": ["The query identifies the relevant tables, which are 'Customers' and 'Complaints'.", "It selects the 'email_address' from the 'Customers' table, aliased as 't1'.", "A JOIN operation is performed between 'Customers' and 'Complaints' on the 'customer_id' to link customers with their complaints.", "The results are grouped by 'customer_id' to ensure unique email addresses are returned.", "The ORDER BY clause is used to sort the results based on the count of complaints per customer, and the LIMIT clause allows for specifying how many results to return."], "gold_sql": "SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "customers"], "description": "This virtual table provides the email addresses of customers who have made complaints, grouped by customer ID. The placeholder in the LIMIT clause allows for specifying the maximum number of email addresses to retrieve.", "virtual_table": "SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5813", "db_id": "customer_complaints", "question": "Give the state that has the most customers.", "rationale": ["The query identifies the relevant table, which is 'Customers'.", "It selects the 'state' column to display the states of customers.", "The GROUP BY clause is used to group the results by 'state' to count the number of customers in each state.", "The ORDER BY clause sorts the results based on the count of customers in each state.", "The LIMIT clause restricts the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT state FROM customers GROUP BY state ORDER BY count(*) LIMIT 1", "source_tables": ["customers"], "description": "This virtual table summarizes the states where customers reside, grouped by state. It provides a count of customers in each state, allowing for an ordered list based on the number of customers. The placeholder in the LIMIT clause represents the maximum number of states to return.", "virtual_table": "SELECT state FROM customers GROUP BY state ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5800", "db_id": "customer_complaints", "question": "How many customers are there in the customer type with the most customers?", "rationale": ["The query identifies the relevant table, which is 'Customers'.", "It counts the number of customers and groups the results by 'customer_type_code'.", "The results are ordered in descending order based on the count of customers for each type.", "A placeholder is included in the LIMIT clause to allow the user to specify how many customer types to return."], "gold_sql": "SELECT count(*) FROM customers GROUP BY customer_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers"], "description": "This virtual table summarizes the number of customers grouped by their type, providing insights into the distribution of customer types. The placeholder in the LIMIT clause allows for specifying the maximum number of customer types to display based on their count.", "virtual_table": "SELECT count(*) FROM customers GROUP BY customer_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5812", "db_id": "customer_complaints", "question": "Which state has the most customers?", "rationale": ["The query identifies the relevant table, which is 'Customers'.", "It selects the 'state' column to display the states of the customers.", "The GROUP BY clause is used to group the results by 'state'.", "The ORDER BY clause sorts the states based on the count of customers in each state.", "The LIMIT clause uses a placeholder to specify the maximum number of states to return."], "gold_sql": "SELECT state FROM customers GROUP BY state ORDER BY count(*) LIMIT 1", "source_tables": ["customers"], "description": "This virtual table summarizes the states where customers reside, grouped by state. The placeholder in the LIMIT clause allows for specifying the maximum number of states to return based on the count of customers in each state.", "virtual_table": "SELECT state FROM customers GROUP BY state ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5802", "db_id": "customer_complaints", "question": "What is the last name of the staff who has handled the first ever complaint?", "rationale": ["The query identifies the relevant tables, which are 'staff' and 'complaints'.", "It selects the 'last_name' column from the 'staff' table.", "A JOIN operation is performed between 'staff' and 'complaints' on the 'staff_id' to link staff members to the complaints they are handling.", "The results are ordered by the 'date_complaint_raised' from the 'complaints' table to show the most recent complaints first.", "The LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id ORDER BY t2.date_complaint_raised LIMIT 1", "source_tables": ["complaints", "staff"], "description": "This virtual table provides a list of last names of staff members who are handling complaints, ordered by the date the complaints were raised. The placeholder in the LIMIT clause allows for specifying the maximum number of staff names to retrieve.", "virtual_table": "SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id ORDER BY t2.date_complaint_raised LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5794", "db_id": "customer_complaints", "question": "Find the last name of the staff member who processed the complaint of the cheapest product.", "rationale": ["The query identifies the relevant tables: 'Staff', 'Complaints', and 'Products'.", "It selects the 'last_name' column from the 'Staff' table.", "The JOIN operations link the 'Staff' table to the 'Complaints' table using 'staff_id', and the 'Complaints' table to the 'Products' table using 'product_id'.", "The results are ordered by the 'product_price' from the 'Products' table.", "The LIMIT clause uses a placeholder to allow the user to specify how many results they want to retrieve."], "gold_sql": "SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT 1", "source_tables": ["complaints", "products", "staff"], "description": "This virtual table provides a list of last names of staff members who are handling complaints related to products. The data is sourced from the 'Staff', 'Complaints', and 'Products' tables, with the results ordered by the price of the products involved in the complaints. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.", "virtual_table": "SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2857", "db_id": "customer_deliveries", "question": "List the state names and the number of customers living in each state.", "rationale": ["The query identifies the relevant tables, which are 'Customer_Addresses' and 'Addresses'.", "It performs a JOIN operation to combine data from both tables based on the address ID.", "The SELECT statement specifies the 'state_province_county' column from the 'Addresses' table and counts the number of occurrences for each state, province, or county.", "The GROUP BY clause is used to aggregate the results by 'state_province_county' to provide a count for each unique state, province, or county."], "gold_sql": "SELECT t2.state_province_county ,  count(*) FROM customer_addresses AS t1 JOIN addresses AS t2 ON t1.address_id  =  t2.address_id GROUP BY t2.state_province_county", "source_tables": ["addresses", "customer_addresses"], "description": "The virtual table summarizes the count of customer addresses grouped by state, province, or county from the 'Addresses' table. The placeholder in the SELECT statement represents the state, province, or county, while the count indicates the number of customer addresses in each grouping.", "virtual_table": "SELECT t2.state_province_county ,  count(*) FROM customer_addresses AS t1 JOIN addresses AS t2 ON t1.address_id  =  t2.address_id GROUP BY t2.state_province_county"}
{"sample_id": "train.2843", "db_id": "customer_deliveries", "question": "Find the name and price of the product that has been ordered the greatest number of times.", "rationale": ["The query identifies the relevant tables, 'Products' and 'Regular_Order_Products'.", "It selects the columns to display, 'product_name' and 'product_price' from the 'Products' table.", "A JOIN operation is performed on 'Products' and 'Regular_Order_Products' to link products with their orders based on 'product_id'.", "The results are grouped by 'product_id' to count occurrences of each product in the orders.", "The results are ordered in descending order based on the count of occurrences, allowing the most frequently ordered products to appear first.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT t1.product_name ,   t1.product_price FROM products AS t1 JOIN regular_order_products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t2.product_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["regular_order_products", "products"], "description": "The virtual table summarizes the names and prices of products from the 'Products' table that are included in regular orders. It groups the results by product ID to count how many times each product appears in the orders, allowing for an ordered list of the most frequently ordered products. The placeholder in the LIMIT clause represents the maximum number of products to return.", "virtual_table": "SELECT t1.product_name ,   t1.product_price FROM products AS t1 JOIN regular_order_products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t2.product_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2854", "db_id": "customer_deliveries", "question": "Find the payment method that is used most frequently.", "rationale": ["The query identifies the relevant table, which is 'Customers'.", "It selects the 'payment_method' column to display the preferred payment methods.", "The results are grouped by 'payment_method' to aggregate the data.", "The results are ordered by the count of each payment method in descending order to show the most popular methods first.", "A limit is applied to restrict the number of payment methods returned, using a placeholder for numeric values."], "gold_sql": "SELECT payment_method FROM Customers GROUP BY payment_method ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers"], "description": "The virtual table summarizes the preferred payment methods of customers from the 'Customers' table. It groups the results by payment method and orders them by the frequency of each method, allowing the user to specify a limit on the number of payment methods returned.", "virtual_table": "SELECT payment_method FROM Customers GROUP BY payment_method ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2853", "db_id": "customer_deliveries", "question": "Find the name of the first 5 customers.", "rationale": ["The query identifies the relevant table, which is 'Customers'.", "Select the column to display, 'customer_name'.", "Order the results by the 'date_became_customer' column to show the most recent customers first.", "Use a placeholder in the LIMIT clause to allow the user to specify how many customer names to retrieve."], "gold_sql": "SELECT customer_name FROM Customers ORDER BY date_became_customer LIMIT 5", "source_tables": ["customers"], "description": "This virtual table provides a list of customer names from the 'Customers' table, ordered by the date they became customers. The placeholder in the LIMIT clause allows for specifying the maximum number of customer names to retrieve.", "virtual_table": "SELECT customer_name FROM Customers ORDER BY date_became_customer LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6106", "db_id": "customers_and_addresses", "question": "What are the name and active date of the customers whose contact channel code is email?", "rationale": ["The query identifies the relevant tables, 'Customers' and 'Customer_Contact_Channels'.", "It selects the 'customer_name' from the 'Customers' table and 'active_from_date' from the 'Customer_Contact_Channels' table.", "A JOIN operation is performed on the 'customer_id' to link customers with their contact channels.", "A condition is added to filter the results based on the specified 'channel_code' using a placeholder for string values."], "gold_sql": "SELECT t1.customer_name ,  t2.active_from_date FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t2.channel_code  =  'Email'", "source_tables": ["customer_contact_channels", "customers"], "description": "This virtual table provides the names of customers along with the activation dates of their preferred contact channels. The placeholder in the WHERE clause represents the specific contact channel code being queried.", "virtual_table": "SELECT t1.customer_name ,  t2.active_from_date FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t2.channel_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6105", "db_id": "customers_and_addresses", "question": "Find the name and active date of the customer that use email as the contact channel.", "rationale": ["The query identifies the relevant tables, 'Customers' and 'Customer_Contact_Channels'.", "It selects the 'customer_name' from the 'Customers' table and 'active_from_date' from the 'Customer_Contact_Channels' table.", "A JOIN operation is performed on the 'customer_id' to link customers with their contact channels.", "A condition is added to filter the results based on the specified 'channel_code' using a placeholder for string values."], "gold_sql": "SELECT t1.customer_name ,  t2.active_from_date FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t2.channel_code  =  'Email'", "source_tables": ["customer_contact_channels", "customers"], "description": "This virtual table provides the names of customers along with the activation dates of their preferred contact channels. The placeholder in the WHERE clause represents the specific contact channel code being queried.", "virtual_table": "SELECT t1.customer_name ,  t2.active_from_date FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t2.channel_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6104", "db_id": "customers_and_addresses", "question": "Return the channel code and contact number of the customer contact channel whose active duration was the longest.", "rationale": ["The query identifies the relevant table, which is 'Customer_Contact_Channels'.", "Select the columns to display, 'channel_code' and 'contact_number'.", "Add a condition to filter the records based on the difference between 'active_to_date' and 'active_from_date'.", "Use a subquery to find the maximum duration of activity and limit the results based on a placeholder for numeric values."], "gold_sql": "SELECT channel_code ,  contact_number FROM customer_contact_channels WHERE active_to_date - active_from_date  =  (SELECT active_to_date - active_from_date FROM customer_contact_channels ORDER BY (active_to_date - active_from_date) DESC LIMIT 1)", "source_tables": ["customer_contact_channels"], "description": "This virtual table provides information about the contact channels of customers, specifically the channel code and associated contact number. The query filters the contact channels based on the duration of their activity, comparing it to the longest active duration found in the table. The placeholder in the LIMIT clause allows for specifying how many records to retrieve based on the longest active duration.", "virtual_table": "SELECT channel_code ,  contact_number FROM customer_contact_channels WHERE active_to_date - active_from_date  =  (SELECT active_to_date - active_from_date FROM customer_contact_channels ORDER BY (active_to_date - active_from_date) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.6134", "db_id": "customers_and_addresses", "question": "What are all the addresses in East Julianaside, Texas or in Gleasonmouth, Arizona.", "rationale": ["The query identifies the relevant table, which is 'Addresses'.", "It selects the 'address_content' column to display the detailed description of the addresses.", "The query includes two UNIONed SELECT statements to combine results from two identical queries, each filtering by 'city' and 'state_province_county' using placeholders for string values."], "gold_sql": "SELECT address_content FROM addresses WHERE city  =  'East Julianaside' AND state_province_county  =  'Texas' UNION SELECT address_content FROM addresses WHERE city  =  'Gleasonmouth' AND state_province_county  =  'Arizona'", "source_tables": ["addresses"], "description": "This virtual table provides a list of address contents from the 'Addresses' table that match specific criteria for city and state, allowing for the retrieval of addresses from two different queries based on the same conditions. The placeholders in the WHERE clauses represent the city and state values to be specified by the user.", "virtual_table": "SELECT address_content FROM addresses WHERE city  =  [PLACEHOLDER-TYPE:STRING] AND state_province_county  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT address_content FROM addresses WHERE city  =  [PLACEHOLDER-TYPE:STRING] AND state_province_county  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6129", "db_id": "customers_and_addresses", "question": "Which product has been ordered most number of times?", "rationale": ["The query identifies the relevant tables, which are 'Order_Items' and 'Products'.", "It selects the 'product_details' from the 'Products' table.", "The query joins 'Order_Items' with 'Products' on the product ID to link ordered items with their details.", "It groups the results by 'product_id' to aggregate the order counts for each product.", "The results are ordered by the count of orders in descending order to show the most ordered products first.", "The placeholder in the LIMIT clause allows the user to specify how many product details they want to retrieve."], "gold_sql": "SELECT t2.product_details FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["products", "order_items"], "description": "This virtual table provides a summary of product details from the 'Products' table based on the quantity of each product ordered. The query joins the 'Order_Items' table with the 'Products' table to retrieve the product specifications, grouping the results by product ID and ordering them by the count of orders in descending order. The placeholder in the LIMIT clause represents the maximum number of product details to return.", "virtual_table": "SELECT t2.product_details FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6065", "db_id": "customers_and_addresses", "question": "Which payment method is used by most customers?", "rationale": ["The query identifies the relevant table, which is 'Customers'.", "It selects the 'payment_method' column to display the different payment methods used by customers.", "The results are grouped by 'payment_method' to aggregate the data based on unique payment methods.", "The query orders the results by the count of each payment method in descending order to show the most popular methods first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT payment_method FROM customers GROUP BY payment_method ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers"], "description": "This virtual table summarizes the preferred payment methods used by customers in the 'Customers' table. It groups the results by payment method and orders them by the frequency of each method, allowing for a limit on the number of results returned.", "virtual_table": "SELECT payment_method FROM customers GROUP BY payment_method ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6098", "db_id": "customers_and_addresses", "question": "Find the contact channel code that was used by the customer named \"Tillman Ernser\".", "rationale": ["The query identifies the relevant tables, which are 'Customers' and 'Customer_Contact_Channels'.", "It selects the distinct 'channel_code' to ensure unique contact channels are listed.", "A JOIN operation is performed on 'customer_id' to link customers with their contact channels.", "A condition is added to filter the results based on the specified customer's name using a placeholder for string values."], "gold_sql": "SELECT DISTINCT channel_code FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  'Tillman Ernser'", "source_tables": ["customer_contact_channels", "customers"], "description": "This virtual table provides a distinct list of contact channels used by customers from the 'Customers' table based on the customer's name. The placeholder in the WHERE clause represents the specific customer's name being queried.", "virtual_table": "SELECT DISTINCT channel_code FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6066", "db_id": "customers_and_addresses", "question": "Find the payment method that is used most frequently.", "rationale": ["The query identifies the relevant table, which is 'Customers'.", "It selects the 'payment_method' column to display the different payment methods used by customers.", "The query groups the results by 'payment_method' to aggregate the data based on unique payment methods.", "It orders the results by the count of each payment method in descending order to show the most popular methods first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT payment_method FROM customers GROUP BY payment_method ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers"], "description": "This virtual table summarizes the preferred payment methods used by customers in the 'Customers' table. It groups the results by payment method and orders them by the frequency of each method, allowing for a limit on the number of results returned. The placeholder in the LIMIT clause represents the maximum number of payment methods to display.", "virtual_table": "SELECT payment_method FROM customers GROUP BY payment_method ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6099", "db_id": "customers_and_addresses", "question": "What is the \"active to date\" of the latest contact channel used by \"Tillman Ernser\"?", "rationale": ["The query identifies the relevant tables, which are 'Customers' and 'Customer_Contact_Channels'.", "It selects the maximum value of 'active_to_date' from the 'Customer_Contact_Channels' table.", "A JOIN operation is performed on 'customer_id' to link the two tables based on the customer.", "A condition is added to filter the results based on the specified customer's name using a placeholder for string values."], "gold_sql": "SELECT max(t2.active_to_date) FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  'Tillman Ernser'", "source_tables": ["customer_contact_channels", "customers"], "description": "This virtual table provides the maximum deactivation date of contact channels for a specific customer from the 'Customers' and 'Customer_Contact_Channels' tables. The placeholder in the WHERE clause represents the customer's name.", "virtual_table": "SELECT max(t2.active_to_date) FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6072", "db_id": "customers_and_addresses", "question": "Return the the details of all products.", "rationale": ["The query is identifying the relevant table, which is 'Products'.", "Select the column to display, 'product_details'.", "Use DISTINCT to ensure that only unique product specifications are returned."], "gold_sql": "SELECT DISTINCT product_details FROM products", "source_tables": ["products"], "description": "This virtual table provides a unique list of product specifications from the 'Products' table. The placeholder in the SELECT clause represents the product details that can be filtered or modified as needed.", "virtual_table": "SELECT DISTINCT product_details FROM products"}
{"sample_id": "train.6059", "db_id": "customers_and_addresses", "question": "What is the average amount of items ordered in each order?", "rationale": ["The query is identifying the relevant table, which is 'Order_Items'.", "Select the average of the 'order_quantity' column to calculate the average quantity of products ordered."], "gold_sql": "SELECT avg(order_quantity) FROM order_items", "source_tables": ["order_items"], "description": "This virtual table provides the average quantity of products ordered from the 'Order_Items' table. The placeholder in the SELECT clause represents the average quantity of the ordered items.", "virtual_table": "SELECT avg(order_quantity) FROM order_items"}
{"sample_id": "train.6102", "db_id": "customers_and_addresses", "question": "Compute the average active time span of contact channels.", "rationale": ["The query is identifying the relevant table, which is 'Customer_Contact_Channels'.", "The SELECT clause is calculating the average duration between 'active_to_date' and 'active_from_date'.", "The result will provide insights into how long, on average, contact channels remain active for customers."], "gold_sql": "SELECT avg(active_to_date - active_from_date) FROM customer_contact_channels", "source_tables": ["customer_contact_channels"], "description": "This virtual table calculates the average duration for which contact channels have been active for customers. The placeholder in the SELECT clause represents the calculation of the difference between the active dates, which is averaged across all records in the 'Customer_Contact_Channels' table.", "virtual_table": "SELECT avg(active_to_date - active_from_date) FROM customer_contact_channels"}
{"sample_id": "train.6127", "db_id": "customers_and_addresses", "question": "Who made the latest order?", "rationale": ["The query identifies the relevant tables, which are 'Customers' and 'Customer_Orders'.", "It selects the 'customer_name' column from the 'Customers' table.", "A JOIN operation is performed to link 'Customers' with 'Customer_Orders' based on the 'customer_id'.", "The results are ordered by 'order_date' in descending order to show the most recent orders first.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT t1.customer_name FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id ORDER BY t2.order_date DESC LIMIT 1", "source_tables": ["customer_orders", "customers"], "description": "This virtual table provides a list of customer names from the 'Customers' table who have placed orders, sorted by the date of their orders in descending order. The placeholder in the LIMIT clause represents the maximum number of customer names to retrieve.", "virtual_table": "SELECT t1.customer_name FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id ORDER BY t2.order_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1590", "db_id": "customers_and_invoices", "question": "Return the names and ids of each account, as well as the number of transactions.", "rationale": ["The query identifies the relevant tables, which are 'Financial_Transactions' and 'Accounts'.", "It selects the 'account_name' from the 'Accounts' table and 'account_id' from the 'Financial_Transactions' table.", "The count function is used to aggregate the number of transactions for each account.", "A JOIN operation is performed on the 'account_id' to link transactions to their respective accounts.", "Finally, the results are grouped by 'account_id' to provide a count of transactions per account."], "gold_sql": "SELECT T2.account_name ,  T1.account_id ,  count(*) FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id GROUP BY T1.account_id", "source_tables": ["accounts", "financial_transactions"], "description": "This virtual table summarizes the account names and their corresponding account IDs from the 'Accounts' table, along with the count of financial transactions associated with each account from the 'Financial_Transactions' table. The placeholders in the SELECT statement represent the account name and account ID, while the count reflects the number of transactions linked to each account.", "virtual_table": "SELECT T2.account_name ,  T1.account_id ,  count(*) FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id GROUP BY T1.account_id"}
{"sample_id": "train.1570", "db_id": "customers_and_invoices", "question": "What are the the full names and ids for all customers, and how many accounts does each have?", "rationale": ["The query identifies the relevant tables, 'Accounts' and 'Customers'.", "It selects the 'customer_id', 'customer_first_name', and 'customer_last_name' from the 'Customers' table.", "It counts the number of accounts for each customer using the COUNT function.", "The JOIN operation links the 'Accounts' table with the 'Customers' table based on the 'customer_id'.", "The GROUP BY clause is used to group the results by 'customer_id' to aggregate the count of accounts for each customer."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id", "source_tables": ["accounts", "customers"], "description": "This virtual table provides a summary of customers who have accounts, displaying their unique customer identifiers, first names, and last names. The count of accounts associated with each customer is also included. The placeholders represent the customer details and the count of accounts.", "virtual_table": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id"}
{"sample_id": "train.1569", "db_id": "customers_and_invoices", "question": "Show id, first name and last name for all customers and the number of accounts.", "rationale": ["The query identifies the relevant tables, 'Accounts' and 'Customers', to gather customer information.", "It selects the 'customer_id', 'customer_first_name', and 'customer_last_name' from the 'Customers' table.", "The query counts the number of accounts for each customer by using the COUNT function and grouping the results by 'customer_id'.", "A JOIN operation is performed to link the 'Accounts' table with the 'Customers' table based on the 'customer_id' field."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id", "source_tables": ["accounts", "customers"], "description": "This virtual table provides a summary of customers who have accounts, displaying their unique identifiers, first names, and last names. The count represents the number of accounts associated with each customer. The placeholders in the SELECT statement allow for dynamic retrieval of customer information based on their account details.", "virtual_table": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id"}
{"sample_id": "train.1610", "db_id": "customers_and_invoices", "question": "Return the order ids and details for orderes with two or more invoices.", "rationale": ["The query identifies the relevant tables, which are 'Invoices' and 'Orders'.", "It selects the columns to display, specifically 'order_id' and 'order_details' from the 'Orders' table.", "A JOIN operation is performed between 'Invoices' and 'Orders' on the 'order_id' to link the two tables.", "The results are grouped by 'order_id' to aggregate the data for each order.", "A HAVING clause is added to filter the groups, ensuring only those with a count of associated invoices greater than a specified number are included."], "gold_sql": "SELECT T2.order_id ,  T2.order_details FROM Invoices AS T1 JOIN Orders AS T2 ON T1.order_id  =  T2.order_id GROUP BY T2.order_id HAVING count(*)  >  2", "source_tables": ["orders", "invoices"], "description": "The virtual table summarizes the order IDs and their corresponding details from the 'Orders' table that are associated with invoices in the 'Invoices' table. It filters the results to include only those orders that have more than a specified number of associated invoices, represented by a placeholder for numeric values.", "virtual_table": "SELECT T2.order_id ,  T2.order_details FROM Invoices AS T1 JOIN Orders AS T2 ON T1.order_id  =  T2.order_id GROUP BY T2.order_id HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1623", "db_id": "customers_and_invoices", "question": "Show order ids and the number of products in each order.", "rationale": ["The query identifies the relevant table, which is 'Order_Items'.", "Select the 'order_id' to group the results by each order.", "Use the count function with DISTINCT to count unique 'product_id' values for each order, ensuring that only distinct products are counted."], "gold_sql": "SELECT order_id ,  count(DISTINCT product_id) FROM Order_items GROUP BY order_id", "source_tables": ["order_items"], "description": "This virtual table summarizes the total number of distinct products associated with each order from the 'Order_Items' table. The placeholder in the SELECT clause represents the order identifier, while the count function calculates the unique product count for each order.", "virtual_table": "SELECT order_id ,  count(DISTINCT product_id) FROM Order_items GROUP BY order_id"}
{"sample_id": "train.1607", "db_id": "customers_and_invoices", "question": "Show the order ids and the number of invoices for each order.", "rationale": ["The query identifies the relevant table, which is 'Invoices'.", "Select the 'order_id' to group the results by each order.", "Use the count function to calculate the total number of invoices for each order, grouping the results by 'order_id' to ensure each order's invoice count is displayed."], "gold_sql": "SELECT order_id ,  count(*) FROM Invoices GROUP BY order_id", "source_tables": ["invoices"], "description": "This virtual table summarizes the number of invoices associated with each order from the 'Invoices' table. The placeholder in the SELECT clause represents the unique identifier for each order, while the count function provides the total number of invoices for each order.", "virtual_table": "SELECT order_id ,  count(*) FROM Invoices GROUP BY order_id"}
{"sample_id": "train.1621", "db_id": "customers_and_invoices", "question": "Show all product names and the number of customers having an order on each product.", "rationale": ["The query identifies the relevant tables: 'Order_Items', 'Products', and 'Orders'.", "It selects the 'product_name' from the 'Products' table and counts the occurrences of each product ordered.", "The JOIN operation connects 'Order_Items' to 'Products' using 'product_id' to get product details, and to 'Orders' using 'order_id' to ensure the orders are valid.", "The GROUP BY clause is used to aggregate the results by 'product_name', providing a count of how many times each product has been ordered."], "gold_sql": "SELECT T2.product_name ,  count(*) FROM Order_items AS T1 JOIN Products AS T2 ON T1.product_id  =  T2.product_id JOIN Orders AS T3 ON T3.order_id  =  T1.order_id GROUP BY T2.product_name", "source_tables": ["orders", "products", "order_items"], "description": "The virtual table summarizes the count of each product ordered from the 'Products' table, along with the product name. It aggregates the data from the 'Order_Items' table, which links orders to products, and the 'Orders' table to ensure that only valid orders are considered. The result is grouped by product name to provide a total count for each product.", "virtual_table": "SELECT T2.product_name ,  count(*) FROM Order_items AS T1 JOIN Products AS T2 ON T1.product_id  =  T2.product_id JOIN Orders AS T3 ON T3.order_id  =  T1.order_id GROUP BY T2.product_name"}
{"sample_id": "train.1622", "db_id": "customers_and_invoices", "question": "What are teh names of the different products, as well as the number of customers who have ordered each product.", "rationale": ["The query identifies the relevant tables: 'Order_Items', 'Products', and 'Orders'.", "It selects the 'product_name' from the 'Products' table and counts the occurrences of each product ordered.", "The JOIN operation connects 'Order_Items' to 'Products' using 'product_id' and to 'Orders' using 'order_id'.", "The GROUP BY clause is used to aggregate the results by 'product_name', allowing for a count of each product ordered."], "gold_sql": "SELECT T2.product_name ,  count(*) FROM Order_items AS T1 JOIN Products AS T2 ON T1.product_id  =  T2.product_id JOIN Orders AS T3 ON T3.order_id  =  T1.order_id GROUP BY T2.product_name", "source_tables": ["orders", "products", "order_items"], "description": "The virtual table summarizes the count of each product ordered from the 'Products' table, along with the product name. It aggregates the data from the 'Order_Items' table, which links orders to products, and the 'Orders' table to ensure that only valid orders are considered. The result is grouped by product name to provide a total count for each product.", "virtual_table": "SELECT T2.product_name ,  count(*) FROM Order_items AS T1 JOIN Products AS T2 ON T1.product_id  =  T2.product_id JOIN Orders AS T3 ON T3.order_id  =  T1.order_id GROUP BY T2.product_name"}
{"sample_id": "train.1549", "db_id": "customers_and_invoices", "question": "How many customers have opened an account?", "rationale": ["The query is identifying the relevant table, which is 'Accounts'.", "The goal is to count the number of unique customers, hence the use of 'count(DISTINCT customer_id)'."], "gold_sql": "SELECT count(DISTINCT customer_id) FROM Accounts", "source_tables": ["accounts"], "description": "This virtual table provides the count of unique customers who have opened accounts in the 'Accounts' table. The placeholder in the SELECT clause represents the distinct customer identifiers.", "virtual_table": "SELECT count(DISTINCT customer_id) FROM Accounts"}
{"sample_id": "train.1580", "db_id": "customers_and_invoices", "question": "Count the number of financial transactions that correspond to each account id.", "rationale": ["The query identifies the relevant table, which is 'Financial_Transactions'.", "It selects the count of transactions and the associated account identifier.", "The count function is used to aggregate the number of transactions per account, which is indicated by the placeholder for account_id."], "gold_sql": "SELECT count(*) ,  account_id FROM Financial_transactions", "source_tables": ["financial_transactions"], "description": "This virtual table summarizes the total number of financial transactions associated with each account from the 'Financial_Transactions' table. The placeholder in the SELECT clause represents the account identifier for which the transaction count is being retrieved.", "virtual_table": "SELECT count(*) ,  account_id FROM Financial_transactions"}
{"sample_id": "train.727", "db_id": "customers_card_transactions", "question": "Show the customer ids and firstname without a credit card.", "rationale": ["The query is identifying the relevant table, which is 'Customers'.", "It selects the 'customer_id' and 'customer_first_name' from the 'Customers' table.", "The EXCEPT clause is used to exclude customers who have a card of a specific type.", "A JOIN is performed between 'Customers_cards' and 'Customers' to filter out those customers who have the specified card type using a placeholder for string values."], "gold_sql": "SELECT customer_id ,  customer_first_name FROM Customers EXCEPT SELECT T1.customer_id ,  T2.customer_first_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE card_type_code  =  'Credit'", "source_tables": ["customers", "customers_cards"], "description": "This virtual table identifies customers from the 'Customers' table who do not possess a specific type of card. The placeholder in the EXCEPT clause represents the card type code that is being filtered out.", "virtual_table": "SELECT customer_id ,  customer_first_name FROM Customers EXCEPT SELECT T1.customer_id ,  T2.customer_first_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE card_type_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.716", "db_id": "customers_card_transactions", "question": "What are the ids and full names of customers who hold two or more cards?", "rationale": ["The query identifies the relevant tables, which are 'Customers_cards' and 'Customers'.", "It selects the 'customer_id', 'customer_first_name', and 'customer_last_name' to display in the results.", "A JOIN operation is performed on 'customer_id' to link the two tables together.", "The results are grouped by 'customer_id' to aggregate the data for each customer.", "The HAVING clause is used to filter the results based on the count of cards associated with each customer, using a placeholder for the minimum count."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id HAVING count(*)  >=  2", "source_tables": ["customers", "customers_cards"], "description": "This virtual table provides a summary of customers who have multiple cards associated with them. It includes the customer ID along with their first and last names. The placeholder in the HAVING clause indicates the minimum number of cards a customer must have to be included in the results.", "virtual_table": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.682", "db_id": "customers_card_transactions", "question": "Give the full name and customer id of the customer with the fewest accounts.", "rationale": ["The query identifies the relevant tables, 'Accounts' and 'Customers', and establishes a join between them based on the 'customer_id'.", "It selects the 'customer_first_name' and 'customer_last_name' from the 'Customers' table and the 'customer_id' from the 'Accounts' table.", "The results are grouped by 'customer_id' to aggregate the data, and ordered by the count of accounts associated with each customer in ascending order.", "The LIMIT clause uses a placeholder to specify the maximum number of results to return."], "gold_sql": "SELECT T2.customer_first_name ,  T2.customer_last_name ,  T1.customer_id FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) ASC LIMIT 1", "source_tables": ["accounts", "customers"], "description": "This virtual table provides a list of customers along with their first and last names, linked to their respective accounts. The data is aggregated by customer ID, allowing for the identification of customers with the least number of associated accounts. The placeholder in the LIMIT clause represents the maximum number of results to return.", "virtual_table": "SELECT T2.customer_first_name ,  T2.customer_last_name ,  T1.customer_id FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.728", "db_id": "customers_card_transactions", "question": "What are the ids and first names of customers who do not hold a credit card?", "rationale": ["The query starts by selecting the customer_id and customer_first_name from the Customers table.", "It uses the EXCEPT clause to exclude customers who have a card of a specific type.", "The subquery joins the Customers_Cards table with the Customers table to find customers with the specified card type, using a placeholder for the card type code."], "gold_sql": "SELECT customer_id ,  customer_first_name FROM Customers EXCEPT SELECT T1.customer_id ,  T2.customer_first_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE card_type_code  =  'Credit'", "source_tables": ["customers", "customers_cards"], "description": "This virtual table identifies customers who do not possess a specific type of card. It retrieves the customer ID and first name from the 'Customers' table, excluding those who have a card of the specified type. The placeholder in the EXCEPT clause represents the card type code that is used to filter the results.", "virtual_table": "SELECT customer_id ,  customer_first_name FROM Customers EXCEPT SELECT T1.customer_id ,  T2.customer_first_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE card_type_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.694", "db_id": "customers_card_transactions", "question": "What are the ids, full names, and phones of each customer?", "rationale": ["The query identifies the relevant table, which is 'Customers'.", "Select the columns to display: 'customer_id', 'customer_first_name', 'customer_last_name', and 'customer_phone'.", "This selection provides a concise overview of customer identity and contact information."], "gold_sql": "SELECT customer_id ,  customer_first_name ,  customer_last_name ,  customer_phone FROM Customers", "source_tables": ["customers"], "description": "The virtual table provides a view of customer information from the 'Customers' table, including their unique identifier, first name, last name, and phone number. This allows for easy access to essential customer details without exposing other sensitive information.", "virtual_table": "SELECT customer_id ,  customer_first_name ,  customer_last_name ,  customer_phone FROM Customers"}
{"sample_id": "train.722", "db_id": "customers_card_transactions", "question": "Return the code of the card type that is most common.", "rationale": ["The query identifies the relevant table, which is 'Customers_Cards'.", "It selects the 'card_type_code' to display the different types of cards.", "The GROUP BY clause is used to aggregate the results by 'card_type_code'.", "The ORDER BY clause sorts the results based on the count of each card type in descending order.", "The LIMIT clause uses a placeholder to allow the user to specify how many of the most common card types they want to retrieve."], "gold_sql": "SELECT card_type_code FROM Customers_cards GROUP BY card_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers_cards"], "description": "This virtual table summarizes the different types of cards issued to customers, categorized by their card type code. The placeholder in the LIMIT clause allows the user to specify the maximum number of card types to retrieve, based on their popularity as indicated by the count of each type.", "virtual_table": "SELECT card_type_code FROM Customers_cards GROUP BY card_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.677", "db_id": "customers_card_transactions", "question": "Show all customer ids and the number of accounts for each customer.", "rationale": ["The query identifies the relevant table, which is 'Accounts'.", "Select the 'customer_id' to group the results by customer.", "Use the count function to calculate the total number of accounts for each customer, grouping the results by 'customer_id' to ensure each customer is represented once."], "gold_sql": "SELECT customer_id ,  count(*) FROM Accounts GROUP BY customer_id", "source_tables": ["accounts"], "description": "This virtual table summarizes the number of accounts associated with each customer from the 'Accounts' table. The placeholder in the SELECT clause represents the customer identifier, while the count function aggregates the total number of accounts for each customer.", "virtual_table": "SELECT customer_id ,  count(*) FROM Accounts GROUP BY customer_id"}
{"sample_id": "train.745", "db_id": "customers_card_transactions", "question": "Show the account id and the number of transactions for each account", "rationale": ["The query identifies the relevant table, which is 'Financial_Transactions'.", "Select the 'account_id' to display along with a count of transactions.", "Use the GROUP BY clause to aggregate the results based on 'account_id', allowing us to see the number of transactions per account."], "gold_sql": "SELECT account_id ,  count(*) FROM Financial_transactions GROUP BY account_id", "source_tables": ["financial_transactions"], "description": "This virtual table summarizes the number of financial transactions associated with each account from the 'Financial_Transactions' table. The placeholder in the SELECT clause represents the account identifier, while the count function aggregates the total number of transactions for each account.", "virtual_table": "SELECT account_id ,  count(*) FROM Financial_transactions GROUP BY account_id"}
{"sample_id": "train.707", "db_id": "customers_card_transactions", "question": "How many debit cards do we have?", "rationale": ["The query identifies the relevant table, which is 'Customers_Cards'.", "It selects a count of all records in the table to determine how many cards exist for a specific type.", "A condition is added to filter the results based on the 'card_type_code' column using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM Customers_cards WHERE card_type_code  =  'Debit'", "source_tables": ["customers_cards"], "description": "This virtual table provides a count of customer cards from the 'Customers_Cards' table filtered by a specific card type. The placeholder in the WHERE clause represents the card type code that the user wants to query.", "virtual_table": "SELECT count(*) FROM Customers_cards WHERE card_type_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.729", "db_id": "customers_card_transactions", "question": "Show all card type codes.", "rationale": ["The query is identifying the relevant table, which is 'Customers_Cards'.", "Select the distinct values of the 'card_type_code' column to ensure that only unique card types are retrieved."], "gold_sql": "SELECT DISTINCT card_type_code FROM Customers_Cards", "source_tables": ["customers_cards"], "description": "This virtual table provides a list of unique card type codes from the 'Customers_Cards' table. The placeholder in the SELECT statement allows for the retrieval of distinct card types associated with customer cards.", "virtual_table": "SELECT DISTINCT card_type_code FROM Customers_Cards"}
{"sample_id": "train.4740", "db_id": "department_store", "question": "What are the ids and names of department stores with both marketing and managing departments?", "rationale": ["The query identifies the relevant tables, which are 'departments' and 'department_stores'.", "It selects the columns 'dept_store_id' and 'store_name' from the 'department_stores' table.", "The JOIN operation connects 'departments' to 'department_stores' based on the 'dept_store_id'.", "The WHERE clause filters the results based on the 'department_name' for two different department names using placeholders.", "The INTERSECT operation is used to find department stores that are associated with both specified department names."], "gold_sql": "SELECT T2.dept_store_id ,  T2.store_name FROM departments AS T1 JOIN department_stores AS T2 ON T1.dept_store_id  =  T2.dept_store_id WHERE T1.department_name  =  'marketing' INTERSECT SELECT T2.dept_store_id ,  T2.store_name FROM departments AS T1 JOIN department_stores AS T2 ON T1.dept_store_id  =  T2.dept_store_id WHERE T1.department_name  =  'managing'", "source_tables": ["departments", "department_stores"], "description": "This virtual table provides a list of department store IDs and names from the 'Department_Stores' table that are associated with specific departments. The query uses an INTERSECT operation to find common department stores linked to two different department names, represented by placeholders in the WHERE clause.", "virtual_table": "SELECT T2.dept_store_id ,  T2.store_name FROM departments AS T1 JOIN department_stores AS T2 ON T1.dept_store_id  =  T2.dept_store_id WHERE T1.department_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.dept_store_id ,  T2.store_name FROM departments AS T1 JOIN department_stores AS T2 ON T1.dept_store_id  =  T2.dept_store_id WHERE T1.department_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4739", "db_id": "department_store", "question": "What is the id and name of the department store that has both marketing and managing department?", "rationale": ["The query identifies the relevant tables, which are 'departments' and 'department_stores'.", "It selects the columns 'dept_store_id' and 'store_name' from the 'department_stores' table.", "The JOIN operation connects 'departments' to 'department_stores' based on the 'dept_store_id'.", "The WHERE clause filters the results based on the specified 'department_name' using a placeholder for string values.", "The INTERSECT operation is used to find common results from two identical queries, ensuring that only department stores associated with the specified department name are returned."], "gold_sql": "SELECT T2.dept_store_id ,  T2.store_name FROM departments AS T1 JOIN department_stores AS T2 ON T1.dept_store_id  =  T2.dept_store_id WHERE T1.department_name  =  'marketing' INTERSECT SELECT T2.dept_store_id ,  T2.store_name FROM departments AS T1 JOIN department_stores AS T2 ON T1.dept_store_id  =  T2.dept_store_id WHERE T1.department_name  =  'managing'", "source_tables": ["departments", "department_stores"], "description": "This virtual table provides a list of department store IDs and names from the 'Department_Stores' table that are associated with a specific department name. The query uses an INTERSECT operation to find common department stores linked to two instances of the same department name, represented by placeholders for the department name.", "virtual_table": "SELECT T2.dept_store_id ,  T2.store_name FROM departments AS T1 JOIN department_stores AS T2 ON T1.dept_store_id  =  T2.dept_store_id WHERE T1.department_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.dept_store_id ,  T2.store_name FROM departments AS T1 JOIN department_stores AS T2 ON T1.dept_store_id  =  T2.dept_store_id WHERE T1.department_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4791", "db_id": "department_store", "question": "Find the id and name of customers whose address contains WY state and do not use credit card for payment.", "rationale": ["The query identifies the relevant table, which is 'Customers'.", "Select the columns to display, 'customer_id' and 'customer_name'.", "Add a condition to filter the 'customer_address' using a LIKE clause with a placeholder for string values.", "Add another condition to exclude certain payment methods using a NOT EQUAL clause with a placeholder for string values."], "gold_sql": "SELECT customer_id ,  customer_name FROM customers WHERE customer_address LIKE '%WY%' AND payment_method_code != 'Credit Card'", "source_tables": ["customers"], "description": "This virtual table provides a list of customer IDs and names from the 'Customers' table, filtered by a specific address pattern and excluding a certain payment method. The placeholders in the WHERE clause represent the address pattern and the payment method code that should not be included.", "virtual_table": "SELECT customer_id ,  customer_name FROM customers WHERE customer_address LIKE [PLACEHOLDER-TYPE:STRING] AND payment_method_code != [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4735", "db_id": "department_store", "question": "Find the name and address of the customers who have both New and Pending orders.", "rationale": ["The query identifies the relevant tables, which are 'Customers' and 'Customer_Orders'.", "It selects the columns to display, 'customer_name' and 'customer_address'.", "The JOIN operation links the 'Customers' table with the 'Customer_Orders' table based on the 'customer_id'.", "The WHERE clause filters the results based on the specified 'order_status_code' using placeholders for string values.", "The INTERSECT operation is used to find common results between two queries with the same structure, both filtering by order status code."], "gold_sql": "SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  'New' INTERSECT SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  'Pending'", "source_tables": ["customer_orders", "customers"], "description": "This virtual table provides the names and addresses of customers who have placed orders with a specific status. The query retrieves customer information from the 'Customers' table and filters the results based on the order status from the 'Customer_Orders' table. The placeholders in the WHERE clause represent the order status codes that can be specified by the user.", "virtual_table": "SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4756", "db_id": "department_store", "question": "Return the id of the staff whose Staff Department Assignment was earlier than that of any Clerical Staff.", "rationale": ["The query identifies the relevant table, which is 'Staff_Department_Assignments'.", "It selects the 'staff_id' column to display the IDs of staff members.", "A condition is added to filter the results based on the 'date_assigned_to' column, ensuring it is less than the maximum assignment date for a specified job title using a placeholder for string values."], "gold_sql": "SELECT staff_id FROM Staff_Department_Assignments WHERE date_assigned_to  <  (SELECT max(date_assigned_to) FROM Staff_Department_Assignments WHERE job_title_code  =  'Clerical Staff')", "source_tables": ["staff_department_assignments"], "description": "This virtual table provides a list of staff members' IDs from the 'Staff_Department_Assignments' table who were assigned to a department before the most recent assignment date for a specific job title. The placeholder in the WHERE clause represents the job title code being queried.", "virtual_table": "SELECT staff_id FROM Staff_Department_Assignments WHERE date_assigned_to  <  (SELECT max(date_assigned_to) FROM Staff_Department_Assignments WHERE job_title_code  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.4754", "db_id": "department_store", "question": "What are the distinct ids of customers who made an order after any order that was Cancelled?", "rationale": ["The query identifies the relevant table, which is 'Customer_Orders'.", "It selects distinct customer IDs to ensure each customer is listed only once.", "A condition is added to filter orders based on the order date, specifically those placed after the earliest date of orders with a specified status code, using a placeholder for the status code."], "gold_sql": "SELECT DISTINCT customer_id FROM Customer_Orders WHERE order_date  >  (SELECT min(order_date) FROM Customer_Orders WHERE order_status_code  =  'Cancelled')", "source_tables": ["customer_orders"], "description": "This virtual table provides a list of unique customer identifiers from the 'Customer_Orders' table for orders placed after a specific date. The placeholder in the subquery represents the order status code used to filter the orders.", "virtual_table": "SELECT DISTINCT customer_id FROM Customer_Orders WHERE order_date  >  (SELECT min(order_date) FROM Customer_Orders WHERE order_status_code  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.4717", "db_id": "department_store", "question": "What are the staff ids and genders of all staffs whose job title is Department Manager?", "rationale": ["The query identifies the relevant tables, which are 'Staff' and 'Staff_Department_Assignments'.", "It selects the columns to display, 'staff_id' and 'staff_gender'.", "A JOIN operation is performed to link the 'Staff' table with the 'Staff_Department_Assignments' table based on the 'staff_id'.", "A condition is added to filter the results based on the 'job_title_code' using a placeholder for string values."], "gold_sql": "SELECT T1.staff_id ,  T1.staff_gender FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.job_title_code  =  'Department Manager'", "source_tables": ["staff_department_assignments", "staff"], "description": "This virtual table provides information about staff members and their gender from the 'Staff' table who are assigned to a specific job title. The placeholder in the WHERE clause represents the job title code that is used to filter the results.", "virtual_table": "SELECT T1.staff_id ,  T1.staff_gender FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.job_title_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4759", "db_id": "department_store", "question": "Return the name and gender of the staff who was assigned in 2016.", "rationale": ["The query identifies the relevant tables, which are 'Staff' and 'Staff_Department_Assignments'.", "Select the columns to display, 'staff_name' and 'staff_gender'.", "Join the 'Staff' table with 'Staff_Department_Assignments' on the 'staff_id' to link staff members with their department assignments.", "Add a condition to filter the assignments based on the 'date_assigned_from' column using a placeholder for string values."], "gold_sql": "SELECT T1.staff_name ,  T1.staff_gender FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.date_assigned_from LIKE '2016%'", "source_tables": ["staff_department_assignments", "staff"], "description": "This virtual table provides the names and genders of staff members from the 'Staff' table who have been assigned to a department during a specific date range. The placeholder in the WHERE clause represents the start date of the staff assignment.", "virtual_table": "SELECT T1.staff_name ,  T1.staff_gender FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.date_assigned_from LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4730", "db_id": "department_store", "question": "Return the name and job title of the staff with the latest date assigned.", "rationale": ["The query identifies the relevant tables, which are 'Staff' and 'Staff_Department_Assignments'.", "It selects the 'staff_name' from the 'Staff' table and 'job_title_code' from the 'Staff_Department_Assignments' table.", "A JOIN operation is performed on the 'staff_id' to combine data from both tables.", "The results are ordered by 'date_assigned_to' in descending order to show the most recent assignments first.", "A LIMIT clause is added with a placeholder for numeric values to restrict the number of results returned."], "gold_sql": "SELECT T1.staff_name ,  T2.job_title_code FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY T2.date_assigned_to DESC LIMIT 1", "source_tables": ["staff_department_assignments", "staff"], "description": "This virtual table provides a list of staff members along with their job titles from the 'Staff' and 'Staff_Department_Assignments' tables. The results are ordered by the end date of their assignments, and a placeholder is included to limit the number of results returned.", "virtual_table": "SELECT T1.staff_name ,  T2.job_title_code FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY T2.date_assigned_to DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4794", "db_id": "department_store", "question": "What is the average price of clothes?", "rationale": ["The query identifies the relevant table, which is 'Products'.", "It calculates the average of the 'product_price' column.", "A condition is added to filter the results based on the 'product_type_code' using a placeholder for string values."], "gold_sql": "SELECT avg(product_price) FROM products WHERE product_type_code  =  'Clothes'", "source_tables": ["products"], "description": "This virtual table provides the average price of products from the 'Products' table filtered by a specific product type. The placeholder in the WHERE clause represents the product type code that the user can specify.", "virtual_table": "SELECT avg(product_price) FROM products WHERE product_type_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4709", "db_id": "department_store", "question": "What are the ids of the top three products that were purchased in the largest amount?", "rationale": ["The query identifies the relevant table, which is 'Product_Suppliers'.", "Select the column to display, 'product_id'.", "Order the results by 'total_amount_purchased' in descending order to get the most purchased products first.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT product_id FROM product_suppliers ORDER BY total_amount_purchased DESC LIMIT 3", "source_tables": ["product_suppliers"], "description": "The virtual table provides a list of product identifiers from the 'Product_Suppliers' table, ordered by the total amount purchased in descending order. The placeholder in the LIMIT clause allows the user to specify the number of top products to retrieve based on their purchase quantity.", "virtual_table": "SELECT product_id FROM product_suppliers ORDER BY total_amount_purchased DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4729", "db_id": "department_store", "question": "What is the name and job title of the staff who was assigned the latest?", "rationale": ["The query identifies the relevant tables, which are 'Staff' and 'Staff_Department_Assignments'.", "It selects the 'staff_name' from the 'Staff' table and 'job_title_code' from the 'Staff_Department_Assignments' table.", "A JOIN operation is performed on the 'staff_id' to combine data from both tables.", "The results are ordered by 'date_assigned_to' in descending order to show the most recent assignments first.", "A LIMIT clause is included with a placeholder to restrict the number of results returned."], "gold_sql": "SELECT T1.staff_name ,  T2.job_title_code FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY T2.date_assigned_to DESC LIMIT 1", "source_tables": ["staff_department_assignments", "staff"], "description": "This virtual table provides a list of staff members along with their job titles from the 'Staff' and 'Staff_Department_Assignments' tables. The results are ordered by the end date of their assignments, and a placeholder is included to limit the number of results returned.", "virtual_table": "SELECT T1.staff_name ,  T2.job_title_code FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY T2.date_assigned_to DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4521", "db_id": "document_management", "question": "List all the username and passwords of users with the most popular role.", "rationale": ["The query identifies the relevant table, which is 'Users'.", "Select the columns to display, 'user_name' and 'password'.", "Group the results by 'role_code' to aggregate users based on their roles.", "Order the results by the count of users in each role in descending order to prioritize the most common roles.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT user_name ,  password FROM users GROUP BY role_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["users"], "description": "This virtual table provides a list of user names and their corresponding passwords from the 'Users' table, grouped by their role codes. The placeholder in the LIMIT clause indicates the maximum number of user records to retrieve, allowing for flexibility in the number of results returned.", "virtual_table": "SELECT user_name ,  password FROM users GROUP BY role_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4522", "db_id": "document_management", "question": "What are the usernames and passwords of users that have the most common role?", "rationale": ["The query identifies the relevant table, which is 'Users'.", "Select the columns to display, 'user_name' and 'password'.", "Group the results by 'role_code' to aggregate users based on their roles.", "Order the results by the count of users in each role in descending order to prioritize the most common roles.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT user_name ,  password FROM users GROUP BY role_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["users"], "description": "This virtual table provides a list of user names and their corresponding passwords from the 'Users' table, grouped by their role codes. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return, based on the count of users in each role.", "virtual_table": "SELECT user_name ,  password FROM users GROUP BY role_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4535", "db_id": "document_management", "question": "Find the average access count of documents with the least popular structure.", "rationale": ["The query identifies the relevant table, which is 'Documents'.", "It calculates the average of the 'access_count' column to determine how often documents are accessed.", "The results are grouped by 'document_structure_code' to categorize the average access counts according to different document structures.", "The ORDER BY clause sorts the results in ascending order based on the count of documents in each group.", "The LIMIT clause uses a placeholder to allow the user to specify how many results they want to retrieve."], "gold_sql": "SELECT avg(access_count) FROM documents GROUP BY document_structure_code ORDER BY count(*) ASC LIMIT 1", "source_tables": ["documents"], "description": "This virtual table provides the average access count of documents grouped by their document structure code. The placeholder in the LIMIT clause allows the user to specify the maximum number of results to return, enabling them to control the output size based on their needs.", "virtual_table": "SELECT avg(access_count) FROM documents GROUP BY document_structure_code ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4509", "db_id": "document_management", "question": "What is the structure of the document with the least number of accesses?", "rationale": ["The query identifies the relevant tables, which are 'Documents' and 'Document_Structures'.", "It selects the 'document_structure_description' from the 'Document_Structures' table.", "A JOIN operation is performed on the 'document_structure_code' to link documents with their respective structures.", "The results are grouped by 'document_structure_code' to aggregate the data.", "The results are ordered by the count of documents associated with each structure in descending order.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT t2.document_structure_description FROM documents AS t1 JOIN document_structures AS t2 ON t1.document_structure_code  =  t2.document_structure_code GROUP BY t1.document_structure_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["document_structures", "documents"], "description": "This virtual table provides a summary of document structures associated with documents in the 'Documents' table. It retrieves the descriptions of document structures by joining the 'Documents' table with the 'Document_Structures' table based on the document structure code. The results are grouped by document structure code and ordered by the count of documents associated with each structure, allowing users to see the most frequently used document structures, limited to a specified number of results.", "virtual_table": "SELECT t2.document_structure_description FROM documents AS t1 JOIN document_structures AS t2 ON t1.document_structure_code  =  t2.document_structure_code GROUP BY t1.document_structure_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4531", "db_id": "document_management", "question": "How many users are logged in?", "rationale": ["The query is identifying the relevant table, which is 'Users'.", "The count function is used to determine the number of users that match the specified condition.", "Add a condition to filter the 'user_login' column for the specified login using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM users WHERE user_login  =  1", "source_tables": ["users"], "description": "This virtual table provides the count of users from the 'Users' table based on a specific login username. The placeholder in the WHERE clause represents the user's login name.", "virtual_table": "SELECT count(*) FROM users WHERE user_login  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4526", "db_id": "document_management", "question": "What are the names of documents that do not have any images?", "rationale": ["The query identifies the relevant table, which is 'Documents'.", "It selects the 'document_name' column to display the names of the documents.", "The EXCEPT clause is used to filter out document names that have associated images by joining the 'Documents' table with 'Document_Sections' and 'Document_Sections_Images' tables based on their respective keys."], "gold_sql": "SELECT document_name FROM documents EXCEPT SELECT t1.document_name FROM documents AS t1 JOIN document_sections AS t2 ON t1.document_code  =  t2.document_code JOIN document_sections_images AS t3 ON t2.section_id  =  t3.section_id", "source_tables": ["document_sections", "document_sections_images", "documents"], "description": "This virtual table lists the names of documents from the 'Documents' table that do not have any associated images in their sections. The query uses an EXCEPT clause to exclude document names that are linked to images through the 'Document_Sections' and 'Document_Sections_Images' tables.", "virtual_table": "SELECT document_name FROM documents EXCEPT SELECT t1.document_name FROM documents AS t1 JOIN document_sections AS t2 ON t1.document_code  =  t2.document_code JOIN document_sections_images AS t3 ON t2.section_id  =  t3.section_id"}
{"sample_id": "dev.936", "db_id": "dog_kennels", "question": "Which owner has paid for the most treatments on his or her dogs? List the owner id and last name.", "rationale": ["The query identifies the relevant tables: 'Owners', 'Dogs', and 'Treatments'.", "It selects the 'owner_id' and 'last_name' from the 'Owners' table.", "The JOIN operations link the 'Dogs' table to the 'Owners' table using 'owner_id', and the 'Treatments' table to the 'Dogs' table using 'dog_id'.", "The GROUP BY clause groups the results by 'owner_id' to count the number of treatments per owner.", "The ORDER BY clause sorts the results by the count of treatments in descending order.", "The LIMIT clause uses a placeholder to allow the user to specify how many results to return."], "gold_sql": "SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["owners", "dogs", "treatments"], "description": "This virtual table provides a list of owners along with their last names who have had dogs treated, sorted by the number of treatments in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of owners to retrieve.", "virtual_table": "SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.944", "db_id": "dog_kennels", "question": "What are the first name and last name of the professionals who have done treatment with cost below average?", "rationale": ["The query identifies the relevant tables, 'Professionals' and 'Treatments'.", "It selects distinct first and last names from the 'Professionals' table.", "A join is performed with the 'Treatments' table to link professionals to the treatments they administered.", "A subquery calculates the average treatment cost from the 'Treatments' table.", "The main query filters professionals based on whether the cost of treatment is less than the average cost using a placeholder for numeric values."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T1.last_name FROM Professionals AS T1 JOIN Treatments AS T2 WHERE cost_of_treatment  <  ( SELECT avg(cost_of_treatment) FROM Treatments )", "source_tables": ["professionals", "treatments"], "description": "This virtual table provides a list of unique first and last names of professionals who have administered treatments that cost less than the average treatment cost. The placeholders in the query allow for dynamic filtering based on treatment costs.", "virtual_table": "SELECT DISTINCT T1.first_name ,  T1.last_name FROM Professionals AS T1 JOIN Treatments AS T2 WHERE cost_of_treatment  <  ( SELECT avg(cost_of_treatment) FROM Treatments )"}
{"sample_id": "dev.945", "db_id": "dog_kennels", "question": "Which professionals have operated a treatment that costs less than the average? Give me theor first names and last names.", "rationale": ["The query identifies the relevant tables, 'Professionals' and 'Treatments'.", "It selects distinct first and last names from the 'Professionals' table.", "A join is performed between 'Professionals' and 'Treatments' to link professionals with the treatments they administered.", "A condition is added to filter treatments where the cost is less than the average cost of treatments, using a subquery to calculate the average."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T1.last_name FROM Professionals AS T1 JOIN Treatments AS T2 WHERE cost_of_treatment  <  ( SELECT avg(cost_of_treatment) FROM Treatments )", "source_tables": ["professionals", "treatments"], "description": "This virtual table provides a list of unique first and last names of professionals who have administered treatments that cost less than the average treatment cost. The placeholders in the query allow for dynamic filtering based on treatment costs.", "virtual_table": "SELECT DISTINCT T1.first_name ,  T1.last_name FROM Professionals AS T1 JOIN Treatments AS T2 WHERE cost_of_treatment  <  ( SELECT avg(cost_of_treatment) FROM Treatments )"}
{"sample_id": "dev.925", "db_id": "dog_kennels", "question": "What are the names of the dogs for which the owner has not spend more than 1000 for treatment ?", "rationale": ["The query identifies the relevant table, which is 'Dogs'.", "It selects the 'name' column to display the names of the dogs.", "The subquery filters out dogs that have received treatments by summing the 'cost_of_treatment' from the 'Treatments' table, grouping by 'dog_id'.", "A condition is added to exclude dogs whose total treatment cost exceeds a specified amount using a placeholder for numeric values."], "gold_sql": "select name from dogs where dog_id not in ( select dog_id from treatments group by dog_id having sum(cost_of_treatment)  >  1000 )", "source_tables": ["dogs", "treatments"], "description": "This virtual table lists the names of dogs from the 'Dogs' table that have not received treatments exceeding a specified total cost. The placeholder in the HAVING clause represents the maximum allowable total treatment cost for filtering the dogs.", "virtual_table": "select name from dogs where dog_id not in ( select dog_id from treatments group by dog_id having sum(cost_of_treatment)  >  [PLACEHOLDER-TYPE:NUMBER] )"}
{"sample_id": "dev.951", "db_id": "dog_kennels", "question": "What are each owner's first name, last name, and the size of their dog?", "rationale": ["The query identifies the relevant tables, which are 'Owners' and 'Dogs'.", "It selects the columns to display: 'first_name' and 'last_name' from the 'Owners' table (aliased as T1) and 'size_code' from the 'Dogs' table (aliased as T2).", "A JOIN operation is used to link the two tables on the 'owner_id' column, ensuring that the data retrieved corresponds to the correct owner and their dog."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id", "source_tables": ["owners", "dogs"], "description": "This virtual table provides the first and last names of dog owners along with the size code of their dogs. The join operation links the 'Owners' table with the 'Dogs' table based on the owner ID, allowing for the retrieval of relevant owner information alongside the corresponding size category of each dog.", "virtual_table": "SELECT T1.first_name ,  T1.last_name ,  T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id"}
{"sample_id": "dev.961", "db_id": "dog_kennels", "question": "Who owns the youngest dog? Give me his or her last name.", "rationale": ["The query identifies the relevant tables, which are 'Owners' and 'Dogs'.", "It selects the 'last_name' column from the 'Owners' table.", "A JOIN operation is performed to link the 'Owners' table with the 'Dogs' table based on the 'owner_id'.", "A subquery is used to find the maximum age of dogs in the 'Dogs' table, which serves as a condition in the WHERE clause to filter for the oldest dog."], "gold_sql": "SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )", "source_tables": ["owners", "dogs"], "description": "This virtual table provides the last names of dog owners who own the oldest dog in the database. The query joins the 'Owners' table with the 'Dogs' table to find the owner associated with the dog that has the maximum age. The placeholder in the WHERE clause is used to filter the dogs based on their age.", "virtual_table": "SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )"}
{"sample_id": "dev.920", "db_id": "dog_kennels", "question": "What is the average age of the dogs who have gone through any treatments?", "rationale": ["The query identifies the relevant table, which is 'Dogs'.", "It calculates the average age of dogs using the AVG function on the 'age' column.", "The subquery filters the 'dog_id' to include only those dogs that have treatment records from the 'Treatments' table."], "gold_sql": "SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )", "source_tables": ["dogs", "treatments"], "description": "This virtual table provides the average age of dogs that have received treatments. The placeholder in the WHERE clause indicates that only the dogs with treatment records are considered for the average calculation.", "virtual_table": "SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )"}
{"sample_id": "dev.996", "db_id": "dog_kennels", "question": "What are all the possible breed type and size type combinations?", "rationale": ["The query is identifying the relevant table, which is 'Dogs'.", "Select the distinct columns to display, 'breed_code' and 'size_code'.", "Using DISTINCT ensures that only unique combinations of breed and size codes are returned."], "gold_sql": "SELECT DISTINCT breed_code ,  size_code FROM dogs", "source_tables": ["dogs"], "description": "This virtual table provides a unique list of breed codes and size codes associated with dogs from the 'Dogs' table. The placeholders represent the breed and size categories of the dogs.", "virtual_table": "SELECT DISTINCT breed_code ,  size_code FROM dogs"}
{"sample_id": "dev.998", "db_id": "dog_kennels", "question": "List the first name of all the professionals along with the description of the treatment they have done.", "rationale": ["The query identifies the relevant tables: 'professionals', 'Treatments', and 'Treatment_Types'.", "It selects distinct first names from the 'professionals' table and the treatment type descriptions from the 'Treatment_Types' table.", "The JOIN operations link the 'professionals' table to the 'Treatments' table using the professional_id, and then link the 'Treatments' table to the 'Treatment_Types' table using the treatment_type_code."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code", "source_tables": ["professionals", "treatments", "treatment_types"], "description": "This virtual table provides a list of unique first names of professionals along with the descriptions of the treatment types they have administered. The placeholders in the query allow for filtering or further specification of the professionals or treatment types if needed.", "virtual_table": "SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code"}
{"sample_id": "train.5729", "db_id": "dorm_1", "question": "What is the average age and how many male students are there in each city?", "rationale": ["The query identifies the relevant table, which is 'Student'.", "It selects the count of students and the average age, along with the city code.", "A condition is added to filter the results based on the 'Sex' column using a placeholder for string values.", "The results are grouped by 'city_code' to provide a summary for each city."], "gold_sql": "SELECT count(*) ,  avg(age) ,  city_code FROM student WHERE sex  =  'M' GROUP BY city_code", "source_tables": ["student"], "description": "This virtual table summarizes the number of students and their average age, grouped by the city code, for a specific gender. The placeholder in the WHERE clause represents the gender of the students being queried.", "virtual_table": "SELECT count(*) ,  avg(age) ,  city_code FROM student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] GROUP BY city_code"}
{"sample_id": "train.5739", "db_id": "dorm_1", "question": "For each dorm, how many amenities does it have?", "rationale": ["The query identifies the relevant tables, 'dorm' and 'has_amenity'.", "It selects the count of amenities and the dormitory ID from the 'dorm' table.", "A join is performed between 'dorm' and 'has_amenity' on the dormitory ID to link dormitories with their amenities.", "A condition is added to filter dormitories based on their student capacity using a placeholder for numeric values.", "The results are grouped by the dormitory ID to provide a count of amenities for each dormitory."], "gold_sql": "SELECT count(*) ,  T1.dormid FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid WHERE T1.student_capacity  >  100 GROUP BY T1.dormid", "source_tables": ["has_amenity", "dorm"], "description": "The virtual table summarizes the count of amenities available in dormitories that can accommodate more students than a specified number. The placeholders in the query allow users to specify the minimum student capacity they are interested in.", "virtual_table": "SELECT count(*) ,  T1.dormid FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid WHERE T1.student_capacity  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.dormid"}
{"sample_id": "train.5699", "db_id": "dorm_1", "question": "What are the names and types of the dorms that have a capacity greater than 300 or less than 100?", "rationale": ["The query identifies the relevant table, which is 'Dorm'.", "Select the columns to display, 'dorm_name' and 'gender'.", "Add a condition to filter the 'student_capacity' column for dormitories that have a capacity greater than or less than specified values using placeholders for numeric values."], "gold_sql": "SELECT dorm_name ,  gender FROM dorm WHERE student_capacity  >  300 OR student_capacity  <  100", "source_tables": ["dorm"], "description": "This virtual table provides information about dormitories, specifically their names and gender designations, from the 'Dorm' table. The placeholders in the WHERE clause represent the minimum and maximum student capacities to filter the dormitories accordingly.", "virtual_table": "SELECT dorm_name ,  gender FROM dorm WHERE student_capacity  >  [PLACEHOLDER-TYPE:NUMBER] OR student_capacity  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5706", "db_id": "dorm_1", "question": "Find the last name of students who is either female (sex is F) and living in the city of code BAL or male (sex is M) and in age of below 20.", "rationale": ["The query identifies the relevant table, which is 'Student'.", "It selects the 'LName' column to display the last names of students.", "The first part of the query filters students based on their gender and city code using placeholders for string values.", "The second part of the query uses a UNION to combine results from the same table, filtering students by gender and age, with a placeholder for the age value."], "gold_sql": "SELECT lname FROM student WHERE sex  =  'F' AND city_code  =  'BAL' UNION SELECT lname FROM student WHERE sex  =  'M' AND age  <  20", "source_tables": ["student"], "description": "This virtual table provides the last names of students from the 'Student' table who meet specific criteria based on gender and city of residence. It also includes students of the same gender who are younger than a specified age. The placeholders in the WHERE clauses represent the gender, city code, and age values.", "virtual_table": "SELECT lname FROM student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND city_code  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT lname FROM student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND age  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5755", "db_id": "dorm_1", "question": "What is the most common amenity in the dorms?", "rationale": ["The query identifies the relevant tables, 'dorm_amenity' and 'has_amenity', to retrieve the amenity names.", "It uses a JOIN operation to connect the two tables based on the amenity identifier.", "The GROUP BY clause is used to aggregate the results by amenity identifier, allowing for counting occurrences.", "The ORDER BY clause sorts the results by the count of occurrences in descending order, ensuring the most common amenities are listed first.", "The LIMIT clause includes a placeholder for the user to specify how many amenities they want to retrieve."], "gold_sql": "SELECT T1.amenity_name FROM dorm_amenity AS T1 JOIN has_amenity AS T2 ON T1.amenid  =  T2.amenid GROUP BY T2.amenid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["has_amenity", "dorm_amenity"], "description": "This virtual table provides a list of amenities available in dormitories, aggregated by their frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of amenities to retrieve, sorted by the most common amenities first.", "virtual_table": "SELECT T1.amenity_name FROM dorm_amenity AS T1 JOIN has_amenity AS T2 ON T1.amenid  =  T2.amenid GROUP BY T2.amenid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5757", "db_id": "dorm_1", "question": "What are the first names of all students who live in the dorm with the most amenities?", "rationale": ["The query identifies the relevant tables, which are 'Student', 'Lives_in', 'Dorm', 'Has_amenity', and 'Dorm_amenity'.", "It selects the 'fname' column from the 'Student' table.", "The query joins 'Student' with 'Lives_in' to link students to their respective dormitories.", "A subquery is used to find dormitories with the highest number of amenities by joining 'Dorm', 'Has_amenity', and 'Dorm_amenity'.", "The subquery groups the results by dormitory ID and orders them by the count of amenities in descending order, limiting the results based on a placeholder for the number of dormitories."], "gold_sql": "SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["has_amenity", "lives_in", "student", "dorm_amenity", "dorm"], "description": "This virtual table provides the first names of students who reside in dormitories that have the most amenities. The query joins the 'Student' table with the 'Lives_in' table to find students' dormitory assignments, and it filters the dormitories based on the count of amenities they offer, using a placeholder for the limit on the number of dormitories to consider.", "virtual_table": "SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.5669", "db_id": "dorm_1", "question": "What are the names of the all-female dorms?", "rationale": ["The query is identifying the relevant table, which is 'Dorm'.", "Select the column to display, 'dorm_name'.", "Add a condition to filter the 'gender' column for the specified gender using a placeholder for string values."], "gold_sql": "SELECT dorm_name FROM dorm WHERE gender  =  'F'", "source_tables": ["dorm"], "description": "This virtual table provides the names of dormitories from the 'Dorm' table that are designated for a specific gender. The placeholder in the WHERE clause represents the gender designation for the dormitory.", "virtual_table": "SELECT dorm_name FROM dorm WHERE gender  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5688", "db_id": "dorm_1", "question": "Find the average and total capacity of dorms for the students with gender X.", "rationale": ["The query identifies the relevant table, which is 'Dorm'.", "It selects the average and sum of the 'student_capacity' column to provide insights into dormitory capacity.", "A condition is added to filter the results based on the 'gender' column using a placeholder for string values."], "gold_sql": "SELECT avg(student_capacity) ,  sum(student_capacity) FROM dorm WHERE gender  =  'X'", "source_tables": ["dorm"], "description": "The virtual table provides the average and total student capacity of dormitories filtered by gender designation. The placeholder in the WHERE clause represents the gender of the dormitory.", "virtual_table": "SELECT avg(student_capacity) ,  sum(student_capacity) FROM dorm WHERE gender  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6677", "db_id": "driving_school", "question": "How many lessons did the customer Ryan Goodwin complete?", "rationale": ["The query identifies the relevant tables, 'Lessons' and 'Customers', to gather the necessary data.", "It uses a JOIN operation to link the 'Lessons' table with the 'Customers' table based on the customer ID.", "The SELECT statement counts the total number of lessons that match the specified criteria.", "The WHERE clause filters the results based on the customer's first name, last name, and the lesson status code, using placeholders for these values."], "gold_sql": "SELECT count(*) FROM Lessons AS T1 JOIN Customers AS T2 ON T1.customer_id  = T2.customer_id WHERE T2.first_name = 'Rylan' AND T2.last_name = 'Goodwin' AND T1.lesson_status_code = 'Completed';", "source_tables": ["lessons", "customers"], "description": "This virtual table provides a count of lessons attended by a specific customer, identified by their first and last names, along with the status of those lessons. The placeholders in the WHERE clause represent the customer's first name, last name, and the lesson status code.", "virtual_table": "SELECT count(*) FROM Lessons AS T1 JOIN Customers AS T2 ON T1.customer_id  = T2.customer_id WHERE T2.first_name = [PLACEHOLDER-TYPE:STRING] AND T2.last_name = [PLACEHOLDER-TYPE:STRING] AND T1.lesson_status_code = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.6654", "db_id": "driving_school", "question": "Which city lives most of staffs? List the city name and number of staffs.", "rationale": ["The query identifies the relevant tables, which are 'Addresses' and 'Staff'.", "It selects the 'city' column from the 'Addresses' table and counts the number of staff members associated with each city.", "A JOIN operation is performed on the 'staff_address_id' to link staff members to their addresses.", "The results are grouped by 'city' to aggregate the count of staff members per city.", "The results are ordered by the count of staff members in descending order to show the cities with the most staff first.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.city ,  count(*) FROM Addresses AS T1 JOIN Staff AS T2 ON T1.address_id = T2.staff_address_id GROUP BY T1.city ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["addresses", "staff"], "description": "This virtual table summarizes the number of staff members located in each city by joining the 'Addresses' and 'Staff' tables. The placeholder in the LIMIT clause allows the user to specify the maximum number of cities to return, sorted by the number of staff members in descending order.", "virtual_table": "SELECT T1.city ,  count(*) FROM Addresses AS T1 JOIN Staff AS T2 ON T1.address_id = T2.staff_address_id GROUP BY T1.city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.6689", "db_id": "driving_school", "question": "What is the city with the most customers?", "rationale": ["The query identifies the relevant tables, 'Customers' and 'Addresses', and establishes a join between them based on the customer address ID.", "It selects the 'city' column from the 'Addresses' table.", "The results are grouped by city to aggregate customer counts.", "The results are ordered in descending order based on the count of customers in each city.", "A limit is applied to restrict the number of cities returned, using a placeholder for numeric values."], "gold_sql": "SELECT T2.city FROM Customers AS T1 JOIN Addresses AS T2 ON T1.customer_address_id = T2.address_id GROUP BY T2.city ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["addresses", "customers"], "description": "The virtual table provides a list of cities where customers are located, derived from the 'Customers' and 'Addresses' tables. It groups the results by city and orders them by the number of customers in each city, limiting the output to a specified number of top cities.", "virtual_table": "SELECT T2.city FROM Customers AS T1 JOIN Addresses AS T2 ON T1.customer_address_id = T2.address_id GROUP BY T2.city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.6627", "db_id": "driving_school", "question": "What are the details of the car with id 1?", "rationale": ["The query is identifying the relevant table, which is 'Vehicles'.", "Select the column to display, 'vehicle_details'.", "Add a condition to filter the 'vehicle_id' column for the specified vehicle using a placeholder for numeric values."], "gold_sql": "SELECT vehicle_details FROM Vehicles WHERE vehicle_id = 1;", "source_tables": ["vehicles"], "description": "This virtual table provides detailed information about vehicles from the 'Vehicles' table based on a specific vehicle identifier. The placeholder in the WHERE clause represents the unique identifier for the vehicle.", "virtual_table": "SELECT vehicle_details FROM Vehicles WHERE vehicle_id = [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.6699", "db_id": "driving_school", "question": "How many lessons have been cancelled?", "rationale": ["The query identifies the relevant table, which is 'Lessons'.", "It selects a count of all records in the table.", "A condition is added to filter the results based on the 'lesson_status_code' using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM Lessons WHERE lesson_status_code = 'Cancelled';", "source_tables": ["lessons"], "description": "This virtual table provides a count of lessons from the 'Lessons' table that have a specific status. The placeholder in the WHERE clause represents the lesson status code being queried.", "virtual_table": "SELECT count(*) FROM Lessons WHERE lesson_status_code = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.6651", "db_id": "driving_school", "question": "How many employees live in Georgia?", "rationale": ["The query identifies the relevant table, which is 'Addresses'.", "It selects a count of all entries in the table to determine how many addresses exist in the specified location.", "A condition is added to filter the results based on the 'state_province_county' column using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM Addresses WHERE state_province_county = 'Georgia';", "source_tables": ["addresses"], "description": "This virtual table provides a count of addresses from the 'Addresses' table that are located in a specific state, province, or county. The placeholder in the WHERE clause represents the name of the state, province, or county being queried.", "virtual_table": "SELECT count(*) FROM Addresses WHERE state_province_county = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.6698", "db_id": "driving_school", "question": "How many lessons were in cancelled state?", "rationale": ["The query identifies the relevant table, which is 'Lessons'.", "It selects a count of all records in the table.", "A condition is added to filter the results based on the 'lesson_status_code' using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM Lessons WHERE lesson_status_code = 'Cancelled';", "source_tables": ["lessons"], "description": "This virtual table provides a count of lessons from the 'Lessons' table that have a specific status. The placeholder in the WHERE clause represents the lesson status code being queried.", "virtual_table": "SELECT count(*) FROM Lessons WHERE lesson_status_code = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.6324", "db_id": "e_government", "question": "Find the last name of the first ever contact person of the organization with the highest UK Vat number.", "rationale": ["The query identifies the relevant tables: 'organizations', 'organization_contact_individuals', and 'individuals'.", "It selects the 'individual_last_name' from the 'individuals' table.", "The query joins the 'organizations' table with 'organization_contact_individuals' on 'organization_id' and then joins with 'individuals' on 'individual_id'.", "A subquery is used to find the maximum VAT number from the 'organizations' table to filter the results.", "The results are ordered by 'date_contact_to' in ascending order and limited by a placeholder for numeric values."], "gold_sql": "SELECT t3.individual_last_name FROM organizations AS t1 JOIN organization_contact_individuals AS t2 ON t1.organization_id  =  t2.organization_id JOIN individuals AS t3 ON t2.individual_id  =  t3.individual_id WHERE t1.uk_vat_number  =  (SELECT max(uk_vat_number) FROM organizations) ORDER BY t2.date_contact_to ASC LIMIT 1", "source_tables": ["organizations", "organization_contact_individuals", "individuals"], "description": "This virtual table provides the last names of individuals who have contacted organizations, specifically focusing on the organization with the highest VAT registration number. The results are ordered by the end date of the contact period, and a placeholder is included to limit the number of results returned.", "virtual_table": "SELECT t3.individual_last_name FROM organizations AS t1 JOIN organization_contact_individuals AS t2 ON t1.organization_id  =  t2.organization_id JOIN individuals AS t3 ON t2.individual_id  =  t3.individual_id WHERE t1.uk_vat_number  =  (SELECT max(uk_vat_number) FROM organizations) ORDER BY t2.date_contact_to ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6331", "db_id": "e_government", "question": "What are the names of all cities and states?", "rationale": ["The query identifies the relevant table, which is 'Addresses'.", "It selects the 'town_city' column to retrieve the names of towns or cities.", "It also selects the 'state_province_county' column to retrieve the names of states, provinces, or counties.", "The UNION operator is used to combine the results of the two SELECT statements into a single result set, ensuring that duplicate entries are removed."], "gold_sql": "SELECT town_city FROM addresses UNION SELECT state_province_county FROM addresses", "source_tables": ["addresses"], "description": "The virtual table presents a combined list of town or city names and state, province, or county names from the 'Addresses' table. The use of UNION allows for the merging of these two distinct sets of data into a single result set, providing a comprehensive view of geographical locations associated with the addresses.", "virtual_table": "SELECT town_city FROM addresses UNION SELECT state_province_county FROM addresses"}
{"sample_id": "train.6323", "db_id": "e_government", "question": "What is the last name of the contact individual from the Labour party organization who was contacted most recently?", "rationale": ["The query identifies the relevant tables: 'organizations', 'organization_contact_individuals', and 'individuals'.", "It selects the 'individual_last_name' from the 'individuals' table.", "The JOIN operations link the tables based on their foreign key relationships, ensuring that only relevant contacts for the specified organization are included.", "A WHERE clause filters the results to include only those contacts associated with a specific organization name, using a placeholder for the string value.", "The results are ordered by 'date_contact_to' in descending order to show the most recent contacts first.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for the numeric value."], "gold_sql": "SELECT t3.individual_last_name FROM organizations AS t1 JOIN organization_contact_individuals AS t2 ON t1.organization_id  =  t2.organization_id JOIN individuals AS t3 ON t2.individual_id  =  t3.individual_id WHERE t1.organization_name  =  'Labour Party' ORDER BY t2.date_contact_to DESC LIMIT 1", "source_tables": ["organizations", "organization_contact_individuals", "individuals"], "description": "This virtual table provides the last names of individuals who have contacted a specific organization. The data is retrieved from the 'organizations', 'organization_contact_individuals', and 'individuals' tables, with a filter applied to the organization name. The results are ordered by the contact end date in descending order, and a limit is set on the number of results returned.", "virtual_table": "SELECT t3.individual_last_name FROM organizations AS t1 JOIN organization_contact_individuals AS t2 ON t1.organization_id  =  t2.organization_id JOIN individuals AS t3 ON t2.individual_id  =  t3.individual_id WHERE t1.organization_name  =  [PLACEHOLDER-TYPE:STRING] ORDER BY t2.date_contact_to DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6328", "db_id": "e_government", "question": "Find name of the services that has never been used.", "rationale": ["The query identifies the relevant table, which is 'Services'.", "It selects the 'service_name' column to display the names of the services.", "The EXCEPT clause is used to exclude service names that are present in the 'Party_Services' table, which indicates that those services have been booked by parties. This is achieved by joining the 'Services' table with the 'Party_Services' table on the 'service_id' column."], "gold_sql": "SELECT service_name FROM services EXCEPT SELECT t1.service_name FROM services AS t1 JOIN party_services AS t2 ON t1.service_id  =  t2.service_id", "source_tables": ["services", "party_services"], "description": "The virtual table provides a list of service names from the 'Services' table that are not booked by any party in the 'Party_Services' table. The query uses an EXCEPT clause to filter out services that have been associated with any party bookings, ensuring that only unbooked services are displayed.", "virtual_table": "SELECT service_name FROM services EXCEPT SELECT t1.service_name FROM services AS t1 JOIN party_services AS t2 ON t1.service_id  =  t2.service_id"}
{"sample_id": "train.6343", "db_id": "e_government", "question": "Give the state corresponding to the line number building \"6862 Kaitlyn Knolls\".", "rationale": ["The query identifies the relevant table, which is 'Addresses'.", "Select the column to display, 'state_province_county'.", "Add a condition to filter the 'line_1_number_building' column using a LIKE clause with a placeholder for string values."], "gold_sql": "SELECT state_province_county FROM addresses WHERE line_1_number_building LIKE '%6862 Kaitlyn Knolls%'", "source_tables": ["addresses"], "description": "This virtual table provides the state, province, or county information from the 'Addresses' table for addresses that match a specific building line. The placeholder in the LIKE clause represents a pattern to search for in the address line.", "virtual_table": "SELECT state_province_county FROM addresses WHERE line_1_number_building LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.437", "db_id": "flight_1", "question": "What is the salary and name of the employee who has the most number of certificates on aircrafts with distance more than 5000?", "rationale": ["The query identifies the relevant tables: 'Employee', 'Certificate', and 'Aircraft'.", "It selects the 'name' column from the 'Employee' table.", "The query joins the 'Employee' table with the 'Certificate' table on the employee ID, and then joins the 'Certificate' table with the 'Aircraft' table on the aircraft ID.", "A condition is added to filter the results based on the maximum distance the aircraft can travel using a placeholder for numeric values.", "The results are grouped by employee ID to count the number of certificates held by each employee.", "The results are ordered in descending order based on the count of certificates, and a limit is applied to restrict the number of results returned."], "gold_sql": "SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  5000 GROUP BY T1.eid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employee", "certificate", "aircraft"], "description": "This virtual table provides the names of employees who hold certificates for aircraft that can travel a distance greater than a specified value. The results are grouped by employee ID and ordered by the number of certificates held, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause represent the maximum distance and the number of results to display, respectively.", "virtual_table": "SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.eid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.429", "db_id": "flight_1", "question": "Show names for all employees who do not have certificate of Boeing 737-800.", "rationale": ["The query identifies the relevant table, which is 'Employee'.", "It selects the 'name' column to display the names of employees.", "The EXCEPT clause is used to exclude employees who hold a certificate for a specific aircraft model.", "A JOIN operation is performed between 'Employee', 'Certificate', and 'Aircraft' tables to filter out employees based on the aircraft model using a placeholder for string values."], "gold_sql": "SELECT name FROM Employee EXCEPT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  'Boeing 737-800'", "source_tables": ["employee", "certificate", "aircraft"], "description": "This virtual table lists the names of employees from the 'Employee' table who do not hold a certificate for a specific aircraft model. The placeholder in the query represents the name of the aircraft model for which the certification is being checked.", "virtual_table": "SELECT name FROM Employee EXCEPT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.402", "db_id": "flight_1", "question": "What is the average distance and price for all flights from LA?", "rationale": ["The query identifies the relevant table, which is 'Flight'.", "It selects the average values of 'distance' and 'price' columns.", "A condition is added to filter the results based on the 'origin' column using a placeholder for string values."], "gold_sql": "SELECT avg(distance) ,  avg(price) FROM Flight WHERE origin  =  'Los Angeles'", "source_tables": ["flight"], "description": "This virtual table provides the average distance and average price of flights originating from a specific location. The placeholder in the WHERE clause represents the origin of the flights.", "virtual_table": "SELECT avg(distance) ,  avg(price) FROM Flight WHERE origin  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.434", "db_id": "flight_1", "question": "What is the name and distance of every aircraft that can cover a distance of more than 5000 and which at least 5 people can fly?", "rationale": ["The query identifies the relevant tables, which are 'Certificate' and 'Aircraft'.", "It selects the 'name' column from the 'Aircraft' table.", "A JOIN operation is performed between 'Certificate' and 'Aircraft' on the aircraft ID to link certifications to aircraft.", "A condition is added to filter aircraft based on their maximum travel distance using a placeholder for numeric values.", "The results are grouped by aircraft ID to aggregate the certifications.", "An ORDER BY clause is included to filter the results based on the count of certifications, using a placeholder for numeric values."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  5000 GROUP BY T1.aid ORDER BY count(*)  >=  5", "source_tables": ["aircraft", "certificate"], "description": "This virtual table provides the names of aircraft that have been certified by employees, filtered by the maximum distance the aircraft can travel. The placeholders in the WHERE clause represent the distance threshold and the minimum count of certifications required for the aircraft.", "virtual_table": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.aid ORDER BY count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.433", "db_id": "flight_1", "question": "Show the name and distance of the aircrafts with more than 5000 distance and which at least 5 people have its certificate.", "rationale": ["The query identifies the relevant tables, 'Certificate' and 'Aircraft', and establishes a join between them based on the aircraft ID.", "It selects the 'name' column from the 'Aircraft' table to display the names of the aircraft models.", "A condition is added to filter the aircraft based on their maximum travel distance using a placeholder for numeric values.", "The results are grouped by the aircraft ID to aggregate the data appropriately.", "An ordering condition is applied to ensure that only those aircraft with a count of certifications above a specified threshold are included in the results."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  5000 GROUP BY T1.aid ORDER BY count(*)  >=  5", "source_tables": ["aircraft", "certificate"], "description": "This virtual table provides the names of aircraft models that have been certified for use by employees, specifically filtering for those aircraft that can travel a distance greater than a specified value. The results are grouped by aircraft ID and ordered based on the count of certifications that meet a minimum threshold.", "virtual_table": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.aid ORDER BY count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.408", "db_id": "flight_1", "question": "What place has the most flights coming from there?", "rationale": ["The query identifies the relevant table, which is 'Flight'.", "It selects the 'origin' column to display the starting locations of flights.", "The GROUP BY clause is used to group the results by 'origin' to count the number of flights from each location.", "The ORDER BY clause sorts the results based on the count of flights in descending order.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT origin FROM Flight GROUP BY origin ORDER BY count(*) DESC LIMIT 1", "source_tables": ["flight"], "description": "The virtual table summarizes the origins of flights from the 'Flight' table, grouping them to count how many flights depart from each origin. The results are ordered by the number of flights in descending order, and a placeholder is used to limit the number of origins returned.", "virtual_table": "SELECT origin FROM Flight GROUP BY origin ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.407", "db_id": "flight_1", "question": "Which origin has most number of flights?", "rationale": ["The query identifies the relevant table, which is 'Flight'.", "It selects the 'origin' column to display the starting locations of flights.", "The results are grouped by 'origin' to aggregate the data based on unique departure locations.", "The query orders the results by the count of flights from each origin in descending order to show the most popular departure points first.", "A limit is applied to restrict the number of origins returned, using a placeholder for numeric values."], "gold_sql": "SELECT origin FROM Flight GROUP BY origin ORDER BY count(*) DESC LIMIT 1", "source_tables": ["flight"], "description": "This virtual table provides a list of origins from which flights depart, grouped by the origin location. The results are ordered by the number of flights departing from each origin in descending order, with a limit on the number of origins returned as specified by the placeholder.", "virtual_table": "SELECT origin FROM Flight GROUP BY origin ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.387", "db_id": "flight_1", "question": "Show origins of all flights with destination Honolulu.", "rationale": ["The query is identifying the relevant table, which is 'Flight'.", "Select the column to display, 'origin'.", "Add a condition to filter the 'destination' column for the specified destination using a placeholder for string values."], "gold_sql": "SELECT origin FROM Flight WHERE destination  =  'Honolulu'", "source_tables": ["flight"], "description": "This virtual table provides the origin locations of flights from the 'Flight' table that are headed to a specific destination. The placeholder in the WHERE clause represents the destination's name.", "virtual_table": "SELECT origin FROM Flight WHERE destination  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.400", "db_id": "flight_1", "question": "What are the numbers of the shortest flights?", "rationale": ["The query is identifying the relevant table, which is 'flight'.", "Select the column to display, 'flno', which represents the flight number.", "Order the results by the 'distance' column in ascending order to show the shortest flights first.", "Limit the number of results returned using a placeholder for numeric values to specify how many flight numbers to retrieve."], "gold_sql": "SELECT flno FROM Flight ORDER BY distance ASC LIMIT 3", "source_tables": ["flight"], "description": "This virtual table lists the flight numbers from the 'flight' table, ordered by the distance of each flight in ascending order. The placeholder in the LIMIT clause indicates the maximum number of flight numbers to return.", "virtual_table": "SELECT flno FROM Flight ORDER BY distance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.241", "db_id": "flight_2", "question": "Find all airlines that have at least 10 flights.", "rationale": ["The query identifies the relevant tables, which are 'airlines' and 'flights'.", "It selects the 'Airline' column from the 'airlines' table, aliased as T1.", "A JOIN operation is performed between 'airlines' and 'flights' on the airline identifier to link the two tables.", "The results are grouped by the airline name to aggregate the flight counts.", "The HAVING clause filters the results to include only those airlines that have a flight count greater than a specified number, using a placeholder for numeric values."], "gold_sql": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  >  10", "source_tables": ["flights", "airlines"], "description": "The virtual table provides a list of airlines that operate more than a specified number of flights. The placeholder in the HAVING clause represents the minimum number of flights an airline must operate to be included in the results.", "virtual_table": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.243", "db_id": "flight_2", "question": "Find all airlines that have fewer than 200 flights.", "rationale": ["The query identifies the relevant tables, which are 'airlines' and 'flights'.", "It selects the 'Airline' column from the 'airlines' table.", "A JOIN operation is performed between 'airlines' and 'flights' on the airline identifier to associate flights with their respective airlines.", "The results are grouped by the airline name to aggregate the flight counts for each airline.", "The HAVING clause is used to filter the grouped results to include only those airlines with a flight count less than a specified number, using a placeholder for numeric values."], "gold_sql": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  <  200", "source_tables": ["flights", "airlines"], "description": "The virtual table provides a list of airlines that operate flights, grouped by the airline name. It filters the results to show only those airlines that have fewer flights than a specified number. The placeholder in the HAVING clause represents the maximum number of flights an airline can have to be included in the results.", "virtual_table": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.231", "db_id": "flight_2", "question": "Find the abbreviation and country of the airline that has fewest number of flights?", "rationale": ["The query identifies the relevant tables, which are 'airlines' and 'flights'.", "It selects the 'Abbreviation' and 'Country' columns from the 'airlines' table, aliased as T1.", "The query joins the 'airlines' table with the 'flights' table on the airline identifier to associate flights with their respective airlines.", "It groups the results by the 'Airline' to aggregate the data based on the number of flights each airline operates.", "Finally, it orders the results by the count of flights and limits the output to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT T1.Abbreviation ,  T1.Country FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) LIMIT 1", "source_tables": ["flights", "airlines"], "description": "This virtual table provides a summary of the abbreviations and countries of airlines that operate flights. The data is aggregated by airline, showing how many flights each airline operates, with a limit on the number of results returned based on a specified number.", "virtual_table": "SELECT T1.Abbreviation ,  T1.Country FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.242", "db_id": "flight_2", "question": "Which airlines have at least 10 flights?", "rationale": ["The query identifies the relevant tables, which are 'airlines' and 'flights'.", "It selects the 'Airline' column from the 'airlines' table.", "A JOIN operation is performed between 'airlines' and 'flights' on the airline identifier to link the two tables.", "The results are grouped by the 'Airline' to aggregate the flight counts for each airline.", "The HAVING clause filters the results to include only those airlines that have a flight count greater than a specified number, using a placeholder for numeric values."], "gold_sql": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  >  10", "source_tables": ["flights", "airlines"], "description": "The virtual table provides a list of airlines that operate more than a specified number of flights. The placeholder in the HAVING clause represents the minimum count of flights an airline must have to be included in the results.", "virtual_table": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.228", "db_id": "flight_2", "question": "Give the code of the airport with the least flights.", "rationale": ["The query identifies the relevant tables, which are 'airports' and 'flights'.", "It selects the 'AirportCode' from the 'airports' table.", "A JOIN operation is performed between 'airports' and 'flights' on the condition that the airport code matches either the source or destination airport code.", "The results are grouped by 'AirportCode' to ensure uniqueness.", "The results are ordered by the count of flights associated with each airport code, and a limit is applied to restrict the number of results returned."], "gold_sql": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) LIMIT 1", "source_tables": ["airports", "flights"], "description": "This virtual table provides a list of unique airport codes from the 'airports' table that are either source or destination airports for flights in the 'flights' table. The placeholder in the LIMIT clause indicates the maximum number of airport codes to return.", "virtual_table": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.230", "db_id": "flight_2", "question": "What airline serves the most flights?", "rationale": ["The query identifies the relevant tables, which are 'airlines' and 'flights'.", "It selects the 'Airline' column from the 'airlines' table, aliased as T1.", "A JOIN operation is performed between 'airlines' and 'flights' on the airline identifier to link the two tables.", "The results are grouped by the 'Airline' to aggregate the flight counts for each airline.", "The results are ordered by the count of flights in descending order to show the most active airlines first.", "A limit is applied to restrict the number of results returned based on a placeholder for numeric values."], "gold_sql": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) DESC LIMIT 1", "source_tables": ["flights", "airlines"], "description": "The virtual table provides a list of airlines from the 'airlines' table that are associated with flights in the 'flights' table. The results are grouped by airline name and ordered by the number of flights in descending order, with a limit on the number of airlines returned based on a specified number.", "virtual_table": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.226", "db_id": "flight_2", "question": "What is the airport code of the airport with the most flights?", "rationale": ["The query identifies the relevant tables, which are 'airports' and 'flights'.", "It selects the 'AirportCode' from the 'airports' table.", "A JOIN operation is performed between 'airports' and 'flights' on the condition that the airport code matches either the source or destination airport code.", "The results are grouped by 'AirportCode' to aggregate the data based on the number of flights.", "The results are ordered in descending order based on the count of flights associated with each airport code.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "flights"], "description": "The virtual table provides a list of airport codes that are either source or destination airports for flights. The results are grouped by airport code and ordered by the number of flights associated with each airport, allowing users to identify the most frequently used airports. The placeholder in the LIMIT clause represents the maximum number of airport codes to return.", "virtual_table": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.246", "db_id": "flight_2", "question": "Which flight numbers correspond to United Airlines flights?", "rationale": ["The query identifies the relevant tables, which are 'flights' and 'airlines'.", "It selects the 'FlightNo' column from the 'flights' table.", "A JOIN operation is performed between 'flights' and 'airlines' on the airline identifier to link the two tables.", "A condition is added to filter the results based on the specified airline name using a placeholder for string values."], "gold_sql": "SELECT T1.FlightNo FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T2.uid  =  T1.Airline WHERE T2.Airline  =  'United Airlines'", "source_tables": ["flights", "airlines"], "description": "This virtual table provides the unique flight numbers from the 'flights' table for a specific airline. The placeholder in the WHERE clause represents the name of the airline being queried.", "virtual_table": "SELECT T1.FlightNo FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T2.uid  =  T1.Airline WHERE T2.Airline  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.245", "db_id": "flight_2", "question": "What are flight numbers of Airline \"United Airlines\"?", "rationale": ["The query identifies the relevant tables, which are 'flights' and 'airlines'.", "It selects the 'FlightNo' column from the 'flights' table.", "A JOIN operation is performed between 'flights' and 'airlines' on the airline identifier to link the two tables.", "A condition is added to filter the results based on the specified airline name using a placeholder for string values."], "gold_sql": "SELECT T1.FlightNo FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T2.uid  =  T1.Airline WHERE T2.Airline  =  'United Airlines'", "source_tables": ["flights", "airlines"], "description": "This virtual table provides the unique flight numbers from the 'flights' table operated by a specific airline. The placeholder in the WHERE clause represents the name of the airline.", "virtual_table": "SELECT T1.FlightNo FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T2.uid  =  T1.Airline WHERE T2.Airline  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.182", "db_id": "flight_2", "question": "Which abbreviation corresponds to Jetblue Airways?", "rationale": ["The query identifies the relevant table, which is 'airlines'.", "Select the column to display, 'Abbreviation'.", "Add a condition to filter the 'Airline' column for the specified airline name using a placeholder for string values."], "gold_sql": "SELECT Abbreviation FROM AIRLINES WHERE Airline  =  'JetBlue Airways'", "source_tables": ["airlines"], "description": "This virtual table provides the abbreviation of airlines from the 'airlines' table based on the specified airline name. The placeholder in the WHERE clause represents the name of the airline for which the abbreviation is being queried.", "virtual_table": "SELECT Abbreviation FROM AIRLINES WHERE Airline  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.213", "db_id": "flight_2", "question": "How many flights does airline 'JetBlue Airways' have?", "rationale": ["The query identifies the relevant tables, which are 'flights' and 'airlines'.", "It uses a JOIN operation to connect the 'flights' table with the 'airlines' table based on the airline's unique identifier.", "The SELECT statement counts the total number of flights for the specified airline.", "A condition is added to filter the results based on the airline's name using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T1.Airline  =  T2.uid WHERE T2.Airline = 'JetBlue Airways'", "source_tables": ["flights", "airlines"], "description": "This virtual table provides the count of flights operated by a specific airline from the 'flights' table, joined with the 'airlines' table to filter by the airline's name. The placeholder in the WHERE clause represents the name of the airline.", "virtual_table": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T1.Airline  =  T2.uid WHERE T2.Airline = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6857", "db_id": "flight_4", "question": "List the cities which have more than 2 airports sorted by the number of airports.", "rationale": ["The query identifies the relevant table, which is 'airports'.", "It selects the 'city' column to display the names of cities.", "The GROUP BY clause is used to group the results by city, allowing for aggregation.", "The HAVING clause filters the groups to include only those cities that have a count of airports greater than a specified number, using a placeholder for numeric values.", "Finally, the results are ordered by the count of airports in ascending order."], "gold_sql": "SELECT city FROM airports GROUP BY city HAVING count(*)  >  2 ORDER BY count(*)", "source_tables": ["airports"], "description": "This virtual table provides a list of cities that have more than a specified number of airports. The placeholder in the HAVING clause represents the minimum count of airports required for a city to be included in the results.", "virtual_table": "SELECT city FROM airports GROUP BY city HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER] ORDER BY count(*)"}
{"sample_id": "train.6852", "db_id": "flight_4", "question": "What is the number of cities in the United States with more than 3 airports?", "rationale": ["The query identifies the relevant table, which is 'airports'.", "It selects the 'city' column to display the names of cities.", "The WHERE clause filters the results based on the specified country using a placeholder for string values.", "The GROUP BY clause groups the results by city to aggregate the data.", "The HAVING clause ensures that only cities with a count of airports greater than a specified number are included, using a placeholder for numeric values."], "gold_sql": "SELECT city FROM airports WHERE country  =  'United States' GROUP BY city HAVING count(*)  >  3", "source_tables": ["airports"], "description": "The virtual table provides a list of cities from the 'airports' table that are located in a specific country. The query groups the results by city and includes a condition to only show cities that have more than a specified number of airports.", "virtual_table": "SELECT city FROM airports WHERE country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY city HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6881", "db_id": "flight_4", "question": "Find the busiest source airport that runs most number of routes in China.", "rationale": ["The query identifies the relevant tables, which are 'airports' and 'routes'.", "It selects the 'name' column from the 'airports' table, aliased as T1.", "A JOIN operation is performed between 'airports' (T1) and 'routes' (T2) on the source airport ID to link routes to their respective airports.", "A condition is added to filter the results based on the specified country using a placeholder for string values.", "The results are grouped by airport name to aggregate the count of routes for each airport.", "The results are ordered by the count of routes in descending order to show the most active airports first.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid WHERE T1.country  =  'China' GROUP BY T1.name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "description": "This virtual table provides a list of airport names from the 'airports' table that are located in a specific country. The query joins the 'airports' table with the 'routes' table to filter the airports based on their country and counts the number of routes originating from each airport. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the country name and the maximum number of results to return.", "virtual_table": "SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid WHERE T1.country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6837", "db_id": "flight_4", "question": "Find the name and city of the airport which is the source for the most number of flight routes.", "rationale": ["The query identifies the relevant tables, which are 'airports' and 'routes'.", "It selects the 'name' and 'city' columns from the 'airports' table and the 'src_apid' from the 'routes' table.", "A JOIN operation is performed on the 'apid' of the 'airports' table and 'src_apid' of the 'routes' table to combine the data.", "The results are grouped by 'src_apid' to aggregate the data based on source airport IDs.", "The results are ordered by the count of routes associated with each source airport in descending order.", "A limit is applied to restrict the number of results returned based on a placeholder for numeric values."], "gold_sql": "SELECT T1.name ,  T1.city ,  T2.src_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T2.src_apid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "description": "This virtual table provides a list of airport names and their corresponding cities, along with the source airport IDs from the 'airports' and 'routes' tables. The data is grouped by source airport ID and ordered by the number of routes associated with each source airport, with a limit on the number of results returned based on a specified number.", "virtual_table": "SELECT T1.name ,  T1.city ,  T2.src_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T2.src_apid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6844", "db_id": "flight_4", "question": "What are the countries with the most airlines whose active status is Y?", "rationale": ["The query identifies the relevant table, which is 'airlines'.", "It selects the 'country' column to display the countries of the airlines.", "A condition is added to filter the results based on the 'active' status of the airlines using a placeholder for string values.", "The results are grouped by 'country' to count the number of active airlines in each country.", "The results are ordered in descending order based on the count of active airlines, and a limit is applied to restrict the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT country FROM airlines WHERE active  =  'Y' GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airlines"], "description": "The virtual table summarizes the countries of airlines that are currently active, grouping them to count the number of active airlines per country. The placeholders in the query allow for specifying the activity status of the airlines and limiting the number of results returned based on user preference.", "virtual_table": "SELECT country FROM airlines WHERE active  =  [PLACEHOLDER-TYPE:STRING] GROUP BY country ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6843", "db_id": "flight_4", "question": "Which countries has the most number of airlines whose active status is 'Y'?", "rationale": ["The query identifies the relevant table, which is 'airlines'.", "It selects the 'country' column to display the countries of the airlines.", "A condition is added to filter the results based on the 'active' status of the airlines using a placeholder for string values.", "The results are grouped by 'country' to count the number of active airlines in each country.", "The results are ordered in descending order based on the count of active airlines, and a limit is applied to restrict the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT country FROM airlines WHERE active  =  'Y' GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airlines"], "description": "The virtual table summarizes the countries of airlines that are currently active, grouping them to count the number of active airlines per country. The placeholders in the query allow for specifying the activity status of the airlines and limiting the number of results returned based on user preference.", "virtual_table": "SELECT country FROM airlines WHERE active  =  [PLACEHOLDER-TYPE:STRING] GROUP BY country ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6833", "db_id": "flight_4", "question": "Find the name and city of the airport which is the destination of the most number of routes.", "rationale": ["The query identifies the relevant tables, which are 'airports' and 'routes'.", "It selects the 'name' and 'city' columns from the 'airports' table (aliased as T1) and the 'dst_apid' from the 'routes' table (aliased as T2).", "A JOIN operation is performed on the 'apid' of 'airports' and 'dst_apid' of 'routes' to link the two tables based on destination airport IDs.", "The results are grouped by 'dst_apid' to aggregate the data for each destination airport.", "The results are ordered by the count of routes to each destination in descending order, allowing the most popular destinations to appear first.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.name ,  T1.city ,  T2.dst_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid GROUP BY T2.dst_apid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "description": "This virtual table provides a list of destination airport names and their corresponding cities from the 'airports' table, along with the destination airport IDs from the 'routes' table. The results are grouped by destination airport ID and ordered by the number of routes to each destination, with a limit on the number of results returned, specified by a placeholder for numeric values.", "virtual_table": "SELECT T1.name ,  T1.city ,  T2.dst_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid GROUP BY T2.dst_apid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6859", "db_id": "flight_4", "question": "Find the number of routes for each source airport and the airport name.", "rationale": ["The query identifies the relevant tables, which are 'airports' and 'routes'.", "It selects the count of routes and the name of the airport from the 'airports' table.", "A JOIN operation is performed between 'airports' and 'routes' on the source airport ID to link the two tables.", "The results are grouped by the airport name to aggregate the count of routes for each airport."], "gold_sql": "SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name", "source_tables": ["airports", "routes"], "description": "This virtual table provides a count of routes originating from each airport, along with the names of those airports. The placeholder in the SELECT statement represents the count of routes, while the GROUP BY clause organizes the results by the airport names.", "virtual_table": "SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name"}
{"sample_id": "train.6860", "db_id": "flight_4", "question": "For each airport name, how many routes start at that airport?", "rationale": ["The query identifies the relevant tables, which are 'airports' and 'routes'.", "It selects the count of routes and the name of the airport from the 'airports' table.", "A JOIN operation is performed between 'airports' and 'routes' on the source airport ID to link the two tables.", "The results are grouped by the airport name to aggregate the count of routes for each airport."], "gold_sql": "SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name", "source_tables": ["airports", "routes"], "description": "This virtual table provides a count of routes originating from each airport, along with the names of those airports. The placeholder in the SELECT statement represents the count of routes, while the GROUP BY clause organizes the results by the airport names.", "virtual_table": "SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name"}
{"sample_id": "train.6879", "db_id": "flight_4", "question": "Find the name of airline which runs the most number of routes.", "rationale": ["The query identifies the relevant tables, which are 'airlines' and 'routes'.", "It selects the 'name' column from the 'airlines' table, aliased as T1.", "A JOIN operation is performed between 'airlines' (T1) and 'routes' (T2) on the airline ID (alid) to associate airlines with their routes.", "The results are grouped by the airline name to aggregate the number of routes for each airline.", "The results are ordered in descending order based on the count of routes, allowing us to see which airlines operate the most routes.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.name FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["routes", "airlines"], "description": "The virtual table provides a list of airline names from the 'airlines' table, which are associated with routes in the 'routes' table. The results are grouped by airline name and ordered by the number of routes each airline operates, with a limit on the number of results returned based on a specified number.", "virtual_table": "SELECT T1.name FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6846", "db_id": "flight_4", "question": "How many airlines operate out of each country in descending order?", "rationale": ["The query identifies the relevant table, which is 'airlines'.", "It selects the 'country' column and counts the number of entries for each country using the COUNT function.", "The GROUP BY clause is used to group the results by 'country'.", "The ORDER BY clause sorts the results in descending order based on the count of airlines per country."], "gold_sql": "SELECT country ,  count(*) FROM airlines GROUP BY country ORDER BY count(*) DESC", "source_tables": ["airlines"], "description": "This virtual table summarizes the number of airlines grouped by their country of operation. The placeholder in the SELECT statement represents the country, and the count indicates the total number of airlines from each country, sorted in descending order of their count.", "virtual_table": "SELECT country ,  count(*) FROM airlines GROUP BY country ORDER BY count(*) DESC"}
{"sample_id": "train.6836", "db_id": "flight_4", "question": "For the airline ids with the top 10 most routes operated, what are their names?", "rationale": ["The query identifies the relevant tables, which are 'airlines' and 'routes'.", "It selects the 'name' column from the 'airlines' table and the 'alid' column from the 'routes' table.", "A JOIN operation is performed on the airline ID to combine data from both tables.", "The results are grouped by the airline ID to count the number of routes associated with each airline.", "The results are ordered by the count of routes in descending order to show the most active airlines first.", "A placeholder is included in the LIMIT clause to allow the user to specify how many results they want to retrieve."], "gold_sql": "SELECT T1.name ,  T2.alid FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T2.alid ORDER BY count(*) DESC LIMIT 10", "source_tables": ["routes", "airlines"], "description": "This virtual table provides a list of airline names along with their unique identifiers from the 'airlines' and 'routes' tables. The data is grouped by airline ID to aggregate the number of routes each airline operates, and the results are ordered by the count of routes in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of results to return.", "virtual_table": "SELECT T1.name ,  T2.alid FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T2.alid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6835", "db_id": "flight_4", "question": "Find the names of the top 10 airlines that operate the most number of routes.", "rationale": ["The query identifies the relevant tables, which are 'airlines' and 'routes'.", "It selects the 'name' column from the 'airlines' table and the 'alid' column from the 'routes' table.", "A JOIN operation is performed on the 'alid' column to combine data from both tables based on the airline ID.", "The results are grouped by 'alid' to count the number of routes associated with each airline.", "The results are ordered by the count of routes in descending order to show the most active airlines first.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.name ,  T2.alid FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T2.alid ORDER BY count(*) DESC LIMIT 10", "source_tables": ["routes", "airlines"], "description": "This virtual table provides a list of airline names along with their unique identifiers from the 'airlines' and 'routes' tables. The data is grouped by airline ID to aggregate the number of routes each airline operates, and the results are ordered by the count of routes in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of results to return.", "virtual_table": "SELECT T1.name ,  T2.alid FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T2.alid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6874", "db_id": "flight_4", "question": "What is the number of routes that end at John F Kennedy International Airport?", "rationale": ["The query identifies the relevant tables, which are 'airports' and 'routes'.", "It uses a JOIN operation to connect the two tables based on the destination airport ID.", "The SELECT statement counts the number of routes that match the specified destination airport name using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.name  =  'John F Kennedy International Airport'", "source_tables": ["airports", "routes"], "description": "This virtual table provides the count of routes that lead to a specific destination airport from the 'airports' and 'routes' tables. The placeholder in the WHERE clause represents the name of the destination airport being queried.", "virtual_table": "SELECT count(*) FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6822", "db_id": "flight_4", "question": "How many airports' names have the word Interanation in them?", "rationale": ["The query is identifying the relevant table, which is 'airports'.", "The SELECT statement is used to count the total number of records that match a certain condition.", "The condition is specified in the WHERE clause, using the LIKE operator to filter the 'name' column for a specified pattern, represented by a placeholder for string values."], "gold_sql": "SELECT count(*) FROM airports WHERE name LIKE '%International%'", "source_tables": ["airports"], "description": "This virtual table provides the count of airports from the 'airports' table that match a specific name pattern. The placeholder in the WHERE clause represents the name pattern to search for.", "virtual_table": "SELECT count(*) FROM airports WHERE name LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6816", "db_id": "flight_4", "question": "What are the countries of all airlines whose names start with Orbit?", "rationale": ["The query identifies the relevant table, which is 'airlines'.", "Select the column to display, 'country'.", "Add a condition to filter the 'name' column using a LIKE operator for partial matches, utilizing a placeholder for string values."], "gold_sql": "SELECT country FROM airlines WHERE name LIKE 'Orbit%'", "source_tables": ["airlines"], "description": "This virtual table provides the country of airlines based on their name. The placeholder in the WHERE clause allows for filtering by a specific airline name, accommodating partial matches.", "virtual_table": "SELECT country FROM airlines WHERE name LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6872", "db_id": "flight_4", "question": "What is the number of routes operated by the airline American Airlines whose destinations are in Italy?", "rationale": ["The query identifies the relevant tables: 'routes', 'airports', and 'airlines'.", "It uses JOIN operations to connect these tables based on their foreign key relationships: 'routes.dst_apid' with 'airports.apid' and 'routes.alid' with 'airlines.alid'.", "The SELECT statement counts the total number of routes that meet the specified conditions.", "The WHERE clause filters the results based on the country of the destination airport and the name of the airline, using placeholders for user-defined values."], "gold_sql": "SELECT count(*) FROM routes AS T1 JOIN airports AS T2 ON T1.dst_apid  =  T2.apid JOIN airlines AS T3 ON T1.alid  =  T3.alid WHERE T2.country  =  'Italy' AND T3.name  =  'American Airlines'", "source_tables": ["routes", "airlines", "airports"], "description": "This virtual table provides a count of routes that lead to airports located in a specific country, operated by a particular airline. The placeholders in the WHERE clause represent the country name and the airline name, allowing users to filter the results based on their criteria.", "virtual_table": "SELECT count(*) FROM routes AS T1 JOIN airports AS T2 ON T1.dst_apid  =  T2.apid JOIN airlines AS T3 ON T1.alid  =  T3.alid WHERE T2.country  =  [PLACEHOLDER-TYPE:STRING] AND T3.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6379", "db_id": "flight_company", "question": "List the name of the pilots who have flied for both a company that mainly provide 'Cargo' services and a company that runs 'Catering services' activities.", "rationale": ["The query identifies the relevant tables, which are 'operate_company' and 'flight'.", "It selects the 'pilot' column from the 'flight' table, which is linked to the 'operate_company' table.", "The query uses a JOIN to connect the 'operate_company' and 'flight' tables based on the company ID.", "It applies a WHERE clause to filter the results based on the 'principal_activities' of the operating companies, using placeholders for string values.", "The INTERSECT operator is used to find common pilots from two different sets of results, both filtered by their principal activities."], "gold_sql": "SELECT T2.pilot FROM operate_company AS T1 JOIN flight AS t2 ON T1.id  =  T2.company_id WHERE T1.principal_activities  =  'Cargo' INTERSECT SELECT T2.pilot FROM operate_company AS T1 JOIN flight AS t2 ON T1.id  =  T2.company_id WHERE T1.principal_activities  =  'Catering services'", "source_tables": ["flight", "operate_company"], "description": "This virtual table provides a list of pilots who operate flights for companies engaged in specific principal activities. The query uses an intersection to find pilots from two different sets of operating companies, both filtered by their principal activities, represented by placeholders for string values.", "virtual_table": "SELECT T2.pilot FROM operate_company AS T1 JOIN flight AS t2 ON T1.id  =  T2.company_id WHERE T1.principal_activities  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.pilot FROM operate_company AS T1 JOIN flight AS t2 ON T1.id  =  T2.company_id WHERE T1.principal_activities  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6384", "db_id": "flight_company", "question": "which pilot is in charge of the most number of flights?", "rationale": ["The query identifies the relevant table, which is 'flight'.", "Select the column to display, 'pilot', which represents the name of the pilot operating the flight.", "Group the results by the 'pilot' column to aggregate the data based on each pilot's name.", "Order the results by the count of flights each pilot has operated in descending order to highlight the most active pilots.", "Limit the number of results returned using a placeholder for numeric values to specify how many pilots to display."], "gold_sql": "SELECT pilot FROM flight GROUP BY pilot ORDER BY count(*) DESC LIMIT 1", "source_tables": ["flight"], "description": "This virtual table provides a list of pilots from the 'flight' table, grouped by their names. The results are ordered by the number of flights each pilot has operated, allowing users to identify the most active pilots. The placeholder in the LIMIT clause represents the maximum number of pilots to return.", "virtual_table": "SELECT pilot FROM flight GROUP BY pilot ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6370", "db_id": "flight_company", "question": "What is the velocity of the pilot named 'Thompson'?", "rationale": ["The query identifies the relevant table, which is 'flight'.", "It selects the average of the 'velocity' column to calculate the average speed of flights.", "A condition is added to filter the results based on the specified pilot using a placeholder for string values."], "gold_sql": "SELECT avg(velocity) FROM flight WHERE pilot  =  'Thompson'", "source_tables": ["flight"], "description": "This virtual table provides the average velocity of flights operated by a specific pilot from the 'flight' table. The placeholder in the WHERE clause represents the name of the pilot whose flights are being analyzed.", "virtual_table": "SELECT avg(velocity) FROM flight WHERE pilot  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2179", "db_id": "formula_1", "question": "Find the id and forenames of drivers who participated both the races with name Australian Grand Prix and the races with name Chinese Grand Prix?", "rationale": ["The query identifies the relevant tables: 'races', 'results', and 'drivers'.", "It selects the 'driverId' and 'forename' columns to display the driver information.", "The query uses JOIN operations to connect the 'races' table with the 'results' and 'drivers' tables based on their relationships.", "The WHERE clause filters the results based on the names of the races, using placeholders for the race names.", "The INTERSECT operator is used to find drivers who participated in both specified races."], "gold_sql": "SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = 'Australian Grand Prix' INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = 'Chinese Grand Prix'", "source_tables": ["races", "drivers", "results"], "description": "This virtual table provides a list of driver IDs and their corresponding first names from the 'drivers' table who participated in two specific races. The races are identified by their names, which are represented by placeholders in the WHERE clause.", "virtual_table": "SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2180", "db_id": "formula_1", "question": "What is the id and first name of all the drivers who participated in the Australian Grand Prix and the Chinese Grand Prix?", "rationale": ["The query identifies the relevant tables: 'races', 'results', and 'drivers'.", "It selects the 'driverId' and 'forename' columns to display the driver information.", "The query uses JOIN operations to connect the 'races' table with the 'results' and 'drivers' tables based on their relationships.", "The WHERE clause filters the results based on the names of the races, using placeholders for the race names.", "The INTERSECT operator is used to find drivers who participated in both specified races."], "gold_sql": "SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = 'Australian Grand Prix' INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = 'Chinese Grand Prix'", "source_tables": ["races", "drivers", "results"], "description": "This virtual table provides a list of driver IDs and their corresponding first names from the 'drivers' table who participated in two specific races. The races are identified by their names, which are represented by placeholders in the WHERE clause.", "virtual_table": "SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2181", "db_id": "formula_1", "question": "What are the forenames and surnames of drivers who participated in the races named Australian Grand Prix but not the races named Chinese Grand Prix?", "rationale": ["The query identifies the relevant tables: 'races', 'results', and 'drivers'.", "It selects the 'forename' and 'surname' columns from the 'drivers' table.", "The query uses JOINs to connect the 'races' table with the 'results' table and the 'drivers' table based on their respective identifiers.", "A condition is added to filter the results based on the name of the race using a placeholder for string values.", "The EXCEPT clause is used to exclude drivers from another specified race, again using a placeholder for the race name."], "gold_sql": "SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Australian Grand Prix' EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Chinese Grand Prix'", "source_tables": ["races", "drivers", "results"], "description": "This virtual table provides the first and last names of drivers who participated in a specific race, excluding those who participated in another specified race. The placeholders in the WHERE clause represent the names of the races.", "virtual_table": "SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2174", "db_id": "formula_1", "question": "How many drivers did not race in 2009?", "rationale": ["The query identifies the relevant table, which is 'results', to count distinct drivers.", "It uses a subquery to filter out race IDs from the 'races' table based on the specified year using a placeholder for numeric values.", "The main query counts the distinct 'driverId' from the 'results' table where the 'raceId' is not in the filtered list from the subquery."], "gold_sql": "SELECT count(DISTINCT driverId) FROM results WHERE raceId NOT IN( SELECT raceId FROM races WHERE YEAR != 2009 )", "source_tables": ["results", "races"], "description": "This virtual table provides the count of distinct drivers who participated in races, excluding those that took place in a specific year. The placeholder in the WHERE clause represents the year to filter out races.", "virtual_table": "SELECT count(DISTINCT driverId) FROM results WHERE raceId NOT IN( SELECT raceId FROM races WHERE YEAR != [PLACEHOLDER-TYPE:NUMBER] )"}
{"sample_id": "train.2223", "db_id": "formula_1", "question": "What are the maximum fastest lap speed in races held after 2004 grouped by race name and ordered by year?", "rationale": ["The query identifies the relevant tables, which are 'races' and 'results'.", "It selects the maximum fastest lap speed from the 'results' table and the race name and year from the 'races' table.", "A JOIN operation is performed on the raceId to combine data from both tables.", "A condition is added to filter the results for races that took place after a specified year using a placeholder for numeric values.", "The results are grouped by race name to ensure that the maximum speed is calculated for each race, and ordered by year."], "gold_sql": "SELECT max(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "description": "The virtual table summarizes the maximum fastest lap speed recorded for each race name from the 'races' table, filtered by races that occurred after a specified year. The placeholders in the WHERE clause represent the year of interest.", "virtual_table": "SELECT max(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.name ORDER BY T1.year"}
{"sample_id": "train.2173", "db_id": "formula_1", "question": "How many drivers did not participate in the races held in 2009?", "rationale": ["The query identifies the relevant table, which is 'results', to count distinct drivers.", "It uses a subquery to filter out race IDs from the 'races' table based on the specified year using a placeholder for numeric values.", "The main query counts the distinct 'driverId' from the 'results' table where the 'raceId' is not in the filtered list from the subquery."], "gold_sql": "SELECT count(DISTINCT driverId) FROM results WHERE raceId NOT IN( SELECT raceId FROM races WHERE YEAR != 2009 )", "source_tables": ["results", "races"], "description": "This virtual table provides the count of distinct drivers who participated in races, excluding those that took place in a specific year. The placeholder in the WHERE clause represents the year to filter out races.", "virtual_table": "SELECT count(DISTINCT driverId) FROM results WHERE raceId NOT IN( SELECT raceId FROM races WHERE YEAR != [PLACEHOLDER-TYPE:NUMBER] )"}
{"sample_id": "train.2190", "db_id": "formula_1", "question": "For each constructor id, how many races are there?", "rationale": ["The query is identifying the relevant table, which is 'constructorStandings'.", "Select the count of standings and the constructor identifier to display.", "Group the results by the constructor identifier to aggregate the standings for each constructor."], "gold_sql": "SELECT count(*) ,  constructorid FROM constructorStandings GROUP BY constructorid", "source_tables": ["constructorstandings"], "description": "The virtual table summarizes the total number of constructor standings for each constructor in the 'constructorStandings' table. The placeholder in the SELECT clause represents the constructor's identifier, while the count function aggregates the standings for each constructor.", "virtual_table": "SELECT count(*) ,  constructorid FROM constructorStandings GROUP BY constructorid"}
{"sample_id": "train.2217", "db_id": "formula_1", "question": "Find the names of Japanese constructors that have once earned more than 5 points?", "rationale": ["The query identifies the relevant tables, which are 'constructors' and 'constructorStandings'.", "It selects the 'name' column from the 'constructors' table.", "A JOIN operation is performed between 'constructors' and 'constructorStandings' on the 'constructorId' to link constructors with their standings.", "Conditions are added to filter constructors by their nationality using a placeholder for string values and to ensure they have more points than a specified threshold using a placeholder for numeric values."], "gold_sql": "SELECT T1.name FROM constructors AS T1 JOIN constructorstandings AS T2 ON T1.constructorid = T2.constructorid WHERE T1.nationality = 'Japanese' AND T2.points > 5", "source_tables": ["constructorstandings", "constructors"], "description": "The virtual table describes the names of constructors from the 'constructors' table who have a specific nationality and have scored more than a certain number of points in the constructor standings. The placeholders in the WHERE clause represent the constructor's nationality and the points threshold.", "virtual_table": "SELECT T1.name FROM constructors AS T1 JOIN constructorstandings AS T2 ON T1.constructorid = T2.constructorid WHERE T1.nationality = [PLACEHOLDER-TYPE:STRING] AND T2.points > [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2184", "db_id": "formula_1", "question": "What are all the different first names of the drivers who are in position as standing and won?", "rationale": ["The query identifies the relevant tables, which are 'drivers' and 'driverstandings'.", "It selects the distinct 'forename' column from the 'drivers' table.", "A JOIN operation is performed between 'drivers' and 'driverstandings' on the 'driverId' to link drivers with their standings.", "Conditions are added to filter the results based on the specified position and number of wins using placeholders for numeric values."], "gold_sql": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = 1 AND T2.wins = 1", "source_tables": ["drivers", "driverstandings"], "description": "The virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.", "virtual_table": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = [PLACEHOLDER-TYPE:NUMBER] AND T2.wins = [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2194", "db_id": "formula_1", "question": "What are the names of all races held after 2000 in Spain?", "rationale": ["The query identifies the relevant tables, which are 'races' and 'circuits'.", "It selects distinct race names from the 'races' table.", "A join is performed between 'races' and 'circuits' on the circuit identifier to link races to their respective circuits.", "Conditions are added to filter the results based on the specified country of the circuit and the year of the race using placeholders for string and numeric values."], "gold_sql": "SELECT DISTINCT T1.name FROM races AS T1 JOIN circuits AS T2 ON T1.circuitid = T2.circuitid WHERE T2.country = 'Spain' AND T1.year > 2000", "source_tables": ["races", "circuits"], "description": "The virtual table provides a list of unique race names from the 'races' table that are held at circuits located in a specific country. The query filters the results based on the country of the circuit and the year of the race, allowing users to specify both criteria using placeholders.", "virtual_table": "SELECT DISTINCT T1.name FROM races AS T1 JOIN circuits AS T2 ON T1.circuitid = T2.circuitid WHERE T2.country = [PLACEHOLDER-TYPE:STRING] AND T1.year > [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2202", "db_id": "formula_1", "question": "What are the different names of all the races in reverse alphabetical order?", "rationale": ["The query is identifying the relevant table, which is 'races'.", "Select the column to display, 'name', ensuring that only distinct values are retrieved.", "Order the results by the 'name' column in descending order to present the race names from Z to A."], "gold_sql": "SELECT DISTINCT name FROM races ORDER BY name DESC", "source_tables": ["races"], "description": "This virtual table provides a list of unique race names from the 'races' table, sorted in descending order. The placeholder in the SELECT statement allows for the retrieval of distinct race names without any specific filtering criteria.", "virtual_table": "SELECT DISTINCT name FROM races ORDER BY name DESC"}
{"sample_id": "train.2219", "db_id": "formula_1", "question": "What is the average fastest lap speed in race named 'Monaco Grand Prix' in 2008 ?", "rationale": ["The query identifies the relevant tables, which are 'races' and 'results'.", "It selects the average of the 'fastestLapSpeed' from the 'results' table.", "A JOIN is performed between 'races' and 'results' on the 'raceId' to correlate race data with results.", "Conditions are added to filter the results based on the specified year and race name using placeholders for numeric and string values."], "gold_sql": "SELECT avg(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "description": "This virtual table calculates the average fastest lap speed of drivers from the 'results' table for races that occurred in a specific year and with a specific race name. The placeholders in the WHERE clause represent the year of the race and the name of the race.", "virtual_table": "SELECT avg(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T1.name = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2167", "db_id": "formula_1", "question": "What is the id and family name of the driver who has the longest laptime?", "rationale": ["The query identifies the relevant tables, which are 'drivers' and 'lapTimes'.", "It selects the 'driverId' and 'surname' from the 'drivers' table.", "A JOIN operation is performed between 'drivers' and 'lapTimes' on the 'driverId' to combine relevant data.", "The results are ordered by the 'milliseconds' column from the 'lapTimes' table in descending order to show the fastest lap times first.", "The LIMIT clause is included to allow the user to specify how many results they want to retrieve."], "gold_sql": "SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT 1", "source_tables": ["laptimes", "drivers"], "description": "The virtual table provides a list of drivers along with their surnames, sorted by their lap times in descending order. The placeholder in the LIMIT clause allows the user to specify the number of top results to retrieve.", "virtual_table": "SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2168", "db_id": "formula_1", "question": "What is the id and last name of the driver with the longest laptime?", "rationale": ["The query identifies the relevant tables, which are 'drivers' and 'lapTimes'.", "It selects the 'driverId' and 'surname' from the 'drivers' table.", "A JOIN operation is performed between 'drivers' and 'lapTimes' on the 'driverId' to associate drivers with their lap times.", "The results are ordered by the 'milliseconds' column from the 'lapTimes' table in descending order to show the fastest lap times first.", "The LIMIT clause includes a placeholder for the user to specify how many results they want to retrieve."], "gold_sql": "SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT 1", "source_tables": ["laptimes", "drivers"], "description": "The virtual table provides a list of drivers along with their surnames, sorted by their lap times in descending order. The placeholder in the LIMIT clause allows the user to specify the number of results to return.", "virtual_table": "SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6027", "db_id": "game_1", "question": "Show all male student ids who don't play football.", "rationale": ["The query is identifying the relevant table, which is 'Student'.", "Select the column to display, 'StuID', which is the unique identifier for each student.", "Add a condition to filter the 'sex' column for the specified gender using a placeholder for string values.", "Use the EXCEPT clause to exclude students who are participating in a specific sport, filtering the 'SportsInfo' table by 'sportname' with a placeholder for string values."], "gold_sql": "SELECT StuID FROM Student WHERE sex  =  'M' EXCEPT SELECT StuID FROM Sportsinfo WHERE sportname  =  'Football'", "source_tables": ["sportsinfo", "student"], "description": "This virtual table identifies students from the 'Student' table who are of a specific gender and are not participating in a specified sport. The placeholders in the WHERE clause represent the gender of the students and the name of the sport they are not involved in.", "virtual_table": "SELECT StuID FROM Student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT StuID FROM Sportsinfo WHERE sportname  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6017", "db_id": "game_1", "question": "What is the first name and last name of the student who have most number of sports?", "rationale": ["The query identifies the relevant tables, 'SportsInfo' and 'Student'.", "It selects the 'Fname' and 'Lname' columns from the 'Student' table.", "A JOIN operation is performed between 'SportsInfo' and 'Student' on the 'StuID' column to link students with their sports participation.", "The results are grouped by 'StuID' to aggregate the data for each student.", "The results are ordered by the count of sports participation in descending order to show the most active students first.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T2.Fname ,  T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID GROUP BY T1.StuID ORDER BY count(*) DESC LIMIT 1", "source_tables": ["sportsinfo", "student"], "description": "The virtual table provides a list of first and last names of students who are involved in sports, along with the count of their participation. The placeholder in the LIMIT clause represents the maximum number of students to be displayed based on their sports involvement.", "virtual_table": "SELECT T2.Fname ,  T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID GROUP BY T1.StuID ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6013", "db_id": "game_1", "question": "Show all student IDs with the number of sports and total number of games played", "rationale": ["The query identifies the relevant table, which is 'SportsInfo'.", "It selects the 'StuID' to uniquely identify each student.", "The query uses the count function to determine the number of sports each student is involved in, and the sum function to calculate the total games played by each student.", "The GROUP BY clause is used to aggregate the results by 'StuID', ensuring that the counts and sums are calculated for each individual student."], "gold_sql": "SELECT StuID ,  count(*) ,  sum(gamesplayed) FROM Sportsinfo GROUP BY StuID", "source_tables": ["sportsinfo"], "description": "This virtual table summarizes the participation of students in sports by displaying their unique identifiers, the total number of sports they are involved in, and the cumulative number of games they have played. The placeholder in the SELECT clause allows for the selection of specific student identifiers, while the aggregation functions count and sum provide insights into their sports activities.", "virtual_table": "SELECT StuID ,  count(*) ,  sum(gamesplayed) FROM Sportsinfo GROUP BY StuID"}
{"sample_id": "train.5998", "db_id": "game_1", "question": "What are the advisors", "rationale": ["The query identifies the relevant table, which is 'Student'.", "It selects the 'advisor' column to display.", "The GROUP BY clause is used to group the results by the 'advisor' column.", "The HAVING clause filters the groups to include only those advisors who have a count of students greater than or equal to a specified number, using a placeholder for numeric values."], "gold_sql": "SELECT advisor FROM Student GROUP BY advisor HAVING count(*)  >=  2", "source_tables": ["student"], "description": "This virtual table provides a list of academic advisors from the 'Student' table who have a minimum number of students assigned to them. The placeholder in the HAVING clause represents the minimum count of students required for an advisor to be included in the results.", "virtual_table": "SELECT advisor FROM Student GROUP BY advisor HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6018", "db_id": "game_1", "question": "What is the first and last name of the student who played the most sports?", "rationale": ["The query identifies the relevant tables, 'SportsInfo' and 'Student'.", "It selects the 'Fname' and 'Lname' columns from the 'Student' table.", "A JOIN operation is performed on 'SportsInfo' and 'Student' using the 'StuID' to link the two tables.", "The results are grouped by 'StuID' to aggregate the data for each student.", "The results are ordered by the count of games played in descending order to prioritize students with the most participation.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T2.Fname ,  T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID GROUP BY T1.StuID ORDER BY count(*) DESC LIMIT 1", "source_tables": ["sportsinfo", "student"], "description": "The virtual table provides a list of first and last names of students who are involved in sports, along with the count of their participation. The placeholder in the LIMIT clause represents the maximum number of students to be displayed based on their sports involvement.", "virtual_table": "SELECT T2.Fname ,  T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID GROUP BY T1.StuID ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6023", "db_id": "game_1", "question": "Show student ids who are on scholarship and have major 600.", "rationale": ["The query is identifying the relevant tables, which are 'Student' and 'SportsInfo'.", "Select the 'StuID' from the 'Student' table where the major matches a specified value using a placeholder for numeric values.", "Use the INTERSECT operator to find students who also appear in the 'SportsInfo' table where the 'OnScholarship' status matches a specified value using a placeholder for string values."], "gold_sql": "SELECT StuID FROM Student WHERE major  =  600 INTERSECT SELECT StuID FROM Sportsinfo WHERE onscholarship  =  'Y'", "source_tables": ["sportsinfo", "student"], "description": "This virtual table identifies students who are majoring in a specific field of study and are also participating in sports while being on a scholarship. The placeholders in the WHERE clauses represent the major and scholarship status of the students.", "virtual_table": "SELECT StuID FROM Student WHERE major  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT StuID FROM Sportsinfo WHERE onscholarship  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6029", "db_id": "game_1", "question": "Show total hours per week and number of games played for student David Shieber.", "rationale": ["The query identifies the relevant tables, which are 'SportsInfo' and 'Student'.", "It selects the sum of 'HoursPerWeek' and 'GamesPlayed' from the 'SportsInfo' table.", "A JOIN operation is performed on 'StuID' to combine data from 'SportsInfo' and 'Student'.", "Conditions are added to filter the results based on the specified first and last names using placeholders for string values."], "gold_sql": "SELECT sum(hoursperweek) ,  sum(gamesplayed) FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.Fname  =  'David' AND T2.Lname  =  'Shieber'", "source_tables": ["sportsinfo", "student"], "description": "This virtual table summarizes the total hours per week and total games played by students who have a specific first and last name. The placeholders in the WHERE clause represent the first and last names of the student.", "virtual_table": "SELECT sum(hoursperweek) ,  sum(gamesplayed) FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.Fname  =  [PLACEHOLDER-TYPE:STRING] AND T2.Lname  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5986", "db_id": "game_1", "question": "What type has the most games?", "rationale": ["The query identifies the relevant table, which is 'Video_Games'.", "It selects the 'GType' column to display the genre of the video games.", "The GROUP BY clause is used to group the results by 'GType' to aggregate the data based on the genre.", "The ORDER BY clause sorts the genres by their count in descending order to show the most popular genres first.", "The LIMIT clause uses a placeholder to allow users to specify the number of top genres they want to retrieve."], "gold_sql": "SELECT gtype FROM Video_games GROUP BY gtype ORDER BY count(*) DESC LIMIT 1", "source_tables": ["video_games"], "description": "This virtual table summarizes the types of video games from the 'Video_Games' table, grouped by their genre. The placeholder in the LIMIT clause represents the maximum number of genres to be displayed, allowing users to specify how many top genres they want to retrieve based on their popularity.", "virtual_table": "SELECT gtype FROM Video_games GROUP BY gtype ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6009", "db_id": "game_1", "question": "How many games are played for all football games by students on scholarship?", "rationale": ["The query identifies the relevant table, which is 'SportsInfo'.", "It selects the sum of the 'GamesPlayed' column to get the total number of games played.", "Conditions are added to filter the results based on the specified 'SportName' and whether the student is 'OnScholarship', using placeholders for string values."], "gold_sql": "SELECT sum(gamesplayed) FROM Sportsinfo WHERE sportname  =  'Football' AND onscholarship  =  'Y'", "source_tables": ["sportsinfo"], "description": "This virtual table summarizes the total number of games played by students involved in a specific sport and who are on a sports scholarship. The placeholders in the WHERE clause represent the sport's name and the scholarship status.", "virtual_table": "SELECT sum(gamesplayed) FROM Sportsinfo WHERE sportname  =  [PLACEHOLDER-TYPE:STRING] AND onscholarship  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6031", "db_id": "game_1", "question": "Show total hours per week and number of games played for students under 20.", "rationale": ["The query identifies the relevant tables, which are 'SportsInfo' and 'Student'.", "It selects the sum of 'HoursPerWeek' and 'GamesPlayed' from the 'SportsInfo' table.", "A JOIN operation is performed on 'StuID' to combine data from 'SportsInfo' and 'Student'.", "A condition is added to filter students based on their age using a placeholder for numeric values."], "gold_sql": "SELECT sum(hoursperweek) ,  sum(gamesplayed) FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.age  <  20", "source_tables": ["sportsinfo", "student"], "description": "The virtual table summarizes the total hours per week dedicated to sports and the total number of games played by students from the 'SportsInfo' table who are younger than a specified age. The placeholders in the WHERE clause represent the age limit for filtering the students.", "virtual_table": "SELECT sum(hoursperweek) ,  sum(gamesplayed) FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.age  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5982", "db_id": "game_1", "question": "Count the number of video games with Massively multiplayer online game type .", "rationale": ["The query is identifying the relevant table, which is 'Video_Games'.", "The goal is to count the number of games, hence using the count(*) function.", "Add a condition to filter the 'GType' column for the specified genre using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM Video_games WHERE gtype  =  'Massively multiplayer online game'", "source_tables": ["video_games"], "description": "This virtual table provides the count of video games from the 'Video_Games' table that belong to a specific genre. The placeholder in the WHERE clause represents the type of the video game.", "virtual_table": "SELECT count(*) FROM Video_games WHERE gtype  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5978", "db_id": "game_1", "question": "What are the names of all video games that are collectible cards?", "rationale": ["The query is identifying the relevant table, which is 'Video_Games'.", "Select the column to display, 'GName'.", "Add a condition to filter the 'GType' column for the specified genre using a placeholder for string values."], "gold_sql": "SELECT gname FROM Video_games WHERE gtype  =  'Collectible card game'", "source_tables": ["video_games"], "description": "The virtual table provides a list of video game names from the 'Video_Games' table that belong to a specific genre. The placeholder in the WHERE clause represents the type of the video game.", "virtual_table": "SELECT gname FROM Video_games WHERE gtype  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5977", "db_id": "game_1", "question": "Show all video games with type Collectible card game.", "rationale": ["The query is identifying the relevant table, which is 'Video_Games'.", "Select the column to display, 'GName'.", "Add a condition to filter the 'GType' column for the specified genre using a placeholder for string values."], "gold_sql": "SELECT gname FROM Video_games WHERE gtype  =  'Collectible card game'", "source_tables": ["video_games"], "description": "This virtual table provides the names of video games from the 'Video_Games' table that belong to a specific genre. The placeholder in the WHERE clause represents the type of the video game.", "virtual_table": "SELECT gname FROM Video_games WHERE gtype  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6005", "db_id": "game_1", "question": "Show last names for all student who are on scholarship.", "rationale": ["The query identifies the relevant tables, which are 'SportsInfo' and 'Student'.", "It selects the 'Lname' column from the 'Student' table.", "A JOIN operation is performed between 'SportsInfo' and 'Student' on the 'StuID' column to link students with their sports participation.", "A condition is added to filter the results based on the 'OnScholarship' column from the 'SportsInfo' table using a placeholder for string values."], "gold_sql": "SELECT T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T1.onscholarship  =  'Y'", "source_tables": ["sportsinfo", "student"], "description": "This virtual table provides the last names of students from the 'Student' table who are participating in sports and are on a sports scholarship. The placeholder in the WHERE clause represents the scholarship status, indicating whether the student is on a scholarship or not.", "virtual_table": "SELECT T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T1.onscholarship  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3985", "db_id": "hospital_1", "question": "What procedures cost less than 5000 and have John Wen as a trained physician?", "rationale": ["The query identifies the relevant table, which is 'procedures', to select the names of procedures based on their cost.", "It uses a subquery to find physicians who are trained in specific procedures by joining the 'physician' and 'trained_in' tables.", "The intersection of the two queries ensures that only procedures that are both under the specified cost and are associated with the specified physician are returned."], "gold_sql": "SELECT name FROM procedures WHERE cost  <  5000 INTERSECT SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  'John Wen'", "source_tables": ["procedures", "physician", "trained_in"], "description": "The virtual table provides a list of medical procedures that are less expensive than a specified cost, along with the names of physicians who are trained in those procedures. The placeholders represent the cost limit and the physician's name for filtering the results.", "virtual_table": "SELECT name FROM procedures WHERE cost  <  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3931", "db_id": "hospital_1", "question": "Which physicians are in charge of more than one patient? Give me their names.", "rationale": ["The query identifies the relevant tables, which are 'Physician' and 'Patient'.", "It selects the 'name' column from the 'Physician' table.", "A JOIN operation is performed between 'Physician' and 'Patient' on the condition that the physician's EmployeeID matches the patient's PCP identifier.", "The results are grouped by the physician's EmployeeID to aggregate the patient counts.", "The HAVING clause filters the results to include only those physicians who have more than a specified number of patients, using a placeholder for the numeric value."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  1", "source_tables": ["physician", "patient"], "description": "The virtual table lists the names of physicians who are primary care providers (PCP) for patients, filtered to show only those physicians who have a certain number of patients assigned to them. The placeholder in the HAVING clause represents the minimum number of patients a physician must have to be included in the results.", "virtual_table": "SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3934", "db_id": "hospital_1", "question": "Find the number of rooms for different block code?", "rationale": ["The query identifies the relevant tables, which are 'Block' and 'Room'.", "It selects the count of rooms and the block code from the 'Block' table.", "A JOIN operation is performed on the 'Block' and 'Room' tables based on matching block floor and block code values.", "The results are grouped by the block code to provide a count of rooms for each unique block code."], "gold_sql": "SELECT count(*) ,  T1.blockcode FROM BLOCK AS T1 JOIN room AS T2 ON T1.blockfloor  =  T2.blockfloor AND T1.blockcode  =  T2.blockcode GROUP BY T1.blockcode", "source_tables": ["block", "room"], "description": "The virtual table summarizes the count of rooms grouped by their block code status from the 'Block' and 'Room' tables. The placeholders represent the block floor and block code statuses used for filtering the results.", "virtual_table": "SELECT count(*) ,  T1.blockcode FROM BLOCK AS T1 JOIN room AS T2 ON T1.blockfloor  =  T2.blockfloor AND T1.blockcode  =  T2.blockcode GROUP BY T1.blockcode"}
{"sample_id": "train.3915", "db_id": "hospital_1", "question": "What are the name and primarily affiliated department name of each physician?", "rationale": ["The query identifies the relevant tables: 'Physician', 'Affiliated_With', and 'Department'.", "It selects the 'name' column from the 'Physician' table and the 'name' column from the 'Department' table.", "The JOIN operations link the tables based on the physician's identifier and the department's identifier.", "A condition is added to filter the results based on whether the affiliation is primary, using a placeholder for numeric values."], "gold_sql": "SELECT T1.name ,  T3.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T2.PrimaryAffiliation  =  1", "source_tables": ["physician", "department", "affiliated_with"], "description": "The virtual table provides a list of physician names along with their affiliated department names from the 'Physician', 'Affiliated_With', and 'Department' tables. The placeholder in the WHERE clause indicates whether the affiliation is the primary one, represented by a numeric value.", "virtual_table": "SELECT T1.name ,  T3.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T2.PrimaryAffiliation  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3961", "db_id": "hospital_1", "question": "What are each physician's employee id and department id primarily affiliated.", "rationale": ["The query identifies the relevant table, which is 'Affiliated_With'.", "Select the columns to display, 'physician' and 'department'.", "Add a condition to filter the 'primaryaffiliation' column for the specified status using a placeholder for numeric values."], "gold_sql": "SELECT physician ,  department FROM affiliated_with WHERE primaryaffiliation  =  1", "source_tables": ["affiliated_with"], "description": "This virtual table provides a list of physicians along with their associated departments from the 'Affiliated_With' table, filtered by whether the affiliation is marked as primary. The placeholder in the WHERE clause indicates the primary affiliation status.", "virtual_table": "SELECT physician ,  department FROM affiliated_with WHERE primaryaffiliation  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3929", "db_id": "hospital_1", "question": "Return the name of each physician and the number of patients he or she treats.", "rationale": ["The query identifies the relevant tables, which are 'Physician' and 'Patient'.", "It selects the physician's name from the 'Physician' table and counts the number of patients from the 'Patient' table.", "A JOIN operation is performed on the 'EmployeeID' from the 'Physician' table and the 'PCP' from the 'Patient' table to associate patients with their primary care physician.", "The results are grouped by the physician's employee ID to aggregate the patient counts accordingly."], "gold_sql": "SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid", "source_tables": ["physician", "patient"], "description": "This virtual table provides a summary of the number of patients assigned to each physician, identified by their unique employee ID. The placeholder in the SELECT statement allows for the retrieval of the physician's name and the count of patients associated with them.", "virtual_table": "SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid"}
{"sample_id": "train.3981", "db_id": "hospital_1", "question": "What are the procedures that cost more than 1000 or are specialized in by physician John Wen?", "rationale": ["The query identifies the relevant tables: 'Procedures', 'Physician', and 'Trained_In'.", "The first part of the query selects procedure names from the 'Procedures' table where the cost exceeds a specified number using a placeholder for numeric values.", "The second part of the query uses a JOIN to connect 'Physician' and 'Trained_In' tables to find procedures that a specific physician is trained in, filtering by the physician's name with a placeholder for string values.", "The UNION operator combines the results of both queries into a single result set."], "gold_sql": "SELECT name FROM procedures WHERE cost  >  1000 UNION SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  'John Wen'", "source_tables": ["procedures", "physician", "trained_in"], "description": "The virtual table provides a list of medical procedures that either exceed a specified cost or are associated with a specific physician's training. The first part of the query retrieves procedure names based on their cost, while the second part retrieves procedure names linked to a physician's training, filtered by the physician's name.", "virtual_table": "SELECT name FROM procedures WHERE cost  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3945", "db_id": "hospital_1", "question": "How many medications are prescribed for each brand?", "rationale": ["The query identifies the relevant tables, which are 'medication' and 'prescribes'.", "It selects the count of prescriptions and the brand name from the 'medication' table.", "A JOIN operation is performed between 'medication' and 'prescribes' on the medication code to link the two tables.", "The results are grouped by the brand name of the medication to provide a summary count for each brand."], "gold_sql": "SELECT count(*) ,  T1.name FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand", "source_tables": ["prescribes", "medication"], "description": "This virtual table summarizes the count of prescribed medications grouped by their brand names. It combines data from the 'medication' table, which contains details about each medication, and the 'prescribes' table, which records the prescriptions made by physicians. The placeholder in the SELECT statement represents the count of prescriptions, while the grouping is done based on the brand of the medication.", "virtual_table": "SELECT count(*) ,  T1.name FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand"}
{"sample_id": "train.3964", "db_id": "hospital_1", "question": "What nurses are on call with block floor 1 and block code 1? Tell me their names.", "rationale": ["The query identifies the relevant table, which is 'On_Call'.", "Select the column to display, 'Nurse'.", "Add conditions to filter the 'BlockFloor' and 'BlockCode' columns using placeholders for numeric values."], "gold_sql": "SELECT nurse FROM on_call WHERE blockfloor  =  1 AND blockcode  =  1", "source_tables": ["on_call"], "description": "This virtual table provides information about nurses who are on call, filtered by the status of blocked floors and blocked codes. The placeholders in the WHERE clause represent the identifiers for the blocked floor and blocked code statuses.", "virtual_table": "SELECT nurse FROM on_call WHERE blockfloor  =  [PLACEHOLDER-TYPE:NUMBER] AND blockcode  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3962", "db_id": "hospital_1", "question": "List the names of departments where some physicians are primarily affiliated with.", "rationale": ["The query identifies the relevant tables, which are 'Affiliated_With' and 'Department'.", "It selects distinct department names from the 'Department' table.", "A JOIN operation is performed between 'Affiliated_With' and 'Department' on the department identifier.", "A condition is added to filter the results based on the primary affiliation status using a placeholder for numeric values."], "gold_sql": "SELECT DISTINCT T2.name FROM affiliated_with AS T1 JOIN department AS T2 ON T1.department = T2.departmentid WHERE PrimaryAffiliation  =  1", "source_tables": ["department", "affiliated_with"], "description": "The virtual table provides a list of distinct department names from the 'Department' table that are associated with physicians based on their primary affiliation. The placeholder in the WHERE clause indicates whether the affiliation is primary or not.", "virtual_table": "SELECT DISTINCT T2.name FROM affiliated_with AS T1 JOIN department AS T2 ON T1.department = T2.departmentid WHERE PrimaryAffiliation  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3900", "db_id": "hospital_1", "question": "What is the employee id of the head whose department has the least number of employees?", "rationale": ["The query identifies the relevant table, which is 'Department'.", "It selects the 'head' column to display the heads of the departments.", "The query groups the results by 'DepartmentID' to ensure unique department heads are listed.", "The ORDER BY clause is used to sort the results based on the count of department IDs, which helps in organizing the output.", "The LIMIT clause includes a placeholder for the user to specify how many department heads they want to retrieve."], "gold_sql": "SELECT head FROM department GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["department"], "description": "This virtual table provides a list of department heads from the 'Department' table, grouped by department ID. The placeholder in the LIMIT clause allows the user to specify the maximum number of department heads to retrieve.", "virtual_table": "SELECT head FROM department GROUP BY departmentID ORDER BY count(departmentID) LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3963", "db_id": "hospital_1", "question": "What are the names of departments that have primarily affiliated physicians.", "rationale": ["The query identifies the relevant tables, which are 'Affiliated_With' and 'Department'.", "It selects distinct department names from the 'Department' table.", "A JOIN operation is performed between 'Affiliated_With' and 'Department' on the department identifier.", "A condition is added to filter the results based on the primary affiliation status using a placeholder for numeric values."], "gold_sql": "SELECT DISTINCT T2.name FROM affiliated_with AS T1 JOIN department AS T2 ON T1.department = T2.departmentid WHERE PrimaryAffiliation  =  1", "source_tables": ["department", "affiliated_with"], "description": "The virtual table provides a list of distinct department names from the 'Department' table that are associated with physicians based on their primary affiliation. The placeholder in the WHERE clause indicates whether the affiliation is primary or not.", "virtual_table": "SELECT DISTINCT T2.name FROM affiliated_with AS T1 JOIN department AS T2 ON T1.department = T2.departmentid WHERE PrimaryAffiliation  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3924", "db_id": "hospital_1", "question": "Find the patient who most recently stayed in room 111.", "rationale": ["The query identifies the relevant table, which is 'Stay'.", "Select the 'patient' column to display the patients staying in the specified room.", "Add a condition to filter the 'room' column for the specified room number using a placeholder for numeric values.", "Order the results by 'StayStart' in descending order to show the most recent stays first.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT patient FROM stay WHERE room  =  111 ORDER BY staystart DESC LIMIT 1", "source_tables": ["stay"], "description": "This virtual table provides a list of patients currently staying in a specific room within the hospital. The placeholder in the WHERE clause represents the room number, while the LIMIT placeholder allows for specifying the maximum number of patients to retrieve, sorted by the start date of their stay in descending order.", "virtual_table": "SELECT patient FROM stay WHERE room  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY staystart DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3905", "db_id": "hospital_1", "question": "List the names of patients who have made appointments.", "rationale": ["The query identifies the relevant tables, which are 'Appointment' and 'Patient'.", "It selects the 'name' column from the 'Patient' table.", "A JOIN operation is performed to connect the 'Appointment' table with the 'Patient' table using the common key, which is the patient's Social Security Number (SSN)."], "gold_sql": "SELECT name FROM appointment AS T1 JOIN patient AS T2 ON T1.patient  =  T2.ssn", "source_tables": ["patient", "appointment"], "description": "The virtual table provides a list of patient names associated with their appointments. It combines data from the 'Appointment' table and the 'Patient' table, linking them through the patient's Social Security Number. This allows for the retrieval of patient names based on their scheduled appointments.", "virtual_table": "SELECT name FROM appointment AS T1 JOIN patient AS T2 ON T1.patient  =  T2.ssn"}
{"sample_id": "train.3973", "db_id": "hospital_1", "question": "Which physicians are trained in procedures that are more expensive than 5000?", "rationale": ["The query identifies the relevant tables: 'Physician', 'Trained_In', and 'Procedures'.", "It selects the 'name' column from the 'Physician' table.", "The query joins 'Physician' with 'Trained_In' on the physician's identifier to link physicians with their training.", "It further joins 'Trained_In' with 'Procedures' on the procedure code to access procedure details.", "A condition is added to filter procedures based on their cost, using a placeholder for numeric values."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  5000", "source_tables": ["physician", "procedures", "trained_in"], "description": "This virtual table provides the names of physicians who are trained in specific medical procedures that have a cost exceeding a specified amount. The placeholders in the WHERE clause represent the cost threshold for filtering the procedures.", "virtual_table": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3910", "db_id": "hospital_1", "question": "List the name of physicians who took some appointment.", "rationale": ["The query identifies the relevant tables, which are 'Appointment' and 'Physician'.", "It selects the 'Name' column from the 'Physician' table, which contains the names of the physicians.", "The JOIN operation connects the 'Appointment' table with the 'Physician' table using the 'Physician' identifier, ensuring that only the names of physicians conducting the appointments are retrieved."], "gold_sql": "SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID", "source_tables": ["physician", "appointment"], "description": "The virtual table provides the names of physicians associated with specific appointments. It combines data from the 'Appointment' table and the 'Physician' table, linking them through the physician's unique identifier. This allows users to see which physician is conducting each appointment.", "virtual_table": "SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID"}
{"sample_id": "train.3970", "db_id": "hospital_1", "question": "Find the three most expensive procedures.", "rationale": ["The query identifies the relevant table, which is 'Procedures'.", "Select the column to display, 'name', which represents the name of the medical procedures.", "Order the results by the 'cost' column to sort the procedures based on their costs.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT name FROM procedures ORDER BY cost LIMIT 3", "source_tables": ["procedures"], "description": "The virtual table provides a list of medical procedures from the 'Procedures' table, ordered by their associated costs. The placeholder in the LIMIT clause allows the user to specify the maximum number of procedures to retrieve.", "virtual_table": "SELECT name FROM procedures ORDER BY cost LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3911", "db_id": "hospital_1", "question": "What are the names of all the physicians who took appointments.", "rationale": ["The query identifies the relevant tables, which are 'Appointment' and 'Physician'.", "It selects the 'Name' column from the 'Physician' table to display the names of physicians.", "A JOIN operation is performed between the 'Appointment' table and the 'Physician' table using the 'Physician' identifier to link the two tables."], "gold_sql": "SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID", "source_tables": ["physician", "appointment"], "description": "The virtual table provides the names of physicians associated with specific appointments. It combines data from the 'Appointment' table and the 'Physician' table, linking them through the physician's unique identifier. The placeholder in the JOIN clause represents the physician's identifier used to match records between the two tables.", "virtual_table": "SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID"}
{"sample_id": "train.3958", "db_id": "hospital_1", "question": "What are the names of the physician who prescribed the highest dose?", "rationale": ["The query identifies the relevant tables, which are 'Physician' and 'Prescribes'.", "It selects the 'name' column from the 'Physician' table, aliased as T1.", "A JOIN operation is performed between 'Physician' (T1) and 'Prescribes' (T2) on the condition that the 'EmployeeID' from 'Physician' matches the 'Physician' identifier in 'Prescribes'.", "The results are ordered by the 'dose' column from the 'Prescribes' table in descending order to show the highest doses first.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT 1", "source_tables": ["physician", "prescribes"], "description": "This virtual table provides a list of physician names from the 'Physician' table who have prescribed medications, ordered by the dosage of the medications in descending order. The placeholder in the LIMIT clause represents the maximum number of physician names to return.", "virtual_table": "SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3516", "db_id": "hr_1", "question": "What are the department ids, full names, and salaries for employees who make the most in their departments?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Select the columns to display: 'first_name', 'last_name', 'salary', and 'department_id'.", "Include an aggregate function to find the maximum salary for each department using GROUP BY on 'department_id' to group the results accordingly."], "gold_sql": "SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id", "source_tables": ["employees"], "description": "This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause allows for the inclusion of the maximum salary within each department, providing insights into salary distribution across different departments.", "virtual_table": "SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id"}
{"sample_id": "train.3458", "db_id": "hr_1", "question": "What are the job ids for jobs done more than once for a period of more than 300 days?", "rationale": ["The query identifies the relevant table, which is 'job_history'.", "It selects the 'job_id' column to display the job identifiers.", "A condition is added to filter the records where the difference between 'end_date' and 'start_date' exceeds a specified number of days using a placeholder for numeric values.", "The results are grouped by 'job_id' to aggregate the data.", "A HAVING clause is included to filter the groups to only those with a count of occurrences greater than or equal to a specified number, using another placeholder for numeric values."], "gold_sql": "SELECT job_id FROM job_history WHERE end_date - start_date  > 300 GROUP BY job_id HAVING COUNT(*) >= 2", "source_tables": ["job_history"], "description": "This virtual table provides a list of job identifiers from the 'job_history' table where the duration of each job (calculated as the difference between the end date and start date) exceeds a specified number of days. Additionally, it groups the results by job identifier and filters to include only those jobs that have been held by employees for a specified minimum number of occurrences.", "virtual_table": "SELECT job_id FROM job_history WHERE end_date - start_date  > [PLACEHOLDER-TYPE:NUMBER] GROUP BY job_id HAVING COUNT(*) >= [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3473", "db_id": "hr_1", "question": "Find the first name and last name and department id for those employees who earn such amount of salary which is the smallest salary of any of the departments.", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Select the columns to display: 'first_name', 'last_name', and 'department_id'.", "Add a condition to filter employees whose salaries are in a subquery that selects the minimum salary from the 'employees' table, grouped by 'department_id'."], "gold_sql": "SELECT first_name ,  last_name ,  department_id FROM employees WHERE salary IN (SELECT MIN(salary) FROM employees GROUP BY department_id)", "source_tables": ["employees"], "description": "This virtual table provides the first and last names of employees along with their department identifiers from the 'employees' table. It specifically filters for employees whose salaries are equal to the minimum salary within their respective departments. The placeholder in the WHERE clause represents the salary criteria derived from a subquery that calculates the minimum salary for each department.", "virtual_table": "SELECT first_name ,  last_name ,  department_id FROM employees WHERE salary IN (SELECT MIN(salary) FROM employees GROUP BY department_id)"}
{"sample_id": "train.3509", "db_id": "hr_1", "question": "display the employee number, name( first name and last name ) and job title for all employees whose salary is more than any salary of those employees whose job title is PU_MAN.", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Select the columns to display: 'employee_id', 'first_name', 'last_name', and 'job_id'.", "Add a condition to filter employees based on their salary being greater than the maximum salary for a specific job, using a subquery with a placeholder for the job identifier."], "gold_sql": "SELECT employee_id ,  first_name ,  last_name ,  job_id FROM employees WHERE salary  >  ( SELECT max(salary) FROM employees WHERE job_id  =  'PU_MAN' )", "source_tables": ["employees"], "description": "This virtual table provides a list of employees, including their unique identifiers, first names, last names, and job identifiers, from the 'employees' table. The results are filtered to show only those employees whose salaries exceed the maximum salary for a specified job, represented by a placeholder in the subquery.", "virtual_table": "SELECT employee_id ,  first_name ,  last_name ,  job_id FROM employees WHERE salary  >  ( SELECT max(salary) FROM employees WHERE job_id  =  [PLACEHOLDER-TYPE:STRING] )"}
{"sample_id": "train.3417", "db_id": "hr_1", "question": "display the full name (first and last), hire date, salary, and department number for those employees whose first name does not containing the letter M.", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Select the columns to display: 'first_name', 'last_name', 'hire_date', 'salary', and 'department_id'.", "Add a condition to filter out employees based on their first name using a placeholder for string values."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%'", "source_tables": ["employees"], "description": "This virtual table provides a list of employees, including their first name, last name, hire date, salary, and department ID, from the 'employees' table. The placeholder in the WHERE clause allows for filtering out employees whose first name matches a specific pattern.", "virtual_table": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3504", "db_id": "hr_1", "question": "What are the ids and full names for employees who work in a department that has someone with a first name that contains the letter T?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Select the columns to display: 'employee_id', 'first_name', and 'last_name'.", "Add a condition to filter the 'department_id' using a subquery that checks for employees with a specified first name, using a placeholder for string values."], "gold_sql": "SELECT employee_id ,  first_name ,  last_name FROM employees WHERE department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE '%T%' )", "source_tables": ["employees"], "description": "This virtual table provides a list of employee IDs, first names, and last names from the 'employees' table for those employees who belong to the same department as an employee with a specified first name. The placeholder in the subquery represents the first name of the employee being searched for.", "virtual_table": "SELECT employee_id ,  first_name ,  last_name FROM employees WHERE department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE [PLACEHOLDER-TYPE:STRING] )"}
{"sample_id": "train.3510", "db_id": "hr_1", "question": "What are the employee ids, full names, and job ids for employees who make more than the highest earning employee with title PU_MAN?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Select the columns to display: 'employee_id', 'first_name', 'last_name', and 'job_id'.", "Add a condition to filter employees based on their salary being greater than the maximum salary for a specified job using a subquery.", "The subquery selects the maximum salary from the 'employees' table where the job identifier matches the placeholder."], "gold_sql": "SELECT employee_id ,  first_name ,  last_name ,  job_id FROM employees WHERE salary  >  ( SELECT max(salary) FROM employees WHERE job_id  =  'PU_MAN' )", "source_tables": ["employees"], "description": "This virtual table provides a list of employees, including their unique identifiers, first names, last names, and job identifiers, specifically for those whose salaries exceed the maximum salary for a specified job. The placeholder in the subquery represents the job identifier for which the maximum salary is being compared.", "virtual_table": "SELECT employee_id ,  first_name ,  last_name ,  job_id FROM employees WHERE salary  >  ( SELECT max(salary) FROM employees WHERE job_id  =  [PLACEHOLDER-TYPE:STRING] )"}
{"sample_id": "train.3449", "db_id": "hr_1", "question": "display those departments where more than ten employees work who got a commission percentage.", "rationale": ["The query identifies the relevant table, which is 'employees'.", "It selects the 'department_id' to group the results by department.", "The HAVING clause filters the groups to include only those departments where the count of employees with a commission percentage exceeds a specified number, using a placeholder for numeric values."], "gold_sql": "SELECT department_id FROM employees GROUP BY department_id HAVING COUNT(commission_pct) > 10", "source_tables": ["employees"], "description": "This virtual table lists the identifiers of departments from the 'employees' table that have more than a specified number of employees receiving commissions. The placeholder in the HAVING clause represents the minimum count of employees with a commission percentage.", "virtual_table": "SELECT department_id FROM employees GROUP BY department_id HAVING COUNT(commission_pct) > [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3474", "db_id": "hr_1", "question": "What are the full names and department ids for the lowest paid employees across all departments.", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Select the columns to display: 'first_name', 'last_name', and 'department_id'.", "Add a condition to filter employees whose salary is in the set of minimum salaries for each department, using a subquery that groups by 'department_id' and selects the minimum salary."], "gold_sql": "SELECT first_name ,  last_name ,  department_id FROM employees WHERE salary IN (SELECT MIN(salary) FROM employees GROUP BY department_id)", "source_tables": ["employees"], "description": "This virtual table provides the first and last names of employees along with their department identifiers from the 'employees' table, specifically focusing on those who earn the minimum salary within their respective departments. The placeholder in the WHERE clause allows for filtering based on the minimum salary criteria derived from a subquery that groups employees by department.", "virtual_table": "SELECT first_name ,  last_name ,  department_id FROM employees WHERE salary IN (SELECT MIN(salary) FROM employees GROUP BY department_id)"}
{"sample_id": "train.3457", "db_id": "hr_1", "question": "display job ID for those jobs that were done by two or more for more than 300 days.", "rationale": ["The query identifies the relevant table, which is 'job_history'.", "It selects the 'job_id' column to display the job identifiers.", "A condition is added to filter the records where the difference between 'end_date' and 'start_date' exceeds a specified number of days using a placeholder for numeric values.", "The results are grouped by 'job_id' to aggregate the data based on job identifiers.", "A HAVING clause is included to filter the grouped results to only include those jobs that have been held a minimum specified number of times, using another placeholder for numeric values."], "gold_sql": "SELECT job_id FROM job_history WHERE end_date - start_date  > 300 GROUP BY job_id HAVING COUNT(*) >= 2", "source_tables": ["job_history"], "description": "This virtual table provides a list of job identifiers from the 'job_history' table where the duration of each job (calculated as the difference between the end date and start date) exceeds a specified number of days. Additionally, it groups the results by job identifier and filters to include only those jobs that have been held by employees for a minimum specified number of times. The placeholders in the query represent the duration in days and the minimum count of occurrences for the jobs.", "virtual_table": "SELECT job_id FROM job_history WHERE end_date - start_date  > [PLACEHOLDER-TYPE:NUMBER] GROUP BY job_id HAVING COUNT(*) >= [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3506", "db_id": "hr_1", "question": "What are the ids, full names, and salaries for employees making more than average and who work in a department with employees who have the letter J in their first name?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Select the columns to display: 'employee_id', 'first_name', 'last_name', and 'salary'.", "Add a condition to filter employees whose salary is greater than the average salary calculated from the 'employees' table.", "Include a subquery to filter departments based on the first name of employees using a placeholder for string values."], "gold_sql": "SELECT employee_id ,  first_name ,  last_name ,  salary FROM employees WHERE salary  >  ( SELECT AVG (salary) FROM employees ) AND department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE '%J%')", "source_tables": ["employees"], "description": "This virtual table provides a list of employees, including their unique identifiers, first names, last names, and salaries, from the 'employees' table. It filters the results to show only those employees whose salaries are above the average salary of all employees and belong to departments where the first name of at least one employee matches a specified pattern.", "virtual_table": "SELECT employee_id ,  first_name ,  last_name ,  salary FROM employees WHERE salary  >  ( SELECT AVG (salary) FROM employees ) AND department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.3451", "db_id": "hr_1", "question": "Find the ids of the departments where any manager is managing 4 or more employees.", "rationale": ["The query identifies the relevant table, which is 'employees'.", "It selects distinct department identifiers to ensure uniqueness.", "The results are grouped by both 'department_id' and 'manager_id' to organize the data accordingly.", "A condition is applied using the HAVING clause to filter departments that have a count of employees greater than or equal to a specified number, using a placeholder for numeric values."], "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"], "description": "This virtual table provides a list of unique department identifiers from the 'employees' table. It groups the results by both department and manager identifiers, ensuring that only departments with a specified minimum number of employees are included. The placeholder in the HAVING clause represents the minimum count of employees required for a department to be listed.", "virtual_table": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3428", "db_id": "hr_1", "question": "Return the full names and salaries for employees with first names that end with the letter m.", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Select the columns to display: 'first_name', 'last_name', and 'salary'.", "Add a condition to filter the 'first_name' column using a LIKE operator with a placeholder for string values."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees WHERE first_name LIKE '%m'", "source_tables": ["employees"], "description": "This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who have a first name matching a specific pattern. The placeholder in the WHERE clause allows for flexible searching of employee first names.", "virtual_table": "SELECT first_name ,  last_name ,  salary FROM employees WHERE first_name LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3463", "db_id": "hr_1", "question": "display the department name and number of employees in each of the department.", "rationale": ["The query identifies the relevant tables, which are 'employees' and 'departments'.", "It selects the 'department_name' from the 'departments' table and counts the number of employees from the 'employees' table.", "A JOIN operation is performed on the 'department_id' to link employees to their respective departments.", "The results are grouped by 'department_name' to provide a count of employees in each department."], "gold_sql": "SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name", "source_tables": ["employees", "departments"], "description": "This virtual table summarizes the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT clause represents the department's name, while the COUNT function calculates the total number of employees per department.", "virtual_table": "SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name"}
{"sample_id": "train.3470", "db_id": "hr_1", "question": "Provide the full names of employees earning more than the employee with id 163.", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Select the columns to display, 'first_name' and 'last_name'.", "Add a condition to filter employees based on their salary being greater than the salary of a specific employee.", "The subquery retrieves the salary of the employee specified by the placeholder for numeric values."], "gold_sql": "SELECT first_name ,  last_name FROM employees WHERE salary  >  (SELECT salary FROM employees WHERE employee_id = 163 )", "source_tables": ["employees"], "description": "This virtual table provides the first and last names of employees from the 'employees' table whose salary is greater than that of a specified employee. The placeholder in the subquery represents the unique identifier of the employee whose salary is being compared.", "virtual_table": "SELECT first_name ,  last_name FROM employees WHERE salary  >  (SELECT salary FROM employees WHERE employee_id = [PLACEHOLDER-TYPE:NUMBER] )"}
{"sample_id": "train.3508", "db_id": "hr_1", "question": "What are the employee ids and job ids for employees who make less than the lowest earning employee with title MK_MAN?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Select the columns to display, 'employee_id' and 'job_id'.", "Add a condition to filter employees based on their salary being less than a minimum salary from a subquery.", "The subquery selects the minimum salary from the 'employees' table for a specific job, using a placeholder for the job identifier."], "gold_sql": "SELECT employee_id ,  job_id FROM employees WHERE salary  <  ( SELECT min(salary) FROM employees WHERE job_id  =  'MK_MAN' )", "source_tables": ["employees"], "description": "This virtual table provides a list of employee IDs and their corresponding job IDs from the 'employees' table, specifically for those employees whose salary is less than the minimum salary for a specified job. The placeholder in the subquery represents the job identifier for which the minimum salary is being compared.", "virtual_table": "SELECT employee_id ,  job_id FROM employees WHERE salary  <  ( SELECT min(salary) FROM employees WHERE job_id  =  [PLACEHOLDER-TYPE:STRING] )"}
{"sample_id": "train.3472", "db_id": "hr_1", "question": "What is the minimum salary in each department?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "It selects the minimum salary and groups the results by department_id to show the lowest salary for each department."], "gold_sql": "SELECT MIN(salary) ,  department_id FROM employees GROUP BY department_id", "source_tables": ["employees"], "description": "This virtual table summarizes the minimum salary for each department from the 'employees' table. The placeholder in the SELECT clause represents the department's identifier, allowing users to see the lowest salary within each department.", "virtual_table": "SELECT MIN(salary) ,  department_id FROM employees GROUP BY department_id"}
{"sample_id": "train.3408", "db_id": "hr_1", "question": "What are the full names and salaries for any employees earning less than 6000?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Select the columns to display: 'first_name', 'last_name', and 'salary'.", "Add a condition to filter the 'salary' column for employees earning less than a specified amount using a placeholder for numeric values."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees WHERE salary  <  6000", "source_tables": ["employees"], "description": "This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who earn less than a specified salary. The placeholder in the WHERE clause represents the salary threshold.", "virtual_table": "SELECT first_name ,  last_name ,  salary FROM employees WHERE salary  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3447", "db_id": "hr_1", "question": "display the employee ID for each employee and the date on which he ended his previous job.", "rationale": ["The query identifies the relevant table, which is 'job_history'.", "Select the column 'employee_id' to display the unique identifier for each employee.", "Use the MAX function to find the latest 'end_date' for each employee's job history.", "Group the results by 'employee_id' to ensure that the maximum end date is calculated for each individual employee."], "gold_sql": "SELECT employee_id ,  MAX(end_date) FROM job_history GROUP BY employee_id", "source_tables": ["job_history"], "description": "This virtual table provides a summary of the most recent job end dates for each employee from the 'job_history' table. The placeholder in the SELECT clause represents the unique identifier for each employee, while the MAX function is used to retrieve the latest end date for their job history.", "virtual_table": "SELECT employee_id ,  MAX(end_date) FROM job_history GROUP BY employee_id"}
{"sample_id": "train.3432", "db_id": "hr_1", "question": "What are the full names of employees who with in department 70 or 90?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Select the columns to display, 'first_name' and 'last_name'.", "Add a condition to filter the 'department_id' column for the specified department identifiers using placeholders for numeric values."], "gold_sql": "SELECT first_name ,  last_name FROM employees WHERE department_id  =  70 OR department_id  =  90", "source_tables": ["employees"], "description": "This virtual table provides the first and last names of employees from the 'employees' table who belong to specific departments. The placeholders in the WHERE clause represent the identifiers of the departments being queried.", "virtual_table": "SELECT first_name ,  last_name FROM employees WHERE department_id  =  [PLACEHOLDER-TYPE:NUMBER] OR department_id  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3464", "db_id": "hr_1", "question": "Give the name of each department and the number of employees in each.", "rationale": ["The query identifies the relevant tables, which are 'employees' and 'departments'.", "It selects the 'department_name' from the 'departments' table and counts the number of employees from the 'employees' table.", "A JOIN operation is performed on the 'department_id' to link employees to their respective departments.", "The results are grouped by 'department_name' to provide a count of employees in each department."], "gold_sql": "SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name", "source_tables": ["employees", "departments"], "description": "This virtual table summarizes the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT clause represents the department's name, and the COUNT function is used to calculate the total number of employees per department.", "virtual_table": "SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name"}
{"sample_id": "train.3518", "db_id": "hr_1", "question": "What are the full names, departments, cities, and state provinces for each employee?", "rationale": ["The query identifies the relevant tables: 'employees', 'departments', and 'locations'.", "It selects the columns to display: 'first_name' and 'last_name' from 'employees', 'department_name' from 'departments', and 'city' and 'state_province' from 'locations'.", "The JOIN operations link the 'employees' table to the 'departments' table using 'department_id', and the 'departments' table to the 'locations' table using 'location_id'."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T2.department_name ,  T3.city ,  T3.state_province FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id", "source_tables": ["employees", "departments", "locations"], "description": "This virtual table provides a view of employees along with their department names and the locations of those departments. It combines data from the 'employees', 'departments', and 'locations' tables, linking them through their respective identifiers. The placeholders in the SELECT statement represent the employee's first and last names, the department name, and the city and state of the department's location.", "virtual_table": "SELECT T1.first_name ,  T1.last_name ,  T2.department_name ,  T3.city ,  T3.state_province FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id"}
{"sample_id": "train.3471", "db_id": "hr_1", "question": "return the smallest salary for every departments.", "rationale": ["The query identifies the relevant table, which is 'employees'.", "It selects the minimum salary and groups the results by department_id to show the lowest salary for each department."], "gold_sql": "SELECT MIN(salary) ,  department_id FROM employees GROUP BY department_id", "source_tables": ["employees"], "description": "This virtual table summarizes the minimum salary for each department from the 'employees' table. The placeholder in the SELECT clause represents the department's identifier, allowing users to see the lowest salary within each department.", "virtual_table": "SELECT MIN(salary) ,  department_id FROM employees GROUP BY department_id"}
{"sample_id": "train.3524", "db_id": "hr_1", "question": "What the full names, ids of each employee and the name of the country they are in?", "rationale": ["The query identifies the relevant tables: 'employees', 'departments', 'locations', and 'countries'.", "It selects the columns to display: 'first_name', 'last_name', 'employee_id' from the 'employees' table and 'country_name' from the 'countries' table.", "The JOIN operations link the 'employees' table to the 'departments' table using 'department_id', then to the 'locations' table using 'location_id', and finally to the 'countries' table using 'country_id'."], "gold_sql": "SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id", "source_tables": ["countries", "employees", "departments", "locations"], "description": "The virtual table provides a list of employees along with their first names, last names, and employee IDs, as well as the names of the countries where their respective departments are located. The placeholders in the query represent the necessary identifiers to link employees to their departments and the locations of those departments to their countries.", "virtual_table": "SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id"}
{"sample_id": "train.3481", "db_id": "hr_1", "question": "get the details of employees who manage a department.", "rationale": ["The query selects distinct records from the 'employees' table and joins it with the 'departments' table.", "The join condition links the 'department_id' from both tables to associate employees with their departments.", "The WHERE clause filters the results to include only those employees whose 'employee_id' matches the 'manager_id' in the departments table."], "gold_sql": "SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T1.employee_id  =  T2.manager_id", "source_tables": ["employees", "departments"], "description": "The virtual table provides a view of employees and their corresponding departments, specifically focusing on those employees who are also managers of their respective departments. The placeholders in the query allow for filtering based on specific employee and department identifiers.", "virtual_table": "SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T1.employee_id  =  T2.manager_id"}
{"sample_id": "train.3498", "db_id": "hr_1", "question": "What are the ids for employees who do not work in departments with managers that have ids between 100 and 200?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "It selects all columns from the 'employees' table.", "A condition is added to filter out employees whose department IDs are in a subquery.", "The subquery selects department IDs from the 'departments' table where the manager ID is between two specified values, using placeholders for numeric values."], "gold_sql": "SELECT * FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN 100 AND 200)", "source_tables": ["employees", "departments"], "description": "This virtual table provides a list of all employees from the 'employees' table who do not belong to any department managed by a manager whose ID falls within a specified range. The placeholders in the subquery represent the range of manager IDs to filter out the departments.", "virtual_table": "SELECT * FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.3497", "db_id": "hr_1", "question": "Find the ids of the employees who does not work in those departments where some employees works whose manager id within the range 100 and 200.", "rationale": ["The query identifies the relevant table, which is 'employees'.", "It selects all columns from the 'employees' table.", "A condition is added to filter out employees whose department IDs are in a subquery.", "The subquery selects department IDs from the 'departments' table where the manager ID is between two specified values, using placeholders for numeric values."], "gold_sql": "SELECT * FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN 100 AND 200)", "source_tables": ["employees", "departments"], "description": "This virtual table provides a list of all employees from the 'employees' table who do not belong to any department managed by a manager whose ID falls within a specified range. The placeholders in the subquery represent the range of manager IDs to filter out the departments.", "virtual_table": "SELECT * FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.3466", "db_id": "hr_1", "question": "What is all the job history info done by employees earning a salary greater than or equal to 12000?", "rationale": ["The query identifies the relevant tables, which are 'job_history' and 'employees'.", "It selects all columns from the joined tables using the wildcard '*'.", "The JOIN operation is performed on the 'employee_id' to link job history records with the corresponding employee details.", "A condition is added to filter employees based on their salary, using a placeholder for numeric values."], "gold_sql": "SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  12000", "source_tables": ["job_history", "employees"], "description": "This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter records based on a specified minimum salary. The placeholder in the WHERE clause represents the minimum salary threshold for filtering the results.", "virtual_table": "SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2619", "db_id": "inn_1", "question": "How many rooms have king beds? Report the number for each decor type.", "rationale": ["The query identifies the relevant table, which is 'Rooms'.", "Select the column 'decor' to display the description of the room's decor.", "Use the count function to aggregate the number of rooms for each type of decor.", "Add a condition to filter the 'bedType' column for the specified bed type using a placeholder for string values.", "Group the results by the 'decor' column to get the count of rooms for each unique decor type."], "gold_sql": "SELECT decor ,  count(*) FROM Rooms WHERE bedType = 'King' GROUP BY decor;", "source_tables": ["rooms"], "description": "This virtual table provides a summary of the room decor and the count of rooms available for a specific bed type from the 'Rooms' table. The placeholder in the WHERE clause represents the type of bed that is being queried.", "virtual_table": "SELECT decor ,  count(*) FROM Rooms WHERE bedType = [PLACEHOLDER-TYPE:STRING] GROUP BY decor;"}
{"sample_id": "train.2591", "db_id": "inn_1", "question": "What are the names and decor of rooms with a king bed? Sort them by their price", "rationale": ["The query identifies the relevant table, which is 'Rooms'.", "Select the columns to display, 'roomName' and 'decor'.", "Add a condition to filter the 'bedType' column for the specified bed type using a placeholder for string values.", "Order the results by 'basePrice' to show the rooms in ascending order of their price."], "gold_sql": "SELECT roomName ,  decor FROM Rooms WHERE bedtype  =  'King' ORDER BY basePrice;", "source_tables": ["rooms"], "description": "This virtual table provides the names and decor descriptions of rooms from the 'Rooms' table that have a specific type of bed. The placeholder in the WHERE clause represents the bed type being queried, and the results are ordered by the base price of the rooms.", "virtual_table": "SELECT roomName ,  decor FROM Rooms WHERE bedtype  =  [PLACEHOLDER-TYPE:STRING] ORDER BY basePrice;"}
{"sample_id": "train.2638", "db_id": "inn_1", "question": "Return the name and number of reservations made for each of the rooms.", "rationale": ["The query identifies the relevant tables, 'Reservations' and 'Rooms', and uses a JOIN to combine them based on the room identifier.", "It selects the 'roomName' from the 'Rooms' table and counts the number of reservations for each room from the 'Reservations' table.", "The GROUP BY clause is used to aggregate the results by the room identifier, ensuring that the count reflects the number of reservations per room."], "gold_sql": "SELECT T2.roomName ,  count(*) ,  T1.Room FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room", "source_tables": ["rooms", "reservations"], "description": "This virtual table provides a summary of room reservations, displaying the room names along with the count of reservations for each room. The placeholders represent the room identifiers used to join the Reservations and Rooms tables, allowing for aggregation of reservation data by room.", "virtual_table": "SELECT T2.roomName ,  count(*) ,  T1.Room FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room"}
{"sample_id": "train.2618", "db_id": "inn_1", "question": "Find the number of rooms with king bed for each decor type.", "rationale": ["The query identifies the relevant table, which is 'Rooms'.", "Select the column 'decor' to display the description of the room's decor.", "Use the count function to aggregate the number of rooms for each type of decor.", "Add a condition to filter the 'bedType' column for the specified bed type using a placeholder for string values.", "Group the results by the 'decor' column to get the count of rooms for each unique decor type."], "gold_sql": "SELECT decor ,  count(*) FROM Rooms WHERE bedType = 'King' GROUP BY decor;", "source_tables": ["rooms"], "description": "This virtual table provides a summary of the room decor and the count of rooms available for a specific bed type from the 'Rooms' table. The placeholder in the WHERE clause represents the type of bed that is being queried.", "virtual_table": "SELECT decor ,  count(*) FROM Rooms WHERE bedType = [PLACEHOLDER-TYPE:STRING] GROUP BY decor;"}
{"sample_id": "train.2579", "db_id": "inn_1", "question": "Find the number of kids staying in the rooms reserved by a person called ROY SWEAZ.", "rationale": ["The query is identifying the relevant table, which is 'Reservations'.", "Select the column to display, 'kids'.", "Add conditions to filter the 'FirstName' and 'LastName' columns for the specified guest using placeholders for string values."], "gold_sql": "SELECT kids FROM Reservations WHERE FirstName = 'ROY' AND LastName  =  'SWEAZY';", "source_tables": ["reservations"], "description": "This virtual table provides information about the number of kids associated with reservations made by guests in the 'Reservations' table. The placeholders in the WHERE clause represent the first and last names of the guest making the reservation.", "virtual_table": "SELECT kids FROM Reservations WHERE FirstName = [PLACEHOLDER-TYPE:STRING] AND LastName  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.2629", "db_id": "inn_1", "question": "What are the names of rooms that have either king or queen bed?", "rationale": ["The query is identifying the relevant table, which is 'Rooms'.", "Select the column to display, 'roomName'.", "Add a condition to filter the 'bedType' column for the specified bed types using placeholders for string values. The use of OR allows for multiple bed types to be specified."], "gold_sql": "SELECT roomName FROM Rooms WHERE bedType  =  'King' OR bedType  =  'Queen';", "source_tables": ["rooms"], "description": "The virtual table provides a list of room names from the 'Rooms' table that have specific types of beds available. The placeholders in the WHERE clause represent the different bed types that the user is interested in.", "virtual_table": "SELECT roomName FROM Rooms WHERE bedType  =  [PLACEHOLDER-TYPE:STRING] OR bedType  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.2605", "db_id": "inn_1", "question": "What are the first and last names of people who payed more than the rooms' base prices?", "rationale": ["The query identifies the relevant tables, which are 'Reservations' and 'Rooms'.", "It selects the columns to display, 'FirstName' and 'LastName' from the 'Reservations' table.", "A JOIN operation is performed on the 'Room' column from 'Reservations' and 'RoomId' from 'Rooms' to link the two tables based on the room reserved.", "A condition is added to filter the results where the difference between the 'Rate' from 'Reservations' and 'basePrice' from 'Rooms' exceeds a specified numeric value using a placeholder."], "gold_sql": "SELECT T1.firstname ,  T1.lastname FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T1.Rate - T2.basePrice  >  0", "source_tables": ["rooms", "reservations"], "description": "This virtual table provides a list of first and last names of guests from the 'Reservations' table who have a reservation rate that exceeds the base price of the corresponding room. The placeholders in the WHERE clause represent the numeric difference between the reservation rate and the room's base price.", "virtual_table": "SELECT T1.firstname ,  T1.lastname FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T1.Rate - T2.basePrice  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2601", "db_id": "inn_1", "question": "What is the least popular kind of decor?", "rationale": ["The query identifies the relevant tables, 'Reservations' and 'Rooms', and establishes a join between them based on the room identifier.", "It selects the 'decor' column from the 'Rooms' table, which describes the room's decor.", "The results are grouped by the 'decor' type to aggregate similar decor types together.", "The results are ordered in ascending order based on the count of each decor type, allowing the least common decor types to appear first.", "A limit is applied to restrict the number of decor types returned, using a placeholder for numeric values."], "gold_sql": "SELECT T2.decor FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T2.decor ORDER BY count(T2.decor) ASC LIMIT 1;", "source_tables": ["rooms", "reservations"], "description": "This virtual table provides a list of room decorations from the 'Rooms' table that have been reserved, grouped by their decor type. The placeholder in the LIMIT clause indicates the maximum number of decor types to return, allowing for flexibility in the number of results.", "virtual_table": "SELECT T2.decor FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T2.decor ORDER BY count(T2.decor) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.2600", "db_id": "inn_1", "question": "What kind of decor has the least number of reservations?", "rationale": ["The query identifies the relevant tables, 'Reservations' and 'Rooms', and establishes a join between them based on the room identifier.", "It selects the 'decor' column from the 'Rooms' table to display the types of room decorations.", "The results are grouped by the 'decor' column to aggregate similar types together.", "The results are ordered in ascending order based on the count of each decor type, allowing the least common types to appear first.", "A limit is applied to control the number of decor types returned, using a placeholder for numeric values."], "gold_sql": "SELECT T2.decor FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T2.decor ORDER BY count(T2.decor) ASC LIMIT 1;", "source_tables": ["rooms", "reservations"], "description": "This virtual table provides a list of room decorations from the 'Rooms' table that have been reserved, grouped by their decor type. The placeholder in the LIMIT clause indicates the maximum number of decor types to return, allowing for flexibility in the number of results displayed.", "virtual_table": "SELECT T2.decor FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T2.decor ORDER BY count(T2.decor) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.2588", "db_id": "inn_1", "question": "How many king beds are there?", "rationale": ["The query identifies the relevant table, which is 'Rooms'.", "It selects the sum of the 'beds' column to calculate the total number of beds.", "A condition is added to filter the results based on the 'bedType' column using a placeholder for string values."], "gold_sql": "SELECT sum(beds) FROM Rooms WHERE bedtype  =  'King';", "source_tables": ["rooms"], "description": "This virtual table summarizes the total number of beds available in rooms of a specific bed type from the 'Rooms' table. The placeholder in the WHERE clause represents the type of beds being queried.", "virtual_table": "SELECT sum(beds) FROM Rooms WHERE bedtype  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.2615", "db_id": "inn_1", "question": "Which room has the highest base price?", "rationale": ["The query is identifying the relevant table, which is 'Rooms'.", "Select the columns to display, 'RoomId' and 'roomName'.", "Add an ORDER BY clause to sort the results based on 'basePrice' in descending order.", "Include a LIMIT clause to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT RoomId ,  roomName FROM Rooms ORDER BY basePrice DESC LIMIT 1;", "source_tables": ["rooms"], "description": "This virtual table provides a list of room identifiers and names from the 'Rooms' table, sorted by the base price in descending order. The placeholder in the LIMIT clause represents the maximum number of rooms to be displayed.", "virtual_table": "SELECT RoomId ,  roomName FROM Rooms ORDER BY basePrice DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.2608", "db_id": "inn_1", "question": "Find the number of rooms with a king bed.", "rationale": ["The query is identifying the relevant table, which is 'Rooms'.", "It selects a count of all entries in the table to determine how many rooms meet the specified criteria.", "A condition is added to filter the 'bedType' column for the specified type of bed using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM Rooms WHERE bedType  =  'King';", "source_tables": ["rooms"], "description": "This virtual table provides the count of rooms from the 'Rooms' table that have a specific type of bed. The placeholder in the WHERE clause represents the type of bed being queried.", "virtual_table": "SELECT count(*) FROM Rooms WHERE bedType  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.2602", "db_id": "inn_1", "question": "List how many times the number of people in the room reached the maximum occupancy of the room. The number of people include adults and kids.", "rationale": ["The query identifies the relevant tables, which are 'Reservations' and 'Rooms'.", "It uses a JOIN operation to link the two tables based on the room identifier.", "The SELECT statement counts the number of reservations that meet the condition of total occupants being equal to the maximum occupancy of the room."], "gold_sql": "SELECT count(*) FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T2.maxOccupancy  =  T1.Adults + T1.Kids;", "source_tables": ["rooms", "reservations"], "description": "This virtual table provides a count of reservations where the total number of occupants (adults and kids) matches the maximum occupancy allowed for each room. The placeholders in the query represent the relationships between the Reservations and Rooms tables, ensuring that only those reservations that meet the occupancy criteria are counted.", "virtual_table": "SELECT count(*) FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T2.maxOccupancy  =  T1.Adults + T1.Kids;"}
{"sample_id": "train.1536", "db_id": "insurance_and_eClaims", "question": "What are the names of the customers and staff members?", "rationale": ["The query is identifying the relevant tables, which are 'Customers' and 'Staff'.", "Using the UNION operator to combine results from both tables into a single result set.", "Selecting the 'Customer_Details' from the 'Customers' table and 'Staff_Details' from the 'Staff' table to display their information."], "gold_sql": "SELECT customer_details FROM customers UNION SELECT staff_details FROM staff", "source_tables": ["staff", "customers"], "description": "This virtual table combines detailed information about customers and staff members from the 'Customers' and 'Staff' tables. The result will include all customer details alongside all staff details, allowing for a comprehensive view of both entities.", "virtual_table": "SELECT customer_details FROM customers UNION SELECT staff_details FROM staff"}
{"sample_id": "train.1535", "db_id": "insurance_and_eClaims", "question": "Find the names of all the customers and staff members.", "rationale": ["The query identifies the relevant tables, which are 'Customers' and 'Staff'.", "It selects the 'Customer_Details' from the 'Customers' table and 'Staff_Details' from the 'Staff' table.", "The UNION operator is used to combine the results from both tables into a single output, allowing for a unified view of details from both customers and staff."], "gold_sql": "SELECT customer_details FROM customers UNION SELECT staff_details FROM staff", "source_tables": ["staff", "customers"], "description": "This virtual table combines detailed information about customers and staff members from the 'Customers' and 'Staff' tables. The placeholder in the SELECT clause allows for the retrieval of customer details and staff details, respectively, while the UNION operator merges the results into a single dataset.", "virtual_table": "SELECT customer_details FROM customers UNION SELECT staff_details FROM staff"}
{"sample_id": "train.1517", "db_id": "insurance_and_eClaims", "question": "Find the total amount claimed in the most recently created document.", "rationale": ["The query identifies the relevant tables, 'Claim_Headers' and 'Claims_Documents'.", "It selects the sum of the 'amount_claimed' from 'Claim_Headers'.", "A join is performed between 'Claim_Headers' and 'Claims_Documents' on the claim identifier to link claims with their documents.", "A condition is added to filter the documents based on their creation date, using a subquery to select the created date with a limit, represented by a placeholder for numeric values."], "gold_sql": "SELECT sum(t1.amount_claimed) FROM claim_headers AS t1 JOIN claims_documents AS t2 ON t1.claim_header_id  =  t2.claim_id WHERE t2.created_date  =  (SELECT created_date FROM claims_documents ORDER BY created_date LIMIT 1)", "source_tables": ["claims_documents", "claim_headers"], "description": "This virtual table summarizes the total amount claimed from the 'Claim_Headers' table, specifically for claims that have associated documents created on a specific date. The placeholder in the subquery represents the limit for selecting the created date of the documents.", "virtual_table": "SELECT sum(t1.amount_claimed) FROM claim_headers AS t1 JOIN claims_documents AS t2 ON t1.claim_header_id  =  t2.claim_id WHERE t2.created_date  =  (SELECT created_date FROM claims_documents ORDER BY created_date LIMIT [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.1528", "db_id": "insurance_and_eClaims", "question": "Which claim processing stage has the most claims? Show the claim status name.", "rationale": ["The query identifies the relevant tables, which are 'claims_processing' and 'claims_processing_stages'.", "It selects the 'claim_status_name' from the 'claims_processing_stages' table.", "A JOIN operation is performed on the 'claim_stage_id' to link the two tables.", "The results are grouped by 'claim_stage_id' to aggregate the data.", "The results are ordered by the count of occurrences in descending order to prioritize the most common statuses.", "A LIMIT clause is included to allow the user to specify how many results they want to retrieve."], "gold_sql": "SELECT t2.claim_status_name FROM claims_processing AS t1 JOIN claims_processing_stages AS t2 ON t1.claim_stage_id  =  t2.claim_stage_id GROUP BY t1.claim_stage_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["claims_processing", "claims_processing_stages"], "description": "This virtual table provides the names of claim statuses from the 'claims_processing_stages' table, based on the processing records in the 'claims_processing' table. The results are grouped by the claim stage ID and ordered by the count of occurrences, allowing the user to specify a limit on the number of statuses returned.", "virtual_table": "SELECT t2.claim_status_name FROM claims_processing AS t1 JOIN claims_processing_stages AS t2 ON t1.claim_stage_id  =  t2.claim_stage_id GROUP BY t1.claim_stage_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1527", "db_id": "insurance_and_eClaims", "question": "What is the name of the claim processing stage that most of the claims are on?", "rationale": ["The query identifies the relevant tables, which are 'claims_processing' and 'claims_processing_stages'.", "It selects the 'claim_status_name' from the 'claims_processing_stages' table.", "A JOIN operation is performed on the 'claim_stage_id' to link the two tables together.", "The results are grouped by 'claim_stage_id' to aggregate the data accordingly.", "The results are ordered by the count of occurrences in descending order to prioritize the most common claim statuses.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT t2.claim_status_name FROM claims_processing AS t1 JOIN claims_processing_stages AS t2 ON t1.claim_stage_id  =  t2.claim_stage_id GROUP BY t1.claim_stage_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["claims_processing", "claims_processing_stages"], "description": "This virtual table provides the names of claim statuses from the 'claims_processing_stages' table, based on the processing records in the 'claims_processing' table. The results are grouped by the claim stage ID and ordered by the count of occurrences, allowing the user to limit the number of results returned using a numeric placeholder.", "virtual_table": "SELECT t2.claim_status_name FROM claims_processing AS t1 JOIN claims_processing_stages AS t2 ON t1.claim_stage_id  =  t2.claim_stage_id GROUP BY t1.claim_stage_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1545", "db_id": "insurance_and_eClaims", "question": "Which customer is associated with the latest policy?", "rationale": ["The query identifies the relevant tables, which are 'Policies' and 'Customers'.", "It selects the 'Customer_Details' from the 'Customers' table.", "A JOIN operation is performed on 'Policies' and 'Customers' using the 'Customer_ID' to link them.", "The WHERE clause filters the results to only include the customer details associated with the most recent policy by using a subquery to find the maximum start date from the 'Policies' table."], "gold_sql": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)", "source_tables": ["policies", "customers"], "description": "This virtual table provides detailed information about customers who have the most recent insurance policy. The placeholder in the WHERE clause represents the start date of the policy, which is dynamically determined by selecting the maximum start date from the policies table.", "virtual_table": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)"}
{"sample_id": "train.1522", "db_id": "insurance_and_eClaims", "question": "Which customer made the smallest amount of claim in one claim? Return the customer details.", "rationale": ["The query identifies the relevant tables: 'Claim_Headers', 'Policies', and 'Customers'.", "It selects the 'customer_details' from the 'Customers' table.", "The JOIN operations link 'Claim_Headers' to 'Policies' using 'policy_id', and 'Policies' to 'Customers' using 'customer_id'.", "A condition is added to filter the results based on the minimum amount paid for claims, using a subquery to determine this value."], "gold_sql": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)", "source_tables": ["policies", "customers", "claim_headers"], "description": "This virtual table provides detailed information about customers associated with claims that have the minimum amount paid. It combines data from the 'Claim_Headers', 'Policies', and 'Customers' tables, linking claims to their respective policies and customers. The placeholder in the WHERE clause represents the minimum amount paid for claims.", "virtual_table": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)"}
{"sample_id": "train.1515", "db_id": "insurance_and_eClaims", "question": "Find the total and average amount paid in claim headers.", "rationale": ["The query identifies the relevant table, which is 'Claim_Headers'.", "It selects the sum and average of the 'amount_piad' column to provide a summary of the amounts paid.", "The use of aggregate functions allows for the calculation of total and average values, which are represented by placeholders in the SELECT clause."], "gold_sql": "SELECT sum(amount_piad) ,  avg(amount_piad) FROM claim_headers", "source_tables": ["claim_headers"], "description": "This virtual table summarizes the total and average amounts paid for claims from the 'Claim_Headers' table. The placeholders in the SELECT clause represent the aggregated values of the amounts paid.", "virtual_table": "SELECT sum(amount_piad) ,  avg(amount_piad) FROM claim_headers"}
{"sample_id": "train.900", "db_id": "insurance_fnol", "question": "Find the policy types more than 4 customers use. Show their type code.", "rationale": ["The query identifies the relevant table, which is 'Available_Policies'.", "It selects the 'policy_type_code' to display distinct policy types.", "The GROUP BY clause is used to group the results by 'policy_type_code'.", "The HAVING clause filters the groups to include only those with a count greater than a specified number, using a placeholder for numeric values."], "gold_sql": "SELECT policy_type_code FROM available_policies GROUP BY policy_type_code HAVING count(*)  >  4", "source_tables": ["available_policies"], "description": "This virtual table summarizes the distinct types of insurance policies available in the 'Available_Policies' table, specifically focusing on those policy types that have been issued more than a specified number of times. The placeholder in the HAVING clause represents the minimum count of policies required for inclusion in the results.", "virtual_table": "SELECT policy_type_code FROM available_policies GROUP BY policy_type_code HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.899", "db_id": "insurance_fnol", "question": "Find the policy type used by more than 4 customers.", "rationale": ["The query identifies the relevant table, which is 'Available_Policies'.", "It selects the 'policy_type_code' to display the different types of policies.", "The query groups the results by 'policy_type_code' to aggregate the data.", "A condition is added using the HAVING clause to filter policy types that have a count greater than a specified number, using a placeholder for numeric values."], "gold_sql": "SELECT policy_type_code FROM available_policies GROUP BY policy_type_code HAVING count(*)  >  4", "source_tables": ["available_policies"], "description": "This virtual table summarizes the different types of insurance policies available in the 'Available_Policies' table. It groups the policies by their type code and filters the results to show only those policy types that have a count exceeding a specified number. The placeholder in the HAVING clause represents the minimum count of policies required for each type.", "virtual_table": "SELECT policy_type_code FROM available_policies GROUP BY policy_type_code HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.930", "db_id": "insurance_fnol", "question": "What is the ordered list of customer ids?", "rationale": ["The query identifies the relevant table, which is 'Customers'.", "Select the columns to display, 'customer_id' and 'customer_name'.", "Add an ORDER BY clause to sort the results by 'customer_id' in ascending order."], "gold_sql": "SELECT customer_id ,  customer_name FROM customers ORDER BY customer_id ASC", "source_tables": ["customers"], "description": "This virtual table provides a list of customer IDs and their corresponding names from the 'Customers' table, sorted in ascending order by customer ID. The placeholders represent the customer ID and name values.", "virtual_table": "SELECT customer_id ,  customer_name FROM customers ORDER BY customer_id ASC"}
{"sample_id": "train.896", "db_id": "insurance_fnol", "question": "Which policy type appears most frequently in the available policies?", "rationale": ["The query identifies the relevant table, which is 'Available_Policies'.", "It selects the 'policy_type_code' column to display the different types of policies.", "The GROUP BY clause is used to group the results by 'policy_type_code'.", "The ORDER BY clause sorts the grouped results by their count in descending order to show the most common policy types first.", "The LIMIT clause includes a placeholder for the user to specify how many policy types they want to retrieve."], "gold_sql": "SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["available_policies"], "description": "This virtual table summarizes the different types of insurance policies available in the 'Available_Policies' table, grouped by their policy type code. The placeholder in the LIMIT clause allows the user to specify the maximum number of policy types to retrieve, sorted by their frequency in descending order.", "virtual_table": "SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.894", "db_id": "insurance_fnol", "question": "What are the phone numbers of customers using the policy with the code \"Life Insurance\"?", "rationale": ["The query identifies the relevant table, which is 'Available_Policies'.", "Select the column to display, 'Customer_Phone'.", "Add a condition to filter the 'policy_type_code' column for the specified policy type using a placeholder for string values."], "gold_sql": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  'Life Insurance'", "source_tables": ["available_policies"], "description": "This virtual table provides the contact phone numbers of customers from the 'Available_Policies' table who have a specific type of insurance policy. The placeholder in the WHERE clause represents the policy type code.", "virtual_table": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3894", "db_id": "insurance_policies", "question": "List the date the claim was made, the date it was settled and the amount settled for all the claims which had exactly one settlement.", "rationale": ["The query identifies the relevant tables, which are 'Claims' and 'Settlements'.", "It selects the 'claim_id', 'date_claim_made', and 'Date_Claim_Settled' columns from the 'Claims' table (aliased as T1).", "A JOIN operation is performed between 'Claims' and 'Settlements' on the 'Claim_id' to link claims with their settlements.", "The results are grouped by 'claim_id' to aggregate the data for each claim.", "The HAVING clause is used to filter the results based on the count of settlements for each claim, using a placeholder for numeric values."], "gold_sql": "SELECT T1.claim_id ,  T1.date_claim_made ,  T1.Date_Claim_Settled FROM Claims AS T1 JOIN Settlements AS T2 ON T1.Claim_id  =  T2.Claim_id GROUP BY T1.claim_id HAVING count(*)  =  1", "source_tables": ["claims", "settlements"], "description": "This virtual table provides a summary of claims and their corresponding settlement dates from the 'Claims' and 'Settlements' tables. The placeholder in the HAVING clause represents the number of settlements associated with each claim, allowing users to filter claims based on the count of their settlements.", "virtual_table": "SELECT T1.claim_id ,  T1.date_claim_made ,  T1.Date_Claim_Settled FROM Claims AS T1 JOIN Settlements AS T2 ON T1.Claim_id  =  T2.Claim_id GROUP BY T1.claim_id HAVING count(*)  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3861", "db_id": "insurance_policies", "question": "Give me the claim date, settlement date for all the claims whose claimed amount is larger than the average.", "rationale": ["The query identifies the relevant table, which is 'Claims'.", "Select the columns to display, 'Date_Claim_Made' and 'Date_Claim_Settled'.", "Add a condition to filter the claims where 'Amount_Claimed' is greater than the average amount claimed, using a subquery to calculate the average dynamically."], "gold_sql": "SELECT Date_Claim_Made ,  Date_Claim_Settled FROM Claims WHERE Amount_Claimed  >  ( SELECT avg(Amount_Claimed) FROM Claims )", "source_tables": ["claims"], "description": "This virtual table provides information about the dates when claims were made and settled from the 'Claims' table, specifically for claims where the amount claimed exceeds the average amount claimed across all claims. The placeholder in the WHERE clause represents the average amount claimed, which is calculated dynamically.", "virtual_table": "SELECT Date_Claim_Made ,  Date_Claim_Settled FROM Claims WHERE Amount_Claimed  >  ( SELECT avg(Amount_Claimed) FROM Claims )"}
{"sample_id": "train.3864", "db_id": "insurance_policies", "question": "How many settlements does each claim correspond to? List the claim id and the number of settlements.", "rationale": ["The query identifies the relevant tables, which are 'Claims' and 'Settlements'.", "It selects the 'Claim_ID' from the 'Claims' table and counts the number of associated records in the 'Settlements' table.", "A JOIN operation is performed on the 'Claim_ID' to link claims with their corresponding settlements.", "The results are grouped by 'Claim_ID' to provide a count of settlements for each unique claim."], "gold_sql": "SELECT T1.Claim_id ,  count(*) FROM Claims AS T1 JOIN Settlements AS T2 ON T1.claim_id  =  T2.claim_id GROUP BY T1.claim_id", "source_tables": ["claims", "settlements"], "description": "This virtual table summarizes the number of settlements associated with each insurance claim from the 'Claims' table. The placeholder in the SELECT statement represents the unique identifier for each claim, while the count function aggregates the total number of settlements linked to each claim.", "virtual_table": "SELECT T1.Claim_id ,  count(*) FROM Claims AS T1 JOIN Settlements AS T2 ON T1.claim_id  =  T2.claim_id GROUP BY T1.claim_id"}
{"sample_id": "train.3881", "db_id": "insurance_policies", "question": "What is the payment method that were used the least often?", "rationale": ["The query identifies the relevant table, which is 'Payments'.", "It selects the 'Payment_Method_Code' column to display the different payment methods.", "The GROUP BY clause is used to group the results by 'Payment_Method_Code'.", "The ORDER BY clause sorts the grouped results in ascending order based on their count.", "The LIMIT clause allows the user to specify how many payment methods to return, using a placeholder for numeric values."], "gold_sql": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) ASC LIMIT 1", "source_tables": ["payments"], "description": "This virtual table summarizes the different payment methods used in the 'Payments' table, grouped by their method codes. The placeholder in the LIMIT clause allows the user to specify the maximum number of payment methods to retrieve, sorted in ascending order based on their frequency of use.", "virtual_table": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3859", "db_id": "insurance_policies", "question": "Find the claimed amount in the claim with the least amount settled. Show both the settlement amount and claim amount.", "rationale": ["The query identifies the relevant table, which is 'Claims'.", "Selects the columns to display, 'Amount_Settled' and 'Amount_Claimed'.", "Orders the results by 'Amount_Settled' in ascending order to show the smallest settled amounts first.", "Limits the number of records returned based on a placeholder for numeric values."], "gold_sql": "SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Settled ASC LIMIT 1", "source_tables": ["claims"], "description": "This virtual table provides a summary of the amounts settled and claimed for insurance claims from the 'Claims' table. The placeholder in the LIMIT clause allows the user to specify the maximum number of records to retrieve, sorted by the settled amount in ascending order.", "virtual_table": "SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Settled ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3858", "db_id": "insurance_policies", "question": "Among all the claims, what is the amount claimed in the claim with the least amount settled? List both the settlement amount and claim amount.", "rationale": ["The query identifies the relevant table, which is 'Claims'.", "Selects the columns to display, 'Amount_Settled' and 'Amount_Claimed'.", "Orders the results by 'Amount_Settled' in ascending order to show the smallest settled amounts first.", "Limits the number of records returned based on a placeholder for numeric values."], "gold_sql": "SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Settled ASC LIMIT 1", "source_tables": ["claims"], "description": "This virtual table provides a summary of the amounts settled and claimed for insurance claims from the 'Claims' table. The placeholder in the LIMIT clause allows the user to specify the maximum number of records to retrieve, sorted by the settled amount in ascending order.", "virtual_table": "SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Settled ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3887", "db_id": "insurance_policies", "question": "Find the policy type the most customers choose.", "rationale": ["The query identifies the relevant table, which is 'Customer_Policies'.", "It selects the 'Policy_Type_Code' to display the different types of insurance policies.", "The GROUP BY clause is used to group the results by 'Policy_Type_Code'.", "The ORDER BY clause sorts the grouped results by their count in descending order to show the most common policy types first.", "The LIMIT clause includes a placeholder to allow the user to specify how many policy types they want to retrieve."], "gold_sql": "SELECT Policy_Type_Code FROM Customer_Policies GROUP BY Policy_Type_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customer_policies"], "description": "This virtual table summarizes the different types of insurance policies from the 'Customer_Policies' table, grouped by their policy type codes. The placeholder in the LIMIT clause allows the user to specify the maximum number of policy types to retrieve, sorted by the frequency of each type in descending order.", "virtual_table": "SELECT Policy_Type_Code FROM Customer_Policies GROUP BY Policy_Type_Code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3856", "db_id": "insurance_policies", "question": "Among all the claims, what is the settlement amount of the claim with the largest claim amount? List both the settlement amount and claim amount.", "rationale": ["The query identifies the relevant table, which is 'Claims'.", "Selects the columns to display, 'Amount_Settled' and 'Amount_Claimed'.", "Orders the results by 'Amount_Claimed' in descending order to show the highest claims first.", "Limits the number of records returned using a placeholder for numeric values."], "gold_sql": "SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Claimed DESC LIMIT 1", "source_tables": ["claims"], "description": "This virtual table provides a summary of the amounts claimed and settled for insurance claims from the 'Claims' table. The results are ordered by the claimed amount in descending order, with a limit on the number of records returned, specified by a placeholder for numeric values.", "virtual_table": "SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Claimed DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3892", "db_id": "insurance_policies", "question": "List the details of the customers who do not have any policies.", "rationale": ["The query identifies the relevant table, which is 'Customers'.", "It selects the 'customer_details' column to display customer information.", "The EXCEPT clause is used to exclude customers who have policies by joining 'Customers' with 'Customer_Policies' on 'Customer_ID' to filter out those with existing policies."], "gold_sql": "SELECT customer_details FROM Customers EXCEPT SELECT T1.customer_details FROM Customers AS T1 JOIN Customer_Policies AS T2 ON T1.customer_id  =  T2.customer_id", "source_tables": ["customer_policies", "customers"], "description": "This virtual table provides a list of customer details from the 'Customers' table, excluding those customers who have associated insurance policies. The query uses an EXCEPT clause to filter out customers that are linked to any policies in the 'Customer_Policies' table.", "virtual_table": "SELECT customer_details FROM Customers EXCEPT SELECT T1.customer_details FROM Customers AS T1 JOIN Customer_Policies AS T2 ON T1.customer_id  =  T2.customer_id"}
{"sample_id": "train.2257", "db_id": "machine_repair", "question": "Show names of technicians and the number of machines they are assigned to repair.", "rationale": ["The query identifies the relevant tables, which are 'repair_assignment' and 'technician'.", "It selects the 'Name' column from the 'technician' table and counts the number of records from the 'repair_assignment' table.", "The JOIN operation links the two tables based on the technician's ID to associate each repair assignment with the corresponding technician.", "The GROUP BY clause is used to aggregate the results by technician's name, allowing us to count the number of assignments for each technician."], "gold_sql": "SELECT T2.Name ,  COUNT(*) FROM repair_assignment AS T1 JOIN technician AS T2 ON T1.technician_ID  =  T2.technician_ID GROUP BY T2.Name", "source_tables": ["repair_assignment", "technician"], "description": "This virtual table summarizes the count of repair assignments for each technician from the 'repair_assignment' and 'technician' tables. The placeholder in the SELECT clause represents the technician's name, and the COUNT function aggregates the number of assignments per technician.", "virtual_table": "SELECT T2.Name ,  COUNT(*) FROM repair_assignment AS T1 JOIN technician AS T2 ON T1.technician_ID  =  T2.technician_ID GROUP BY T2.Name"}
{"sample_id": "train.2262", "db_id": "machine_repair", "question": "What are the starting years shared by the technicians from the team \"CLE\" or \"CWS\"?", "rationale": ["The query identifies the relevant table, which is 'technician'.", "Select the column to display, 'Starting_Year'.", "Add a condition to filter the 'Team' column for the specified teams using placeholders for string values.", "Use the INTERSECT operator to find common starting years between the two specified teams."], "gold_sql": "SELECT Starting_Year FROM technician WHERE Team  =  'CLE' INTERSECT SELECT Starting_Year FROM technician WHERE Team  =  'CWS'", "source_tables": ["technician"], "description": "The virtual table provides the starting years of technicians from the 'technician' table who belong to two specific teams. The placeholders in the WHERE clause represent the identifiers for the teams being compared.", "virtual_table": "SELECT Starting_Year FROM technician WHERE Team  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT Starting_Year FROM technician WHERE Team  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2247", "db_id": "machine_repair", "question": "Please show the team that has the most number of technicians.", "rationale": ["The query identifies the relevant table, which is 'technician'.", "It selects the 'Team' column to display the team identifiers.", "The GROUP BY clause is used to group the results by the 'Team' column.", "The ORDER BY clause sorts the teams based on the count of technicians in each team in descending order.", "The LIMIT clause uses a placeholder to specify how many teams to return."], "gold_sql": "SELECT Team FROM technician GROUP BY Team ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["technician"], "description": "This virtual table summarizes the teams of technicians from the 'technician' table, grouping them by their team identifier. The placeholder in the LIMIT clause allows for specifying the maximum number of teams to display, sorted by the number of technicians in each team in descending order.", "virtual_table": "SELECT Team FROM technician GROUP BY Team ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2256", "db_id": "machine_repair", "question": "What are the names of the technicians that are assigned to repair machines with more point values than 70?", "rationale": ["The query identifies the relevant tables: 'repair_assignment', 'machine', and 'technician'.", "It selects the 'Name' column from the 'technician' table (aliased as T3).", "The JOIN operations link the 'repair_assignment' table (T1) with the 'machine' table (T2) and the 'technician' table (T3) based on their respective identifiers.", "A condition is added to filter machines based on their 'value_points', using a placeholder for numeric values."], "gold_sql": "SELECT T3.Name FROM repair_assignment AS T1 JOIN machine AS T2 ON T1.machine_id  =  T2.machine_id JOIN technician AS T3 ON T1.technician_ID  =  T3.technician_ID WHERE T2.value_points  >  70", "source_tables": ["machine", "repair_assignment", "technician"], "description": "The virtual table provides the names of technicians who are assigned to repair tasks for machines that have a value point greater than a specified threshold. The placeholders in the WHERE clause allow users to input the desired value point for filtering the results.", "virtual_table": "SELECT T3.Name FROM repair_assignment AS T1 JOIN machine AS T2 ON T1.machine_id  =  T2.machine_id JOIN technician AS T3 ON T1.technician_ID  =  T3.technician_ID WHERE T2.value_points  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2244", "db_id": "machine_repair", "question": "What is the starting year for the oldest technician?", "rationale": ["The query identifies the relevant table, which is 'technician'.", "Select the column to display, 'Starting_Year'.", "Order the results by the 'Age' column in descending order to show the oldest technicians first.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT Starting_Year FROM technician ORDER BY Age DESC LIMIT 1", "source_tables": ["technician"], "description": "This virtual table provides the starting years of technicians from the 'technician' table, ordered by their age in descending order. The placeholder in the LIMIT clause indicates the maximum number of records to return.", "virtual_table": "SELECT Starting_Year FROM technician ORDER BY Age DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1108", "db_id": "match_season", "question": "Which college have both players with position midfielder and players with position defender?", "rationale": ["The query identifies the relevant table, which is 'match_season'.", "It selects the 'College' column to display the colleges attended by players.", "The INTERSECT operator is used to find colleges attended by players in two different positions, with placeholders for the specified positions in the WHERE clause."], "gold_sql": "SELECT College FROM match_season WHERE POSITION  =  'Midfielder' INTERSECT SELECT College FROM match_season WHERE POSITION  =  'Defender'", "source_tables": ["match_season"], "description": "The virtual table provides a list of colleges attended by players in the 'match_season' table who play in two specified positions. The placeholders in the WHERE clause represent the positions of the players being compared.", "virtual_table": "SELECT College FROM match_season WHERE POSITION  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT College FROM match_season WHERE POSITION  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1106", "db_id": "match_season", "question": "What are the names of countries that have both players with position forward and players with position defender?", "rationale": ["The query is identifying the relevant tables, which are 'country' and 'match_season'.", "It selects the 'Country_name' from the 'country' table.", "The JOIN operation links the 'country' table with the 'match_season' table based on the 'Country_id'.", "The WHERE clause filters the results based on the specified player position using a placeholder for string values.", "The INTERSECT operation is used to find common countries represented by players in the specified position from two instances of the same condition."], "gold_sql": "SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  'Forward' INTERSECT SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  'Defender'", "source_tables": ["country", "match_season"], "description": "This virtual table identifies the names of countries represented by players who occupy a specific position in matches. The query uses an intersection to find countries where players in that position are participating in matches, ensuring that only countries with players in both instances of the specified position are returned. The placeholders in the WHERE clause represent the position of the players.", "virtual_table": "SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1064", "db_id": "match_season", "question": "Show the draft pick numbers and draft classes of players whose positions are defenders.", "rationale": ["The query identifies the relevant table, which is 'match_season'.", "Select the columns to display, 'Draft_Pick_Number' and 'Draft_Class'.", "Add a condition to filter the 'Position' column for the specified position using a placeholder for string values."], "gold_sql": "SELECT Draft_Pick_Number ,  Draft_Class FROM match_season WHERE POSITION  =  'Defender'", "source_tables": ["match_season"], "description": "This virtual table provides information about the draft pick number and draft class of players from the 'match_season' table who play in a specific position. The placeholder in the WHERE clause represents the position of the player.", "virtual_table": "SELECT Draft_Pick_Number ,  Draft_Class FROM match_season WHERE POSITION  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1093", "db_id": "match_season", "question": "How many players are from each country?", "rationale": ["The query identifies the relevant tables, which are 'country' and 'match_season'.", "It selects the 'Country_name' from the 'country' table and counts the number of matches from the 'match_season' table.", "A JOIN operation is performed on the 'Country_id' from the 'country' table and the 'Country' from the 'match_season' table to link the data.", "The results are grouped by 'Country_name' to provide a count of matches for each country."], "gold_sql": "SELECT Country_name ,  COUNT(*) FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country GROUP BY T1.Country_name", "source_tables": ["country", "match_season"], "description": "This virtual table summarizes the number of matches played by players from each country by joining the 'country' and 'match_season' tables. The placeholder in the COUNT function represents the count of matches associated with each country.", "virtual_table": "SELECT Country_name ,  COUNT(*) FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country GROUP BY T1.Country_name"}
{"sample_id": "train.1073", "db_id": "match_season", "question": "For each player, what are their name, season, and country that they belong to?", "rationale": ["The query identifies the relevant tables, which are 'country' and 'match_season'.", "It selects the columns to display: 'Season' and 'Player' from the 'match_season' table, and 'Country_name' from the 'country' table.", "A JOIN operation is performed to combine data from both tables based on the matching 'Country_id' in 'country' and 'Country' in 'match_season'."], "gold_sql": "SELECT T2.Season ,  T2.Player ,  T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country", "source_tables": ["country", "match_season"], "description": "This virtual table provides information about the seasons, players, and their corresponding countries from the 'match_season' and 'country' tables. The join operation links the country data with the match season data based on the country identifier, allowing users to see which players participated in which seasons and the countries they represent.", "virtual_table": "SELECT T2.Season ,  T2.Player ,  T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country"}
{"sample_id": "train.1080", "db_id": "match_season", "question": "How many distinct official languages are there among countries of players whose positions are defenders.", "rationale": ["The query identifies the relevant tables, which are 'country' and 'match_season'.", "It counts the distinct values of 'Official_native_language' from the 'country' table.", "A JOIN is performed between 'country' and 'match_season' on the 'Country_id' to link players to their respective countries.", "A condition is added to filter the results based on the specified player's position using a placeholder for string values."], "gold_sql": "SELECT count(DISTINCT T1.Official_native_language) FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  'Defender'", "source_tables": ["country", "match_season"], "description": "This virtual table provides the count of distinct official native languages spoken in countries represented by players in a specific position during matches. The placeholder in the WHERE clause indicates the player's position.", "virtual_table": "SELECT count(DISTINCT T1.Official_native_language) FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1083", "db_id": "match_season", "question": "Who are the different players, what season do they play in, and what is the name of the team they are on?", "rationale": ["The query identifies the relevant tables, which are 'match_season' and 'team'.", "It selects the columns to display: 'Season' and 'Player' from 'match_season', and 'Name' from 'team'.", "A JOIN operation is performed to connect 'match_season' and 'team' on the 'Team' identifier, ensuring that we can retrieve the team names associated with each player in the specified season."], "gold_sql": "SELECT T1.Season ,  T1.Player ,  T2.Name FROM match_season AS T1 JOIN team AS T2 ON T1.Team  =  T2.Team_id", "source_tables": ["team", "match_season"], "description": "This virtual table provides information about the seasons in which players participated, along with their names and the corresponding team names. The join operation connects the 'match_season' table with the 'team' table based on the team identifier, allowing us to retrieve the relevant team names for each player in a specific season.", "virtual_table": "SELECT T1.Season ,  T1.Player ,  T2.Name FROM match_season AS T1 JOIN team AS T2 ON T1.Team  =  T2.Team_id"}
{"sample_id": "train.1094", "db_id": "match_season", "question": "Return all players sorted by college in ascending alphabetical order.", "rationale": ["The query identifies the relevant table, which is 'match_season'.", "Select the column to display, which is 'player'.", "Add an ORDER BY clause to sort the results based on the 'College' column in ascending order."], "gold_sql": "SELECT player FROM match_season ORDER BY College ASC", "source_tables": ["match_season"], "description": "This virtual table provides a list of players from the 'match_season' table, ordered by their college names in ascending order. The placeholder in the ORDER BY clause indicates that the sorting will be based on the college each player attended.", "virtual_table": "SELECT player FROM match_season ORDER BY College ASC"}
{"sample_id": "train.2506", "db_id": "movie_1", "question": "Find the title and score of the movie with the lowest rating among all movies directed by each director.", "rationale": ["The query identifies the relevant tables, which are 'Rating' and 'Movie'.", "It selects the columns to display: 'title' from the 'Movie' table, 'stars' from the 'Rating' table, and 'director' from the 'Movie' table.", "The query uses a JOIN operation to link the 'Rating' table with the 'Movie' table based on the movie identifier (mID).", "It groups the results by the director's name to aggregate the star ratings, specifically calculating the minimum star rating for each director."], "gold_sql": "SELECT T2.title ,  T1.stars ,  T2.director ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T2.director", "source_tables": ["rating", "movie"], "description": "This virtual table provides a summary of movie ratings, displaying the title of each movie, the number of stars given, the director's name, and the minimum star rating for each director. The placeholders in the query represent the relevant identifiers and values for the movies and ratings.", "virtual_table": "SELECT T2.title ,  T1.stars ,  T2.director ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T2.director"}
{"sample_id": "train.2514", "db_id": "movie_1", "question": "Find the average rating star for each movie that are not reviewed by Brittany Harris.", "rationale": ["The query identifies the relevant table, which is 'Rating', to calculate average ratings.", "It selects the movie identifier 'mID' and the average of 'stars' for the ratings.", "A subquery is used to filter out movies that have been rated by a specific reviewer, linking the 'Rating' table to the 'Reviewer' table using the reviewer ID.", "The placeholder in the subquery represents the reviewer's name whose ratings are to be excluded from the average calculation."], "gold_sql": "SELECT mID ,  avg(stars) FROM Rating WHERE mID NOT IN (SELECT T1.mID FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T2.name  =  'Brittany Harris') GROUP BY mID", "source_tables": ["rating", "reviewer"], "description": "This virtual table provides the average star ratings of movies from the 'Rating' table, excluding those rated by a specific reviewer. The placeholder in the subquery represents the reviewer's name whose ratings are to be excluded.", "virtual_table": "SELECT mID ,  avg(stars) FROM Rating WHERE mID NOT IN (SELECT T1.mID FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING]) GROUP BY mID"}
{"sample_id": "train.2519", "db_id": "movie_1", "question": "For each movie that received more than 3 reviews, what is the average rating?", "rationale": ["The query identifies the relevant table, which is 'Rating'.", "It selects the movie identifier 'mID' and calculates the average of the 'stars' column.", "The results are grouped by 'mID' to aggregate ratings for each movie.", "A condition is added to filter the results to only include movies that have received a specified minimum number of ratings, using a placeholder for numeric values."], "gold_sql": "SELECT mID ,  avg(stars) FROM Rating GROUP BY mID HAVING count(*)  >=  2", "source_tables": ["rating"], "description": "This virtual table provides the average star ratings for movies from the 'Rating' table, grouped by movie identifier. The placeholder in the HAVING clause represents the minimum number of ratings a movie must have to be included in the results.", "virtual_table": "SELECT mID ,  avg(stars) FROM Rating GROUP BY mID HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2504", "db_id": "movie_1", "question": "Find the title and star rating of the movie that got the least rating star for each reviewer.", "rationale": ["The query identifies the relevant tables, which are 'Rating' and 'Movie'.", "It selects the columns to display: the movie title from the 'Movie' table, the reviewer ID, the stars given in the rating, and the minimum stars given by each reviewer.", "The JOIN operation links the 'Rating' table with the 'Movie' table based on the movie identifier, ensuring that the ratings correspond to the correct movies.", "The GROUP BY clause is used to aggregate the results by reviewer ID, allowing for the calculation of the minimum stars given by each reviewer."], "gold_sql": "SELECT T2.title ,  T1.rID ,  T1.stars ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.rID", "source_tables": ["rating", "movie"], "description": "This virtual table provides a summary of movie ratings by reviewers. It includes the title of the movie, the unique identifier of the reviewer, the number of stars given in the rating, and the minimum stars given by each reviewer. The placeholders in the query allow for dynamic filtering based on the reviewer's ID and the movie's ID.", "virtual_table": "SELECT T2.title ,  T1.rID ,  T1.stars ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.rID"}
{"sample_id": "train.2487", "db_id": "movie_1", "question": "For all directors who have directed more than one movie, what movies have they directed and what are their names?", "rationale": ["The query identifies the relevant table, which is 'Movie'.", "It selects the columns 'title' and 'director' from the 'Movie' table.", "A self-join is performed on the 'Movie' table to compare movies directed by the same director.", "A condition is added to ensure that the titles are not the same, using a placeholder for the title comparison.", "The results are ordered by 'director' and 'title' to provide a structured output."], "gold_sql": "SELECT T1.title ,  T1.director FROM Movie AS T1 JOIN Movie AS T2 ON T1.director  =  T2.director WHERE T1.title != T2.title ORDER BY T1.director ,  T1.title", "source_tables": ["movie"], "description": "This virtual table provides a list of movie titles along with their directors from the 'Movie' table, specifically focusing on movies that share the same director but have different titles. The query ensures that only distinct titles are selected by excluding cases where the title is the same as the other movie's title, and it organizes the results by director and title.", "virtual_table": "SELECT T1.title ,  T1.director FROM Movie AS T1 JOIN Movie AS T2 ON T1.director  =  T2.director WHERE T1.title != T2.title ORDER BY T1.director ,  T1.title"}
{"sample_id": "train.2531", "db_id": "movie_1", "question": "What are the names of all movies that received 3 or 4 stars?", "rationale": ["The query identifies the relevant tables, which are 'Rating' and 'Movie'.", "It selects the 'title' column from the 'Movie' table.", "The JOIN operation links the 'Rating' table to the 'Movie' table using the movie identifier 'mID'.", "The WHERE clause filters the results based on the number of stars given, using a placeholder for numeric values.", "The INTERSECT operation is used to find titles that have been rated with the same star value by different reviewers."], "gold_sql": "SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  3 INTERSECT SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  4", "source_tables": ["rating", "movie"], "description": "The virtual table presents the titles of movies that have received a specific number of stars from reviewers. The query uses an intersection to find movies that have been rated with the same star value by different reviewers. The placeholders in the WHERE clause represent the star ratings given by reviewers.", "virtual_table": "SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2515", "db_id": "movie_1", "question": "What is the average rating for each movie that has never been reviewed by Brittany Harris?", "rationale": ["The query identifies the relevant table, which is 'Rating', to calculate average ratings.", "It selects the movie identifier 'mID' and the average of 'stars' for the ratings.", "A subquery is used to filter out movies that have been rated by a specific reviewer, linking the 'Rating' and 'Reviewer' tables through the reviewer ID 'rID'.", "The placeholder in the subquery represents the reviewer's name whose ratings should be excluded from the average calculation."], "gold_sql": "SELECT mID ,  avg(stars) FROM Rating WHERE mID NOT IN (SELECT T1.mID FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T2.name  =  'Brittany Harris') GROUP BY mID", "source_tables": ["rating", "reviewer"], "description": "This virtual table provides the average star ratings of movies from the 'Rating' table, excluding those rated by a specific reviewer. The placeholder in the subquery represents the reviewer's name whose ratings are to be excluded.", "virtual_table": "SELECT mID ,  avg(stars) FROM Rating WHERE mID NOT IN (SELECT T1.mID FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING]) GROUP BY mID"}
{"sample_id": "train.2529", "db_id": "movie_1", "question": "What are the names of all reviewers that have given 3 or 4 stars for reviews?", "rationale": ["The query identifies the relevant tables, which are 'Rating' and 'Reviewer'.", "It selects the 'name' column from the 'Reviewer' table.", "The JOIN operation links the 'Rating' table to the 'Reviewer' table using the reviewer ID.", "The WHERE clause filters the ratings based on the specified number of stars using a placeholder for numeric values.", "The INTERSECT operation is used to find common reviewers who rated two different movies with the same star rating."], "gold_sql": "SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T1.stars  =  3 INTERSECT SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T1.stars  =  4", "source_tables": ["rating", "reviewer"], "description": "The virtual table describes the names of reviewers who have given a specific number of stars to movies. The query uses an INTERSECT operation to find reviewers who rated two different movies with the same star rating. The placeholders represent the number of stars given in the ratings.", "virtual_table": "SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2497", "db_id": "movie_1", "question": "What are the movie titles with the highest average rating and what are those ratings?", "rationale": ["The query identifies the relevant tables, which are 'Rating' and 'Movie'.", "It selects the 'title' from the 'Movie' table and calculates the average of 'stars' from the 'Rating' table.", "A JOIN operation is performed on the 'mID' to link ratings to their corresponding movies.", "The results are grouped by 'mID' to ensure that the average rating is calculated for each movie.", "The results are ordered in descending order based on the average rating, allowing the highest-rated movies to appear first.", "A LIMIT clause is included to restrict the number of results returned, with a placeholder for the user to specify this limit."], "gold_sql": "SELECT T2.title ,  avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY avg(T1.stars) DESC LIMIT 1", "source_tables": ["rating", "movie"], "description": "This virtual table provides a list of movie titles along with their average ratings from the 'Rating' table. The placeholder in the LIMIT clause allows the user to specify the maximum number of results to return, enabling them to control how many top-rated movies they wish to see.", "virtual_table": "SELECT T2.title ,  avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY avg(T1.stars) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2482", "db_id": "movie_1", "question": "Return all reviewer names and movie names together in a single list.", "rationale": ["The query is identifying the relevant tables, which are 'Reviewer' and 'Movie'.", "Select the 'name' column from the 'Reviewer' table.", "Select the 'title' column from the 'Movie' table.", "Use UNION to combine the results from both SELECT statements into a single result set."], "gold_sql": "SELECT name FROM Reviewer UNION SELECT title FROM Movie", "source_tables": ["movie", "reviewer"], "description": "This virtual table combines the names of reviewers and the titles of movies from the 'Reviewer' and 'Movie' tables, respectively. The use of UNION allows for a single list that includes both reviewers and movie titles.", "virtual_table": "SELECT name FROM Reviewer UNION SELECT title FROM Movie"}
{"sample_id": "train.2494", "db_id": "movie_1", "question": "How many movie reviews does each director get?", "rationale": ["The query identifies the relevant tables, which are 'Movie' and 'Rating'.", "It selects the count of ratings and the director's name from the 'Movie' table.", "A JOIN operation is performed on the 'mID' to link the 'Movie' and 'Rating' tables.", "The results are grouped by the director's name to aggregate the count of ratings for each director."], "gold_sql": "SELECT count(*) ,  T1.director FROM Movie AS T1 JOIN Rating AS T2 ON T1.mID  =  T2.mID GROUP BY T1.director", "source_tables": ["rating", "movie"], "description": "This virtual table summarizes the number of ratings received by each movie director from the 'Movie' and 'Rating' tables. The placeholder in the SELECT clause represents the count of ratings, while the director's name is grouped to show the total ratings per director.", "virtual_table": "SELECT count(*) ,  T1.director FROM Movie AS T1 JOIN Rating AS T2 ON T1.mID  =  T2.mID GROUP BY T1.director"}
{"sample_id": "train.2496", "db_id": "movie_1", "question": "Find the movies with the highest average rating. Return the movie titles and average rating.", "rationale": ["The query identifies the relevant tables, which are 'Rating' and 'Movie'.", "It selects the 'title' from the 'Movie' table and calculates the average of 'stars' from the 'Rating' table.", "A JOIN operation is performed on the 'mID' to link ratings to their corresponding movies.", "The results are grouped by 'mID' to ensure that the average rating is calculated for each movie.", "The results are ordered in descending order based on the average rating, allowing the highest-rated movies to appear first.", "A LIMIT clause is included to restrict the number of results returned, with a placeholder for the user to specify this limit."], "gold_sql": "SELECT T2.title ,  avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY avg(T1.stars) DESC LIMIT 1", "source_tables": ["rating", "movie"], "description": "This virtual table provides a list of movie titles along with their average ratings from the 'Rating' table. The placeholder in the LIMIT clause allows the user to specify the maximum number of results to return, enabling them to control how many top-rated movies they wish to see.", "virtual_table": "SELECT T2.title ,  avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY avg(T1.stars) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2516", "db_id": "movie_1", "question": "What are the ids of the movies that are not reviewed by Brittany Harris.", "rationale": ["The query is identifying the relevant table, which is 'Rating'.", "It selects the unique movie identifiers (mID) from the 'Rating' table.", "The EXCEPT clause is used to exclude movies that have been rated by a specific reviewer.", "A JOIN operation is performed between 'Rating' and 'Reviewer' to filter based on the reviewer's name using a placeholder for string values."], "gold_sql": "SELECT mID FROM Rating EXCEPT SELECT T1.mID FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T2.name  =  'Brittany Harris'", "source_tables": ["rating", "reviewer"], "description": "This virtual table identifies the unique movie identifiers from the 'Rating' table that have not been rated by a specific reviewer. The placeholder in the query represents the reviewer's name, allowing users to filter out movies rated by that individual.", "virtual_table": "SELECT mID FROM Rating EXCEPT SELECT T1.mID FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2499", "db_id": "movie_1", "question": "What are the titles and average ratings for all movies that have the lowest average rating?", "rationale": ["The query identifies the relevant tables, which are 'Rating' and 'Movie'.", "It selects the movie title from the 'Movie' table and calculates the average stars from the 'Rating' table.", "The JOIN operation links the two tables based on the movie identifier to ensure the correct ratings are associated with the correct movies.", "The results are grouped by the movie identifier to compute the average rating for each movie.", "The ORDER BY clause sorts the results based on the average stars in ascending order, and the LIMIT clause allows for a specified number of results to be returned."], "gold_sql": "SELECT T2.title ,  avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY avg(T1.stars) LIMIT 1", "source_tables": ["rating", "movie"], "description": "The virtual table summarizes the average star ratings of movies from the 'Movie' table. It joins the 'Rating' table to calculate the average stars given to each movie, grouping the results by movie identifier. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.", "virtual_table": "SELECT T2.title ,  avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY avg(T1.stars) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2460", "db_id": "movie_1", "question": "Find the names of all reviewers who have ratings with a NULL value for the date.", "rationale": ["The query identifies the relevant tables, which are 'Reviewer' and 'Rating'.", "It uses a JOIN operation to combine these tables based on the matching reviewer ID (rID).", "The SELECT DISTINCT statement is used to ensure that only unique reviewer names are returned.", "A condition is added to filter the results based on the specified rating submission date using a placeholder for string values."], "gold_sql": "SELECT DISTINCT name FROM Reviewer AS T1 JOIN Rating AS T2 ON T1.rID  =  T2.rID WHERE ratingDate  =  'null'", "source_tables": ["rating", "reviewer"], "description": "This virtual table provides a list of unique reviewer names from the 'Reviewer' table who have submitted ratings on a specific date. The placeholder in the WHERE clause represents the date when the ratings were submitted.", "virtual_table": "SELECT DISTINCT name FROM Reviewer AS T1 JOIN Rating AS T2 ON T1.rID  =  T2.rID WHERE ratingDate  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2511", "db_id": "movie_1", "question": "What are the titles of all movies that have between 3 and 5 stars?", "rationale": ["The query identifies the relevant tables, which are 'Rating' and 'Movie'.", "It selects the 'title' column from the 'Movie' table.", "A JOIN operation is performed between 'Rating' and 'Movie' on the movie identifier 'mID'.", "A condition is added to filter the ratings based on a specified range of stars using placeholders for numeric values."], "gold_sql": "SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars BETWEEN 3 AND 5", "source_tables": ["rating", "movie"], "description": "This virtual table provides the titles of movies from the 'Movie' table that have received ratings within a specified range of stars. The placeholders in the WHERE clause represent the minimum and maximum star ratings.", "virtual_table": "SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2523", "db_id": "movie_1", "question": "What are the ids of all reviewers who have not given 4 stars at least once?", "rationale": ["The query is identifying the relevant table, which is 'Rating'.", "Select the column to display, 'rID', which represents the reviewer identifier.", "Add a condition to filter the 'stars' column for ratings that are not equal to the specified number using a placeholder for numeric values."], "gold_sql": "SELECT rID FROM Rating WHERE stars != 4", "source_tables": ["rating"], "description": "This virtual table provides a list of reviewer identifiers from the 'Rating' table who have given a rating that is not equal to a specified number of stars. The placeholder in the WHERE clause represents the number of stars to filter the ratings.", "virtual_table": "SELECT rID FROM Rating WHERE stars != [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2522", "db_id": "movie_1", "question": "Find the ids of reviewers who didn't only give 4 star.", "rationale": ["The query is identifying the relevant table, which is 'Rating'.", "Select the column to display, 'rID', which represents the reviewer identifier.", "Add a condition to filter the 'stars' column for ratings that are not equal to the specified number using a placeholder for numeric values."], "gold_sql": "SELECT rID FROM Rating WHERE stars != 4", "source_tables": ["rating"], "description": "This virtual table provides a list of reviewer identifiers from the 'Rating' table who have given a rating that is not equal to a specified number of stars. The placeholder in the WHERE clause represents the number of stars to filter the ratings.", "virtual_table": "SELECT rID FROM Rating WHERE stars != [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3583", "db_id": "music_1", "question": "List the names of all songs that have 4 minute duration or are in English.", "rationale": ["The query identifies the relevant tables, which are 'files' and 'song'.", "It selects the 'song_name' from the 'song' table based on a join with the 'files' table using the 'f_id' column.", "The WHERE clause filters the results based on the duration of the files using a placeholder for string values.", "Additionally, it uses a UNION to include song names from the 'song' table that match a specific language, again using a placeholder for string values."], "gold_sql": "SELECT T2.song_name FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.duration LIKE '4:%' UNION SELECT song_name FROM song WHERE languages  =  'english'", "source_tables": ["files", "song"], "description": "The virtual table provides a list of song titles from the 'files' and 'song' tables based on specific criteria. It retrieves song names associated with files that match a certain duration and also includes song names that are available in a specified language. The placeholders in the query represent the duration and language criteria.", "virtual_table": "SELECT T2.song_name FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.duration LIKE [PLACEHOLDER-TYPE:STRING] UNION SELECT song_name FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3584", "db_id": "music_1", "question": "What are the names of all songs that are approximately 4 minutes long or are in English?", "rationale": ["The query identifies the relevant tables, which are 'files' and 'song'.", "It selects the 'song_name' from the 'song' table based on a join condition with the 'files' table using the 'f_id' column.", "The first part of the query filters songs based on the duration of the files using a placeholder for string values.", "The second part of the query uses a UNION to include song names from the 'song' table that match a specific language, also using a placeholder for string values."], "gold_sql": "SELECT T2.song_name FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.duration LIKE '4:%' UNION SELECT song_name FROM song WHERE languages  =  'english'", "source_tables": ["files", "song"], "description": "The virtual table provides a list of song titles from the 'files' and 'song' tables based on specific criteria. It retrieves song names associated with files that match a certain duration and also includes song names that are available in a specified language. The placeholders in the WHERE clause represent the duration and language criteria.", "virtual_table": "SELECT T2.song_name FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.duration LIKE [PLACEHOLDER-TYPE:STRING] UNION SELECT song_name FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3587", "db_id": "music_1", "question": "What is the language that was used most often in songs with resolution above 500?", "rationale": ["The query identifies the relevant table, which is 'song'.", "Select the column to display, 'artist_name'.", "Add a condition to filter the 'resolution' column for values greater than a specified number using a placeholder for numeric values.", "Group the results by the 'languages' column to aggregate the data based on the languages available for the songs.", "Order the results by the count of songs in descending order to prioritize artists with more songs in the specified languages.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT artist_name FROM song WHERE resolution  >  500 GROUP BY languages ORDER BY count(*) DESC LIMIT 1", "source_tables": ["song"], "description": "The virtual table provides a list of music artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, and ordered by the count of songs in descending order. The placeholders in the query allow users to specify the resolution threshold and the limit on the number of results returned.", "virtual_table": "SELECT artist_name FROM song WHERE resolution  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY languages ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3588", "db_id": "music_1", "question": "What is the name of the artist, for each language, that has the most songs with a higher resolution than 500?", "rationale": ["The query identifies the relevant table, which is 'song'.", "Select the column to display, 'artist_name'.", "Add a condition to filter the 'resolution' column for values greater than a specified number using a placeholder for numeric values.", "Group the results by the 'languages' column to aggregate the data based on the languages available.", "Order the results by the count of songs in descending order to prioritize artists with more songs.", "Limit the number of results returned to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT artist_name FROM song WHERE resolution  >  500 GROUP BY languages ORDER BY count(*) DESC LIMIT 1", "source_tables": ["song"], "description": "The virtual table provides a list of music artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, and ordered by the count of songs in descending order. The placeholders in the query allow users to specify the resolution threshold and the limit on the number of results returned.", "virtual_table": "SELECT artist_name FROM song WHERE resolution  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY languages ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3602", "db_id": "music_1", "question": "What are the maximum duration and resolution of all songs, for each language, ordered alphabetically by language?", "rationale": ["The query identifies the relevant tables, which are 'files' and 'song'.", "It selects the maximum duration from the 'files' table and the maximum resolution from the 'song' table.", "The JOIN operation is used to connect the two tables based on the file identifier 'f_id'.", "The results are grouped by the 'languages' column from the 'song' table to aggregate the data accordingly.", "Finally, the results are ordered by the 'languages' to present them in a structured manner."], "gold_sql": "SELECT max(T1.duration) ,  max(T2.resolution) ,  T2.languages FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.languages ORDER BY T2.languages", "source_tables": ["files", "song"], "description": "This virtual table provides the maximum duration of audio files and their corresponding maximum audio resolution, grouped by the languages in which the songs are available. The placeholders represent the aggregated values for duration and resolution, while the grouping is based on the languages associated with the songs.", "virtual_table": "SELECT max(T1.duration) ,  max(T2.resolution) ,  T2.languages FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.languages ORDER BY T2.languages"}
{"sample_id": "train.3620", "db_id": "music_1", "question": "What are the top 3 artists with the largest number of songs in the language Bangla?", "rationale": ["The query identifies the relevant tables, which are 'artist' and 'song'.", "It selects the 'artist_name' from the 'artist' table.", "A JOIN operation is performed on the 'artist_name' column to link the two tables.", "A condition is added to filter the songs based on the specified language using a placeholder for string values.", "The results are grouped by 'artist_name' to aggregate the data.", "The results are ordered by the count of songs in descending order to show the most prolific artists first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.languages  =  'bangla' GROUP BY T2.artist_name ORDER BY count(*) DESC LIMIT 3", "source_tables": ["artist", "song"], "description": "This virtual table lists the names of artists from the 'artist' table who have songs available in a specific language. The query joins the 'artist' and 'song' tables based on the artist's name, filters the results by the specified language, groups the results by artist name, and orders them by the number of songs in descending order. The placeholders represent the language and the limit on the number of results returned.", "virtual_table": "SELECT T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.languages  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T2.artist_name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3604", "db_id": "music_1", "question": "What is the shortest and most poorly rated song for each genre, ordered alphabetically by genre?", "rationale": ["The query identifies the relevant tables, which are 'files' and 'song'.", "It selects the minimum duration from the 'files' table and the minimum rating from the 'song' table, along with the genre of the song.", "The JOIN operation links the two tables based on the file identifier, ensuring that the data corresponds correctly between audio files and songs.", "The results are grouped by the genre of the song to aggregate the data accordingly, and ordered by the genre for better readability."], "gold_sql": "SELECT min(T1.duration) ,  min(T2.rating) ,  T2.genre_is FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.genre_is ORDER BY T2.genre_is", "source_tables": ["files", "song"], "description": "This virtual table provides the minimum duration of audio files and the minimum rating of songs grouped by their genre. The placeholders represent the necessary fields from the 'files' and 'song' tables, allowing users to analyze the relationship between audio file durations and song ratings across different genres.", "virtual_table": "SELECT min(T1.duration) ,  min(T2.rating) ,  T2.genre_is FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.genre_is ORDER BY T2.genre_is"}
{"sample_id": "train.3569", "db_id": "music_1", "question": "Find the distinct names of all songs that have a higher resolution than some songs in English.", "rationale": ["The query identifies the relevant table, which is 'song'.", "Select distinct song titles to avoid duplicates.", "Add a condition to filter the 'resolution' column to be greater than the minimum resolution found in a subquery.", "The subquery selects the minimum resolution from the 'song' table where the 'languages' column matches a specified language using a placeholder for string values."], "gold_sql": "SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  'english')", "source_tables": ["song"], "description": "The virtual table lists distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the subquery represents the language for which the minimum resolution is being queried.", "virtual_table": "SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.3575", "db_id": "music_1", "question": "List the name and gender for all artists who released songs in March.", "rationale": ["The query identifies the relevant tables, which are 'artist' and 'song'.", "It selects the columns to display, 'artist_name' and 'gender' from the 'artist' table.", "A JOIN operation is performed on the 'artist_name' column to link the 'artist' and 'song' tables.", "A condition is added to filter the results based on the 'releasedate' column from the 'song' table using a placeholder for string values."], "gold_sql": "SELECT T1.artist_name ,  T1.gender FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.releasedate LIKE '%Mar%'", "source_tables": ["artist", "song"], "description": "This virtual table provides the names and genders of artists from the 'artist' table who have released songs within a specific date range. The placeholder in the WHERE clause represents the release date pattern to filter the results.", "virtual_table": "SELECT T1.artist_name ,  T1.gender FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.releasedate LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3570", "db_id": "music_1", "question": "What are the different names for all songs that have a higher resolution than English songs?", "rationale": ["The query identifies the relevant table, which is 'song'.", "It selects distinct song titles from the 'song' table.", "A subquery is used to find the minimum resolution of songs that are available in a specified language, using a placeholder for string values in the WHERE clause of the subquery."], "gold_sql": "SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  'english')", "source_tables": ["song"], "description": "The virtual table lists distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the subquery represents the language for which the minimum resolution is being queried.", "virtual_table": "SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.3550", "db_id": "music_1", "question": "How many songs, on average, are sung by a female artist?", "rationale": ["The query identifies the relevant tables, which are 'artist' and 'song'.", "It uses a JOIN operation to link the two tables based on the 'artist_name' column.", "The SELECT statement calculates the average of the 'rating' column from the 'song' table.", "A condition is added to filter the results based on the 'gender' column from the 'artist' table, using a placeholder for string values."], "gold_sql": "SELECT avg(T2.rating) FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  'Female'", "source_tables": ["artist", "song"], "description": "This virtual table calculates the average rating of songs performed by artists of a specific gender. It combines data from the 'artist' and 'song' tables, using the artist's name as the linking key. The placeholder in the WHERE clause represents the gender of the artists being queried.", "virtual_table": "SELECT avg(T2.rating) FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3585", "db_id": "music_1", "question": "What is the language used most often in the songs?", "rationale": ["The query identifies the relevant table, which is 'song'.", "It selects the 'languages' column to display.", "The GROUP BY clause is used to group the results by 'languages'.", "The ORDER BY clause sorts the grouped results by their count in descending order to show the most popular languages first.", "The LIMIT clause includes a placeholder for the user to specify how many languages they want to retrieve."], "gold_sql": "SELECT languages FROM song GROUP BY languages ORDER BY count(*) DESC LIMIT 1", "source_tables": ["song"], "description": "This virtual table provides a list of languages in which songs are available, grouped by language and ordered by their popularity. The placeholder in the LIMIT clause allows the user to specify the maximum number of languages to retrieve.", "virtual_table": "SELECT languages FROM song GROUP BY languages ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3591", "db_id": "music_1", "question": "Find the names of songs whose genre is modern or language is English.", "rationale": ["The query identifies the relevant table, which is 'song'.", "Select the column to display, 'song_name'.", "Add conditions to filter the 'genre_is' and 'languages' columns for the specified genre and language using placeholders for string values."], "gold_sql": "SELECT song_name FROM song WHERE genre_is  =  'modern' OR languages  =  'english'", "source_tables": ["song"], "description": "This virtual table provides a list of song titles from the 'song' table that belong to a specific genre or are available in a specific language. The placeholders in the WHERE clause represent the genre and language criteria for filtering the songs.", "virtual_table": "SELECT song_name FROM song WHERE genre_is  =  [PLACEHOLDER-TYPE:STRING] OR languages  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3600", "db_id": "music_1", "question": "What is the maximum and minimum resolution of all songs that are approximately 3 minutes long?", "rationale": ["The query identifies the relevant tables, which are 'files' and 'song'.", "It uses a JOIN operation to connect these tables based on the file identifier 'f_id'.", "The SELECT statement retrieves the maximum and minimum values of the 'resolution' column from the 'song' table.", "A condition is added to filter the results based on the 'duration' column from the 'files' table using a placeholder for string values."], "gold_sql": "SELECT max(T2.resolution) ,  min(T2.resolution) FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.duration LIKE '3:%'", "source_tables": ["files", "song"], "description": "The virtual table provides the maximum and minimum audio resolutions of songs from the 'song' table that are associated with files in the 'files' table, filtered by a specific duration. The placeholder in the WHERE clause represents the duration of the audio files.", "virtual_table": "SELECT max(T2.resolution) ,  min(T2.resolution) FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.duration LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3565", "db_id": "music_1", "question": "Return the gender and name of artist who produced the song with the lowest resolution.", "rationale": ["The query identifies the relevant tables, which are 'artist' and 'song'.", "It selects the 'gender' and 'artist_name' columns from the 'artist' table (aliased as T1).", "A JOIN operation is performed between the 'artist' table and the 'song' table (aliased as T2) on the 'artist_name' column to combine related data.", "The results are ordered by the 'resolution' column from the 'song' table to sort the output based on audio quality.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.gender ,  T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.resolution LIMIT 1", "source_tables": ["artist", "song"], "description": "This virtual table provides information about music artists and their gender, specifically focusing on the artists who have songs in the database. The data is organized by joining the 'artist' and 'song' tables based on the artist's name. The results are sorted by the audio resolution of the songs, and a limit is applied to control the number of records returned, represented by a numeric placeholder.", "virtual_table": "SELECT T1.gender ,  T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.resolution LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3541", "db_id": "music_1", "question": "What is the name of the artist who produced the shortest song?", "rationale": ["The query identifies the relevant tables, which are 'song' and 'files'.", "It selects the 'artist_name' from the 'song' table (aliased as T1).", "A JOIN operation is performed between 'song' and 'files' on the 'f_id' column to link songs with their corresponding files.", "The results are ordered by the 'duration' column from the 'files' table (aliased as T2).", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.artist_name FROM song AS T1 JOIN files AS T2 ON T1.f_id  =  T2.f_id ORDER BY T2.duration LIMIT 1", "source_tables": ["files", "song"], "description": "This virtual table lists the names of artists from the 'song' table, joined with the 'files' table based on the unique file identifier. The results are ordered by the duration of the audio files, and the number of results returned is limited by a placeholder for numeric values.", "virtual_table": "SELECT T1.artist_name FROM song AS T1 JOIN files AS T2 ON T1.f_id  =  T2.f_id ORDER BY T2.duration LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3551", "db_id": "music_1", "question": "What is the most popular file format?", "rationale": ["The query identifies the relevant table, which is 'files'.", "It selects the 'formats' column to display the different audio file formats.", "The GROUP BY clause is used to group the results by the 'formats' column, ensuring that each format is listed only once.", "The ORDER BY clause sorts the grouped formats based on their count in descending order, showing the most common formats first.", "The LIMIT clause uses a placeholder to allow the user to specify how many formats they want to retrieve."], "gold_sql": "SELECT formats FROM files GROUP BY formats ORDER BY COUNT (*) DESC LIMIT 1", "source_tables": ["files"], "description": "The virtual table provides a list of audio file formats available in the 'files' table, grouped by format type. The placeholder in the LIMIT clause allows the user to specify the maximum number of formats to retrieve, enabling them to control the output size based on their needs.", "virtual_table": "SELECT formats FROM files GROUP BY formats ORDER BY COUNT (*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3529", "db_id": "music_1", "question": "What is the name of the song that was released in the most recent year?", "rationale": ["The query identifies the relevant table, which is 'song'.", "Selects the columns to display, 'song_name' and 'releasedate'.", "Orders the results by 'releasedate' in descending order to show the latest songs first.", "Limits the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT song_name ,  releasedate FROM song ORDER BY releasedate DESC LIMIT 1", "source_tables": ["song"], "description": "This virtual table provides a list of song titles along with their release dates from the 'song' table, sorted by the most recent release date. The placeholder in the LIMIT clause indicates the maximum number of records to return.", "virtual_table": "SELECT song_name ,  releasedate FROM song ORDER BY releasedate DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3530", "db_id": "music_1", "question": "What is the name of the song that was released most recently?", "rationale": ["The query identifies the relevant table, which is 'song'.", "Selects the columns to display, 'song_name' and 'releasedate'.", "Orders the results by 'releasedate' in descending order to show the latest songs first.", "Limits the number of results returned based on a numeric placeholder."], "gold_sql": "SELECT song_name ,  releasedate FROM song ORDER BY releasedate DESC LIMIT 1", "source_tables": ["song"], "description": "This virtual table provides a list of song titles along with their release dates from the 'song' table, ordered by the most recent release date. The placeholder in the LIMIT clause indicates the maximum number of records to return.", "virtual_table": "SELECT song_name ,  releasedate FROM song ORDER BY releasedate DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3546", "db_id": "music_1", "question": "What is the count of the songs that last approximately 4 minutes?", "rationale": ["The query is identifying the relevant table, which is 'files'.", "The count function is used to get the total number of records that meet the specified condition.", "Add a condition to filter the 'duration' column using a placeholder for string values to allow for flexible duration matching."], "gold_sql": "SELECT count(*) FROM files WHERE duration LIKE '4:%'", "source_tables": ["files"], "description": "This virtual table provides a count of audio files from the 'files' table that match a specific duration pattern. The placeholder in the WHERE clause represents the duration criteria to filter the results.", "virtual_table": "SELECT count(*) FROM files WHERE duration LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3531", "db_id": "music_1", "question": "What is the id of the longest song?", "rationale": ["The query is identifying the relevant table, which is 'files'.", "Select the column to display, 'f_id', which is the unique identifier for the file.", "Order the results by the 'duration' column in descending order to get the longest files first.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT f_id FROM files ORDER BY duration DESC LIMIT 1", "source_tables": ["files"], "description": "This virtual table provides a list of file identifiers from the 'files' table, ordered by the duration of the audio files in descending order. The placeholder in the LIMIT clause indicates the maximum number of file identifiers to return.", "virtual_table": "SELECT f_id FROM files ORDER BY duration DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3543", "db_id": "music_1", "question": "What are the names and countries of origin for the artists who produced the top three highly rated songs.", "rationale": ["The query identifies the relevant tables, which are 'artist' and 'song'.", "It selects the columns 'artist_name' and 'country' from the 'artist' table.", "A JOIN operation is performed between the 'artist' table and the 'song' table based on the 'artist_name' column to link artists with their songs.", "The results are ordered by the 'rating' column from the 'song' table in descending order to show the highest-rated songs first.", "The LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.artist_name ,  T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.rating DESC LIMIT 3", "source_tables": ["artist", "song"], "description": "This virtual table provides a list of artists along with their countries, derived from the 'artist' table. The results are filtered to include only those artists who have songs in the 'song' table, and are ordered by the song ratings in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.", "virtual_table": "SELECT T1.artist_name ,  T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.rating DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6191", "db_id": "music_4", "question": "Show the famous titles of the artists with both volumes that lasted more than 2 weeks on top and volumes that lasted less than 2 weeks on top.", "rationale": ["The query is identifying the relevant tables, which are 'artist' and 'volume'.", "It selects the 'Famous_Title' from the 'artist' table.", "The join condition links the 'artist' table with the 'volume' table using 'Artist_ID'.", "The first part of the query filters for songs that have been on top for more than a specified number of weeks using a placeholder for numeric values.", "The second part of the query filters for songs that have been on top for less than another specified number of weeks using a different placeholder for numeric values.", "The INTERSECT operator is used to find common song titles that meet both conditions."], "gold_sql": "SELECT T1.Famous_Title FROM artist AS T1 JOIN volume AS T2 ON T1.Artist_ID  =  T2.Artist_ID WHERE T2.Weeks_on_Top  >  2 INTERSECT SELECT T1.Famous_Title FROM artist AS T1 JOIN volume AS T2 ON T1.Artist_ID  =  T2.Artist_ID WHERE T2.Weeks_on_Top  <  2", "source_tables": ["artist", "volume"], "description": "This virtual table identifies the famous titles of songs by artists who have had varying success on the charts. It retrieves titles of songs that have spent more than a specified number of weeks at the top and also those that have spent less than another specified number of weeks. The placeholders represent the numeric values for the weeks spent at the top.", "virtual_table": "SELECT T1.Famous_Title FROM artist AS T1 JOIN volume AS T2 ON T1.Artist_ID  =  T2.Artist_ID WHERE T2.Weeks_on_Top  >  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T1.Famous_Title FROM artist AS T1 JOIN volume AS T2 ON T1.Artist_ID  =  T2.Artist_ID WHERE T2.Weeks_on_Top  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6156", "db_id": "music_4", "question": "Return the categories of music festivals that have the result \"Awarded\".", "rationale": ["The query identifies the relevant table, which is 'music_festival'.", "Select the column to display, 'Category'.", "Add a condition to filter the 'RESULT' column for the specified result using a placeholder for string values."], "gold_sql": "SELECT Category FROM music_festival WHERE RESULT  =  'Awarded'", "source_tables": ["music_festival"], "description": "The virtual table provides information about the categories of awards or recognitions from music festivals based on specific results. The placeholder in the WHERE clause represents the outcome of the festival participation that is being queried.", "virtual_table": "SELECT Category FROM music_festival WHERE RESULT  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6165", "db_id": "music_4", "question": "Please show the date of ceremony of the volumes that last more than 2 weeks on top.", "rationale": ["The query identifies the relevant tables, which are 'music_festival' and 'volume'.", "It selects the 'Date_of_ceremony' from the 'music_festival' table.", "A JOIN operation is performed between 'music_festival' and 'volume' on the 'Volume' and 'Volume_ID' columns to link the two tables.", "A condition is added to filter the results based on the 'Weeks_on_Top' column from the 'volume' table, using a placeholder for numeric values."], "gold_sql": "SELECT T1.Date_of_ceremony FROM music_festival AS T1 JOIN volume AS T2 ON T1.Volume  =  T2.Volume_ID WHERE T2.Weeks_on_Top  >  2", "source_tables": ["music_festival", "volume"], "description": "The virtual table provides the dates of ceremonies from the 'music_festival' table for volumes that have songs which stayed at the top for a specified number of weeks. The placeholder in the WHERE clause represents the minimum number of weeks a song must have been at the top.", "virtual_table": "SELECT T1.Date_of_ceremony FROM music_festival AS T1 JOIN volume AS T2 ON T1.Volume  =  T2.Volume_ID WHERE T2.Weeks_on_Top  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6162", "db_id": "music_4", "question": "What are the the songs in volumes, listed in ascending order?", "rationale": ["The query identifies the relevant table, which is 'volume'.", "Select the column to display, 'Song'.", "Add an ORDER BY clause to sort the results based on the 'Song' column."], "gold_sql": "SELECT Song FROM volume ORDER BY Song", "source_tables": ["volume"], "description": "The virtual table provides a list of songs from the 'volume' table, ordered by the song identifier. This allows users to see the songs in a sequential manner based on their identifiers.", "virtual_table": "SELECT Song FROM volume ORDER BY Song"}
{"sample_id": "train.6184", "db_id": "music_4", "question": "Return the result that is most frequent at music festivals.", "rationale": ["The query identifies the relevant table, which is 'music_festival'.", "It selects the 'RESULT' column to display the outcomes of the festivals.", "The results are grouped by the 'RESULT' column to aggregate similar outcomes.", "The results are ordered by the count of each result type in descending order to show the most common outcomes first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT RESULT FROM music_festival GROUP BY RESULT ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["music_festival"], "description": "The virtual table summarizes the results of music festivals, showing the outcomes grouped by their result type. The placeholder in the LIMIT clause allows the user to specify the maximum number of results to return, enabling them to control the output size based on their needs.", "virtual_table": "SELECT RESULT FROM music_festival GROUP BY RESULT ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6188", "db_id": "music_4", "question": "Return the song in the volume that has spent the most weeks on top?", "rationale": ["The query identifies the relevant table, which is 'volume'.", "Select the 'Song' column to display the songs.", "Order the results by 'Weeks_on_Top' in descending order to show the most successful songs first.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT Song FROM volume ORDER BY Weeks_on_Top DESC LIMIT 1", "source_tables": ["volume"], "description": "The virtual table displays the songs from the 'volume' table, sorted by the number of weeks they have spent at the top of the charts. The placeholder in the LIMIT clause allows the user to specify the maximum number of songs to retrieve.", "virtual_table": "SELECT Song FROM volume ORDER BY Weeks_on_Top DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4443", "db_id": "network_2", "question": "What are the different names and ages of every friend of either Dan or alice?", "rationale": ["The query identifies the relevant tables, which are 'Person' and 'PersonFriend'.", "It selects distinct names and ages from the 'Person' table.", "A JOIN operation is performed on the 'Person' and 'PersonFriend' tables based on the person's name.", "The WHERE clause filters the results to include only those individuals who are friends with the specified names using placeholders for string values."], "gold_sql": "SELECT DISTINCT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Dan' OR T2.friend  =  'Alice'", "source_tables": ["personfriend", "person"], "description": "This virtual table provides a distinct list of names and ages of individuals from the 'Person' table who are friends with specific individuals. The placeholders in the WHERE clause represent the names of the friends being queried.", "virtual_table": "SELECT DISTINCT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] OR T2.friend  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4474", "db_id": "network_2", "question": "Find the name, age, and job title of persons who are friends with Alice for the longest years.", "rationale": ["The query identifies the relevant tables, 'Person' and 'PersonFriend'.", "It selects the columns to display: 'name', 'age', and 'job' from the 'Person' table.", "A JOIN operation is performed on the 'name' column to link the two tables based on friendships.", "Conditions are added to filter the results for a specific friend using a placeholder for string values.", "A subquery is included to find the most recent year of friendship established for the specified friend."], "gold_sql": "SELECT T1.name ,  T1.age ,  T1.job FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend =  'Alice' AND T2.year  =  (SELECT max(YEAR) FROM PersonFriend WHERE friend =  'Alice')", "source_tables": ["personfriend", "person"], "description": "This virtual table provides the names, ages, and job titles of individuals from the 'Person' table who have a specific friend, along with the most recent year of friendship established. The placeholders in the WHERE clause represent the friend's name and the year of friendship.", "virtual_table": "SELECT T1.name ,  T1.age ,  T1.job FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend =  [PLACEHOLDER-TYPE:STRING] AND T2.year  =  (SELECT max(YEAR) FROM PersonFriend WHERE friend =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.4440", "db_id": "network_2", "question": "Find the name and age of the person who is a friend of both Dan and Alice.", "rationale": ["The query identifies the relevant tables, which are 'Person' and 'PersonFriend'.", "It selects the columns to display, 'name' and 'age', from the 'Person' table.", "The JOIN operation is used to connect 'Person' and 'PersonFriend' based on the person's name.", "The WHERE clause filters the results to include only those individuals who are friends with the first specified friend.", "The INTERSECT operation is used to find individuals who are also friends with the second specified friend, ensuring mutual friendship."], "gold_sql": "SELECT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Dan' INTERSECT SELECT T1.name ,   T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Alice'", "source_tables": ["personfriend", "person"], "description": "This virtual table provides the names and ages of individuals from the 'Person' table who share mutual friends. The placeholders in the WHERE clause represent the names of the friends being compared, allowing users to find individuals who are friends with both specified friends.", "virtual_table": "SELECT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.name ,   T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4448", "db_id": "network_2", "question": "Find the name of the person who has no student friends.", "rationale": ["The query identifies the relevant tables, which are 'Person' and 'PersonFriend'.", "It selects the 'name' column from the 'Person' table.", "The EXCEPT clause is used to exclude names of friends from the 'Person' table who have a specific job title.", "A JOIN operation is performed between 'Person' and 'PersonFriend' to find friends of individuals.", "The WHERE clause filters the friends based on the specified job title using a placeholder for string values."], "gold_sql": "SELECT name FROM person EXCEPT SELECT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.job  =  'student'", "source_tables": ["personfriend", "person"], "description": "This virtual table lists the names of individuals from the 'Person' table who do not have any friends that work in a specific occupation. The placeholder in the query represents the job title that is used to filter out friends based on their occupation.", "virtual_table": "SELECT name FROM person EXCEPT SELECT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.job  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4442", "db_id": "network_2", "question": "Find the name and age of the person who is a friend of Dan or Alice.", "rationale": ["The query identifies the relevant tables, which are 'Person' and 'PersonFriend'.", "It selects distinct names and ages from the 'Person' table.", "A JOIN operation is performed between 'Person' and 'PersonFriend' on the name column to link friends to their respective persons.", "The WHERE clause filters the results to include only those persons who are friends with the specified individuals, using placeholders for the friends' names."], "gold_sql": "SELECT DISTINCT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Dan' OR T2.friend  =  'Alice'", "source_tables": ["personfriend", "person"], "description": "This virtual table provides a list of distinct names and ages of individuals from the 'Person' table who are friends with specific individuals. The placeholders in the WHERE clause represent the names of the friends being queried.", "virtual_table": "SELECT DISTINCT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] OR T2.friend  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4446", "db_id": "network_2", "question": "Find the name of the person who has friends with age above 40 but not under age 30?", "rationale": ["The query starts by selecting names from the 'Person' table, aliased as T1.", "It joins the 'PersonFriend' table, aliased as T2, on the condition that the names match.", "The first part of the WHERE clause filters friends who are older than a specified age using a subquery.", "The EXCEPT clause is used to exclude names from the result where friends are younger than the specified age, again using a subquery."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  40) EXCEPT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  30)", "source_tables": ["personfriend", "person"], "description": "This virtual table identifies individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends younger than that age. The placeholders in the query represent the age criteria for filtering friends.", "virtual_table": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  [PLACEHOLDER-TYPE:NUMBER]) EXCEPT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.4447", "db_id": "network_2", "question": "What are the names of the people who are older 40 but no friends under age 30?", "rationale": ["The query starts by selecting names from the 'Person' table, aliased as T1.", "It joins the 'PersonFriend' table, aliased as T2, on the condition that the names match.", "The first part of the WHERE clause filters friends who are older than a specified age using a placeholder for numeric values.", "The EXCEPT clause is used to exclude names from the result where friends are younger than the specified age, again using a placeholder for numeric values."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  40) EXCEPT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  30)", "source_tables": ["personfriend", "person"], "description": "This virtual table identifies individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that age. The placeholders in the query represent the age criteria for filtering friends.", "virtual_table": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  [PLACEHOLDER-TYPE:NUMBER]) EXCEPT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.4481", "db_id": "network_2", "question": "What is the total number of people who have no friends living in Austin?", "rationale": ["The query identifies the relevant table, which is 'PersonFriend'.", "It counts distinct names to determine how many individuals have friends not residing in a specific city.", "A subquery is used to filter out friends based on their city of residence, using a placeholder for the city name."], "gold_sql": "SELECT count(DISTINCT name) FROM PersonFriend WHERE friend NOT IN (SELECT name FROM person WHERE city  =  'Austin')", "source_tables": ["personfriend", "person"], "description": "This virtual table provides a count of distinct individuals from the 'PersonFriend' table who have friends that do not reside in a specified city. The placeholder in the WHERE clause represents the name of the city to filter out friends based on their residence.", "virtual_table": "SELECT count(DISTINCT name) FROM PersonFriend WHERE friend NOT IN (SELECT name FROM person WHERE city  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.4469", "db_id": "network_2", "question": "Which friend of Zach has the longest-lasting friendship?", "rationale": ["The query identifies the relevant table, which is 'PersonFriend'.", "Select the column to display, 'friend'.", "Add a condition to filter the 'name' column for the specified person's name using a placeholder for string values.", "Include a subquery to find the maximum year of friendship established for that person, ensuring that only the most recent friendship is selected."], "gold_sql": "SELECT friend FROM PersonFriend WHERE name =  'Zach' AND YEAR  =  (SELECT max(YEAR) FROM PersonFriend WHERE name =  'Zach')", "source_tables": ["personfriend"], "description": "This virtual table provides a list of friends for a specific person from the 'PersonFriend' table, filtered to show only the most recent friendship established in a given year. The placeholders in the WHERE clause represent the person's name and the year of the most recent friendship.", "virtual_table": "SELECT friend FROM PersonFriend WHERE name =  [PLACEHOLDER-TYPE:STRING] AND YEAR  =  (SELECT max(YEAR) FROM PersonFriend WHERE name =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.4408", "db_id": "network_2", "question": "Who is the oldest person?", "rationale": ["The query identifies the relevant table, which is 'Person'.", "It selects the 'name' column to display the names of the individuals.", "A subquery is used to find the maximum age from the 'Person' table.", "The WHERE clause filters the results to include only those individuals whose age matches the maximum age found in the subquery."], "gold_sql": "SELECT name FROM Person WHERE age  =  (SELECT max(age) FROM person)", "source_tables": ["person"], "description": "This virtual table provides the names of individuals from the 'Person' table who are the oldest among all persons listed. The subquery identifies the maximum age, and the placeholder in the WHERE clause is used to filter based on that age.", "virtual_table": "SELECT name FROM Person WHERE age  =  (SELECT max(age) FROM person)"}
{"sample_id": "train.4411", "db_id": "network_2", "question": "What is the name of the oldest student?", "rationale": ["The query identifies the relevant table, which is 'Person'.", "It selects the 'name' column to display the names of individuals.", "The first condition filters the results based on a specific job title using a placeholder for string values.", "The second condition uses a subquery to find the maximum age of individuals with the same job title, ensuring that only the oldest individual(s) are selected."], "gold_sql": "SELECT name FROM Person WHERE job  =  'student' AND age  =  (SELECT max(age) FROM person WHERE job  =  'student' )", "source_tables": ["person"], "description": "This virtual table provides the names of individuals from the 'Person' table who have a specific job title and are the oldest among those with the same job. The placeholders in the WHERE clause represent the job title being queried.", "virtual_table": "SELECT name FROM Person WHERE job  =  [PLACEHOLDER-TYPE:STRING] AND age  =  (SELECT max(age) FROM person WHERE job  =  [PLACEHOLDER-TYPE:STRING] )"}
{"sample_id": "train.4438", "db_id": "network_2", "question": "Find the name and age of all males in order of their age.", "rationale": ["The query identifies the relevant table, which is 'Person'.", "It selects the 'name' column to display the names of individuals.", "A condition is added to filter the results based on the 'gender' column using a placeholder for string values.", "The results are ordered by the 'age' column to present the names in a specific sequence."], "gold_sql": "SELECT name FROM Person WHERE gender  =  'male' ORDER BY age", "source_tables": ["person"], "description": "This virtual table lists the names of individuals from the 'Person' table who match a specific gender. The results are ordered by the age of the individuals, allowing for easy identification of names based on gender and age criteria.", "virtual_table": "SELECT name FROM Person WHERE gender  =  [PLACEHOLDER-TYPE:STRING] ORDER BY age"}
{"sample_id": "train.4457", "db_id": "network_2", "question": "What are the names of all females who are friends with Zach?", "rationale": ["The query identifies the relevant tables, which are 'Person' and 'PersonFriend'.", "It selects the 'name' column from the 'Person' table.", "A JOIN operation is performed between 'Person' and 'PersonFriend' on the 'name' column to link friends to their respective persons.", "Conditions are added to filter the results based on the specified friend's name and the gender of the individuals using placeholders for string values."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Zach' AND T1.gender  =  'female'", "source_tables": ["personfriend", "person"], "description": "This virtual table provides the names of individuals from the 'Person' table who have a specific friend and belong to a certain gender. The placeholders in the WHERE clause represent the friend's name and the gender of the individuals.", "virtual_table": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] AND T1.gender  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4463", "db_id": "network_2", "question": "What are the names of all friends who are from New York?", "rationale": ["The query identifies the relevant tables, which are 'Person' and 'PersonFriend'.", "It selects the 'name' column from the 'PersonFriend' table, which represents the friends' names.", "A JOIN operation is performed to connect 'Person' and 'PersonFriend' based on the condition that the friend's name matches the name in the 'Person' table.", "A WHERE clause is added to filter the results based on the specified city using a placeholder for string values."], "gold_sql": "SELECT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.city  =  'new york city'", "source_tables": ["personfriend", "person"], "description": "This virtual table lists the names of friends of individuals who reside in a specific city. The query joins the 'Person' table with the 'PersonFriend' table to find friends based on the city of residence, with a placeholder for the city name.", "virtual_table": "SELECT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.city  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2057", "db_id": "party_people", "question": "Show all party names and the number of members in each party.", "rationale": ["The query identifies the relevant tables, which are 'Member' and 'party'.", "It selects the 'party_name' from the 'party' table and counts the number of members from the 'Member' table.", "A JOIN operation is performed on the 'party_id' to link members to their respective parties.", "The results are grouped by 'party_id' to ensure that the count reflects the number of members per party."], "gold_sql": "SELECT T2.party_name ,  count(*) FROM Member AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id", "source_tables": ["party", "member"], "description": "This virtual table provides a summary of the number of members associated with each political party. It combines data from the 'Member' and 'party' tables, where the party's name is displayed alongside the count of its members. The grouping is done by the party identifier to aggregate the member counts accurately.", "virtual_table": "SELECT T2.party_name ,  count(*) FROM Member AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id"}
{"sample_id": "train.2072", "db_id": "party_people", "question": "How many events are there for each party?", "rationale": ["The query identifies the relevant tables, which are 'party_events' and 'party'.", "It selects the 'party_name' from the 'party' table and counts the number of events from the 'party_events' table.", "A JOIN operation is performed on the 'party_id' to link events to their respective parties.", "The results are grouped by 'party_id' to ensure that the count of events is calculated for each party individually."], "gold_sql": "SELECT T2.party_name ,  count(*) FROM party_events AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id", "source_tables": ["party", "party_events"], "description": "This virtual table summarizes the number of events organized by each political party. It combines data from the 'party_events' table and the 'party' table, where each party's name is displayed alongside the count of events they have hosted. The grouping is done by the party identifier to aggregate the event counts accurately.", "virtual_table": "SELECT T2.party_name ,  count(*) FROM party_events AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id"}
{"sample_id": "train.2082", "db_id": "party_people", "question": "Count the number of Annual Meeting events that took place in the region of the United Kingdom.", "rationale": ["The query identifies the relevant tables: 'region', 'party', and 'party_events'.", "It uses JOIN operations to connect these tables based on their foreign key relationships: 'region_id' from 'party' and 'party_id' from 'party_events'.", "The SELECT statement counts the total number of events that match the specified criteria.", "The WHERE clause filters the results based on the region's name and the event's name, using placeholders for string values."], "gold_sql": "SELECT count(*) FROM region AS t1 JOIN party AS t2 ON t1.region_id  =  t2.region_id JOIN party_events AS t3 ON t2.party_id  =  t3.party_id WHERE t1.region_name  =  'United Kingdom' AND t3.Event_Name  =  'Annaual Meeting'", "source_tables": ["party", "party_events", "region"], "description": "This virtual table provides a count of party events associated with a specific region and event name. It combines data from the 'region', 'party', and 'party_events' tables, filtering by the region's name and the event's name using placeholders for both values.", "virtual_table": "SELECT count(*) FROM region AS t1 JOIN party AS t2 ON t1.region_id  =  t2.region_id JOIN party_events AS t3 ON t2.party_id  =  t3.party_id WHERE t1.region_name  =  [PLACEHOLDER-TYPE:STRING] AND t3.Event_Name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2050", "db_id": "party_people", "question": "Which ministers are not a part of the Progress Party?", "rationale": ["The query identifies the relevant table, which is 'party'.", "Select the column to display, 'minister'.", "Add a condition to filter the 'party_name' column to exclude the specified party name using a placeholder for string values."], "gold_sql": "SELECT minister FROM party WHERE party_name != 'Progress Party'", "source_tables": ["party"], "description": "This virtual table provides the list of ministers from the 'party' table who are associated with political parties that do not match a specified party name. The placeholder in the WHERE clause represents the name of the party to be excluded.", "virtual_table": "SELECT minister FROM party WHERE party_name != [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.315", "db_id": "product_catalog", "question": "What are the entry names of catalog with the attribute possessed by most entries.", "rationale": ["The query identifies the relevant tables, 'Catalog_Contents' and 'Catalog_Contents_Additional_Attributes'.", "It selects the 'catalog_entry_name' from 'Catalog_Contents'.", "A JOIN operation is performed to link 'Catalog_Contents' with 'Catalog_Contents_Additional_Attributes' based on the 'catalog_entry_id'.", "A subquery is used to find the most common 'attribute_value' from 'Catalog_Contents_Additional_Attributes', grouping by 'attribute_value' and ordering by count, with a limit specified by a placeholder for numeric values."], "gold_sql": "SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.attribute_value  =  (SELECT attribute_value FROM Catalog_Contents_Additional_Attributes GROUP BY attribute_value ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["catalog_contents", "catalog_contents_additional_attributes"], "description": "This virtual table provides the names of catalog entries from the 'Catalog_Contents' table that are associated with specific additional attributes. The query filters these entries based on the most frequently occurring attribute values from the 'Catalog_Contents_Additional_Attributes' table, with a placeholder indicating the limit for the number of results to return.", "virtual_table": "SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.attribute_value  =  (SELECT attribute_value FROM Catalog_Contents_Additional_Attributes GROUP BY attribute_value ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.337", "db_id": "product_catalog", "question": "Find the dates on which more than one revisions were made.", "rationale": ["The query identifies the relevant table, which is 'Catalogs'.", "It selects the 'date_of_latest_revision' column to display the latest revision dates.", "The results are grouped by 'date_of_latest_revision' to aggregate the data based on this column.", "The HAVING clause is used to filter the groups, ensuring only those with a count greater than a specified number are included, using a placeholder for numeric values."], "gold_sql": "SELECT date_of_latest_revision FROM Catalogs GROUP BY date_of_latest_revision HAVING count(*)  >  1", "source_tables": ["catalogs"], "description": "This virtual table provides the latest revision dates of catalogs from the 'Catalogs' table, grouped by the revision date. The placeholder in the HAVING clause represents the minimum count of catalogs that must share the same revision date to be included in the results.", "virtual_table": "SELECT date_of_latest_revision FROM Catalogs GROUP BY date_of_latest_revision HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.312", "db_id": "product_catalog", "question": "Find the catalog publisher that has the most catalogs.", "rationale": ["The query identifies the relevant table, which is 'Catalogs'.", "It selects the 'catalog_publisher' column to display the names of publishers.", "The GROUP BY clause is used to group the results by 'catalog_publisher'.", "The ORDER BY clause sorts the grouped results based on the count of catalogs for each publisher in descending order.", "The LIMIT clause uses a placeholder to allow the user to specify how many publishers to return."], "gold_sql": "SELECT catalog_publisher FROM catalogs GROUP BY catalog_publisher ORDER BY count(*) DESC LIMIT 1", "source_tables": ["catalogs"], "description": "This virtual table provides a list of catalog publishers from the 'Catalogs' table, grouped by publisher name. The placeholder in the LIMIT clause allows the user to specify the maximum number of publishers to retrieve, sorted by the number of catalogs each publisher has, in descending order.", "virtual_table": "SELECT catalog_publisher FROM catalogs GROUP BY catalog_publisher ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.329", "db_id": "product_catalog", "question": "Find the names of catalog entries with level number 8.", "rationale": ["The query identifies the relevant tables, 'Catalog_Contents' and 'Catalog_Contents_Additional_Attributes'.", "It selects the 'catalog_entry_name' from 'Catalog_Contents'.", "A join is performed on 'catalog_entry_id' to link the two tables.", "A condition is added to filter the results based on 'catalog_level_number' using a placeholder for string values."], "gold_sql": "SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.catalog_level_number  =  '8'", "source_tables": ["catalog_contents", "catalog_contents_additional_attributes"], "description": "This virtual table provides the names of catalog entries from the 'Catalog_Contents' table that are associated with specific additional attributes. The join between 'Catalog_Contents' and 'Catalog_Contents_Additional_Attributes' allows for filtering based on the catalog level number, represented by a placeholder.", "virtual_table": "SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.catalog_level_number  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.311", "db_id": "product_catalog", "question": "Which catalog publisher has published the most catalogs?", "rationale": ["The query identifies the relevant table, which is 'Catalogs'.", "It selects the 'catalog_publisher' column to display the names of the publishers.", "The GROUP BY clause is used to group the results by 'catalog_publisher'.", "The ORDER BY clause sorts the results based on the count of catalogs for each publisher in descending order.", "The LIMIT clause restricts the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT catalog_publisher FROM catalogs GROUP BY catalog_publisher ORDER BY count(*) DESC LIMIT 1", "source_tables": ["catalogs"], "description": "This virtual table provides a list of catalog publishers from the 'Catalogs' table, grouped by publisher name. The result is ordered by the number of catalogs each publisher has, allowing users to see which publishers have the most catalogs. The placeholder in the LIMIT clause represents the maximum number of publishers to return.", "virtual_table": "SELECT catalog_publisher FROM catalogs GROUP BY catalog_publisher ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.319", "db_id": "product_catalog", "question": "What is the level name of the cheapest catalog (in USD)?", "rationale": ["The query identifies the relevant tables, which are 'Catalog_Contents' and 'Catalog_Structure'.", "It selects the 'catalog_level_name' from the 'Catalog_Structure' table.", "A JOIN operation is performed on the 'catalog_level_number' to link the two tables based on their hierarchy.", "The results are ordered by the 'price_in_dollars' from the 'Catalog_Contents' table.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT t2.catalog_level_name FROM catalog_contents AS t1 JOIN catalog_structure AS t2 ON t1.catalog_level_number  =  t2.catalog_level_number ORDER BY t1.price_in_dollars LIMIT 1", "source_tables": ["catalog_structure", "catalog_contents"], "description": "This virtual table provides the names of catalog levels from the 'Catalog_Structure' table that correspond to entries in the 'Catalog_Contents' table. The results are ordered by the price of the entries in dollars, and the number of results returned is limited by a placeholder for numeric values.", "virtual_table": "SELECT t2.catalog_level_name FROM catalog_contents AS t1 JOIN catalog_structure AS t2 ON t1.catalog_level_number  =  t2.catalog_level_number ORDER BY t1.price_in_dollars LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.320", "db_id": "product_catalog", "question": "Find the level name of the catalog with the lowest price (in USD).", "rationale": ["The query identifies the relevant tables, which are 'Catalog_Contents' and 'Catalog_Structure'.", "It selects the 'catalog_level_name' from the 'Catalog_Structure' table.", "A JOIN operation is performed on the 'catalog_level_number' to link the two tables based on their hierarchy.", "The results are ordered by the 'price_in_dollars' from the 'Catalog_Contents' table.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT t2.catalog_level_name FROM catalog_contents AS t1 JOIN catalog_structure AS t2 ON t1.catalog_level_number  =  t2.catalog_level_number ORDER BY t1.price_in_dollars LIMIT 1", "source_tables": ["catalog_structure", "catalog_contents"], "description": "The virtual table provides a list of catalog level names from the 'Catalog_Structure' table that correspond to entries in the 'Catalog_Contents' table. The results are ordered by the price in dollars of the catalog entries, and the number of results returned is limited by a specified placeholder value.", "virtual_table": "SELECT t2.catalog_level_name FROM catalog_contents AS t1 JOIN catalog_structure AS t2 ON t1.catalog_level_number  =  t2.catalog_level_number ORDER BY t1.price_in_dollars LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5589", "db_id": "products_gen_characteristics", "question": "What are the names of products that are not 'white' in color and are not measured by the unit 'Handful'?", "rationale": ["The query identifies the relevant tables: 'Products', 'Ref_Product_Categories', and 'Ref_Colors'.", "It selects the 'product_name' column from the 'Products' table.", "The JOIN operations link the 'Products' table with 'Ref_Product_Categories' and 'Ref_Colors' based on their respective foreign keys.", "The WHERE clause filters the results based on the specified color description and ensures the unit of measure is not equal to a specified value, using placeholders for both conditions."], "gold_sql": "SELECT t1.product_name FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code JOIN ref_colors AS t3 ON t1.color_code  =  t3.color_code WHERE t3.color_description  =  'white' AND t2.unit_of_measure != 'Handful'", "source_tables": ["products", "ref_colors", "ref_product_categories"], "description": "This virtual table provides a list of product names from the 'Products' table, filtered by a specific color description and a unit of measure that is not equal to a specified value. The placeholders in the WHERE clause represent the color description and the unit of measure, allowing users to customize the query based on their needs.", "virtual_table": "SELECT t1.product_name FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code JOIN ref_colors AS t3 ON t1.color_code  =  t3.color_code WHERE t3.color_description  =  [PLACEHOLDER-TYPE:STRING] AND t2.unit_of_measure != [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5535", "db_id": "products_gen_characteristics", "question": "How many products are in the 'Spices' category and have a typical price of over 1000?", "rationale": ["The query identifies the relevant table, which is 'Products'.", "It counts the total number of products that meet specific criteria.", "The WHERE clause filters products based on the 'product_category_code' and ensures that the 'typical_buying_price' exceeds a specified value using placeholders for both string and numeric values."], "gold_sql": "SELECT count(*) FROM products WHERE product_category_code  =  'Spices' AND typical_buying_price  >  1000", "source_tables": ["products"], "description": "This virtual table provides a count of products from the 'Products' table that belong to a specific product category and have a typical buying price above a certain threshold. The placeholders in the WHERE clause represent the product category code and the minimum buying price.", "virtual_table": "SELECT count(*) FROM products WHERE product_category_code  =  [PLACEHOLDER-TYPE:STRING] AND typical_buying_price  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5576", "db_id": "products_gen_characteristics", "question": "Count the products that have the color description \"white\" or have the characteristic name \"hot\".", "rationale": ["The query identifies the relevant tables: 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors'.", "It uses JOIN operations to connect these tables based on their foreign key relationships.", "The SELECT statement counts the total number of products that meet the specified conditions.", "The WHERE clause filters the results based on the color description or characteristic name, using placeholders for user-defined values."], "gold_sql": "SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  'white' OR t3.characteristic_name  =  'hot'", "source_tables": ["products", "ref_colors", "characteristics", "product_characteristics"], "description": "This virtual table provides a count of products that either match a specific color description or have a specific characteristic name. It combines data from the 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors' tables, using joins to link products to their characteristics and colors. The placeholders in the WHERE clause represent the color description and characteristic name that the user can specify.", "virtual_table": "SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  [PLACEHOLDER-TYPE:STRING] OR t3.characteristic_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5562", "db_id": "products_gen_characteristics", "question": "List all characteristics of product named \"sesame\" with type code \"Grade\".", "rationale": ["The query identifies the relevant tables: 'Products', 'Product_Characteristics', and 'Characteristics'.", "It selects the 'characteristic_name' from the 'Characteristics' table.", "The JOIN operations link the 'Products' table to the 'Product_Characteristics' table and then to the 'Characteristics' table based on their respective IDs.", "The WHERE clause filters the results based on the specified product name and characteristic type code, using placeholders for string values."], "gold_sql": "SELECT t3.characteristic_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  'sesame' AND t3.characteristic_type_code  =  'Grade'", "source_tables": ["products", "characteristics", "product_characteristics"], "description": "This virtual table provides the names of characteristics associated with a specific product from the 'Products' table. The query filters the results based on the product's name and the type of characteristic, both represented by placeholders for string values.", "virtual_table": "SELECT t3.characteristic_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING] AND t3.characteristic_type_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5593", "db_id": "products_gen_characteristics", "question": "Give the color description that is least common across products.", "rationale": ["The query identifies the relevant tables, 'Products' and 'Ref_Colors'.", "It selects the 'color_description' from the 'Ref_Colors' table.", "A JOIN operation is performed on the 'color_code' to link products with their respective colors.", "The results are grouped by 'color_description' to aggregate the data based on color.", "The ORDER BY clause sorts the colors by their count in ascending order.", "The LIMIT clause uses a placeholder to allow the user to specify how many color descriptions to return."], "gold_sql": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) ASC LIMIT 1", "source_tables": ["products", "ref_colors"], "description": "This virtual table provides a list of color descriptions for products from the 'Products' table, grouped by color and ordered by the frequency of each color's occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of color descriptions to retrieve.", "virtual_table": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5557", "db_id": "products_gen_characteristics", "question": "Count the number of different characteristic names the product 'cumin' has.", "rationale": ["The query identifies the relevant tables: 'Products', 'Product_Characteristics', and 'Characteristics'.", "It counts the distinct characteristic names from the 'Characteristics' table.", "The JOIN operations link the 'Products' table to the 'Product_Characteristics' table and then to the 'Characteristics' table based on their respective IDs.", "A condition is added to filter the results based on the specified product name using a placeholder for string values."], "gold_sql": "SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  'sesame'", "source_tables": ["products", "characteristics", "product_characteristics"], "description": "This virtual table provides the count of distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.", "virtual_table": "SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5542", "db_id": "products_gen_characteristics", "question": "Find the category descriptions of the products whose descriptions include letter 't'.", "rationale": ["The query identifies the relevant tables, which are 'Ref_Product_Categories' and 'Products'.", "It selects the 'product_category_description' from the 'Ref_Product_Categories' table.", "A JOIN operation is performed to link 'Ref_Product_Categories' with 'Products' based on the 'product_category_code'.", "A condition is added to filter the results based on the 'product_description' in the 'Products' table using a placeholder for string values."], "gold_sql": "SELECT T1.product_category_description FROM ref_product_categories AS T1 JOIN products AS T2 ON T1.product_category_code  =  T2.product_category_code WHERE T2.product_description LIKE '%t%'", "source_tables": ["products", "ref_product_categories"], "description": "This virtual table provides the descriptions of product categories from the 'Ref_Product_Categories' table that are associated with products in the 'Products' table, filtered by a specific product description. The placeholder in the WHERE clause represents the product description to search for.", "virtual_table": "SELECT T1.product_category_description FROM ref_product_categories AS T1 JOIN products AS T2 ON T1.product_category_code  =  T2.product_category_code WHERE T2.product_description LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5526", "db_id": "products_gen_characteristics", "question": "Find the names of all the product characteristics.", "rationale": ["The query is identifying the relevant table, which is 'Characteristics'.", "Select the column to display, 'characteristic_name'.", "Use DISTINCT to ensure that only unique characteristic names are returned."], "gold_sql": "SELECT DISTINCT characteristic_name FROM CHARACTERISTICS", "source_tables": ["characteristics"], "description": "The virtual table provides a list of unique characteristic names from the 'Characteristics' table. This table includes various characteristics that can be associated with products, and the placeholder allows for filtering or further specification if needed.", "virtual_table": "SELECT DISTINCT characteristic_name FROM CHARACTERISTICS"}
{"sample_id": "train.5652", "db_id": "railway", "question": "Show the countries that have managers of age above 50 or below 46.", "rationale": ["The query identifies the relevant table, which is 'manager'.", "Select the column to display, 'Country'.", "Add a condition to filter the 'Age' column for managers who are either older than a specified age or younger than another specified age using placeholders for numeric values."], "gold_sql": "SELECT Country FROM manager WHERE Age  >  50 OR Age  <  46", "source_tables": ["manager"], "description": "This virtual table provides a list of countries where managers are based, filtered by their age. The placeholders in the WHERE clause allow for specifying age limits to retrieve managers who are either older than a certain age or younger than another age.", "virtual_table": "SELECT Country FROM manager WHERE Age  >  [PLACEHOLDER-TYPE:NUMBER] OR Age  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5635", "db_id": "railway", "question": "What is the maximum level of managers in countries that are not \"Australia\"?", "rationale": ["The query identifies the relevant table, which is 'manager'.", "It selects the maximum value of the 'Level' column to find the highest management level.", "A condition is added to filter out managers based in a specified country using a placeholder for string values."], "gold_sql": "SELECT max(LEVEL) FROM manager WHERE Country != 'Australia\t'", "source_tables": ["manager"], "description": "This virtual table provides the highest management level of managers from the 'manager' table who are not based in a specific country. The placeholder in the WHERE clause represents the name of the country to be excluded from the results.", "virtual_table": "SELECT max(LEVEL) FROM manager WHERE Country != [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5639", "db_id": "railway", "question": "What is the name of the oldest manager?", "rationale": ["The query identifies the relevant table, which is 'manager'.", "Select the column to display, 'Name', which represents the names of the managers.", "Order the results by the 'Age' column in descending order to get the oldest managers first.", "Limit the number of results returned using a placeholder for numeric values, allowing the user to specify how many names they want to see."], "gold_sql": "SELECT Name FROM manager ORDER BY Age DESC LIMIT 1", "source_tables": ["manager"], "description": "This virtual table provides a list of managers from the 'manager' table, ordered by their age in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of managers to retrieve.", "virtual_table": "SELECT Name FROM manager ORDER BY Age DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1299", "db_id": "soccer_1", "question": "List the names of all players who have a crossing score higher than 90 and prefer their right foot.", "rationale": ["The query identifies the relevant tables, which are 'Player' and 'Player_Attributes'.", "It selects the distinct player names from the 'Player' table.", "A JOIN operation is performed on the 'player_api_id' to combine data from both tables.", "Conditions are added to filter players based on their crossing ability and preferred foot using placeholders for numeric and string values."], "gold_sql": "SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.crossing  >  90 AND T2.preferred_foot  =  'right'", "source_tables": ["player_attributes", "player"], "description": "This virtual table lists the names of players from the 'Player' table who have a crossing ability above a specified threshold and have a preferred foot that matches a given value. The placeholders in the WHERE clause represent the minimum crossing ability and the preferred foot of the players.", "virtual_table": "SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.crossing  >  [PLACEHOLDER-TYPE:NUMBER] AND T2.preferred_foot  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1300", "db_id": "soccer_1", "question": "List the names of all left-footed players who have overall rating between 85 and 90.", "rationale": ["The query identifies the relevant tables, which are 'Player' and 'Player_Attributes'.", "It selects distinct player names from the 'Player' table.", "A JOIN operation is performed on the 'player_api_id' to combine data from both tables.", "Conditions are added to filter players based on their preferred foot and their overall rating, using placeholders for the preferred foot and the rating range."], "gold_sql": "SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.preferred_foot  =  'left' AND T2.overall_rating  >=  85 AND T2.overall_rating  <=  90", "source_tables": ["player_attributes", "player"], "description": "This virtual table lists the distinct names of players from the 'Player' table who have a specific preferred foot and whose overall skill rating falls within a defined range. The placeholders in the WHERE clause represent the preferred foot and the minimum and maximum overall ratings.", "virtual_table": "SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.preferred_foot  =  [PLACEHOLDER-TYPE:STRING] AND T2.overall_rating  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.overall_rating  <=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1298", "db_id": "soccer_1", "question": "What are the names of players who have the best dribbling?", "rationale": ["The query identifies the relevant tables, which are 'Player' and 'Player_Attributes'.", "It selects distinct player names from the 'Player' table.", "A join is performed between 'Player' and 'Player_Attributes' on the 'player_api_id' to link player names with their attributes.", "A subquery is used to find the maximum overall rating from the 'Player_Attributes' table, which is then used to filter players based on their dribbling attribute."], "gold_sql": "SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.dribbling  =  ( SELECT max(overall_rating) FROM Player_Attributes)", "source_tables": ["player_attributes", "player"], "description": "The virtual table provides a list of unique player names from the 'Player' table who have the highest overall skill rating recorded in the 'Player_Attributes' table. The placeholder in the WHERE clause represents the dribbling attribute that is being compared to the maximum overall rating.", "virtual_table": "SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.dribbling  =  ( SELECT max(overall_rating) FROM Player_Attributes)"}
{"sample_id": "train.1297", "db_id": "soccer_1", "question": "List all player names who have an overall rating higher than the average.", "rationale": ["The query identifies the relevant tables, which are 'Player' and 'Player_Attributes'.", "It selects the distinct player names from the 'Player' table.", "A JOIN operation is performed on the 'player_api_id' to link player attributes with player names.", "A condition is added to filter players whose overall rating is greater than the average overall rating calculated from the 'Player_Attributes' table using a subquery."], "gold_sql": "SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.overall_rating  >  ( SELECT avg(overall_rating) FROM Player_Attributes )", "source_tables": ["player_attributes", "player"], "description": "This virtual table lists the names of players from the 'Player' table who have an overall skill rating higher than the average overall rating of all players recorded in the 'Player_Attributes' table. The query uses a subquery to calculate the average overall rating, and the placeholder in the WHERE clause represents this average value.", "virtual_table": "SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.overall_rating  >  ( SELECT avg(overall_rating) FROM Player_Attributes )"}
{"sample_id": "train.1305", "db_id": "soccer_1", "question": "Who are the top 3 players in terms of overall rating?", "rationale": ["The query identifies the relevant tables, which are 'Player' and 'Player_Attributes'.", "It selects the distinct player names from the 'Player' table.", "A join is performed on the 'player_api_id' to combine player names with their attributes.", "The results are ordered by 'overall_rating' in descending order to show the highest-rated players first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id  =  T2.player_api_id ORDER BY overall_rating DESC LIMIT 3", "source_tables": ["player_attributes", "player"], "description": "The virtual table lists the names of players from the 'Player' table, joined with their attributes from the 'Player_Attributes' table. The results are ordered by the players' overall skill ratings in descending order, and the number of players returned is limited by a specified placeholder value.", "virtual_table": "SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id  =  T2.player_api_id ORDER BY overall_rating DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1296", "db_id": "soccer_1", "question": "What is the maximum and minimum height of all players?", "rationale": ["The query identifies the relevant table, which is 'Player'.", "It selects the maximum and minimum values of the 'weight' column.", "The use of aggregate functions 'max' and 'min' allows for retrieving the highest and lowest weights of players, respectively."], "gold_sql": "SELECT max(weight) ,  min(weight) FROM Player", "source_tables": ["player"], "description": "The virtual table summarizes the maximum and minimum weights of players from the 'Player' table. The placeholders in the SELECT statement allow for potential modifications to specify different attributes or conditions if needed.", "virtual_table": "SELECT max(weight) ,  min(weight) FROM Player"}
{"sample_id": "train.5035", "db_id": "soccer_2", "question": "What are the names of all the states with college students playing in the mid position but no goalies?", "rationale": ["The query identifies the relevant tables, which are 'College' and 'Tryout'.", "It joins these tables on the college name to associate players with their respective colleges.", "The SELECT statement retrieves the 'state' column from the 'College' table.", "A condition is added to filter the results based on the player's position using a placeholder for string values.", "The EXCEPT clause is used to exclude any states that are also associated with players trying out for the same position, ensuring the results are unique."], "gold_sql": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'mid' EXCEPT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'goalie'", "source_tables": ["tryout", "college"], "description": "This virtual table provides the states of colleges where players are trying out for a specific position. The first part of the query retrieves the states of colleges associated with players trying out for the given position, while the EXCEPT clause filters out any states that are also associated with players trying out for the same position, effectively returning unique states.", "virtual_table": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5024", "db_id": "soccer_2", "question": "Find the names of either colleges in LA with greater than 15000 size or in state AZ with less than 13000 enrollment.", "rationale": ["The query identifies the relevant table, which is 'College'.", "It selects the 'cName' column to display the names of the colleges.", "The first part of the query filters colleges with an enrollment number less than a specified value using a placeholder for numeric values.", "The second part of the query filters colleges with an enrollment number greater than another specified value using a placeholder for numeric values.", "Both parts of the query are filtered by the 'state' column using a placeholder for string values."], "gold_sql": "SELECT cName FROM College WHERE enr  <  13000 AND state = 'AZ' UNION SELECT cName FROM College WHERE enr  >  15000 AND state = 'LA'", "source_tables": ["college"], "description": "This virtual table provides a list of college names from the 'College' table based on specific enrollment criteria and state. The first part of the query retrieves colleges with an enrollment number less than a specified value, while the second part retrieves colleges with an enrollment number greater than another specified value, both filtered by the state. The placeholders represent the enrollment numbers and the state name.", "virtual_table": "SELECT cName FROM College WHERE enr  <  [PLACEHOLDER-TYPE:NUMBER] AND state = [PLACEHOLDER-TYPE:STRING] UNION SELECT cName FROM College WHERE enr  >  [PLACEHOLDER-TYPE:NUMBER] AND state = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4993", "db_id": "soccer_2", "question": "What is the name of the school with smallest enrollment size per state?", "rationale": ["The query identifies the relevant table, which is 'College'.", "Select the columns to display, 'cName' and 'state', along with the minimum enrollment number using the aggregation function 'min(enr)'.", "Group the results by 'state' to get the minimum enrollment for each state, ensuring that the data is organized accordingly."], "gold_sql": "SELECT cName ,  state ,  min(enr) FROM college GROUP BY state", "source_tables": ["college"], "description": "This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college name and state, while the aggregation function is used to find the minimum enrollment number for each state.", "virtual_table": "SELECT cName ,  state ,  min(enr) FROM college GROUP BY state"}
{"sample_id": "train.5015", "db_id": "soccer_2", "question": "For each position, what is the maximum number of  hours for students who spent more than 1000 hours training?", "rationale": ["The query identifies the relevant tables, which are 'Player' and 'Tryout'.", "It selects the maximum high school value and the position of the player from the joined tables.", "The JOIN operation is performed on the player ID to link players with their tryout information.", "A condition is added to filter players based on their high school enrollment number using a placeholder for numeric values.", "The results are grouped by the position of the players to aggregate the maximum high school value accordingly."], "gold_sql": "SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  1000 GROUP BY T2.pPos", "source_tables": ["player", "tryout"], "description": "This virtual table provides the maximum high school attended by players along with their positions from the 'Player' and 'Tryout' tables. The placeholder in the WHERE clause represents a numeric threshold for filtering players based on their high school enrollment number.", "virtual_table": "SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos"}
{"sample_id": "train.4992", "db_id": "soccer_2", "question": "What is the name of school that has the smallest enrollment in each state?", "rationale": ["The query identifies the relevant table, which is 'College'.", "Select the columns to display, 'cName' and 'state', along with the minimum enrollment number using the aggregation function 'min(enr)'.", "Group the results by 'state' to get the minimum enrollment number for each state, ensuring that the data is organized accordingly."], "gold_sql": "SELECT cName ,  state ,  min(enr) FROM college GROUP BY state", "source_tables": ["college"], "description": "This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college name and state, while the aggregation function is used to find the minimum enrollment number for each state.", "virtual_table": "SELECT cName ,  state ,  min(enr) FROM college GROUP BY state"}
{"sample_id": "train.5027", "db_id": "soccer_2", "question": "What are the names of all schools that have students trying out for the position of goal and 'mid'-field.", "rationale": ["The query is identifying the relevant table, which is 'Tryout'.", "It selects the 'cName' column to display the names of colleges.", "The INTERSECT operator is used to find colleges where players are trying out for two different positions.", "Placeholders are used for the positions to allow flexibility in specifying which positions to compare."], "gold_sql": "SELECT cName FROM  tryout WHERE pPos  =  'goalie' INTERSECT SELECT cName FROM  tryout WHERE pPos  =  'mid'", "source_tables": ["tryout"], "description": "This virtual table identifies the colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify any two positions of interest.", "virtual_table": "SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5014", "db_id": "soccer_2", "question": "What is the maximum training hours for the students whose training hours is greater than 1000 in different positions?", "rationale": ["The query identifies the relevant tables, which are 'Player' and 'Tryout'.", "It selects the maximum high school identifier and the position of the player.", "A JOIN operation is performed on the player ID to combine data from both tables.", "A condition is added to filter players based on their high school identifier using a placeholder for numeric values.", "The results are grouped by the player's position to aggregate the data accordingly."], "gold_sql": "SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  1000 GROUP BY T2.pPos", "source_tables": ["player", "tryout"], "description": "This virtual table provides the maximum high school identifier of players along with their positions from the 'Player' and 'Tryout' tables. The placeholder in the WHERE clause represents a numeric threshold for filtering players based on their high school identifier.", "virtual_table": "SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos"}
{"sample_id": "train.5041", "db_id": "soccer_2", "question": "What are the names of the colleges that are larger than at least one college in Florida?", "rationale": ["The query identifies the relevant table, which is 'College'.", "It selects distinct college names to avoid duplicates.", "The condition filters colleges based on their enrollment number being greater than a subquery result.", "The subquery finds the minimum enrollment number from the 'College' table for a specified state, using a placeholder for the state name."], "gold_sql": "SELECT DISTINCT cName FROM college WHERE enr  >  (SELECT min(enr) FROM college WHERE state  =  'FL')", "source_tables": ["college"], "description": "This virtual table lists the distinct names of colleges from the 'College' table that have an enrollment number greater than the minimum enrollment number of colleges located in a specific state. The placeholder in the WHERE clause represents the state name.", "virtual_table": "SELECT DISTINCT cName FROM college WHERE enr  >  (SELECT min(enr) FROM college WHERE state  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.5043", "db_id": "soccer_2", "question": "What are the names of all colleges with a larger enrollment than the largest college in Florida?", "rationale": ["The query identifies the relevant table, which is 'College'.", "It selects the 'cName' column to display the names of the colleges.", "A subquery is used to find the maximum enrollment number from the 'College' table filtered by a specific state, using a placeholder for string values in the WHERE clause."], "gold_sql": "SELECT cName FROM college WHERE enr  >  (SELECT max(enr) FROM college WHERE state  =  'FL')", "source_tables": ["college"], "description": "This virtual table lists the names of colleges from the 'College' table that have an enrollment number greater than the maximum enrollment number of colleges located in a specific state. The placeholder in the WHERE clause represents the state name.", "virtual_table": "SELECT cName FROM college WHERE enr  >  (SELECT max(enr) FROM college WHERE state  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.5011", "db_id": "soccer_2", "question": "What is the average and maximum number of hours students who made the team practiced?", "rationale": ["The query identifies the relevant tables, which are 'Player' and 'Tryout'.", "It selects the average and maximum values of the 'HS' column from the 'Player' table.", "A JOIN operation is performed on the 'pID' column to link players with their tryout records.", "A condition is added to filter the results based on the 'decision' column in the 'Tryout' table using a placeholder for string values."], "gold_sql": "SELECT avg(T1.HS) ,  max(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes'", "source_tables": ["player", "tryout"], "description": "This virtual table provides the average and maximum high school identifiers of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.", "virtual_table": "SELECT avg(T1.HS) ,  max(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5002", "db_id": "soccer_2", "question": "Find the name and hours of the students whose tryout decision is yes.", "rationale": ["The query identifies the relevant tables, which are 'Player' and 'Tryout'.", "It selects the columns to display, 'pName' and 'HS' from the 'Player' table.", "A JOIN operation is performed between 'Player' and 'Tryout' on the player ID to link the two tables.", "A condition is added to filter the results based on the 'decision' column in the 'Tryout' table using a placeholder for string values."], "gold_sql": "SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes'", "source_tables": ["player", "tryout"], "description": "This virtual table provides the names and high schools of players from the 'Player' table who have participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.", "virtual_table": "SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5010", "db_id": "soccer_2", "question": "Find the average and maximum hours for the students whose tryout decision is yes.", "rationale": ["The query identifies the relevant tables, which are 'Player' and 'Tryout'.", "It selects the average and maximum values of the 'HS' column from the 'Player' table, aliased as T1.", "A JOIN operation is performed between 'Player' and 'Tryout' on the player ID to link players with their tryout information.", "A condition is added to filter the results based on the 'decision' column from the 'Tryout' table using a placeholder for string values."], "gold_sql": "SELECT avg(T1.HS) ,  max(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes'", "source_tables": ["player", "tryout"], "description": "This virtual table provides the average and maximum high school attended by players who participated in tryouts, filtered by the decision made regarding their tryout. The placeholder in the WHERE clause represents the specific decision outcome.", "virtual_table": "SELECT avg(T1.HS) ,  max(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4997", "db_id": "soccer_2", "question": "What are the different states that had students successfully try out?", "rationale": ["The query identifies the relevant tables, which are 'College' and 'Tryout'.", "It selects distinct states from the 'College' table to avoid duplicates.", "A JOIN operation is performed between 'College' and 'Tryout' on the college name to link the two tables.", "A condition is added to filter the results based on the player's tryout decision using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  'yes'", "source_tables": ["tryout", "college"], "description": "This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.", "virtual_table": "SELECT DISTINCT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4980", "db_id": "soccer_2", "question": "Find the name of players whose card is yes in the descending order of training hours.", "rationale": ["The query identifies the relevant table, which is 'Player'.", "Select the column to display, 'pName'.", "Add a condition to filter the 'yCard' column for the specified year of eligibility using a placeholder for string values.", "Order the results by the 'HS' column in descending order to prioritize players from certain high schools."], "gold_sql": "SELECT pName FROM Player WHERE yCard  =  'yes' ORDER BY HS DESC", "source_tables": ["player"], "description": "This virtual table provides the names of players from the 'Player' table who have a specific year of eligibility. The results are ordered by the high school attended by the players in descending order. The placeholder in the WHERE clause represents the year of the player's card or eligibility.", "virtual_table": "SELECT pName FROM Player WHERE yCard  =  [PLACEHOLDER-TYPE:STRING] ORDER BY HS DESC"}
{"sample_id": "train.4957", "db_id": "soccer_2", "question": "What are the names and number of hours spent training for each player who trains for less than 1500 hours?", "rationale": ["The query identifies the relevant table, which is 'Player'.", "Select the columns to display, 'pName' and 'HS'.", "Add a condition to filter the 'HS' column for high schools with an enrollment number less than the specified value using a placeholder for numeric values."], "gold_sql": "SELECT pName ,  HS FROM Player WHERE HS  <  1500", "source_tables": ["player"], "description": "This virtual table provides the names and high schools of players from the 'Player' table who attended high schools with an enrollment number less than a specified value. The placeholder in the WHERE clause represents the enrollment number of students at the high school.", "virtual_table": "SELECT pName ,  HS FROM Player WHERE HS  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4972", "db_id": "soccer_2", "question": "Find the players whose names contain letter 'a'.", "rationale": ["The query is identifying the relevant table, which is 'Player'.", "Select the column to display, 'pName', ensuring that only distinct names are retrieved.", "Add a condition to filter the 'pName' column using a placeholder for string values to allow for pattern matching."], "gold_sql": "SELECT DISTINCT pName FROM Player WHERE pName LIKE '%a%'", "source_tables": ["player"], "description": "This virtual table lists the distinct names of players from the 'Player' table that match a specific pattern. The placeholder in the WHERE clause allows for filtering player names based on a given string pattern.", "virtual_table": "SELECT DISTINCT pName FROM Player WHERE pName LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5019", "db_id": "soccer_2", "question": "What college has a student who successfully made the team in the role of a goalie?", "rationale": ["The query identifies the relevant table, which is 'Tryout'.", "Select the column to display, 'cName', which represents the college name.", "Add conditions to filter the 'decision' and 'pPos' columns for the specified values using placeholders for string values."], "gold_sql": "SELECT cName FROM  tryout WHERE decision  =  'yes' AND pPos  =  'goalie'", "source_tables": ["tryout"], "description": "This virtual table provides the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.", "virtual_table": "SELECT cName FROM  tryout WHERE decision  =  [PLACEHOLDER-TYPE:STRING] AND pPos  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5009", "db_id": "soccer_2", "question": "In which state is the college that Charles attends?", "rationale": ["The query identifies the relevant tables: 'College', 'Tryout', and 'Player'.", "It selects the 'state' column from the 'College' table.", "The JOIN operations link the 'Tryout' table to the 'College' table using the college name, and the 'Player' table to the 'Tryout' table using the player ID.", "A condition is added to filter the results based on the player's name using a placeholder for string values."], "gold_sql": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName JOIN player AS T3 ON T2.pID  =  T3.pID WHERE T3.pName  =  'Charles'", "source_tables": ["player", "tryout", "college"], "description": "This virtual table provides the states of colleges where a specific player has participated in tryouts. The placeholder in the WHERE clause represents the name of the player whose college tryout states are being queried.", "virtual_table": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName JOIN player AS T3 ON T2.pID  =  T3.pID WHERE T3.pName  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4960", "db_id": "soccer_2", "question": "What are the unique types of player positions in the tryout?", "rationale": ["The query is identifying the relevant table, which is 'Tryout'.", "The goal is to count the distinct values in the 'pPos' column, which represents the positions players are trying out for.", "Using the COUNT function with DISTINCT allows us to get the unique positions from the tryouts."], "gold_sql": "SELECT count(DISTINCT pPos) FROM tryout", "source_tables": ["tryout"], "description": "This virtual table provides the count of distinct positions that players are trying out for in the 'Tryout' table. The placeholder in the SELECT clause represents the distinct player positions.", "virtual_table": "SELECT count(DISTINCT pPos) FROM tryout"}
{"sample_id": "train.4954", "db_id": "soccer_2", "question": "What is the average training hours of all players?", "rationale": ["The query is identifying the relevant table, which is 'Player'.", "Select the average of the 'HS' column to calculate the average high school attended by players."], "gold_sql": "SELECT avg(HS) FROM Player", "source_tables": ["player"], "description": "This virtual table provides the average high school attended by players from the 'Player' table. The placeholder in the SELECT clause represents the average value of the high school data.", "virtual_table": "SELECT avg(HS) FROM Player"}
{"sample_id": "train.5031", "db_id": "soccer_2", "question": "How many schools have students playing in goalie and mid-field positions?", "rationale": ["The query is identifying the relevant table, which is 'Tryout'.", "It uses a subquery to select the college names where players are trying out for the first specified position.", "It uses another subquery to select the college names where players are trying out for the second specified position.", "The INTERSECT operator is used to find colleges that appear in both subqueries, meaning they have players trying out for both positions.", "Finally, COUNT(*) is used to count the number of colleges that meet the criteria."], "gold_sql": "SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  'goalie' INTERSECT SELECT cName FROM  tryout WHERE pPos  =  'mid')", "source_tables": ["tryout"], "description": "This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify any two positions they are interested in.", "virtual_table": "SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.5001", "db_id": "soccer_2", "question": "What are the names of all students who tried out in alphabetical order?", "rationale": ["The query identifies the relevant tables, which are 'Player' and 'Tryout'.", "It selects the 'pName' column from the 'Player' table to display the names of the players.", "A JOIN operation is performed between 'Player' and 'Tryout' on the 'pID' column to link players with their tryout records.", "The results are ordered by the player's name to provide a sorted list."], "gold_sql": "SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName", "source_tables": ["player", "tryout"], "description": "This virtual table provides a list of player names from the 'Player' table who are participating in tryouts. The players are ordered by their names. The join operation connects the 'Player' and 'Tryout' tables based on the unique player identifier, ensuring that only players with tryout records are included in the result.", "virtual_table": "SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName"}
{"sample_id": "train.5000", "db_id": "soccer_2", "question": "Find the name of all students who were in the tryout sorted in alphabetic order.", "rationale": ["The query identifies the relevant tables, which are 'Player' and 'Tryout'.", "It selects the 'pName' column from the 'Player' table.", "A join operation is performed on the 'pID' column to link players with their tryout records.", "The results are ordered by the player's name to provide a sorted list."], "gold_sql": "SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName", "source_tables": ["player", "tryout"], "description": "This virtual table provides a list of player names from the 'Player' table who are participating in tryouts. The join operation connects the 'Player' and 'Tryout' tables based on the unique player identifier, ensuring that only players with corresponding tryout records are included. The results are ordered alphabetically by the player's name.", "virtual_table": "SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName"}
{"sample_id": "train.4965", "db_id": "soccer_2", "question": "What is the number of students playing as a goalie?", "rationale": ["The query is identifying the relevant table, which is 'Tryout'.", "The query is counting the number of entries in the 'Tryout' table.", "A condition is added to filter the results based on the 'pPos' column, which indicates the position the player is trying out for, using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM tryout WHERE pPos  =  'goalie'", "source_tables": ["tryout"], "description": "This virtual table provides the count of players participating in tryouts for a specific position. The placeholder in the WHERE clause represents the position that the players are trying out for.", "virtual_table": "SELECT count(*) FROM tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4969", "db_id": "soccer_2", "question": "What is average number of students enrolled in Florida colleges?", "rationale": ["The query is identifying the relevant table, which is 'College'.", "Select the average of the 'enr' column to calculate the average enrollment number.", "Add a condition to filter the 'state' column for the specified state using a placeholder for string values."], "gold_sql": "SELECT avg(enr) FROM College WHERE state  =  'FL'", "source_tables": ["college"], "description": "This virtual table provides the average enrollment number of colleges located in a specific state. The placeholder in the WHERE clause represents the state name.", "virtual_table": "SELECT avg(enr) FROM College WHERE state  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4964", "db_id": "soccer_2", "question": "How many students whose are playing the role of goalie?", "rationale": ["The query is identifying the relevant table, which is 'Tryout'.", "The count function is used to determine the number of players for a specific position.", "A condition is added to filter the 'pPos' column for the specified position using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM tryout WHERE pPos  =  'goalie'", "source_tables": ["tryout"], "description": "This virtual table provides the count of players participating in tryouts for a specific position. The placeholder in the WHERE clause represents the position that the players are trying out for.", "virtual_table": "SELECT count(*) FROM tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4950", "db_id": "soccer_2", "question": "How many players have more than 1000 hours of training?", "rationale": ["The query is identifying the relevant table, which is 'Player'.", "The goal is to count the number of players, hence using 'count(*)'.", "Add a condition to filter the 'HS' column for high schools with an enrollment number greater than a specified value using a placeholder for numeric values."], "gold_sql": "SELECT count(*) FROM Player WHERE HS  >  1000", "source_tables": ["player"], "description": "This virtual table provides the count of players from the 'Player' table who attended high schools with an enrollment number greater than a specified value. The placeholder in the WHERE clause represents the enrollment number of students at the high school.", "virtual_table": "SELECT count(*) FROM Player WHERE HS  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5012", "db_id": "soccer_2", "question": "Find the average hours for the students whose tryout decision is no.", "rationale": ["The query identifies the relevant tables, which are 'Player' and 'Tryout'.", "It selects the average of the 'HS' column from the 'Player' table.", "A JOIN operation is performed on the 'pID' column to link players with their tryout records.", "A condition is added to filter the results based on the 'decision' column in the 'Tryout' table using a placeholder for string values."], "gold_sql": "SELECT avg(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'no'", "source_tables": ["player", "tryout"], "description": "This virtual table calculates the average high school attended by players who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.", "virtual_table": "SELECT avg(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4951", "db_id": "soccer_2", "question": "How many different players trained for more than 1000 hours?", "rationale": ["The query is identifying the relevant table, which is 'Player'.", "The goal is to count the number of players, hence using 'count(*)'.", "Add a condition to filter the 'HS' column for high schools with an enrollment number greater than a specified value using a placeholder for numeric values."], "gold_sql": "SELECT count(*) FROM Player WHERE HS  >  1000", "source_tables": ["player"], "description": "This virtual table provides the count of players from the 'Player' table who attended high schools with an enrollment number greater than a specified value. The placeholder in the WHERE clause represents the minimum enrollment number of students at the high schools.", "virtual_table": "SELECT count(*) FROM Player WHERE HS  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3385", "db_id": "sports_competition", "question": "which countries did participated in both Friendly and Tournament type competitions.", "rationale": ["The query is identifying the relevant table, which is 'competition'.", "Select the 'country' column to display the countries where competitions were held.", "Use the INTERSECT operator to find common countries between two different competition types, each specified by a placeholder for string values."], "gold_sql": "SELECT country FROM competition WHERE competition_type  =  'Friendly' INTERSECT SELECT country FROM competition WHERE competition_type  =  'Tournament'", "source_tables": ["competition"], "description": "This virtual table identifies the countries that hosted competitions of two specific types. The placeholders in the query represent the types of competitions being compared, allowing users to find common countries for those competition types.", "virtual_table": "SELECT country FROM competition WHERE competition_type  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT country FROM competition WHERE competition_type  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3387", "db_id": "sports_competition", "question": "Find the countries that have never participated in any competition with Friendly type.", "rationale": ["The query identifies the relevant table, which is 'competition'.", "Select the 'country' column to display the countries where competitions took place.", "Use the EXCEPT clause to exclude countries that hosted competitions of a specific type, utilizing a placeholder for the competition type."], "gold_sql": "SELECT country FROM competition EXCEPT SELECT country FROM competition WHERE competition_type  =  'Friendly'", "source_tables": ["competition"], "description": "This virtual table lists the countries where competitions were held, excluding those countries that hosted a specific type of competition. The placeholder in the EXCEPT clause represents the type of competition to filter out.", "virtual_table": "SELECT country FROM competition EXCEPT SELECT country FROM competition WHERE competition_type  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3386", "db_id": "sports_competition", "question": "What are the countries that participated in both friendly and tournament type competitions?", "rationale": ["The query is identifying the relevant table, which is 'competition'.", "Select the 'country' column to display the countries where competitions were held.", "Use the INTERSECT operator to find common countries between two different competition types, with placeholders for the competition types."], "gold_sql": "SELECT country FROM competition WHERE competition_type  =  'Friendly' INTERSECT SELECT country FROM competition WHERE competition_type  =  'Tournament'", "source_tables": ["competition"], "description": "This virtual table identifies the countries that hosted competitions of two specific types. The placeholders in the query represent the types of competitions being compared.", "virtual_table": "SELECT country FROM competition WHERE competition_type  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT country FROM competition WHERE competition_type  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3370", "db_id": "sports_competition", "question": "What are the types of competition that have most 5 competitions for that type?", "rationale": ["The query identifies the relevant table, which is 'competition'.", "It selects the 'Competition_type' column to display the different types of competitions.", "The results are grouped by 'Competition_type' to aggregate the data.", "A condition is added using the HAVING clause to filter the competition types based on their count, using a placeholder for numeric values."], "gold_sql": "SELECT Competition_type FROM competition GROUP BY Competition_type HAVING COUNT(*)  <=  5", "source_tables": ["competition"], "description": "This virtual table summarizes the types of competitions held, grouped by their type. It filters the results to show only those competition types that have a count of occurrences less than or equal to a specified number. The placeholder in the HAVING clause represents the maximum count of competitions for each type.", "virtual_table": "SELECT Competition_type FROM competition GROUP BY Competition_type HAVING COUNT(*)  <=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3367", "db_id": "sports_competition", "question": "List the most common type of competition.", "rationale": ["The query identifies the relevant table, which is 'competition'.", "It selects the 'Competition_type' column to display the different types of competitions.", "The GROUP BY clause is used to group the results by 'Competition_type' to count occurrences.", "The ORDER BY clause sorts the competition types based on their count in descending order.", "The LIMIT clause restricts the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT Competition_type FROM competition GROUP BY Competition_type ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["competition"], "description": "This virtual table summarizes the types of competitions held, categorized by their type from the 'competition' table. The placeholder in the LIMIT clause represents the maximum number of competition types to be displayed.", "virtual_table": "SELECT Competition_type FROM competition GROUP BY Competition_type ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3368", "db_id": "sports_competition", "question": "What is the most common competition type?", "rationale": ["The query identifies the relevant table, which is 'competition'.", "It selects the 'Competition_type' column to display the different types of competitions.", "The GROUP BY clause is used to group the results by 'Competition_type' to count occurrences.", "The ORDER BY clause sorts the competition types based on their count in descending order.", "The LIMIT clause restricts the number of results returned to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT Competition_type FROM competition GROUP BY Competition_type ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["competition"], "description": "This virtual table summarizes the types of competitions held, categorized by their type from the 'competition' table. The placeholder in the LIMIT clause represents the maximum number of competition types to be displayed.", "virtual_table": "SELECT Competition_type FROM competition GROUP BY Competition_type ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3344", "db_id": "sports_competition", "question": "What are the types of every competition and in which countries are they located?", "rationale": ["The query identifies the relevant table, which is 'competition'.", "Select the columns to display, 'Competition_type' and 'Country'.", "No filtering conditions are applied, allowing for a broad retrieval of all competition types and their respective countries."], "gold_sql": "SELECT Competition_type ,  Country FROM competition", "source_tables": ["competition"], "description": "This virtual table provides information about various competitions, including their types and the countries where they were held. The placeholders in the SELECT statement allow for dynamic querying of competition types and countries.", "virtual_table": "SELECT Competition_type ,  Country FROM competition"}
{"sample_id": "train.3356", "db_id": "sports_competition", "question": "What are the names and players of all the clubs?", "rationale": ["The query identifies the relevant tables, which are 'club' and 'player'.", "It selects the 'name' column from the 'club' table and the 'Player_ID' column from the 'player' table.", "A JOIN operation is performed on the 'Club_ID' column to link players to their respective clubs, ensuring that only players belonging to the selected clubs are included in the results."], "gold_sql": "SELECT T1.name ,  T2.Player_id FROM club AS T1 JOIN player AS T2 ON T1.Club_ID  =  T2.Club_ID", "source_tables": ["club", "player"], "description": "This virtual table provides the names of clubs along with the unique identifiers of players associated with those clubs. The join operation links the 'club' table and the 'player' table based on the common 'Club_ID' field, allowing for the retrieval of player information for each club.", "virtual_table": "SELECT T1.name ,  T2.Player_id FROM club AS T1 JOIN player AS T2 ON T1.Club_ID  =  T2.Club_ID"}
{"sample_id": "train.565", "db_id": "store_1", "question": "List the state in the US with the most invoices.", "rationale": ["The query identifies the relevant table, which is 'invoices'.", "It selects the 'billing_state' column and counts the number of invoices for each state.", "A condition is added to filter the results by 'billing_country' using a placeholder for string values.", "The results are grouped by 'billing_state' to aggregate the counts.", "The results are ordered in descending order based on the count of invoices.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT 1;", "source_tables": ["invoices"], "description": "This virtual table summarizes the number of invoices issued per state within a specific country. The placeholders in the WHERE clause represent the country name, and the LIMIT clause allows for specifying the maximum number of states to return based on the invoice count.", "virtual_table": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.604", "db_id": "store_1", "question": "How many employees who are IT staff are from each city?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "It selects the count of employees and the city they reside in.", "A condition is added to filter employees based on their job title using a placeholder for string values.", "The results are grouped by city to provide a count of employees in each city for the specified job title."], "gold_sql": "SELECT count(*) ,  city FROM employees WHERE title  =  'IT Staff' GROUP BY city", "source_tables": ["employees"], "description": "This virtual table provides a count of employees grouped by their city, specifically for those holding a certain job title. The placeholder in the WHERE clause represents the job title of the employees.", "virtual_table": "SELECT count(*) ,  city FROM employees WHERE title  =  [PLACEHOLDER-TYPE:STRING] GROUP BY city"}
{"sample_id": "train.587", "db_id": "store_1", "question": "What is the title, phone and hire date of Nancy Edwards?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Select the columns to display: 'title', 'phone', and 'hire_date'.", "Add conditions to filter the 'first_name' and 'last_name' columns for the specified employee using placeholders for string values."], "gold_sql": "SELECT title ,  phone ,  hire_date FROM employees WHERE first_name = 'Nancy' AND last_name = 'Edwards';", "source_tables": ["employees"], "description": "This virtual table provides the titles, phone numbers, and hire dates of employees from the 'employees' table who match a specific first and last name. The placeholders in the WHERE clause represent the first and last names of the employee being queried.", "virtual_table": "SELECT title ,  phone ,  hire_date FROM employees WHERE first_name = [PLACEHOLDER-TYPE:STRING] AND last_name = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.567", "db_id": "store_1", "question": "List the number of invoices and the invoice total from California.", "rationale": ["The query identifies the relevant table, which is 'invoices'.", "Select the columns to display, 'billing_state', the count of invoices, and the sum of the total amounts.", "Add a condition to filter the 'billing_state' column for the specified state using a placeholder for string values."], "gold_sql": "SELECT billing_state ,  COUNT(*) ,  SUM(total) FROM invoices WHERE billing_state  =  'CA';", "source_tables": ["invoices"], "description": "This virtual table summarizes the total number of invoices and the total amount billed for a specific billing state from the 'invoices' table. The placeholder in the WHERE clause represents the billing state being queried.", "virtual_table": "SELECT billing_state ,  COUNT(*) ,  SUM(total) FROM invoices WHERE billing_state  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.594", "db_id": "store_1", "question": "What is the full name of the employee who has the most customers?", "rationale": ["The query identifies the relevant tables, which are 'employees' and 'customers'.", "It selects the 'first_name' and 'last_name' columns from the 'employees' table, aliased as T1.", "A JOIN operation is performed between 'employees' (T1) and 'customers' (T2) on the condition that the employee's ID matches the support representative ID in the customers table.", "The results are grouped by the employee's ID to aggregate the count of customers they support.", "The results are ordered in descending order based on the count of customers, allowing us to see which employees support the most customers.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for the maximum number of employees."], "gold_sql": "SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employees", "customers"], "description": "The virtual table summarizes the first and last names of employees who serve as support representatives for customers. It aggregates the data by counting the number of customers each employee supports, allowing for the identification of the top support representatives based on the number of customers they assist. The placeholder in the LIMIT clause represents the maximum number of employees to be returned in the result.", "virtual_table": "SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.606", "db_id": "store_1", "question": "What are the first and last names of all the employees and how many people report to them?", "rationale": ["The query identifies the relevant table, which is 'employees', and uses it twice to differentiate between employees and their managers.", "It selects the first and last names of the managers (T2) and counts the number of employees (T1) reporting to each manager.", "The JOIN operation connects employees to their respective managers based on the 'reports_to' relationship.", "The results are grouped by the manager's ID to aggregate the count of employees reporting to each manager.", "Finally, the results are ordered by the count of reports in descending order, and a limit is applied to restrict the number of results displayed."], "gold_sql": "SELECT T2.first_name , T2.last_name ,  count(T1.reports_to) FROM employees AS T1 JOIN employees AS T2 ON T1.reports_to = T2.id GROUP BY T1.reports_to ORDER BY count(T1.reports_to) DESC LIMIT 1;", "source_tables": ["employees"], "description": "This virtual table provides a summary of employees and their managers from the 'employees' table. It lists the first and last names of managers along with the count of employees reporting to each manager. The placeholder in the LIMIT clause represents the maximum number of managers to be displayed.", "virtual_table": "SELECT T2.first_name , T2.last_name ,  count(T1.reports_to) FROM employees AS T1 JOIN employees AS T2 ON T1.reports_to = T2.id GROUP BY T1.reports_to ORDER BY count(T1.reports_to) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.592", "db_id": "store_1", "question": "What is Nancy Edwards's address?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Select the column to display, 'address'.", "Add conditions to filter the 'first_name' and 'last_name' columns for the specified employee using placeholders for string values."], "gold_sql": "SELECT address FROM employees WHERE first_name = 'Nancy' AND last_name = 'Edwards';", "source_tables": ["employees"], "description": "This virtual table provides the addresses of employees from the 'employees' table based on their first and last names. The placeholders in the WHERE clause represent the specific first and last names of the employees being queried.", "virtual_table": "SELECT address FROM employees WHERE first_name = [PLACEHOLDER-TYPE:STRING] AND last_name = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.560", "db_id": "store_1", "question": "What are the total amount of money in the invoices billed from Chicago, Illinois?", "rationale": ["The query identifies the relevant table, which is 'invoices'.", "It selects the sum of the 'total' column to calculate the total amount of invoices.", "Conditions are added to filter the results based on 'billing_city' and 'billing_state' using placeholders for string values."], "gold_sql": "SELECT sum(total) FROM invoices WHERE billing_city  =  'Chicago' AND billing_state  =  'IL';", "source_tables": ["invoices"], "description": "This virtual table summarizes the total amount of invoices issued to customers based on their billing city and state. The placeholders in the WHERE clause represent the specific billing city and state for which the total is being calculated.", "virtual_table": "SELECT sum(total) FROM invoices WHERE billing_city  =  [PLACEHOLDER-TYPE:STRING] AND billing_state  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.555", "db_id": "store_1", "question": "List every album whose title starts with A in alphabetical order.", "rationale": ["The query identifies the relevant table, which is 'albums'.", "Select the column to display, 'title'.", "Add a condition to filter the 'title' column using a LIKE operator for pattern matching with a placeholder for string values.", "Order the results by 'title' to ensure they are presented in a sorted manner."], "gold_sql": "SELECT title FROM albums WHERE title LIKE 'A%' ORDER BY title;", "source_tables": ["albums"], "description": "The virtual table provides a list of album titles from the 'albums' table that match a specific pattern. The placeholder in the WHERE clause allows users to specify a search term for the album title, enabling flexible querying based on user input.", "virtual_table": "SELECT title FROM albums WHERE title LIKE [PLACEHOLDER-TYPE:STRING] ORDER BY title;"}
{"sample_id": "train.589", "db_id": "store_1", "question": "find the full name of employees who report to Nancy Edwards?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "It uses a self-join on the 'employees' table to relate employees to their managers.", "Selects the columns to display, 'first_name' and 'last_name' of the employees who report to the specified manager.", "Adds conditions to filter the manager's first and last names using placeholders for string values."], "gold_sql": "SELECT T2.first_name , T2.last_name FROM employees AS T1 JOIN employees AS T2 ON T1.id = T2.reports_to WHERE T1.first_name = 'Nancy' AND T1.last_name = 'Edwards';", "source_tables": ["employees"], "description": "The virtual table provides the first and last names of employees who report to a specific manager. The manager is identified by their first and last names, which are used as placeholders in the query.", "virtual_table": "SELECT T2.first_name , T2.last_name FROM employees AS T1 JOIN employees AS T2 ON T1.id = T2.reports_to WHERE T1.first_name = [PLACEHOLDER-TYPE:STRING] AND T1.last_name = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.625", "db_id": "store_1", "question": "List name of all tracks in Balls to the Wall.", "rationale": ["The query identifies the relevant tables, which are 'albums' and 'tracks'.", "It selects the 'name' column from the 'tracks' table, which contains the track names.", "A JOIN operation is performed between 'albums' and 'tracks' on the condition that the album ID matches the genre ID, which is a mistake in the original query as it should be on album ID.", "A condition is added to filter the results based on the specified album title using a placeholder for string values."], "gold_sql": "SELECT T2.name FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T1.title = 'Balls to the Wall';", "source_tables": ["albums", "tracks"], "description": "This virtual table provides the names of tracks from the 'tracks' table that belong to a specific album in the 'albums' table. The placeholder in the WHERE clause represents the title of the album.", "virtual_table": "SELECT T2.name FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T1.title = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.624", "db_id": "store_1", "question": "What is the name of the album that has the track Ball to the Wall?", "rationale": ["The query identifies the relevant tables, which are 'albums' and 'tracks'.", "It selects the 'title' column from the 'albums' table.", "A JOIN operation is performed between 'albums' and 'tracks' on the condition that the album's ID matches the genre ID of the track.", "A condition is added to filter the results based on the track's name using a placeholder for string values."], "gold_sql": "SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T2.name = 'Balls to the Wall';", "source_tables": ["albums", "tracks"], "description": "The virtual table provides a list of album titles from the 'albums' table that are associated with tracks of a specific genre. The placeholder in the WHERE clause represents the name of the track, allowing users to filter the results based on the track's name.", "virtual_table": "SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T2.name = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.553", "db_id": "store_1", "question": "List every album ordered by album title in ascending order.", "rationale": ["The query identifies the relevant table, which is 'albums'.", "Select the column to display, 'title'.", "Add an ORDER BY clause to sort the results by the 'title' column in ascending order."], "gold_sql": "SELECT title FROM albums ORDER BY title;", "source_tables": ["albums"], "description": "This virtual table lists the titles of albums from the 'albums' table, sorted in alphabetical order. The query retrieves all album titles without any filtering conditions.", "virtual_table": "SELECT title FROM albums ORDER BY title;"}
{"sample_id": "train.611", "db_id": "store_1", "question": "List all media types.", "rationale": ["The query identifies the relevant table, which is 'media_types'.", "Select the column to display, 'name', which represents the type of media.", "No conditions are applied, so it retrieves all entries from the 'media_types' table."], "gold_sql": "SELECT name FROM media_types;", "source_tables": ["media_types"], "description": "This virtual table provides a list of media types from the 'media_types' table. Each entry represents a unique type of media used for tracks, such as audio formats. The query retrieves the 'name' of each media type available.", "virtual_table": "SELECT name FROM media_types;"}
{"sample_id": "train.4943", "db_id": "store_product", "question": "What are the names of the districts that have both mall and village store style shops?", "rationale": ["The query identifies the relevant tables: 'store', 'store_district', and 'district'.", "It selects the 'District_name' from the 'district' table.", "The query joins the 'store' table with 'store_district' to link stores to their respective districts.", "It further joins the 'store_district' table with the 'district' table to access district names.", "The WHERE clause filters the stores based on their type, using placeholders for the specific types of stores being compared."], "gold_sql": "SELECT t3.District_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t1.Type  =  'City Mall' INTERSECT SELECT t3.District_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t1.Type  =  'Village Store'", "source_tables": ["store_district", "store", "district"], "description": "This virtual table identifies the names of districts that have stores of a specific type. The query uses an intersection to find districts that have stores matching two different types, represented by placeholders for the store types.", "virtual_table": "SELECT t3.District_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t1.Type  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT t3.District_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t1.Type  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4942", "db_id": "store_product", "question": "Find the names of districts where have both city mall and village store type stores.", "rationale": ["The query identifies the relevant tables: 'store', 'store_district', and 'district'.", "It selects the 'District_name' from the 'district' table.", "The query joins the 'store' table with 'store_district' to link stores to their respective districts.", "It further joins with the 'district' table to access district names.", "The WHERE clause filters stores based on their type, using placeholders for the specific types to be compared."], "gold_sql": "SELECT t3.District_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t1.Type  =  'City Mall' INTERSECT SELECT t3.District_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t1.Type  =  'Village Store'", "source_tables": ["store_district", "store", "district"], "description": "This virtual table provides the names of districts that contain stores of a specific type. The query uses an intersection to find districts that have stores matching two different types, represented by placeholders for the store types.", "virtual_table": "SELECT t3.District_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t1.Type  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT t3.District_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t1.Type  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4939", "db_id": "store_product", "question": "What are the names of all products that are not the most frequently-used maximum page size?", "rationale": ["The query identifies the relevant table, which is 'product'.", "Select the column to display, 'product'.", "Add a condition to filter out products that have the maximum page size by using a subquery that groups by 'max_page_size' and orders by the count of occurrences, limiting the result to the most common maximum page size using a placeholder for numeric values."], "gold_sql": "SELECT product FROM product WHERE product != (SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["product"], "description": "This virtual table lists the names or descriptions of products from the 'product' table that do not have the most common maximum page size. The placeholder in the subquery represents a numeric value to limit the results based on the count of maximum page sizes.", "virtual_table": "SELECT product FROM product WHERE product != (SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.4931", "db_id": "store_product", "question": "What are the products with the maximum page size A4 that also have a pages per minute color smaller than 5?", "rationale": ["The query identifies the relevant table, which is 'product'.", "Select the column to display, which is 'product'.", "Add conditions to filter the 'max_page_size' column for a specified maximum size using a placeholder for string values.", "Add another condition to filter the 'pages_per_minute_color' column to be less than a specified number using a placeholder for numeric values."], "gold_sql": "SELECT product FROM product WHERE max_page_size  =  'A4' AND pages_per_minute_color  <  5", "source_tables": ["product"], "description": "The virtual table provides a list of products from the 'product' table that meet specific criteria regarding their maximum page size and print speed for color output. The placeholders in the WHERE clause represent the maximum page size and the maximum pages per minute for color printing, allowing users to filter products based on these attributes.", "virtual_table": "SELECT product FROM product WHERE max_page_size  =  [PLACEHOLDER-TYPE:STRING] AND pages_per_minute_color  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4933", "db_id": "store_product", "question": "What are the products with the maximum page size eqal to A4 or a pages per minute color less than 5?", "rationale": ["The query identifies the relevant table, which is 'product'.", "Select the column to display, 'product'.", "Add conditions to filter the 'max_page_size' for a specific value and 'pages_per_minute_color' for values less than a specified number using placeholders for string and numeric values."], "gold_sql": "SELECT product FROM product WHERE max_page_size  =  'A4' OR pages_per_minute_color  <  5", "source_tables": ["product"], "description": "The virtual table provides a list of products from the 'product' table that either have a specific maximum page size or a print speed that is below a certain threshold. The placeholders in the WHERE clause allow users to specify the maximum page size and the maximum pages per minute for color output.", "virtual_table": "SELECT product FROM product WHERE max_page_size  =  [PLACEHOLDER-TYPE:STRING] OR pages_per_minute_color  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4922", "db_id": "store_product", "question": "Find the number of stores in each city.", "rationale": ["The query identifies the relevant tables: 'store', 'store_district', and 'district'.", "It joins the 'store' table with 'store_district' on the store ID to associate stores with their districts.", "Then, it joins the resulting table with the 'district' table on the district ID to access district information, specifically the headquartered city.", "The query groups the results by the 'headquartered_city' to count the number of stores in each city, providing a summary of store distribution by city."], "gold_sql": "SELECT t3.headquartered_city ,  count(*) FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id GROUP BY t3.headquartered_city", "source_tables": ["store_district", "store", "district"], "description": "This virtual table summarizes the count of stores grouped by the city where their respective districts are headquartered. The placeholder in the SELECT clause represents the city name, while the count reflects the number of stores in each city.", "virtual_table": "SELECT t3.headquartered_city ,  count(*) FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id GROUP BY t3.headquartered_city"}
{"sample_id": "train.4925", "db_id": "store_product", "question": "What is the city with the most number of flagship stores?", "rationale": ["The query identifies the relevant tables: 'store', 'store_district', and 'district'.", "It joins these tables to connect stores with their respective districts and retrieve the headquarters city for each district.", "The GROUP BY clause is used to aggregate the results by 'headquartered_city', allowing for counting the number of stores in each city.", "The ORDER BY clause sorts the results based on the count of stores in descending order, ensuring that the most populated cities appear first.", "The LIMIT clause uses a placeholder to specify the maximum number of results to return, making the query adaptable."], "gold_sql": "SELECT t3.headquartered_city FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id GROUP BY t3.headquartered_city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["store_district", "store", "district"], "description": "This virtual table provides a list of cities where the headquarters of districts are located, based on the stores associated with those districts. The placeholder in the LIMIT clause represents the maximum number of cities to return, allowing for flexibility in the query results.", "virtual_table": "SELECT t3.headquartered_city FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id GROUP BY t3.headquartered_city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4916", "db_id": "store_product", "question": "Find the names of all stores in Khanewal District.", "rationale": ["The query identifies the relevant tables: 'store', 'store_district', and 'district'.", "It selects the 'store_name' column from the 'store' table.", "The query uses JOIN operations to connect 'store' with 'store_district' and 'district' based on their respective IDs.", "A WHERE clause is added to filter the results by the specified district name using a placeholder for string values."], "gold_sql": "SELECT t1.store_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t3.district_name  =  'Khanewal District'", "source_tables": ["store_district", "store", "district"], "description": "This virtual table lists the names of stores located in a specific district. The query joins the 'store' table with the 'store_district' table to associate stores with their respective districts, and then filters the results based on the district's name provided as a placeholder.", "virtual_table": "SELECT t1.store_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t3.district_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4928", "db_id": "store_product", "question": "What products are available at store named \"Miramichi\"?", "rationale": ["The query identifies the relevant tables: 'product', 'store_product', and 'store'.", "It selects the 'product' column from the 'product' table.", "The JOIN operations link the 'product' table to the 'store_product' table using 'product_id', and then to the 'store' table using 'store_id'.", "A condition is added to filter the results based on the specified store name using a placeholder for string values."], "gold_sql": "SELECT t1.product FROM product AS t1 JOIN store_product AS t2 ON t1.product_id  =  t2.product_id JOIN store AS t3 ON t2.store_id  =  t3.store_id WHERE t3.store_name  =  'Miramichi'", "source_tables": ["store", "store_product", "product"], "description": "This virtual table provides a list of products from the 'product' table that are available in a specific store. The placeholder in the WHERE clause represents the name of the store being queried.", "virtual_table": "SELECT t1.product FROM product AS t1 JOIN store_product AS t2 ON t1.product_id  =  t2.product_id JOIN store AS t3 ON t2.store_id  =  t3.store_id WHERE t3.store_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4934", "db_id": "store_product", "question": "Find all the product whose name contains the word \"Scanner\".", "rationale": ["The query identifies the relevant table, which is 'product'.", "Select the column to display, 'product'.", "Add a condition to filter the 'product' column using a LIKE operator for pattern matching, with a placeholder for string values."], "gold_sql": "SELECT product FROM product WHERE product LIKE '%Scanner%'", "source_tables": ["product"], "description": "The virtual table provides a list of products from the 'product' table that match a specific search criterion. The placeholder in the WHERE clause allows users to specify a pattern for the product name or description they are interested in.", "virtual_table": "SELECT product FROM product WHERE product LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.81", "db_id": "student_assessment", "question": "How many registed students do each course have? List course name and the number of their registered students?", "rationale": ["The query identifies the relevant tables: 'Students', 'Student_Course_Registrations', and 'Courses'.", "It selects the 'course_name' from the 'Courses' table and counts the number of registrations for each course.", "The JOIN operations link the 'Students' table to 'Student_Course_Registrations' using 'student_id', and then link 'Student_Course_Registrations' to 'Courses' using 'course_id'.", "The GROUP BY clause is used to aggregate the results by 'course_id', allowing for the count of students per course."], "gold_sql": "SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id", "source_tables": ["courses", "student_course_registrations", "students"], "description": "This virtual table summarizes the number of students registered for each course from the 'Courses' table. It combines data from the 'Students' and 'Student_Course_Registrations' tables to count the registrations per course. The placeholders in the query represent the course identifiers and the count of students.", "virtual_table": "SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id"}
{"sample_id": "train.89", "db_id": "student_assessment", "question": "What is the id of the student who most recently registered course 301?", "rationale": ["The query identifies the relevant table, which is 'Student_Course_Attendance'.", "Select the column to display, 'student_id'.", "Add a condition to filter the 'course_id' column for the specified course using a placeholder for numeric values.", "Order the results by 'date_of_attendance' in descending order to show the most recent attendance first.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT student_id FROM student_course_attendance WHERE course_id = 301 ORDER BY date_of_attendance DESC LIMIT 1", "source_tables": ["student_course_attendance"], "description": "This virtual table provides a list of student identifiers from the 'Student_Course_Attendance' table for a specific course. The results are ordered by the date of attendance in descending order, and the number of records returned is limited by a placeholder for numeric values.", "virtual_table": "SELECT student_id FROM student_course_attendance WHERE course_id = [PLACEHOLDER-TYPE:NUMBER] ORDER BY date_of_attendance DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.78", "db_id": "student_assessment", "question": "What are the details of the student who registered for the most number of courses?", "rationale": ["The query identifies the relevant tables, 'Students' and 'Student_Course_Registrations'.", "It selects the 'student_details' from the 'Students' table, which contains information about each student.", "A JOIN operation is performed between 'Students' and 'Student_Course_Registrations' to link students with their course registrations.", "The results are grouped by 'student_id' to aggregate the data for each student.", "The ORDER BY clause sorts the results based on the count of course registrations in descending order, allowing the most enrolled students to appear first.", "The LIMIT clause uses a placeholder to let the user specify how many records to return."], "gold_sql": "SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_course_registrations", "students"], "description": "The virtual table summarizes the details of students who have registered for courses, displaying their information based on the number of courses they are enrolled in. The placeholder in the LIMIT clause allows the user to specify the maximum number of student records to retrieve.", "virtual_table": "SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.58", "db_id": "student_assessment", "question": "what is id of students who registered some courses but the least number of courses in these students?", "rationale": ["The query identifies the relevant table, which is 'Student_Course_Registrations'.", "It selects the 'student_id' to display unique identifiers of students.", "The query groups the results by 'student_id' to ensure each student is listed only once.", "It orders the results by the count of registrations for each student to prioritize those with more courses.", "Finally, a limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT 1", "source_tables": ["student_course_registrations"], "description": "This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the placeholder allows for limiting the number of results returned based on a specified numeric value.", "virtual_table": "SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.59", "db_id": "student_assessment", "question": "What are the ids of the students who registered for some courses but had the least number of courses for all students?", "rationale": ["The query identifies the relevant table, which is 'Student_Course_Registrations'.", "It selects the 'student_id' column to display unique student identifiers.", "The GROUP BY clause is used to group the results by 'student_id' to ensure uniqueness.", "The ORDER BY count(*) is applied to sort the results based on the number of registrations per student.", "The LIMIT clause includes a placeholder to allow the user to specify how many student IDs they want to retrieve."], "gold_sql": "SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT 1", "source_tables": ["student_course_registrations"], "description": "This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The placeholder in the LIMIT clause allows the user to specify the maximum number of student IDs to retrieve.", "virtual_table": "SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.67", "db_id": "student_assessment", "question": "What is detail of the student who most recently registered course?", "rationale": ["The query identifies the relevant tables, which are 'student_course_registrations' and 'students'.", "It selects the 'student_details' column from the 'students' table.", "A JOIN operation is performed to link 'student_course_registrations' with 'students' based on the 'student_id'.", "The results are ordered by 'registration_date' in descending order to show the most recent registrations first.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT 1", "source_tables": ["student_course_registrations", "students"], "description": "The virtual table describes the details of students who have registered for courses, sorted by the date of their registration. The placeholder in the LIMIT clause represents the maximum number of student details to retrieve.", "virtual_table": "SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.68", "db_id": "student_assessment", "question": "What details do we have on the students who registered for courses most recently?", "rationale": ["The query identifies the relevant tables, 'Student_Course_Registrations' and 'Students'.", "It selects the 'student_details' column from the 'Students' table.", "A JOIN operation is performed to link 'Student_Course_Registrations' with 'Students' based on the 'student_id'.", "The results are ordered by 'registration_date' in descending order to show the most recent registrations first.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT 1", "source_tables": ["student_course_registrations", "students"], "description": "This virtual table provides a list of student details from the 'Students' table who are registered for courses, ordered by the most recent registration date. The placeholder in the LIMIT clause indicates the maximum number of records to return.", "virtual_table": "SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.103", "db_id": "student_assessment", "question": "What are all info of students who registered courses but not attended courses?", "rationale": ["The query identifies the relevant table, which is 'student_course_registrations'.", "It selects all columns from this table.", "A subquery is used to find student_ids from the 'student_course_attendance' table, which indicates students who have attended courses.", "The main query uses a NOT IN clause to filter out those student_ids from the 'student_course_registrations', ensuring only students who have not attended any courses are included."], "gold_sql": "SELECT * FROM student_course_registrations WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)", "source_tables": ["student_course_attendance", "student_course_registrations"], "description": "This virtual table provides a list of student course registrations from the 'student_course_registrations' table for students who have not attended any courses. The subquery identifies students who have attended courses, and the main query filters out these students using the student_id placeholder.", "virtual_table": "SELECT * FROM student_course_registrations WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)"}
{"sample_id": "train.92", "db_id": "student_assessment", "question": "What are the different cities where people live?", "rationale": ["The query identifies the relevant table, which is 'Addresses' (aliased as T1).", "It selects distinct cities from the 'Addresses' table to avoid duplicates.", "The JOIN operation connects 'Addresses' with 'People_Addresses' (aliased as T2) based on the address_id, allowing us to filter cities associated with people."], "gold_sql": "SELECT DISTINCT T1.city FROM addresses AS T1 JOIN people_addresses AS T2 ON T1.address_id = T2.address_id", "source_tables": ["addresses", "people_addresses"], "description": "The virtual table provides a list of unique cities from the 'Addresses' table that are associated with people through the 'People_Addresses' relationship. The placeholder in the JOIN clause represents the connection between addresses and people addresses.", "virtual_table": "SELECT DISTINCT T1.city FROM addresses AS T1 JOIN people_addresses AS T2 ON T1.address_id = T2.address_id"}
{"sample_id": "dev.526", "db_id": "student_transcripts_tracking", "question": "What are the names and ids of every course with less than 2 sections?", "rationale": ["The query identifies the relevant tables, which are 'Courses' and 'Sections'.", "It selects the 'course_name' and 'course_id' from the 'Courses' table.", "A JOIN operation is performed between 'Courses' and 'Sections' based on the 'course_id' to associate courses with their sections.", "The results are grouped by 'course_id' to aggregate the sections for each course.", "The HAVING clause is used to filter the results to include only those courses that have a count of sections less than or equal to a specified number, using a placeholder for numeric values."], "gold_sql": "SELECT T1.course_name ,  T1.course_id FROM Courses AS T1 JOIN Sections AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_id HAVING count(*)  <=  2", "source_tables": ["courses", "sections"], "description": "The virtual table provides a list of course names and their corresponding identifiers from the 'Courses' table, filtered to include only those courses that have a number of sections less than or equal to a specified threshold. The placeholder in the HAVING clause represents the maximum number of sections allowed for the courses listed.", "virtual_table": "SELECT T1.course_name ,  T1.course_id FROM Courses AS T1 JOIN Sections AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_id HAVING count(*)  <=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.535", "db_id": "student_transcripts_tracking", "question": "Who is enrolled in a Bachelor degree program? List the first name, middle name, last name.", "rationale": ["The query identifies the relevant tables: 'Students', 'Student_Enrolment', and 'Degree_Programs'.", "It selects distinct names (first, middle, last) from the 'Students' table.", "The JOIN operations link the 'Students' table to the 'Student_Enrolment' table using the student ID, and then to the 'Degree_Programs' table using the degree program ID.", "A condition is added to filter the results based on the specified degree program name using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  'Bachelor'", "source_tables": ["student_enrolment", "degree_programs", "students"], "description": "The virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholder in the WHERE clause represents the name of the degree program being queried.", "virtual_table": "SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.572", "db_id": "student_transcripts_tracking", "question": "What is the maximum number of times that a course shows up in different transcripts and what is that course's enrollment id?", "rationale": ["The query is identifying the relevant table, which is 'Transcript_Contents'.", "It selects the count of occurrences and the 'student_course_id' to determine how many times each course appears in the transcripts.", "The GROUP BY clause is used to aggregate the results by 'student_course_id', allowing us to count the occurrences for each course.", "The ORDER BY clause sorts the results in descending order based on the count, showing the most frequently recorded courses first.", "The LIMIT clause uses a placeholder to allow users to specify the number of results they want to retrieve."], "gold_sql": "SELECT count(*) ,  student_course_id FROM Transcript_Contents GROUP BY student_course_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["transcript_contents"], "description": "This virtual table summarizes the number of times each student course has been recorded in the transcripts. The placeholder in the LIMIT clause represents the maximum number of records to return, allowing users to specify how many of the most frequently recorded courses they wish to see.", "virtual_table": "SELECT count(*) ,  student_course_id FROM Transcript_Contents GROUP BY student_course_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.575", "db_id": "student_transcripts_tracking", "question": "Find the semester when both Master students and Bachelor students got enrolled in.", "rationale": ["The query is identifying the relevant tables, which are 'Degree_Programs' and 'Student_Enrolment'.", "It selects distinct semester IDs from the 'Student_Enrolment' table that are associated with a specific degree program.", "The query uses an INTERSECT operation to find common semesters for two instances of the same degree program, indicated by the placeholder for the degree program name."], "gold_sql": "SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Master' INTERSECT SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Bachelor'", "source_tables": ["student_enrolment", "degree_programs"], "description": "This virtual table identifies the distinct semesters in which students are enrolled in a specific degree program. The placeholders in the query represent the name of the degree program, allowing users to specify which program's semesters they are interested in.", "virtual_table": "SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.542", "db_id": "student_transcripts_tracking", "question": "What is the first, middle, and last name, along with the id and number of enrollments, for the student who enrolled the most in any program?", "rationale": ["The query identifies the relevant table, which is 'Students', aliased as T1.", "It selects the columns for student ID, first name, middle name, and last name from the 'Students' table.", "It counts the number of courses each student is enrolled in by joining the 'Student_Enrolment' table, aliased as T2, on the student ID.", "The results are grouped by student ID to aggregate the course counts.", "Finally, the results are ordered by the count of courses in descending order, and a limit is applied to restrict the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "students"], "description": "This virtual table provides a summary of students along with their first, middle, and last names, and the count of courses they are enrolled in. The placeholder in the LIMIT clause allows for specifying the maximum number of students to be returned, sorted by the number of courses in descending order.", "virtual_table": "SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.534", "db_id": "student_transcripts_tracking", "question": "What are the first, middle, and last names, along with the ids, of all students who enrolled in 2 degree programs in one semester?", "rationale": ["The query identifies the relevant table, which is 'Students', and aliases it as T1.", "It selects the columns to display: 'first_name', 'middle_name', 'last_name', and 'student_id'.", "The query joins the 'Students' table with the 'Student_Enrolment' table (aliased as T2) on the student identifier to link students with their enrolment records.", "The results are grouped by 'student_id' to aggregate the data for each student.", "The HAVING clause is used to filter the results based on the count of enrolments, using a placeholder for numeric values."], "gold_sql": "SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  2", "source_tables": ["student_enrolment", "students"], "description": "This virtual table provides a list of students along with their first name, middle name, last name, and unique student identifier from the 'Students' table. The results are filtered to include only those students who are enrolled in a specific number of courses, as indicated by the placeholder in the HAVING clause.", "virtual_table": "SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.549", "db_id": "student_transcripts_tracking", "question": "Find the last name of the students who currently live in the state of North Carolina but have not registered in any degree program.", "rationale": ["The query identifies the relevant tables, 'Students' and 'Addresses', to retrieve student last names based on their current address.", "It joins the 'Students' table with the 'Addresses' table using the current address identifier to filter by state or province.", "The WHERE clause specifies a condition to filter students based on their current address's state or province using a placeholder for string values.", "The EXCEPT clause is used to exclude students who are currently enrolled in any courses by joining the 'Students' table with the 'Student_Enrolment' table."], "gold_sql": "SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  'NorthCarolina' EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id", "source_tables": ["addresses", "student_enrolment", "students"], "description": "This virtual table provides a list of last names of students who currently reside in a specific state, excluding those who are enrolled in any courses. The placeholders in the WHERE clause represent the state or province name.", "virtual_table": "SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id"}
{"sample_id": "dev.584", "db_id": "student_transcripts_tracking", "question": "What are the first names of the students who live in Haiti permanently or have the cell phone number 09700166582 ?", "rationale": ["The query identifies the relevant tables, which are 'Students' and 'Addresses'.", "It selects the 'first_name' column from the 'Students' table.", "A JOIN operation is performed between 'Students' and 'Addresses' on the 'permanent_address_id' and 'address_id' columns to link students with their permanent addresses.", "The WHERE clause includes conditions to filter students based on the country from the 'Addresses' table and the mobile phone number from the 'Students' table, using placeholders for both values."], "gold_sql": "select t1.first_name from students as t1 join addresses as t2 on t1.permanent_address_id  =  t2.address_id where t2.country  =  'haiti' or t1.cell_mobile_number  =  '09700166582'", "source_tables": ["addresses", "students"], "description": "The virtual table provides a list of first names of students from the 'Students' table who either have a permanent address in a specific country or have a specified mobile phone number. The placeholders in the WHERE clause represent the country name and the mobile phone number.", "virtual_table": "select t1.first_name from students as t1 join addresses as t2 on t1.permanent_address_id  =  t2.address_id where t2.country  =  [PLACEHOLDER-TYPE:STRING] or t1.cell_mobile_number  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.548", "db_id": "student_transcripts_tracking", "question": "What is the name of the course with the most students enrolled?", "rationale": ["The query identifies the relevant table, which is 'Courses', and uses an alias 'T1' for clarity.", "It joins the 'Courses' table with the 'Student_Enrolment_Courses' table (aliased as 'T2') to link courses with student enrolments.", "The SELECT statement specifies that only the 'course_name' from 'Courses' should be displayed.", "The GROUP BY clause is used to group the results by 'course_name' to aggregate enrolment counts.", "The ORDER BY clause sorts the results based on the count of enrolments in descending order to highlight the most popular courses.", "The LIMIT clause restricts the number of results returned, using a placeholder for the maximum number of courses to display."], "gold_sql": "SELECT  T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["courses", "student_enrolment_courses"], "description": "The virtual table provides a list of course names from the 'Courses' table, which are associated with student enrolments. The results are grouped by course name and ordered by the number of enrolments in descending order, allowing users to see the most popular courses. The placeholder in the LIMIT clause represents the maximum number of course names to return.", "virtual_table": "SELECT  T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.583", "db_id": "student_transcripts_tracking", "question": "Find the first name of the students who permanently live in the country Haiti or have the cell phone number 09700166582 .", "rationale": ["The query identifies the relevant tables, which are 'Students' and 'Addresses'.", "It selects the 'first_name' column from the 'Students' table.", "A JOIN operation is performed between 'Students' and 'Addresses' on the 'permanent_address_id' and 'address_id' columns to link students with their permanent addresses.", "The WHERE clause includes conditions to filter results based on the country from the 'Addresses' table and the mobile phone number from the 'Students' table, using placeholders for both values."], "gold_sql": "select t1.first_name from students as t1 join addresses as t2 on t1.permanent_address_id  =  t2.address_id where t2.country  =  'haiti' or t1.cell_mobile_number  =  '09700166582'", "source_tables": ["addresses", "students"], "description": "This virtual table provides the first names of students from the 'Students' table who either have a permanent address in a specific country or have a specified mobile phone number. The placeholders in the WHERE clause represent the country name and the mobile phone number.", "virtual_table": "select t1.first_name from students as t1 join addresses as t2 on t1.permanent_address_id  =  t2.address_id where t2.country  =  [PLACEHOLDER-TYPE:STRING] or t1.cell_mobile_number  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.578", "db_id": "student_transcripts_tracking", "question": "What are the different addresses that have students living there?", "rationale": ["The query is identifying the relevant table, which is 'Students'.", "The goal is to count the distinct current addresses, so the COUNT function is used with DISTINCT on the 'current_address_id' column.", "The result will give the number of unique current addresses linked to students."], "gold_sql": "SELECT count(DISTINCT current_address_id) FROM Students", "source_tables": ["students"], "description": "This virtual table provides the count of distinct current addresses associated with students from the 'Students' table. The placeholder in the SELECT clause represents the unique current address identifiers.", "virtual_table": "SELECT count(DISTINCT current_address_id) FROM Students"}
{"sample_id": "dev.579", "db_id": "student_transcripts_tracking", "question": "List all the student details in reversed lexicographical order.", "rationale": ["The query identifies the relevant table, which is 'Students'.", "Select the column to display, 'other_student_details'.", "Add an ORDER BY clause to sort the results in descending order based on 'other_student_details'."], "gold_sql": "SELECT other_student_details FROM Students ORDER BY other_student_details DESC", "source_tables": ["students"], "description": "This virtual table provides a list of additional details related to students from the 'Students' table. The results are sorted in descending order based on the additional details provided for each student.", "virtual_table": "SELECT other_student_details FROM Students ORDER BY other_student_details DESC"}
{"sample_id": "train.4322", "db_id": "tracking_grants_for_research", "question": "List the project details of the project both producing patent and paper as outcomes.", "rationale": ["The query identifies the relevant table, which is 'Projects', and uses an alias 'T1' for clarity.", "It joins the 'Projects' table with the 'Project_Outcomes' table using the project_id to link projects with their outcomes.", "The WHERE clause filters the results based on the outcome_code, using placeholders for the specific codes to be provided by the user.", "The INTERSECT operator is used to ensure that only projects that meet both outcome criteria are returned."], "gold_sql": "SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  'Paper' INTERSECT SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  'Patent'", "source_tables": ["project_outcomes", "projects"], "description": "The virtual table provides a list of project details from the 'Projects' table that have specific outcomes. It retrieves projects that have two distinct outcome codes, ensuring that only projects meeting both criteria are included. The placeholders in the WHERE clause represent the outcome codes that can be specified by the user.", "virtual_table": "SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4338", "db_id": "tracking_grants_for_research", "question": "List the project details of the projects which did not hire any staff for a researcher role.", "rationale": ["The query identifies the relevant table, which is 'Projects'.", "Select the column to display, 'project_details'.", "Add a condition to filter out projects that have staff members with a specific role using a subquery that checks the 'Project_Staff' table for the specified role code, using a placeholder for string values."], "gold_sql": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_Staff WHERE role_code  =  'researcher' )", "source_tables": ["project_staff", "projects"], "description": "The virtual table provides a list of project details from the 'Projects' table for projects that do not have any associated staff members with a specific role. The placeholder in the WHERE clause represents the role code that is being filtered out.", "virtual_table": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING] )"}
{"sample_id": "train.4326", "db_id": "tracking_grants_for_research", "question": "List from which date and to which date these staff work: project staff of the project which hires the most staffs", "rationale": ["The query identifies the relevant table, which is 'Project_Staff'.", "It selects the columns 'date_from' and 'date_to' to display the involvement dates of staff members.", "The first part of the query filters projects based on the count of staff members, using a subquery to get the top N projects.", "The second part of the query filters by a specific 'role_code', allowing for a focused view of staff involvement based on their roles."], "gold_sql": "SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT 1 ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  'leader'", "source_tables": ["project_staff"], "description": "This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders in the query allow for dynamic filtering based on the number of projects and the role code.", "virtual_table": "SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4321", "db_id": "tracking_grants_for_research", "question": "What are the different grant amounts for documents sent before '1986-08-26 20:49:27' and after the grant ended on '1989-03-16 18:27:16'?", "rationale": ["The query identifies the relevant tables, which are 'Grants' and 'Documents'.", "It selects the 'grant_amount' from the 'Grants' table.", "A JOIN operation is performed between 'Grants' and 'Documents' on the 'grant_id' to link the documents to their respective grants.", "The first condition filters documents based on the 'sent_date' being earlier than a specified date using a placeholder for string values.", "The INTERSECT operation is used to find common grant amounts that also meet the second condition, which filters grants based on the 'grant_end_date' being later than another specified date, again using a placeholder for string values."], "gold_sql": "SELECT T1.grant_amount FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id WHERE T2.sent_date  <  '1986-08-26 20:49:27' INTERSECT SELECT grant_amount FROM grants WHERE grant_end_date  >  '1989-03-16 18:27:16'", "source_tables": ["grants", "documents"], "description": "The virtual table provides information about the grant amounts from the 'Grants' table that are associated with documents sent before a specific date and grants that are still active after a certain end date. The placeholders in the WHERE clause represent the dates for filtering the documents and grants.", "virtual_table": "SELECT T1.grant_amount FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id WHERE T2.sent_date  <  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT grant_amount FROM grants WHERE grant_end_date  >  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4339", "db_id": "tracking_grants_for_research", "question": "What are the details for all projects that did not hire any staff in a research role?", "rationale": ["The query identifies the relevant table, which is 'Projects'.", "Select the column to display, 'project_details'.", "Add a condition to filter out projects that have staff members with a specific role using a subquery that checks the 'Project_Staff' table for the specified role code, using a placeholder for string values."], "gold_sql": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_Staff WHERE role_code  =  'researcher' )", "source_tables": ["project_staff", "projects"], "description": "The virtual table provides a list of project details from the 'Projects' table for projects that do not have any associated staff members with a specific role. The placeholder in the WHERE clause represents the role code that is being filtered out.", "virtual_table": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING] )"}
{"sample_id": "train.4323", "db_id": "tracking_grants_for_research", "question": "What are the details of the project that is producing both patents and papers as outcomes?", "rationale": ["The query identifies the relevant table, which is 'Projects', and aliases it as T1.", "It joins the 'Project_Outcomes' table, aliased as T2, on the project_id to link projects with their outcomes.", "The WHERE clause filters the results based on the outcome_code for the first condition using a placeholder for string values.", "The INTERSECT operator is used to find projects that meet both outcome criteria, with a second WHERE clause for the second outcome_code, also using a placeholder for string values."], "gold_sql": "SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  'Paper' INTERSECT SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  'Patent'", "source_tables": ["project_outcomes", "projects"], "description": "The virtual table provides a list of project details from the 'Projects' table that have specific outcomes. It uses an intersection to find projects that meet two different outcome criteria, represented by placeholders for the outcome codes.", "virtual_table": "SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4391", "db_id": "tracking_grants_for_research", "question": "For each project id, how many tasks are there?", "rationale": ["The query identifies the relevant tables, which are 'Projects' and 'Tasks'.", "It selects the count of tasks and the project details from the 'Projects' table.", "A JOIN operation is performed on the 'project_id' to link tasks to their respective projects.", "The GROUP BY clause is used to aggregate the results by each project, allowing for a count of tasks per project."], "gold_sql": "SELECT count(*) ,  T1.project_details FROM Projects AS T1 JOIN Tasks AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id", "source_tables": ["tasks", "projects"], "description": "This virtual table provides a count of tasks associated with each project along with the project details from the 'Projects' table. The count represents the number of tasks linked to each project, and the project details give additional context about each project. The grouping by project ID ensures that the count is calculated for each distinct project.", "virtual_table": "SELECT count(*) ,  T1.project_details FROM Projects AS T1 JOIN Tasks AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id"}
{"sample_id": "train.4359", "db_id": "tracking_grants_for_research", "question": "What are the details of the project with no outcomes?", "rationale": ["The query identifies the relevant table, which is 'Projects'.", "Select the column to display, 'project_details'.", "Add a condition to filter projects that do not have associated outcomes by using a subquery that selects 'project_id' from the 'Project_Outcomes' table."], "gold_sql": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_outcomes )", "source_tables": ["project_outcomes", "projects"], "description": "This virtual table provides details of projects from the 'Projects' table that do not have any associated outcomes in the 'Project_Outcomes' table. The placeholder in the WHERE clause indicates that we are filtering projects based on their unique identifiers, ensuring we only retrieve those without outcomes.", "virtual_table": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_outcomes )"}
{"sample_id": "train.4351", "db_id": "tracking_grants_for_research", "question": "For each project id, how many staff does it have? List them in increasing order.", "rationale": ["The query identifies the relevant tables, which are 'Project_Staff' and 'Projects'.", "It selects the 'project_id' from 'Project_Staff' and counts the number of staff members associated with each project.", "A JOIN operation is performed between 'Project_Staff' and 'Projects' on the 'project_id' to link staff to their respective projects.", "The results are grouped by 'project_id' to aggregate the count of staff members for each project.", "Finally, the results are ordered by the count of staff members in ascending order."], "gold_sql": "SELECT T1.project_id ,  count(*) FROM Project_Staff AS T1 JOIN Projects AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) ASC", "source_tables": ["project_staff", "projects"], "description": "The virtual table summarizes the number of staff members associated with each project from the 'Project_Staff' table, joined with the 'Projects' table to ensure that only valid projects are considered. The results are grouped by project ID and ordered by the count of staff members in ascending order.", "virtual_table": "SELECT T1.project_id ,  count(*) FROM Project_Staff AS T1 JOIN Projects AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) ASC"}
{"sample_id": "train.4385", "db_id": "tracking_grants_for_research", "question": "What are the details for the projects which were launched by the organization with the most projects?", "rationale": ["The query identifies the relevant table, which is 'Projects'.", "It selects the 'project_details' column to display information about the projects.", "The WHERE clause filters the results to include only those organisations whose IDs are found in a subquery.", "The subquery groups the projects by 'organisation_id' and orders them by the count of projects in descending order, limiting the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT 1 )", "source_tables": ["projects"], "description": "This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.", "virtual_table": "SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] )"}
{"sample_id": "train.4393", "db_id": "tracking_grants_for_research", "question": "What roles did staff members play between '2003-04-19 15:06:20' and '2016-03-15 00:33:18'?", "rationale": ["The query identifies the relevant table, which is 'Project_Staff'.", "Select the column to display, 'role_code'.", "Add conditions to filter the 'date_from' and 'date_to' columns for the specified date range using placeholders for string values."], "gold_sql": "SELECT role_code FROM Project_Staff WHERE date_from  >  '2003-04-19 15:06:20' AND date_to  <  '2016-03-15 00:33:18'", "source_tables": ["project_staff"], "description": "This virtual table provides the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.", "virtual_table": "SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4332", "db_id": "tracking_grants_for_research", "question": "Which organisation type hires most research staff?", "rationale": ["The query identifies the relevant tables, 'Organisations' and 'Research_Staff'.", "It selects the 'organisation_type' from the 'Organisations' table.", "A JOIN operation is performed to link 'Organisations' with 'Research_Staff' based on the organisation ID.", "The results are grouped by 'organisation_type' to aggregate the data.", "The ORDER BY clause sorts the results by the count of research staff in descending order.", "The LIMIT clause uses a placeholder to allow the user to specify how many organisation types to return."], "gold_sql": "SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "description": "This virtual table provides a list of organisation types associated with research staff, grouped by the type of organisation. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisation types to retrieve, based on the count of research staff associated with each type.", "virtual_table": "SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4373", "db_id": "tracking_grants_for_research", "question": "What are the details of all organizations that are described as Sponsors and sort the results in ascending order?", "rationale": ["The query identifies the relevant tables, which are 'Organisations' and 'Organisation_Types'.", "It selects the 'organisation_details' column from the 'Organisations' table.", "A JOIN operation is performed on the 'organisation_type' column to link the two tables based on their relationship.", "A condition is added to filter the results based on the 'organisation_type_description' using a placeholder for string values.", "The results are ordered by 'organisation_details' to provide a sorted output."], "gold_sql": "SELECT organisation_details FROM Organisations AS T1 JOIN organisation_Types AS T2 ON T1.organisation_type  =  T2.organisation_type WHERE T2.organisation_type_description  =  'Sponsor' ORDER BY organisation_details", "source_tables": ["organisation_types", "organisations"], "description": "The virtual table provides details about organisations filtered by their type description. It joins the 'Organisations' table with the 'Organisation_Types' table to retrieve the organisation details for a specific type of organisation. The placeholder in the WHERE clause represents the description of the organisation type.", "virtual_table": "SELECT organisation_details FROM Organisations AS T1 JOIN organisation_Types AS T2 ON T1.organisation_type  =  T2.organisation_type WHERE T2.organisation_type_description  =  [PLACEHOLDER-TYPE:STRING] ORDER BY organisation_details"}
{"sample_id": "train.4377", "db_id": "tracking_grants_for_research", "question": "How many project members were leaders or started working before '1989-04-24 23:51:54'?", "rationale": ["The query identifies the relevant table, which is 'Project_Staff'.", "It counts the total number of entries in the 'Project_Staff' table.", "The WHERE clause includes conditions to filter by 'role_code' and 'date_from', using placeholders for string values."], "gold_sql": "SELECT count(*) FROM Project_Staff WHERE role_code  =  'leader' OR date_from  <  '1989-04-24 23:51:54'", "source_tables": ["project_staff"], "description": "This virtual table provides a count of staff members associated with projects, filtered by a specific role or a date condition. The placeholders in the WHERE clause represent the role code and the date from which to start counting staff members.", "virtual_table": "SELECT count(*) FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING] OR date_from  <  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4396", "db_id": "tracking_grants_for_research", "question": "Which role is most common for the staff?", "rationale": ["The query identifies the relevant table, which is 'Project_Staff'.", "It selects the 'role_code' column to display unique role codes.", "The GROUP BY clause is used to group the results by 'role_code' to aggregate the data.", "The ORDER BY clause sorts the grouped results by the count of occurrences in descending order to highlight the most common roles.", "The LIMIT clause uses a placeholder to allow the user to specify how many of the top role codes they want to retrieve."], "gold_sql": "SELECT role_code FROM Project_Staff GROUP BY role_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_staff"], "description": "This virtual table summarizes the unique role codes from the 'Project_Staff' table, grouping them to identify the most common roles associated with projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of role codes to retrieve.", "virtual_table": "SELECT role_code FROM Project_Staff GROUP BY role_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4357", "db_id": "tracking_grants_for_research", "question": "What are the details and id of the project with the most outcomes?", "rationale": ["The query identifies the relevant table, which is 'Projects', aliased as T1.", "It selects the 'project_details' and 'project_id' columns from the 'Projects' table.", "The query joins the 'Project_Outcomes' table, aliased as T2, on the 'project_id' to link projects with their outcomes.", "The results are grouped by 'project_id' to aggregate the outcomes for each project.", "The results are ordered by the count of outcomes in descending order to prioritize projects with more outcomes.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.project_details ,  T1.project_id FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "projects"], "description": "This virtual table provides a summary of projects from the 'Projects' table, along with their details. It joins with the 'Project_Outcomes' table to aggregate the outcomes associated with each project. The results are grouped by project ID and ordered by the count of outcomes in descending order, allowing users to see the projects with the most outcomes. The placeholder in the LIMIT clause represents the maximum number of projects to return.", "virtual_table": "SELECT T1.project_details ,  T1.project_id FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4376", "db_id": "tracking_grants_for_research", "question": "How many project staff worked as leaders or started working before '1989-04-24 23:51:54'?", "rationale": ["The query identifies the relevant table, which is 'Project_Staff'.", "It counts the total number of entries in the 'Project_Staff' table.", "The WHERE clause includes conditions to filter by 'role_code' and 'date_from', using placeholders for string values."], "gold_sql": "SELECT count(*) FROM Project_Staff WHERE role_code  =  'leader' OR date_from  <  '1989-04-24 23:51:54'", "source_tables": ["project_staff"], "description": "This virtual table provides a count of staff members associated with projects, filtered by a specific role or a date condition. The placeholders in the WHERE clause represent the role code and the date from which to start counting staff members.", "virtual_table": "SELECT count(*) FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING] OR date_from  <  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4337", "db_id": "tracking_grants_for_research", "question": "What is the response received date for the document described as Regular that was granted more than 100 dollars?", "rationale": ["The query identifies the relevant tables: 'Documents', 'Document_Types', and 'Grants'.", "It selects the 'response_received_date' from the 'Documents' table.", "The JOIN operations link the 'Documents' table with 'Document_Types' and 'Grants' based on their respective foreign keys.", "The WHERE clause filters results based on the document description and grant amount, using placeholders for user-defined values."], "gold_sql": "SELECT T1.response_received_date FROM Documents AS T1 JOIN Document_Types AS T2 ON T1.document_type_code  =  T2.document_type_code JOIN Grants AS T3 ON T1.grant_id  =  T3.grant_id WHERE T2.document_description  =  'Regular' OR T3.grant_amount  >  100", "source_tables": ["grants", "document_types", "documents"], "description": "The virtual table provides the response received dates of documents from the 'Documents' table, filtered by either the description of the document type from the 'Document_Types' table or the grant amount from the 'Grants' table. The placeholders in the WHERE clause represent the specific document description and the grant amount criteria.", "virtual_table": "SELECT T1.response_received_date FROM Documents AS T1 JOIN Document_Types AS T2 ON T1.document_type_code  =  T2.document_type_code JOIN Grants AS T3 ON T1.grant_id  =  T3.grant_id WHERE T2.document_description  =  [PLACEHOLDER-TYPE:STRING] OR T3.grant_amount  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4342", "db_id": "tracking_grants_for_research", "question": "When do all the researcher role staff start to work, and when do they stop working?", "rationale": ["The query identifies the relevant table, which is 'Project_Staff'.", "Select the columns to display, 'date_from' and 'date_to', which indicate the duration of staff involvement.", "Add a condition to filter the 'role_code' column for the specified role using a placeholder for string values."], "gold_sql": "SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  'researcher'", "source_tables": ["project_staff"], "description": "This virtual table provides information about the start and end dates of staff members' involvement in various projects from the 'Project_Staff' table, filtered by a specific role code. The placeholder in the WHERE clause represents the role of the staff member.", "virtual_table": "SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4350", "db_id": "tracking_grants_for_research", "question": "How many staff does each project has? List the project id and the number in an ascending order.", "rationale": ["The query identifies the relevant tables, which are 'Project_Staff' and 'Projects'.", "It selects the 'project_id' from 'Project_Staff' and counts the number of staff members associated with each project.", "A JOIN operation is performed between 'Project_Staff' and 'Projects' on the 'project_id' to link staff to their respective projects.", "The results are grouped by 'project_id' to aggregate the count of staff members for each project.", "Finally, the results are ordered by the count of staff members in ascending order."], "gold_sql": "SELECT T1.project_id ,  count(*) FROM Project_Staff AS T1 JOIN Projects AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) ASC", "source_tables": ["project_staff", "projects"], "description": "The virtual table summarizes the number of staff members associated with each project from the 'Project_Staff' table, joined with the 'Projects' table to ensure that only valid projects are considered. The results are grouped by project ID and ordered by the count of staff members in ascending order.", "virtual_table": "SELECT T1.project_id ,  count(*) FROM Project_Staff AS T1 JOIN Projects AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) ASC"}
{"sample_id": "train.4364", "db_id": "tracking_grants_for_research", "question": "Which document type is described with the prefix 'Initial'?", "rationale": ["The query identifies the relevant table, which is 'Document_Types'.", "It selects the column 'document_type_code' to display the unique codes for document types.", "A condition is added to filter the results based on the 'document_description' using a placeholder for string values."], "gold_sql": "SELECT document_type_code FROM Document_Types WHERE document_description LIKE 'Initial%'", "source_tables": ["document_types"], "description": "This virtual table provides a list of document type codes from the 'Document_Types' table that match a specific description. The placeholder in the WHERE clause allows for filtering based on the document description provided by the user.", "virtual_table": "SELECT document_type_code FROM Document_Types WHERE document_description LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4386", "db_id": "tracking_grants_for_research", "question": "List the research staff details, and order in ascending order.", "rationale": ["The query identifies the relevant table, which is 'Research_Staff'.", "Select the column to display, 'staff_details'.", "Add an ORDER BY clause to sort the results in ascending order based on 'staff_details'."], "gold_sql": "SELECT staff_details FROM Research_Staff ORDER BY staff_details ASC", "source_tables": ["research_staff"], "description": "The virtual table provides a list of details about research staff members from the 'Research_Staff' table, sorted in ascending order. This allows users to view the information in a structured manner, making it easier to analyze or retrieve specific details about the staff members involved in research activities.", "virtual_table": "SELECT staff_details FROM Research_Staff ORDER BY staff_details ASC"}
{"sample_id": "train.4325", "db_id": "tracking_grants_for_research", "question": "What is the total amount of grant money for research?", "rationale": ["The query identifies the relevant tables: 'Grants', 'Organisations', and 'Organisation_Types'.", "It selects the sum of the 'grant_amount' from the 'Grants' table.", "The query joins the 'Grants' table with the 'Organisations' table on the 'organisation_id' to link grants to their respective organisations.", "It further joins the 'Organisations' table with the 'Organisation_Types' table on 'organisation_type' to access the type descriptions.", "A condition is added to filter the results based on the 'organisation_type_description' using a placeholder for string values."], "gold_sql": "SELECT sum(grant_amount) FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id JOIN organisation_Types AS T3 ON T2.organisation_type  =  T3.organisation_type WHERE T3.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations"], "description": "The virtual table summarizes the total grant amounts associated with organisations of a specific type. It combines data from the 'Grants', 'Organisations', and 'Organisation_Types' tables, filtering the results based on the description of the organisation type provided by the user.", "virtual_table": "SELECT sum(grant_amount) FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id JOIN organisation_Types AS T3 ON T2.organisation_type  =  T3.organisation_type WHERE T3.organisation_type_description  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4353", "db_id": "tracking_grants_for_research", "question": "What is the complete description of the job of a researcher?", "rationale": ["The query identifies the relevant table, which is 'Staff_Roles'.", "Select the column to display, 'role_description'.", "Add a condition to filter the 'role_code' column for the specified role using a placeholder for string values."], "gold_sql": "SELECT role_description FROM Staff_Roles WHERE role_code  =  'researcher'", "source_tables": ["staff_roles"], "description": "This virtual table provides the descriptions of staff roles from the 'Staff_Roles' table based on a specific role code. The placeholder in the WHERE clause represents the unique code for the role being queried.", "virtual_table": "SELECT role_description FROM Staff_Roles WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4387", "db_id": "tracking_grants_for_research", "question": "What details are there on the research staff? List the result in ascending alphabetical order.", "rationale": ["The query identifies the relevant table, which is 'Research_Staff'.", "Select the column to display, 'staff_details'.", "Add an ORDER BY clause to sort the results in ascending order based on 'staff_details'."], "gold_sql": "SELECT staff_details FROM Research_Staff ORDER BY staff_details ASC", "source_tables": ["research_staff"], "description": "The virtual table provides a list of details about research staff members from the 'Research_Staff' table, sorted in ascending order. This allows users to view the information in a structured manner, making it easier to analyze or retrieve specific details about the staff members involved in research activities.", "virtual_table": "SELECT staff_details FROM Research_Staff ORDER BY staff_details ASC"}
{"sample_id": "train.4374", "db_id": "tracking_grants_for_research", "question": "How many Patent outcomes are generated from all the projects?", "rationale": ["The query identifies the relevant table, which is 'Project_Outcomes'.", "It selects a count of all records that match a specific condition.", "The condition filters the records based on the 'outcome_code' column using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM Project_outcomes WHERE outcome_code  =  'Patent'", "source_tables": ["project_outcomes"], "description": "This virtual table provides a count of project outcomes from the 'Project_Outcomes' table that match a specific outcome code. The placeholder in the WHERE clause represents the outcome code being queried.", "virtual_table": "SELECT count(*) FROM Project_outcomes WHERE outcome_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5873", "db_id": "tracking_share_transactions", "question": "Show the number of transactions with transaction type code \"SALE\" for different investors if it is larger than 0.", "rationale": ["The query identifies the relevant table, which is 'Transactions'.", "It selects the 'investor_id' and counts the number of transactions for each investor.", "A condition is added to filter the results based on the 'transaction_type_code' using a placeholder for string values.", "The results are grouped by 'investor_id' to provide a count of transactions per investor."], "gold_sql": "SELECT investor_id ,  COUNT(*) FROM TRANSACTIONS WHERE transaction_type_code  =  'SALE' GROUP BY investor_id", "source_tables": ["transactions"], "description": "This virtual table summarizes the count of transactions for each investor from the 'Transactions' table, filtered by a specific transaction type. The placeholder in the WHERE clause represents the transaction type code.", "virtual_table": "SELECT investor_id ,  COUNT(*) FROM TRANSACTIONS WHERE transaction_type_code  =  [PLACEHOLDER-TYPE:STRING] GROUP BY investor_id"}
{"sample_id": "train.5865", "db_id": "tracking_share_transactions", "question": "What are the lot details of lots associated with transactions whose share count is bigger than 100 and whose type code is \"PUR\"?", "rationale": ["The query identifies the relevant tables: 'Lots', 'Transactions_Lots', and 'Transactions'.", "It selects the 'lot_details' from the 'Lots' table.", "The query joins 'Lots' with 'Transactions_Lots' to link lots to their respective transactions.", "It further joins 'Transactions_Lots' with 'Transactions' to access transaction details.", "Conditions are added to filter transactions where the 'share_count' exceeds a specified number and the 'transaction_type_code' matches a specified type, using placeholders for these values."], "gold_sql": "SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON  T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  >  100 AND T3.transaction_type_code  =  'PUR'", "source_tables": ["lots", "transactions_lots", "transactions"], "description": "This virtual table provides details of lots associated with transactions that meet specific criteria. It filters the lots based on the number of shares involved in the transaction and the type of transaction, represented by placeholders for numeric and string values respectively.", "virtual_table": "SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON  T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  >  [PLACEHOLDER-TYPE:NUMBER] AND T3.transaction_type_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5876", "db_id": "tracking_share_transactions", "question": "Show the transaction type code that occurs the most frequently.", "rationale": ["The query identifies the relevant table, which is 'Transactions'.", "It selects the 'transaction_type_code' to display the different types of transactions.", "The GROUP BY clause is used to group the results by 'transaction_type_code'.", "The ORDER BY clause sorts the grouped results based on the count of each transaction type in descending order.", "The LIMIT clause uses a placeholder to allow the user to specify how many transaction types they want to retrieve."], "gold_sql": "SELECT transaction_type_code FROM TRANSACTIONS GROUP BY transaction_type_code ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["transactions"], "description": "This virtual table summarizes the different types of transactions recorded in the 'Transactions' table, grouped by their unique transaction type codes. The placeholder in the LIMIT clause allows the user to specify the maximum number of transaction types to retrieve, sorted by their frequency in descending order.", "virtual_table": "SELECT transaction_type_code FROM TRANSACTIONS GROUP BY transaction_type_code ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5884", "db_id": "tracking_share_transactions", "question": "What are the details of the lots which are not used in any transactions?", "rationale": ["The query identifies the relevant table, which is 'Lots'.", "It selects the 'lot_details' column to display information about the lots.", "The EXCEPT clause is used to exclude lot details that are linked to transactions, which are identified by joining the 'Lots' table with the 'Transactions_Lots' table on the 'lot_id' column."], "gold_sql": "SELECT lot_details FROM Lots EXCEPT SELECT T1.lot_details FROM Lots AS T1 JOIN transactions_lots AS T2 ON T1.lot_id  =  T2.lot_id", "source_tables": ["lots", "transactions_lots"], "description": "This virtual table provides details of lots from the 'Lots' table that are not associated with any transactions. The query uses an EXCEPT clause to filter out lot details that are linked to transactions through the 'Transactions_Lots' table, ensuring only unlinked lots are displayed.", "virtual_table": "SELECT lot_details FROM Lots EXCEPT SELECT T1.lot_details FROM Lots AS T1 JOIN transactions_lots AS T2 ON T1.lot_id  =  T2.lot_id"}
{"sample_id": "train.5851", "db_id": "tracking_share_transactions", "question": "Show all dates of transactions whose type code is \"SALE\".", "rationale": ["The query identifies the relevant table, which is 'Transactions'.", "Select the column to display, 'date_of_transaction'.", "Add a condition to filter the 'transaction_type_code' column for the specified transaction type using a placeholder for string values."], "gold_sql": "SELECT date_of_transaction FROM TRANSACTIONS WHERE transaction_type_code  =  'SALE'", "source_tables": ["transactions"], "description": "This virtual table provides the dates of transactions from the 'Transactions' table that correspond to a specific type of transaction. The placeholder in the WHERE clause represents the unique code for the transaction type.", "virtual_table": "SELECT date_of_transaction FROM TRANSACTIONS WHERE transaction_type_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5485", "db_id": "voter_2", "question": "What are the first names and last names of the students who are 18 years old and have vice president votes.", "rationale": ["The query identifies the relevant tables, 'Student' and 'Voting_record'.", "It selects the distinct first and last names of students from the 'Student' table.", "A JOIN operation is performed between 'Student' and 'Voting_record' on the condition that the student's ID matches the vice presidential vote.", "A condition is added to filter the results based on the specified age using a placeholder for numeric values."], "gold_sql": "SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_President_VOTE WHERE T1.age  =  18", "source_tables": ["student", "voting_record"], "description": "This virtual table provides the first and last names of students who have voted in the vice presidential election, filtered by a specific age. The placeholder in the WHERE clause represents the age of the students.", "virtual_table": "SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_President_VOTE WHERE T1.age  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5497", "db_id": "voter_2", "question": "What are the distinct last names of the students who have president votes but do not have 2192 as the advisor?", "rationale": ["The query identifies the relevant tables, 'Student' and 'Voting_record'.", "It selects the distinct last names of students from the 'Student' table who have voted for a presidential candidate by joining on the 'StuID' and 'President_Vote' columns.", "The EXCEPT clause is used to exclude students who have a specific advisor, which is represented by a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote EXCEPT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  '2192'", "source_tables": ["student", "voting_record"], "description": "The virtual table presents the last names of students who have voted for a presidential candidate, excluding those who have a specific academic advisor. The placeholders in the query allow for the specification of the advisor's name to filter the results accordingly.", "virtual_table": "SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote EXCEPT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5498", "db_id": "voter_2", "question": "Find the distinct last names of all the students who have president votes and whose advisor is 8741.", "rationale": ["The query identifies the relevant tables, 'Student' and 'Voting_record'.", "It selects distinct last names from the 'Student' table where the student has voted for a presidential candidate.", "The JOIN operation links the 'Student' table with the 'Voting_record' table based on the condition that the student's ID matches the presidential vote.", "The INTERSECT operation ensures that only those students who have voted and are associated with a specific advisor are included in the final result."], "gold_sql": "SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote INTERSECT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  '8741'", "source_tables": ["student", "voting_record"], "description": "This virtual table provides the last names of students who have voted for a presidential candidate and are under a specific academic advisor. The placeholders in the query represent the advisor's name and the voting record for the presidential candidate.", "virtual_table": "SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote INTERSECT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5482", "db_id": "voter_2", "question": "Find the first and last names of all the female (sex is F) students who have president votes.", "rationale": ["The query identifies the relevant tables, which are 'Student' and 'Voting_record'.", "It selects distinct first and last names from the 'Student' table.", "A JOIN operation is performed between 'Student' and 'Voting_record' on the condition that the student ID matches the presidential vote.", "A condition is added to filter the results based on the gender of the students using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.President_VOTE WHERE T1.sex  =  'F'", "source_tables": ["student", "voting_record"], "description": "This virtual table provides a list of distinct first and last names of students from the 'Student' table who have voted for a presidential candidate, filtered by their gender. The placeholder in the WHERE clause represents the gender of the students.", "virtual_table": "SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.President_VOTE WHERE T1.sex  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5484", "db_id": "voter_2", "question": "Find the first and last name of all the students of age 18 who have vice president votes.", "rationale": ["The query identifies the relevant tables, 'Student' and 'Voting_record'.", "It selects the distinct first and last names of students from the 'Student' table.", "A join is performed between 'Student' and 'Voting_record' on the condition that the student's ID matches the vice presidential vote.", "A filter is applied to the 'age' column to only include students of a specified age using a placeholder for numeric values."], "gold_sql": "SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_President_VOTE WHERE T1.age  =  18", "source_tables": ["student", "voting_record"], "description": "This virtual table provides the first and last names of students who have voted in the vice presidential election, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.", "virtual_table": "SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_President_VOTE WHERE T1.age  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5483", "db_id": "voter_2", "question": "What are the first and last names of all the female students who have president votes?", "rationale": ["The query identifies the relevant tables, 'Student' and 'Voting_record'.", "It selects distinct first and last names from the 'Student' table.", "A JOIN operation is performed on the 'StuID' to link students with their voting records.", "A condition is added to filter the results based on the gender of the students using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.President_VOTE WHERE T1.sex  =  'F'", "source_tables": ["student", "voting_record"], "description": "This virtual table provides a list of distinct first and last names of students from the 'Student' table who have voted for a presidential candidate in the 'Voting_record' table. The placeholder in the WHERE clause represents the gender of the students being queried.", "virtual_table": "SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.President_VOTE WHERE T1.sex  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5465", "db_id": "voter_2", "question": "Return all the distinct secretary votes made in the fall election cycle.", "rationale": ["The query is identifying the relevant table, which is 'Voting_record'.", "Select the distinct values of the 'Secretary_Vote' column to avoid duplicates.", "Add a condition to filter the 'Election_Cycle' column for the specified election cycle using a placeholder for string values."], "gold_sql": "SELECT DISTINCT Secretary_Vote FROM VOTING_RECORD WHERE ELECTION_CYCLE  =  'Fall'", "source_tables": ["voting_record"], "description": "The virtual table describes the distinct votes cast for the secretary position from the 'Voting_record' table during a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.", "virtual_table": "SELECT DISTINCT Secretary_Vote FROM VOTING_RECORD WHERE ELECTION_CYCLE  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5478", "db_id": "voter_2", "question": "Find the distinct Advisor of students who have treasurer votes in the spring election cycle.", "rationale": ["The query identifies the relevant tables, 'Student' and 'Voting_record'.", "It selects the distinct 'Advisor' from the 'Student' table.", "A JOIN is performed on the 'StuID' from 'Student' and 'Treasurer_Vote' from 'Voting_record' to link students with their voting records.", "A condition is added to filter the results based on the specified 'Election_Cycle' using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.Advisor FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Treasurer_Vote WHERE T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "description": "This virtual table provides a list of unique academic advisors for students who voted for a specific treasurer in a given election cycle. The placeholder in the WHERE clause represents the election cycle identifier.", "virtual_table": "SELECT DISTINCT T1.Advisor FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Treasurer_Vote WHERE T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5508", "db_id": "voter_2", "question": "Which major has the most students?", "rationale": ["The query identifies the relevant table, which is 'Student'.", "It selects the 'Major' column to display the fields of study.", "The GROUP BY clause is used to group the results by 'Major' to count occurrences.", "The ORDER BY clause sorts the results in descending order based on the count of each major.", "The LIMIT clause restricts the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT Major FROM STUDENT GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "description": "This virtual table summarizes the majors of students from the 'Student' table, grouping them to show the most popular fields of study. The placeholder in the LIMIT clause represents the maximum number of majors to display.", "virtual_table": "SELECT Major FROM STUDENT GROUP BY major ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5490", "db_id": "voter_2", "question": "Find the average age of students who live in the city with code \"NYC\" and have secretary votes in the spring election cycle.", "rationale": ["The query identifies the relevant tables, 'Student' and 'Voting_record'.", "It selects the average age of students, which is calculated using the AVG function.", "A JOIN operation is performed on the 'StuID' to link students with their voting records based on the vote for the secretary candidate.", "Conditions are added to filter the results based on the specified city code and election cycle using placeholders for string values."], "gold_sql": "SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.city_code  =  'NYC' AND T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "description": "This virtual table calculates the average age of students from the 'Student' table who have voted for a specific candidate in the 'Voting_record' table. The placeholders in the WHERE clause represent the city code where the students reside and the election cycle during which the votes were cast.", "virtual_table": "SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.city_code  =  [PLACEHOLDER-TYPE:STRING] AND T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5464", "db_id": "voter_2", "question": "What are the distinct secretary votes in the fall election cycle?", "rationale": ["The query identifies the relevant table, which is 'Voting_record'.", "Select the distinct values of the 'Secretary_Vote' column to avoid duplicates.", "Add a condition to filter the records based on the 'Election_Cycle' column using a placeholder for string values."], "gold_sql": "SELECT DISTINCT Secretary_Vote FROM VOTING_RECORD WHERE ELECTION_CYCLE  =  'Fall'", "source_tables": ["voting_record"], "description": "The virtual table describes the distinct votes cast for the secretary position from the 'Voting_record' table during a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.", "virtual_table": "SELECT DISTINCT Secretary_Vote FROM VOTING_RECORD WHERE ELECTION_CYCLE  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5487", "db_id": "voter_2", "question": "Count the number of male students who had class senator votes in the fall election cycle.", "rationale": ["The query identifies the relevant tables, 'Student' and 'Voting_record'.", "It performs a JOIN operation on the 'StuID' to link students with their voting records.", "The SELECT statement counts the number of records that meet the specified conditions.", "The WHERE clause filters the results based on the student's gender and the election cycle using placeholders for string values."], "gold_sql": "SELECT count(*) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  Class_Senator_Vote WHERE T1.Sex  =  'M' AND T2.Election_Cycle  =  'Fall'", "source_tables": ["student", "voting_record"], "description": "This virtual table provides a count of students who are female or male and have voted in a specific election cycle for the class senator position. The placeholders in the WHERE clause represent the gender of the students and the election cycle identifier.", "virtual_table": "SELECT count(*) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  Class_Senator_Vote WHERE T1.Sex  =  [PLACEHOLDER-TYPE:STRING] AND T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5477", "db_id": "voter_2", "question": "What are the distinct ages of students who have secretary votes in the fall election cycle?", "rationale": ["The query identifies the relevant tables, which are 'Student' and 'Voting_record'.", "It selects the distinct 'Age' column from the 'Student' table.", "A JOIN operation is performed on 'StuID' to link the 'Student' table with the 'Voting_record' table based on the vote for the secretary candidate.", "A condition is added to filter the results based on the specified 'Election_Cycle' using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.Age FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Secretary_Vote WHERE T2.Election_Cycle  =  'Fall'", "source_tables": ["student", "voting_record"], "description": "This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.", "virtual_table": "SELECT DISTINCT T1.Age FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Secretary_Vote WHERE T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5493", "db_id": "voter_2", "question": "What is the average age of the female students with secretary votes in the spring election cycle?", "rationale": ["The query identifies the relevant tables, 'Student' and 'Voting_record'.", "It selects the average age from the 'Student' table.", "A JOIN is performed on the 'StuID' to link students with their voting records, specifically focusing on those who voted for the secretary candidate.", "Conditions are added to filter by the student's gender and the election cycle using placeholders for string values."], "gold_sql": "SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.Sex  =  'F' AND T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "description": "This virtual table calculates the average age of students from the 'Student' table who voted for a specific candidate in the 'Voting_record' table. The placeholders in the WHERE clause represent the gender of the students and the election cycle during which the votes were cast.", "virtual_table": "SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.Sex  =  [PLACEHOLDER-TYPE:STRING] AND T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5457", "db_id": "voter_2", "question": "List the major of each male student.", "rationale": ["The query identifies the relevant table, which is 'Student'.", "Select the column to display, 'Major'.", "Add a condition to filter the 'Sex' column for the specified gender using a placeholder for string values."], "gold_sql": "SELECT Major FROM STUDENT WHERE Sex  =  'M'", "source_tables": ["student"], "description": "This virtual table provides a list of majors from the 'Student' table for students of a specific gender. The placeholder in the WHERE clause represents the gender of the students being queried.", "virtual_table": "SELECT Major FROM STUDENT WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5475", "db_id": "voter_2", "question": "What are the distinct first names of the students who have class president votes?", "rationale": ["The query identifies the relevant tables, which are 'Student' and 'Voting_record'.", "It selects the distinct first names from the 'Student' table.", "A JOIN operation is performed between 'Student' and 'Voting_record' on the condition that the student's ID matches the class senator vote, ensuring that only students who voted for a class senator are included."], "gold_sql": "SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.CLASS_Senator_VOTE", "source_tables": ["student", "voting_record"], "description": "This virtual table provides the distinct first names of students who have cast votes for the class senator position. The placeholder in the JOIN clause represents the relationship between the students and their voting records, ensuring that only those students who participated in the voting for class senator are included.", "virtual_table": "SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.CLASS_Senator_VOTE"}
{"sample_id": "train.6582", "db_id": "wine_1", "question": "What are the countries for appelations with at most 3 wines?", "rationale": ["The query identifies the relevant tables, which are 'appellations' and 'wine'.", "It selects the 'County' from the 'appellations' table.", "A JOIN operation is performed between 'appellations' and 'wine' on the 'Appelation' column to link the two tables.", "The results are grouped by 'Appelation' to aggregate the data based on the number of wines.", "The HAVING clause is used to filter the groups where the count of wines is less than or equal to a specified number, represented by a placeholder."], "gold_sql": "SELECT T1.County FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation GROUP BY T2.Appelation HAVING count(*)  <=  3", "source_tables": ["wine", "appellations"], "description": "This virtual table provides a list of counties associated with appellations that have a limited number of wines produced. The placeholder in the HAVING clause represents the maximum count of wines allowed for the grouping.", "virtual_table": "SELECT T1.County FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation GROUP BY T2.Appelation HAVING count(*)  <=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6598", "db_id": "wine_1", "question": "What is the county that produces the most wines scoring higher than 90?", "rationale": ["The query identifies the relevant tables, which are 'appellations' and 'wine'.", "It selects the 'County' column from the 'appellations' table.", "A JOIN operation is performed between 'appellations' and 'wine' on the 'Appelation' column to combine relevant data.", "A condition is added to filter wines with a score greater than a specified number using a placeholder for numeric values.", "The results are grouped by 'County' to aggregate the data, and ordered by the count of wines in descending order.", "A limit is set on the number of counties returned, using another placeholder for numeric values."], "gold_sql": "SELECT T1.County FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T2.Score  >  90 GROUP BY T1.County ORDER BY count(*) DESC LIMIT 1", "source_tables": ["wine", "appellations"], "description": "This virtual table provides a list of counties where wines, rated above a certain score, are produced. It aggregates the data from the 'appellations' and 'wine' tables, linking them through the appellation name. The placeholders in the query allow users to specify the minimum score for the wine rating and the maximum number of counties to return.", "virtual_table": "SELECT T1.County FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T2.Score  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.County ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6587", "db_id": "wine_1", "question": "Find the top 3 wineries with the greatest number of wines made of white color grapes.", "rationale": ["The query identifies the relevant tables, which are 'grapes' and 'wine'.", "It selects the 'Winery' column from the 'wine' table.", "A JOIN operation is performed between 'grapes' and 'wine' on the 'Grape' column to link grape varieties to their respective wines.", "A condition is added to filter the results based on the specified grape color using a placeholder for string values.", "The results are grouped by winery to count the number of wines produced by each winery.", "The results are ordered in descending order based on the count of wines, and a limit is applied to restrict the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT T2.Winery FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.GRAPE  =  T2.GRAPE WHERE T1.Color  =  'White' GROUP BY T2.Winery ORDER BY count(*) DESC LIMIT 3", "source_tables": ["wine", "grapes"], "description": "The virtual table provides a list of wineries that produce wines made from grape varieties of a specific color. The placeholder in the WHERE clause represents the color of the grape, while the LIMIT placeholder allows for specifying the maximum number of wineries to return, sorted by the number of wines they produce.", "virtual_table": "SELECT T2.Winery FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.GRAPE  =  T2.GRAPE WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T2.Winery ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6548", "db_id": "wine_1", "question": "Find the white grape used to produce wines with scores above 90.", "rationale": ["The query identifies the relevant tables, which are 'grapes' and 'wine'.", "It selects distinct grape varieties from the 'grapes' table.", "A JOIN operation is performed between 'grapes' and 'wine' on the grape variety to combine relevant data.", "Conditions are added to filter the results based on the specified grape color and a minimum score for the wines using placeholders for string and numeric values."], "gold_sql": "SELECT DISTINCT T1.Grape FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'White' AND T2.score  >  90", "source_tables": ["wine", "grapes"], "description": "This virtual table lists distinct grape varieties from the 'grapes' table that have a specific color and are associated with wines that have a score above a certain threshold. The placeholders in the WHERE clause represent the grape color and the minimum score for filtering the results.", "virtual_table": "SELECT DISTINCT T1.Grape FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING] AND T2.score  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6543", "db_id": "wine_1", "question": "What are the names and scores of wines that are made of white color grapes?", "rationale": ["The query identifies the relevant tables, which are 'grapes' and 'wine'.", "It selects the columns to display, 'Name' and 'Score' from the 'wine' table.", "A JOIN operation is performed on the 'Grape' column to link the two tables based on the grape variety.", "A condition is added to filter the 'Color' column from the 'grapes' table for the specified color using a placeholder for string values."], "gold_sql": "SELECT T2.Name ,   T2.Score FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'White'", "source_tables": ["wine", "grapes"], "description": "This virtual table provides the names and scores of wines from the 'wine' table that are made from grape varieties of a specific color. The placeholder in the WHERE clause represents the color of the grape.", "virtual_table": "SELECT T2.Name ,   T2.Score FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6549", "db_id": "wine_1", "question": "What are the wines that have prices higher than 50 and made of Red color grapes?", "rationale": ["The query identifies the relevant tables, which are 'Grapes' and 'Wine'.", "It selects the 'Name' column from the 'Wine' table.", "A JOIN operation is performed on the 'Grape' column to link the two tables based on the grape variety.", "Conditions are added to filter the results based on the specified grape color and the price of the wine using placeholders for string and numeric values."], "gold_sql": "SELECT T2.Name FROM Grapes AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'Red' AND T2.price  >  50", "source_tables": ["wine", "grapes"], "description": "The virtual table describes the names of wines made from grape varieties of a specific color and priced above a certain amount. The placeholders in the WHERE clause represent the grape color and the price threshold.", "virtual_table": "SELECT T2.Name FROM Grapes AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING] AND T2.price  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6534", "db_id": "wine_1", "question": "What are the names of wines made from red grapes?", "rationale": ["The query identifies the relevant tables, which are 'grapes' and 'wine'.", "It uses a JOIN operation to connect the two tables based on the grape variety.", "The SELECT DISTINCT statement is used to ensure that only unique wine names are returned.", "A condition is added to filter the grape color using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T2.Name FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'Red'", "source_tables": ["wine", "grapes"], "description": "The virtual table lists the distinct names of wines made from grape varieties of a specific color. The placeholder in the WHERE clause represents the color of the grape, allowing users to filter the results based on their preference.", "virtual_table": "SELECT DISTINCT T2.Name FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6551", "db_id": "wine_1", "question": "What are the wines that have prices lower than 50 and have appelations in Monterey county?", "rationale": ["The query identifies the relevant tables, which are 'appellations' and 'wine'.", "It uses a JOIN operation to combine data from both tables based on the matching 'Appelation' column.", "The SELECT statement specifies that only the 'Name' of the wine should be returned.", "Conditions are added to filter the results based on the specified county and the price of the wine, using placeholders for user input."], "gold_sql": "SELECT T2.Name FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T1.County  =  'Monterey' AND T2.price  <  50", "source_tables": ["wine", "appellations"], "description": "The virtual table lists the names of wines produced in a specific county, filtered by a price threshold. The placeholders in the WHERE clause represent the county name and the maximum price of the wine.", "virtual_table": "SELECT T2.Name FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T1.County  =  [PLACEHOLDER-TYPE:STRING] AND T2.price  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6519", "db_id": "wine_1", "question": "Which winery is the wine that has the highest score from?", "rationale": ["The query identifies the relevant table, which is 'wine'.", "Select the column to display, 'Winery'.", "Order the results by the 'Score' column to rank the wineries based on their ratings.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT Winery FROM WINE ORDER BY SCORE LIMIT 1", "source_tables": ["wine"], "description": "This virtual table provides a list of wineries from the 'wine' table, ordered by their rating scores. The placeholder in the LIMIT clause allows the user to specify the maximum number of wineries to retrieve.", "virtual_table": "SELECT Winery FROM WINE ORDER BY SCORE LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6562", "db_id": "wine_1", "question": "What are the names of wines, sorted by price ascending?", "rationale": ["The query is identifying the relevant table, which is 'wine'.", "Select the distinct column to display, 'Name', to ensure unique wine names are listed.", "Add an ORDER BY clause to sort the results based on the 'Price' column, using a placeholder for the price value."], "gold_sql": "SELECT DISTINCT Name FROM WINE ORDER BY price", "source_tables": ["wine"], "description": "This virtual table lists the distinct names of wines from the 'wine' table, ordered by their retail price. The placeholder in the ORDER BY clause represents the price of the wines, allowing for dynamic sorting based on user input.", "virtual_table": "SELECT DISTINCT Name FROM WINE ORDER BY price"}
{"sample_id": "train.6560", "db_id": "wine_1", "question": "What are the names of wines, sorted in alphabetical order?", "rationale": ["The query is identifying the relevant table, which is 'wine'.", "Select the column to display, 'Name', ensuring that only unique names are retrieved using the DISTINCT keyword.", "Order the results alphabetically by the 'Name' column to present the wine names in a sorted manner."], "gold_sql": "SELECT DISTINCT Name FROM WINE ORDER BY Name", "source_tables": ["wine"], "description": "This virtual table lists the unique names of wines from the 'wine' table, sorted in alphabetical order. The query uses a DISTINCT clause to ensure that each wine name appears only once in the results.", "virtual_table": "SELECT DISTINCT Name FROM WINE ORDER BY Name"}
{"sample_id": "train.6531", "db_id": "wine_1", "question": "List the names of all distinct wines that have scores higher than 90.", "rationale": ["The query identifies the relevant table, which is 'wine'.", "Select the column to display, 'Name', which represents the names of the wines.", "Add a condition to filter the 'score' column for wines that have a score greater than the specified threshold using a placeholder for numeric values."], "gold_sql": "SELECT Name FROM WINE WHERE score  >  90", "source_tables": ["wine"], "description": "This virtual table provides the names of wines from the 'wine' table that have a score exceeding a specified threshold. The placeholder in the WHERE clause represents the minimum score for filtering the wines.", "virtual_table": "SELECT Name FROM WINE WHERE score  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.818", "db_id": "world_1", "question": "What is the total number of countries where Spanish is spoken by the largest percentage of people?", "rationale": ["The query identifies the relevant table, which is 'countrylanguage'.", "It selects the count of countries and the maximum percentage of speakers for the specified language.", "The WHERE clause filters the results based on the language using a placeholder for string values.", "The results are grouped by 'CountryCode' to provide the count and maximum percentage for each country."], "gold_sql": "SELECT count(*) ,   max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  'Spanish' GROUP BY CountryCode", "source_tables": ["countrylanguage"], "description": "This virtual table provides a count of countries and the maximum percentage of speakers for a specific language from the 'countrylanguage' table. The placeholder in the WHERE clause represents the language name being queried.", "virtual_table": "SELECT count(*) ,   max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING] GROUP BY CountryCode"}
{"sample_id": "dev.774", "db_id": "world_1", "question": "What are the African countries that have a  population less than any country in Asia?", "rationale": ["The query identifies the relevant table, which is 'country'.", "It selects the 'Name' column to display the names of the countries.", "The first condition filters countries based on the specified continent using a placeholder for string values.", "The second condition ensures that the population of the selected countries is less than the maximum population of any country in the same continent, which is determined by a subquery."], "gold_sql": "SELECT Name FROM country WHERE Continent  =  'Africa'  AND population  <  (SELECT max(population) FROM country WHERE Continent  =  'Asia')", "source_tables": ["country"], "description": "This virtual table lists the names of countries from the 'country' table that are located in a specific continent and have a population less than the maximum population of any country within the same continent. The placeholders in the WHERE clause represent the continent's name.", "virtual_table": "SELECT Name FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING]  AND population  <  (SELECT max(population) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "dev.777", "db_id": "world_1", "question": "What are the Asian countries which have a population larger than that of any country in Africa?", "rationale": ["The query identifies the relevant table, which is 'country'.", "It selects the 'Name' column to display the names of the countries.", "The first condition filters the countries based on the specified continent using a placeholder for string values.", "The second condition ensures that the population of the countries is greater than the minimum population of countries in the same continent, which is determined by a subquery."], "gold_sql": "SELECT Name FROM country WHERE Continent  =  'Asia'  AND population  >  (SELECT min(population) FROM country WHERE Continent  =  'Africa')", "source_tables": ["country"], "description": "This virtual table lists the names of countries from the 'country' table that are located in a specific continent and have a population greater than the minimum population of countries within the same continent. The placeholders in the WHERE clause represent the continent's name.", "virtual_table": "SELECT Name FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING]  AND population  >  (SELECT min(population) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "dev.819", "db_id": "world_1", "question": "Count the number of countries for which Spanish is the predominantly spoken language.", "rationale": ["The query identifies the relevant table, which is 'countrylanguage'.", "It selects the count of countries and the maximum percentage of speakers for the specified language.", "The WHERE clause filters the results based on the language using a placeholder for string values.", "The results are grouped by 'CountryCode' to provide the count and maximum percentage for each country."], "gold_sql": "SELECT count(*) ,   max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  'Spanish' GROUP BY CountryCode", "source_tables": ["countrylanguage"], "description": "This virtual table provides a count of countries and the maximum percentage of speakers for a specific language from the 'countrylanguage' table. The placeholder in the WHERE clause represents the name of the language being queried.", "virtual_table": "SELECT count(*) ,   max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING] GROUP BY CountryCode"}
{"sample_id": "dev.759", "db_id": "world_1", "question": "What languages are only used by a single country with a republic government?", "rationale": ["The query identifies the relevant tables, which are 'country' and 'countrylanguage'.", "It joins these tables on the country code to relate languages to their respective countries.", "A condition is added to filter countries based on their government form using a placeholder for string values.", "The query groups the results by language and uses a HAVING clause to filter languages that meet a specific count, using a placeholder for numeric values."], "gold_sql": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.GovernmentForm  =  'Republic' GROUP BY T2.Language HAVING COUNT(*)  =  1", "source_tables": ["country", "countrylanguage"], "description": "This virtual table provides a list of languages spoken in countries that have a specific form of government. The query joins the 'country' and 'countrylanguage' tables to filter languages based on the government form of the country. The placeholders in the WHERE clause represent the type of government and the number of languages spoken in those countries.", "virtual_table": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.GovernmentForm  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T2.Language HAVING COUNT(*)  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.758", "db_id": "world_1", "question": "Which languages are spoken by only one country in republic governments?", "rationale": ["The query identifies the relevant tables, which are 'country' and 'countrylanguage'.", "It selects the 'Language' column from the 'countrylanguage' table.", "The join condition links the 'country' table to the 'countrylanguage' table using the 'Code' and 'CountryCode' columns.", "A filter is applied to the 'GovernmentForm' column in the 'country' table using a placeholder for string values.", "The results are grouped by 'Language' to aggregate the data.", "A HAVING clause is included to filter the grouped results based on the count of languages, using a placeholder for numeric values."], "gold_sql": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.GovernmentForm  =  'Republic' GROUP BY T2.Language HAVING COUNT(*)  =  1", "source_tables": ["country", "countrylanguage"], "description": "This virtual table provides a list of languages spoken in countries that have a specific form of government. The query joins the 'country' and 'countrylanguage' tables based on the country code, filtering the results by the type of government using a placeholder for string values. Additionally, it groups the results by language and includes a condition to count the occurrences of each language, using a placeholder for numeric values.", "virtual_table": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.GovernmentForm  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T2.Language HAVING COUNT(*)  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.821", "db_id": "world_1", "question": "Return the codes of countries for which Spanish is the predominantly spoken language.", "rationale": ["The query identifies the relevant table, which is 'countrylanguage'.", "Select the 'CountryCode' and the maximum 'Percentage' of speakers for the specified language.", "Add a condition to filter the 'Language' column for the specified language using a placeholder for string values.", "Group the results by 'CountryCode' to aggregate the maximum percentage of speakers for each country."], "gold_sql": "SELECT CountryCode ,  max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  'Spanish' GROUP BY CountryCode", "source_tables": ["countrylanguage"], "description": "This virtual table provides the country codes along with the maximum percentage of speakers for a specific language from the 'countrylanguage' table. The placeholder in the WHERE clause represents the name of the language being queried.", "virtual_table": "SELECT CountryCode ,  max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING] GROUP BY CountryCode"}
{"sample_id": "dev.754", "db_id": "world_1", "question": "What are the countries where either English or Dutch is the official language ?", "rationale": ["The query identifies the relevant tables, which are 'country' and 'countrylanguage'.", "It selects the 'name' column from the 'country' table.", "The query joins the 'country' table with the 'countrylanguage' table on the country code to filter the results based on the specified language.", "It includes conditions to check for the specified language and its official status using placeholders for string values.", "The UNION operator is used to combine results from two similar queries, allowing for flexibility in the official status of the language."], "gold_sql": "select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  'english' and isofficial  =  't' union select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  'dutch' and isofficial  =  't'", "source_tables": ["country", "countrylanguage"], "description": "This virtual table provides a list of countries that speak a specific language, distinguishing between official and non-official status. The placeholders in the WHERE clause represent the language name and its official status.", "virtual_table": "select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  [PLACEHOLDER-TYPE:STRING] and isofficial  =  [PLACEHOLDER-TYPE:STRING] union select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  [PLACEHOLDER-TYPE:STRING] and isofficial  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.799", "db_id": "world_1", "question": "What are the different continents and the total popuation and average life expectancy corresponding to each, for continents that have an average life expectancy less than 72?", "rationale": ["The query identifies the relevant table, which is 'country'.", "It selects the sum of the 'Population' and the average of 'LifeExpectancy' columns, along with the 'Continent' column.", "The results are grouped by 'Continent' to aggregate the data accordingly.", "A condition is applied using the HAVING clause to filter continents where the average life expectancy is below a specified threshold, represented by a placeholder for numeric values."], "gold_sql": "SELECT sum(Population) ,  avg(LifeExpectancy) ,  Continent FROM country GROUP BY Continent HAVING avg(LifeExpectancy)  <  72", "source_tables": ["country"], "description": "This virtual table summarizes the total population and average life expectancy of countries grouped by continent. The placeholder in the HAVING clause represents a threshold for average life expectancy, allowing users to filter continents based on this criterion.", "virtual_table": "SELECT sum(Population) ,  avg(LifeExpectancy) ,  Continent FROM country GROUP BY Continent HAVING avg(LifeExpectancy)  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.786", "db_id": "world_1", "question": "Which unique cities are in Asian countries where Chinese is the official language ?", "rationale": ["The query identifies the relevant tables: 'country', 'countrylanguage', and 'city'.", "It joins these tables based on their foreign key relationships to connect countries with their languages and cities.", "The SELECT statement specifies that only distinct city names should be retrieved.", "The WHERE clause filters the results based on whether the language is official, the specific language name, and the continent of the country using placeholders for string values."], "gold_sql": "select distinct t3.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode join city as t3 on t1.code  =  t3.countrycode where t2.isofficial  =  't' and t2.language  =  'chinese' and t1.continent  =  'asia'", "source_tables": ["country", "city", "countrylanguage"], "description": "This virtual table provides a list of distinct city names from the 'city' table that are located in countries where a specific language is officially spoken. The query filters based on whether the language is official, the name of the language, and the continent of the country. The placeholders in the WHERE clause represent the official status of the language, the language name, and the continent.", "virtual_table": "select distinct t3.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode join city as t3 on t1.code  =  t3.countrycode where t2.isofficial  =  [PLACEHOLDER-TYPE:STRING] and t2.language  =  [PLACEHOLDER-TYPE:STRING] and t1.continent  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.820", "db_id": "world_1", "question": "What are the codes of countries where Spanish is spoken by the largest percentage of people?", "rationale": ["The query identifies the relevant table, which is 'countrylanguage'.", "Select the 'CountryCode' and the maximum 'Percentage' of speakers for the specified language.", "Add a condition to filter the 'Language' column for the specified language using a placeholder for string values.", "Group the results by 'CountryCode' to get the maximum percentage of speakers for each country."], "gold_sql": "SELECT CountryCode ,  max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  'Spanish' GROUP BY CountryCode", "source_tables": ["countrylanguage"], "description": "This virtual table provides the country codes along with the maximum percentage of speakers for a specific language from the 'countrylanguage' table. The placeholder in the WHERE clause represents the name of the language being queried.", "virtual_table": "SELECT CountryCode ,  max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING] GROUP BY CountryCode"}
{"sample_id": "dev.782", "db_id": "world_1", "question": "What are the codes of the countries that do not speak English and whose government forms are not Republic?", "rationale": ["The query identifies the relevant table, which is 'country'.", "It selects the 'Code' column from the 'country' table where the 'GovernmentForm' does not match a specified type using a placeholder for string values.", "The EXCEPT clause is used to exclude country codes from the 'countrylanguage' table where the 'Language' matches a specified language, also using a placeholder for string values."], "gold_sql": "SELECT Code FROM country WHERE GovernmentForm != 'Republic' EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  'English'", "source_tables": ["country", "countrylanguage"], "description": "This virtual table provides a list of country codes for countries that do not have a specific type of government, excluding those countries where a particular language is spoken. The placeholders in the query represent the type of government and the language name.", "virtual_table": "SELECT Code FROM country WHERE GovernmentForm != [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.772", "db_id": "world_1", "question": "What are the countries that have greater surface area than any country in Europe?", "rationale": ["The query identifies the relevant table, which is 'country'.", "It selects the 'Name' column to display the names of the countries.", "A subquery is used to find the minimum surface area of countries filtered by the specified continent, using a placeholder for string values in the WHERE clause."], "gold_sql": "SELECT Name FROM country WHERE SurfaceArea  >  (SELECT min(SurfaceArea) FROM country WHERE Continent  =  'Europe')", "source_tables": ["country"], "description": "This virtual table provides the names of countries from the 'country' table that have a surface area greater than the minimum surface area of countries located in a specified continent. The placeholder in the subquery represents the continent's name.", "virtual_table": "SELECT Name FROM country WHERE SurfaceArea  >  (SELECT min(SurfaceArea) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "dev.731", "db_id": "world_1", "question": "Give the mean GNP and total population of nations which are considered US territory.", "rationale": ["The query identifies the relevant table, which is 'country'.", "It selects the average GNP and the sum of the population columns to provide aggregate data.", "A condition is added to filter the results based on the 'GovernmentForm' column using a placeholder for string values."], "gold_sql": "SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  'US Territory'", "source_tables": ["country"], "description": "The virtual table summarizes the average Gross National Product (GNP) and total population of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.", "virtual_table": "SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.773", "db_id": "world_1", "question": "Which countries have greater area than that of any country in Europe?", "rationale": ["The query identifies the relevant table, which is 'country'.", "Select the column to display, 'Name', which represents the names of the countries.", "Add a condition to filter the countries based on their 'SurfaceArea' being greater than a subquery result.", "The subquery selects the minimum 'SurfaceArea' from the 'country' table where the 'Continent' matches the specified continent using a placeholder for string values."], "gold_sql": "SELECT Name FROM country WHERE SurfaceArea  >  (SELECT min(SurfaceArea) FROM country WHERE Continent  =  'Europe')", "source_tables": ["country"], "description": "This virtual table provides the names of countries from the 'country' table that have a surface area greater than the minimum surface area of countries located in a specified continent. The placeholder in the subquery represents the continent's name.", "virtual_table": "SELECT Name FROM country WHERE SurfaceArea  >  (SELECT min(SurfaceArea) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "dev.778", "db_id": "world_1", "question": "What are the country codes for countries that do not speak English?", "rationale": ["The query is identifying the relevant table, which is 'countrylanguage'.", "It selects the 'CountryCode' from the 'countrylanguage' table.", "The EXCEPT clause is used to exclude country codes where the specified language is an official language.", "A placeholder is used in the WHERE clause to represent the language being queried."], "gold_sql": "SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  'English'", "source_tables": ["countrylanguage"], "description": "This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is an official language. The placeholder in the query represents the name of the language being queried.", "virtual_table": "SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.723", "db_id": "world_1", "question": "How many people live in Asia, and what is the largest GNP among them?", "rationale": ["The query identifies the relevant table, which is 'country'.", "It selects the total population using the SUM function and the maximum GNP using the MAX function.", "A condition is added to filter the results based on the specified continent using a placeholder for string values."], "gold_sql": "SELECT sum(Population) ,  max(GNP) FROM country WHERE Continent  =  'Asia'", "source_tables": ["country"], "description": "This virtual table summarizes the total population and the maximum Gross National Product (GNP) of countries located in a specific continent. The placeholder in the WHERE clause represents the continent's name.", "virtual_table": "SELECT sum(Population) ,  max(GNP) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.760", "db_id": "world_1", "question": "Find the city with the largest population that uses English.", "rationale": ["The query identifies the relevant tables, which are 'city' and 'countrylanguage'.", "It selects the 'Name' and 'Population' columns from the 'city' table (aliased as T1).", "A JOIN operation is performed between 'city' and 'countrylanguage' on the 'CountryCode' to link cities with their respective languages.", "A condition is added to filter the results based on the specified language using a placeholder for string values.", "The results are ordered by population in descending order, and a limit is set on the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT T1.Name ,  T1.Population FROM city AS T1 JOIN countrylanguage AS T2 ON T1.CountryCode  =  T2.CountryCode WHERE T2.Language  =  'English' ORDER BY T1.Population DESC LIMIT 1", "source_tables": ["city", "countrylanguage"], "description": "This virtual table provides the names and populations of cities from the 'city' table that speak a specific language, as indicated in the 'countrylanguage' table. The placeholder in the WHERE clause represents the language name, while the placeholder in the LIMIT clause specifies the maximum number of results to return.", "virtual_table": "SELECT T1.Name ,  T1.Population FROM city AS T1 JOIN countrylanguage AS T2 ON T1.CountryCode  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.Population DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.713", "db_id": "world_1", "question": "What language is predominantly spoken in Aruba?", "rationale": ["The query identifies the relevant tables, which are 'country' and 'countrylanguage'.", "It selects the 'Language' column from the 'countrylanguage' table.", "A JOIN operation is performed on the 'Code' from the 'country' table and 'CountryCode' from the 'countrylanguage' table to link languages to their respective countries.", "A WHERE clause filters the results based on the specified country's name using a placeholder for string values.", "The results are ordered by the 'Percentage' column in descending order to show the most spoken languages first.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Name  =  'Aruba' ORDER BY Percentage DESC LIMIT 1", "source_tables": ["country", "countrylanguage"], "description": "This virtual table provides a list of languages spoken in a specific country, along with their respective percentages of speakers. The query joins the 'country' table with the 'countrylanguage' table based on the country code, filtering by the country's name. The results are ordered by the percentage of speakers in descending order, with a limit on the number of results returned.", "virtual_table": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Name  =  [PLACEHOLDER-TYPE:STRING] ORDER BY Percentage DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.779", "db_id": "world_1", "question": "Return the country codes for countries that do not speak English.", "rationale": ["The query is identifying the relevant table, which is 'countrylanguage'.", "It selects the 'CountryCode' from the 'countrylanguage' table.", "The EXCEPT clause is used to exclude country codes that have the specified language as an official language.", "A placeholder is used in the WHERE clause to allow users to specify the language they are interested in."], "gold_sql": "SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  'English'", "source_tables": ["countrylanguage"], "description": "This virtual table identifies the country codes of countries that do not have a specific language as an official language. The placeholder in the WHERE clause represents the language name that is being checked against the official languages of the countries.", "virtual_table": "SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.745", "db_id": "world_1", "question": "What is the number of nations that use English and Dutch?", "rationale": ["The query is identifying the relevant tables, which are 'country' and 'countrylanguage'.", "It uses a JOIN operation to combine data from both tables based on the country code.", "The INTERSECT operation is used to find countries that have both specified languages.", "The COUNT function is applied to count the number of countries that meet the criteria."], "gold_sql": "SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English' INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'Dutch')", "source_tables": ["country", "countrylanguage"], "description": "This virtual table counts the number of countries that have two specific languages spoken within them. The placeholders in the query represent the names of the languages being compared.", "virtual_table": "SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "dev.704", "db_id": "world_1", "question": "How many countries have a republic as their form of government?", "rationale": ["The query is identifying the relevant table, which is 'country'.", "The count function is used to determine the number of entries that meet the specified condition.", "A condition is added to filter the 'GovernmentForm' column for the specified type of government using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM country WHERE GovernmentForm  =  'Republic'", "source_tables": ["country"], "description": "This virtual table provides the count of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.", "virtual_table": "SELECT count(*) FROM country WHERE GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.724", "db_id": "world_1", "question": "What is the average life expectancy in African countries that are republics?", "rationale": ["The query identifies the relevant table, which is 'country'.", "It selects the average of the 'LifeExpectancy' column to calculate the average life expectancy.", "Conditions are added to filter the results based on the specified 'Continent' and 'GovernmentForm' using placeholders for string values."], "gold_sql": "SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  'Africa' AND GovernmentForm  =  'Republic'", "source_tables": ["country"], "description": "This virtual table provides the average life expectancy of countries from the 'country' table, filtered by a specific continent and government form. The placeholders in the WHERE clause represent the continent and government form criteria.", "virtual_table": "SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING] AND GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.725", "db_id": "world_1", "question": "Give the average life expectancy for countries in Africa which are republics?", "rationale": ["The query identifies the relevant table, which is 'country'.", "It selects the average of the 'LifeExpectancy' column to calculate the average life expectancy.", "Conditions are added to filter the results based on the specified 'Continent' and 'GovernmentForm' using placeholders for string values."], "gold_sql": "SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  'Africa' AND GovernmentForm  =  'Republic'", "source_tables": ["country"], "description": "This virtual table provides the average life expectancy of countries from the 'country' table, filtered by a specific continent and government form. The placeholders in the WHERE clause represent the continent and government form criteria.", "virtual_table": "SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING] AND GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.485", "db_id": "wta_1", "question": "How many different winners both participated in the WTA Championships and were left handed?", "rationale": ["The query identifies the relevant table, which is 'matches'.", "It counts the distinct names of winners using the 'winner_name' column.", "The query includes conditions to filter the results based on the specified tournament name and the winning player's hand using placeholders for string values."], "gold_sql": "SELECT count(DISTINCT winner_name) FROM matches WHERE tourney_name  =  'WTA Championships' AND winner_hand  =  'L'", "source_tables": ["matches"], "description": "This virtual table provides the count of distinct winners' names from the 'matches' table, filtered by a specific tournament name and the winning player's hand preference. The placeholders in the WHERE clause represent the tournament's name and the winning player's hand (e.g., left or right).", "virtual_table": "SELECT count(DISTINCT winner_name) FROM matches WHERE tourney_name  =  [PLACEHOLDER-TYPE:STRING] AND winner_hand  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.486", "db_id": "wta_1", "question": "Find the number of left handed winners who participated in the WTA Championships.", "rationale": ["The query identifies the relevant table, which is 'matches'.", "It counts the distinct names of winners using the 'winner_name' column.", "Conditions are added to filter the results based on the specified tournament name and the winner's playing hand, using placeholders for string values."], "gold_sql": "SELECT count(DISTINCT winner_name) FROM matches WHERE tourney_name  =  'WTA Championships' AND winner_hand  =  'L'", "source_tables": ["matches"], "description": "This virtual table provides the count of distinct winners from the 'matches' table based on a specific tournament name and the playing hand of the winners. The placeholders in the WHERE clause represent the tournament's name and the winner's playing hand.", "virtual_table": "SELECT count(DISTINCT winner_name) FROM matches WHERE tourney_name  =  [PLACEHOLDER-TYPE:STRING] AND winner_hand  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.475", "db_id": "wta_1", "question": "find the code of the country where has the greatest number of players.", "rationale": ["The query identifies the relevant table, which is 'players'.", "It selects the 'country_code' column to display the unique country codes of players.", "The GROUP BY clause is used to group the results by 'country_code'.", "The ORDER BY clause sorts the results based on the count of players from each country in descending order.", "The LIMIT clause uses a placeholder to allow the user to specify how many country codes they want to retrieve."], "gold_sql": "SELECT country_code FROM players GROUP BY country_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["players"], "description": "This virtual table provides a list of country codes from the 'players' table, grouped by the country code and ordered by the number of players from each country in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of country codes to retrieve.", "virtual_table": "SELECT country_code FROM players GROUP BY country_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.476", "db_id": "wta_1", "question": "What is the code of the country with the most players?", "rationale": ["The query identifies the relevant table, which is 'players'.", "It selects the 'country_code' column to display the unique country codes of players.", "The GROUP BY clause is used to group the results by 'country_code'.", "The ORDER BY clause sorts the results based on the count of players from each country in descending order.", "The LIMIT clause uses a placeholder to allow the user to specify how many country codes they want to retrieve."], "gold_sql": "SELECT country_code FROM players GROUP BY country_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["players"], "description": "This virtual table provides a list of country codes from the 'players' table, grouped by the country code and ordered by the number of players from each country in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of country codes to retrieve.", "virtual_table": "SELECT country_code FROM players GROUP BY country_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.469", "db_id": "wta_1", "question": "Find the average ranking for each player and their first name.", "rationale": ["The query identifies the relevant tables, which are 'players' and 'rankings'.", "It selects the average ranking and the first name of the players.", "A JOIN operation is performed on the player_id to combine data from both tables.", "The results are grouped by the first name to calculate the average ranking for each player."], "gold_sql": "SELECT avg(ranking) ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.first_name", "source_tables": ["rankings", "players"], "description": "This virtual table provides the average ranking of players along with their first names. The data is aggregated from the 'players' and 'rankings' tables, where players are identified by their unique player IDs. The average ranking is calculated for each player, and the results are grouped by the player's first name.", "virtual_table": "SELECT avg(ranking) ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.first_name"}
{"sample_id": "dev.459", "db_id": "wta_1", "question": "Find the first name and country code of the player who did the most number of tours.", "rationale": ["The query identifies the relevant tables, which are 'players' and 'rankings'.", "It selects the 'country_code' and 'first_name' columns from the 'players' table.", "A JOIN operation is performed between 'players' and 'rankings' on the 'player_id' to combine player information with their rankings.", "The results are ordered by the 'tours' column from the 'rankings' table in descending order to prioritize players with more tours.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.country_code ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id ORDER BY T2.tours DESC LIMIT 1", "source_tables": ["rankings", "players"], "description": "This virtual table provides a list of players' first names along with their country codes from the 'players' table, joined with the 'rankings' table. The results are ordered by the number of tours or events considered for their ranking in descending order, and the output is limited to a specified number of entries.", "virtual_table": "SELECT T1.country_code ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id ORDER BY T2.tours DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
