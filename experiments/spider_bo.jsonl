{"sample_id": "train.6779", "db_id": "activity_1", "question": "Show the first and last name of all the faculty members who participated in some activity, together with the number of activities they participated in.", "rationale": ["Identify the relevant tables, which are 'Faculty' and 'Faculty_Participates_In'.", "Select the columns to display: 'fname' and 'lname' from the 'Faculty' table, and count the number of activities from the 'Faculty_Participates_In' table.", "Join the 'Faculty' table with the 'Faculty_Participates_In' table on the faculty identifier to link faculty members with their activities.", "Group the results by the faculty identifier to count the number of activities for each faculty member."], "gold_sql": "SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID", "source_tables": ["faculty", "faculty_participates_in"], "description": "The virtual table presents the first and last names of faculty members from the 'Faculty' table who have participated in various activities, along with a count of the total number of activities each faculty member has engaged in. The join operation links the 'Faculty' table with the 'Faculty_Participates_In' table based on the faculty identifier, and the grouping is done by the faculty identifier to aggregate the count of activities.", "virtual_table": "SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID"}
{"sample_id": "train.6723", "db_id": "activity_1", "question": "Show the first name, last name, and phone number for all female faculty members.", "rationale": ["Identify the relevant table, which is 'Faculty'.", "Select the columns to display: 'Fname', 'Lname', and 'phone'.", "Add a condition to filter the 'Sex' column for female faculty members using a placeholder for string values."], "gold_sql": "SELECT Fname ,  Lname ,  phone FROM Faculty WHERE Sex  =  'F'", "source_tables": ["faculty"], "description": "The virtual table presents the first name, last name, and phone number of faculty members from the 'Faculty' table who are identified as female. The placeholder in the WHERE clause is used to specify the gender of the faculty members.", "virtual_table": "SELECT Fname ,  Lname ,  phone FROM Faculty WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6761", "db_id": "activity_1", "question": "Show the ids for all the faculty members who have at least 2 students.", "rationale": ["Identify the relevant tables, which are 'Faculty' and 'Student'.", "Join the 'Faculty' table with the 'Student' table on the advisor relationship.", "Select the 'FacID' from the 'Faculty' table.", "Group the results by 'FacID' to aggregate the number of students each faculty member advises.", "Add a condition in the HAVING clause to filter faculty members who advise at least a specified number of students using a placeholder for numeric values."], "gold_sql": "SELECT T1.FacID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID HAVING count(*)  >=  2", "source_tables": ["faculty", "student"], "description": "The virtual table lists the unique identifiers of faculty members from the 'Faculty' table who are advising at least a specified number of students. The placeholder in the HAVING clause indicates the minimum number of students that a faculty member must advise to be included in the results.", "virtual_table": "SELECT T1.FacID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6799", "db_id": "activity_1", "question": "Find the first names of the faculty members who participate in Canoeing and Kayaking.", "rationale": ["Identify the relevant tables: 'Faculty', 'Faculty_participates_in', and 'Activity'.", "Select the column to display, which is 'lname' from the 'Faculty' table.", "Join the 'Faculty' table with 'Faculty_participates_in' on 'FacID' to link faculty members to their activities.", "Join the 'Faculty_participates_in' table with 'Activity' on 'actid' to filter by activity names.", "Use an INTERSECT to ensure that only faculty members participating in both specified activities are included in the results.", "Add conditions to filter the 'activity_name' column for the specified activities using placeholders for string values."], "gold_sql": "SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' INTERSECT SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "description": "The virtual table describes the last names of faculty members from the 'Faculty' table who participate in specific activities. It combines results from two queries using an INTERSECT operation, ensuring that only faculty members who participate in both activities are included. The placeholders in the WHERE clause represent the names of the activities being queried.", "virtual_table": "SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6802", "db_id": "activity_1", "question": "Which students participate in both Canoeing and Kayaking as their activities? Tell me their student ids.", "rationale": ["Identify the relevant tables, which are 'Participates_in' and 'Activity'.", "Select the column to display, 'stuid', which represents the student IDs.", "Use JOIN to connect 'Participates_in' with 'Activity' based on the activity identifier 'actid'.", "Filter the results using INTERSECT to find students participating in both specified activities, with placeholders for the activity names."], "gold_sql": "SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  'Canoeing' INTERSECT SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  'Kayaking'", "source_tables": ["activity", "participates_in"], "description": "The virtual table identifies students who are involved in both specified activities by filtering the 'Participates_in' table based on the activity names. The placeholder in the query represents the names of the activities, allowing for the selection of student IDs who participate in both activities.", "virtual_table": "SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6797", "db_id": "activity_1", "question": "Find the first names of professors who are not playing Canoeing or Kayaking.", "rationale": ["Identify the relevant table, which is 'Faculty'.", "Select the column to display, 'lname'.", "Add a condition to filter the 'rank' column for the specified rank using a placeholder for string values.", "Use an EXCEPT clause to exclude faculty members who are participating in activities with specific names.", "Join the 'Faculty' table with 'Faculty_participates_in' and 'Activity' tables to filter out those participating in the specified activities."], "gold_sql": "SELECT lname FROM faculty WHERE rank  =  'Professor' EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "description": "The virtual table lists the last names of faculty members from the 'Faculty' table who hold a specific academic rank and are not participating in certain activities. The placeholders in the query represent the rank of the faculty and the names of the activities that are being excluded from the results.", "virtual_table": "SELECT lname FROM faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6800", "db_id": "activity_1", "question": "What are the first names of the faculty members playing both Canoeing and Kayaking?", "rationale": ["Identify the relevant tables: 'Faculty', 'Faculty_participates_in', and 'Activity'.", "Select the column to display, which is 'lname' from the 'Faculty' table.", "Join the 'Faculty' table with 'Faculty_participates_in' to link faculty members to their activities.", "Join the 'Faculty_participates_in' table with the 'Activity' table to filter by activity names.", "Use the INTERSECT operator to find faculty members who participate in both activities, with placeholders for the activity names."], "gold_sql": "SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' INTERSECT SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "description": "The virtual table describes the last names of faculty members from the 'Faculty' table who participate in both specified activities. The placeholders in the WHERE clauses represent the names of the activities, allowing for the selection of faculty members involved in both Canoeing and Kayaking.", "virtual_table": "SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6798", "db_id": "activity_1", "question": "What are the first names of the professors who do not play Canoeing or Kayaking as activities?", "rationale": ["Identify the relevant table, which is 'Faculty'.", "Select the column to display, 'lname'.", "Add a condition to filter the 'rank' column for the specified rank using a placeholder for string values.", "Use the EXCEPT clause to exclude faculty members who participate in specific activities by joining the 'Faculty' table with 'Faculty_participates_in' and 'Activity' tables.", "Add conditions to filter out the activities 'Canoeing' and 'Kayaking' using placeholders for string values."], "gold_sql": "SELECT lname FROM faculty WHERE rank  =  'Professor' EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "description": "The virtual table describes the last names of faculty members from the 'Faculty' table who hold a specific academic rank and do not participate in certain activities. The placeholders in the query represent the rank of the faculty and the names of the activities that are being excluded from the results.", "virtual_table": "SELECT lname FROM faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6796", "db_id": "activity_1", "question": "Which faculty members are playing either Canoeing or Kayaking? Tell me their first names.", "rationale": ["Identify the relevant tables: 'Faculty', 'Faculty_Participates_in', and 'Activity'.", "Select the column to display, which is the last name of faculty members.", "Join the 'Faculty' table with 'Faculty_Participates_in' on the faculty ID, and then join with the 'Activity' table on the activity ID.", "Add a condition to filter the 'activity_name' column for the specified activities using placeholders for string values."], "gold_sql": "SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "description": "The virtual table describes the distinct last names of faculty members from the 'Faculty' table who are participating in specific activities. The table joins the 'Faculty', 'Faculty_Participates_in', and 'Activity' tables to filter faculty based on their participation in activities, with placeholders representing the names of the activities.", "virtual_table": "SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6789", "db_id": "activity_1", "question": "Show the ids for all the students who participate in an activity and are under 20.", "rationale": ["Identify the relevant tables, which are 'Participates_in' and 'Student'.", "Select the column to display, 'StuID', from the 'Participates_in' table.", "Use an INTERSECT operation to ensure that only students who participate in activities are included.", "Add a condition to filter the 'Student' table for students under a specified age using a placeholder for numeric values."], "gold_sql": "SELECT StuID FROM Participates_in INTERSECT SELECT StuID FROM Student WHERE age  <  20", "source_tables": ["student", "participates_in"], "description": "The virtual table provides the unique identifiers of students from the 'Participates_in' table who are involved in activities and are under a specified age. The placeholder in the WHERE clause represents the age limit for filtering the students.", "virtual_table": "SELECT StuID FROM Participates_in INTERSECT SELECT StuID FROM Student WHERE age  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6738", "db_id": "activity_1", "question": "Find the building that has the largest number of faculty members.", "rationale": ["Identify the relevant table, which is 'Faculty'.", "Select the 'building' column to display.", "Group the results by 'building' to count the number of faculty members in each building.", "Order the results by the count of faculty members in descending order to find the building with the most faculty.", "Use a placeholder in the LIMIT clause to specify how many results to return."], "gold_sql": "SELECT building FROM Faculty GROUP BY building ORDER BY count(*) DESC LIMIT 1", "source_tables": ["faculty"], "description": "The virtual table summarizes the buildings where faculty members are located, grouped by each building. It orders the results by the count of faculty members in descending order, allowing the identification of the building with the largest number of faculty members. The placeholder in the LIMIT clause indicates the maximum number of results to return.", "virtual_table": "SELECT building FROM Faculty GROUP BY building ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6753", "db_id": "activity_1", "question": "Show first name and last name for all the students advised by Michael Goodrich.", "rationale": ["Identify the relevant tables, which are 'Faculty' and 'Student'.", "Select the columns to display, 'fname' and 'lname' from the 'Student' table.", "Join the 'Faculty' table with the 'Student' table on the advisor relationship.", "Add conditions to filter the faculty member's first and last names using placeholders for string values."], "gold_sql": "SELECT T2.fname ,  T2.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.fname  =  'Michael' AND T1.lname  =  'Goodrich'", "source_tables": ["faculty", "student"], "description": "The virtual table describes the first and last names of students from the 'Student' table who are advised by a specific faculty member. The placeholders in the WHERE clause represent the first and last names of the faculty member being queried.", "virtual_table": "SELECT T2.fname ,  T2.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6781", "db_id": "activity_1", "question": "Show all the activity names and the number of faculty involved in each activity.", "rationale": ["Identify the relevant tables, which are 'Activity' and 'Faculty_Participates_in'.", "Select the 'activity_name' from the 'Activity' table and count the number of faculty members from the 'Faculty_Participates_in' table.", "Join the two tables on the activity identifier to link activities with their respective faculty participants.", "Group the results by the activity identifier to ensure the count reflects the number of faculty per activity."], "gold_sql": "SELECT T1.activity_name ,  count(*) FROM Activity AS T1 JOIN Faculty_participates_in AS T2 ON T1.actID  =  T2.actID GROUP BY T1.actID", "source_tables": ["activity", "faculty_participates_in"], "description": "The virtual table presents the names of activities along with the count of faculty members participating in each activity. The join between the 'Activity' and 'Faculty_Participates_in' tables allows for the aggregation of faculty involvement per activity, with the grouping based on the unique activity identifier.", "virtual_table": "SELECT T1.activity_name ,  count(*) FROM Activity AS T1 JOIN Faculty_participates_in AS T2 ON T1.actID  =  T2.actID GROUP BY T1.actID"}
{"sample_id": "train.6750", "db_id": "activity_1", "question": "Who is the advisor of Linda Smith? Give me the first name and last name.", "rationale": ["Identify the relevant tables, which are 'Faculty' and 'Student'.", "Select the columns to display, 'fname' and 'lname' from the 'Faculty' table.", "Join the 'Faculty' table with the 'Student' table on the advisor's ID.", "Add conditions to filter the 'Student' table for the specified first and last names using placeholders."], "gold_sql": "SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T2.fname  =  'Linda' AND T2.lname  =  'Smith'", "source_tables": ["faculty", "student"], "description": "The virtual table provides the first and last names of faculty members who serve as advisors to a specific student. The query joins the 'Faculty' and 'Student' tables based on the advisor's ID, filtering for the student's first and last name using placeholders.", "virtual_table": "SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T2.fname  =  [PLACEHOLDER-TYPE:STRING] AND T2.lname  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6733", "db_id": "activity_1", "question": "Show the first name and last name for all the instructors.", "rationale": ["Identify the relevant table, which is 'Faculty'.", "Select the columns to display, 'fname' and 'lname'.", "Add a condition to filter the 'Rank' column for the specified rank using a placeholder for string values."], "gold_sql": "SELECT fname ,  lname FROM Faculty WHERE Rank  =  'Instructor'", "source_tables": ["faculty"], "description": "The virtual table presents the first and last names of faculty members from the 'Faculty' table, filtered by their academic rank. The placeholder in the WHERE clause allows for specifying the desired rank of the instructors.", "virtual_table": "SELECT fname ,  lname FROM Faculty WHERE Rank  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6755", "db_id": "activity_1", "question": "Show the faculty id of each faculty member, along with the number of students he or she advises.", "rationale": ["Identify the relevant tables, which are 'Faculty' and 'Student'.", "Select the 'FacID' from the 'Faculty' table and count the number of students from the 'Student' table.", "Join the two tables on the condition that the faculty ID matches the advisor field in the 'Student' table.", "Group the results by faculty ID to aggregate the count of students advised by each faculty member."], "gold_sql": "SELECT T1.FacID ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID", "source_tables": ["faculty", "student"], "description": "The virtual table displays the faculty IDs of faculty members along with the count of students they advise. It combines data from the 'Faculty' table and the 'Student' table, using a join on the faculty ID and the advisor field. The result is grouped by faculty ID to provide a count of students for each faculty member.", "virtual_table": "SELECT T1.FacID ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID"}
{"sample_id": "train.6752", "db_id": "activity_1", "question": "Which students have professors as their advisors? Find their student ids.", "rationale": ["Identify the relevant tables, which are 'Faculty' and 'Student'.", "Select the column to display, which is 'StuID' from the 'Student' table.", "Join the 'Faculty' table with the 'Student' table on the condition that the faculty member's ID matches the advisor ID of the student.", "Add a condition to filter the results based on the faculty member's rank using a placeholder for string values."], "gold_sql": "SELECT T2.StuID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.rank  =  'Professor'", "source_tables": ["faculty", "student"], "description": "The virtual table lists the unique identifiers of students from the 'Student' table who have faculty members as their advisors. The join operation connects the 'Faculty' and 'Student' tables based on the faculty member's ID and the advisor ID of the student. A placeholder is used to filter the results based on the academic rank of the faculty advisor.", "virtual_table": "SELECT T2.StuID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.rank  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6766", "db_id": "activity_1", "question": "List all the activities we have.", "rationale": ["Identify the relevant table, which is 'Activity'.", "Select the column to display, 'activity_name'.", "No conditions are needed since the query requests all activities."], "gold_sql": "SELECT activity_name FROM Activity", "source_tables": ["activity"], "description": "The virtual table lists the names of all activities from the 'Activity' table. There are no filters or conditions applied, so it retrieves all available activity names.", "virtual_table": "SELECT activity_name FROM Activity"}
{"sample_id": "train.6725", "db_id": "activity_1", "question": "Show ids for all the male faculty.", "rationale": ["Identify the relevant table, which is 'Faculty'.", "Select the column to display, 'FacID'.", "Add a condition to filter the 'Sex' column for male faculty using a placeholder for string values."], "gold_sql": "SELECT FacID FROM Faculty WHERE Sex  =  'M'", "source_tables": ["faculty"], "description": "The virtual table contains the unique identifiers of faculty members from the 'Faculty' table who are male. The placeholder in the WHERE clause represents the gender of the faculty members.", "virtual_table": "SELECT FacID FROM Faculty WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6726", "db_id": "activity_1", "question": "What are the faculty ids of all the male faculty members?", "rationale": ["Identify the relevant table, which is 'Faculty'.", "Select the column to display, 'FacID'.", "Add a condition to filter the 'Sex' column for male faculty members using a placeholder for string values."], "gold_sql": "SELECT FacID FROM Faculty WHERE Sex  =  'M'", "source_tables": ["faculty"], "description": "The virtual table contains the unique identifiers of faculty members from the 'Faculty' table who are male. The placeholder in the WHERE clause represents the gender of the faculty members being queried.", "virtual_table": "SELECT FacID FROM Faculty WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.535", "db_id": "allergy_1", "question": "Find the first name and major of the students who are not allegry to soy.", "rationale": ["Identify the relevant table, which is 'Student'.", "Select the columns to display, 'fname' and 'major'.", "Add a condition to filter out students based on their allergies by using a subquery that checks the 'Has_Allergy' table for the specified allergy, using a placeholder for string values."], "gold_sql": "SELECT fname ,  major FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Soy')", "source_tables": ["has_allergy", "student"], "description": "The virtual table presents the first names and majors of students from the 'Student' table who do not have a specific allergy. The placeholder in the subquery represents the name of the allergy that is being excluded from the results.", "virtual_table": "SELECT fname ,  major FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.526", "db_id": "allergy_1", "question": "How old are the students with allergies to food and animal types on average?", "rationale": ["Identify the relevant table, which is 'Student' for age information.", "Use the AVG function to calculate the average age of students.", "Filter the students based on their allergies by using a subquery that joins 'Has_Allergy' and 'Allergy_Type' tables.", "The subquery checks for students with allergies of two specific types using placeholders for the allergy types."], "gold_sql": "SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food' INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'animal')", "source_tables": ["has_allergy", "allergy_type", "student"], "description": "The virtual table calculates the average age of students from the 'Student' table who have allergies categorized as food and animal types. The placeholders in the INTERSECT clause represent the specific allergy types being queried.", "virtual_table": "SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.520", "db_id": "allergy_1", "question": "What are the last names and ages of the students who are allergic to milk and cat?", "rationale": ["Identify the relevant table, which is 'Student'.", "Select the columns to display, 'lname' and 'age'.", "Use a subquery to filter 'StuID' from the 'Has_allergy' table for the specified allergies, ensuring that only students with both allergies are included."], "gold_sql": "SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "description": "The virtual table provides the last names and ages of students from the 'Student' table who have allergies to specific substances. The query uses a subquery to filter students based on their allergies, allowing for the identification of students who are allergic to both specified allergens.", "virtual_table": "SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.530", "db_id": "allergy_1", "question": "How many male students (sex is 'M') are allergic to any type of food?", "rationale": ["Identify the relevant table, which is 'Student'.", "Count the number of students by using the count(*) function.", "Add a condition to filter the 'sex' column for male students using a placeholder for string values.", "Use a subquery to filter students who have allergies by joining 'Has_Allergy' and 'Allergy_Type' tables on the allergy name, and filter for the specific allergy type using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM Student WHERE sex  =  'M' AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "description": "The virtual table provides a count of male students from the 'Student' table who have allergies to a specific type of food. The placeholders in the query represent the gender of the students and the type of allergy being queried.", "virtual_table": "SELECT count(*) FROM Student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.531", "db_id": "allergy_1", "question": "Find the different first names and cities of the students who have allergy to milk or cat.", "rationale": ["Identify the relevant tables, which are 'Student' and 'Has_Allergy'.", "Select the columns to display, 'fname' and 'city_code', ensuring that only distinct values are returned.", "Join the 'Student' table with the 'Has_Allergy' table on the student identifier to correlate students with their allergies.", "Add a condition to filter the 'Allergy' column for the specified allergies using placeholders for string values."], "gold_sql": "SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  'Milk' OR T2.Allergy  =  'Cat'", "source_tables": ["has_allergy", "student"], "description": "The virtual table describes the distinct first names and city codes of students from the 'Student' table who have specific allergies. The placeholders in the WHERE clause represent the names of the allergies that the students may have, allowing for the selection of students with either of the specified allergies.", "virtual_table": "SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  [PLACEHOLDER-TYPE:STRING] OR T2.Allergy  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.519", "db_id": "allergy_1", "question": "Find the last name and age of the student who has allergy to both milk and cat.", "rationale": ["Identify the relevant table, which is 'Student'.", "Select the columns to display, 'lname' and 'age'.", "Use a subquery to filter students based on their allergies by checking for the presence of both specified allergies using the INTERSECT operator."], "gold_sql": "SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "description": "The virtual table provides the last names and ages of students from the 'Student' table who have allergies to both specified allergens. The placeholders in the query represent the names of the allergies being checked.", "virtual_table": "SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.532", "db_id": "allergy_1", "question": "What are the distinct first names and cities of the students who have allergy either to milk or to cat?", "rationale": ["Identify the relevant tables, which are 'Student' and 'Has_Allergy'.", "Select the columns to display, 'fname' and 'city_code', ensuring distinct results.", "Join the 'Student' table with the 'Has_Allergy' table on the student identifier to correlate students with their allergies.", "Add a condition to filter the 'Allergy' column for the specified allergies using placeholders for string values."], "gold_sql": "SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  'Milk' OR T2.Allergy  =  'Cat'", "source_tables": ["has_allergy", "student"], "description": "The virtual table presents the distinct first names and city codes of students from the 'Student' table who have allergies to specific substances. The placeholders in the WHERE clause allow for the specification of the allergy names, enabling the query to filter students based on their allergies.", "virtual_table": "SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  [PLACEHOLDER-TYPE:STRING] OR T2.Allergy  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.536", "db_id": "allergy_1", "question": "What are the first name and major of the students who are able to consume soy?", "rationale": ["Identify the relevant table, which is 'Student'.", "Select the columns to display, 'fname' and 'major'.", "Add a condition to filter out students who have a specific allergy by using a subquery that checks the 'StuID' in the 'Has_Allergy' table, with a placeholder for the allergy name."], "gold_sql": "SELECT fname ,  major FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Soy')", "source_tables": ["has_allergy", "student"], "description": "The virtual table presents the first names and majors of students from the 'Student' table who do not have a specific allergy, in this case, soy. The placeholder in the WHERE clause is used to specify the allergy name that is being filtered out.", "virtual_table": "SELECT fname ,  major FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.528", "db_id": "allergy_1", "question": "What is the full name of each student who is not allergic to any type of food.", "rationale": ["Identify the relevant table, which is 'Student'.", "Select the columns to display, 'fname' and 'lname'.", "Add a condition to filter out students whose IDs are in the subquery results, which identifies students with allergies of a specific type using a placeholder for string values."], "gold_sql": "SELECT fname ,  lname FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "description": "The virtual table provides the first and last names of students from the 'Student' table who do not have any allergies to a specific type of food. The placeholder in the WHERE clause represents the category of allergy that is being excluded from the results.", "virtual_table": "SELECT fname ,  lname FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.492", "db_id": "allergy_1", "question": "What is the largest major?", "rationale": ["Identify the relevant table, which is 'Student'.", "Select the column to display, 'major'.", "Group the results by 'major' to count the number of students in each major.", "Order the results in descending order based on the count of students.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT major FROM Student GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "description": "The virtual table summarizes the academic majors of students from the 'Student' table, grouping them to count the number of students in each major. The placeholder in the LIMIT clause indicates the number of top majors to retrieve based on their student count.", "virtual_table": "SELECT major FROM Student GROUP BY major ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.513", "db_id": "allergy_1", "question": "Which allergy has most number of students affected?", "rationale": ["Identify the relevant table, which is 'Has_Allergy'.", "Select the 'Allergy' column to display.", "Group the results by 'Allergy' to count the number of students affected by each allergy.", "Order the results in descending order based on the count of students.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT 1", "source_tables": ["has_allergy"], "description": "The virtual table summarizes the allergies from the 'Has_Allergy' table, grouping them to count the number of students affected by each allergy. The results are ordered in descending order based on the count, allowing the identification of the allergy with the highest number of affected students. The placeholder in the LIMIT clause indicates the maximum number of results to return.", "virtual_table": "SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.448", "db_id": "allergy_1", "question": "What are all the different food allergies?", "rationale": ["Identify the relevant table, which is 'Allergy_Type'.", "Select the distinct values from the 'allergy' column to ensure no duplicates are included.", "Add a condition to filter the results based on the 'allergytype' column using a placeholder for string values."], "gold_sql": "SELECT DISTINCT allergy FROM Allergy_type WHERE allergytype  =  'food'", "source_tables": ["allergy_type"], "description": "The virtual table provides a list of unique food allergies from the 'Allergy_Type' table, filtered by a specific category of allergy. The placeholder in the WHERE clause represents the type of allergy being queried.", "virtual_table": "SELECT DISTINCT allergy FROM Allergy_type WHERE allergytype  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.455", "db_id": "allergy_1", "question": "Which allergy type has most number of allergies?", "rationale": ["Identify the relevant table, which is 'Allergy_Type'.", "Group the results by the 'AllergyType' column to categorize the allergies.", "Order the results by the count of allergies in descending order to find the most common allergy type.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT 1", "source_tables": ["allergy_type"], "description": "The virtual table summarizes the types of allergies categorized in the 'Allergy_Type' table, grouped by their respective allergy types. The query retrieves the allergy type that has the highest count of associated allergies, with a placeholder to limit the number of results returned.", "virtual_table": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.518", "db_id": "allergy_1", "question": "How many students are affected by each allergy type?", "rationale": ["Identify the relevant tables, which are 'Has_Allergy' and 'Allergy_Type'.", "Join the two tables on the allergy name to associate students with their respective allergy types.", "Select the 'allergytype' from the 'Allergy_Type' table and count the number of occurrences from the 'Has_Allergy' table.", "Group the results by 'allergytype' to get the count of students for each allergy type."], "gold_sql": "SELECT T2.allergytype ,  count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy GROUP BY T2.allergytype", "source_tables": ["has_allergy", "allergy_type"], "description": "The virtual table summarizes the count of students affected by each type of allergy. It combines data from the 'Has_Allergy' table, which links students to their allergies, and the 'Allergy_Type' table, which categorizes those allergies. The result groups the data by allergy type, providing a count of students for each category.", "virtual_table": "SELECT T2.allergytype ,  count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy GROUP BY T2.allergytype"}
{"sample_id": "train.510", "db_id": "allergy_1", "question": "How many students who are female are allergic to milk or eggs?", "rationale": ["Identify the relevant tables, which are 'Has_Allergy' and 'Student'.", "Count the total number of records that meet the specified criteria.", "Join the two tables on the unique student identifier 'StuID'.", "Filter the results based on the gender of the students and the specific allergies using placeholders for string values."], "gold_sql": "SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  'F' AND T1.allergy  =  'Milk' OR T1.allergy  =  'Eggs'", "source_tables": ["has_allergy", "student"], "description": "The virtual table provides a count of female students who have allergies to specific substances, namely milk or eggs. It combines data from the 'Has_Allergy' and 'Student' tables, filtering based on the gender of the students and the names of the allergies. The placeholders in the WHERE clause represent the gender and the names of the allergies being queried.", "virtual_table": "SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  [PLACEHOLDER-TYPE:STRING] AND T1.allergy  =  [PLACEHOLDER-TYPE:STRING] OR T1.allergy  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.450", "db_id": "allergy_1", "question": "What is allergy type of a cat allergy?", "rationale": ["Identify the relevant table, which is 'Allergy_Type'.", "Select the column to display, 'allergytype'.", "Add a condition to filter the 'allergy' column for the specified allergy name using a placeholder for string values."], "gold_sql": "SELECT allergytype FROM Allergy_type WHERE allergy  =  'Cat'", "source_tables": ["allergy_type"], "description": "The virtual table provides information about the type of allergy associated with a specific allergy name from the 'Allergy_Type' table. The placeholder in the WHERE clause represents the name of the allergy being queried.", "virtual_table": "SELECT allergytype FROM Allergy_type WHERE allergy  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.503", "db_id": "allergy_1", "question": "How many students have cat allergies?", "rationale": ["Identify the relevant table, which is 'Has_Allergy'.", "Use the count function to determine the number of students with a specific allergy.", "Add a condition to filter the 'Allergy' column for the specified allergy using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  'Cat'", "source_tables": ["has_allergy"], "description": "The virtual table provides a count of students from the 'Has_Allergy' table who have a specific type of allergy. The placeholder in the WHERE clause represents the name of the allergy being queried.", "virtual_table": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.512", "db_id": "allergy_1", "question": "How many students are affected by food related allergies?", "rationale": ["Identify the relevant tables, which are 'Has_Allergy' and 'Allergy_Type'.", "Use a JOIN operation to connect these tables based on the allergy name.", "Select the count of students affected by the specified allergy type using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  'food'", "source_tables": ["has_allergy", "allergy_type"], "description": "The virtual table provides a count of students who have food-related allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the WHERE clause specifies the type of allergy, allowing for filtering based on the allergy type.", "virtual_table": "SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.511", "db_id": "allergy_1", "question": "How many students have a food allergy?", "rationale": ["Identify the relevant tables, which are 'Has_Allergy' and 'Allergy_Type'.", "Count the number of records to determine how many students have allergies.", "Join the two tables on the allergy name to filter the results based on the allergy type using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  'food'", "source_tables": ["has_allergy", "allergy_type"], "description": "The virtual table provides a count of students who have a specific type of food allergy by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the WHERE clause represents the category of the allergy being queried.", "virtual_table": "SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.472", "db_id": "allergy_1", "question": "What are the student ids for all male students?", "rationale": ["Identify the relevant table, which is 'Student'.", "Select the column to display, 'StuID'.", "Add a condition to filter the 'Sex' column for male students using a placeholder for string values."], "gold_sql": "SELECT StuID FROM Student WHERE Sex  =  'M'", "source_tables": ["student"], "description": "The virtual table contains the unique identifiers of students from the 'Student' table who are male. The placeholder in the WHERE clause represents the gender of the students being queried.", "virtual_table": "SELECT StuID FROM Student WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.462", "db_id": "allergy_1", "question": "What are the full names of all students", "rationale": ["Identify the relevant table, which is 'Student'.", "Select the columns to display, 'Fname' and 'Lname', which represent the first and last names of the students."], "gold_sql": "SELECT Fname ,  Lname FROM Student", "source_tables": ["student"], "description": "The virtual table contains the first and last names of students from the 'Student' table. This allows for the retrieval of full names of all students enrolled.", "virtual_table": "SELECT Fname ,  Lname FROM Student"}
{"sample_id": "train.1262", "db_id": "apartment_rentals", "question": "Show the most common apartment type code among apartments with more than 1 bathroom.", "rationale": ["Identify the relevant table, which is 'Apartments'.", "Select the column to display, 'apt_type_code'.", "Add a condition to filter the 'bathroom_count' column for apartments with more than a specified number of bathrooms using a placeholder for numeric values.", "Group the results by 'apt_type_code' to aggregate the data.", "Order the results by the count of each apartment type in descending order to find the most common type.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT apt_type_code FROM Apartments WHERE bathroom_count  >  1 GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["apartments"], "description": "The virtual table summarizes the apartment type codes from the 'Apartments' table, specifically focusing on those apartments that have more than a specified number of bathrooms. The results are grouped by apartment type code and ordered by their frequency, allowing for the identification of the most common type. The placeholders in the query represent the minimum number of bathrooms and the limit on the number of results to return.", "virtual_table": "SELECT apt_type_code FROM Apartments WHERE bathroom_count  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1258", "db_id": "apartment_rentals", "question": "Show the apartment type code that has the largest number of total rooms, together with the number of bathrooms and number of bedrooms.", "rationale": ["Identify the relevant table, which is 'Apartments'.", "Select the columns to display: 'apt_type_code', 'bathroom_count', and 'bedroom_count'.", "Group the results by 'apt_type_code' to aggregate the data.", "Order the results by the sum of 'room_count' in descending order to find the apartment type with the largest total rooms.", "Add a limit to the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT apt_type_code ,  bathroom_count ,  bedroom_count FROM Apartments GROUP BY apt_type_code ORDER BY sum(room_count) DESC LIMIT 1", "source_tables": ["apartments"], "description": "The virtual table summarizes the apartment type codes along with the corresponding number of bathrooms and bedrooms from the 'Apartments' table. It groups the results by apartment type code and orders them by the total number of rooms in descending order, allowing the user to specify a limit on the number of results returned.", "virtual_table": "SELECT apt_type_code ,  bathroom_count ,  bedroom_count FROM Apartments GROUP BY apt_type_code ORDER BY sum(room_count) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1257", "db_id": "apartment_rentals", "question": "What are the top three apartment types in terms of the average room count? Give me the", "rationale": ["Identify the relevant table, which is 'Apartments'.", "Select the column to display, 'apt_type_code'.", "Group the results by 'apt_type_code' to aggregate data for each type.", "Calculate the average of 'room_count' for each apartment type and order the results in descending order.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY avg(room_count) DESC LIMIT 3", "source_tables": ["apartments"], "description": "The virtual table summarizes the apartment types from the 'Apartments' table, grouping them by their type code. It calculates the average room count for each apartment type and orders the results in descending order to identify the top types. The placeholder in the LIMIT clause allows for specifying the number of top results to return.", "virtual_table": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY avg(room_count) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1260", "db_id": "apartment_rentals", "question": "Show the most common apartment type code.", "rationale": ["Identify the relevant table, which is 'Apartments'.", "Select the column 'apt_type_code' to display the apartment type codes.", "Group the results by 'apt_type_code' to aggregate the counts of each type.", "Order the results in descending order based on the count of each apartment type code to find the most common ones.", "Use a placeholder in the LIMIT clause to specify how many of the most common apartment type codes to return."], "gold_sql": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["apartments"], "description": "The virtual table summarizes the apartment type codes from the 'Apartments' table, grouping them to identify the most common types. The placeholder in the LIMIT clause allows for specifying the number of results to return, indicating how many of the most common apartment type codes should be displayed.", "virtual_table": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1225", "db_id": "apartment_rentals", "question": "Find the booking start date and end date for the apartments that have more than two bedrooms.", "rationale": ["Identify the relevant tables, which are 'Apartment_Bookings' and 'Apartments'.", "Select the columns to display, 'booking_start_date' and 'booking_end_date' from the 'Apartment_Bookings' table.", "Join the 'Apartment_Bookings' table with the 'Apartments' table on the apartment ID to access bedroom information.", "Add a condition to filter the 'bedroom_count' column for apartments with more than a specified number of bedrooms using a placeholder for numeric values."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  2", "source_tables": ["apartment_bookings", "apartments"], "description": "The virtual table provides the booking start and end dates for apartments from the 'Apartment_Bookings' table that have a specified number of bedrooms. The placeholder in the WHERE clause allows for filtering apartments based on the number of bedrooms they contain.", "virtual_table": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1232", "db_id": "apartment_rentals", "question": "Show the guest first names, start dates, and end dates of all the apartment bookings.", "rationale": ["Identify the relevant tables, which are 'Apartment_Bookings' and 'Guests'.", "Select the columns to display: 'guest_first_name' from the 'Guests' table and 'booking_start_date' and 'booking_end_date' from the 'Apartment_Bookings' table.", "Use a JOIN operation to connect the two tables based on the 'guest_id' to ensure that the guest information corresponds to the correct booking."], "gold_sql": "SELECT T2.guest_first_name ,  T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id", "source_tables": ["apartment_bookings", "guests"], "description": "The virtual table provides the first names of guests along with the start and end dates of their apartment bookings. It combines data from the 'Apartment_Bookings' table, which contains booking details, and the 'Guests' table, which holds guest information. The join condition links the bookings to the respective guests using their unique identifiers.", "virtual_table": "SELECT T2.guest_first_name ,  T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id"}
{"sample_id": "train.1235", "db_id": "apartment_rentals", "question": "What are the start date and end date of the apartment bookings made by female guests (gender code \"Female\")?", "rationale": ["Identify the relevant tables, which are 'Apartment_Bookings' and 'Guests'.", "Select the columns to display, 'booking_start_date' and 'booking_end_date'.", "Join the two tables on the 'guest_id' to link bookings to guests.", "Add a condition to filter the 'gender_code' column for female guests using a placeholder for string values."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id WHERE T2.gender_code  =  'Female'", "source_tables": ["apartment_bookings", "guests"], "description": "The virtual table provides the start and end dates of apartment bookings from the 'Apartment_Bookings' table, specifically for bookings made by female guests. The join with the 'Guests' table allows filtering based on the gender code, represented by a placeholder for string values.", "virtual_table": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id WHERE T2.gender_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1233", "db_id": "apartment_rentals", "question": "What are the guest first name, start date, and end date of each apartment booking?", "rationale": ["Identify the relevant tables, which are 'Apartment_Bookings' and 'Guests'.", "Select the columns to display: 'guest_first_name' from the 'Guests' table and 'booking_start_date' and 'booking_end_date' from the 'Apartment_Bookings' table.", "Use a JOIN operation to connect the two tables based on the 'guest_id' to ensure that the booking information corresponds to the correct guest."], "gold_sql": "SELECT T2.guest_first_name ,  T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id", "source_tables": ["apartment_bookings", "guests"], "description": "The virtual table provides the first names of guests along with the start and end dates of their respective apartment bookings. It combines data from the 'Apartment_Bookings' table, which contains booking details, and the 'Guests' table, which holds guest information. The join condition links the bookings to the guests based on their unique identifiers.", "virtual_table": "SELECT T2.guest_first_name ,  T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id"}
{"sample_id": "train.1220", "db_id": "apartment_rentals", "question": "Show the apartment numbers, start dates, and end dates of all the apartment bookings.", "rationale": ["Identify the relevant tables, which are 'Apartment_Bookings' and 'Apartments'.", "Select the columns to display: 'apt_number' from the 'Apartments' table and 'booking_start_date' and 'booking_end_date' from the 'Apartment_Bookings' table.", "Use a JOIN operation to connect the two tables based on the apartment identifier, ensuring that the booking details correspond to the correct apartment."], "gold_sql": "SELECT T2.apt_number ,  T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id", "source_tables": ["apartment_bookings", "apartments"], "description": "The virtual table displays the apartment numbers along with the start and end dates of all apartment bookings. It combines data from the 'Apartment_Bookings' table, which contains booking details, and the 'Apartments' table, which provides information about the apartments, specifically their numbers. The join condition links the bookings to their respective apartments using the apartment identifier.", "virtual_table": "SELECT T2.apt_number ,  T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id"}
{"sample_id": "train.1239", "db_id": "apartment_rentals", "question": "What are the facility codes of the apartments with more than four bedrooms?", "rationale": ["Identify the relevant tables, which are 'Apartment_Facilities' and 'Apartments'.", "Select the column to display, 'facility_code' from 'Apartment_Facilities'.", "Join 'Apartment_Facilities' with 'Apartments' on the apartment identifier to link facilities to their respective apartments.", "Add a condition to filter the 'bedroom_count' column for apartments with more than a specified number of bedrooms using a placeholder for numeric values."], "gold_sql": "SELECT T1.facility_code FROM Apartment_Facilities AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  4", "source_tables": ["apartments", "apartment_facilities"], "description": "The virtual table describes the facility codes associated with apartments from the 'Apartment_Facilities' table that have a specific number of bedrooms. The placeholder in the WHERE clause represents the minimum number of bedrooms required for the apartments.", "virtual_table": "SELECT T1.facility_code FROM Apartment_Facilities AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3698", "db_id": "baseball_1", "question": "What are the first name and last name of the players who were paid salary by team Washington Nationals in both 2005 and 2007?", "rationale": ["Identify the relevant tables: 'salary' for salary records, 'player' for player names, and 'team' for team identification.", "Select the columns to display: 'name_first' and 'name_last' from the 'player' table.", "Join the 'salary' table with the 'player' table on 'player_id' to link salary information with player names.", "Join the 'salary' table with the 'team' table to filter by team name using the 'team_id_br' identifier.", "Use the INTERSECT operator to find players who appear in both salary records for the specified years, ensuring they were paid in both years."], "gold_sql": "SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2005 AND T3.name = 'Washington Nationals' INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2007 AND T3.name = 'Washington Nationals'", "source_tables": ["team", "player", "salary"], "description": "The virtual table provides the first and last names of players who received a salary from the Washington Nationals during the years specified. It combines data from the 'salary' table, which records salary information, with the 'player' table to retrieve player names. The query uses an INTERSECT operation to ensure that only players who were paid in both years (2005 and 2007) are included in the results. Placeholders are used for the year values and the team name to allow for flexible querying.", "virtual_table": "SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3683", "db_id": "baseball_1", "question": "What were all the salary values of players in 2010 and 2001?", "rationale": ["Identify the relevant table, which is 'salary'.", "Select the 'salary' column to display the salary values.", "Use a UNION to combine results from two different years, each specified by a placeholder for numeric values in the WHERE clause."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2010 UNION SELECT salary FROM salary WHERE YEAR  =  2001", "source_tables": ["salary"], "description": "The virtual table provides the salary values of players from the 'salary' table for two specific years. The placeholders in the WHERE clause represent the years for which the salary data is being queried, allowing for the retrieval of salary information for players in those years.", "virtual_table": "SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3641", "db_id": "baseball_1", "question": "In 2014, what are the id and rank of the team that has the largest average number of attendance?", "rationale": ["Identify the relevant tables: 'home_game' for attendance data and 'team' for team rankings.", "Select the columns to display: 'team_id' and 'rank' from the 'team' table.", "Join the 'home_game' table with the 'team' table on 'team_id' to correlate attendance with team rankings.", "Filter the results for a specific year using a placeholder for numeric values.", "Group the results by 'team_id' to calculate the average attendance for each team.", "Order the results by the average attendance in descending order to find the team with the largest average attendance.", "Limit the results to return only the top entry."], "gold_sql": "SELECT T2.team_id ,  T2.rank FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id WHERE T1.year  =  2014 GROUP BY T1.team_id ORDER BY avg(T1.attendance) DESC LIMIT 1;", "source_tables": ["team", "home_game"], "description": "The virtual table provides the team ID and rank of the team that has the highest average attendance for home games in a specified year. It combines data from the 'home_game' table, which records attendance figures, and the 'team' table, which contains team rankings. The query groups the results by team ID and orders them by the average attendance in descending order, allowing for the identification of the top team based on attendance.", "virtual_table": "SELECT T2.team_id ,  T2.rank FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id ORDER BY avg(T1.attendance) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3671", "db_id": "baseball_1", "question": "What is the number of wins the team Boston Red Stockings got in the postseasons each year in history?", "rationale": ["Identify the relevant tables: 'postseason' for postseason results and 'team' for team information.", "Select the count of wins and the year from the 'postseason' table.", "Join the 'postseason' table with the 'team' table on the winning team identifier to filter for the specific team.", "Group the results by year to get the number of wins per year for the specified team."], "gold_sql": "SELECT count(*) ,  T1.year FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' GROUP BY T1.year", "source_tables": ["postseason", "team"], "description": "The virtual table summarizes the count of wins achieved by the Boston Red Stockings in postseason games, organized by year. It combines data from the 'postseason' table, which records postseason results, and the 'team' table, which contains team identifiers and names. The placeholder in the WHERE clause is used to specify the team name, allowing for dynamic querying based on different team inputs.", "virtual_table": "SELECT count(*) ,  T1.year FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.year"}
{"sample_id": "train.3661", "db_id": "baseball_1", "question": "Find the players' first name and last name who won award both in 1960 and in 1961.", "rationale": ["Identify the relevant tables, which are 'player' and 'player_award'.", "Select the columns to display, 'name_first' and 'name_last' from the 'player' table.", "Join the 'player' table with the 'player_award' table to access award information.", "Filter the results for the specified years using placeholders for numeric values.", "Use INTERSECT to ensure that only players who won awards in both years are included."], "gold_sql": "SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1960 INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1961", "source_tables": ["player_award", "player"], "description": "The virtual table provides the first and last names of players who have won awards in both specified years. It combines data from the 'player' table and the 'player_award' table, filtering for the years of interest using placeholders for numeric values. The use of INTERSECT ensures that only players who won awards in both years are included in the results.", "virtual_table": "SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3684", "db_id": "baseball_1", "question": "List all the salary values players received in 2010 and 2001.", "rationale": ["Identify the relevant table, which is 'salary'.", "Select the 'salary' column to display the salary values.", "Use a UNION to combine results from two different years, utilizing placeholders for the year values to allow for flexible querying."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2010 UNION SELECT salary FROM salary WHERE YEAR  =  2001", "source_tables": ["salary"], "description": "The virtual table contains the salary values of players from the 'salary' table for the specified years. The placeholders represent the years for which the salary data is being queried, allowing for the retrieval of salary information for multiple years in a single query.", "virtual_table": "SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3662", "db_id": "baseball_1", "question": "Which players won awards in both 1960 and 1961? Return their first names and last names.", "rationale": ["Identify the relevant tables, which are 'player' and 'player_award'.", "Select the columns to display, 'name_first' and 'name_last' from the 'player' table.", "Join the 'player' table with the 'player_award' table to access award information.", "Filter the results for the specified years using placeholders for numeric values.", "Use INTERSECT to find players who won awards in both years."], "gold_sql": "SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1960 INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1961", "source_tables": ["player_award", "player"], "description": "The virtual table provides the first and last names of players who have received awards in both specified years. It combines data from the 'player' table and the 'player_award' table, filtering for the years of interest using placeholders for numeric values. The use of INTERSECT ensures that only players who won awards in both years are included in the results.", "virtual_table": "SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3669", "db_id": "baseball_1", "question": "What are the name and id of the team with the most victories in 2008 postseason?", "rationale": ["Identify the relevant tables: 'postseason' for postseason results and 'team' for team details.", "Select the columns to display: team name from 'team' and team ID from 'postseason'.", "Join the 'postseason' table with the 'team' table on the winning team ID.", "Filter the results for the specified postseason year using a placeholder for numeric values.", "Group the results by the winning team ID to count victories.", "Order the results in descending order to find the team with the most victories.", "Limit the results to return only the top team."], "gold_sql": "SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  2008 GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["postseason", "team"], "description": "The virtual table provides the names and identifiers of teams that achieved the most victories during the postseason of a specific year. It combines data from the 'postseason' table, which records the winning teams, with the 'team' table, which contains team details. The query filters for a particular year and groups the results by team identifier, ordering them by the count of victories to identify the top-performing team. Placeholders are used for the year and the limit on the number of results returned.", "virtual_table": "SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3686", "db_id": "baseball_1", "question": "Find the year in which the least people enter hall of fame.", "rationale": ["Identify the relevant table, which is 'hall_of_fame'.", "Select the 'yearid' column to display the years of induction.", "Group the results by 'yearid' to count the number of inductees per year.", "Order the results by the count of inductees in ascending order to find the year with the least inductees.", "Limit the results to a specific number using a placeholder for numeric values."], "gold_sql": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT 1;", "source_tables": ["hall_of_fame"], "description": "The virtual table provides a list of years from the 'hall_of_fame' table, grouped by the year of induction. It orders the years based on the count of inductees in ascending order, allowing the user to identify the year with the least number of inductees. The placeholder in the LIMIT clause indicates the maximum number of results to return, which can be adjusted as needed.", "virtual_table": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3693", "db_id": "baseball_1", "question": "What is the total home game attendance of team Boston Red Stockings from 2000 to 2010?", "rationale": ["Identify the relevant tables: 'home_game' for attendance data and 'team' for team identification.", "Select the sum of the 'attendance' column from the 'home_game' table.", "Join the 'home_game' table with the 'team' table on the team identifier to filter by team name.", "Add a condition to filter the results based on the specified team name using a placeholder for string values.", "Include a condition to filter the years using placeholders for numeric values to define the range."], "gold_sql": "SELECT sum(T1.attendance) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' AND T1.year BETWEEN 2000 AND 2010;", "source_tables": ["team", "home_game"], "description": "The virtual table summarizes the total home game attendance for a specific team over a defined range of years. It combines data from the 'home_game' table, which contains attendance records, and the 'team' table, which identifies the team by name. The placeholders in the query allow users to specify the team name and the year range for which they want to calculate the total attendance.", "virtual_table": "SELECT sum(T1.attendance) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3710", "db_id": "baseball_1", "question": "Which park did the most people attend in 2008?", "rationale": ["Identify the relevant tables, which are 'home_game' and 'park'.", "Select the 'park_name' column from the 'park' table.", "Join the 'home_game' table with the 'park' table on the 'park_id' to access attendance data.", "Add a condition to filter the results for the specified year using a placeholder for numeric values.", "Order the results by attendance in descending order to find the park with the most attendees.", "Limit the results to return only the top entry."], "gold_sql": "SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 2008 ORDER BY T1.attendance DESC LIMIT 1;", "source_tables": ["park", "home_game"], "description": "The virtual table provides the names of parks from the 'park' table that hosted home games in a specific year, filtered by the year of interest. It joins the 'home_game' table to retrieve attendance data, allowing users to identify which park had the highest attendance. The placeholders in the WHERE clause represent the year and the limit for the number of results to return.", "virtual_table": "SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3650", "db_id": "baseball_1", "question": "What are the three countries that the least players are from?", "rationale": ["Identify the relevant table, which is 'player'.", "Select the 'birth_country' column to display the countries of origin.", "Group the results by 'birth_country' to aggregate the player counts.", "Order the results by the count of players in ascending order to find the least represented countries.", "Limit the results to three countries using a placeholder for numeric values."], "gold_sql": "SELECT birth_country FROM player GROUP BY birth_country ORDER BY count(*) ASC LIMIT 3;", "source_tables": ["player"], "description": "The virtual table provides a list of countries represented by players in the 'player' table, grouped by country. It orders the countries by the number of players from each, in ascending order, and limits the results to the three countries with the fewest players. The placeholder in the LIMIT clause indicates the number of countries to return.", "virtual_table": "SELECT birth_country FROM player GROUP BY birth_country ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3700", "db_id": "baseball_1", "question": "Count the total number of games the team Boston Red Stockings attended from 1990 to 2000.", "rationale": ["Identify the relevant tables: 'home_game' for home game statistics and 'team' for team details.", "Select the sum of games from the 'home_game' table.", "Join the 'home_game' table with the 'team' table on the team identifier to filter by team name.", "Add a condition to filter the results based on the specified team name and the year range using placeholders."], "gold_sql": "SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = 'Boston Red Stockings' AND T1.year BETWEEN 1990 AND 2000;", "source_tables": ["team", "home_game"], "description": "The virtual table summarizes the total number of home games attended by a specific team over a defined range of years. It combines data from the 'home_game' table, which contains information about home games, and the 'team' table, which provides details about the team, including its name. The placeholders in the query allow for the specification of the team's name and the year range for the analysis.", "virtual_table": "SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3685", "db_id": "baseball_1", "question": "In which year did the least people enter hall of fame?", "rationale": ["Identify the relevant table, which is 'hall_of_fame'.", "Select the 'yearid' column to display the years of induction.", "Group the results by 'yearid' to count the number of inductees per year.", "Order the results by the count of inductees in ascending order to find the year with the least inductees.", "Limit the results to a single entry using a placeholder for numeric values."], "gold_sql": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT 1;", "source_tables": ["hall_of_fame"], "description": "The virtual table provides a list of years from the 'hall_of_fame' table, grouped by the year of induction. It orders the years based on the count of inductees in ascending order, allowing the user to identify the year with the least number of inductees. The placeholder in the LIMIT clause indicates that the user can specify how many years they want to retrieve, focusing on the year with the least entries.", "virtual_table": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3694", "db_id": "baseball_1", "question": "How many games in total did team Boston Red Stockings attend from 2000 to 2010?", "rationale": ["Identify the relevant tables: 'home_game' for attendance data and 'team' for team identification.", "Select the sum of the 'attendance' column from the 'home_game' table.", "Join the 'home_game' table with the 'team' table on the team identifier to filter by the specific team.", "Add a condition to filter the team name using a placeholder for string values.", "Include a condition to filter the years using placeholders for numeric values."], "gold_sql": "SELECT sum(T1.attendance) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' AND T1.year BETWEEN 2000 AND 2010;", "source_tables": ["team", "home_game"], "description": "The virtual table summarizes the total attendance of home games played by the team identified as 'Boston Red Stockings' over a specified range of years. It combines data from the 'home_game' table, which contains attendance records, and the 'team' table, which provides the team's identification. The placeholders in the query allow for dynamic input of the team name and the year range for the analysis.", "virtual_table": "SELECT sum(T1.attendance) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3638", "db_id": "baseball_1", "question": "Count the number of players who enter hall of fame for each year.", "rationale": ["Identify the relevant table, which is 'hall_of_fame'.", "Select the 'yearid' column to represent the year of induction.", "Count the number of players for each year using the COUNT function.", "Group the results by 'yearid' to get the count for each specific year."], "gold_sql": "SELECT yearid ,  count(*) FROM hall_of_fame GROUP BY yearid;", "source_tables": ["hall_of_fame"], "description": "The virtual table summarizes the number of players inducted into the Hall of Fame for each year. It groups the data by the year of induction and counts the total number of players for each year.", "virtual_table": "SELECT yearid ,  count(*) FROM hall_of_fame GROUP BY yearid;"}
{"sample_id": "train.3659", "db_id": "baseball_1", "question": "What are the name and id of the team offering the lowest average salary?", "rationale": ["Identify the relevant tables, which are 'team' and 'salary'.", "Select the columns to display, 'name' and 'team_id' from the 'team' table.", "Join the 'team' table with the 'salary' table on the 'team_id' column to associate teams with their salary records.", "Group the results by 'team_id' to calculate the average salary for each team.", "Order the results by the average salary in ascending order to find the team with the lowest average salary.", "Use a placeholder in the LIMIT clause to specify how many results to return."], "gold_sql": "SELECT T1.name ,  T1.team_id FROM team AS T1 JOIN salary AS T2 ON T1.team_id = T2.team_id GROUP BY T1.team_id ORDER BY avg(T2.salary) ASC LIMIT 1;", "source_tables": ["team", "salary"], "description": "The virtual table provides the names and identifiers of teams from the 'team' table that are associated with salary records. It calculates the average salary for each team by joining the 'team' and 'salary' tables, grouping the results by team identifier, and ordering them in ascending order to identify the team with the lowest average salary. The placeholder in the LIMIT clause allows for specifying the number of results to return.", "virtual_table": "SELECT T1.name ,  T1.team_id FROM team AS T1 JOIN salary AS T2 ON T1.team_id = T2.team_id GROUP BY T1.team_id ORDER BY avg(T2.salary) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3702", "db_id": "baseball_1", "question": "Find the team that attended the least number of home games in 1980.", "rationale": ["Identify the relevant tables, which are 'home_game' for home game statistics and 'team' for team names.", "Join the 'home_game' table with the 'team' table on the team identifier to access team names.", "Filter the results for a specific year using a placeholder for numeric values.", "Order the results by attendance in ascending order to find the team with the least number of home games.", "Limit the results to one to get only the team with the least attendance."], "gold_sql": "SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = 1980 ORDER BY T1.attendance ASC LIMIT 1;", "source_tables": ["team", "home_game"], "description": "The virtual table provides the names of teams that hosted home games in a specific year, filtered to show only the team with the least attendance. The placeholders allow for the year and the limit on the number of results to be specified.", "virtual_table": "SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3689", "db_id": "baseball_1", "question": "How many games were played in park \"Columbia Park\" in 1907?", "rationale": ["Identify the relevant tables: 'home_game' for home game statistics and 'park' for park details.", "Join the 'home_game' table with the 'park' table on the park identifier to link games to their respective parks.", "Count the total number of games played by filtering the results based on the specified year and park name using placeholders."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 1907 AND T2.park_name = 'Columbia Park';", "source_tables": ["park", "home_game"], "description": "The virtual table provides a count of the total number of games played in a specific park during a particular year. It combines data from the 'home_game' table, which records home game statistics, and the 'park' table, which contains information about different parks. The placeholders in the query allow users to specify the year and the name of the park they are interested in.", "virtual_table": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T2.park_name = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.3667", "db_id": "baseball_1", "question": "How many times did Boston Red Stockings lose in 2009 postseason?", "rationale": ["Identify the relevant tables: 'postseason' for postseason results and 'team' for team details.", "Join the 'postseason' table with the 'team' table on the condition that the losing team's ID matches the team's identifier in the Baseball Reference database.", "Count the number of records that meet the criteria for the specified team name and year, using placeholders for these values."], "gold_sql": "SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' AND T1.year = 2009;", "source_tables": ["postseason", "team"], "description": "The virtual table provides a count of the losses experienced by a specific team during the postseason in a given year. It combines data from the 'postseason' table, which records the outcomes of postseason games, and the 'team' table, which contains information about the teams. The placeholders allow for the specification of the team's name and the year of interest.", "virtual_table": "SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3668", "db_id": "baseball_1", "question": "Count the number of times the team \"Boston Red Stockings\" lost in 2009 postseason.", "rationale": ["Identify the relevant tables: 'postseason' for postseason results and 'team' for team information.", "Select the count of losses by using count(*) from the 'postseason' table.", "Join the 'postseason' table with the 'team' table on the condition that the losing team's ID matches the team's identifier in the 'team' table.", "Add a condition to filter the team name and the year of the postseason using placeholders for string and numeric values."], "gold_sql": "SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' AND T1.year = 2009;", "source_tables": ["postseason", "team"], "description": "The virtual table provides a count of the total losses experienced by a specific team during the postseason in a given year. It combines data from the 'postseason' table, which records the outcomes of postseason games, and the 'team' table, which contains information about the teams, including their names. The placeholders allow for the specification of the team's name and the year of interest.", "virtual_table": "SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3673", "db_id": "baseball_1", "question": "What is the total number of postseason games that team Boston Red Stockings participated in?", "rationale": ["Identify the relevant tables: 'postseason' for game outcomes and 'team' for team details.", "Use a UNION to combine results from two queries: one for games where the team won and another for games where the team lost.", "Join the 'postseason' table with the 'team' table on the winning and losing team identifiers respectively.", "Filter the results based on the specified team name using placeholders for string values."], "gold_sql": "SELECT count(*) FROM ( SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' UNION SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' );", "source_tables": ["postseason", "team"], "description": "The virtual table provides a count of all postseason games that the specified team participated in, either as a winner or a loser. It combines data from the 'postseason' table, which records the outcomes of postseason games, and the 'team' table, which contains information about the teams, including their names. The placeholders in the query represent the name of the team being queried, allowing for flexibility in specifying different teams.", "virtual_table": "SELECT count(*) FROM ( SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] );"}
{"sample_id": "train.3692", "db_id": "baseball_1", "question": "Find the number of games taken place in city Atlanta in 2000.", "rationale": ["Identify the relevant tables: 'home_game' for home game statistics and 'park' for park information.", "Join the 'home_game' table with the 'park' table on the park_id to link games to their respective locations.", "Count the total number of games by using the count(*) function.", "Add conditions to filter the results based on the specified year and city using placeholders for numeric and string values."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year  =  2000 AND T2.city  =  'Atlanta';", "source_tables": ["park", "home_game"], "description": "The virtual table provides a count of the total number of home games that took place in a specific city during a given year. It combines data from the 'home_game' table, which records home game statistics, and the 'park' table, which contains information about the parks where these games were held. The placeholders in the query allow users to specify the year and the city of interest.", "virtual_table": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] AND T2.city  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.3631", "db_id": "baseball_1", "question": "What is average salary of the players in the team named 'Boston Red Stockings' ?", "rationale": ["Identify the relevant tables, which are 'salary' and 'team'.", "Select the average salary from the 'salary' table.", "Join the 'salary' table with the 'team' table on the team identifier.", "Add a condition to filter the 'team' table for the specified team name using a placeholder for string values."], "gold_sql": "SELECT avg(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings'", "source_tables": ["team", "salary"], "description": "The virtual table calculates the average salary of players from the 'salary' table who are associated with a specific team. It joins the 'salary' table with the 'team' table using the team identifier, and filters the results based on the team's name provided as a placeholder.", "virtual_table": "SELECT avg(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3680", "db_id": "baseball_1", "question": "How many players did Boston Red Stockings have in 2000?", "rationale": ["Identify the relevant tables, which are 'salary' and 'team'.", "Use a JOIN operation to connect the 'salary' table with the 'team' table based on the team identifier.", "Count the total number of players by using the COUNT function.", "Add conditions to filter the results based on the team name and the year using placeholders for string and numeric values."], "gold_sql": "SELECT count(*) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings' AND T1.year  =  2000", "source_tables": ["team", "salary"], "description": "The virtual table provides a count of players from the 'salary' table who were associated with the Boston Red Stockings in the year specified. It joins the 'salary' table with the 'team' table based on the team identifier, filtering the results to include only those players from the specified team name and year.", "virtual_table": "SELECT count(*) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3677", "db_id": "baseball_1", "question": "What is the total salary paid by team Boston Red Stockings in 2010?", "rationale": ["Identify the relevant tables: 'salary' for salary records and 'team' for team information.", "Select the sum of the salary from the 'salary' table.", "Join the 'salary' table with the 'team' table on the team identifier to link salary data with team names.", "Add conditions to filter the results based on the specified team name and year using placeholders."], "gold_sql": "SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings' AND T1.year  =  2010", "source_tables": ["team", "salary"], "description": "The virtual table summarizes the total salary paid by a specific team in a given year. It combines data from the 'salary' table, which contains salary records, and the 'team' table, which provides team identifiers and names. The placeholders in the query allow users to specify the team name and the year for which they want to calculate the total salary.", "virtual_table": "SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.205", "db_id": "bike_1", "question": "Give me the zip code where the average mean humidity is below 70 and at least 100 trips took place.", "rationale": ["Identify the relevant tables, which are 'weather' and 'trip'.", "Select the 'zip_code' column from both tables.", "Group the results by 'zip_code' to aggregate data for each zip code.", "Use the HAVING clause to filter for zip codes with an average mean humidity below a specified value from the 'weather' table.", "Use the INTERSECT operator to combine results with another query that filters for zip codes from the 'trip' table that have a count of trips greater than or equal to a specified number."], "gold_sql": "SELECT zip_code FROM weather GROUP BY zip_code HAVING avg(mean_humidity)  <  70 INTERSECT SELECT zip_code FROM trip GROUP BY zip_code HAVING count(*)  >=  100", "source_tables": ["weather", "trip"], "description": "The virtual table summarizes the zip codes from the 'weather' and 'trip' tables. It filters the results to include only those zip codes where the average mean humidity is below a specified threshold and where there have been at least a certain number of trips recorded. The placeholders represent the specific humidity value and the minimum number of trips required for inclusion in the results.", "virtual_table": "SELECT zip_code FROM weather GROUP BY zip_code HAVING avg(mean_humidity)  <  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT zip_code FROM trip GROUP BY zip_code HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.142", "db_id": "bike_1", "question": "What are the ids of the stations in San Francisco that normally have more than 10 bikes available?", "rationale": ["Identify the relevant tables, which are 'station' and 'status'.", "Select the 'id' column from the 'station' table to get the station identifiers.", "Filter the 'station' table by the 'city' column using a placeholder for the city name.", "Use an INTERSECT to combine results with a subquery that selects 'station_id' from the 'status' table.", "Group the results by 'station_id' and apply a HAVING clause to filter for stations with an average of bikes available greater than a specified number, using a placeholder for the numeric value."], "gold_sql": "SELECT id FROM station WHERE city  =  'San Francisco' INTERSECT SELECT station_id FROM status GROUP BY station_id HAVING avg(bikes_available)  >  10", "source_tables": ["status", "station"], "description": "The virtual table provides the unique identifiers of bike stations located in a specific city, filtered to include only those stations that typically have a higher average number of bikes available. The placeholders in the query allow for customization of the city name and the minimum average bike availability threshold.", "virtual_table": "SELECT id FROM station WHERE city  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT station_id FROM status GROUP BY station_id HAVING avg(bikes_available)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.123", "db_id": "bike_1", "question": "For each zip code, return the average mean temperature of August there.", "rationale": ["Identify the relevant table, which is 'weather'.", "Select the 'zip_code' and calculate the average of 'mean_temperature_f'.", "Add a condition to filter the records for the month of August using a placeholder for string values in the WHERE clause.", "Group the results by 'zip_code' to get the average temperature for each zip code."], "gold_sql": "SELECT zip_code  ,  avg(mean_temperature_f) FROM weather WHERE date LIKE '8/%' GROUP BY zip_code", "source_tables": ["weather"], "description": "The virtual table summarizes the average mean temperature recorded in August for each zip code from the 'weather' table. The placeholder in the WHERE clause is used to filter the records specifically for the month of August, while the results are grouped by zip code to provide the average temperature for each area.", "virtual_table": "SELECT zip_code  ,  avg(mean_temperature_f) FROM weather WHERE date LIKE [PLACEHOLDER-TYPE:STRING] GROUP BY zip_code"}
{"sample_id": "train.133", "db_id": "bike_1", "question": "Which start station had the most trips starting from August? Give me the name and id of the station.", "rationale": ["Identify the relevant table, which is 'trip'.", "Select the columns to display, 'start_station_name' and 'start_station_id'.", "Add a condition to filter the 'start_date' column for trips starting in a specific month using a placeholder for string values.", "Group the results by 'start_station_name' to count the number of trips per station.", "Order the results in descending order based on the count of trips to find the station with the most trips.", "Limit the results to return only the top station."], "gold_sql": "SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE '8/%' GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["trip"], "description": "The virtual table summarizes the names and identifiers of bike stations from the 'trip' table that had the highest number of trips starting from a specific month. The placeholder in the WHERE clause is used to filter trips based on the start date, while the LIMIT placeholder restricts the number of results returned to the top station.", "virtual_table": "SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE [PLACEHOLDER-TYPE:STRING] GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.144", "db_id": "bike_1", "question": "What are the names and ids of all stations that have more than 14 bikes available on average or had bikes installed in December?", "rationale": ["Identify the relevant tables, which are 'station' and 'status'.", "Select the columns to display, 'name' and 'id' from the 'station' table.", "Join the 'station' table with the 'status' table on the station identifier to access bike availability data.", "Group the results by station identifier to calculate the average number of bikes available.", "Add a condition to filter for stations with an average bike availability greater than a specified number using a placeholder for numeric values.", "Use a UNION to combine results with a second query that selects station names and ids based on installation date, using a placeholder for string values."], "gold_sql": "SELECT T1.name ,  T1.id FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(T2.bikes_available)  >  14 UNION SELECT name ,  id FROM station WHERE installation_date LIKE '12/%'", "source_tables": ["status", "station"], "description": "The virtual table provides the names and unique identifiers of bike stations from the 'station' table that either have an average of more than a specified number of bikes available or were installed in a specific month. The first part of the query joins the 'station' and 'status' tables to calculate the average number of bikes available at each station, while the second part filters stations based on their installation date using a placeholder for string values.", "virtual_table": "SELECT T1.name ,  T1.id FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(T2.bikes_available)  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT name ,  id FROM station WHERE installation_date LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.135", "db_id": "bike_1", "question": "Which bike traveled the most often in zip code 94002?", "rationale": ["Identify the relevant table, which is 'trip'.", "Select the column to display, 'bike_id'.", "Add a condition to filter the 'zip_code' column for the specified zip code using a placeholder for numeric values.", "Group the results by 'bike_id' to count the number of trips for each bike.", "Order the results by the count of trips in descending order to find the most frequently used bike.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT bike_id FROM trip WHERE zip_code  =  94002 GROUP BY bike_id ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["trip"], "description": "The virtual table summarizes the bike trips recorded in the 'trip' table, specifically focusing on the bike identifiers that have been used most frequently within a specified zip code. The query groups the results by bike ID and orders them by the count of trips in descending order, allowing for the identification of the most frequently used bike. Placeholders are used to represent the zip code and the limit for the number of results returned.", "virtual_table": "SELECT bike_id FROM trip WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY bike_id ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.155", "db_id": "bike_1", "question": "Give me ids for all the trip that took place in a zip code area with average mean temperature above 60.", "rationale": ["Identify the relevant tables, which are 'trip' and 'weather'.", "Select the 'id' column from the 'trip' table to display the trip identifiers.", "Join the 'trip' table with the 'weather' table on the 'zip_code' column to correlate trips with weather data.", "Group the results by 'zip_code' to calculate the average mean temperature for each area.", "Add a condition to filter the groups based on the average mean temperature using a placeholder for numeric values."], "gold_sql": "SELECT T1.id FROM trip AS T1 JOIN weather AS T2 ON T1.zip_code  =  T2.zip_code GROUP BY T2.zip_code HAVING avg(T2.mean_temperature_f)  >  60", "source_tables": ["weather", "trip"], "description": "The virtual table provides the unique identifiers for trips from the 'trip' table that occurred in specific zip code areas. It joins the 'trip' table with the 'weather' table based on matching zip codes and groups the results by zip code. The condition applied filters the groups to include only those with an average mean temperature exceeding a specified threshold, represented by a placeholder for numeric values.", "virtual_table": "SELECT T1.id FROM trip AS T1 JOIN weather AS T2 ON T1.zip_code  =  T2.zip_code GROUP BY T2.zip_code HAVING avg(T2.mean_temperature_f)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.145", "db_id": "bike_1", "question": "What is the 3 most common cloud cover rates in the region of zip code 94107?", "rationale": ["Identify the relevant table, which is 'weather'.", "Select the 'cloud_cover' column to display the cloud cover rates.", "Add a condition to filter the 'zip_code' column for the specified region using a placeholder for numeric values.", "Group the results by 'cloud_cover' to aggregate the data.", "Order the results by the count of occurrences in descending order to find the most common rates.", "Limit the results to the top three common cloud cover rates."], "gold_sql": "SELECT cloud_cover FROM weather WHERE zip_code  =  94107 GROUP BY cloud_cover ORDER BY COUNT (*) DESC LIMIT 3", "source_tables": ["weather"], "description": "The virtual table presents the cloud cover rates recorded in the 'weather' table for a specific zip code. It groups the data by cloud cover rates and orders them by their frequency, allowing the user to identify the most common rates. The placeholders in the query represent the zip code and the limit for the number of results to return.", "virtual_table": "SELECT cloud_cover FROM weather WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY cloud_cover ORDER BY COUNT (*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.143", "db_id": "bike_1", "question": "What are the names and ids of stations that had more than 14 bikes available on average or were installed in December?", "rationale": ["Identify the relevant tables, which are 'station' and 'status'.", "Select the columns to display, 'name' and 'id' from the 'station' table.", "Join the 'station' table with the 'status' table on the station identifier to access bike availability data.", "Group the results by station identifier to calculate the average number of bikes available.", "Add a condition to filter for stations with an average bike availability greater than a specified number using a placeholder for numeric values.", "Use a UNION to combine results with a second query that selects stations based on their installation date, using a placeholder for string values."], "gold_sql": "SELECT T1.name ,  T1.id FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(T2.bikes_available)  >  14 UNION SELECT name ,  id FROM station WHERE installation_date LIKE '12/%'", "source_tables": ["status", "station"], "description": "The virtual table provides the names and unique identifiers of bike stations from the 'station' table that either have an average availability of more than a specified number of bikes or were installed in a specific month. The first part of the query joins the 'station' and 'status' tables to calculate the average number of bikes available at each station, while the second part filters stations based on their installation date using a placeholder for string values.", "virtual_table": "SELECT T1.name ,  T1.id FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(T2.bikes_available)  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT name ,  id FROM station WHERE installation_date LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.137", "db_id": "bike_1", "question": "How many days had both mean humidity above 50 and mean visibility above 8?", "rationale": ["Identify the relevant table, which is 'weather'.", "Count the total number of records that meet the specified conditions.", "Add conditions to filter the 'mean_humidity' and 'mean_visibility_miles' columns using placeholders for numeric values."], "gold_sql": "SELECT COUNT(*) FROM weather WHERE mean_humidity  >  50 AND mean_visibility_miles  >  8", "source_tables": ["weather"], "description": "The virtual table summarizes the count of days from the 'weather' table where the mean humidity exceeds a specified threshold and the mean visibility in miles also exceeds another specified threshold. The placeholders in the WHERE clause represent the numeric values for mean humidity and mean visibility that need to be defined by the user.", "virtual_table": "SELECT COUNT(*) FROM weather WHERE mean_humidity  >  [PLACEHOLDER-TYPE:NUMBER] AND mean_visibility_miles  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.191", "db_id": "bike_1", "question": "For each station, find its latitude and the minimum duration of trips that ended at the station.", "rationale": ["Identify the relevant tables, which are 'station' and 'trip'.", "Select the columns to display: 'name' and 'lat' from the 'station' table, and the minimum 'duration' from the 'trip' table.", "Join the 'station' table with the 'trip' table on the condition that the station's ID matches the end station ID in the trip records.", "Group the results by the end station ID to ensure that the minimum duration is calculated for each station."], "gold_sql": "SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id", "source_tables": ["trip", "station"], "description": "The virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum duration of trips that concluded at each station. The data is aggregated by the station's identifier, allowing for a summary of trip durations associated with each station.", "virtual_table": "SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id"}
{"sample_id": "train.204", "db_id": "bike_1", "question": "What are the different ids and names of the stations that have had more than 12 bikes available?", "rationale": ["Identify the relevant tables, which are 'station' and 'status'.", "Select the distinct columns to display, 'id' and 'name' from the 'station' table.", "Join the 'station' table with the 'status' table on the station identifier to correlate station information with bike availability.", "Add a condition to filter the results where the number of bikes available exceeds a specified numeric value using a placeholder."], "gold_sql": "SELECT DISTINCT T1.id ,  T1.name FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id WHERE T2.bikes_available  >  12", "source_tables": ["status", "station"], "description": "The virtual table provides a distinct list of station identifiers and names from the 'station' table that are associated with a status indicating more than a specified number of bikes available. The placeholder in the WHERE clause allows for the input of a numeric value to filter the results based on bike availability.", "virtual_table": "SELECT DISTINCT T1.id ,  T1.name FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id WHERE T2.bikes_available  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.190", "db_id": "bike_1", "question": "For each start station id, what is its name, longitude and average duration of trips started there?", "rationale": ["Identify the relevant tables, which are 'station' and 'trip'.", "Select the columns to display: 'name' and 'long' from the 'station' table, and the average of 'duration' from the 'trip' table.", "Join the 'station' table with the 'trip' table on the condition that the station ID matches the start station ID in the trip records.", "Group the results by the start station ID to compute the average duration of trips for each station."], "gold_sql": "SELECT T1.name ,  T1.long ,  avg(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id GROUP BY T2.start_station_id", "source_tables": ["trip", "station"], "description": "The virtual table provides the names and longitudes of bike stations along with the average duration of trips that started at each station. It combines data from the 'station' table, which includes station identifiers and geographical information, with the 'trip' table, which records trip details including start station identifiers and trip durations. The results are grouped by the start station identifier to calculate the average trip duration for each station.", "virtual_table": "SELECT T1.name ,  T1.long ,  avg(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id GROUP BY T2.start_station_id"}
{"sample_id": "train.184", "db_id": "bike_1", "question": "For each city, list their names in decreasing order by their highest station latitude.", "rationale": ["Identify the relevant table, which is 'station'.", "Select the 'city' column to display the names of the cities.", "Group the results by the 'city' column to ensure each city is listed once.", "Order the results by the maximum latitude of the stations in each city in descending order."], "gold_sql": "SELECT city FROM station GROUP BY city ORDER BY max(lat) DESC", "source_tables": ["station"], "description": "The virtual table provides a list of cities derived from the 'station' table, grouped by city name. The results are ordered in descending order based on the maximum latitude of the stations located in each city. This allows for an overview of cities ranked by their highest station latitude.", "virtual_table": "SELECT city FROM station GROUP BY city ORDER BY max(lat) DESC"}
{"sample_id": "train.153", "db_id": "bike_1", "question": "When and in what zip code did max temperature reach 80?", "rationale": ["Identify the relevant table, which is 'weather'.", "Select the columns to display, 'date' and 'zip_code'.", "Add a condition to filter the 'max_temperature_f' column for the specified temperature using a placeholder for numeric values."], "gold_sql": "SELECT date ,  zip_code FROM weather WHERE max_temperature_f  >=  80", "source_tables": ["weather"], "description": "The virtual table provides the date and zip code from the 'weather' table where the maximum temperature reached or exceeded a specified threshold. The placeholder in the WHERE clause represents the temperature value to filter the results accordingly.", "virtual_table": "SELECT date ,  zip_code FROM weather WHERE max_temperature_f  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.167", "db_id": "bike_1", "question": "In zip code 94107, on which day neither Fog nor Rain was not observed?", "rationale": ["Identify the relevant table, which is 'weather'.", "Select the 'date' column to display the days that meet the criteria.", "Add conditions to filter the 'zip_code' for the specified area and exclude specific weather events using placeholders for numeric and string values."], "gold_sql": "SELECT date FROM weather WHERE zip_code  =  94107 AND EVENTS != 'Fog' AND EVENTS != 'Rain'", "source_tables": ["weather"], "description": "The virtual table provides the dates from the 'weather' table for a specific zip code where neither fog nor rain events were recorded. The placeholders in the WHERE clause represent the zip code and the weather events to be excluded.", "virtual_table": "SELECT date FROM weather WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER] AND EVENTS != [PLACEHOLDER-TYPE:STRING] AND EVENTS != [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.163", "db_id": "bike_1", "question": "Which trip started from the station with the largest dock count? Give me the trip id.", "rationale": ["Identify the relevant tables, which are 'trip' and 'station'.", "Select the 'id' column from the 'trip' table to display the trip identifiers.", "Join the 'trip' table with the 'station' table using the station identifier to correlate trips with their starting stations.", "Order the results by the 'dock_count' column from the 'station' table in descending order to find the station with the largest dock count.", "Limit the output to a specified number of results using a placeholder for numeric values."], "gold_sql": "SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT 1", "source_tables": ["trip", "station"], "description": "The virtual table provides the unique identifiers of trips that started from the station with the highest number of docks available. It joins the 'trip' table with the 'station' table based on the station's identifier, and orders the results by the dock count in descending order, limiting the output to a specified number of results.", "virtual_table": "SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.161", "db_id": "bike_1", "question": "For each trip, return its ending station's installation date.", "rationale": ["Identify the relevant tables, which are 'trip' and 'station'.", "Select the trip identifier from the 'trip' table and the installation date from the 'station' table.", "Join the 'trip' table with the 'station' table using the ending station's identifier to link the two datasets."], "gold_sql": "SELECT T1.id ,  T2.installation_date FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id", "source_tables": ["trip", "station"], "description": "The virtual table provides a list of trips along with the installation dates of their respective ending stations. It combines data from the 'trip' table, which contains details about each trip, and the 'station' table, which holds information about the bike stations, including their installation dates. The relationship between the two tables is established through the ending station's identifier.", "virtual_table": "SELECT T1.id ,  T2.installation_date FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id"}
{"sample_id": "train.211", "db_id": "bike_1", "question": "What is the average latitude and longitude of the starting points of all trips?", "rationale": ["Identify the relevant tables, which are 'station' and 'trip'.", "Join the 'station' table with the 'trip' table using the station identifier to link trips to their starting stations.", "Select the average latitude and longitude from the 'station' table for the starting points of the trips."], "gold_sql": "SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id", "source_tables": ["trip", "station"], "description": "The virtual table provides the average latitude and longitude of the starting points of all trips by joining the 'station' and 'trip' tables. The join is based on the station identifier, allowing for the calculation of average coordinates for all trips that started at various bike stations.", "virtual_table": "SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id"}
{"sample_id": "train.162", "db_id": "bike_1", "question": "What is the installation date for each ending station on all the trips?", "rationale": ["Identify the relevant tables, which are 'trip' and 'station'.", "Select the columns to display, which are the unique identifier from the 'trip' table and the installation date from the 'station' table.", "Join the 'trip' table with the 'station' table on the condition that the end station ID from the 'trip' table matches the ID from the 'station' table."], "gold_sql": "SELECT T1.id ,  T2.installation_date FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id", "source_tables": ["trip", "station"], "description": "The virtual table provides the unique identifiers and installation dates of the ending stations for all trips recorded in the 'trip' table. It combines data from the 'trip' table and the 'station' table based on the matching station identifiers, allowing users to see when each ending station was installed.", "virtual_table": "SELECT T1.id ,  T2.installation_date FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id"}
{"sample_id": "train.2403", "db_id": "candidate_poll", "question": "What are the support, consider, and oppose rates of each candidate, ordered ascending by their unsure rate?", "rationale": ["Identify the relevant table, which is 'candidate'.", "Select the columns to display: 'Support_rate', 'Consider_rate', and 'Oppose_rate'.", "Add an ORDER BY clause to sort the results based on the 'unsure_rate' column in ascending order."], "gold_sql": "SELECT Support_rate ,  Consider_rate ,  Oppose_rate FROM candidate ORDER BY unsure_rate", "source_tables": ["candidate"], "description": "The virtual table presents the support, consideration, and opposition rates of candidates from the 'candidate' table. The results are sorted in ascending order based on the unsure rate, which indicates the percentage of respondents who are uncertain about each candidate.", "virtual_table": "SELECT Support_rate ,  Consider_rate ,  Oppose_rate FROM candidate ORDER BY unsure_rate"}
{"sample_id": "train.2417", "db_id": "candidate_poll", "question": "For each sex, what is the name and sex of the candidate with the oppose rate for their sex?", "rationale": ["Identify the relevant tables, which are 'people' and 'candidate'.", "Select the columns to display: 'name' and 'sex' from the 'people' table, and the minimum 'oppose_rate' from the 'candidate' table.", "Join the 'people' table with the 'candidate' table on the 'People_ID' to link candidates with their personal details.", "Group the results by 'sex' to ensure that the minimum oppose rate is calculated for each gender."], "gold_sql": "SELECT t1.name ,  t1.sex ,  min(oppose_rate) FROM people AS t1 JOIN candidate AS t2 ON t1.people_id  =  t2.people_id GROUP BY t1.sex", "source_tables": ["candidate", "people"], "description": "The virtual table provides the names and genders of candidates from the 'people' table, along with the minimum oppose rate for each gender. The data is aggregated by gender, allowing for a comparison of the lowest oppose rates among candidates of the same sex.", "virtual_table": "SELECT t1.name ,  t1.sex ,  min(oppose_rate) FROM people AS t1 JOIN candidate AS t2 ON t1.people_id  =  t2.people_id GROUP BY t1.sex"}
{"sample_id": "train.2397", "db_id": "candidate_poll", "question": "Return the poll resource associated with the most candidates.", "rationale": ["Identify the relevant table, which is 'candidate'.", "Select the 'poll_source' column to display.", "Group the results by 'poll_source' to count the number of candidates associated with each source.", "Order the results in descending order based on the count of candidates.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT poll_source FROM candidate GROUP BY poll_source ORDER BY count(*) DESC LIMIT 1", "source_tables": ["candidate"], "description": "The virtual table summarizes the poll sources from the 'candidate' table, grouping them by the source and counting the number of candidates associated with each source. The placeholder in the LIMIT clause indicates the maximum number of poll sources to return, allowing for flexibility in the query results.", "virtual_table": "SELECT poll_source FROM candidate GROUP BY poll_source ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2396", "db_id": "candidate_poll", "question": "Which poll resource provided the most number of candidate information?", "rationale": ["Identify the relevant table, which is 'candidate'.", "Select the 'poll_source' column to display the sources of poll data.", "Group the results by 'poll_source' to aggregate the candidate information.", "Count the number of candidates for each poll source and order the results in descending order to find the most frequent source.", "Add a limit to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT poll_source FROM candidate GROUP BY poll_source ORDER BY count(*) DESC LIMIT 1", "source_tables": ["candidate"], "description": "The virtual table summarizes the sources of poll data from the 'candidate' table, grouping the information by each unique poll source. It counts the number of candidates associated with each source and orders the results in descending order to identify the source with the highest number of candidates. The placeholder in the LIMIT clause indicates the maximum number of results to return.", "virtual_table": "SELECT poll_source FROM candidate GROUP BY poll_source ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2398", "db_id": "candidate_poll", "question": "what are the top 3 highest support rates?", "rationale": ["Identify the relevant table, which is 'candidate'.", "Select the column to display, 'support_rate'.", "Order the results by 'support_rate' in descending order to get the highest values first.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT support_rate FROM candidate ORDER BY support_rate DESC LIMIT 3", "source_tables": ["candidate"], "description": "The virtual table contains the support rates of candidates from the 'candidate' table, ordered from highest to lowest. The placeholder in the LIMIT clause indicates the number of top support rates to retrieve.", "virtual_table": "SELECT support_rate FROM candidate ORDER BY support_rate DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.171", "db_id": "car_1", "question": "Which models are lighter than 3500 but not built by the 'Ford Motor Company'?", "rationale": ["Identify the relevant tables: 'MODEL_LIST', 'CAR_NAMES', 'CARS_DATA', and 'CAR_MAKERS'.", "Select the distinct 'model' column from the 'MODEL_LIST'.", "Join the tables on their respective identifiers to link models to their makes and data.", "Add conditions to filter models based on weight and exclude those made by a specific manufacturer using placeholders for numeric and string values."], "gold_sql": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.Model  =  T2.Model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.Id JOIN CAR_MAKERS AS T4 ON T1.Maker  =  T4.Id WHERE T3.weight  <  3500 AND T4.FullName != 'Ford Motor Company';", "source_tables": ["car_makers", "model_list", "car_names", "cars_data"], "description": "The virtual table describes distinct car models from the 'MODEL_LIST' that are lighter than a specified weight and are not manufactured by a specific car maker. The placeholders in the WHERE clause represent the weight limit and the name of the car maker to exclude.", "virtual_table": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.Model  =  T2.Model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.Id JOIN CAR_MAKERS AS T4 ON T1.Maker  =  T4.Id WHERE T3.weight  <  [PLACEHOLDER-TYPE:NUMBER] AND T4.FullName != [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "dev.131", "db_id": "car_1", "question": "What is the maximum horsepower and the make of the car models with 3 cylinders?", "rationale": ["Identify the relevant tables, which are 'CAR_NAMES' and 'CARS_DATA'.", "Select the columns to display, 'horsepower' from 'CARS_DATA' and 'Make' from 'CAR_NAMES'.", "Join the two tables on the condition that 'MakeId' from 'CAR_NAMES' matches 'Id' from 'CARS_DATA'.", "Add a condition to filter the 'cylinders' column for the specified number of cylinders using a placeholder for numeric values.", "Order the results by 'horsepower' in descending order and limit the number of results using placeholders."], "gold_sql": "SELECT T2.horsepower ,  T1.Make FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.cylinders  =  3 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "description": "The virtual table summarizes the maximum horsepower and the make of car models from the 'CAR_NAMES' and 'CARS_DATA' tables, specifically for models that have 3 cylinders. The placeholders in the WHERE clause represent the number of cylinders to filter by, and the LIMIT clause allows for specifying how many results to return.", "virtual_table": "SELECT T2.horsepower ,  T1.Make FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.cylinders  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY T2.horsepower DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.129", "db_id": "car_1", "question": "Which countries in europe have at least 3 car manufacturers?", "rationale": ["Identify the relevant tables: 'countries', 'continents', and 'car_makers'.", "Select the column to display, which is 'CountryName' from the 'countries' table.", "Join the 'countries' table with the 'continents' table to filter for countries in Europe.", "Join the 'countries' table with the 'car_makers' table to count the number of manufacturers per country.", "Add a condition to filter for the continent being 'Europe' using a placeholder for string values.", "Group the results by 'CountryName' and use a HAVING clause to ensure that only countries with at least three manufacturers are included, using a placeholder for the numeric value."], "gold_sql": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  'europe' GROUP BY T1.CountryName HAVING count(*)  >=  3;", "source_tables": ["continents", "car_makers", "countries"], "description": "The virtual table lists the names of countries from the 'countries' table that are located in Europe and have a minimum of three car manufacturers. The query joins the 'countries' table with the 'continents' table to filter for European countries and then joins with the 'car_makers' table to count the number of manufacturers per country. The placeholders represent the continent name and the minimum count of manufacturers required.", "virtual_table": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.CountryName HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.161", "db_id": "car_1", "question": "How many countries has more than 2 car makers ?", "rationale": ["Identify the relevant tables, which are 'countries' and 'car_makers'.", "Count the number of car makers for each country by joining the two tables on the country identifier.", "Group the results by country to aggregate the count of car makers.", "Use a HAVING clause to filter the results to only include countries with a count greater than a specified number, represented by a placeholder."], "gold_sql": "select count(*) from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  2", "source_tables": ["car_makers", "countries"], "description": "The virtual table provides a count of countries from the 'countries' table that have more than a specified number of car makers associated with them. The join operation links the 'countries' table with the 'car_makers' table based on the country identifier, and the result is grouped by country to count the number of car makers per country. The placeholder in the HAVING clause allows for filtering countries based on a specified minimum count of car makers.", "virtual_table": "select count(*) from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.175", "db_id": "car_1", "question": "Which are the car makers which produce at least 2 models and more than 3 car makers ? List the id and the maker .", "rationale": ["Identify the relevant tables, which are 'car_makers', 'model_list', and 'car_names'.", "Select the columns to display, 'id' and 'maker' from the 'car_makers' table.", "Join the 'car_makers' table with the 'model_list' table to count the number of models produced by each maker.", "Group the results by 'id' to aggregate the counts of models for each maker.", "Use the HAVING clause to filter makers that produce at least a specified number of models.", "Perform an intersection with another query that counts the number of car makers associated with each model, ensuring that the results meet the criteria for both counts."], "gold_sql": "select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker group by t1.id having count(*)  >=  2 intersect select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker join car_names as t3 on t2.model  =  t3.model group by t1.id having count(*)  >  3;", "source_tables": ["car_makers", "car_names", "model_list"], "description": "The virtual table provides a list of car makers from the 'car_makers' table who produce at least a specified number of models and are associated with more than a specified number of car makers. The placeholders in the HAVING clauses represent the minimum counts for models and car makers, respectively.", "virtual_table": "select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker group by t1.id having count(*)  >=  [PLACEHOLDER-TYPE:NUMBER] intersect select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker join car_names as t3 on t2.model  =  t3.model group by t1.id having count(*)  >  [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.176", "db_id": "car_1", "question": "What are the ids and makers of all car makers that produce at least 2 models and make more than 3 cars?", "rationale": ["Identify the relevant tables, which are 'CAR_MAKERS', 'MODEL_LIST', and 'CAR_NAMES'.", "Select the columns to display, 'Id' and 'Maker' from the 'CAR_MAKERS' table.", "Join the 'CAR_MAKERS' table with the 'MODEL_LIST' table to filter car makers based on the number of models they produce.", "Group the results by 'Id' and 'Maker' to count the number of models for each maker.", "Use the HAVING clause to filter makers that produce at least a specified number of models.", "Perform an intersection with another query that counts the number of cars for each maker by joining 'CAR_MAKERS', 'MODEL_LIST', and 'CAR_NAMES'.", "Use the HAVING clause again to filter makers that manufacture more than a specified number of cars."], "gold_sql": "SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >=  2 INTERSECT SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker JOIN CAR_NAMES AS T3 ON T2.model  =  T3.model GROUP BY T1.Id HAVING count(*)  >  3;", "source_tables": ["car_makers", "car_names", "model_list"], "description": "The virtual table provides the unique identifiers and names of car makers from the 'CAR_MAKERS' table who produce a minimum number of car models and manufacture a greater number of cars. The placeholders in the HAVING clause represent the minimum counts required for models and cars, respectively.", "virtual_table": "SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker JOIN CAR_NAMES AS T3 ON T2.model  =  T3.model GROUP BY T1.Id HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.104", "db_id": "car_1", "question": "What are the different models for the cards produced after 1980?", "rationale": ["Identify the relevant tables: 'model_list', 'car_names', and 'cars_data'.", "Select the distinct 'model' column from the 'model_list' table.", "Join the 'model_list' with 'car_names' on the model name to link car models with their respective makes.", "Join the resulting table with 'cars_data' to access the manufacturing year of each model.", "Add a condition to filter the results for models manufactured after a specified year using a placeholder for numeric values."], "gold_sql": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  1980;", "source_tables": ["model_list", "car_names", "cars_data"], "description": "The virtual table describes the distinct car models produced after a specified year, sourced from the 'model_list', 'car_names', and 'cars_data' tables. The placeholder in the WHERE clause represents the year threshold for filtering the car models.", "virtual_table": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.103", "db_id": "car_1", "question": "Which distinct car models are the produced after 1980?", "rationale": ["Identify the relevant tables: 'model_list', 'car_names', and 'cars_data'.", "Select the distinct 'model' column from the 'model_list' table.", "Join the 'model_list' with 'car_names' on the model name to link car models with their makes.", "Join the resulting table with 'cars_data' to access the manufacturing year of each model.", "Add a condition to filter the results based on the year using a placeholder for numeric values."], "gold_sql": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  1980;", "source_tables": ["model_list", "car_names", "cars_data"], "description": "The virtual table describes distinct car models produced after a specific year, sourced from the 'model_list', 'car_names', and 'cars_data' tables. The placeholder in the WHERE clause represents the year threshold for filtering the car models.", "virtual_table": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.157", "db_id": "car_1", "question": "For model volvo, how many cylinders does the car with the least accelerate have?", "rationale": ["Identify the relevant tables, which are 'CARS_DATA' and 'CAR_NAMES'.", "Select the 'cylinders' column from 'CARS_DATA'.", "Join 'CARS_DATA' with 'CAR_NAMES' on the matching 'Id' and 'MakeId' columns.", "Add a condition to filter the 'Model' column in 'CAR_NAMES' for the specified model using a placeholder for string values.", "Order the results by the 'accelerate' column in ascending order to find the car with the least acceleration time.", "Limit the results to one entry using a placeholder for numeric values."], "gold_sql": "SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  'volvo' ORDER BY T1.accelerate ASC LIMIT 1;", "source_tables": ["cars_data", "car_names"], "description": "The virtual table describes the number of cylinders for a specific car model from the 'CARS_DATA' table, filtered by the model name provided. It retrieves the car with the least acceleration time, ordering the results in ascending order and limiting the output to one entry. The placeholders represent the car model's name and the limit for the number of results.", "virtual_table": "SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.accelerate ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.165", "db_id": "car_1", "question": "For the cars with 4 cylinders, which model has the largest horsepower?", "rationale": ["Identify the relevant tables, which are 'CAR_NAMES' and 'CARS_DATA'.", "Select the 'Model' column from 'CAR_NAMES'.", "Join 'CAR_NAMES' with 'CARS_DATA' on the 'MakeId' and 'Id' columns respectively.", "Add a condition to filter the 'Cylinders' column for the specified number using a placeholder for numeric values.", "Order the results by 'horsepower' in descending order to find the model with the largest horsepower.", "Limit the results to a single entry using a placeholder for numeric values."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  4 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "description": "The virtual table describes car models from the 'CAR_NAMES' table that are associated with specific car entries in the 'CARS_DATA' table. It filters the results to include only those models that have a specified number of cylinders, represented by a placeholder. The results are ordered by horsepower in descending order, allowing the identification of the model with the largest horsepower for the given cylinder count. The second placeholder limits the number of results returned.", "virtual_table": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY T2.horsepower DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.97", "db_id": "car_1", "question": "Find the model of the car whose weight is below the average weight.", "rationale": ["Identify the relevant tables, which are 'CAR_NAMES' and 'CARS_DATA'.", "Select the 'model' column from 'CAR_NAMES'.", "Join 'CAR_NAMES' with 'CARS_DATA' on the 'MakeId' and 'Id' columns to associate car models with their data.", "Add a condition to filter the results where the weight of the cars is less than the average weight calculated from the 'CARS_DATA' table."], "gold_sql": "SELECT T1.model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Weight  <  (SELECT avg(Weight) FROM CARS_DATA)", "source_tables": ["car_names", "cars_data"], "description": "The virtual table provides the models of cars from the 'CAR_NAMES' table that have a weight less than the average weight of all cars in the 'CARS_DATA' table. The query uses a join to connect car models with their corresponding data entries, and it includes a subquery to calculate the average weight.", "virtual_table": "SELECT T1.model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Weight  <  (SELECT avg(Weight) FROM CARS_DATA)"}
{"sample_id": "dev.115", "db_id": "car_1", "question": "How many car models are produced in the usa?", "rationale": ["Identify the relevant tables: 'model_list', 'car_makers', and 'countries'.", "Count the total number of car models by using the count(*) function.", "Join the 'model_list' table with the 'car_makers' table on the Maker identifier.", "Join the 'car_makers' table with the 'countries' table on the Country identifier.", "Add a condition to filter the results based on the specified country name using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  'usa';", "source_tables": ["car_makers", "model_list", "countries"], "description": "The virtual table provides a count of car models produced by car makers based in a specific country. It combines data from the 'model_list', 'car_makers', and 'countries' tables, linking them through their respective identifiers. The placeholder in the WHERE clause represents the name of the country for which the count of car models is requested.", "virtual_table": "SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "dev.114", "db_id": "car_1", "question": "What is the number of makers of care in France?", "rationale": ["Identify the relevant tables, which are 'car_makers' and 'countries'.", "Use a JOIN to connect 'car_makers' with 'countries' based on the country identifier.", "Select the count of car makers as the output.", "Add a condition to filter the 'CountryName' column for the specified country using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  'france';", "source_tables": ["car_makers", "countries"], "description": "The virtual table provides a count of car makers based in a specific country, which is France in this case. It combines data from the 'car_makers' and 'countries' tables, linking them through the country identifier. The placeholder in the WHERE clause allows for the specification of the country name to filter the results accordingly.", "virtual_table": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "dev.134", "db_id": "car_1", "question": "What is the car model with the highest mpg ?", "rationale": ["Identify the relevant tables, which are 'car_names' and 'cars_data'.", "Join the two tables on the condition that the 'makeid' from 'car_names' matches the 'id' from 'cars_data'.", "Select the 'model' column from 'car_names'.", "Order the results by the 'mpg' column from 'cars_data' in descending order to get the highest mpg first.", "Use a placeholder to limit the number of results returned, allowing the user to specify the desired number."], "gold_sql": "select t1.model from car_names as t1 join cars_data as t2 on t1.makeid  =  t2.id order by t2.mpg desc limit 1;", "source_tables": ["car_names", "cars_data"], "description": "The virtual table describes the car models from the 'car_names' table, joined with the 'cars_data' table to retrieve their corresponding miles per gallon (mpg) values. The results are ordered in descending order based on mpg, and a placeholder is used to limit the number of results returned, allowing the user to specify how many top models they want to see.", "virtual_table": "select t1.model from car_names as t1 join cars_data as t2 on t1.makeid  =  t2.id order by t2.mpg desc limit [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.122", "db_id": "car_1", "question": "What are the makers and models?", "rationale": ["Identify the relevant table, which is 'model_list'.", "Select the columns to display, 'Maker' and 'Model'.", "This query retrieves the names of car makers and their associated models from the 'model_list' table."], "gold_sql": "SELECT Maker ,  Model FROM MODEL_LIST;", "source_tables": ["model_list"], "description": "The virtual table provides a list of car makers along with their corresponding car models. The data is sourced from the 'model_list' table, which links car makers to their models, allowing users to see the relationship between different car manufacturers and the models they produce.", "virtual_table": "SELECT Maker ,  Model FROM MODEL_LIST;"}
{"sample_id": "dev.121", "db_id": "car_1", "question": "What are all the makers and models?", "rationale": ["Identify the relevant table, which is 'model_list'.", "Select the columns to display, 'Maker' and 'Model'.", "No filtering conditions are needed as the query requests all makers and models."], "gold_sql": "SELECT Maker ,  Model FROM MODEL_LIST;", "source_tables": ["model_list"], "description": "The virtual table lists the makers and models of cars from the 'model_list' table. The columns include the short name of the car maker and the name of the car model.", "virtual_table": "SELECT Maker ,  Model FROM MODEL_LIST;"}
{"sample_id": "dev.96", "db_id": "car_1", "question": "What is the model of the car with the smallest amount of horsepower?", "rationale": ["Identify the relevant tables, which are 'CAR_NAMES' and 'CARS_DATA'.", "Select the 'Model' column from 'CAR_NAMES'.", "Join 'CAR_NAMES' with 'CARS_DATA' on the 'MakeId' to access horsepower information.", "Order the results by the 'horsepower' column in ascending order to find the smallest value.", "Limit the output to a single result using a placeholder for numeric values."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "description": "The virtual table describes the model of the car from the 'CAR_NAMES' table that has the smallest amount of horsepower. It joins the 'CARS_DATA' table to access the horsepower data and orders the results in ascending order, limiting the output to the top entry. The placeholder in the LIMIT clause represents the number of results to return.", "virtual_table": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.6298", "db_id": "city_record", "question": "Please give me a list of cities whose regional population is over 8000000 or under 5000000.", "rationale": ["Identify the relevant table, which is 'city'.", "Select the column to display, which is 'city'.", "Add conditions to filter the 'regional_population' column for both specified thresholds using placeholders for numeric values."], "gold_sql": "SELECT city FROM city WHERE regional_population  >  10000000 UNION SELECT city FROM city WHERE regional_population  <  5000000", "source_tables": ["city"], "description": "The virtual table lists the names of cities from the 'city' table that have a regional population either exceeding a specified upper limit or falling below a specified lower limit. The placeholders in the WHERE clauses represent the numeric thresholds for population.", "virtual_table": "SELECT city FROM city WHERE regional_population  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT city FROM city WHERE regional_population  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6293", "db_id": "city_record", "question": "Which cities have lower temperature in March than in Dec and have never served as host cities?", "rationale": ["Identify the relevant tables: 'city', 'temperature', and 'hosting_city'.", "Join the 'city' table with the 'temperature' table to access temperature data for each city.", "Apply a condition to filter cities where the average temperature in March is less than in December.", "Use the EXCEPT clause to exclude cities that have hosted matches by checking against the 'hosting_city' table."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "description": "The virtual table lists cities that have a lower average temperature in March compared to December and have never hosted a match. It combines data from the 'city' and 'temperature' tables to filter cities based on their temperature records, while excluding those that appear in the 'hosting_city' table.", "virtual_table": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city"}
{"sample_id": "train.6290", "db_id": "city_record", "question": "Give me a list of cities whose temperature in Mar is lower than that in July and which have also served as host cities?", "rationale": ["Identify the relevant tables: 'city', 'temperature', and 'hosting_city'.", "Join the 'city' table with the 'temperature' table to access temperature data for each city.", "Filter the results to include only those cities where the average temperature in March is lower than in July.", "Use an INTERSECT operation to ensure that the cities listed have also served as host cities, by joining the 'city' table with the 'hosting_city' table."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul INTERSECT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "description": "The virtual table provides a list of cities that have hosted matches and have a March temperature lower than their July temperature. It combines data from the 'city', 'temperature', and 'hosting_city' tables, ensuring that only cities meeting the temperature criteria and hosting criteria are included.", "virtual_table": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul INTERSECT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city"}
{"sample_id": "train.6292", "db_id": "city_record", "question": "Give me a list of cities whose temperature in Mar is lower than that in Dec and which have never been host cities.", "rationale": ["Identify the relevant tables: 'city', 'temperature', and 'hosting_city'.", "Select the 'city' column from the 'city' table.", "Join the 'city' table with the 'temperature' table to access temperature data for comparison.", "Add a condition to filter cities where the March temperature is less than the December temperature.", "Use the EXCEPT clause to exclude cities that appear in the 'hosting_city' table, indicating they have hosted matches."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "description": "The virtual table lists cities from the 'city' table that have a March temperature lower than their December temperature, while also excluding those cities that have hosted any matches. The comparison of temperatures is done using the 'temperature' table, and the exclusion of host cities is managed through the 'hosting_city' table.", "virtual_table": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city"}
{"sample_id": "train.6289", "db_id": "city_record", "question": "Which cities' temperature in March is lower than that in July or higher than that in Oct?", "rationale": ["Identify the relevant tables, which are 'city' and 'temperature'.", "Select the 'city' column from the 'city' table.", "Join the 'city' table with the 'temperature' table on the 'city_id' to access temperature data.", "Add conditions to filter cities based on the average temperature in March compared to July and October using placeholders for numeric values."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul OR T2.Mar  >  T2.Oct", "source_tables": ["city", "temperature"], "description": "The virtual table provides a list of cities along with their temperature data, specifically focusing on the comparison of average temperatures in March with those in July and October. The query filters cities where the temperature in March is either lower than in July or higher than in October, allowing users to analyze temperature variations across different months.", "virtual_table": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul OR T2.Mar  >  T2.Oct"}
{"sample_id": "train.6276", "db_id": "city_record", "question": "What is the venue of the competition \"1994 FIFA World Cup qualification\" hosted by \"Nanjing ( Jiangsu )\"?", "rationale": ["Identify the relevant tables: 'city', 'hosting_city', and 'match'.", "Select the 'venue' column from the 'match' table.", "Join the 'city' table with 'hosting_city' on the city identifier to filter by the host city.", "Join the 'hosting_city' table with 'match' on the match identifier to access competition details.", "Add conditions to filter the results based on the specified city name and competition name using placeholders for string values."], "gold_sql": "SELECT T3.venue FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id = T2.host_city JOIN MATCH AS T3 ON T2.match_id = T3.match_id WHERE T1.city = 'Nanjing ( Jiangsu )' AND T3.competition = '1994 FIFA World Cup qualification'", "source_tables": ["hosting_city", "city", "match"], "description": "The virtual table provides information about the venue of matches from the 'match' table that were hosted in a specific city, as indicated in the 'hosting_city' table. It joins the 'city' table to filter by the city's name and the 'match' table to filter by the competition name, both represented by placeholders for string values.", "virtual_table": "SELECT T3.venue FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id = T2.host_city JOIN MATCH AS T3 ON T2.match_id = T3.match_id WHERE T1.city = [PLACEHOLDER-TYPE:STRING] AND T3.competition = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6286", "db_id": "city_record", "question": "Which city has the highest temperature in February?", "rationale": ["Identify the relevant tables, which are 'city' and 'temperature'.", "Join the 'city' table with the 'temperature' table on the 'City_ID' to associate cities with their temperature data.", "Select the 'City' column from the 'city' table to display the names of the cities.", "Order the results by the 'Feb' column from the 'temperature' table in descending order to find the highest temperature.", "Use a placeholder in the LIMIT clause to allow the user to specify how many cities they want to retrieve."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id ORDER BY T2.Feb DESC LIMIT 1", "source_tables": ["city", "temperature"], "description": "The virtual table provides a list of cities along with their corresponding February temperatures, sorted in descending order. The placeholder in the LIMIT clause indicates that the user can specify the number of cities to retrieve, allowing for flexibility in the query results.", "virtual_table": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id ORDER BY T2.Feb DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6283", "db_id": "city_record", "question": "What are the three largest cities in terms of regional population?", "rationale": ["Identify the relevant table, which is 'city'.", "Select the column to display, 'city'.", "Order the results by 'regional_population' in descending order to get the largest cities first.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT city FROM city ORDER BY regional_population DESC LIMIT 3", "source_tables": ["city"], "description": "The virtual table lists the names of cities from the 'city' table, ordered by their regional population in descending order. The placeholder indicates that the user can specify the number of cities to retrieve, allowing for flexibility in the query results.", "virtual_table": "SELECT city FROM city ORDER BY regional_population DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4270", "db_id": "club_1", "question": "Find all the female members of club \"Bootup Baltimore\". Show the first name and last name.", "rationale": ["Identify the relevant tables: 'Club', 'Member_of_club', and 'Student'.", "Select the columns to display: 'fname' and 'lname' from the 'Student' table.", "Join the 'Club' table with the 'Member_of_club' table on 'ClubID' to link clubs with their members.", "Join the 'Member_of_club' table with the 'Student' table on 'StuID' to link members with their details.", "Add conditions to filter for the specified club name and for female students using placeholders for string values."], "gold_sql": "SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  'Bootup Baltimore' AND t3.sex  =  'F'", "source_tables": ["club", "member_of_club", "student"], "description": "The virtual table provides the first and last names of female students who are members of a specific club. It combines data from the 'Student', 'Club', and 'Member_of_club' tables, filtering for a particular club name and gender. The placeholders in the WHERE clause represent the club's name and the gender of the students.", "virtual_table": "SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  [PLACEHOLDER-TYPE:STRING] AND t3.sex  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4278", "db_id": "club_1", "question": "Find the name of the club that has the most female students.", "rationale": ["Identify the relevant tables: 'Club', 'Member_of_club', and 'Student'.", "Select the column to display, which is 'clubname' from the 'Club' table.", "Join the 'Club' table with 'Member_of_club' on 'clubid' and then with 'Student' on 'stuid' to access student information.", "Add a condition to filter the results based on the 'sex' column for female students using a placeholder for string values.", "Group the results by 'clubname' to count the number of female members in each club.", "Order the results in descending order based on the count of female members and limit the output to the top result using placeholders for the limit."], "gold_sql": "SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.sex  =  'F' GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT 1", "source_tables": ["club", "member_of_club", "student"], "description": "The virtual table provides the names of clubs from the 'Club' table that have the highest number of female students as members. It joins the 'Club', 'Member_of_club', and 'Student' tables to filter the results based on the gender of the students, using a placeholder for the gender value and another placeholder to limit the number of results returned.", "virtual_table": "SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.sex  =  [PLACEHOLDER-TYPE:STRING] GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4279", "db_id": "club_1", "question": "Which club has the most female students as their members? Give me the name of the club.", "rationale": ["Identify the relevant tables: 'Club', 'Member_of_club', and 'Student'.", "Select the 'clubname' from the 'Club' table.", "Join the 'Member_of_club' table to associate students with their respective clubs.", "Join the 'Student' table to filter members based on their gender.", "Add a condition to filter the 'sex' column for female students using a placeholder for string values.", "Group the results by club name and order them by the count of female members in descending order.", "Limit the results to return only the top club using a placeholder for numeric values."], "gold_sql": "SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.sex  =  'F' GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT 1", "source_tables": ["club", "member_of_club", "student"], "description": "The virtual table provides the names of clubs from the 'Club' table that have the highest number of female student members. It joins the 'Club', 'Member_of_club', and 'Student' tables to filter members based on gender, using a placeholder for the gender value and another placeholder to limit the number of results returned.", "virtual_table": "SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.sex  =  [PLACEHOLDER-TYPE:STRING] GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4312", "db_id": "club_1", "question": "List the clubs that have at least a member with advisor \"1121\".", "rationale": ["Identify the relevant tables: 'Club', 'Member_of_club', and 'Student'.", "Select the distinct 'ClubName' from the 'Club' table.", "Join the 'Member_of_club' table on 'ClubID' to associate members with their respective clubs.", "Join the 'Student' table on 'StuID' to access the advisor information of the members.", "Add a condition to filter the results based on the advisor's ID using a placeholder for numeric values."], "gold_sql": "SELECT DISTINCT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.advisor  =  1121", "source_tables": ["club", "member_of_club", "student"], "description": "The virtual table lists the unique names of clubs from the 'Club' table that have at least one member whose academic advisor matches a specified identifier. The query joins the 'Club', 'Member_of_club', and 'Student' tables to filter clubs based on the advisor's ID provided as a placeholder.", "virtual_table": "SELECT DISTINCT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.advisor  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4256", "db_id": "club_1", "question": "What are the first names of all the students?", "rationale": ["Identify the relevant table, which is 'Student'.", "Select the column to display, 'Fname', ensuring to retrieve distinct values to avoid duplicates."], "gold_sql": "SELECT DISTINCT fname FROM student", "source_tables": ["student"], "description": "The virtual table contains the distinct first names of students from the 'Student' table. This table provides a unique list of first names without any duplicates.", "virtual_table": "SELECT DISTINCT fname FROM student"}
{"sample_id": "train.3324", "db_id": "college_1", "question": "What are the different first names and highest degree attained for professors teaching in the Computer Information Systems department?", "rationale": ["Identify the relevant tables: 'CLASS', 'EMPLOYEE', 'PROFESSOR', and 'DEPARTMENT'.", "Select the distinct first names from the 'EMPLOYEE' table and the highest degree from the 'PROFESSOR' table.", "Join the tables based on their relationships: 'CLASS' to 'EMPLOYEE' via 'PROF_NUM', 'EMPLOYEE' to 'PROFESSOR' via 'EMP_NUM', and 'PROFESSOR' to 'DEPARTMENT' via 'DEPT_CODE'.", "Add a condition to filter the results based on the department name using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T2.emp_fname ,  T3.prof_high_degree FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN professor AS T3 ON T2.emp_num  =  T3.emp_num JOIN department AS T4 ON T4.dept_code  =  T3.dept_code WHERE T4.dept_name  =  'Computer Info. Systems'", "source_tables": ["employee", "professor", "class", "department"], "description": "The virtual table provides a list of distinct first names of professors along with their highest degree attained, specifically for those teaching in a designated department. The query joins multiple tables: 'CLASS' to identify the professors, 'EMPLOYEE' to retrieve their first names, 'PROFESSOR' to access their highest degree, and 'DEPARTMENT' to filter by the department name. The placeholder in the WHERE clause allows for specifying the department of interest.", "virtual_table": "SELECT DISTINCT T2.emp_fname ,  T3.prof_high_degree FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN professor AS T3 ON T2.emp_num  =  T3.emp_num JOIN department AS T4 ON T4.dept_code  =  T3.dept_code WHERE T4.dept_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3272", "db_id": "college_1", "question": "Which department has the most professors with a Ph.D.?", "rationale": ["Identify the relevant tables, which are 'professor' and 'department'.", "Select the columns to display, 'dept_name' from the 'department' table and 'dept_code' from the 'professor' table.", "Join the 'professor' table with the 'department' table on the department code to associate professors with their respective departments.", "Add a condition to filter the professors based on their highest degree using a placeholder for string values.", "Group the results by department code to aggregate the count of professors per department.", "Order the results by the count of professors in descending order to find the department with the most professors.", "Limit the results to return only the top department based on the count of professors."], "gold_sql": "SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  'Ph.D.' GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["department", "professor"], "description": "The virtual table provides a list of department names along with their corresponding department codes, specifically focusing on departments that have professors holding a Ph.D. The results are grouped by department code and ordered by the count of professors in descending order, allowing for the identification of the department with the highest number of Ph.D. professors. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the number of results to return.", "virtual_table": "SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3323", "db_id": "college_1", "question": "Find the first names and degree of all professors who are teaching some class in Computer Info. Systems department.", "rationale": ["Identify the relevant tables: 'CLASS', 'EMPLOYEE', 'PROFESSOR', and 'DEPARTMENT'.", "Select the columns to display: 'emp_fname' from 'EMPLOYEE' and 'prof_high_degree' from 'PROFESSOR'.", "Join the tables based on their relationships: 'CLASS' to 'EMPLOYEE' via 'prof_num', 'EMPLOYEE' to 'PROFESSOR' via 'emp_num', and 'PROFESSOR' to 'DEPARTMENT' via 'dept_code'.", "Add a condition to filter the 'DEPARTMENT' table for the specified department's name using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T2.emp_fname ,  T3.prof_high_degree FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN professor AS T3 ON T2.emp_num  =  T3.emp_num JOIN department AS T4 ON T4.dept_code  =  T3.dept_code WHERE T4.dept_name  =  'Computer Info. Systems'", "source_tables": ["employee", "professor", "class", "department"], "description": "The virtual table provides the first names and highest degrees of professors from the 'professor' table who are teaching classes associated with a specific department. The query joins multiple tables to filter professors based on the department's name, represented by a placeholder for string values.", "virtual_table": "SELECT DISTINCT T2.emp_fname ,  T3.prof_high_degree FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN professor AS T3 ON T2.emp_num  =  T3.emp_num JOIN department AS T4 ON T4.dept_code  =  T3.dept_code WHERE T4.dept_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3292", "db_id": "college_1", "question": "What is the first name of the professor who is teaching CIS-220 and QM-261?", "rationale": ["Identify the relevant tables, which are 'employee' and 'class'.", "Select the column to display, 'emp_fname' from the 'employee' table.", "Join the 'employee' table with the 'class' table on the professor's identifier 'emp_num' and 'prof_num'.", "Add conditions to filter the 'crs_code' column for the specified courses using placeholders for string values."], "gold_sql": "SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  'CIS-220' INTERSECT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  'QM-261'", "source_tables": ["employee", "class"], "description": "The virtual table provides the first names of professors who are teaching specific courses. It combines data from the 'employee' and 'class' tables, linking them through the professor's identifier. The placeholders in the WHERE clause represent the course codes for which the professors are being queried.", "virtual_table": "SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3293", "db_id": "college_1", "question": "Find the first name of student who is taking classes from accounting and Computer Info. Systems departments", "rationale": ["Identify the relevant tables: 'student', 'enroll', 'class', 'course', and 'department'.", "Select the column to display, which is 'stu_fname' from the 'student' table.", "Join the tables based on their relationships: 'student' to 'enroll' on 'stu_num', 'enroll' to 'class' on 'class_code', 'class' to 'course' on 'crs_code', and 'course' to 'department' on 'dept_code'.", "Add conditions to filter the results for the specified departments using placeholders for string values.", "Use INTERSECT to ensure that only students enrolled in both departments are included."], "gold_sql": "SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Accounting' INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Computer Info. Systems'", "source_tables": ["course", "enroll", "department", "class", "student"], "description": "The virtual table provides the first names of students who are enrolled in classes from both the accounting and Computer Info. Systems departments. It combines data from multiple tables, including 'student', 'enroll', 'class', 'course', and 'department', using joins to connect the relevant identifiers. The placeholders in the WHERE clause represent the names of the departments being queried.", "virtual_table": "SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3179", "db_id": "college_1", "question": "What are the first names and date of birth of professors teaching course ACCT-211?", "rationale": ["Identify the relevant tables, which are 'employee' and 'CLASS'.", "Select the columns to display, 'EMP_FNAME' and 'EMP_DOB' from the 'employee' table.", "Join the 'employee' table with the 'CLASS' table on the professor's identifier to link professors with their classes.", "Add a condition to filter the 'CRS_CODE' column for the specified course using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["employee", "class"], "description": "The virtual table provides the first names and dates of birth of professors from the 'employee' table who are teaching a specific course. The placeholder in the WHERE clause represents the course code associated with the class.", "virtual_table": "SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3216", "db_id": "college_1", "question": "How many professors have a Ph.D. in each department?", "rationale": ["Identify the relevant table, which is 'professor'.", "Select the count of professors and the department code to display.", "Add a condition to filter the 'prof_high_degree' column for the specified degree using a placeholder for string values.", "Group the results by 'dept_code' to aggregate the count of professors per department."], "gold_sql": "SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  'Ph.D.' GROUP BY dept_code", "source_tables": ["professor"], "description": "The virtual table provides a count of professors holding a specific highest degree, grouped by their respective departments. The placeholder in the WHERE clause allows for filtering by the degree type, such as a Ph.D., while the GROUP BY clause organizes the results by department code.", "virtual_table": "SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY dept_code"}
{"sample_id": "train.3274", "db_id": "college_1", "question": "What are the first names of all professors not teaching any classes?", "rationale": ["Identify the relevant table, which is 'employee'.", "Select the column to display, 'emp_fname'.", "Add a condition to filter the 'emp_jobcode' column using a placeholder for string values.", "Use the EXCEPT clause to exclude professors who are teaching classes by joining the 'employee' table with the 'CLASS' table on the professor's identifier."], "gold_sql": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  'PROF' EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num", "source_tables": ["employee", "class"], "description": "The virtual table provides the first names of professors from the 'employee' table who are not currently assigned to teach any classes. The query uses a placeholder to specify the job code of the professors, and it excludes those who are linked to any class in the 'CLASS' table by comparing the professor's identifier with the professor number in the class records.", "virtual_table": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num"}
{"sample_id": "train.3210", "db_id": "college_1", "question": "How many different professors are there for the different schools?", "rationale": ["Identify the relevant tables, which are 'department' and 'professor'.", "Count the number of professors by grouping them according to the 'school_code' from the 'department' table.", "Use a JOIN operation to connect the 'department' and 'professor' tables based on the 'dept_code' to ensure accurate counting of professors per school."], "gold_sql": "SELECT count(*) ,  T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code", "source_tables": ["department", "professor"], "description": "The virtual table provides a count of distinct professors associated with various schools, as represented by the 'school_code' from the 'department' table. The query joins the 'department' and 'professor' tables based on the department code, allowing for aggregation of professors by their respective schools.", "virtual_table": "SELECT count(*) ,  T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code"}
{"sample_id": "train.3201", "db_id": "college_1", "question": "What is the total credit does each department offer?", "rationale": ["Identify the relevant table, which is 'Course'.", "Select the sum of 'crs_credit' to calculate the total credit hours offered.", "Group the results by 'dept_code' to aggregate the total credit hours for each department."], "gold_sql": "SELECT sum(crs_credit) ,  dept_code FROM course GROUP BY dept_code", "source_tables": ["course"], "description": "The virtual table summarizes the total credit hours offered by each department based on the courses available in the 'Course' table. The placeholder in the SELECT statement represents the total credit hours, while the GROUP BY clause organizes the results by department code.", "virtual_table": "SELECT sum(crs_credit) ,  dept_code FROM course GROUP BY dept_code"}
{"sample_id": "train.3315", "db_id": "college_1", "question": "Find the first names and offices of all instructors who have taught some course and the course description and the department name.", "rationale": ["Identify the relevant tables: CLASS, EMPLOYEE, COURSE, PROFESSOR, and DEPARTMENT.", "Select the columns to display: first names from EMPLOYEE, office locations from PROFESSOR, course descriptions from COURSE, and department names from DEPARTMENT.", "Establish the necessary joins between the tables based on their relationships, such as linking CLASS to EMPLOYEE through professor identifiers, and linking COURSE to CLASS through course codes."], "gold_sql": "SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description ,  T5.dept_name FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num JOIN department AS T5 ON T4.dept_code  =  T5.dept_code", "source_tables": ["course", "department", "professor", "class", "employee"], "description": "The virtual table provides the first names and office locations of instructors who have taught courses, along with the descriptions of those courses and the names of the departments offering them. It combines data from multiple tables, including CLASS, EMPLOYEE, COURSE, PROFESSOR, and DEPARTMENT, to present a comprehensive view of the instructors and their associated courses and departments.", "virtual_table": "SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description ,  T5.dept_name FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num JOIN department AS T5 ON T4.dept_code  =  T5.dept_code"}
{"sample_id": "train.3176", "db_id": "college_1", "question": "How many professors teach a class with the code ACCT-211?", "rationale": ["Identify the relevant table, which is 'CLASS'.", "Select the count of distinct 'PROF_NUM' to determine the number of unique professors.", "Add a condition to filter the 'CRS_CODE' column for the specified class code using a placeholder for string values."], "gold_sql": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["class"], "description": "The virtual table provides a count of distinct professors from the 'CLASS' table who are assigned to teach a specific class identified by its course code. The placeholder in the WHERE clause represents the course code for which the count of professors is being queried.", "virtual_table": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3254", "db_id": "college_1", "question": "What is the name of the department with the most students enrolled?", "rationale": ["Identify the relevant tables: CLASS, ENROLL, COURSE, and DEPARTMENT.", "Join the tables based on their relationships to connect classes with enrollments and courses with departments.", "Select the 'dept_name' from the DEPARTMENT table.", "Group the results by department code to count the number of students enrolled in each department.", "Order the results in descending order based on the count of enrollments to find the department with the most students.", "Limit the results to return only the top department based on the specified number."], "gold_sql": "SELECT T4.dept_name FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code GROUP BY T3.dept_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["course", "department", "class", "enroll"], "description": "The virtual table provides the names of departments from the 'department' table that have the highest number of students enrolled in their courses. It aggregates the data by counting the number of enrollments per department and orders the results to show the department with the most students at the top. The placeholder in the LIMIT clause allows for specifying how many top departments to return.", "virtual_table": "SELECT T4.dept_name FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code GROUP BY T3.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3213", "db_id": "college_1", "question": "Which school has the smallest amount of professors?", "rationale": ["Identify the relevant tables, which are 'department' and 'professor'.", "Join the 'department' table with the 'professor' table on the department code to associate professors with their respective schools.", "Select the 'school_code' from the 'department' table.", "Group the results by 'school_code' to aggregate the count of professors for each school.", "Order the results by the count of professors in ascending order to find the school with the smallest number.", "Use a placeholder to limit the results to the top entry."], "gold_sql": "SELECT T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code ORDER BY count(*) LIMIT 1", "source_tables": ["department", "professor"], "description": "The virtual table identifies the school codes from the 'department' table, joining it with the 'professor' table to count the number of professors associated with each school. The results are grouped by school code and ordered by the count of professors, allowing for the identification of the school with the smallest number of professors, as indicated by the placeholder for limiting the results.", "virtual_table": "SELECT T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3253", "db_id": "college_1", "question": "What is the name of the department that has the largest number of students enrolled?", "rationale": ["Identify the relevant tables: 'CLASS', 'ENROLL', 'COURSE', and 'DEPARTMENT'.", "Join these tables based on their foreign key relationships to access the necessary data.", "Count the number of students enrolled in each department by grouping the results by department code.", "Order the results in descending order to find the department with the largest number of students.", "Use a placeholder in the LIMIT clause to allow for flexibility in specifying how many top results to return."], "gold_sql": "SELECT T4.dept_name FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code GROUP BY T3.dept_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["course", "department", "class", "enroll"], "description": "The virtual table provides the name of the department with the highest enrollment of students by aggregating data from multiple tables. It joins the 'CLASS', 'ENROLL', 'COURSE', and 'DEPARTMENT' tables to count the number of students in each department, grouping the results by department code and ordering them in descending order of student count. The placeholder in the LIMIT clause allows for specifying the number of top results to return.", "virtual_table": "SELECT T4.dept_name FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code GROUP BY T3.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3237", "db_id": "college_1", "question": "Find the total credits of all classes offered by each department.", "rationale": ["Identify the relevant tables, which are 'course' and 'class'.", "Select the sum of 'crs_credit' from the 'course' table and group the results by 'dept_code'.", "Join the 'course' table with the 'class' table on the 'crs_code' to link classes with their respective courses."], "gold_sql": "SELECT sum(T1.crs_credit) ,  T1.dept_code FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY T1.dept_code", "source_tables": ["course", "class"], "description": "The virtual table summarizes the total credits of all classes offered by each department by aggregating the credit hours from the 'course' table and joining it with the 'class' table based on the course code. The result is grouped by the department code, allowing for a clear view of the total credits associated with each department.", "virtual_table": "SELECT sum(T1.crs_credit) ,  T1.dept_code FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY T1.dept_code"}
{"sample_id": "train.3240", "db_id": "college_1", "question": "Which department offers the most credits all together?", "rationale": ["Identify the relevant tables: 'course', 'class', and 'department'.", "Join the 'course' table with the 'class' table on the course code to associate classes with their respective courses.", "Join the resulting table with the 'department' table to retrieve department names based on the department code.", "Group the results by department to aggregate the total credit hours offered by each department.", "Order the results by the sum of credit hours in descending order to find the department offering the most credits.", "Use a placeholder for the limit to specify how many departments to return."], "gold_sql": "SELECT T3.dept_name FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code JOIN department AS T3 ON T1.dept_code  =  T3.dept_code GROUP BY T1.dept_code ORDER BY sum(T1.crs_credit) DESC LIMIT 1", "source_tables": ["course", "department", "class"], "description": "The virtual table summarizes the names of departments that offer courses, along with the total credit hours associated with those courses. It aggregates the credit hours from the 'course' table, joins it with the 'class' table to associate classes with their respective courses, and then links to the 'department' table to retrieve the department names. The results are grouped by department and ordered by the total credit hours in descending order, with a limit specified by a placeholder for numeric values.", "virtual_table": "SELECT T3.dept_name FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code JOIN department AS T3 ON T1.dept_code  =  T3.dept_code GROUP BY T1.dept_code ORDER BY sum(T1.crs_credit) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3219", "db_id": "college_1", "question": "Find the total number of hours have done for all students in each department.", "rationale": ["Identify the relevant table, which is 'student'.", "Select the column to aggregate, 'stu_hrs', and group the results by 'dept_code'.", "Use the SUM function to calculate the total hours for each department."], "gold_sql": "SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "description": "The virtual table summarizes the total credit hours completed by students grouped by their respective departments. It aggregates the 'stu_hrs' from the 'student' table and categorizes the results based on the 'dept_code' associated with each student.", "virtual_table": "SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code"}
{"sample_id": "train.3205", "db_id": "college_1", "question": "Find the number of classes in each department.", "rationale": ["Identify the relevant tables, which are 'CLASS' and 'COURSE'.", "Count the total number of classes using the count(*) function.", "Join the 'CLASS' table with the 'COURSE' table on the course code to associate classes with their respective departments.", "Group the results by the department code to get the count of classes per department."], "gold_sql": "SELECT count(*) ,  dept_code FROM CLASS AS T1 JOIN course AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY dept_code", "source_tables": ["course", "class"], "description": "The virtual table provides a count of classes grouped by their respective departments. It combines data from the 'CLASS' and 'COURSE' tables, linking them through the course code. The result will show the total number of classes available in each department, with a placeholder for the department code used in the grouping.", "virtual_table": "SELECT count(*) ,  dept_code FROM CLASS AS T1 JOIN course AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY dept_code"}
{"sample_id": "train.3217", "db_id": "college_1", "question": "Find the number of students for each department.", "rationale": ["Identify the relevant table, which is 'Student'.", "Use the COUNT function to calculate the number of students.", "Group the results by the 'dept_code' to get the count for each department."], "gold_sql": "SELECT count(*) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "description": "The virtual table summarizes the count of students grouped by their respective departments from the 'Student' table. Each entry in the table represents a department code along with the total number of students enrolled in that department.", "virtual_table": "SELECT count(*) ,  dept_code FROM student GROUP BY dept_code"}
{"sample_id": "train.3241", "db_id": "college_1", "question": "How many students enrolled in class ACCT-211?", "rationale": ["Identify the relevant tables, which are 'CLASS' and 'ENROLL'.", "Use a JOIN to connect the 'CLASS' table with the 'ENROLL' table based on the class code.", "Select the count of students by using the count(*) function.", "Add a condition to filter the results based on the course code using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code WHERE T1.crs_code  =  'ACCT-211'", "source_tables": ["class", "enroll"], "description": "The virtual table provides a count of students enrolled in a specific class from the 'CLASS' and 'ENROLL' tables. The placeholder in the WHERE clause represents the course code associated with the class, allowing users to specify which class they are inquiring about.", "virtual_table": "SELECT count(*) FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code WHERE T1.crs_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3300", "db_id": "college_1", "question": "What is the name of the department with the student that has the lowest GPA?", "rationale": ["Identify the relevant tables, which are 'student' and 'department'.", "Join the 'student' table with the 'department' table using the 'dept_code' to link students to their respective departments.", "Select the 'dept_name' from the 'department' table.", "Order the results by 'stu_gpa' in ascending order to find the student with the lowest GPA.", "Limit the results to one entry to get only the department name of the student with the lowest GPA."], "gold_sql": "SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT 1", "source_tables": ["department", "student"], "description": "The virtual table provides the name of the department associated with the student who has the lowest GPA. It combines data from the 'student' and 'department' tables, linking them through the department code. The result is ordered by the student's GPA in ascending order, ensuring that the student with the lowest GPA is selected.", "virtual_table": "SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3245", "db_id": "college_1", "question": "What is the first name of students enrolled in class ACCT-211 and got grade C?", "rationale": ["Identify the relevant tables: 'CLASS', 'ENROLL', and 'STUDENT'.", "Select the column to display, which is 'stu_fname' from the 'STUDENT' table.", "Join the 'CLASS' table with the 'ENROLL' table on 'class_code' to link classes with enrollments.", "Join the 'ENROLL' table with the 'STUDENT' table on 'stu_num' to link enrollments with student details.", "Add conditions to filter the results based on the specified course code and grade using placeholders for string values."], "gold_sql": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  'ACCT-211' AND T2.enroll_grade  =  'C'", "source_tables": ["student", "class", "enroll"], "description": "The virtual table provides the first names of students who are enrolled in a specific class and have received a particular grade. It combines data from the 'CLASS', 'ENROLL', and 'STUDENT' tables, using placeholders to filter by the course code and the grade received.", "virtual_table": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  [PLACEHOLDER-TYPE:STRING] AND T2.enroll_grade  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3333", "db_id": "college_1", "question": "Find the name of department that offers the class whose description has the word \"Statistics\".", "rationale": ["Identify the relevant tables, which are 'course' and 'department'.", "Select the column to display, 'dept_name' from the 'department' table.", "Join the 'course' table with the 'department' table using the 'dept_code' to link them.", "Add a condition to filter the 'crs_description' column for descriptions that contain a specific keyword using a placeholder for string values."], "gold_sql": "SELECT T2.dept_name FROM course AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.crs_description LIKE '%Statistics%'", "source_tables": ["course", "department"], "description": "The virtual table provides the names of departments that offer courses with descriptions containing a specific keyword. The query joins the 'course' and 'department' tables based on the department code, filtering the results to include only those courses whose descriptions match the given criteria.", "virtual_table": "SELECT T2.dept_name FROM course AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.crs_description LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3299", "db_id": "college_1", "question": "What is the department name of the students with lowest gpa belongs to?", "rationale": ["Identify the relevant tables, which are 'Student' and 'Department'.", "Select the 'dept_name' column from the 'Department' table.", "Join the 'Student' table with the 'Department' table using the 'dept_code' foreign key.", "Order the results by the 'stu_gpa' column in ascending order to find students with the lowest GPA.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT 1", "source_tables": ["department", "student"], "description": "The virtual table provides the names of departments associated with students from the 'Student' table, specifically focusing on those with the lowest GPA. The query joins the 'Student' and 'Department' tables based on the department code, and it orders the results by GPA in ascending order, limiting the output to a specified number of entries.", "virtual_table": "SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3243", "db_id": "college_1", "question": "What is the first name of each student enrolled in class ACCT-211?", "rationale": ["Identify the relevant tables: 'CLASS', 'ENROLL', and 'STUDENT'.", "Select the column to display, which is 'stu_fname' from the 'STUDENT' table.", "Join the 'CLASS' table with the 'ENROLL' table on 'class_code' to link classes with enrollments.", "Join the 'ENROLL' table with the 'STUDENT' table on 'stu_num' to link enrollments with student information.", "Add a condition to filter the 'CLASS' table for the specified course code using a placeholder for string values."], "gold_sql": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  'ACCT-211'", "source_tables": ["student", "class", "enroll"], "description": "The virtual table provides the first names of students who are enrolled in a specific class identified by its course code. The query joins the 'CLASS', 'ENROLL', and 'STUDENT' tables to filter the results based on the course code placeholder.", "virtual_table": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.370", "db_id": "cre_Doc_Template_Mgt", "question": "What are the ids and names of each document, as well as the number of paragraphs in each?", "rationale": ["Identify the relevant tables, which are 'Documents' and 'Paragraphs'.", "Select the columns to display: 'document_id' and 'document_name' from the 'Documents' table, and count the number of paragraphs from the 'Paragraphs' table.", "Join the 'Paragraphs' table with the 'Documents' table using the document ID as the linking key.", "Group the results by the document ID to ensure that the count of paragraphs corresponds to each document."], "gold_sql": "SELECT T1.document_id ,  T2.document_name ,  count(*) FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id GROUP BY T1.document_id", "source_tables": ["paragraphs", "documents"], "description": "The virtual table provides a summary of documents along with their identifiers and names, as well as the count of associated paragraphs. It combines data from the 'Documents' and 'Paragraphs' tables, linking them through the document identifier. The result is grouped by each document's ID to aggregate the number of paragraphs for each document.", "virtual_table": "SELECT T1.document_id ,  T2.document_name ,  count(*) FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id GROUP BY T1.document_id"}
{"sample_id": "dev.368", "db_id": "cre_Doc_Template_Mgt", "question": "Return the different document ids along with the number of paragraphs corresponding to each, ordered by id.", "rationale": ["Identify the relevant table, which is 'Paragraphs'.", "Select the 'document_id' and use the COUNT function to count the number of paragraphs for each document.", "Group the results by 'document_id' to aggregate the paragraph counts for each document.", "Order the final results by 'document_id' in ascending order."], "gold_sql": "SELECT document_id ,  count(*) FROM Paragraphs GROUP BY document_id ORDER BY document_id", "source_tables": ["paragraphs"], "description": "The virtual table provides a summary of document identifiers along with the count of paragraphs associated with each document. The results are organized in ascending order based on the document identifier.", "virtual_table": "SELECT document_id ,  count(*) FROM Paragraphs GROUP BY document_id ORDER BY document_id"}
{"sample_id": "dev.311", "db_id": "cre_Doc_Template_Mgt", "question": "What is the id and type code for the template used by the most documents?", "rationale": ["Identify the relevant tables, which are 'Documents' and 'Templates'.", "Select the columns to display, 'template_id' from 'Documents' and 'Template_Type_Code' from 'Templates'.", "Join the two tables on the 'template_id' to associate documents with their templates.", "Group the results by 'template_id' to count the number of documents for each template.", "Order the results in descending order based on the count of documents to find the most used templates.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT T1.template_id ,  T2.Template_Type_Code FROM Documents AS T1 JOIN Templates AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["templates", "documents"], "description": "The virtual table provides the template IDs and their corresponding type codes from the 'Templates' table, specifically for the templates that are associated with the highest number of documents. The placeholder in the LIMIT clause indicates the number of top results to return based on the document count.", "virtual_table": "SELECT T1.template_id ,  T2.Template_Type_Code FROM Documents AS T1 JOIN Templates AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.309", "db_id": "cre_Doc_Template_Mgt", "question": "Show all template ids and number of documents using each template.", "rationale": ["Identify the relevant table, which is 'Documents'.", "Select the 'template_id' column to display the IDs of the templates.", "Use the COUNT function to count the number of documents for each template ID.", "Group the results by 'template_id' to aggregate the document counts accordingly."], "gold_sql": "SELECT template_id ,  count(*) FROM Documents GROUP BY template_id", "source_tables": ["documents"], "description": "The virtual table displays the template IDs along with the count of documents associated with each template from the 'Documents' table. The grouping by template ID allows for aggregation of the document counts for each unique template.", "virtual_table": "SELECT template_id ,  count(*) FROM Documents GROUP BY template_id"}
{"sample_id": "dev.342", "db_id": "cre_Doc_Template_Mgt", "question": "What are the different template type codes, and how many documents use each type?", "rationale": ["Identify the relevant tables, which are 'Templates' and 'Documents'.", "Join the two tables on the 'Template_ID' to associate documents with their respective templates.", "Select the 'Template_Type_Code' from the 'Templates' table and count the number of documents for each type.", "Group the results by 'Template_Type_Code' to aggregate the document counts for each template type."], "gold_sql": "SELECT T1.template_type_code ,  count(*) FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_type_code", "source_tables": ["templates", "documents"], "description": "The virtual table provides a summary of the different template type codes along with the count of documents associated with each template type. It combines data from the 'Templates' and 'Documents' tables, linking them through the template identifier. The result is grouped by the template type code, allowing users to see how many documents correspond to each type.", "virtual_table": "SELECT T1.template_type_code ,  count(*) FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_type_code"}
{"sample_id": "dev.362", "db_id": "cre_Doc_Template_Mgt", "question": "What are the details for the paragraph that includes the text 'Korea ' ?", "rationale": ["Identify the relevant table, which is 'Paragraphs'.", "Select the column to display, 'Other_Details'.", "Add a condition to filter the 'Paragraph_Text' column using a placeholder for string values to match the specified text."], "gold_sql": "select other_details from paragraphs where paragraph_text like 'korea'", "source_tables": ["paragraphs"], "description": "The virtual table provides details of paragraphs from the 'Paragraphs' table that contain specific text. The placeholder in the WHERE clause is used to filter the paragraphs based on the text content provided by the user.", "virtual_table": "select other_details from paragraphs where paragraph_text like [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.308", "db_id": "cre_Doc_Template_Mgt", "question": "Count the number of documents that use the PPT template type.", "rationale": ["Identify the relevant tables, which are 'Documents' and 'Templates'.", "Use a JOIN to connect 'Documents' with 'Templates' based on the 'Template_ID'.", "Count the total number of documents by using the count(*) function.", "Add a condition to filter the 'Template_Type_Code' in the WHERE clause using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM Documents AS T1 JOIN Templates AS T2 ON T1.Template_ID  =  T2.Template_ID WHERE T2.Template_Type_Code  =  'PPT'", "source_tables": ["templates", "documents"], "description": "The virtual table counts the total number of documents associated with a specific template type from the 'Documents' and 'Templates' tables. The placeholder in the WHERE clause represents the code for the template type being queried.", "virtual_table": "SELECT count(*) FROM Documents AS T1 JOIN Templates AS T2 ON T1.Template_ID  =  T2.Template_ID WHERE T2.Template_Type_Code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.336", "db_id": "cre_Doc_Template_Mgt", "question": "Return the lowest version number, along with its corresponding template type code.", "rationale": ["Identify the relevant table, which is 'Templates'.", "Select the minimum value of 'Version_Number' and the corresponding 'Template_Type_Code'.", "The use of the aggregate function 'min' allows for retrieving the lowest version number, while the template type code is included to provide context for that version."], "gold_sql": "SELECT min(Version_Number) ,  template_type_code FROM Templates", "source_tables": ["templates"], "description": "The virtual table provides the minimum version number of templates along with their associated template type codes from the 'Templates' table. The placeholder in the SELECT clause indicates that the version number will be dynamically determined based on the data in the table.", "virtual_table": "SELECT min(Version_Number) ,  template_type_code FROM Templates"}
{"sample_id": "dev.335", "db_id": "cre_Doc_Template_Mgt", "question": "What the smallest version number and its template type code?", "rationale": ["Identify the relevant table, which is 'Templates'.", "Select the minimum value of 'Version_Number' and the 'Template_Type_Code' to display.", "The query retrieves the smallest version number and its associated template type code, which is useful for understanding the earliest template versions available."], "gold_sql": "SELECT min(Version_Number) ,  template_type_code FROM Templates", "source_tables": ["templates"], "description": "The virtual table provides the minimum version number of templates along with their corresponding template type codes from the 'Templates' table. This allows users to identify the earliest version of templates and the type associated with it.", "virtual_table": "SELECT min(Version_Number) ,  template_type_code FROM Templates"}
{"sample_id": "train.5134", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the names of workshop groups in which services with product name \"film\" are performed?", "rationale": ["Identify the relevant tables, which are 'Drama_Workshop_Groups' and 'Services'.", "Select the columns to display, 'Store_Phone' and 'Store_Email_Address' from 'Drama_Workshop_Groups'.", "Join the 'Drama_Workshop_Groups' table with the 'Services' table on the 'Workshop_Group_ID' to link workshop groups with their services.", "Add a condition to filter the 'Product_Name' column in the 'Services' table using a placeholder for string values."], "gold_sql": "SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T2.Product_Name  =  'film'", "source_tables": ["services", "drama_workshop_groups"], "description": "The virtual table provides the store phone numbers and email addresses of workshop groups from the 'Drama_Workshop_Groups' table that offer services associated with a specific product name. The placeholder in the WHERE clause represents the product name being queried.", "virtual_table": "SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T2.Product_Name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5135", "db_id": "cre_Drama_Workshop_Groups", "question": "Find the names of the workshop groups where services with product name \"film\" are performed.", "rationale": ["Identify the relevant tables, which are 'Drama_Workshop_Groups' and 'Services'.", "Select the columns to display, 'Store_Phone' and 'Store_Email_Address' from 'Drama_Workshop_Groups'.", "Join the 'Drama_Workshop_Groups' table with the 'Services' table on the 'Workshop_Group_ID' to link workshop groups with their services.", "Add a condition to filter the 'Product_Name' column in the 'Services' table using a placeholder for string values."], "gold_sql": "SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T2.Product_Name  =  'film'", "source_tables": ["services", "drama_workshop_groups"], "description": "The virtual table provides the store phone numbers and email addresses of workshop groups from the 'Drama_Workshop_Groups' table that offer services associated with a specific product name. The placeholder in the WHERE clause represents the product name being queried.", "virtual_table": "SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T2.Product_Name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5168", "db_id": "cre_Drama_Workshop_Groups", "question": "What is the product ID of the most frequently ordered item on invoices?", "rationale": ["Identify the relevant table, which is 'INVOICES'.", "Select the 'Product_ID' column to display.", "Group the results by 'Product_ID' to aggregate the data.", "Order the results by the count of occurrences in descending order to find the most frequently ordered items.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT Product_ID FROM INVOICES GROUP BY Product_ID ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["invoices"], "description": "The virtual table provides the product IDs of items listed in the 'INVOICES' table, grouped by product ID. It orders the results by the frequency of each product's occurrence in the invoices, allowing the user to identify the most frequently ordered item. The placeholder in the LIMIT clause indicates the number of top results to return, which can be specified by the user.", "virtual_table": "SELECT Product_ID FROM INVOICES GROUP BY Product_ID ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5161", "db_id": "cre_Drama_Workshop_Groups", "question": "Which status code is the most common of all the bookings?", "rationale": ["Identify the relevant table, which is 'Bookings'.", "Select the 'Status_Code' column to analyze the booking statuses.", "Group the results by 'Status_Code' to count occurrences of each status.", "Order the results in descending order based on the count of each status code to find the most common one.", "Use a placeholder in the LIMIT clause to specify how many top results to return."], "gold_sql": "SELECT Status_Code FROM BOOKINGS GROUP BY Status_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["bookings"], "description": "The virtual table summarizes the status codes of bookings from the 'Bookings' table, grouping them to identify the most frequently occurring status code. The placeholder in the LIMIT clause indicates the number of top results to return, allowing for flexibility in specifying how many of the most common status codes to retrieve.", "virtual_table": "SELECT Status_Code FROM BOOKINGS GROUP BY Status_Code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5103", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the minimum, average, and maximum quantities ordered? Check all the invoices.", "rationale": ["Identify the relevant table, which is 'Invoices'.", "Select the 'Order_Quantity' column to perform aggregate functions: minimum, average, and maximum.", "Use aggregate functions to calculate the minimum, average, and maximum values of the 'Order_Quantity' column."], "gold_sql": "SELECT min(Order_Quantity) ,  avg(Order_Quantity) ,  max(Order_Quantity) FROM INVOICES", "source_tables": ["invoices"], "description": "The virtual table provides the minimum, average, and maximum quantities ordered from the invoices. The data is aggregated from the 'Invoices' table, focusing on the 'Order_Quantity' column to summarize the order quantities across all invoices.", "virtual_table": "SELECT min(Order_Quantity) ,  avg(Order_Quantity) ,  max(Order_Quantity) FROM INVOICES"}
{"sample_id": "train.5143", "db_id": "cre_Drama_Workshop_Groups", "question": "Find the order detail for the products with price above 2000.", "rationale": ["Identify the relevant tables, which are 'ORDER_ITEMS' and 'Products'.", "Select the column 'Other_Item_Details' from the 'ORDER_ITEMS' table.", "Join the 'ORDER_ITEMS' table with the 'Products' table on the 'Product_ID' to access product details.", "Add a condition to filter the products based on their price using a placeholder for numeric values."], "gold_sql": "SELECT T1.Other_Item_Details FROM ORDER_ITEMS AS T1 JOIN Products AS T2 ON T1.Product_ID  =  T2.Product_ID WHERE T2.Product_price  >  2000", "source_tables": ["products", "order_items"], "description": "The virtual table provides details about order items from the 'ORDER_ITEMS' table, specifically focusing on the additional details of items whose associated products have a price exceeding a specified amount. The placeholder in the WHERE clause allows for dynamic input of the price threshold.", "virtual_table": "SELECT T1.Other_Item_Details FROM ORDER_ITEMS AS T1 JOIN Products AS T2 ON T1.Product_ID  =  T2.Product_ID WHERE T2.Product_price  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5132", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the phones and emails of workshop groups in which services are performed?", "rationale": ["Identify the relevant tables, which are 'Drama_Workshop_Groups' and 'Services'.", "Select the columns to display, which are 'Store_Phone' and 'Store_Email_Address' from the 'Drama_Workshop_Groups' table.", "Establish a join between the two tables on the 'Workshop_Group_ID' to filter the results to only those workshop groups that have services performed."], "gold_sql": "SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID", "source_tables": ["services", "drama_workshop_groups"], "description": "The virtual table provides the phone numbers and email addresses of workshop groups from the 'Drama_Workshop_Groups' table that are associated with services offered in the 'Services' table. The join condition links the workshop groups to the services based on their unique identifiers.", "virtual_table": "SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID"}
{"sample_id": "train.5166", "db_id": "cre_Drama_Workshop_Groups", "question": "What is the average quantities ordered with payment method code \"MasterCard\" on invoices?", "rationale": ["Identify the relevant table, which is 'Invoices'.", "Select the column to calculate the average, 'Order_Quantity'.", "Add a condition to filter the 'payment_method_code' column for the specified payment method using a placeholder for string values."], "gold_sql": "SELECT avg(Order_Quantity) FROM Invoices WHERE payment_method_code  =  'MasterCard'", "source_tables": ["invoices"], "description": "The virtual table calculates the average quantity of products ordered from the 'Invoices' table, filtered by a specific payment method code. The placeholder in the WHERE clause represents the payment method being queried.", "virtual_table": "SELECT avg(Order_Quantity) FROM Invoices WHERE payment_method_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5133", "db_id": "cre_Drama_Workshop_Groups", "question": "Give me all the phone numbers and email addresses of the workshop groups where services are performed.", "rationale": ["Identify the relevant tables, which are 'Drama_Workshop_Groups' and 'Services'.", "Select the columns to display, which are 'Store_Phone' and 'Store_Email_Address' from the 'Drama_Workshop_Groups' table.", "Establish a join between 'Drama_Workshop_Groups' and 'Services' using the 'Workshop_Group_ID' to filter the results to only those workshop groups that have services performed."], "gold_sql": "SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID", "source_tables": ["services", "drama_workshop_groups"], "description": "The virtual table provides the phone numbers and email addresses of workshop groups from the 'Drama_Workshop_Groups' table that are associated with services offered. The join condition links the workshop groups to the services based on their unique identifiers, ensuring that only relevant workshop groups are included in the results.", "virtual_table": "SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID"}
{"sample_id": "train.5162", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the names of the workshop groups that have bookings with status code \"stop\"?", "rationale": ["Identify the relevant tables, which are 'Bookings' and 'Drama_Workshop_Groups'.", "Select the column to display, 'Store_Name' from the 'Drama_Workshop_Groups' table.", "Join the two tables on the 'Workshop_Group_ID' to link bookings to their respective workshop groups.", "Add a condition to filter the 'Status_Code' column in the 'Bookings' table using a placeholder for string values."], "gold_sql": "SELECT T2.Store_Name FROM Bookings AS T1 JOIN Drama_Workshop_Groups AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T1.Status_Code  =  'stop'", "source_tables": ["drama_workshop_groups", "bookings"], "description": "The virtual table provides the names of workshop groups from the 'Drama_Workshop_Groups' table that have associated bookings in the 'Bookings' table with a specific status code. The placeholder in the WHERE clause represents the status code to filter the results accordingly.", "virtual_table": "SELECT T2.Store_Name FROM Bookings AS T1 JOIN Drama_Workshop_Groups AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T1.Status_Code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5956", "db_id": "cre_Theme_park", "question": "What are the names and ids of the tourist attractions that are visited at most once?", "rationale": ["Identify the relevant tables, which are 'Tourist_Attractions' and 'Visits'.", "Select the columns to display, 'Name' and 'Tourist_Attraction_ID' from 'Tourist_Attractions'.", "Join the 'Tourist_Attractions' table with the 'Visits' table on the 'Tourist_Attraction_ID' to correlate attractions with their visit records.", "Group the results by 'Tourist_Attraction_ID' to aggregate visit counts for each attraction.", "Add a condition in the HAVING clause to filter attractions based on the count of visits, using a placeholder for the maximum visit count."], "gold_sql": "SELECT T1.Name ,  T1.Tourist_Attraction_ID FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID HAVING count(*)  <=  1", "source_tables": ["visits", "tourist_attractions"], "description": "The virtual table provides the names and unique identifiers of tourist attractions from the 'Tourist_Attractions' table that have been visited at most a specified number of times. The placeholder in the HAVING clause allows for the definition of the maximum visit count.", "virtual_table": "SELECT T1.Name ,  T1.Tourist_Attraction_ID FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID HAVING count(*)  <=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5951", "db_id": "cre_Theme_park", "question": "Show different tourist attractions' names, ids, and the corresponding number of visits.", "rationale": ["Identify the relevant tables, which are 'Tourist_Attractions' and 'Visits'.", "Select the columns to display: the name of the attraction from 'Tourist_Attractions', the attraction ID from 'Visits', and the count of visits.", "Join the two tables on the common column 'Tourist_Attraction_ID'.", "Group the results by 'Tourist_Attraction_ID' to aggregate the visit counts."], "gold_sql": "SELECT T1.Name ,  T2.Tourist_Attraction_ID ,   COUNT(*) FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID", "source_tables": ["visits", "tourist_attractions"], "description": "The virtual table provides a summary of tourist attractions along with their unique identifiers and the total number of visits recorded for each attraction. It combines data from the 'Tourist_Attractions' table, which includes the names and IDs of the attractions, and the 'Visits' table, which tracks the visit records. The result is grouped by the attraction ID to count the number of visits for each attraction.", "virtual_table": "SELECT T1.Name ,  T2.Tourist_Attraction_ID ,   COUNT(*) FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID"}
{"sample_id": "train.5965", "db_id": "cre_Theme_park", "question": "What are the names of tourist attraction that Alison visited but Rosalind did not visit?", "rationale": ["Identify the relevant tables: 'Tourist_Attractions', 'Visitors', and 'Visits'.", "Select the 'Name' column from the 'Tourist_Attractions' table.", "Join the 'Visitors' and 'Visits' tables to link tourist IDs with their respective visits to attractions.", "Use a WHERE clause to filter visits for the first tourist using a placeholder for their name.", "Use the EXCEPT clause to exclude attractions visited by the second tourist, again using a placeholder for their name."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  'Alison' EXCEPT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  'Rosalind'", "source_tables": ["visits", "visitors", "tourist_attractions"], "description": "The virtual table lists the names of tourist attractions that a specific tourist visited, while excluding those visited by another specified tourist. It utilizes joins between the 'Tourist_Attractions', 'Visitors', and 'Visits' tables to correlate the attractions with the respective tourists' visit records. The placeholders represent the names of the tourists involved in the query.", "virtual_table": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5955", "db_id": "cre_Theme_park", "question": "Show the names and ids of tourist attractions that are visited at most once.", "rationale": ["Identify the relevant tables, which are 'Tourist_Attractions' and 'Visits'.", "Select the columns to display, 'Name' and 'Tourist_Attraction_ID' from the 'Tourist_Attractions' table.", "Join the 'Tourist_Attractions' table with the 'Visits' table on the 'Tourist_Attraction_ID'.", "Group the results by 'Tourist_Attraction_ID' to count the number of visits for each attraction.", "Add a condition to filter the grouped results to include only those attractions that have been visited at most a specified number of times using a placeholder for numeric values."], "gold_sql": "SELECT T1.Name ,  T1.Tourist_Attraction_ID FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID HAVING count(*)  <=  1", "source_tables": ["visits", "tourist_attractions"], "description": "The virtual table provides the names and unique identifiers of tourist attractions from the 'Tourist_Attractions' table that have been visited at most a specified number of times. The query joins the 'Tourist_Attractions' table with the 'Visits' table to count the number of visits for each attraction, filtering the results based on the visit count using a placeholder for numeric values.", "virtual_table": "SELECT T1.Name ,  T1.Tourist_Attraction_ID FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID HAVING count(*)  <=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5945", "db_id": "cre_Theme_park", "question": "Show the transportation method most people choose to get to tourist attractions.", "rationale": ["Identify the relevant table, which is 'Tourist_Attractions'.", "Select the column 'How_to_Get_There' to display the transportation methods.", "Group the results by 'How_to_Get_There' to aggregate the data based on transportation methods.", "Order the results by the count of occurrences in descending order to find the most popular transportation method.", "Add a limit to specify how many of the top results to return using a placeholder for numeric values."], "gold_sql": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["tourist_attractions"], "description": "The virtual table summarizes the various transportation methods used by visitors to reach tourist attractions. It groups the data by the method of transportation and orders the results based on the frequency of each method, allowing users to identify the most popular choice. The placeholder in the LIMIT clause indicates the maximum number of results to return.", "virtual_table": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5946", "db_id": "cre_Theme_park", "question": "Which transportation method is used the most often to get to tourist attractions?", "rationale": ["Identify the relevant table, which is 'Tourist_Attractions'.", "Select the column 'How_to_Get_There' to display the transportation methods.", "Group the results by 'How_to_Get_There' to aggregate the data based on different methods.", "Order the results by the count of occurrences in descending order to find the most common method.", "Use a placeholder in the LIMIT clause to specify how many top results to return."], "gold_sql": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["tourist_attractions"], "description": "The virtual table summarizes the various transportation methods used to reach tourist attractions, derived from the 'Tourist_Attractions' table. It groups the data by the 'How_to_Get_There' column and orders the results based on the frequency of each method, allowing users to identify the most commonly used transportation method. The placeholder in the LIMIT clause indicates the number of top methods to retrieve.", "virtual_table": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5898", "db_id": "cre_Theme_park", "question": "What is the average price range of five star hotels that allow pets?", "rationale": ["Identify the relevant table, which is 'Hotels'.", "Select the average of the 'price_range' column to calculate the average price.", "Add conditions to filter the 'star_rating_code' for five-star hotels and 'pets_allowed_yn' to indicate if pets are allowed, using placeholders for these values."], "gold_sql": "SELECT avg(price_range) FROM HOTELS WHERE star_rating_code  =  '5' AND pets_allowed_yn  =  1", "source_tables": ["hotels"], "description": "The virtual table provides the average price range of hotels from the 'Hotels' table that have a specific star rating and allow pets. The placeholders in the WHERE clause represent the star rating code and the indication of whether pets are allowed.", "virtual_table": "SELECT avg(price_range) FROM HOTELS WHERE star_rating_code  =  [PLACEHOLDER-TYPE:STRING] AND pets_allowed_yn  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5927", "db_id": "cre_Theme_park", "question": "What are the details of the markets that can be accessed by walk or bus?", "rationale": ["Identify the relevant tables, which are 'Street_Markets' and 'Tourist_Attractions'.", "Select the column 'Market_Details' from the 'Street_Markets' table.", "Join the 'Street_Markets' table with the 'Tourist_Attractions' table on the condition that the 'Market_ID' matches the 'Tourist_Attraction_ID'.", "Add a condition to filter the results based on the 'How_to_Get_There' column for the specified modes of transportation using placeholders for string values."], "gold_sql": "SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  'walk' OR  T2.How_to_Get_There  =  'bus'", "source_tables": ["street_markets", "tourist_attractions"], "description": "The virtual table provides details of street markets that can be accessed by specific modes of transportation. It combines information from the 'Street_Markets' table and the 'Tourist_Attractions' table, filtering the results based on the accessibility instructions for the attractions. The placeholders in the WHERE clause represent the modes of transportation used to reach the attractions.", "virtual_table": "SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING] OR  T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5941", "db_id": "cre_Theme_park", "question": "Show the details of the top 3 most expensive hotels.", "rationale": ["Identify the relevant table, which is 'Hotels'.", "Select the column 'other_hotel_details' to display the details of the hotels.", "Order the results by 'price_range' in descending order to prioritize the most expensive hotels.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT 3", "source_tables": ["hotels"], "description": "The virtual table provides details of hotels from the 'Hotels' table, specifically focusing on the additional information about each hotel. The results are ordered by the price range in descending order, allowing users to identify the most expensive hotels. The placeholder in the LIMIT clause indicates that only a specified number of records will be returned, representing the top hotels based on their price range.", "virtual_table": "SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5902", "db_id": "cre_Theme_park", "question": "Return the detail of the location named \"UK Gallery\".", "rationale": ["Identify the relevant table, which is 'Locations'.", "Select the column to display, 'Other_Details'.", "Add a condition to filter the 'Location_Name' column for the specified location using a placeholder for string values."], "gold_sql": "SELECT Other_Details FROM LOCATIONS WHERE Location_Name  =  'UK Gallery'", "source_tables": ["locations"], "description": "The virtual table provides details about a specific location from the 'Locations' table, identified by its name. The placeholder in the WHERE clause is used to specify the name of the location being queried.", "virtual_table": "SELECT Other_Details FROM LOCATIONS WHERE Location_Name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5888", "db_id": "cre_Theme_park", "question": "Tell me the price ranges for all the hotels.", "rationale": ["Identify the relevant table, which is 'Hotels'.", "Select the column to display, 'price_range'.", "No additional conditions are needed since the query requests all price ranges."], "gold_sql": "SELECT price_range FROM HOTELS", "source_tables": ["hotels"], "description": "The virtual table provides a list of price ranges for hotels from the 'Hotels' table. Each entry represents a different price category that hotels fall into, allowing users to understand the various pricing options available.", "virtual_table": "SELECT price_range FROM HOTELS"}
{"sample_id": "train.5922", "db_id": "cre_Theme_park", "question": "Which tourist attractions are related to royal family? Tell me their details and how we can get there.", "rationale": ["Identify the relevant tables, which are 'Royal_Family' and 'Tourist_Attractions'.", "Select the columns to display: 'Royal_Family_Details' from the 'Royal_Family' table and 'How_to_Get_There' from the 'Tourist_Attractions' table.", "Establish a join condition that connects the 'Royal_Family_ID' from the 'Royal_Family' table to the 'Tourist_Attraction_ID' in the 'Tourist_Attractions' table, ensuring that only related records are retrieved."], "gold_sql": "SELECT T1.Royal_Family_Details ,  T2.How_to_Get_There FROM ROYAL_FAMILY AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Royal_Family_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["royal_family", "tourist_attractions"], "description": "The virtual table provides details about tourist attractions associated with royal family entries, including specific information about the royal family and instructions on how to reach the respective attractions. The join operation links the royal family details to the corresponding tourist attractions using a unique identifier.", "virtual_table": "SELECT T1.Royal_Family_Details ,  T2.How_to_Get_There FROM ROYAL_FAMILY AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Royal_Family_ID  =  T2.Tourist_Attraction_ID"}
{"sample_id": "train.5893", "db_id": "cre_Theme_park", "question": "Show details of all visitors.", "rationale": ["Identify the relevant table, which is 'Visitors'.", "Select the column to display, 'Tourist_Details'.", "Since the query requests details of all visitors, no additional filtering conditions are needed."], "gold_sql": "SELECT Tourist_Details FROM VISITORS", "source_tables": ["visitors"], "description": "The virtual table contains details of all visitors from the 'Visitors' table. The placeholder represents the specific details related to each tourist.", "virtual_table": "SELECT Tourist_Details FROM VISITORS"}
{"sample_id": "train.5904", "db_id": "cre_Theme_park", "question": "Find all the locations whose names contain the word \"film\".", "rationale": ["Identify the relevant table, which is 'Locations'.", "Select the column to display, 'Location_Name'.", "Add a condition to filter the 'Location_Name' column using a LIKE clause with a placeholder for string values."], "gold_sql": "SELECT Location_Name FROM LOCATIONS WHERE Location_Name LIKE '%film%'", "source_tables": ["locations"], "description": "The virtual table contains the names of locations from the 'Locations' table that include a specific keyword in their names. The placeholder in the WHERE clause is used to filter the location names based on the provided search term.", "virtual_table": "SELECT Location_Name FROM LOCATIONS WHERE Location_Name LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5931", "db_id": "cre_Theme_park", "question": "Which tourist attractions does the visitor with detail 'Vincent' visit?", "rationale": ["Identify the relevant tables: 'Tourist_Attractions', 'Visits', and 'Visitors'.", "Select the column to display, which is 'Name' from the 'Tourist_Attractions' table.", "Join the 'Tourist_Attractions' table with the 'Visits' table on the 'Tourist_Attraction_ID' to connect attractions with visits.", "Join the 'Visits' table with the 'Visitors' table on the 'Tourist_ID' to connect visits with specific visitors.", "Add a condition to filter the 'Tourist_Details' column in the 'Visitors' table using a placeholder for string values."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID JOIN VISITORS AS T3 ON T2.Tourist_ID  =  T3.Tourist_ID WHERE T3.Tourist_Details  =  'Vincent'", "source_tables": ["visits", "visitors", "tourist_attractions"], "description": "The virtual table lists the names of tourist attractions that have been visited by a specific visitor. It combines data from the 'Tourist_Attractions', 'Visits', and 'Visitors' tables, linking them through their respective identifiers. The placeholder in the WHERE clause is used to filter the results based on the visitor's details.", "virtual_table": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID JOIN VISITORS AS T3 ON T2.Tourist_ID  =  T3.Tourist_ID WHERE T3.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5942", "db_id": "cre_Theme_park", "question": "What are the details of the three most expensive hotels?", "rationale": ["Identify the relevant table, which is 'Hotels'.", "Select the column 'other_hotel_details' to display the details of the hotels.", "Order the results by 'price_range' in descending order to prioritize the most expensive hotels.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT 3", "source_tables": ["hotels"], "description": "The virtual table provides details of hotels from the 'Hotels' table, specifically focusing on the additional information about each hotel. The results are ordered by the price range in descending order, allowing users to identify the most expensive hotels. The placeholder in the LIMIT clause indicates the number of hotels to retrieve, which can be adjusted as needed.", "virtual_table": "SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5921", "db_id": "cre_Theme_park", "question": "What are the details and ways to get to tourist attractions related to royal family?", "rationale": ["Identify the relevant tables, which are 'Royal_Family' and 'Tourist_Attractions'.", "Select the columns to display: 'Royal_Family_Details' from the 'Royal_Family' table and 'How_to_Get_There' from the 'Tourist_Attractions' table.", "Establish a join between the two tables based on the unique identifier 'Royal_Family_ID' from 'Royal_Family' and 'Tourist_Attraction_ID' from 'Tourist_Attractions' to filter the results accordingly."], "gold_sql": "SELECT T1.Royal_Family_Details ,  T2.How_to_Get_There FROM ROYAL_FAMILY AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Royal_Family_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["royal_family", "tourist_attractions"], "description": "The virtual table provides details about tourist attractions associated with royal family entries, including specific information about the royal family and instructions on how to reach these attractions. The join condition links the royal family details to the corresponding tourist attractions using a unique identifier.", "virtual_table": "SELECT T1.Royal_Family_Details ,  T2.How_to_Get_There FROM ROYAL_FAMILY AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Royal_Family_ID  =  T2.Tourist_Attraction_ID"}
{"sample_id": "train.2363", "db_id": "csu_1", "question": "What campus started in year 1956, has more than 200 full time students, and more than 400 students enrolled?", "rationale": ["Identify the relevant tables, which are 'Campuses' and 'Enrollments'.", "Select the 'campus' column from the 'Campuses' table.", "Join the 'Campuses' table with the 'Enrollments' table on the campus identifier.", "Add conditions to filter by the specified year, total enrollment, and full-time equivalent enrollment using placeholders for numeric values."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN enrollments AS t2 ON t1.id  =  t2.campus WHERE t2.year  =  1956 AND totalenrollment_ay  >  400 AND FTE_AY  >  200", "source_tables": ["enrollments", "campuses"], "description": "The virtual table provides a list of campuses that were established in a specific year, along with their enrollment statistics. It filters campuses based on the year of establishment and checks for conditions on the total number of enrollments and full-time equivalent enrollments, using placeholders for the year and enrollment numbers.", "virtual_table": "SELECT T1.campus FROM campuses AS t1 JOIN enrollments AS t2 ON t1.id  =  t2.campus WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] AND totalenrollment_ay  >  [PLACEHOLDER-TYPE:NUMBER] AND FTE_AY  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2362", "db_id": "csu_1", "question": "What campus had more than 400 total enrollment but more than 200 full time enrollment in year 1956?", "rationale": ["Identify the relevant tables, which are 'Campuses' and 'Enrollments'.", "Select the 'Campus' column from the 'Campuses' table.", "Join the 'Campuses' table with the 'Enrollments' table on the campus identifier.", "Add conditions to filter the results based on the specified year and the enrollment thresholds using placeholders for numeric values."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN enrollments AS t2 ON t1.id  =  t2.campus WHERE t2.year  =  1956 AND totalenrollment_ay  >  400 AND FTE_AY  >  200", "source_tables": ["enrollments", "campuses"], "description": "The virtual table identifies campuses that had a total enrollment exceeding a specified number and a full-time equivalent enrollment also exceeding another specified number for a particular year. The placeholders in the WHERE clause represent the year, total enrollment threshold, and full-time equivalent enrollment threshold.", "virtual_table": "SELECT T1.campus FROM campuses AS t1 JOIN enrollments AS t2 ON t1.id  =  t2.campus WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] AND totalenrollment_ay  >  [PLACEHOLDER-TYPE:NUMBER] AND FTE_AY  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2335", "db_id": "csu_1", "question": "What campuses are located in Northridge, Los Angeles or in San Francisco, San Francisco?", "rationale": ["Identify the relevant table, which is 'Campuses'.", "Select the 'Campus' column to display the names of the campuses.", "Add conditions to filter the 'Location' and 'County' columns for the specified areas using placeholders for string values.", "Use a UNION to combine results from two different conditions for the two specified locations."], "gold_sql": "SELECT campus FROM campuses WHERE LOCATION  =  'Northridge' AND county  =  'Los Angeles' UNION SELECT campus FROM campuses WHERE LOCATION  =  'San Francisco' AND county  =  'San Francisco'", "source_tables": ["campuses"], "description": "The virtual table lists the names of campuses located in specific geographical areas, specifically Northridge, Los Angeles, and San Francisco, San Francisco. The placeholders in the WHERE clauses represent the locations and counties of the campuses being queried.", "virtual_table": "SELECT campus FROM campuses WHERE LOCATION  =  [PLACEHOLDER-TYPE:STRING] AND county  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT campus FROM campuses WHERE LOCATION  =  [PLACEHOLDER-TYPE:STRING] AND county  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2357", "db_id": "csu_1", "question": "how many degrees were conferred between 1998 and 2002?", "rationale": ["Identify the relevant tables, which are 'Campuses' and 'degrees'.", "Select the campus identifier and the sum of degrees awarded as the output.", "Join the 'Campuses' table with the 'degrees' table on the campus identifier.", "Add a condition to filter the years of degree conferral using placeholders for numeric values.", "Group the results by campus to get the total degrees conferred for each campus."], "gold_sql": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  1998 AND T2.year  <=  2002 GROUP BY T1.campus", "source_tables": ["degrees", "campuses"], "description": "The virtual table summarizes the total number of degrees conferred by each campus within a specified range of years. It combines data from the 'Campuses' table and the 'degrees' table, using the campus identifier to link the two. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.", "virtual_table": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.year  <=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus"}
{"sample_id": "train.2334", "db_id": "csu_1", "question": "Find the name of the campuses that is in Northridge, Los Angeles or in San Francisco, San Francisco.", "rationale": ["Identify the relevant table, which is 'Campuses'.", "Select the column to display, 'Campus'.", "Add conditions to filter the 'Location' and 'County' columns for the specified areas using placeholders for string values.", "Use a UNION to combine results from two different conditions for the specified locations."], "gold_sql": "SELECT campus FROM campuses WHERE LOCATION  =  'Northridge' AND county  =  'Los Angeles' UNION SELECT campus FROM campuses WHERE LOCATION  =  'San Francisco' AND county  =  'San Francisco'", "source_tables": ["campuses"], "description": "The virtual table provides the names of campuses located in specific geographical areas, specifically those situated in Northridge, Los Angeles, or in San Francisco, San Francisco. The placeholders in the WHERE clauses represent the location and county of the campuses being queried.", "virtual_table": "SELECT campus FROM campuses WHERE LOCATION  =  [PLACEHOLDER-TYPE:STRING] AND county  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT campus FROM campuses WHERE LOCATION  =  [PLACEHOLDER-TYPE:STRING] AND county  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2350", "db_id": "csu_1", "question": "Which campus has the most faculties in year 2003?", "rationale": ["Identify the relevant tables, which are 'Campuses' and 'faculty'.", "Select the 'campus' column from the 'Campuses' table.", "Join the 'Campuses' table with the 'faculty' table on the campus identifier.", "Add a condition to filter the results based on the specified year using a placeholder for numeric values.", "Order the results by the number of faculty members in descending order.", "Limit the results to return only the campus with the most faculty members."], "gold_sql": "SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  2003 ORDER BY T2.faculty DESC LIMIT 1", "source_tables": ["faculty", "campuses"], "description": "The virtual table provides information about campuses and their associated faculty counts for a specific year. It joins the 'Campuses' table with the 'faculty' table to filter campuses based on the year and sorts them by the number of faculty members in descending order. The placeholders represent the year of interest and the limit for the number of campuses to return.", "virtual_table": "SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY T2.faculty DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2351", "db_id": "csu_1", "question": "What campus has the most faculties in 2003?", "rationale": ["Identify the relevant tables, which are 'Campuses' and 'faculty'.", "Select the 'campus' column from the 'Campuses' table.", "Join the 'Campuses' table with the 'faculty' table on the campus identifier.", "Add a condition to filter the results for a specific year using a placeholder for numeric values.", "Order the results by the number of faculty members in descending order to find the campus with the most faculty.", "Limit the results to return only the top campus based on the faculty count."], "gold_sql": "SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  2003 ORDER BY T2.faculty DESC LIMIT 1", "source_tables": ["faculty", "campuses"], "description": "The virtual table provides information about campuses and their associated faculty counts for a specific year. It joins the 'Campuses' table with the 'faculty' table to identify which campus has the highest number of faculty members in a given year. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the year and the number of results to return.", "virtual_table": "SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY T2.faculty DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2349", "db_id": "csu_1", "question": "What campus has the most degrees  conferrred over its entire existence?", "rationale": ["Identify the relevant table, which is 'degrees'.", "Select the 'campus' column to display the campuses.", "Group the results by 'campus' to aggregate the degree counts.", "Order the results by the sum of degrees in descending order to find the campus with the most degrees conferred.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT campus FROM degrees GROUP BY campus ORDER BY sum(degrees) DESC LIMIT 1", "source_tables": ["degrees"], "description": "The virtual table summarizes the campuses and the total number of degrees conferred at each campus over the years. It groups the data by campus and orders the results in descending order based on the sum of degrees awarded, allowing for the identification of the campus with the highest total. The placeholder in the LIMIT clause indicates the number of top campuses to return.", "virtual_table": "SELECT campus FROM degrees GROUP BY campus ORDER BY sum(degrees) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2382", "db_id": "csu_1", "question": "How many faculty lines are there in the university that conferred the least number of degrees in year 2001?", "rationale": ["Identify the relevant tables: 'Campuses', 'faculty', and 'degrees'.", "Join the 'Campuses' table with the 'faculty' table on the campus identifier and the 'degrees' table on both the campus identifier and the year.", "Select the 'faculty' column from the 'faculty' table.", "Add a condition to filter the results by the specified year using a placeholder for numeric values.", "Order the results by the number of degrees awarded to find the campus with the least degrees.", "Limit the results to return only the faculty count for that campus."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2001 ORDER BY t3.degrees LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "description": "The virtual table provides information about the number of faculty members at universities that awarded the least number of degrees in a specific year. It combines data from the 'Campuses', 'faculty', and 'degrees' tables, using placeholders to filter by the year and limit the results to the campus with the fewest degrees awarded.", "virtual_table": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2385", "db_id": "csu_1", "question": "How many undergraduates are there at San Jose State", "rationale": ["Identify the relevant tables, which are 'discipline_enrollments' and 'Campuses'.", "Select the sum of the 'undergraduate' column to get the total number of undergraduate enrollments.", "Join the 'discipline_enrollments' table with the 'Campuses' table on the campus identifier.", "Add conditions to filter the results based on the specified year and campus name using placeholders."], "gold_sql": "SELECT sum(t1.undergraduate) FROM discipline_enrollments AS t1 JOIN campuses AS t2 ON t1.campus  =  t2.id WHERE t1.year  =  2004 AND t2.campus  =  'San Jose State University'", "source_tables": ["discipline_enrollments", "campuses"], "description": "The virtual table summarizes the total number of undergraduate enrollments from the 'discipline_enrollments' table for a specific campus and year. The placeholders in the query represent the year of enrollment data and the name of the campus.", "virtual_table": "SELECT sum(t1.undergraduate) FROM discipline_enrollments AS t1 JOIN campuses AS t2 ON t1.campus  =  t2.id WHERE t1.year  =  [PLACEHOLDER-TYPE:NUMBER] AND t2.campus  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2347", "db_id": "csu_1", "question": "In what year was the most degrees conferred?", "rationale": ["Identify the relevant table, which is 'degrees'.", "Select the 'Year' column to display.", "Group the results by 'Year' to aggregate the data.", "Order the results by the sum of degrees awarded in descending order to find the year with the most degrees conferred.", "Limit the results to a single entry using a placeholder for numeric values."], "gold_sql": "SELECT YEAR FROM degrees GROUP BY YEAR ORDER BY sum(degrees) DESC LIMIT 1", "source_tables": ["degrees"], "description": "The virtual table summarizes the years in which degrees were awarded, grouped by year, and ordered by the total number of degrees conferred in descending order. The placeholder indicates the limit on the number of years to return, allowing for the retrieval of the year with the highest number of degrees awarded.", "virtual_table": "SELECT YEAR FROM degrees GROUP BY YEAR ORDER BY sum(degrees) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2365", "db_id": "csu_1", "question": "How many campuses exist are in the county of LA?", "rationale": ["Identify the relevant table, which is 'Campuses'.", "Use the count function to determine the number of campuses.", "Add a condition to filter the 'county' column for the specified county using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM campuses WHERE county  =  'Los Angeles'", "source_tables": ["campuses"], "description": "The virtual table provides a count of campuses from the 'Campuses' table that are located in a specific county. The placeholder in the WHERE clause represents the name of the county being queried.", "virtual_table": "SELECT count(*) FROM campuses WHERE county  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2387", "db_id": "csu_1", "question": "How many people graduated from San Francisco State University in 2004?", "rationale": ["Identify the relevant tables, which are 'discipline_enrollments' for graduate data and 'Campuses' for campus information.", "Select the sum of graduate enrollments from 'discipline_enrollments'.", "Join 'discipline_enrollments' with 'Campuses' on the campus identifier to filter by campus name.", "Add conditions to filter the year of graduation and the specific campus using placeholders for numeric and string values."], "gold_sql": "SELECT sum(t1.graduate) FROM discipline_enrollments AS t1 JOIN campuses AS t2 ON t1.campus  =  t2.id WHERE t1.year  =  2004 AND t2.campus  =  'San Francisco State University'", "source_tables": ["discipline_enrollments", "campuses"], "description": "The virtual table summarizes the total number of graduate students who graduated from a specific campus in a given year. It combines data from the 'discipline_enrollments' table, which tracks graduate enrollments, and the 'Campuses' table, which provides information about the campus. The placeholders in the query represent the year of graduation and the name of the campus.", "virtual_table": "SELECT sum(t1.graduate) FROM discipline_enrollments AS t1 JOIN campuses AS t2 ON t1.campus  =  t2.id WHERE t1.year  =  [PLACEHOLDER-TYPE:NUMBER] AND t2.campus  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2376", "db_id": "csu_1", "question": "How many faculty lines are there in \"San Francisco State University\" in year 2004?", "rationale": ["Identify the relevant tables, which are 'faculty' and 'Campuses'.", "Select the column to display, 'faculty', which represents the number of faculty members.", "Join the 'faculty' table with the 'Campuses' table on the campus identifier to access campus names.", "Add conditions to filter the results based on the specified year and campus name using placeholders for numeric and string values."], "gold_sql": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  2004 AND T2.campus  =  'San Francisco State University'", "source_tables": ["faculty", "campuses"], "description": "The virtual table summarizes the number of faculty members at a specific campus for a given year. It combines data from the 'faculty' table and the 'Campuses' table, using a join to match the campus identifier with the campus name. The placeholders in the WHERE clause allow for filtering by the year and the campus name.", "virtual_table": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] AND T2.campus  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2369", "db_id": "csu_1", "question": "How many degrees were conferred at San Jose State University in 2000?", "rationale": ["Identify the relevant tables, which are 'Campuses' and 'degrees'.", "Join the two tables on the campus identifier to relate degrees to their respective campuses.", "Select the 'degrees' column to display the types of degrees conferred.", "Add conditions to filter the results based on the specified campus name and year using placeholders."], "gold_sql": "SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  'San Jose State University' AND t2.year  =  2000", "source_tables": ["degrees", "campuses"], "description": "The virtual table summarizes the types of degrees conferred at a specific campus during a particular year. It combines data from the 'Campuses' and 'degrees' tables, linking them through the campus identifier. The placeholders in the WHERE clause allow for specifying the campus name and the year of interest.", "virtual_table": "SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  [PLACEHOLDER-TYPE:STRING] AND t2.year  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2327", "db_id": "csu_1", "question": "What campuses are located in Chico?", "rationale": ["Identify the relevant table, which is 'Campuses'.", "Select the column to display, 'Campus'.", "Add a condition to filter the 'Location' column for the specified location using a placeholder for string values."], "gold_sql": "SELECT campus FROM campuses WHERE LOCATION  =  'Chico'", "source_tables": ["campuses"], "description": "The virtual table lists the names of campuses from the 'Campuses' table that are situated in a specific geographical location. The placeholder in the WHERE clause represents the location of the campus.", "virtual_table": "SELECT campus FROM campuses WHERE LOCATION  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6980", "db_id": "culture_company", "question": "Show all publishers which do not have a book in 1989.", "rationale": ["Identify the relevant table, which is 'book_club'.", "Select the 'publisher' column to display.", "Use the EXCEPT clause to filter out publishers that have books published in the specified year, using a placeholder for numeric values."], "gold_sql": "SELECT publisher FROM book_club EXCEPT SELECT publisher FROM book_club WHERE YEAR  =  1989", "source_tables": ["book_club"], "description": "The virtual table lists all publishers from the 'book_club' table that do not have any associated books published in a specific year. The placeholder in the query represents the year for which the absence of books is being checked.", "virtual_table": "SELECT publisher FROM book_club EXCEPT SELECT publisher FROM book_club WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6996", "db_id": "culture_company", "question": "Show the movie titles and book titles for all companies in China.", "rationale": ["Identify the relevant tables: 'movie', 'culture_company', and 'book_club'.", "Select the columns to display: 'title' from the 'movie' table and 'book_title' from the 'book_club' table.", "Join the 'movie' table with the 'culture_company' table using the 'movie_id' foreign key.", "Join the 'culture_company' table with the 'book_club' table using the 'book_club_id' foreign key.", "Add a condition to filter the 'incorporated_in' column for the specified year using a placeholder for string values."], "gold_sql": "SELECT T1.title ,  T3.book_title FROM movie AS T1 JOIN culture_company AS T2 ON T1.movie_id  =  T2.movie_id JOIN book_club AS T3 ON T3.book_club_id  =  T2.book_club_id WHERE T2.incorporated_in  =  'China'", "source_tables": ["culture_company", "movie", "book_club"], "description": "The virtual table displays the titles of movies and books associated with cultural companies that were incorporated in a specific year. The placeholders in the WHERE clause allow for filtering based on the year of incorporation of the companies.", "virtual_table": "SELECT T1.title ,  T3.book_title FROM movie AS T1 JOIN culture_company AS T2 ON T1.movie_id  =  T2.movie_id JOIN book_club AS T3 ON T3.book_club_id  =  T2.book_club_id WHERE T2.incorporated_in  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6991", "db_id": "culture_company", "question": "Which directors had a movie in either 1999 or 2000?", "rationale": ["Identify the relevant table, which is 'movie'.", "Select the column to display, 'director'.", "Add a condition to filter the 'Year' column for the specified years using placeholders for numeric values."], "gold_sql": "SELECT director FROM movie WHERE YEAR  =  1999 OR YEAR  =  2000", "source_tables": ["movie"], "description": "The virtual table lists the directors of movies from the 'movie' table that were released in specific years. The placeholders in the WHERE clause represent the years of interest, allowing for the selection of directors based on the specified release years.", "virtual_table": "SELECT director FROM movie WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER] OR YEAR  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6995", "db_id": "culture_company", "question": "What are all the company names that have a book published by Alyson?", "rationale": ["Identify the relevant tables, which are 'culture_company' and 'book_club'.", "Select the column to display, 'company_name' from 'culture_company'.", "Join the 'culture_company' table with the 'book_club' table on the 'book_club_id' to link companies with their respective book clubs.", "Add a condition to filter the 'publisher' column in the 'book_club' table for the specified publisher using a placeholder for string values."], "gold_sql": "SELECT T1.company_name FROM culture_company AS T1 JOIN book_club AS T2 ON T1.book_club_id  =  T2.book_club_id WHERE T2.publisher  =  'Alyson'", "source_tables": ["culture_company", "book_club"], "description": "The virtual table describes the names of cultural companies that are associated with book clubs where a specific publisher has published a book. The placeholder in the WHERE clause represents the name of the publisher.", "virtual_table": "SELECT T1.company_name FROM culture_company AS T1 JOIN book_club AS T2 ON T1.book_club_id  =  T2.book_club_id WHERE T2.publisher  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5772", "db_id": "customer_complaints", "question": "Which city has the least number of customers whose type code is \"Good Credit Rating\"?", "rationale": ["Identify the relevant table, which is 'Customers'.", "Select the 'town_city' column to display the cities.", "Add a condition to filter the 'customer_type_code' for the specified type using a placeholder for string values.", "Group the results by 'town_city' to count the number of customers in each city.", "Order the results by the count of customers in ascending order to find the city with the least number.", "Limit the results to one to get only the city with the least number of customers."], "gold_sql": "SELECT town_city FROM customers WHERE customer_type_code  =  'Good Credit Rating' GROUP BY town_city ORDER BY count(*) LIMIT 1", "source_tables": ["customers"], "description": "The virtual table summarizes the towns or cities from the 'Customers' table where customers with a specific type code reside. It groups the results by city and orders them by the count of customers in ascending order, allowing for the identification of the city with the least number of customers of that type. The placeholders represent the customer type code and the limit for the number of results returned.", "virtual_table": "SELECT town_city FROM customers WHERE customer_type_code  =  [PLACEHOLDER-TYPE:STRING] GROUP BY town_city ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5779", "db_id": "customer_complaints", "question": "Return the names of products that have had complaints filed by the customer who has filed the fewest complaints.", "rationale": ["Identify the relevant tables: 'Products', 'Complaints', and 'Customers'.", "Select the distinct column 'product_name' from the 'Products' table.", "Join the 'Products' table with the 'Complaints' table on the product identifier to filter products with complaints.", "Join the result with the 'Customers' table to access customer information.", "Group the results by 'customer_id' to count the number of complaints per customer.", "Order the results by the count of complaints to identify the customer with the fewest complaints.", "Use a placeholder in the LIMIT clause to specify how many product names to return."], "gold_sql": "SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "products", "customers"], "description": "The virtual table provides a list of distinct product names from the 'Products' table that have received complaints. It joins the 'Products' table with the 'Complaints' table based on the product identifier, and further joins with the 'Customers' table to identify the customer who has filed the fewest complaints. The placeholder in the LIMIT clause indicates the number of products to return based on the specified criteria.", "virtual_table": "SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5777", "db_id": "customer_complaints", "question": "What are the emails of customers who have filed complaints on the product which has had the greatest number of complaints?", "rationale": ["Identify the relevant tables, which are 'Customers' and 'Complaints'.", "Select the 'email_address' column from the 'Customers' table.", "Join the 'Customers' table with the 'Complaints' table using the customer_id as the linking key.", "Group the results by customer_id to count the number of complaints for each customer.", "Order the results by the count of complaints to find the product with the greatest number of complaints.", "Use a placeholder in the LIMIT clause to specify the maximum number of results to return."], "gold_sql": "SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "customers"], "description": "The virtual table provides the email addresses of customers from the 'Customers' table who have filed complaints related to a specific product. It joins the 'Customers' and 'Complaints' tables based on the customer identifier, groups the results by customer to count the number of complaints, and orders the results to identify the customers associated with the product that has received the highest number of complaints. The placeholder in the LIMIT clause indicates the maximum number of email addresses to return.", "virtual_table": "SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5776", "db_id": "customer_complaints", "question": "Find the emails of customers who has filed a complaints of the product with the most complaints.", "rationale": ["Identify the relevant tables, which are 'Customers' and 'Complaints'.", "Select the 'email_address' column from the 'Customers' table.", "Join the 'Customers' table with the 'Complaints' table on the 'customer_id' to link customers with their complaints.", "Group the results by 'customer_id' to aggregate the complaints for each customer.", "Order the results by the count of complaints to find the product with the most complaints.", "Use a placeholder in the LIMIT clause to specify how many top customers to return."], "gold_sql": "SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "customers"], "description": "The virtual table describes the email addresses of customers from the 'Customers' table who have filed complaints related to a specific product. The query joins the 'Customers' and 'Complaints' tables based on the customer ID, groups the results by customer ID, and orders them by the count of complaints to identify the product with the most complaints. The placeholder in the LIMIT clause represents the number of top customers to retrieve.", "virtual_table": "SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5810", "db_id": "customer_complaints", "question": "What is first names of the top 5 staff who have handled the greatest number of complaints?", "rationale": ["Identify the relevant tables, which are 'Staff' and 'Complaints'.", "Select the 'first_name' column from the 'Staff' table.", "Join the 'Staff' table with the 'Complaints' table using the 'staff_id' as the key.", "Group the results by 'staff_id' to aggregate the number of complaints handled by each staff member.", "Order the results by the count of complaints in descending order to find the top staff members.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT 5", "source_tables": ["complaints", "staff"], "description": "The virtual table provides the first names of staff members from the 'Staff' table who have managed the highest number of complaints. It joins the 'Staff' and 'Complaints' tables based on the staff identifier, groups the results by staff, and orders them by the count of complaints handled, limiting the results to a specified number.", "virtual_table": "SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5801", "db_id": "customer_complaints", "question": "Count the number of customers that have the customer type that is most common.", "rationale": ["Identify the relevant table, which is 'Customers'.", "Use the COUNT function to count the number of customers.", "Group the results by 'customer_type_code' to categorize the counts by customer type.", "Order the results in descending order based on the count to find the most common customer type.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT count(*) FROM customers GROUP BY customer_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers"], "description": "The virtual table provides a count of customers grouped by their customer type, allowing for the identification of the most common customer type. The placeholder in the LIMIT clause indicates the number of top results to return, which can be adjusted as needed.", "virtual_table": "SELECT count(*) FROM customers GROUP BY customer_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5802", "db_id": "customer_complaints", "question": "What is the last name of the staff who has handled the first ever complaint?", "rationale": ["Identify the relevant tables, which are 'Staff' and 'Complaints'.", "Join the 'Staff' table with the 'Complaints' table on the 'staff_id' to link staff members to the complaints they handled.", "Select the 'last_name' column from the 'Staff' table.", "Order the results by the 'date_complaint_raised' column from the 'Complaints' table to ensure the first complaint is at the top.", "Limit the results to one record to get the last name of the staff member who handled the first complaint."], "gold_sql": "SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id ORDER BY t2.date_complaint_raised LIMIT 1", "source_tables": ["complaints", "staff"], "description": "The virtual table describes the last names of staff members from the 'Staff' table who have handled complaints, specifically focusing on the first complaint raised. The placeholder in the LIMIT clause indicates the number of records to return, which in this case is set to one to retrieve the last name of the staff member associated with the earliest complaint.", "virtual_table": "SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id ORDER BY t2.date_complaint_raised LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5795", "db_id": "customer_complaints", "question": "What is the last name of the staff member in charge of the complaint on the product with the lowest price?", "rationale": ["Identify the relevant tables: 'Staff', 'Complaints', and 'Products'.", "Select the 'last_name' column from the 'Staff' table.", "Join the 'Complaints' table to link complaints to staff members using 'staff_id'.", "Join the 'Products' table to link complaints to products using 'product_id'.", "Order the results by 'product_price' to find the product with the lowest price.", "Use a placeholder to limit the number of results returned."], "gold_sql": "SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT 1", "source_tables": ["complaints", "products", "staff"], "description": "The virtual table describes the last names of staff members from the 'Staff' table who are responsible for handling complaints related to products. It joins the 'Complaints' table to associate each complaint with the corresponding staff member and the 'Products' table to access product details. The results are ordered by product price, allowing the identification of the staff member associated with the complaint on the product that has the lowest price, with a placeholder indicating the limit of results to return.", "virtual_table": "SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2857", "db_id": "customer_deliveries", "question": "List the state names and the number of customers living in each state.", "rationale": ["Identify the relevant tables, which are 'Customer_Addresses' and 'Addresses'.", "Join the two tables on the 'address_id' to connect customer addresses with their corresponding state information.", "Select the 'state_province_county' from the 'Addresses' table and count the number of customers from the 'Customer_Addresses' table.", "Group the results by 'state_province_county' to get the number of customers in each state."], "gold_sql": "SELECT t2.state_province_county ,  count(*) FROM customer_addresses AS t1 JOIN addresses AS t2 ON t1.address_id  =  t2.address_id GROUP BY t2.state_province_county", "source_tables": ["addresses", "customer_addresses"], "description": "The virtual table provides a summary of the state names along with the count of customers residing in each state. It combines data from the 'Customer_Addresses' and 'Addresses' tables, linking them through the address identifier. The result is grouped by the state, allowing for an aggregated count of customers per state.", "virtual_table": "SELECT t2.state_province_county ,  count(*) FROM customer_addresses AS t1 JOIN addresses AS t2 ON t1.address_id  =  t2.address_id GROUP BY t2.state_province_county"}
{"sample_id": "train.2848", "db_id": "customer_deliveries", "question": "Find the names of customers who are not living in the state of California.", "rationale": ["Identify the relevant table, which is 'Customers'.", "Select the column to display, 'customer_name'.", "Use an EXCEPT clause to exclude names of customers who live in a specific state.", "Join 'Customers' with 'Customer_Addresses' and 'Addresses' to access the state information for filtering."], "gold_sql": "SELECT customer_name FROM customers EXCEPT SELECT t1.customer_name FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id WHERE t3.state_province_county  =  'California'", "source_tables": ["addresses", "customers", "customer_addresses"], "description": "The virtual table presents the names of customers from the 'Customers' table who do not reside in a specified state. It utilizes an EXCEPT clause to exclude customers living in the state indicated by the placeholder. The query involves joining the 'Customers', 'Customer_Addresses', and 'Addresses' tables to filter out those in the specified state.", "virtual_table": "SELECT customer_name FROM customers EXCEPT SELECT t1.customer_name FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id WHERE t3.state_province_county  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2856", "db_id": "customer_deliveries", "question": "Find the name of route that has the highest number of deliveries.", "rationale": ["Identify the relevant tables, which are 'Delivery_Routes' and 'Delivery_Route_Locations'.", "Select the 'route_name' column from 'Delivery_Routes'.", "Join 'Delivery_Routes' with 'Delivery_Route_Locations' on the route identifier to associate routes with their delivery locations.", "Group the results by the route identifier to count the number of deliveries for each route.", "Order the results by the count of deliveries in descending order to find the route with the highest number of deliveries.", "Add a limit to specify how many routes to return using a placeholder for numeric values."], "gold_sql": "SELECT t1.route_name FROM Delivery_Routes AS t1 JOIN Delivery_Route_Locations AS t2 ON t1.route_id  =  t2.route_id GROUP BY t1.route_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["delivery_route_locations", "delivery_routes"], "description": "The virtual table provides the name of delivery routes from the 'Delivery_Routes' table that are associated with delivery locations. It groups the results by route identifier and orders them by the count of deliveries in descending order, allowing the user to specify a limit on the number of routes returned.", "virtual_table": "SELECT t1.route_name FROM Delivery_Routes AS t1 JOIN Delivery_Route_Locations AS t2 ON t1.route_id  =  t2.route_id GROUP BY t1.route_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2846", "db_id": "customer_deliveries", "question": "Show the details of all trucks in the order of their license number.", "rationale": ["Identify the relevant table, which is 'Trucks'.", "Select the column to display, 'truck_details'.", "Add an order clause to sort the results by 'truck_licence_number' in ascending order."], "gold_sql": "SELECT truck_details FROM trucks ORDER BY truck_licence_number", "source_tables": ["trucks"], "description": "The virtual table contains detailed information about trucks from the 'Trucks' table, specifically focusing on the truck details. The results are organized in ascending order based on the truck's license number, allowing for easy identification and comparison of the trucks.", "virtual_table": "SELECT truck_details FROM trucks ORDER BY truck_licence_number"}
{"sample_id": "train.6105", "db_id": "customers_and_addresses", "question": "Find the name and active date of the customer that use email as the contact channel.", "rationale": ["Identify the relevant tables, which are 'Customers' and 'Customer_Contact_Channels'.", "Select the columns to display, 'customer_name' from 'Customers' and 'active_from_date' from 'Customer_Contact_Channels'.", "Join the two tables on the 'customer_id' to link customers with their contact channels.", "Add a condition to filter the 'channel_code' column for the specified contact channel using a placeholder for string values."], "gold_sql": "SELECT t1.customer_name ,  t2.active_from_date FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t2.channel_code  =  'Email'", "source_tables": ["customer_contact_channels", "customers"], "description": "The virtual table describes the names of customers along with the dates when their email contact channels became active. The placeholder in the WHERE clause represents the specific contact channel code being queried.", "virtual_table": "SELECT t1.customer_name ,  t2.active_from_date FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t2.channel_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6131", "db_id": "customers_and_addresses", "question": "Find the name and ID of the product whose total order quantity is the largest.", "rationale": ["Identify the relevant tables, which are 'Order_Items' and 'Products'.", "Select the columns to display, 'product_details' and 'product_id'.", "Join the 'Order_Items' table with the 'Products' table on the product ID.", "Group the results by 'product_id' to aggregate the order quantities.", "Order the results by the sum of 'order_quantity' to find the product with the largest total order quantity.", "Use a placeholder in the LIMIT clause to specify the number of results to return."], "gold_sql": "SELECT t2.product_details ,  t2.product_id FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY sum(t1.order_quantity) LIMIT 1", "source_tables": ["products", "order_items"], "description": "The virtual table provides the product details and product ID from the 'Products' table, which are associated with the total order quantities from the 'Order_Items' table. The query groups the results by product ID and orders them by the sum of the order quantities, allowing for the identification of the product with the largest total order quantity. The placeholder in the LIMIT clause indicates the maximum number of results to return.", "virtual_table": "SELECT t2.product_details ,  t2.product_id FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY sum(t1.order_quantity) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6134", "db_id": "customers_and_addresses", "question": "What are all the addresses in East Julianaside, Texas or in Gleasonmouth, Arizona.", "rationale": ["Identify the relevant table, which is 'Addresses'.", "Select the column to display, 'address_content'.", "Add conditions to filter the 'city' and 'state_province_county' columns for the specified locations using placeholders for string values.", "Use a UNION to combine results from two different city and state combinations."], "gold_sql": "SELECT address_content FROM addresses WHERE city  =  'East Julianaside' AND state_province_county  =  'Texas' UNION SELECT address_content FROM addresses WHERE city  =  'Gleasonmouth' AND state_province_county  =  'Arizona'", "source_tables": ["addresses"], "description": "The virtual table contains the detailed descriptions of addresses from the 'Addresses' table that are located in specific cities and states. The placeholders in the WHERE clause represent the names of the cities and the corresponding states for which the addresses are being queried.", "virtual_table": "SELECT address_content FROM addresses WHERE city  =  [PLACEHOLDER-TYPE:STRING] AND state_province_county  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT address_content FROM addresses WHERE city  =  [PLACEHOLDER-TYPE:STRING] AND state_province_county  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6133", "db_id": "customers_and_addresses", "question": "Find all the addresses in East Julianaside, Texas or in Gleasonmouth, Arizona.", "rationale": ["Identify the relevant table, which is 'Addresses'.", "Select the column to display, 'address_content'.", "Add conditions to filter the 'city' and 'state_province_county' columns for the specified locations using placeholders for string values.", "Use a UNION to combine results from two different city and state combinations."], "gold_sql": "SELECT address_content FROM addresses WHERE city  =  'East Julianaside' AND state_province_county  =  'Texas' UNION SELECT address_content FROM addresses WHERE city  =  'Gleasonmouth' AND state_province_county  =  'Arizona'", "source_tables": ["addresses"], "description": "The virtual table provides a list of address details from the 'Addresses' table for specific cities and states. The placeholders in the WHERE clause represent the names of the cities and the corresponding state or province, allowing for the retrieval of addresses from two different locations.", "virtual_table": "SELECT address_content FROM addresses WHERE city  =  [PLACEHOLDER-TYPE:STRING] AND state_province_county  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT address_content FROM addresses WHERE city  =  [PLACEHOLDER-TYPE:STRING] AND state_province_county  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6085", "db_id": "customers_and_addresses", "question": "Which city has the most customers living in?", "rationale": ["Identify the relevant tables: 'Customers', 'Customer_Addresses', and 'Addresses'.", "Join the tables to connect customers with their respective addresses.", "Group the results by the 'city' column to aggregate customer counts per city.", "Order the results in descending order based on the count of customers in each city.", "Use a placeholder in the LIMIT clause to specify how many top cities to return."], "gold_sql": "SELECT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id GROUP BY t3.city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "customers", "customer_addresses"], "description": "The virtual table describes the cities associated with customers from the 'Customers' table, joined with their addresses from the 'Addresses' table through the 'Customer_Addresses' table. It groups the results by city and orders them by the number of customers residing in each city, allowing for the identification of the city with the highest customer count. The placeholder in the LIMIT clause represents the maximum number of results to return.", "virtual_table": "SELECT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id GROUP BY t3.city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6086", "db_id": "customers_and_addresses", "question": "Find the city where the most customers live.", "rationale": ["Identify the relevant tables: 'Customers', 'Customer_Addresses', and 'Addresses'.", "Join these tables on their respective foreign keys to link customers to their addresses.", "Select the 'city' column from the 'Addresses' table.", "Group the results by 'city' to aggregate customer counts per city.", "Order the results in descending order based on the count of customers in each city.", "Use a placeholder in the LIMIT clause to specify how many top cities to return."], "gold_sql": "SELECT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id GROUP BY t3.city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "customers", "customer_addresses"], "description": "The virtual table summarizes the cities associated with customers by joining the 'Customers', 'Customer_Addresses', and 'Addresses' tables. It groups the results by city and orders them based on the number of customers residing in each city, allowing for the identification of the city with the highest customer population. The placeholder in the LIMIT clause indicates the maximum number of cities to return.", "virtual_table": "SELECT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id GROUP BY t3.city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6075", "db_id": "customers_and_addresses", "question": "Find the detail of products whose detail contains the word \"Latte\" or the word \"Americano\"", "rationale": ["Identify the relevant table, which is 'Products'.", "Select the column to display, 'product_details'.", "Add conditions to filter the 'product_details' column for the specified keywords using placeholders for string values."], "gold_sql": "SELECT product_details FROM products WHERE product_details LIKE '%Latte%' OR product_details LIKE '%Americano%'", "source_tables": ["products"], "description": "The virtual table provides details of products from the 'Products' table that contain specific keywords in their descriptions. The placeholders in the WHERE clause represent the keywords to be searched for within the product details.", "virtual_table": "SELECT product_details FROM products WHERE product_details LIKE [PLACEHOLDER-TYPE:STRING] OR product_details LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6130", "db_id": "customers_and_addresses", "question": "What is the most frequently ordered product? Tell me the detail of the product", "rationale": ["Identify the relevant tables, which are 'Order_Items' and 'Products'.", "Join the 'Order_Items' table with the 'Products' table on the product_id to access product details.", "Group the results by product_id to count the number of orders for each product.", "Order the results by the count of orders in descending order to find the most frequently ordered product.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT t2.product_details FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["products", "order_items"], "description": "The virtual table provides details of products from the 'Products' table that have been ordered, specifically focusing on the most frequently ordered product. The query aggregates the order items to count the occurrences of each product and sorts them in descending order, allowing the user to retrieve the details of the top product based on the specified limit.", "virtual_table": "SELECT t2.product_details FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6102", "db_id": "customers_and_addresses", "question": "Compute the average active time span of contact channels.", "rationale": ["Identify the relevant table, which is 'Customer_Contact_Channels'.", "Select the average of the difference between 'active_to_date' and 'active_from_date' to compute the average active time span."], "gold_sql": "SELECT avg(active_to_date - active_from_date) FROM customer_contact_channels", "source_tables": ["customer_contact_channels"], "description": "The virtual table computes the average duration of active contact channels from the 'Customer_Contact_Channels' table. The calculation is based on the difference between the activation and deactivation dates of each contact channel.", "virtual_table": "SELECT avg(active_to_date - active_from_date) FROM customer_contact_channels"}
{"sample_id": "train.6071", "db_id": "customers_and_addresses", "question": "What are the details of all products?", "rationale": ["Identify the relevant table, which is 'Products'.", "Select the column to display, 'product_details'.", "Use DISTINCT to ensure that only unique product details are retrieved."], "gold_sql": "SELECT DISTINCT product_details FROM products", "source_tables": ["products"], "description": "The virtual table contains distinct product details from the 'Products' table, providing a summary of all available products without duplicates.", "virtual_table": "SELECT DISTINCT product_details FROM products"}
{"sample_id": "train.6100", "db_id": "customers_and_addresses", "question": "Return the the \"active to date\" of the latest contact channel used by the customer named \"Tillman Ernser\".", "rationale": ["Identify the relevant tables, which are 'Customers' and 'Customer_Contact_Channels'.", "Join the two tables on the 'customer_id' to link customers with their contact channels.", "Select the maximum 'active_to_date' from the 'Customer_Contact_Channels' table to find the latest date.", "Add a condition to filter the 'customer_name' column for the specified customer using a placeholder for string values."], "gold_sql": "SELECT max(t2.active_to_date) FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  'Tillman Ernser'", "source_tables": ["customer_contact_channels", "customers"], "description": "The virtual table provides the latest 'active to date' of contact channels associated with a specific customer from the 'Customers' and 'Customer_Contact_Channels' tables. The placeholder in the WHERE clause represents the customer's name.", "virtual_table": "SELECT max(t2.active_to_date) FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6127", "db_id": "customers_and_addresses", "question": "Who made the latest order?", "rationale": ["Identify the relevant tables, which are 'Customers' and 'Customer_Orders'.", "Select the 'customer_name' from the 'Customers' table.", "Join the 'Customers' table with the 'Customer_Orders' table using the 'customer_id' as the linking key.", "Order the results by 'order_date' in descending order to get the latest orders.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT t1.customer_name FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id ORDER BY t2.order_date DESC LIMIT 1", "source_tables": ["customer_orders", "customers"], "description": "The virtual table provides the names of customers who have placed orders, specifically focusing on the most recent order. It joins the 'Customers' table with the 'Customer_Orders' table based on the customer identifier, and orders the results by the order date in descending order, limiting the output to a specified number of entries.", "virtual_table": "SELECT t1.customer_name FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id ORDER BY t2.order_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6060", "db_id": "customers_and_addresses", "question": "Find the average order quantity per order.", "rationale": ["Identify the relevant table, which is 'Order_Items'.", "Select the column 'order_quantity' to calculate the average.", "Use the aggregate function 'avg' to compute the average order quantity."], "gold_sql": "SELECT avg(order_quantity) FROM order_items", "source_tables": ["order_items"], "description": "The virtual table calculates the average quantity of products ordered from the 'Order_Items' table. The result will provide insights into the typical order size across all orders.", "virtual_table": "SELECT avg(order_quantity) FROM order_items"}
{"sample_id": "train.1553", "db_id": "customers_and_invoices", "question": "Show the id, the account name, and other account details for all accounts by the customer with first name 'Meaghan'.", "rationale": ["Identify the relevant tables, which are 'Accounts' and 'Customers'.", "Select the columns to display: 'account_id', 'date_account_opened', 'account_name', and 'other_account_details' from the 'Accounts' table.", "Join the 'Accounts' table with the 'Customers' table on the 'customer_id' to link accounts to customers.", "Add a condition to filter the 'customer_first_name' column in the 'Customers' table using a placeholder for string values."], "gold_sql": "SELECT T1.account_id ,  T1.date_account_opened ,  T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  'Meaghan'", "source_tables": ["accounts", "customers"], "description": "The virtual table provides the account ID, the date the account was opened, the account name, and additional details for all accounts associated with a specific customer. The placeholder in the WHERE clause is used to filter the results based on the customer's first name.", "virtual_table": "SELECT T1.account_id ,  T1.date_account_opened ,  T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1610", "db_id": "customers_and_invoices", "question": "Return the order ids and details for orderes with two or more invoices.", "rationale": ["Identify the relevant tables, which are 'Invoices' and 'Orders'.", "Select the columns to display, 'order_id' and 'order_details' from the 'Orders' table.", "Join the 'Invoices' table with the 'Orders' table on the 'order_id' to link orders with their corresponding invoices.", "Group the results by 'order_id' to aggregate the invoices associated with each order.", "Add a condition in the HAVING clause to filter for orders that have more than a specified number of invoices using a placeholder for numeric values."], "gold_sql": "SELECT T2.order_id ,  T2.order_details FROM Invoices AS T1 JOIN Orders AS T2 ON T1.order_id  =  T2.order_id GROUP BY T2.order_id HAVING count(*)  >  2", "source_tables": ["orders", "invoices"], "description": "The virtual table provides the order IDs and details from the 'Orders' table for those orders that are associated with two or more invoices. The placeholder in the HAVING clause indicates the minimum number of invoices required for the orders to be included in the results.", "virtual_table": "SELECT T2.order_id ,  T2.order_details FROM Invoices AS T1 JOIN Orders AS T2 ON T1.order_id  =  T2.order_id GROUP BY T2.order_id HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1589", "db_id": "customers_and_invoices", "question": "Show the account name, id and the number of transactions for each account.", "rationale": ["Identify the relevant tables, which are 'Accounts' and 'Financial_Transactions'.", "Select the columns to display: 'account_name' from 'Accounts' and 'account_id' from 'Accounts', along with a count of transactions from 'Financial_Transactions'.", "Join the two tables on the 'account_id' to relate transactions to their respective accounts.", "Group the results by 'account_id' to aggregate the transaction counts for each account."], "gold_sql": "SELECT T2.account_name ,  T1.account_id ,  count(*) FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id GROUP BY T1.account_id", "source_tables": ["accounts", "financial_transactions"], "description": "The virtual table provides a summary of account names, account IDs, and the count of transactions associated with each account. It combines data from the 'Accounts' and 'Financial_Transactions' tables, linking them through the account ID. The count of transactions is aggregated for each account, allowing users to see how many transactions each account has processed.", "virtual_table": "SELECT T2.account_name ,  T1.account_id ,  count(*) FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id GROUP BY T1.account_id"}
{"sample_id": "train.1570", "db_id": "customers_and_invoices", "question": "What are the the full names and ids for all customers, and how many accounts does each have?", "rationale": ["Identify the relevant tables, which are 'Customers' and 'Accounts'.", "Select the columns to display: 'customer_id', 'customer_first_name', and 'customer_last_name' from the 'Customers' table, and count the number of accounts from the 'Accounts' table.", "Join the 'Accounts' table with the 'Customers' table on the 'customer_id' to associate each account with the corresponding customer.", "Group the results by 'customer_id' to aggregate the account counts for each customer."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id", "source_tables": ["accounts", "customers"], "description": "The virtual table provides a summary of customers along with their unique identifiers and the count of accounts associated with each customer. It combines data from the 'Customers' and 'Accounts' tables, linking them through the customer ID. The result includes the customer ID, first name, last name, and the total number of accounts for each customer.", "virtual_table": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id"}
{"sample_id": "train.1602", "db_id": "customers_and_invoices", "question": "What is the invoice number and invoice date corresponding to the invoice with the greatest number of transactions?", "rationale": ["Identify the relevant tables, which are 'Financial_Transactions' and 'Invoices'.", "Join the two tables on the invoice number to correlate transactions with their respective invoices.", "Group the results by invoice number to count the number of transactions for each invoice.", "Order the results in descending order based on the count of transactions to find the invoice with the greatest number of transactions.", "Limit the results to a single entry using a placeholder for numeric values."], "gold_sql": "SELECT T2.invoice_number ,  T2.invoice_date FROM Financial_transactions AS T1 JOIN Invoices AS T2 ON T1.invoice_number  =  T2.invoice_number GROUP BY T1.invoice_number ORDER BY count(*) DESC LIMIT 1", "source_tables": ["invoices", "financial_transactions"], "description": "The virtual table provides the invoice number and invoice date from the 'Invoices' table, corresponding to the invoice that has the highest number of associated financial transactions. The placeholder in the LIMIT clause indicates the maximum number of transactions to consider for the result.", "virtual_table": "SELECT T2.invoice_number ,  T2.invoice_date FROM Financial_transactions AS T1 JOIN Invoices AS T2 ON T1.invoice_number  =  T2.invoice_number GROUP BY T1.invoice_number ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1621", "db_id": "customers_and_invoices", "question": "Show all product names and the number of customers having an order on each product.", "rationale": ["Identify the relevant tables: 'Order_Items', 'Products', and 'Orders'.", "Select the 'product_name' from the 'Products' table and count the number of customers from the 'Order_Items' table.", "Join 'Order_Items' with 'Products' on 'product_id' to get product details, and join with 'Orders' on 'order_id' to ensure the orders are counted correctly.", "Group the results by 'product_name' to aggregate the count of customers for each product."], "gold_sql": "SELECT T2.product_name ,  count(*) FROM Order_items AS T1 JOIN Products AS T2 ON T1.product_id  =  T2.product_id JOIN Orders AS T3 ON T3.order_id  =  T1.order_id GROUP BY T2.product_name", "source_tables": ["orders", "products", "order_items"], "description": "The virtual table displays the names of products along with the count of customers who have placed orders for each product. It combines data from the 'Order_Items', 'Products', and 'Orders' tables, using joins to connect the relevant identifiers. The result is grouped by product name to provide a summary of customer orders for each product.", "virtual_table": "SELECT T2.product_name ,  count(*) FROM Order_items AS T1 JOIN Products AS T2 ON T1.product_id  =  T2.product_id JOIN Orders AS T3 ON T3.order_id  =  T1.order_id GROUP BY T2.product_name"}
{"sample_id": "train.1599", "db_id": "customers_and_invoices", "question": "Show the invoice number and the number of transactions for each invoice.", "rationale": ["Identify the relevant table, which is 'Financial_Transactions'.", "Select the 'invoice_number' column and use the COUNT function to count the number of transactions.", "Group the results by 'invoice_number' to aggregate the transaction counts for each invoice."], "gold_sql": "SELECT invoice_number ,  count(*) FROM Financial_transactions GROUP BY invoice_number", "source_tables": ["financial_transactions"], "description": "The virtual table provides a summary of invoice numbers along with the count of transactions associated with each invoice from the 'Financial_Transactions' table. The grouping by invoice number allows for the aggregation of transaction counts for each unique invoice.", "virtual_table": "SELECT invoice_number ,  count(*) FROM Financial_transactions GROUP BY invoice_number"}
{"sample_id": "train.1617", "db_id": "customers_and_invoices", "question": "Show the order ids and the number of items in each order.", "rationale": ["Identify the relevant table, which is 'Order_Items'.", "Select the 'order_id' column and use the COUNT function to count the number of items for each order.", "Group the results by 'order_id' to aggregate the counts for each unique order."], "gold_sql": "SELECT order_id ,  count(*) FROM Order_items GROUP BY order_id", "source_tables": ["order_items"], "description": "The virtual table displays the order IDs along with the count of items associated with each order from the 'Order_Items' table. The grouping by 'order_id' allows for aggregation of the number of items per order, providing a summary of item quantities for each unique order.", "virtual_table": "SELECT order_id ,  count(*) FROM Order_items GROUP BY order_id"}
{"sample_id": "train.1580", "db_id": "customers_and_invoices", "question": "Count the number of financial transactions that correspond to each account id.", "rationale": ["Identify the relevant table, which is 'Financial_Transactions'.", "Select the count of transactions and group them by 'account_id'.", "Use a placeholder to represent the account identifier in the output."], "gold_sql": "SELECT count(*) ,  account_id FROM Financial_transactions", "source_tables": ["financial_transactions"], "description": "The virtual table summarizes the count of financial transactions associated with each account from the 'Financial_Transactions' table. The placeholder in the SELECT statement represents the account identifier, allowing for the aggregation of transaction counts per account.", "virtual_table": "SELECT count(*) ,  account_id FROM Financial_transactions"}
{"sample_id": "train.1549", "db_id": "customers_and_invoices", "question": "How many customers have opened an account?", "rationale": ["Identify the relevant table, which is 'Accounts'.", "Use the COUNT function to count the number of distinct 'customer_id' entries.", "The query focuses on counting unique customers who have opened accounts, hence the use of DISTINCT."], "gold_sql": "SELECT count(DISTINCT customer_id) FROM Accounts", "source_tables": ["accounts"], "description": "The virtual table provides a count of unique customers who have opened accounts from the 'Accounts' table. The query uses a placeholder to represent the distinct customer identifier, ensuring that only unique customers are counted.", "virtual_table": "SELECT count(DISTINCT customer_id) FROM Accounts"}
{"sample_id": "train.727", "db_id": "customers_card_transactions", "question": "Show the customer ids and firstname without a credit card.", "rationale": ["Identify the relevant tables, which are 'Customers' and 'Customers_Cards'.", "Select the columns to display, 'customer_id' and 'customer_first_name'.", "Use the EXCEPT clause to exclude customers who have a credit card by joining the two tables on 'customer_id' and filtering by 'card_type_code' using a placeholder for string values."], "gold_sql": "SELECT customer_id ,  customer_first_name FROM Customers EXCEPT SELECT T1.customer_id ,  T2.customer_first_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE card_type_code  =  'Credit'", "source_tables": ["customers", "customers_cards"], "description": "The virtual table provides a list of customer IDs and their first names from the 'Customers' table, excluding those who have a credit card. The placeholder in the query represents the type of card that is being filtered out.", "virtual_table": "SELECT customer_id ,  customer_first_name FROM Customers EXCEPT SELECT T1.customer_id ,  T2.customer_first_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE card_type_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.718", "db_id": "customers_card_transactions", "question": "Return the id and full name of the customer who has the fewest accounts.", "rationale": ["Identify the relevant tables, which are 'Customers' and 'Customers_Cards'.", "Select the columns to display: 'customer_id', 'customer_first_name', and 'customer_last_name'.", "Join the 'Customers' table with the 'Customers_Cards' table on 'customer_id'.", "Group the results by 'customer_id' to aggregate the account counts.", "Order the results by the count of accounts in ascending order to find the customer with the fewest accounts.", "Use a placeholder to limit the results to the top entry."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) ASC LIMIT 1", "source_tables": ["customers", "customers_cards"], "description": "The virtual table provides the customer ID and full name (first and last name) of customers from the 'Customers' table who are linked to the fewest accounts. The query joins the 'Customers' and 'Customers_Cards' tables, groups the results by customer ID, and orders them in ascending order based on the count of accounts associated with each customer. A placeholder is used to limit the results to the customer with the fewest accounts.", "virtual_table": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.728", "db_id": "customers_card_transactions", "question": "What are the ids and first names of customers who do not hold a credit card?", "rationale": ["Identify the relevant tables, which are 'Customers' and 'Customers_Cards'.", "Select the columns to display, 'customer_id' and 'customer_first_name' from the 'Customers' table.", "Use an EXCEPT clause to filter out customers who hold a credit card by joining 'Customers_Cards' with 'Customers' on 'customer_id' and applying a condition for the card type code using a placeholder."], "gold_sql": "SELECT customer_id ,  customer_first_name FROM Customers EXCEPT SELECT T1.customer_id ,  T2.customer_first_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE card_type_code  =  'Credit'", "source_tables": ["customers", "customers_cards"], "description": "The virtual table provides the unique identifiers and first names of customers from the 'Customers' table who do not possess a credit card. The query uses an EXCEPT clause to exclude customers who have a card of a specific type, represented by a placeholder for the card type code.", "virtual_table": "SELECT customer_id ,  customer_first_name FROM Customers EXCEPT SELECT T1.customer_id ,  T2.customer_first_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE card_type_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.716", "db_id": "customers_card_transactions", "question": "What are the ids and full names of customers who hold two or more cards?", "rationale": ["Identify the relevant tables, which are 'Customers_cards' and 'Customers'.", "Select the columns to display: 'customer_id', 'customer_first_name', and 'customer_last_name'.", "Join the 'Customers_cards' table with the 'Customers' table on the 'customer_id' to link cardholders with their details.", "Group the results by 'customer_id' to aggregate the number of cards held by each customer.", "Add a condition in the HAVING clause to filter customers who hold two or more cards using a placeholder for numeric values."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id HAVING count(*)  >=  2", "source_tables": ["customers", "customers_cards"], "description": "The virtual table provides the customer IDs along with their first and last names from the 'Customers' table for those customers who hold two or more cards. The placeholder in the HAVING clause indicates the minimum number of cards a customer must have to be included in the results.", "virtual_table": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.743", "db_id": "customers_card_transactions", "question": "What is the transaction type that has processed the greatest total amount in transactions?", "rationale": ["Identify the relevant table, which is 'Financial_Transactions'.", "Select the 'transaction_type' column to display.", "Group the results by 'transaction_type' to aggregate the transaction amounts.", "Order the results by the sum of 'transaction_amount' in descending order to find the greatest total.", "Limit the output to a single result using a placeholder for numeric values."], "gold_sql": "SELECT transaction_type FROM Financial_transactions GROUP BY transaction_type ORDER BY sum(transaction_amount) DESC LIMIT 1", "source_tables": ["financial_transactions"], "description": "The virtual table summarizes the transaction types from the 'Financial_Transactions' table, grouping them to calculate the total amount for each type. The result is ordered in descending order based on the summed transaction amounts, with a placeholder to limit the output to the top result.", "virtual_table": "SELECT transaction_type FROM Financial_transactions GROUP BY transaction_type ORDER BY sum(transaction_amount) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.722", "db_id": "customers_card_transactions", "question": "Return the code of the card type that is most common.", "rationale": ["Identify the relevant table, which is 'Customers_Cards'.", "Select the column to display, 'card_type_code'.", "Group the results by 'card_type_code' to count occurrences.", "Order the results in descending order based on the count of each card type.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT card_type_code FROM Customers_cards GROUP BY card_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers_cards"], "description": "The virtual table summarizes the card type codes from the 'Customers_Cards' table, grouping them to identify the most frequently occurring type. The placeholder in the LIMIT clause indicates the number of top results to return, allowing for flexibility in specifying how many of the most common card types to retrieve.", "virtual_table": "SELECT card_type_code FROM Customers_cards GROUP BY card_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.745", "db_id": "customers_card_transactions", "question": "Show the account id and the number of transactions for each account", "rationale": ["Identify the relevant table, which is 'Financial_Transactions'.", "Select the 'account_id' column and use the count function to calculate the number of transactions for each account.", "Group the results by 'account_id' to ensure that the count is specific to each account."], "gold_sql": "SELECT account_id ,  count(*) FROM Financial_transactions GROUP BY account_id", "source_tables": ["financial_transactions"], "description": "The virtual table summarizes the account IDs along with the count of transactions associated with each account from the 'Financial_Transactions' table. The grouping by account ID allows for the aggregation of transaction counts for each unique account.", "virtual_table": "SELECT account_id ,  count(*) FROM Financial_transactions GROUP BY account_id"}
{"sample_id": "train.694", "db_id": "customers_card_transactions", "question": "What are the ids, full names, and phones of each customer?", "rationale": ["Identify the relevant table, which is 'Customers'.", "Select the columns to display: 'customer_id', 'customer_first_name', 'customer_last_name', and 'customer_phone'.", "No additional filtering conditions are needed, as the query retrieves all customers' information."], "gold_sql": "SELECT customer_id ,  customer_first_name ,  customer_last_name ,  customer_phone FROM Customers", "source_tables": ["customers"], "description": "The virtual table provides the unique identifiers, full names, and phone numbers of customers from the 'Customers' table. The placeholders represent the specific values for customer identification and contact information.", "virtual_table": "SELECT customer_id ,  customer_first_name ,  customer_last_name ,  customer_phone FROM Customers"}
{"sample_id": "train.688", "db_id": "customers_card_transactions", "question": "What are the full names of customers who have accounts?", "rationale": ["Identify the relevant tables, which are 'Customers' and 'Accounts'.", "Select the columns to display, which are 'customer_first_name' and 'customer_last_name'.", "Use a JOIN operation to link the 'Customers' table with the 'Accounts' table based on the 'customer_id' to filter customers who have accounts."], "gold_sql": "SELECT DISTINCT T1.customer_first_name ,  T1.customer_last_name FROM Customers AS T1 JOIN Accounts AS T2 ON T1.customer_id  =  T2.customer_id", "source_tables": ["accounts", "customers"], "description": "The virtual table provides the distinct first and last names of customers from the 'Customers' table who are linked to accounts in the 'Accounts' table. The join condition ensures that only customers with existing accounts are included in the results.", "virtual_table": "SELECT DISTINCT T1.customer_first_name ,  T1.customer_last_name FROM Customers AS T1 JOIN Accounts AS T2 ON T1.customer_id  =  T2.customer_id"}
{"sample_id": "train.729", "db_id": "customers_card_transactions", "question": "Show all card type codes.", "rationale": ["Identify the relevant table, which is 'Customers_Cards'.", "Select the column to display, 'card_type_code'.", "Use the DISTINCT keyword to ensure that only unique card type codes are returned."], "gold_sql": "SELECT DISTINCT card_type_code FROM Customers_Cards", "source_tables": ["customers_cards"], "description": "The virtual table displays the distinct card type codes from the 'Customers_Cards' table. This allows users to see all unique types of cards available without duplicates.", "virtual_table": "SELECT DISTINCT card_type_code FROM Customers_Cards"}
{"sample_id": "train.4762", "db_id": "department_store", "question": "What are the names of staff who have been assigned multiple jobs?", "rationale": ["Identify the relevant tables, which are 'Staff' and 'Staff_Department_Assignments'.", "Select the column to display, 'staff_name' from the 'Staff' table.", "Join the 'Staff' table with the 'Staff_Department_Assignments' table on 'staff_id' to link staff members with their job assignments.", "Group the results by 'staff_id' to aggregate the assignments for each staff member.", "Add a condition to filter for staff members who have more than a specified number of job assignments using a placeholder for numeric values."], "gold_sql": "SELECT T1.staff_name FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id GROUP BY T2.staff_id HAVING COUNT (*)  >  1", "source_tables": ["staff_department_assignments", "staff"], "description": "The virtual table provides the names of staff members from the 'Staff' table who have been assigned to multiple jobs. It joins the 'Staff' table with the 'Staff_Department_Assignments' table to correlate staff members with their job assignments. The results are grouped by staff ID, and a condition is applied to filter for those with more than a specified number of assignments, represented by a placeholder for numeric values.", "virtual_table": "SELECT T1.staff_name FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id GROUP BY T2.staff_id HAVING COUNT (*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4792", "db_id": "department_store", "question": "What are the ids and names of customers with addressed that contain WY and who do not use a credit card for payment?", "rationale": ["Identify the relevant table, which is 'Customers'.", "Select the columns to display, 'customer_id' and 'customer_name'.", "Add conditions to filter the 'customer_address' for a specific substring using a placeholder for string values and to exclude a specific payment method using another placeholder for string values."], "gold_sql": "SELECT customer_id ,  customer_name FROM customers WHERE customer_address LIKE '%WY%' AND payment_method_code != 'Credit Card'", "source_tables": ["customers"], "description": "The virtual table provides the unique identifiers and names of customers from the 'Customers' table who have addresses containing a specific substring and do not use a particular payment method. The placeholders in the WHERE clause allow for filtering based on the address and payment method criteria.", "virtual_table": "SELECT customer_id ,  customer_name FROM customers WHERE customer_address LIKE [PLACEHOLDER-TYPE:STRING] AND payment_method_code != [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4740", "db_id": "department_store", "question": "What are the ids and names of department stores with both marketing and managing departments?", "rationale": ["Identify the relevant tables, which are 'departments' and 'department_stores'.", "Select the columns to display, 'dept_store_id' and 'store_name'.", "Use JOIN to connect the two tables based on the 'dept_store_id'.", "Filter the results to include only those department stores that have both specified department names using INTERSECT and placeholders for the department names."], "gold_sql": "SELECT T2.dept_store_id ,  T2.store_name FROM departments AS T1 JOIN department_stores AS T2 ON T1.dept_store_id  =  T2.dept_store_id WHERE T1.department_name  =  'marketing' INTERSECT SELECT T2.dept_store_id ,  T2.store_name FROM departments AS T1 JOIN department_stores AS T2 ON T1.dept_store_id  =  T2.dept_store_id WHERE T1.department_name  =  'managing'", "source_tables": ["departments", "department_stores"], "description": "The virtual table provides the identifiers and names of department stores that have both marketing and managing departments. It combines data from the 'departments' and 'department_stores' tables, ensuring that only stores with the specified departments are included. The placeholders in the query represent the names of the departments being searched for.", "virtual_table": "SELECT T2.dept_store_id ,  T2.store_name FROM departments AS T1 JOIN department_stores AS T2 ON T1.dept_store_id  =  T2.dept_store_id WHERE T1.department_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.dept_store_id ,  T2.store_name FROM departments AS T1 JOIN department_stores AS T2 ON T1.dept_store_id  =  T2.dept_store_id WHERE T1.department_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4791", "db_id": "department_store", "question": "Find the id and name of customers whose address contains WY state and do not use credit card for payment.", "rationale": ["Identify the relevant table, which is 'Customers'.", "Select the columns to display, 'customer_id' and 'customer_name'.", "Add conditions to filter the 'customer_address' for a specific state using a placeholder for string values and to exclude a specific payment method using another placeholder for string values."], "gold_sql": "SELECT customer_id ,  customer_name FROM customers WHERE customer_address LIKE '%WY%' AND payment_method_code != 'Credit Card'", "source_tables": ["customers"], "description": "The virtual table describes the unique identifiers and names of customers from the 'Customers' table who have an address containing a specific state and do not use a specific payment method. The placeholders in the WHERE clause represent the state in the address and the payment method code.", "virtual_table": "SELECT customer_id ,  customer_name FROM customers WHERE customer_address LIKE [PLACEHOLDER-TYPE:STRING] AND payment_method_code != [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4758", "db_id": "department_store", "question": "Return the names and ids of customers who have TN in their address.", "rationale": ["Identify the relevant table, which is 'Customers'.", "Select the columns to display, 'customer_name' and 'customer_id'.", "Add a condition to filter the 'customer_address' column using a LIKE clause with a placeholder for string values."], "gold_sql": "SELECT customer_name ,  customer_id FROM customers WHERE customer_address LIKE '%TN%'", "source_tables": ["customers"], "description": "The virtual table provides the names and unique identifiers of customers from the 'Customers' table whose addresses contain a specific substring. The placeholder in the WHERE clause allows for filtering based on the address criteria.", "virtual_table": "SELECT customer_name ,  customer_id FROM customers WHERE customer_address LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4756", "db_id": "department_store", "question": "Return the id of the staff whose Staff Department Assignment was earlier than that of any Clerical Staff.", "rationale": ["Identify the relevant table, which is 'Staff_Department_Assignments'.", "Select the column to display, 'staff_id'.", "Add a condition to filter the 'date_assigned_to' column to be less than the maximum 'date_assigned_to' from a subquery.", "The subquery selects the maximum assignment end date for staff members with a specific job title, using a placeholder for the job title code."], "gold_sql": "SELECT staff_id FROM Staff_Department_Assignments WHERE date_assigned_to  <  (SELECT max(date_assigned_to) FROM Staff_Department_Assignments WHERE job_title_code  =  'Clerical Staff')", "source_tables": ["staff_department_assignments"], "description": "The virtual table provides the unique identifiers of staff members from the 'Staff_Department_Assignments' table whose assignment end date is earlier than the latest assignment end date of any staff member with a specific job title. The placeholder in the subquery represents the job title code for Clerical Staff.", "virtual_table": "SELECT staff_id FROM Staff_Department_Assignments WHERE date_assigned_to  <  (SELECT max(date_assigned_to) FROM Staff_Department_Assignments WHERE job_title_code  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.4717", "db_id": "department_store", "question": "What are the staff ids and genders of all staffs whose job title is Department Manager?", "rationale": ["Identify the relevant tables, which are 'Staff' and 'Staff_Department_Assignments'.", "Select the columns to display, 'staff_id' and 'staff_gender' from the 'Staff' table.", "Join the 'Staff' table with the 'Staff_Department_Assignments' table on the 'staff_id' column to associate staff members with their job titles.", "Add a condition to filter the 'job_title_code' column for the specified job title using a placeholder for string values."], "gold_sql": "SELECT T1.staff_id ,  T1.staff_gender FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.job_title_code  =  'Department Manager'", "source_tables": ["staff_department_assignments", "staff"], "description": "The virtual table provides the staff IDs and genders of staff members from the 'Staff' table who hold a specific job title. The join with the 'Staff_Department_Assignments' table allows for filtering based on the job title, represented by a placeholder for string values.", "virtual_table": "SELECT T1.staff_id ,  T1.staff_gender FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.job_title_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4759", "db_id": "department_store", "question": "Return the name and gender of the staff who was assigned in 2016.", "rationale": ["Identify the relevant tables, which are 'Staff' and 'Staff_Department_Assignments'.", "Select the columns to display, 'staff_name' and 'staff_gender'.", "Join the 'Staff' table with 'Staff_Department_Assignments' on the 'staff_id' to link staff members with their assignments.", "Add a condition to filter the 'date_assigned_from' column for the specified year using a placeholder for string values."], "gold_sql": "SELECT T1.staff_name ,  T1.staff_gender FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.date_assigned_from LIKE '2016%'", "source_tables": ["staff_department_assignments", "staff"], "description": "The virtual table provides the names and genders of staff members from the 'Staff' table who were assigned to a department during a specific time period in 2016. The placeholder in the WHERE clause allows for filtering based on the assignment date.", "virtual_table": "SELECT T1.staff_name ,  T1.staff_gender FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.date_assigned_from LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4794", "db_id": "department_store", "question": "What is the average price of clothes?", "rationale": ["Identify the relevant table, which is 'Products'.", "Select the column to calculate the average, 'product_price'.", "Add a condition to filter the 'product_type_code' column for the specified clothing type using a placeholder for string values."], "gold_sql": "SELECT avg(product_price) FROM products WHERE product_type_code  =  'Clothes'", "source_tables": ["products"], "description": "The virtual table calculates the average price of products from the 'Products' table, specifically filtering for those that belong to a certain type of clothing. The placeholder in the WHERE clause represents the product type code for the clothing category.", "virtual_table": "SELECT avg(product_price) FROM products WHERE product_type_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4750", "db_id": "department_store", "question": "What is the id and name of the staff who has been assigned for the least amount of time?", "rationale": ["Identify the relevant tables, which are 'Staff' and 'Staff_Department_Assignments'.", "Select the columns to display, 'staff_id' and 'staff_name'.", "Join the 'Staff' table with 'Staff_Department_Assignments' on the staff ID to correlate staff members with their assignments.", "Order the results by the difference between 'date_assigned_to' and 'date_assigned_from' to find the least amount of time assigned.", "Use a placeholder in the LIMIT clause to specify how many records to return."], "gold_sql": "SELECT T1.staff_id ,  T1.staff_name FROM staff AS T1 JOIN Staff_Department_Assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY date_assigned_to - date_assigned_from LIMIT 1", "source_tables": ["staff_department_assignments", "staff"], "description": "The virtual table provides the staff ID and name of staff members from the 'Staff' table who are assigned to departments, ordered by the duration of their assignments. The placeholder in the LIMIT clause indicates the number of records to return, representing the staff member with the least amount of assignment time.", "virtual_table": "SELECT T1.staff_id ,  T1.staff_name FROM staff AS T1 JOIN Staff_Department_Assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY date_assigned_to - date_assigned_from LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4730", "db_id": "department_store", "question": "Return the name and job title of the staff with the latest date assigned.", "rationale": ["Identify the relevant tables, which are 'Staff' and 'Staff_Department_Assignments'.", "Select the columns to display, 'staff_name' from the 'Staff' table and 'job_title_code' from the 'Staff_Department_Assignments' table.", "Join the two tables on the 'staff_id' to associate staff members with their department assignments.", "Order the results by 'date_assigned_to' in descending order to get the latest assignments first.", "Add a limit to the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT T1.staff_name ,  T2.job_title_code FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY T2.date_assigned_to DESC LIMIT 1", "source_tables": ["staff_department_assignments", "staff"], "description": "The virtual table provides the names and job titles of staff members from the 'Staff' table, joined with their department assignments from the 'Staff_Department_Assignments' table. The results are ordered by the date of assignment, allowing for the retrieval of the most recently assigned staff members, with a placeholder to limit the number of results returned.", "virtual_table": "SELECT T1.staff_name ,  T2.job_title_code FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY T2.date_assigned_to DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4729", "db_id": "department_store", "question": "What is the name and job title of the staff who was assigned the latest?", "rationale": ["Identify the relevant tables, which are 'Staff' and 'Staff_Department_Assignments'.", "Select the columns to display, 'staff_name' from the 'Staff' table and 'job_title_code' from the 'Staff_Department_Assignments' table.", "Join the two tables on the 'staff_id' to associate staff members with their department assignments.", "Order the results by 'date_assigned_to' in descending order to get the latest assignments first.", "Use a placeholder in the LIMIT clause to specify how many records to return."], "gold_sql": "SELECT T1.staff_name ,  T2.job_title_code FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY T2.date_assigned_to DESC LIMIT 1", "source_tables": ["staff_department_assignments", "staff"], "description": "The virtual table provides the names and job titles of staff members from the 'Staff' table who have been assigned to departments, sorted by the most recent assignment date. The placeholder in the LIMIT clause indicates the number of records to return, allowing for flexibility in the query results.", "virtual_table": "SELECT T1.staff_name ,  T2.job_title_code FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY T2.date_assigned_to DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4522", "db_id": "document_management", "question": "What are the usernames and passwords of users that have the most common role?", "rationale": ["Identify the relevant table, which is 'Users'.", "Select the columns to display, 'user_name' and 'password'.", "Group the results by 'role_code' to aggregate users by their roles.", "Order the results by the count of users in each role in descending order to find the most common role.", "Use a placeholder in the LIMIT clause to specify how many results to return."], "gold_sql": "SELECT user_name ,  password FROM users GROUP BY role_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["users"], "description": "The virtual table provides the usernames and passwords of users from the 'Users' table, grouped by their role. It orders the results by the frequency of each role, allowing the retrieval of the most common role's users. The placeholder in the LIMIT clause indicates the maximum number of results to return.", "virtual_table": "SELECT user_name ,  password FROM users GROUP BY role_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4503", "db_id": "document_management", "question": "Find the types of documents with more than 4 documents.", "rationale": ["Identify the relevant table, which is 'Documents'.", "Select the column to display, 'document_type_code'.", "Group the results by 'document_type_code' to aggregate the data.", "Add a condition to filter the grouped results using HAVING to count the number of documents and compare it to a placeholder for numeric values."], "gold_sql": "SELECT document_type_code FROM documents GROUP BY document_type_code HAVING count(*)  >  4", "source_tables": ["documents"], "description": "The virtual table summarizes the types of documents from the 'Documents' table, grouping them by their document type code. It filters the results to include only those document types that have more than a specified number of associated documents, represented by a placeholder for numeric values.", "virtual_table": "SELECT document_type_code FROM documents GROUP BY document_type_code HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4509", "db_id": "document_management", "question": "What is the structure of the document with the least number of accesses?", "rationale": ["Identify the relevant tables, which are 'Documents' and 'Document_Structures'.", "Join the 'Documents' table with the 'Document_Structures' table on the 'document_structure_code' to access the structure descriptions.", "Group the results by 'document_structure_code' to aggregate the access counts for each document structure.", "Order the results by the count of accesses in descending order to find the least accessed document structure.", "Use a placeholder to limit the number of results returned, focusing on the document structure with the least accesses."], "gold_sql": "SELECT t2.document_structure_description FROM documents AS t1 JOIN document_structures AS t2 ON t1.document_structure_code  =  t2.document_structure_code GROUP BY t1.document_structure_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["document_structures", "documents"], "description": "The virtual table provides the description of the document structure associated with documents in the database. It retrieves the structure description for the document that has been accessed the least number of times, using a placeholder to specify the limit on the number of results returned.", "virtual_table": "SELECT t2.document_structure_description FROM documents AS t1 JOIN document_structures AS t2 ON t1.document_structure_code  =  t2.document_structure_code GROUP BY t1.document_structure_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4535", "db_id": "document_management", "question": "Find the average access count of documents with the least popular structure.", "rationale": ["Identify the relevant table, which is 'Documents'.", "Select the average of the 'access_count' column to calculate the average access count.", "Group the results by 'document_structure_code' to categorize the documents by their structure.", "Order the results by the count of documents in ascending order to find the least popular structures.", "Use a placeholder in the LIMIT clause to specify how many of the least popular structures to include in the results."], "gold_sql": "SELECT avg(access_count) FROM documents GROUP BY document_structure_code ORDER BY count(*) ASC LIMIT 1", "source_tables": ["documents"], "description": "The virtual table calculates the average access count of documents grouped by their structure. It identifies the document structure with the least popularity by ordering the groups based on the count of documents in ascending order. The placeholder in the LIMIT clause allows for specifying the number of least popular structures to consider.", "virtual_table": "SELECT avg(access_count) FROM documents GROUP BY document_structure_code ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4526", "db_id": "document_management", "question": "What are the names of documents that do not have any images?", "rationale": ["Identify the relevant table, which is 'Documents'.", "Select the column to display, 'document_name'.", "Use a subquery to find document names that have images by joining 'Documents', 'Document_Sections', and 'Document_Sections_Images'.", "Utilize the EXCEPT clause to filter out document names that are present in the subquery, ensuring only those without images are included."], "gold_sql": "SELECT document_name FROM documents EXCEPT SELECT t1.document_name FROM documents AS t1 JOIN document_sections AS t2 ON t1.document_code  =  t2.document_code JOIN document_sections_images AS t3 ON t2.section_id  =  t3.section_id", "source_tables": ["document_sections", "document_sections_images", "documents"], "description": "The virtual table lists the names of documents from the 'Documents' table that do not have any associated images. It uses a subquery to identify documents that have sections linked to images, and the placeholder in the EXCEPT clause ensures that only document names without images are returned.", "virtual_table": "SELECT document_name FROM documents EXCEPT SELECT t1.document_name FROM documents AS t1 JOIN document_sections AS t2 ON t1.document_code  =  t2.document_code JOIN document_sections_images AS t3 ON t2.section_id  =  t3.section_id"}
{"sample_id": "train.4525", "db_id": "document_management", "question": "Find names of the document without any images.", "rationale": ["Identify the relevant table, which is 'Documents'.", "Select the column to display, 'document_name'.", "Use an EXCEPT clause to filter out document names that have associated images by joining 'Documents', 'Document_Sections', and 'Document_Sections_Images' tables."], "gold_sql": "SELECT document_name FROM documents EXCEPT SELECT t1.document_name FROM documents AS t1 JOIN document_sections AS t2 ON t1.document_code  =  t2.document_code JOIN document_sections_images AS t3 ON t2.section_id  =  t3.section_id", "source_tables": ["document_sections", "document_sections_images", "documents"], "description": "The virtual table lists the names of documents from the 'Documents' table that do not have any associated images. It excludes documents that are linked to any images through their sections, ensuring that only those documents without images are displayed.", "virtual_table": "SELECT document_name FROM documents EXCEPT SELECT t1.document_name FROM documents AS t1 JOIN document_sections AS t2 ON t1.document_code  =  t2.document_code JOIN document_sections_images AS t3 ON t2.section_id  =  t3.section_id"}
{"sample_id": "dev.944", "db_id": "dog_kennels", "question": "What are the first name and last name of the professionals who have done treatment with cost below average?", "rationale": ["Identify the relevant tables, which are 'Professionals' and 'Treatments'.", "Select the distinct columns to display, 'first_name' and 'last_name' from the 'Professionals' table.", "Join the 'Professionals' table with the 'Treatments' table to link professionals with the treatments they have administered.", "Add a condition to filter the treatments based on their cost being below the average treatment cost, which is calculated using a subquery."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T1.last_name FROM Professionals AS T1 JOIN Treatments AS T2 WHERE cost_of_treatment  <  ( SELECT avg(cost_of_treatment) FROM Treatments )", "source_tables": ["professionals", "treatments"], "description": "The virtual table provides the distinct first and last names of professionals from the 'Professionals' table who have administered treatments with costs below the average treatment cost. The query joins the 'Professionals' and 'Treatments' tables, and includes a subquery to calculate the average treatment cost, using a placeholder for the cost condition.", "virtual_table": "SELECT DISTINCT T1.first_name ,  T1.last_name FROM Professionals AS T1 JOIN Treatments AS T2 WHERE cost_of_treatment  <  ( SELECT avg(cost_of_treatment) FROM Treatments )"}
{"sample_id": "dev.937", "db_id": "dog_kennels", "question": "Tell me the owner id and last name of the owner who spent the most on treatments of his or her dogs.", "rationale": ["Identify the relevant tables: 'Owners', 'Dogs', and 'Treatments'.", "Select the columns to display: 'owner_id' and 'last_name' from the 'Owners' table.", "Join the 'Dogs' table on the owner ID to link dogs to their respective owners.", "Join the 'Treatments' table on the dog ID to link treatments to the dogs.", "Group the results by owner ID to aggregate treatment costs for each owner.", "Order the results by the count of treatments in descending order to find the owners who spent the most.", "Add a limit to restrict the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["owners", "dogs", "treatments"], "description": "The virtual table provides the owner ID and last name of the owners from the 'Owners' table who have the highest expenditure on treatments for their dogs. The query joins the 'Owners', 'Dogs', and 'Treatments' tables to aggregate treatment costs by owner, with a placeholder to limit the results to a specific number of owners.", "virtual_table": "SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.925", "db_id": "dog_kennels", "question": "What are the names of the dogs for which the owner has not spend more than 1000 for treatment ?", "rationale": ["Identify the relevant table, which is 'Dogs'.", "Select the column to display, which is 'name'.", "Use a subquery to filter dogs based on their total treatment costs, grouping by 'dog_id'.", "Add a condition in the HAVING clause to ensure the total cost is less than or equal to a specified amount using a placeholder for numeric values."], "gold_sql": "select name from dogs where dog_id not in ( select dog_id from treatments group by dog_id having sum(cost_of_treatment)  >  1000 )", "source_tables": ["dogs", "treatments"], "description": "The virtual table lists the names of dogs from the 'Dogs' table whose total treatment costs do not exceed a specified amount. The subquery calculates the total treatment costs for each dog, and the placeholder in the HAVING clause allows for filtering based on the treatment cost threshold.", "virtual_table": "select name from dogs where dog_id not in ( select dog_id from treatments group by dog_id having sum(cost_of_treatment)  >  [PLACEHOLDER-TYPE:NUMBER] )"}
{"sample_id": "dev.942", "db_id": "dog_kennels", "question": "Which professionals have done at least two types of treatments? List the professional id and cell phone.", "rationale": ["Identify the relevant tables, which are 'Professionals' and 'Treatments'.", "Select the columns to display, 'professional_id' and 'cell_number'.", "Join the 'Professionals' table with the 'Treatments' table on the professional ID to link treatments to professionals.", "Group the results by professional ID to aggregate treatment counts.", "Add a condition to filter professionals who have administered at least a specified number of treatments using a placeholder for numeric values."], "gold_sql": "SELECT T1.professional_id ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  2", "source_tables": ["professionals", "treatments"], "description": "The virtual table describes the professional IDs and cell phone numbers of professionals from the 'Professionals' table who have administered at least a specified number of treatments. The placeholder in the HAVING clause represents the minimum count of treatment types that a professional must have performed.", "virtual_table": "SELECT T1.professional_id ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.960", "db_id": "dog_kennels", "question": "List the last name of the owner owning the youngest dog.", "rationale": ["Identify the relevant tables, which are 'Owners' and 'Dogs'.", "Select the 'last_name' column from the 'Owners' table.", "Join the 'Owners' table with the 'Dogs' table using the 'owner_id' to link them.", "Add a condition to filter the results based on the age of the dog, specifically looking for the maximum age using a subquery."], "gold_sql": "SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )", "source_tables": ["owners", "dogs"], "description": "The virtual table describes the last names of owners from the 'Owners' table who own the youngest dog. It joins the 'Owners' and 'Dogs' tables based on the owner's unique identifier and filters the results to find the owner of the dog with the maximum age, represented by a placeholder in the subquery.", "virtual_table": "SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )"}
{"sample_id": "dev.921", "db_id": "dog_kennels", "question": "Find the average age of the dogs who went through treatments.", "rationale": ["Identify the relevant tables, which are 'Dogs' and 'Treatments'.", "Select the column to display, which is the average age of the dogs.", "Add a condition to filter the 'Dogs' table for dogs that have treatment records by using a subquery that selects dog_ids from the 'Treatments' table."], "gold_sql": "SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )", "source_tables": ["dogs", "treatments"], "description": "The virtual table provides the average age of dogs from the 'Dogs' table that have undergone treatments. The inner query filters the dogs based on their identifiers found in the 'Treatments' table, ensuring that only those dogs that have received treatments are included in the average calculation.", "virtual_table": "SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )"}
{"sample_id": "dev.920", "db_id": "dog_kennels", "question": "What is the average age of the dogs who have gone through any treatments?", "rationale": ["Identify the relevant table, which is 'Dogs'.", "Select the column to calculate the average, which is 'age'.", "Add a condition to filter the 'dog_id' column to include only those dogs that have records in the 'Treatments' table using a subquery."], "gold_sql": "SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )", "source_tables": ["dogs", "treatments"], "description": "The virtual table provides the average age of dogs from the 'Dogs' table that have received any treatments. The inner query filters the dogs based on their identifiers found in the 'Treatments' table, ensuring that only those dogs who have undergone treatment are considered in the average calculation.", "virtual_table": "SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )"}
{"sample_id": "dev.998", "db_id": "dog_kennels", "question": "List the first name of all the professionals along with the description of the treatment they have done.", "rationale": ["Identify the relevant tables: 'Professionals', 'Treatments', and 'Treatment_Types'.", "Select the 'first_name' from the 'Professionals' table and 'treatment_type_description' from the 'Treatment_Types' table.", "Join the 'Professionals' table with the 'Treatments' table using the 'professional_id' to link treatments to professionals.", "Join the 'Treatments' table with the 'Treatment_Types' table using 'treatment_type_code' to get the treatment descriptions.", "Use DISTINCT to ensure that the results do not contain duplicate entries."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code", "source_tables": ["professionals", "treatments", "treatment_types"], "description": "The virtual table provides a list of unique first names of professionals along with the descriptions of the treatments they have administered. It combines data from the 'Professionals' table, the 'Treatments' table, and the 'Treatment_Types' table, linking them through their respective identifiers. This allows for a comprehensive view of which professionals are associated with which treatment types.", "virtual_table": "SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code"}
{"sample_id": "dev.958", "db_id": "dog_kennels", "question": "What are the arriving date and the departing date of the dogs who have gone through a treatment?", "rationale": ["Identify the relevant tables, which are 'Dogs' and 'Treatments'.", "Select the columns to display, 'date_arrived' and 'date_departed' from the 'Dogs' table.", "Join the 'Dogs' table with the 'Treatments' table on the dog identifier to filter for dogs that have received treatments.", "Use DISTINCT to ensure that the results do not contain duplicate date entries."], "gold_sql": "SELECT DISTINCT T1.date_arrived ,  T1.date_departed FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id", "source_tables": ["dogs", "treatments"], "description": "The virtual table provides the distinct arriving and departing dates of dogs from the 'Dogs' table that have undergone treatments. It combines data from the 'Dogs' and 'Treatments' tables, linking them through the dog identifier. This allows for filtering the results to only include dogs that have received treatments, with placeholders representing the specific dates.", "virtual_table": "SELECT DISTINCT T1.date_arrived ,  T1.date_departed FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id"}
{"sample_id": "train.5765", "db_id": "dorm_1", "question": "What is the first name and age of every student who lives in a dorm with a TV Lounge?", "rationale": ["Identify the relevant tables: 'Student', 'Lives_in', 'Has_amenity', and 'Dorm_amenity'.", "Select the columns to display, which are 'fname' and 'age' from the 'Student' table.", "Join the 'Student' table with the 'Lives_in' table to link students with their respective dormitories.", "Use a subquery to filter out dormitories that have the specified amenity (TV Lounge) by checking against the 'Has_amenity' and 'Dorm_amenity' tables.", "Add a condition to ensure that only students living in dorms without the specified amenity are included in the results."], "gold_sql": "SELECT T1.fname ,  T1.age FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid NOT IN (SELECT T3.dormid FROM has_amenity AS T3 JOIN dorm_amenity AS T4 ON T3.amenid  =  T4.amenid WHERE T4.amenity_name  =  'TV Lounge')", "source_tables": ["has_amenity", "student", "lives_in", "dorm_amenity"], "description": "The virtual table describes the first names and ages of students from the 'Student' table who reside in dormitories that do not have a specific amenity, in this case, a TV Lounge. The placeholders in the query represent the amenity's name that is being filtered out.", "virtual_table": "SELECT T1.fname ,  T1.age FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid NOT IN (SELECT T3.dormid FROM has_amenity AS T3 JOIN dorm_amenity AS T4 ON T3.amenid  =  T4.amenid WHERE T4.amenity_name  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.5729", "db_id": "dorm_1", "question": "What is the average age and how many male students are there in each city?", "rationale": ["Identify the relevant table, which is 'Student'.", "Select the columns to display: count of students and average age.", "Add a condition to filter the 'Sex' column for male students using a placeholder for string values.", "Group the results by 'city_code' to get the data for each city."], "gold_sql": "SELECT count(*) ,  avg(age) ,  city_code FROM student WHERE sex  =  'M' GROUP BY city_code", "source_tables": ["student"], "description": "The virtual table provides a summary of the count of male students and their average age from the 'Student' table, grouped by the city of residence. The placeholder in the WHERE clause represents the gender of the students being filtered.", "virtual_table": "SELECT count(*) ,  avg(age) ,  city_code FROM student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] GROUP BY city_code"}
{"sample_id": "train.5707", "db_id": "dorm_1", "question": "What is the last name of every student who is either female or living in a city with the code BAL or male and under 20?", "rationale": ["Identify the relevant table, which is 'Student'.", "Select the column to display, 'LName'.", "Add conditions to filter the results based on gender, city code, and age using placeholders for string and numeric values."], "gold_sql": "SELECT lname FROM student WHERE sex  =  'F' AND city_code  =  'BAL' UNION SELECT lname FROM student WHERE sex  =  'M' AND age  <  20", "source_tables": ["student"], "description": "The virtual table provides the last names of students from the 'Student' table who meet specific criteria based on their gender, age, or city of residence. The placeholders in the WHERE clause represent the gender, city code, and age conditions that can be modified to filter the results accordingly.", "virtual_table": "SELECT lname FROM student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND city_code  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT lname FROM student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND age  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5699", "db_id": "dorm_1", "question": "What are the names and types of the dorms that have a capacity greater than 300 or less than 100?", "rationale": ["Identify the relevant table, which is 'Dorm'.", "Select the columns to display, 'dorm_name' and 'gender'.", "Add conditions to filter the 'student_capacity' column for values greater than or less than specified thresholds using placeholders for numeric values."], "gold_sql": "SELECT dorm_name ,  gender FROM dorm WHERE student_capacity  >  300 OR student_capacity  <  100", "source_tables": ["dorm"], "description": "The virtual table provides the names and gender designations of dormitories from the 'Dorm' table that have a student capacity exceeding a specified number or falling below another specified number. The placeholders in the WHERE clause represent the capacity thresholds.", "virtual_table": "SELECT dorm_name ,  gender FROM dorm WHERE student_capacity  >  [PLACEHOLDER-TYPE:NUMBER] OR student_capacity  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5757", "db_id": "dorm_1", "question": "What are the first names of all students who live in the dorm with the most amenities?", "rationale": ["Identify the relevant tables: 'Student', 'Lives_in', 'Dorm', 'Has_amenity', and 'Dorm_amenity'.", "Select the column to display, which is 'fname' from the 'Student' table.", "Join the 'Student' table with the 'Lives_in' table to connect students with their dormitories.", "Use a subquery to find the dormitory with the most amenities by joining 'Dorm', 'Has_amenity', and 'Dorm_amenity' tables, grouping by dormitory ID, and ordering by the count of amenities.", "Add a condition to filter the dormitory IDs based on the result of the subquery, using a placeholder for the number of top dormitories to consider."], "gold_sql": "SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["has_amenity", "lives_in", "student", "dorm_amenity", "dorm"], "description": "The virtual table provides the first names of students from the 'Student' table who reside in the dormitory that has the highest number of amenities. The query involves joining the 'Student' table with the 'Lives_in' table to link students to their respective dorms, and it uses a subquery to identify the dormitory with the most amenities by counting the amenities associated with each dormitory. The placeholder in the LIMIT clause indicates the number of top dormitories to consider based on the count of amenities.", "virtual_table": "SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.5756", "db_id": "dorm_1", "question": "Find the first name of students who are living in the dorm that has most number of amenities.", "rationale": ["Identify the relevant tables: 'Student', 'Lives_in', 'Dorm', 'Has_amenity', and 'Dorm_amenity'.", "Select the column to display, which is 'fname' from the 'Student' table.", "Join the 'Student' table with the 'Lives_in' table to link students with their respective dormitories.", "Use a subquery to find the dormitory with the most amenities by joining 'Dorm', 'Has_amenity', and 'Dorm_amenity' tables, grouping by dormitory ID, and counting the amenities.", "Add a condition to filter the dormitory IDs based on the result of the subquery, using a placeholder for the number of top dormitories to consider."], "gold_sql": "SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["has_amenity", "lives_in", "student", "dorm_amenity", "dorm"], "description": "The virtual table provides the first names of students from the 'Student' table who reside in the dormitory with the highest number of amenities. It utilizes a subquery to determine which dormitory has the most amenities by counting the amenities associated with each dormitory and ordering them in descending order. The placeholder in the LIMIT clause allows for specifying the number of top dormitories to consider.", "virtual_table": "SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.5747", "db_id": "dorm_1", "question": "What are the total number of students who are living in a male dorm?", "rationale": ["Identify the relevant tables: 'Student', 'Lives_in', and 'Dorm'.", "Count the total number of students by using the count(*) function.", "Join the 'Student' table with the 'Lives_in' table on the student ID, and then join the result with the 'Dorm' table on the dormitory ID.", "Add a condition to filter the results based on the gender of the dormitory using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T3.gender  =  'M'", "source_tables": ["student", "lives_in", "dorm"], "description": "The virtual table provides the total count of students residing in male-designated dormitories. It combines data from the 'Student', 'Lives_in', and 'Dorm' tables, filtering the results based on the gender designation of the dormitory using a placeholder for string values.", "virtual_table": "SELECT count(*) FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T3.gender  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5688", "db_id": "dorm_1", "question": "Find the average and total capacity of dorms for the students with gender X.", "rationale": ["Identify the relevant table, which is 'Dorm'.", "Select the columns to display, which are the average and total of 'student_capacity'.", "Add a condition to filter the 'gender' column for the specified gender using a placeholder for string values."], "gold_sql": "SELECT avg(student_capacity) ,  sum(student_capacity) FROM dorm WHERE gender  =  'X'", "source_tables": ["dorm"], "description": "The virtual table provides the average and total capacity of dormitories from the 'Dorm' table, filtered by a specific gender designation. The placeholder in the WHERE clause represents the gender of the students.", "virtual_table": "SELECT avg(student_capacity) ,  sum(student_capacity) FROM dorm WHERE gender  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6714", "db_id": "driving_school", "question": "What is the id and detail of the vehicle used in lessons for most of the times?", "rationale": ["Identify the relevant tables, which are 'Vehicles' and 'Lessons'.", "Select the columns to display, 'vehicle_id' and 'vehicle_details'.", "Join the 'Vehicles' table with the 'Lessons' table on the vehicle ID to correlate vehicles with lessons.", "Group the results by vehicle ID to count how many times each vehicle is used in lessons.", "Order the results in descending order based on the count of lessons to find the most frequently used vehicles.", "Add a limit to specify how many of the top vehicles to return, using a placeholder for numeric values."], "gold_sql": "SELECT T1.vehicle_id ,  T1.vehicle_details FROM Vehicles AS T1 JOIN Lessons AS T2 ON T1.vehicle_id  =  T2.vehicle_id GROUP BY T1.vehicle_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["lessons", "vehicles"], "description": "The virtual table provides the vehicle IDs and their corresponding details from the 'Vehicles' table that are used in lessons. It aggregates the data by counting the number of times each vehicle is associated with lessons, ordering the results to show the most frequently used vehicles first. The placeholder in the LIMIT clause allows for specifying the number of top vehicles to retrieve.", "virtual_table": "SELECT T1.vehicle_id ,  T1.vehicle_details FROM Vehicles AS T1 JOIN Lessons AS T2 ON T1.vehicle_id  =  T2.vehicle_id GROUP BY T1.vehicle_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6654", "db_id": "driving_school", "question": "Which city lives most of staffs? List the city name and number of staffs.", "rationale": ["Identify the relevant tables, which are 'Addresses' and 'Staff'.", "Join the two tables on the address identifier to associate staff with their respective cities.", "Select the 'city' column and count the number of staff members in each city.", "Group the results by city to aggregate the staff counts.", "Order the results in descending order based on the count of staff members to find the city with the most staff.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT T1.city ,  count(*) FROM Addresses AS T1 JOIN Staff AS T2 ON T1.address_id = T2.staff_address_id GROUP BY T1.city ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["addresses", "staff"], "description": "The virtual table provides a summary of the cities where staff members reside, along with the count of staff in each city. It aggregates data from the 'Addresses' and 'Staff' tables, linking them through the staff's address identifier. The result is grouped by city and ordered by the number of staff members, allowing for the identification of the city with the highest staff count, limited to a specified number of results.", "virtual_table": "SELECT T1.city ,  count(*) FROM Addresses AS T1 JOIN Staff AS T2 ON T1.address_id = T2.staff_address_id GROUP BY T1.city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.6688", "db_id": "driving_school", "question": "Which city does has most number of customers?", "rationale": ["Identify the relevant tables, which are 'Customers' and 'Addresses'.", "Join the 'Customers' table with the 'Addresses' table using the customer_address_id to address_id relationship.", "Select the 'city' column from the 'Addresses' table.", "Group the results by the 'city' to count the number of customers in each city.", "Order the results in descending order based on the count of customers to find the city with the most customers.", "Use a placeholder in the LIMIT clause to specify how many results to return."], "gold_sql": "SELECT T2.city FROM Customers AS T1 JOIN Addresses AS T2 ON T1.customer_address_id = T2.address_id GROUP BY T2.city ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["addresses", "customers"], "description": "The virtual table provides a list of cities from the 'Addresses' table that are associated with customers in the 'Customers' table. It groups the results by city and orders them by the number of customers in each city, allowing the user to identify the city with the highest customer count. The placeholder in the LIMIT clause indicates the maximum number of results to return.", "virtual_table": "SELECT T2.city FROM Customers AS T1 JOIN Addresses AS T2 ON T1.customer_address_id = T2.address_id GROUP BY T2.city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.6711", "db_id": "driving_school", "question": "What are the last names that are used by customers and staff?", "rationale": ["Identify the relevant tables, which are 'Customers' and 'Staff'.", "Select the 'last_name' column from both tables.", "Use the INTERSECT operator to find common last names between the two tables."], "gold_sql": "SELECT last_name FROM Customers INTERSECT SELECT last_name FROM Staff", "source_tables": ["staff", "customers"], "description": "The virtual table presents the last names of individuals from both the 'Customers' and 'Staff' tables, showing the intersection of last names used by customers and staff members. This allows for identifying common last names between these two groups.", "virtual_table": "SELECT last_name FROM Customers INTERSECT SELECT last_name FROM Staff"}
{"sample_id": "train.6627", "db_id": "driving_school", "question": "What are the details of the car with id 1?", "rationale": ["Identify the relevant table, which is 'Vehicles'.", "Select the column to display, 'vehicle_details'.", "Add a condition to filter the 'vehicle_id' column for the specified vehicle using a placeholder for numeric values."], "gold_sql": "SELECT vehicle_details FROM Vehicles WHERE vehicle_id = 1;", "source_tables": ["vehicles"], "description": "The virtual table provides the details of vehicles from the 'Vehicles' table, specifically focusing on the vehicle's information based on a unique identifier. The placeholder in the WHERE clause represents the vehicle's ID.", "virtual_table": "SELECT vehicle_details FROM Vehicles WHERE vehicle_id = [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.6699", "db_id": "driving_school", "question": "How many lessons have been cancelled?", "rationale": ["Identify the relevant table, which is 'Lessons'.", "Use the count function to aggregate the total number of lessons.", "Add a condition to filter the 'lesson_status_code' column for the specified status using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM Lessons WHERE lesson_status_code = 'Cancelled';", "source_tables": ["lessons"], "description": "The virtual table provides a count of lessons from the 'Lessons' table that have a specific status indicating cancellation. The placeholder in the WHERE clause represents the status code for cancelled lessons.", "virtual_table": "SELECT count(*) FROM Lessons WHERE lesson_status_code = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.6698", "db_id": "driving_school", "question": "How many lessons were in cancelled state?", "rationale": ["Identify the relevant table, which is 'Lessons'.", "Select the count of lessons to display.", "Add a condition to filter the 'lesson_status_code' column for the specified status using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM Lessons WHERE lesson_status_code = 'Cancelled';", "source_tables": ["lessons"], "description": "The virtual table provides a count of lessons from the 'Lessons' table that are in a specific status, indicated by a placeholder. This allows users to filter the lessons based on their current status, such as 'cancelled'.", "virtual_table": "SELECT count(*) FROM Lessons WHERE lesson_status_code = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.6331", "db_id": "e_government", "question": "What are the names of all cities and states?", "rationale": ["Identify the relevant table, which is 'Addresses'.", "Select the 'town_city' column to retrieve city names.", "Select the 'state_province_county' column to retrieve state names.", "Use the UNION operator to combine the results from both selections, ensuring unique entries."], "gold_sql": "SELECT town_city FROM addresses UNION SELECT state_province_county FROM addresses", "source_tables": ["addresses"], "description": "The virtual table presents a list of unique town and city names along with their corresponding state, province, or county from the 'Addresses' table. The query combines these two sets of data using a UNION operation to ensure that all entries are included without duplicates.", "virtual_table": "SELECT town_city FROM addresses UNION SELECT state_province_county FROM addresses"}
{"sample_id": "train.6330", "db_id": "e_government", "question": "Find the name of all the cities and states.", "rationale": ["Identify the relevant table, which is 'Addresses'.", "Select the 'town_city' column to retrieve city names.", "Select the 'state_province_county' column to retrieve state or county names.", "Use a UNION to combine the results from both selections into a single list."], "gold_sql": "SELECT town_city FROM addresses UNION SELECT state_province_county FROM addresses", "source_tables": ["addresses"], "description": "The virtual table presents a list of unique town and city names along with their corresponding state, province, or county from the 'Addresses' table. The query combines these two sets of data using a UNION operation, allowing for a comprehensive view of geographical locations represented in the database.", "virtual_table": "SELECT town_city FROM addresses UNION SELECT state_province_county FROM addresses"}
{"sample_id": "train.6323", "db_id": "e_government", "question": "What is the last name of the contact individual from the Labour party organization who was contacted most recently?", "rationale": ["Identify the relevant tables: 'Organizations', 'Organization_Contact_Individuals', and 'Individuals'.", "Select the 'individual_last_name' from the 'Individuals' table.", "Join the tables based on their relationships: 'Organizations' to 'Organization_Contact_Individuals' and 'Organization_Contact_Individuals' to 'Individuals'.", "Add a condition to filter the organization name using a placeholder for string values.", "Sort the results by the contact date in descending order to get the most recent contact.", "Limit the results to one entry to retrieve only the most recent contact individual."], "gold_sql": "SELECT t3.individual_last_name FROM organizations AS t1 JOIN organization_contact_individuals AS t2 ON t1.organization_id  =  t2.organization_id JOIN individuals AS t3 ON t2.individual_id  =  t3.individual_id WHERE t1.organization_name  =  'Labour Party' ORDER BY t2.date_contact_to DESC LIMIT 1", "source_tables": ["organizations", "organization_contact_individuals", "individuals"], "description": "The virtual table provides the last names of contact individuals associated with a specific organization, in this case, the Labour party. It joins the 'Organizations', 'Organization_Contact_Individuals', and 'Individuals' tables to retrieve the relevant data. The placeholder in the WHERE clause is used to specify the organization's name, while the ORDER BY clause sorts the results by the most recent contact date, limiting the output to the most recent individual.", "virtual_table": "SELECT t3.individual_last_name FROM organizations AS t1 JOIN organization_contact_individuals AS t2 ON t1.organization_id  =  t2.organization_id JOIN individuals AS t3 ON t2.individual_id  =  t3.individual_id WHERE t1.organization_name  =  [PLACEHOLDER-TYPE:STRING] ORDER BY t2.date_contact_to DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6346", "db_id": "e_government", "question": "Find the last name of the individuals that have been contact individuals of an organization.", "rationale": ["Identify the relevant tables, which are 'Individuals' and 'Organization_Contact_Individuals'.", "Select the 'individual_last_name' column from the 'Individuals' table and ensure distinct values are returned.", "Join the 'Individuals' table with the 'Organization_Contact_Individuals' table using the 'individual_id' to filter for individuals who are contact persons for organizations."], "gold_sql": "SELECT DISTINCT t1.individual_last_name FROM individuals AS t1 JOIN organization_contact_individuals AS t2 ON t1.individual_id  =  t2.individual_id", "source_tables": ["organization_contact_individuals", "individuals"], "description": "The virtual table describes the distinct last names of individuals from the 'Individuals' table who have been identified as contact individuals for organizations. This is achieved by joining the 'Individuals' table with the 'Organization_Contact_Individuals' table based on the unique identifier for individuals, ensuring that only those individuals who have a contact relationship with an organization are included.", "virtual_table": "SELECT DISTINCT t1.individual_last_name FROM individuals AS t1 JOIN organization_contact_individuals AS t2 ON t1.individual_id  =  t2.individual_id"}
{"sample_id": "train.6342", "db_id": "e_government", "question": "Which state can address \"6862 Kaitlyn Knolls\" possibly be in?", "rationale": ["Identify the relevant table, which is 'Addresses'.", "Select the column to display, 'state_province_county'.", "Add a condition to filter the 'line_1_number_building' column using a LIKE clause with a placeholder for string values to accommodate partial matches."], "gold_sql": "SELECT state_province_county FROM addresses WHERE line_1_number_building LIKE '%6862 Kaitlyn Knolls%'", "source_tables": ["addresses"], "description": "The virtual table provides a list of possible states, provinces, or counties associated with addresses from the 'Addresses' table that match a specific address line. The placeholder in the WHERE clause allows for the input of a partial or complete address to filter the results accordingly.", "virtual_table": "SELECT state_province_county FROM addresses WHERE line_1_number_building LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.430", "db_id": "flight_1", "question": "What are the names of all employees who are not certified to fly Boeing 737-800s?", "rationale": ["Identify the relevant table, which is 'Employee'.", "Select the column to display, 'name'.", "Use an EXCEPT clause to filter out employees who are certified to fly a specific aircraft.", "Join the 'Employee' table with the 'Certificate' and 'Aircraft' tables to find certified employees.", "Add a condition to filter the aircraft name using a placeholder for string values."], "gold_sql": "SELECT name FROM Employee EXCEPT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  'Boeing 737-800'", "source_tables": ["employee", "certificate", "aircraft"], "description": "The virtual table describes the names of employees from the 'Employee' table who do not hold a certification for a specific aircraft model. The query uses an EXCEPT clause to exclude those employees who are certified to fly the specified aircraft, represented by a placeholder for the aircraft's name.", "virtual_table": "SELECT name FROM Employee EXCEPT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.415", "db_id": "flight_1", "question": "Show aircraft names and number of flights for each aircraft.", "rationale": ["Identify the relevant tables, which are 'Flight' and 'Aircraft'.", "Select the 'name' column from the 'Aircraft' table and count the number of flights from the 'Flight' table.", "Join the two tables on the aircraft ID to associate flights with their respective aircraft.", "Group the results by the aircraft ID to get the count of flights for each aircraft name."], "gold_sql": "SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid", "source_tables": ["aircraft", "flight"], "description": "The virtual table provides a summary of aircraft names along with the count of flights associated with each aircraft. It combines data from the 'Flight' and 'Aircraft' tables, linking them through the aircraft ID. The result is grouped by the aircraft ID to aggregate the number of flights for each aircraft name.", "virtual_table": "SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid"}
{"sample_id": "train.438", "db_id": "flight_1", "question": "What is the salaray and name of the employee with the most certificates to fly planes more than 5000?", "rationale": ["Identify the relevant tables: 'Employee', 'Certificate', and 'Aircraft'.", "Select the 'name' column from the 'Employee' table.", "Join the 'Employee' table with the 'Certificate' table on the employee ID, and then join with the 'Aircraft' table on the aircraft ID.", "Add a condition to filter the aircraft distance using a placeholder for numeric values.", "Group the results by employee ID to count the number of certificates each employee holds.", "Order the results by the count of certificates in descending order and limit the output to a specified number using placeholders."], "gold_sql": "SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  5000 GROUP BY T1.eid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employee", "certificate", "aircraft"], "description": "The virtual table provides the names of employees from the 'Employee' table who hold the most certificates for flying aircraft that can travel a distance greater than a specified value. The query joins the 'Employee', 'Certificate', and 'Aircraft' tables to filter and group the results based on the number of certificates held by each employee, ordering them in descending order. Placeholders are used for the distance threshold and the limit on the number of results returned.", "virtual_table": "SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.eid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.434", "db_id": "flight_1", "question": "What is the name and distance of every aircraft that can cover a distance of more than 5000 and which at least 5 people can fly?", "rationale": ["Identify the relevant tables, which are 'Certificate' and 'Aircraft'.", "Select the column to display, which is 'name' from the 'Aircraft' table.", "Join the 'Certificate' table with the 'Aircraft' table on the aircraft ID to filter the results based on aircraft capabilities.", "Add a condition to filter the 'distance' column for aircraft that can cover more than a specified distance using a placeholder for numeric values.", "Group the results by aircraft ID and ensure that the count of associated certificates meets the minimum passenger requirement using another placeholder for numeric values."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  5000 GROUP BY T1.aid ORDER BY count(*)  >=  5", "source_tables": ["aircraft", "certificate"], "description": "The virtual table provides the names of aircraft from the 'Aircraft' table that can travel a distance greater than a specified value and can accommodate at least a certain number of passengers. The placeholders in the WHERE clause represent the distance threshold and the minimum number of passengers required.", "virtual_table": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.aid ORDER BY count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.437", "db_id": "flight_1", "question": "What is the salary and name of the employee who has the most number of certificates on aircrafts with distance more than 5000?", "rationale": ["Identify the relevant tables: 'Employee', 'Certificate', and 'Aircraft'.", "Join the 'Employee' table with the 'Certificate' table on the employee ID, and then join the 'Certificate' table with the 'Aircraft' table on the aircraft ID.", "Filter the results based on the distance of the aircraft using a placeholder for numeric values.", "Group the results by employee ID to count the number of certificates each employee holds.", "Order the results in descending order based on the count of certificates and limit the output to a specified number using placeholders."], "gold_sql": "SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  5000 GROUP BY T1.eid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employee", "certificate", "aircraft"], "description": "The virtual table provides the names of employees from the 'Employee' table who hold the most certificates for aircrafts that can travel a distance greater than a specified value. The query joins the 'Employee', 'Certificate', and 'Aircraft' tables to filter and group the results based on the number of certificates held by each employee, ordering them in descending order. Placeholders are used for the distance threshold and the limit on the number of results returned.", "virtual_table": "SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.eid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.431", "db_id": "flight_1", "question": "Show the name of aircraft which fewest people have its certificate.", "rationale": ["Identify the relevant tables, which are 'Certificate' and 'Aircraft'.", "Select the 'name' column from the 'Aircraft' table.", "Join the 'Certificate' table with the 'Aircraft' table on the aircraft ID.", "Group the results by the aircraft ID to count the number of certificates for each aircraft.", "Order the results by the count of certificates in descending order to find the aircraft with the fewest certificates.", "Use a placeholder in the LIMIT clause to allow the user to specify how many results they want."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["aircraft", "certificate"], "description": "The virtual table provides the names of aircraft from the 'Aircraft' table that have the fewest associated certificates. It utilizes a join between the 'Certificate' and 'Aircraft' tables, grouping the results by aircraft ID and ordering them by the count of certificates in descending order. The placeholder in the LIMIT clause allows for specifying the number of results to return.", "virtual_table": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.394", "db_id": "flight_1", "question": "What is the average price for flights from LA to Honolulu?", "rationale": ["Identify the relevant table, which is 'Flight'.", "Select the column to display, which is the average of the 'price' column.", "Add conditions to filter the 'origin' and 'destination' columns for the specified locations using placeholders for string values."], "gold_sql": "SELECT avg(price) FROM Flight WHERE origin  =  'Los Angeles' AND destination  =  'Honolulu'", "source_tables": ["flight"], "description": "The virtual table provides the average price of flights from a specified origin to a specified destination. The placeholders in the WHERE clause represent the origin and destination locations for the flight.", "virtual_table": "SELECT avg(price) FROM Flight WHERE origin  =  [PLACEHOLDER-TYPE:STRING] AND destination  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.388", "db_id": "flight_1", "question": "What are the origins of all flights that are headed to Honolulu?", "rationale": ["Identify the relevant table, which is 'Flight'.", "Select the column to display, 'origin'.", "Add a condition to filter the 'destination' column for the specified city using a placeholder for string values."], "gold_sql": "SELECT origin FROM Flight WHERE destination  =  'Honolulu'", "source_tables": ["flight"], "description": "The virtual table provides a list of origins for all flights from the 'Flight' table that are destined for a specific location. The placeholder in the WHERE clause represents the destination city.", "virtual_table": "SELECT origin FROM Flight WHERE destination  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.400", "db_id": "flight_1", "question": "What are the numbers of the shortest flights?", "rationale": ["Identify the relevant table, which is 'Flight'.", "Select the column to display, 'flno', which represents the flight numbers.", "Order the results by the 'distance' column in ascending order to find the shortest flights.", "Use a placeholder in the LIMIT clause to specify how many flight numbers to return."], "gold_sql": "SELECT flno FROM Flight ORDER BY distance ASC LIMIT 3", "source_tables": ["flight"], "description": "The virtual table lists the flight numbers from the 'Flight' table, ordered by the distance of the flights in ascending order. The placeholder in the LIMIT clause indicates the maximum number of flight numbers to return, allowing for the selection of the shortest flights.", "virtual_table": "SELECT flno FROM Flight ORDER BY distance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.258", "db_id": "flight_2", "question": "Which airports do not have departing or arriving flights?", "rationale": ["Identify the relevant table, which is 'Airports'.", "Select the column to display, 'AirportName'.", "Add a condition to filter out airports that have any flights by using a subquery that combines both source and destination airports from the 'Flights' table, ensuring that only airports without any flight activity are selected."], "gold_sql": "SELECT AirportName FROM Airports WHERE AirportCode NOT IN (SELECT SourceAirport FROM Flights UNION SELECT DestAirport FROM Flights)", "source_tables": ["airports", "flights"], "description": "The virtual table lists the names of airports from the 'Airports' table that do not have any flights either departing from or arriving at them. The query uses a subquery to identify all airport codes that are involved in flights, and the placeholder in the WHERE clause ensures that only airports without any flight activity are included.", "virtual_table": "SELECT AirportName FROM Airports WHERE AirportCode NOT IN (SELECT SourceAirport FROM Flights UNION SELECT DestAirport FROM Flights)"}
{"sample_id": "dev.243", "db_id": "flight_2", "question": "Find all airlines that have fewer than 200 flights.", "rationale": ["Identify the relevant tables, which are 'airlines' and 'flights'.", "Join the 'airlines' table with the 'flights' table on the airline identifier.", "Select the 'Airline' column from the 'airlines' table.", "Group the results by airline to aggregate flight counts.", "Use the HAVING clause to filter airlines based on the count of flights, using a placeholder for the numeric threshold."], "gold_sql": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  <  200", "source_tables": ["flights", "airlines"], "description": "The virtual table lists the names of airlines from the 'airlines' table that have a flight count below a specified threshold. The placeholder in the HAVING clause indicates the maximum number of flights an airline can have to be included in the results.", "virtual_table": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.241", "db_id": "flight_2", "question": "Find all airlines that have at least 10 flights.", "rationale": ["Identify the relevant tables, which are 'airlines' and 'flights'.", "Select the column to display, which is 'Airline' from the 'airlines' table.", "Join the 'airlines' table with the 'flights' table on the unique identifier of the airline.", "Group the results by the airline name to aggregate flight counts.", "Add a condition to filter the grouped results to include only those airlines with a flight count greater than a specified number using a placeholder for numeric values."], "gold_sql": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  >  10", "source_tables": ["flights", "airlines"], "description": "The virtual table lists the names of airlines from the 'airlines' table that have a specified number of flights. The query joins the 'airlines' and 'flights' tables based on the unique identifier of the airline, grouping the results by airline name and filtering to include only those with a flight count exceeding a placeholder for numeric values.", "virtual_table": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.244", "db_id": "flight_2", "question": "Which airlines have less than 200 flights?", "rationale": ["Identify the relevant tables, which are 'airlines' and 'flights'.", "Select the column to display, which is 'Airline' from the 'airlines' table.", "Join the 'airlines' table with the 'flights' table on the unique identifier of the airline.", "Group the results by the airline name to aggregate the flight counts.", "Add a condition to filter the grouped results to include only those airlines with a flight count less than the specified number using a placeholder for numeric values."], "gold_sql": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  <  200", "source_tables": ["flights", "airlines"], "description": "The virtual table lists the names of airlines from the 'airlines' table that operate fewer than a specified number of flights. The query joins the 'airlines' and 'flights' tables based on the airline's unique identifier, grouping the results by airline name and applying a condition to filter those with a flight count below the placeholder value.", "virtual_table": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.225", "db_id": "flight_2", "question": "What is the code of airport that has the highest number of flights?", "rationale": ["Identify the relevant tables, which are 'airports' and 'flights'.", "Join the two tables on the airport code to include both source and destination airports.", "Group the results by airport code to count the number of flights associated with each airport.", "Order the results in descending order based on the count of flights to find the airport with the highest number.", "Use a placeholder in the LIMIT clause to allow for flexibility in specifying the number of results to return."], "gold_sql": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "flights"], "description": "The virtual table provides the airport code of the airport that has the highest number of flights, either as a departure or arrival point. It aggregates data from the 'airports' and 'flights' tables, counting the total flights associated with each airport code and ordering them to identify the one with the most flights. The placeholder in the LIMIT clause allows for specifying how many top results to return.", "virtual_table": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.226", "db_id": "flight_2", "question": "What is the airport code of the airport with the most flights?", "rationale": ["Identify the relevant tables, which are 'airports' and 'flights'.", "Join the two tables on the airport code to include both source and destination airports.", "Group the results by the airport code to count the number of flights associated with each airport.", "Order the results in descending order based on the count of flights to find the airport with the most flights.", "Limit the results to a single entry using a placeholder for numeric values."], "gold_sql": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "flights"], "description": "The virtual table provides the airport code of the airport that has the highest number of flights, either as a departure or arrival point. It aggregates data from the 'airports' and 'flights' tables, grouping by airport code and ordering the results by the count of flights, with a limit specified by a placeholder for numeric values.", "virtual_table": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.229", "db_id": "flight_2", "question": "Which airline has most number of flights?", "rationale": ["Identify the relevant tables, which are 'AIRLINES' and 'FLIGHTS'.", "Join the two tables on the unique identifier for airlines to associate each flight with its respective airline.", "Select the 'Airline' column from the 'AIRLINES' table.", "Group the results by the 'Airline' to aggregate the flight counts.", "Order the results by the count of flights in descending order to find the airline with the most flights.", "Add a limit to the results using a placeholder for numeric values."], "gold_sql": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) DESC LIMIT 1", "source_tables": ["flights", "airlines"], "description": "The virtual table summarizes the airlines and their corresponding flight counts from the 'AIRLINES' and 'FLIGHTS' tables. It groups the results by airline name and orders them in descending order based on the number of flights, allowing the user to specify a limit on the number of results returned.", "virtual_table": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.194", "db_id": "flight_2", "question": "Give the airline with abbreviation 'UAL'.", "rationale": ["Identify the relevant table, which is 'airlines'.", "Select the column to display, 'Airline'.", "Add a condition to filter the 'Abbreviation' column for the specified abbreviation using a placeholder for string values."], "gold_sql": "SELECT Airline FROM AIRLINES WHERE Abbreviation  =  'UAL'", "source_tables": ["airlines"], "description": "The virtual table provides the name of the airline from the 'airlines' table that corresponds to a specific abbreviation. The placeholder in the WHERE clause represents the abbreviation of the airline.", "virtual_table": "SELECT Airline FROM AIRLINES WHERE Abbreviation  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.182", "db_id": "flight_2", "question": "Which abbreviation corresponds to Jetblue Airways?", "rationale": ["Identify the relevant table, which is 'airlines'.", "Select the column to display, 'Abbreviation'.", "Add a condition to filter the 'Airline' column for the specified airline using a placeholder for string values."], "gold_sql": "SELECT Abbreviation FROM AIRLINES WHERE Airline  =  'JetBlue Airways'", "source_tables": ["airlines"], "description": "The virtual table provides the abbreviation of airlines from the 'airlines' table based on the specified airline name. The placeholder in the WHERE clause represents the name of the airline for which the abbreviation is being queried.", "virtual_table": "SELECT Abbreviation FROM AIRLINES WHERE Airline  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.214", "db_id": "flight_2", "question": "Give the number of Jetblue Airways flights.", "rationale": ["Identify the relevant tables, which are 'flights' and 'airlines'.", "Use a JOIN to connect the 'flights' table with the 'airlines' table based on the airline's unique identifier.", "Select the count of flights from the 'flights' table.", "Add a condition to filter the results based on the airline's name using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T1.Airline  =  T2.uid WHERE T2.Airline = 'JetBlue Airways'", "source_tables": ["flights", "airlines"], "description": "The virtual table provides a count of flights operated by a specific airline from the 'flights' table, joined with the 'airlines' table to filter by the airline's name. The placeholder in the WHERE clause represents the name of the airline for which the flight count is requested.", "virtual_table": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T1.Airline  =  T2.uid WHERE T2.Airline = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.180", "db_id": "flight_2", "question": "What country is Jetblue Airways affiliated with?", "rationale": ["Identify the relevant table, which is 'airlines'.", "Select the column to display, 'Country'.", "Add a condition to filter the 'Airline' column for the specified airline using a placeholder for string values."], "gold_sql": "SELECT Country FROM AIRLINES WHERE Airline  =  'JetBlue Airways'", "source_tables": ["airlines"], "description": "The virtual table provides information about the country associated with a specific airline. The placeholder in the WHERE clause allows for the input of the airline's name to filter the results accordingly.", "virtual_table": "SELECT Country FROM AIRLINES WHERE Airline  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6852", "db_id": "flight_4", "question": "What is the number of cities in the United States with more than 3 airports?", "rationale": ["Identify the relevant table, which is 'airports'.", "Select the 'city' column to display the cities.", "Add a condition to filter the 'country' column for the specified country using a placeholder for string values.", "Group the results by 'city' to aggregate the data.", "Use the HAVING clause to filter cities that have more than a specified number of airports, using a placeholder for numeric values."], "gold_sql": "SELECT city FROM airports WHERE country  =  'United States' GROUP BY city HAVING count(*)  >  3", "source_tables": ["airports"], "description": "The virtual table provides a list of cities from the 'airports' table located in a specific country, grouped by city. It includes a condition to filter cities that have more than a specified number of airports, represented by a placeholder for numeric values. The placeholder in the WHERE clause indicates the country, while the HAVING clause specifies the minimum number of airports required for the city to be included in the results.", "virtual_table": "SELECT city FROM airports WHERE country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY city HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6843", "db_id": "flight_4", "question": "Which countries has the most number of airlines whose active status is 'Y'?", "rationale": ["Identify the relevant table, which is 'airlines'.", "Select the 'country' column to display.", "Add a condition to filter the 'active' column for the specified status using a placeholder for string values.", "Group the results by 'country' to aggregate the counts of active airlines.", "Order the results in descending order based on the count of airlines and limit the output using placeholders."], "gold_sql": "SELECT country FROM airlines WHERE active  =  'Y' GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airlines"], "description": "The virtual table summarizes the countries that have the highest number of active airlines. It filters the airlines based on their active status and groups the results by country, allowing for an ordered list of countries based on the count of active airlines. The placeholders represent the active status and the limit for the number of results to return.", "virtual_table": "SELECT country FROM airlines WHERE active  =  [PLACEHOLDER-TYPE:STRING] GROUP BY country ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6857", "db_id": "flight_4", "question": "List the cities which have more than 2 airports sorted by the number of airports.", "rationale": ["Identify the relevant table, which is 'airports'.", "Select the 'city' column to display the names of cities.", "Group the results by 'city' to aggregate the number of airports per city.", "Add a condition to filter cities that have more than a specified number of airports using a placeholder for numeric values.", "Sort the results by the count of airports in descending order."], "gold_sql": "SELECT city FROM airports GROUP BY city HAVING count(*)  >  2 ORDER BY count(*)", "source_tables": ["airports"], "description": "The virtual table summarizes the cities that have a significant number of airports, specifically those with more than a specified threshold. The results are grouped by city and sorted based on the count of airports in descending order, allowing users to identify cities with a high concentration of airport facilities.", "virtual_table": "SELECT city FROM airports GROUP BY city HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER] ORDER BY count(*)"}
{"sample_id": "train.6883", "db_id": "flight_4", "question": "Find the busiest destination airport that runs most number of routes in China.", "rationale": ["Identify the relevant tables, which are 'airports' and 'routes'.", "Select the column to display, which is the airport name from the 'airports' table.", "Join the 'airports' table with the 'routes' table on the destination airport ID to associate routes with airports.", "Add a condition to filter the 'country' column for the specified country using a placeholder for string values.", "Group the results by airport name to aggregate the route counts.", "Order the results by the count of routes in descending order to find the busiest airport.", "Limit the results to return only the top entry."], "gold_sql": "SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.country  =  'China' GROUP BY T1.name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "description": "The virtual table provides the names of destination airports from the 'airports' table that are located in a specific country, specifically China. It joins the 'routes' table to count the number of routes associated with each airport. The results are grouped by airport name and ordered by the count of routes in descending order, with a limit applied to return only the busiest airport.", "virtual_table": "SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6868", "db_id": "flight_4", "question": "What is the total number of routes for each country and airline in that country?", "rationale": ["Identify the relevant tables, which are 'airlines' and 'routes'.", "Select the 'country' and 'name' columns from the 'airlines' table.", "Count the number of routes by using the COUNT function.", "Join the 'airlines' table with the 'routes' table on the airline ID to associate routes with their respective airlines.", "Group the results by 'country' and 'name' to get the total number of routes for each airline in each country."], "gold_sql": "SELECT T1.country ,  T1.name ,  count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.country ,  T1.name", "source_tables": ["routes", "airlines"], "description": "The virtual table summarizes the total number of routes associated with each airline, categorized by the country where the airline is based. It combines data from the 'airlines' and 'routes' tables, using the airline ID as a link between them. The placeholders represent the country and airline name, while the count reflects the number of routes for each airline in that country.", "virtual_table": "SELECT T1.country ,  T1.name ,  count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.country ,  T1.name"}
{"sample_id": "train.6884", "db_id": "flight_4", "question": "What is the name of the airport that is the destination of the most number of routes that start in China?", "rationale": ["Identify the relevant tables, which are 'airports' and 'routes'.", "Join the 'airports' table with the 'routes' table on the destination airport ID.", "Filter the results based on the specified country using a placeholder for string values.", "Group the results by airport name to aggregate the count of routes.", "Order the results in descending order based on the count of routes to find the most popular destination.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.country  =  'China' GROUP BY T1.name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "description": "The virtual table provides the names of airports that serve as destinations for routes originating from a specific country. It joins the 'airports' table with the 'routes' table to filter for destination airports based on the country specified. The results are grouped by airport name and ordered by the count of routes, allowing the user to identify the airport with the highest number of routes. The placeholders represent the country name and the limit on the number of results to return.", "virtual_table": "SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6837", "db_id": "flight_4", "question": "Find the name and city of the airport which is the source for the most number of flight routes.", "rationale": ["Identify the relevant tables, which are 'airports' and 'routes'.", "Select the columns to display: 'name' and 'city' from the 'airports' table, and 'src_apid' from the 'routes' table.", "Join the 'airports' table with the 'routes' table on the airport ID to correlate source airports with their routes.", "Group the results by the source airport ID to count the number of routes for each airport.", "Order the results by the count of routes in descending order to find the airport with the most routes.", "Add a limit to the results to allow the user to specify how many records they want to retrieve."], "gold_sql": "SELECT T1.name ,  T1.city ,  T2.src_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T2.src_apid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "description": "The virtual table provides the names and cities of airports that serve as the source for flight routes, along with a count of those routes. It aggregates data from the 'airports' and 'routes' tables, joining them on the airport ID. The results are grouped by the source airport ID and ordered by the number of routes in descending order, allowing the user to specify a limit on the number of records returned.", "virtual_table": "SELECT T1.name ,  T1.city ,  T2.src_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T2.src_apid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6859", "db_id": "flight_4", "question": "Find the number of routes for each source airport and the airport name.", "rationale": ["Identify the relevant tables, which are 'routes' and 'airports'.", "Select the count of routes and the name of the source airport from the 'airports' table.", "Join the 'airports' table with the 'routes' table on the source airport ID.", "Group the results by the airport name to aggregate the count of routes for each source airport."], "gold_sql": "SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name", "source_tables": ["airports", "routes"], "description": "The virtual table summarizes the count of routes originating from each source airport along with the corresponding airport names. It combines data from the 'routes' and 'airports' tables, using a join on the source airport ID, and groups the results by the airport name to provide a count of routes for each airport.", "virtual_table": "SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name"}
{"sample_id": "train.6860", "db_id": "flight_4", "question": "For each airport name, how many routes start at that airport?", "rationale": ["Identify the relevant tables, which are 'airports' and 'routes'.", "Select the count of routes and the airport name from the 'airports' table.", "Join the 'airports' table with the 'routes' table on the source airport ID to link routes to their respective airports.", "Group the results by the airport name to get the total number of routes for each airport."], "gold_sql": "SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name", "source_tables": ["airports", "routes"], "description": "The virtual table provides a count of routes originating from each airport, along with the corresponding airport names. It combines data from the 'airports' table and the 'routes' table, using a join on the source airport ID. The result is grouped by the airport name to aggregate the number of routes for each airport.", "virtual_table": "SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name"}
{"sample_id": "train.6841", "db_id": "flight_4", "question": "Which countries has the most number of airlines?", "rationale": ["Identify the relevant table, which is 'airlines'.", "Select the 'country' column to display.", "Group the results by 'country' to count the number of airlines in each country.", "Order the results in descending order based on the count of airlines.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT country FROM airlines GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airlines"], "description": "The virtual table summarizes the countries that have the highest number of airlines by grouping the airline data based on the country. The placeholder in the LIMIT clause indicates the maximum number of countries to be returned in the result.", "virtual_table": "SELECT country FROM airlines GROUP BY country ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6862", "db_id": "flight_4", "question": "For each  airport name, how many routes start at that airport, ordered from most to least?", "rationale": ["Identify the relevant tables, which are 'airports' and 'routes'.", "Select the count of routes and the airport name from the 'airports' table.", "Join the 'airports' table with the 'routes' table on the source airport ID.", "Group the results by the airport name to get the count of routes for each airport.", "Order the results by the count of routes in descending order."], "gold_sql": "SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name ORDER BY count(*) DESC", "source_tables": ["airports", "routes"], "description": "The virtual table provides a count of routes originating from each airport, along with the corresponding airport names. It aggregates the data from the 'airports' and 'routes' tables, using a join on the source airport ID. The results are grouped by airport name and ordered by the number of routes in descending order.", "virtual_table": "SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name ORDER BY count(*) DESC"}
{"sample_id": "train.6831", "db_id": "flight_4", "question": "Find the name, city, and country of the airport that has the highest latitude.", "rationale": ["Identify the relevant table, which is 'airports'.", "Select the columns to display: 'name', 'city', and 'country'.", "Sort the results by the 'elevation' column in descending order to find the airport with the highest elevation.", "Use a placeholder in the LIMIT clause to specify how many results to return."], "gold_sql": "SELECT name ,  city ,  country FROM airports ORDER BY elevation DESC LIMIT 1", "source_tables": ["airports"], "description": "The virtual table provides the name, city, and country of airports from the 'airports' table, sorted by their elevation in descending order. The placeholder in the LIMIT clause indicates the number of top results to return, which can be adjusted as needed.", "virtual_table": "SELECT name ,  city ,  country FROM airports ORDER BY elevation DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6835", "db_id": "flight_4", "question": "Find the names of the top 10 airlines that operate the most number of routes.", "rationale": ["Identify the relevant tables, which are 'airlines' and 'routes'.", "Join the 'airlines' table with the 'routes' table on the airline ID to associate each airline with its routes.", "Select the airline name and ID for display.", "Group the results by airline ID to count the number of routes each airline operates.", "Order the results in descending order based on the count of routes to identify the top airlines.", "Use a placeholder in the LIMIT clause to allow the user to specify how many top airlines to return."], "gold_sql": "SELECT T1.name ,  T2.alid FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T2.alid ORDER BY count(*) DESC LIMIT 10", "source_tables": ["routes", "airlines"], "description": "The virtual table provides the names and unique identifiers of airlines that operate routes, sorted by the number of routes they manage. The placeholder in the LIMIT clause allows for specifying the number of top airlines to retrieve.", "virtual_table": "SELECT T1.name ,  T2.alid FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T2.alid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6873", "db_id": "flight_4", "question": "Find the number of routes that have destination John F Kennedy International Airport.", "rationale": ["Identify the relevant tables, which are 'airports' and 'routes'.", "Join the 'airports' table with the 'routes' table on the airport ID to link routes to their destination airports.", "Select the count of routes by using the count(*) function.", "Add a condition to filter the results based on the destination airport's name using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.name  =  'John F Kennedy International Airport'", "source_tables": ["airports", "routes"], "description": "The virtual table summarizes the count of routes from the 'routes' table that have a specific destination airport, identified by its name. The placeholder in the WHERE clause represents the name of the destination airport.", "virtual_table": "SELECT count(*) FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6872", "db_id": "flight_4", "question": "What is the number of routes operated by the airline American Airlines whose destinations are in Italy?", "rationale": ["Identify the relevant tables: 'routes', 'airports', and 'airlines'.", "Count the total number of routes by using the count(*) function.", "Join the 'routes' table with the 'airports' table on the destination airport ID to access the country information.", "Join the 'routes' table with the 'airlines' table on the airline ID to filter by the airline's name.", "Add conditions in the WHERE clause to filter by the specified country and airline using placeholders."], "gold_sql": "SELECT count(*) FROM routes AS T1 JOIN airports AS T2 ON T1.dst_apid  =  T2.apid JOIN airlines AS T3 ON T1.alid  =  T3.alid WHERE T2.country  =  'Italy' AND T3.name  =  'American Airlines'", "source_tables": ["routes", "airlines", "airports"], "description": "The virtual table summarizes the count of routes from the 'routes' table that are operated by a specific airline and have destinations in a particular country. It joins the 'routes' table with the 'airports' table to filter by the destination country's identifier and with the 'airlines' table to filter by the airline's name. The placeholders in the WHERE clause represent the country and airline name respectively.", "virtual_table": "SELECT count(*) FROM routes AS T1 JOIN airports AS T2 ON T1.dst_apid  =  T2.apid JOIN airlines AS T3 ON T1.alid  =  T3.alid WHERE T2.country  =  [PLACEHOLDER-TYPE:STRING] AND T3.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6822", "db_id": "flight_4", "question": "How many airports' names have the word Interanation in them?", "rationale": ["Identify the relevant table, which is 'airports'.", "Select the count of rows that match the condition.", "Add a condition to filter the 'name' column using a LIKE clause with a placeholder for string values."], "gold_sql": "SELECT count(*) FROM airports WHERE name LIKE '%International%'", "source_tables": ["airports"], "description": "The virtual table provides a count of airport names from the 'airports' table that contain a specific substring. The placeholder in the WHERE clause is used to represent the substring that is being searched for within the airport names.", "virtual_table": "SELECT count(*) FROM airports WHERE name LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6825", "db_id": "flight_4", "question": "Find the number of routes operated by American Airlines.", "rationale": ["Identify the relevant tables, which are 'airlines' and 'routes'.", "Count the total number of routes by using the count(*) function.", "Join the 'airlines' table with the 'routes' table on the airline ID to associate routes with their respective airlines.", "Add a condition to filter the results based on the airline's name using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid WHERE T1.name  =  'American Airlines'", "source_tables": ["routes", "airlines"], "description": "The virtual table summarizes the count of routes associated with a specific airline from the 'routes' and 'airlines' tables. It joins these tables based on the airline ID and filters the results to include only those routes operated by the specified airline name.", "virtual_table": "SELECT count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6379", "db_id": "flight_company", "question": "List the name of the pilots who have flied for both a company that mainly provide 'Cargo' services and a company that runs 'Catering services' activities.", "rationale": ["Identify the relevant tables, which are 'operate_company' and 'flight'.", "Select the column to display, which is 'pilot' from the 'flight' table.", "Use JOIN to connect the 'operate_company' and 'flight' tables based on the company ID.", "Apply an INTERSECT operation to find pilots who have flown for both types of companies by filtering the 'principal_activities' column with placeholders for the specified service types."], "gold_sql": "SELECT T2.pilot FROM operate_company AS T1 JOIN flight AS t2 ON T1.id  =  T2.company_id WHERE T1.principal_activities  =  'Cargo' INTERSECT SELECT T2.pilot FROM operate_company AS T1 JOIN flight AS t2 ON T1.id  =  T2.company_id WHERE T1.principal_activities  =  'Catering services'", "source_tables": ["flight", "operate_company"], "description": "The virtual table lists the names of pilots from the 'flight' table who have operated flights for companies that primarily provide specific services. It uses an intersection of two queries to ensure that the pilots have flown for both a company focused on cargo services and another that specializes in catering services. The placeholders in the WHERE clauses represent the types of principal activities of the companies.", "virtual_table": "SELECT T2.pilot FROM operate_company AS T1 JOIN flight AS t2 ON T1.id  =  T2.company_id WHERE T1.principal_activities  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.pilot FROM operate_company AS T1 JOIN flight AS t2 ON T1.id  =  T2.company_id WHERE T1.principal_activities  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6381", "db_id": "flight_company", "question": "How many companies operates airlines in each airport?", "rationale": ["Identify the relevant tables: 'operate_company', 'flight', and 'airport'.", "Join the 'operate_company' table with the 'flight' table using the company identifier to associate flights with their operating companies.", "Join the resulting table with the 'airport' table using the airport identifier to link flights to their respective airports.", "Count the number of companies for each airport by grouping the results based on the airport's unique identifier."], "gold_sql": "SELECT T3.id ,  count(*) FROM operate_company AS T1 JOIN flight AS t2 ON T1.id  =  T2.company_id JOIN airport AS T3 ON T2.airport_id  =  T3.id GROUP BY T3.id", "source_tables": ["airport", "flight", "operate_company"], "description": "The virtual table provides a count of operating companies that manage airlines at each airport. It combines data from the 'operate_company', 'flight', and 'airport' tables, linking them through their respective identifiers. The result is grouped by each airport's unique identifier, allowing for a summary of airline operations per airport.", "virtual_table": "SELECT T3.id ,  count(*) FROM operate_company AS T1 JOIN flight AS t2 ON T1.id  =  T2.company_id JOIN airport AS T3 ON T2.airport_id  =  T3.id GROUP BY T3.id"}
{"sample_id": "train.6371", "db_id": "flight_company", "question": "What are the names and types of the companies that have ever operated a flight?", "rationale": ["Identify the relevant tables, which are 'operate_company' and 'flight'.", "Select the columns to display, 'name' and 'Type' from the 'operate_company' table.", "Use a JOIN operation to connect the 'operate_company' table with the 'flight' table based on the company identifier, ensuring that only companies that have operated flights are included."], "gold_sql": "SELECT T1.name ,  T1.type FROM operate_company AS T1 JOIN flight AS t2 ON T1.id  =  T2.company_id", "source_tables": ["flight", "operate_company"], "description": "The virtual table presents the names and types of operating companies from the 'operate_company' table that have been associated with flights recorded in the 'flight' table. The join condition links the companies to their respective flights using the company identifier.", "virtual_table": "SELECT T1.name ,  T1.type FROM operate_company AS T1 JOIN flight AS t2 ON T1.id  =  T2.company_id"}
{"sample_id": "train.2225", "db_id": "formula_1", "question": "What are the average fastest lap speed in races held after 2004 grouped by race name and ordered by year?", "rationale": ["Identify the relevant tables, which are 'races' and 'results'.", "Select the average of the 'fastestLapSpeed' from the 'results' table and the 'name' and 'year' from the 'races' table.", "Join the 'races' and 'results' tables on the race identifier to correlate race details with results.", "Add a condition to filter the races based on the specified year using a placeholder for numeric values.", "Group the results by race name to calculate the average speed for each race.", "Order the results by the year of the race."], "gold_sql": "SELECT avg(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "description": "The virtual table provides the average fastest lap speed of drivers in races held after a specified year, grouped by the race name and ordered by the year of the race. The placeholders allow users to specify the year for filtering the races.", "virtual_table": "SELECT avg(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.name ORDER BY T1.year"}
{"sample_id": "train.2179", "db_id": "formula_1", "question": "Find the id and forenames of drivers who participated both the races with name Australian Grand Prix and the races with name Chinese Grand Prix?", "rationale": ["Identify the relevant tables: 'races', 'results', and 'drivers'.", "Select the columns to display: 'driverId' and 'forename'.", "Join the 'races' table with the 'results' table to link races with their corresponding results.", "Join the 'results' table with the 'drivers' table to get driver information.", "Use the INTERSECT operator to find drivers who participated in both specified races, filtering by race names using placeholders."], "gold_sql": "SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = 'Australian Grand Prix' INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = 'Chinese Grand Prix'", "source_tables": ["races", "drivers", "results"], "description": "The virtual table provides the driver IDs and forenames of drivers who participated in both the races named 'Australian Grand Prix' and 'Chinese Grand Prix'. It utilizes an INTERSECT operation to ensure that only drivers who appear in both race results are included. The placeholders in the WHERE clauses represent the names of the races being queried.", "virtual_table": "SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2182", "db_id": "formula_1", "question": "What are the first and last names of all drivers who participated in the Australian Grand Prix but not the Chinese Grand Prix?", "rationale": ["Identify the relevant tables: 'races', 'results', and 'drivers'.", "Select the columns to display, which are 'forename' and 'surname' from the 'drivers' table.", "Join the 'races' table with the 'results' table to link races with their results, and then join with the 'drivers' table to get driver names.", "Use a WHERE clause to filter for the Australian Grand Prix and use EXCEPT to exclude drivers who participated in the Chinese Grand Prix, with placeholders for the race names."], "gold_sql": "SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Australian Grand Prix' EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Chinese Grand Prix'", "source_tables": ["races", "drivers", "results"], "description": "The virtual table provides the first and last names of drivers who participated in a specific race, in this case, the Australian Grand Prix, while excluding those who participated in another specified race, the Chinese Grand Prix. The placeholders in the query represent the names of the races being filtered.", "virtual_table": "SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2185", "db_id": "formula_1", "question": "Find all the forenames of distinct drivers who won in position 1 as driver standing and had more than 20 points?", "rationale": ["Identify the relevant tables, which are 'drivers' and 'driverStandings'.", "Select the 'forename' column from the 'drivers' table and ensure the results are distinct.", "Join the 'drivers' table with the 'driverStandings' table on the driver ID to correlate driver information with their standings.", "Add conditions to filter for drivers who have a winning position, a specified number of wins, and more than a certain number of points using placeholders for numeric values."], "gold_sql": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = 1 AND T2.wins = 1 AND T2.points > 20", "source_tables": ["drivers", "driverstandings"], "description": "The virtual table describes the distinct forenames of drivers from the 'drivers' table who have achieved a winning position in the driver standings. The placeholders in the WHERE clause represent the specific winning position, the number of wins, and the minimum points threshold required for selection.", "virtual_table": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = [PLACEHOLDER-TYPE:NUMBER] AND T2.wins = [PLACEHOLDER-TYPE:NUMBER] AND T2.points > [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2180", "db_id": "formula_1", "question": "What is the id and first name of all the drivers who participated in the Australian Grand Prix and the Chinese Grand Prix?", "rationale": ["Identify the relevant tables: 'races', 'results', and 'drivers'.", "Select the columns to display: 'driverId' from the results table and 'forename' from the drivers table.", "Join the 'races' table with the 'results' table on 'raceId' to link races with their results.", "Join the 'results' table with the 'drivers' table on 'driverId' to link results with driver information.", "Use the INTERSECT operator to find drivers who participated in both specified races, filtering by race names using placeholders."], "gold_sql": "SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = 'Australian Grand Prix' INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = 'Chinese Grand Prix'", "source_tables": ["races", "drivers", "results"], "description": "The virtual table provides the driver IDs and first names of drivers who participated in both the Australian Grand Prix and the Chinese Grand Prix. It combines results from the 'races', 'results', and 'drivers' tables, filtering based on the race names specified in the placeholders.", "virtual_table": "SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2181", "db_id": "formula_1", "question": "What are the forenames and surnames of drivers who participated in the races named Australian Grand Prix but not the races named Chinese Grand Prix?", "rationale": ["Identify the relevant tables: 'races', 'results', and 'drivers'.", "Join the 'races' table with the 'results' table to link races with their results.", "Join the 'results' table with the 'drivers' table to get driver information.", "Use a WHERE clause to filter for the 'Australian Grand Prix' race name using a placeholder.", "Use an EXCEPT clause to exclude drivers from the 'Chinese Grand Prix' race name, also using a placeholder."], "gold_sql": "SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Australian Grand Prix' EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Chinese Grand Prix'", "source_tables": ["races", "drivers", "results"], "description": "The virtual table provides the forenames and surnames of drivers who participated in specific races. It includes drivers from the 'races' table filtered by the race names, specifically including those from the 'Australian Grand Prix' while excluding those from the 'Chinese Grand Prix'. The placeholders in the query represent the names of the races.", "virtual_table": "SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2190", "db_id": "formula_1", "question": "For each constructor id, how many races are there?", "rationale": ["Identify the relevant table, which is 'constructorStandings'.", "Count the number of races for each constructor using the count(*) function.", "Group the results by 'constructorId' to aggregate the race counts for each constructor."], "gold_sql": "SELECT count(*) ,  constructorid FROM constructorStandings GROUP BY constructorid", "source_tables": ["constructorstandings"], "description": "The virtual table summarizes the count of races associated with each constructor from the 'constructorStandings' table. The results are grouped by the constructor identifier, allowing users to see how many races each constructor has participated in.", "virtual_table": "SELECT count(*) ,  constructorid FROM constructorStandings GROUP BY constructorid"}
{"sample_id": "train.2184", "db_id": "formula_1", "question": "What are all the different first names of the drivers who are in position as standing and won?", "rationale": ["Identify the relevant tables, which are 'drivers' and 'driverstandings'.", "Select the 'forename' column from the 'drivers' table, ensuring distinct values are returned.", "Join the 'drivers' table with the 'driverstandings' table on the 'driverId' to correlate driver information with their standings.", "Add conditions to filter the results based on the specified standing position and the number of wins using placeholders for numeric values."], "gold_sql": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = 1 AND T2.wins = 1", "source_tables": ["drivers", "driverstandings"], "description": "The virtual table provides a list of distinct first names of drivers from the 'drivers' table who are currently in a specific standing position and have achieved a certain number of wins. The placeholders in the WHERE clause allow for filtering based on the driver's standing position and the number of wins they have.", "virtual_table": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = [PLACEHOLDER-TYPE:NUMBER] AND T2.wins = [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2189", "db_id": "formula_1", "question": "What are the numbers of races for each constructor id?", "rationale": ["Identify the relevant table, which is 'constructorStandings'.", "Select the count of races and the constructor ID to display.", "Group the results by the constructor ID to aggregate the race counts for each constructor."], "gold_sql": "SELECT count(*) ,  constructorid FROM constructorStandings GROUP BY constructorid", "source_tables": ["constructorstandings"], "description": "The virtual table summarizes the total number of races associated with each constructor from the 'constructorStandings' table. The results are grouped by the constructor's unique identifier, allowing for an aggregated count of races per constructor.", "virtual_table": "SELECT count(*) ,  constructorid FROM constructorStandings GROUP BY constructorid"}
{"sample_id": "train.2176", "db_id": "formula_1", "question": "What are the names and years of all races that had a driver with the last name Lewis?", "rationale": ["Identify the relevant tables: 'results' for race results, 'races' for race details, and 'drivers' for driver information.", "Select the columns to display: 'name' and 'year' from the 'races' table.", "Join the 'results' table with the 'races' table on 'raceId' to connect race results to their respective races.", "Join the 'results' table with the 'drivers' table on 'driverId' to connect race results to the drivers.", "Add a condition to filter the driver's first name using a placeholder for string values."], "gold_sql": "SELECT T2.name ,  T2.year FROM results AS T1 JOIN races AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T1.driverid = T3.driverid WHERE T3.forename = 'Lewis'", "source_tables": ["results", "drivers", "races"], "description": "The virtual table provides the names and years of races from the 'races' table that involved a specific driver. It combines data from the 'results' table to link drivers to their respective races, filtering based on the driver's first name using a placeholder for string values.", "virtual_table": "SELECT T2.name ,  T2.year FROM results AS T1 JOIN races AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T1.driverid = T3.driverid WHERE T3.forename = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2167", "db_id": "formula_1", "question": "What is the id and family name of the driver who has the longest laptime?", "rationale": ["Identify the relevant tables, which are 'drivers' and 'lapTimes'.", "Select the columns to display, 'driverId' and 'surname'.", "Join the 'drivers' table with the 'lapTimes' table on the 'driverId' to correlate drivers with their lap times.", "Order the results by the 'milliseconds' column in descending order to find the longest lap time.", "Use a placeholder in the LIMIT clause to specify how many results to return."], "gold_sql": "SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT 1", "source_tables": ["laptimes", "drivers"], "description": "The virtual table provides the driver ID and surname of drivers from the 'drivers' table who have recorded lap times in the 'lapTimes' table. The results are ordered by the lap time in milliseconds in descending order, allowing the identification of the driver with the longest lap time. The placeholder in the LIMIT clause indicates the number of results to return.", "virtual_table": "SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2222", "db_id": "formula_1", "question": "What is the maximum fastest lap speed in the Monaco Grand Prix in 2008?", "rationale": ["Identify the relevant tables, which are 'races' and 'results'.", "Select the maximum value of the 'fastestLapSpeed' from the 'results' table.", "Join the 'races' table with the 'results' table on the race identifier to correlate race details with results.", "Add conditions to filter the results based on the specified year and race name using placeholders for numeric and string values."], "gold_sql": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "description": "The virtual table provides the maximum fastest lap speed recorded during a specific race, identified as the Monaco Grand Prix in a particular year. It combines data from the 'races' table and the 'results' table, using placeholders to filter by the year and the race name.", "virtual_table": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T1.name = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2168", "db_id": "formula_1", "question": "What is the id and last name of the driver with the longest laptime?", "rationale": ["Identify the relevant tables, which are 'drivers' and 'lapTimes'.", "Select the columns to display, 'driverId' and 'surname'.", "Join the 'drivers' table with the 'lapTimes' table on the 'driverId' to correlate drivers with their lap times.", "Order the results by the 'milliseconds' column in descending order to find the longest lap time.", "Limit the results to a specific number using a placeholder for numeric values."], "gold_sql": "SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT 1", "source_tables": ["laptimes", "drivers"], "description": "The virtual table provides the driver ID and last name of drivers from the 'drivers' table who have recorded lap times in the 'lapTimes' table. The results are ordered by the lap time in milliseconds in descending order, allowing the identification of the driver with the longest lap time. The placeholder in the LIMIT clause indicates the number of results to return.", "virtual_table": "SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2220", "db_id": "formula_1", "question": "What is the average fastest lap speed for the Monaco Grand Prix in 2008?", "rationale": ["Identify the relevant tables, which are 'races' and 'results'.", "Select the average of the 'fastestLapSpeed' from the 'results' table.", "Join the 'races' table with the 'results' table on the race identifier to correlate race data with results.", "Add conditions to filter the results based on the specified year and race name using placeholders for numeric and string values."], "gold_sql": "SELECT avg(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "description": "The virtual table provides the average fastest lap speed recorded during a specific race, identified as the Monaco Grand Prix in a particular year. It combines data from the 'races' and 'results' tables, where the year and race name are specified using placeholders for numeric and string values, respectively.", "virtual_table": "SELECT avg(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T1.name = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6017", "db_id": "game_1", "question": "What is the first name and last name of the student who have most number of sports?", "rationale": ["Identify the relevant tables, which are 'SportsInfo' and 'Student'.", "Join the 'SportsInfo' table with the 'Student' table using the 'StuID' column to link students with their sports participation.", "Select the columns to display, 'Fname' and 'Lname' from the 'Student' table.", "Group the results by 'StuID' to count the number of sports each student is involved in.", "Order the results in descending order based on the count of sports to find the student with the most participation.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT T2.Fname ,  T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID GROUP BY T1.StuID ORDER BY count(*) DESC LIMIT 1", "source_tables": ["sportsinfo", "student"], "description": "The virtual table describes the first and last names of students from the 'Student' table who are involved in sports, sorted by the number of sports they participate in. The placeholder in the LIMIT clause indicates the maximum number of students to return based on their sports participation count.", "virtual_table": "SELECT T2.Fname ,  T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID GROUP BY T1.StuID ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6029", "db_id": "game_1", "question": "Show total hours per week and number of games played for student David Shieber.", "rationale": ["Identify the relevant tables, which are 'SportsInfo' and 'Student'.", "Select the aggregated columns to display: total hours per week and total games played.", "Join the 'SportsInfo' table with the 'Student' table on the student identifier (StuID).", "Add conditions to filter the results based on the specified student's first and last names using placeholders for string values."], "gold_sql": "SELECT sum(hoursperweek) ,  sum(gamesplayed) FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.Fname  =  'David' AND T2.Lname  =  'Shieber'", "source_tables": ["sportsinfo", "student"], "description": "The virtual table summarizes the total hours per week dedicated to sports and the total number of games played by a specific student. It combines data from the 'SportsInfo' table and the 'Student' table, using the student's first and last names as criteria for filtering the results.", "virtual_table": "SELECT sum(hoursperweek) ,  sum(gamesplayed) FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.Fname  =  [PLACEHOLDER-TYPE:STRING] AND T2.Lname  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6025", "db_id": "game_1", "question": "Show student ids who are female and play football.", "rationale": ["Identify the relevant tables, which are 'Student' and 'SportsInfo'.", "Select the column to display, 'StuID', from both tables.", "Add a condition to filter the 'sex' column for female students using a placeholder for string values.", "Use an INTERSECT to combine results from both queries, ensuring that only student IDs that meet both criteria are returned."], "gold_sql": "SELECT StuID FROM Student WHERE sex  =  'F' INTERSECT SELECT StuID FROM Sportsinfo WHERE sportname  =  'Football'", "source_tables": ["sportsinfo", "student"], "description": "The virtual table provides a list of student IDs from the 'Student' table who are identified as female and also participate in football, as indicated in the 'SportsInfo' table. The placeholders in the WHERE clause represent the gender and the sport name being queried.", "virtual_table": "SELECT StuID FROM Student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT StuID FROM Sportsinfo WHERE sportname  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6019", "db_id": "game_1", "question": "Which sport has most number of students on scholarship?", "rationale": ["Identify the relevant table, which is 'SportsInfo'.", "Select the column to display, 'SportName'.", "Add a condition to filter the 'OnScholarship' column for students who are on scholarship using a placeholder for string values.", "Group the results by 'SportName' to aggregate the data.", "Order the results by the count of students in descending order to find the sport with the most students on scholarship.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT sportname FROM Sportsinfo WHERE onscholarship  =  'Y' GROUP BY sportname ORDER BY count(*) DESC LIMIT 1", "source_tables": ["sportsinfo"], "description": "The virtual table summarizes the names of sports from the 'SportsInfo' table where students are on a sports scholarship. The query groups the results by sport name and orders them by the count of students in descending order, allowing the identification of the sport with the highest number of students on scholarship. Placeholders are used for the scholarship status and the limit on the number of results returned.", "virtual_table": "SELECT sportname FROM Sportsinfo WHERE onscholarship  =  [PLACEHOLDER-TYPE:STRING] GROUP BY sportname ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6013", "db_id": "game_1", "question": "Show all student IDs with the number of sports and total number of games played", "rationale": ["Identify the relevant table, which is 'SportsInfo'.", "Select the 'StuID' column to display the unique student identifiers.", "Use the COUNT function to count the number of sports for each student.", "Use the SUM function to calculate the total number of games played by each student.", "Group the results by 'StuID' to ensure each student's data is aggregated correctly."], "gold_sql": "SELECT StuID ,  count(*) ,  sum(gamesplayed) FROM Sportsinfo GROUP BY StuID", "source_tables": ["sportsinfo"], "description": "The virtual table summarizes the unique student identifiers along with the count of sports each student participates in and the total number of games they have played. The data is aggregated from the 'SportsInfo' table, grouping the results by each student's ID.", "virtual_table": "SELECT StuID ,  count(*) ,  sum(gamesplayed) FROM Sportsinfo GROUP BY StuID"}
{"sample_id": "train.6024", "db_id": "game_1", "question": "What are the student ids for those on scholarship in major number 600?", "rationale": ["Identify the relevant tables, which are 'Student' and 'SportsInfo'.", "Select the 'StuID' column from both tables to find the student identifiers.", "Add a condition to filter the 'major' column in the 'Student' table using a placeholder for numeric values.", "Add a condition to filter the 'OnScholarship' column in the 'SportsInfo' table using a placeholder for string values.", "Use the INTERSECT operator to find common student IDs from both queries."], "gold_sql": "SELECT StuID FROM Student WHERE major  =  600 INTERSECT SELECT StuID FROM Sportsinfo WHERE onscholarship  =  'Y'", "source_tables": ["sportsinfo", "student"], "description": "The virtual table identifies the unique student identifiers from the 'Student' table for students who are enrolled in a specific major and are also participating in sports on a scholarship. The placeholders in the query represent the major number and the scholarship status.", "virtual_table": "SELECT StuID FROM Student WHERE major  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT StuID FROM Sportsinfo WHERE onscholarship  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6027", "db_id": "game_1", "question": "Show all male student ids who don't play football.", "rationale": ["Identify the relevant table, which is 'Student', to retrieve student IDs.", "Filter the results to include only male students by using a placeholder for the gender.", "Use the EXCEPT clause to exclude student IDs from the 'SportsInfo' table where the sport name matches football, using a placeholder for the sport name."], "gold_sql": "SELECT StuID FROM Student WHERE sex  =  'M' EXCEPT SELECT StuID FROM Sportsinfo WHERE sportname  =  'Football'", "source_tables": ["sportsinfo", "student"], "description": "The virtual table lists the unique identifiers of male students from the 'Student' table who are not involved in playing football. The placeholders in the query represent the gender and the sport name, allowing for flexible input to filter the results accordingly.", "virtual_table": "SELECT StuID FROM Student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT StuID FROM Sportsinfo WHERE sportname  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5985", "db_id": "game_1", "question": "Which game type has most number of games?", "rationale": ["Identify the relevant table, which is 'Video_Games'.", "Select the 'GType' column to display the types of games.", "Group the results by 'GType' to aggregate the data based on game genres.", "Order the results by the count of games in each genre in descending order to find the most common type.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT gtype FROM Video_games GROUP BY gtype ORDER BY count(*) DESC LIMIT 1", "source_tables": ["video_games"], "description": "The virtual table summarizes the types of video games from the 'Video_Games' table, grouping them by their genre. It orders the results by the count of games in each genre in descending order, allowing the user to identify the game type with the highest number of entries. The placeholder in the LIMIT clause indicates the maximum number of results to return.", "virtual_table": "SELECT gtype FROM Video_games GROUP BY gtype ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6031", "db_id": "game_1", "question": "Show total hours per week and number of games played for students under 20.", "rationale": ["Identify the relevant tables, which are 'SportsInfo' and 'Student'.", "Select the columns to display, which are the sum of 'HoursPerWeek' and 'GamesPlayed'.", "Join the 'SportsInfo' table with the 'Student' table on the 'StuID' column to correlate sports participation with student information.", "Add a condition to filter the results based on the 'Age' column from the 'Student' table, using a placeholder for numeric values."], "gold_sql": "SELECT sum(hoursperweek) ,  sum(gamesplayed) FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.age  <  20", "source_tables": ["sportsinfo", "student"], "description": "The virtual table summarizes the total hours per week dedicated to sports and the total number of games played by students from the 'SportsInfo' table, filtered by students who are under a specific age. The placeholders in the WHERE clause represent the age limit for the students.", "virtual_table": "SELECT sum(hoursperweek) ,  sum(gamesplayed) FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.age  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5986", "db_id": "game_1", "question": "What type has the most games?", "rationale": ["Identify the relevant table, which is 'Video_Games'.", "Select the 'GType' column to display the types of games.", "Group the results by 'GType' to aggregate the count of games for each type.", "Order the results in descending order based on the count of games.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT gtype FROM Video_games GROUP BY gtype ORDER BY count(*) DESC LIMIT 1", "source_tables": ["video_games"], "description": "The virtual table summarizes the types of video games from the 'Video_Games' table, grouping them by genre and ordering them by the count of games in each genre. The placeholder in the LIMIT clause indicates the number of top genres to return.", "virtual_table": "SELECT gtype FROM Video_games GROUP BY gtype ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6001", "db_id": "game_1", "question": "How many students play sports?", "rationale": ["Identify the relevant table, which is 'SportsInfo'.", "Count the distinct 'StuID' to determine the number of unique students participating in sports."], "gold_sql": "SELECT count(DISTINCT StuID) FROM Sportsinfo", "source_tables": ["sportsinfo"], "description": "The virtual table provides a count of unique students from the 'SportsInfo' table who are participating in sports activities. This count reflects the number of distinct student identifiers, indicating how many students are involved in sports.", "virtual_table": "SELECT count(DISTINCT StuID) FROM Sportsinfo"}
{"sample_id": "train.5978", "db_id": "game_1", "question": "What are the names of all video games that are collectible cards?", "rationale": ["Identify the relevant table, which is 'Video_Games'.", "Select the column to display, 'GName'.", "Add a condition to filter the 'GType' column for the specified genre using a placeholder for string values."], "gold_sql": "SELECT gname FROM Video_games WHERE gtype  =  'Collectible card game'", "source_tables": ["video_games"], "description": "The virtual table lists the names of video games from the 'Video_Games' table that fall under a specific genre. The placeholder in the WHERE clause represents the type of game being queried.", "virtual_table": "SELECT gname FROM Video_games WHERE gtype  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5977", "db_id": "game_1", "question": "Show all video games with type Collectible card game.", "rationale": ["Identify the relevant table, which is 'Video_Games'.", "Select the column to display, 'GName'.", "Add a condition to filter the 'GType' column for the specified game type using a placeholder for string values."], "gold_sql": "SELECT gname FROM Video_games WHERE gtype  =  'Collectible card game'", "source_tables": ["video_games"], "description": "The virtual table lists the names of video games from the 'Video_Games' table that fall under a specific genre. The placeholder in the WHERE clause represents the type of video game being queried.", "virtual_table": "SELECT gname FROM Video_games WHERE gtype  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6003", "db_id": "game_1", "question": "List ids for all student who are on scholarship.", "rationale": ["Identify the relevant table, which is 'SportsInfo'.", "Select the column to display, 'StuID'.", "Add a condition to filter the 'OnScholarship' column for students who are on scholarship using a placeholder for string values."], "gold_sql": "SELECT StuID FROM Sportsinfo WHERE onscholarship  =  'Y'", "source_tables": ["sportsinfo"], "description": "The virtual table lists the unique identifiers of students from the 'SportsInfo' table who are participating in sports and are indicated as being on a sports scholarship. The placeholder in the WHERE clause represents the scholarship status.", "virtual_table": "SELECT StuID FROM Sportsinfo WHERE onscholarship  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3944", "db_id": "hospital_1", "question": "Find the number of medications prescribed for each brand.", "rationale": ["Identify the relevant tables, which are 'Medication' and 'Prescribes'.", "Select the count of prescriptions and the brand name from the 'Medication' table.", "Join the 'Medication' table with the 'Prescribes' table on the medication code to link prescriptions to their respective medications.", "Group the results by the brand name to aggregate the count of prescriptions for each brand."], "gold_sql": "SELECT count(*) ,  T1.name FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand", "source_tables": ["prescribes", "medication"], "description": "The virtual table summarizes the count of medications prescribed, grouped by their brand names. It combines data from the 'Medication' table, which contains details about each medication including its unique code and brand name, with the 'Prescribes' table that records the prescriptions made by physicians. The count reflects the total number of prescriptions for each brand, providing insights into medication usage.", "virtual_table": "SELECT count(*) ,  T1.name FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand"}
{"sample_id": "train.3985", "db_id": "hospital_1", "question": "What procedures cost less than 5000 and have John Wen as a trained physician?", "rationale": ["Identify the relevant tables: 'Procedures', 'Physician', and 'Trained_In'.", "Select the 'name' column from the 'Procedures' table where the 'cost' is less than a specified number.", "Use an INTERSECT to combine this with another selection that finds procedures associated with the physician named John Wen.", "Join the 'Physician' table with the 'Trained_In' table to find the treatments they are certified in, and then join with the 'Procedures' table to get the names of those procedures.", "The placeholders represent the cost limit and the physician's name for dynamic querying."], "gold_sql": "SELECT name FROM procedures WHERE cost  <  5000 INTERSECT SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  'John Wen'", "source_tables": ["procedures", "physician", "trained_in"], "description": "The virtual table provides a list of medical procedures from the 'Procedures' table that are priced below a specified amount. Additionally, it intersects this list with the names of procedures that have been performed by a physician named John Wen, who is identified in the 'Physician' table and is linked to the procedures through the 'Trained_In' table. The placeholders in the query allow for dynamic input of the cost limit and the physician's name.", "virtual_table": "SELECT name FROM procedures WHERE cost  <  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3928", "db_id": "hospital_1", "question": "How many patients do each physician take care of? List their names and number of patients they take care of.", "rationale": ["Identify the relevant tables, which are 'Physician' and 'Patient'.", "Select the 'name' column from the 'Physician' table and count the number of patients from the 'Patient' table.", "Join the two tables on the condition that the physician's employee ID matches the patient's primary care physician identifier.", "Group the results by the physician's employee ID to aggregate the patient counts for each physician."], "gold_sql": "SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid", "source_tables": ["physician", "patient"], "description": "The virtual table provides the names of physicians along with the count of patients they are responsible for. It combines data from the 'Physician' table and the 'Patient' table, linking them through the primary care physician identifier. The result is grouped by each physician to show the total number of patients associated with them.", "virtual_table": "SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid"}
{"sample_id": "train.3960", "db_id": "hospital_1", "question": "List the physicians' employee ids together with their primary affiliation departments' ids.", "rationale": ["Identify the relevant table, which is 'Affiliated_With'.", "Select the columns to display, 'physician' and 'department'.", "Add a condition to filter the 'primaryaffiliation' column for the specified primary affiliation using a placeholder for numeric values."], "gold_sql": "SELECT physician ,  department FROM affiliated_with WHERE primaryaffiliation  =  1", "source_tables": ["affiliated_with"], "description": "The virtual table lists the employee IDs of physicians along with the department IDs of their primary affiliations. The placeholder in the WHERE clause indicates that the query will filter for primary affiliations based on a specific numeric value.", "virtual_table": "SELECT physician ,  department FROM affiliated_with WHERE primaryaffiliation  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3902", "db_id": "hospital_1", "question": "what is the name and position of the head whose department has least number of employees?", "rationale": ["Identify the relevant tables, which are 'Department' and 'Physician'.", "Select the columns to display, 'name' and 'position' from the 'Physician' table.", "Join the 'Department' table with the 'Physician' table on the head of the department.", "Group the results by department ID to aggregate the number of employees in each department.", "Order the results by the count of employees in ascending order to find the department with the least number of employees.", "Add a limit to the results using a placeholder for numeric values."], "gold_sql": "SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["physician", "department"], "description": "The virtual table describes the names and positions of heads of departments from the 'Department' and 'Physician' tables. It joins these tables based on the head of the department and groups the results by department ID. The results are ordered by the count of employees in each department, allowing for the identification of the head of the department with the least number of employees, with a placeholder to limit the number of results returned.", "virtual_table": "SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3934", "db_id": "hospital_1", "question": "Find the number of rooms for different block code?", "rationale": ["Identify the relevant tables, which are 'Block' and 'Room'.", "Count the number of rooms by using the count(*) function.", "Join the 'Block' table with the 'Room' table based on the block floor and block code to correlate the data.", "Group the results by the block code to get the count for each unique block code."], "gold_sql": "SELECT count(*) ,  T1.blockcode FROM BLOCK AS T1 JOIN room AS T2 ON T1.blockfloor  =  T2.blockfloor AND T1.blockcode  =  T2.blockcode GROUP BY T1.blockcode", "source_tables": ["block", "room"], "description": "The virtual table summarizes the count of rooms associated with different block codes from the 'Block' and 'Room' tables. It groups the results by block code, allowing for an overview of how many rooms correspond to each unique block code. The placeholders in the query represent the block code values used for grouping.", "virtual_table": "SELECT count(*) ,  T1.blockcode FROM BLOCK AS T1 JOIN room AS T2 ON T1.blockfloor  =  T2.blockfloor AND T1.blockcode  =  T2.blockcode GROUP BY T1.blockcode"}
{"sample_id": "train.3903", "db_id": "hospital_1", "question": "Find the name and position of the head of the department with the least employees.", "rationale": ["Identify the relevant tables, which are 'Department' and 'Physician'.", "Select the columns to display, 'name' and 'position' from the 'Physician' table.", "Join the 'Department' table with the 'Physician' table on the head of the department.", "Group the results by department ID to count the number of employees in each department.", "Order the results by the count of employees in ascending order to find the department with the least employees.", "Limit the results to one entry using a placeholder for numeric values."], "gold_sql": "SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["physician", "department"], "description": "The virtual table provides the names and positions of physicians who are heads of departments, specifically focusing on the department that has the least number of employees. The query utilizes a join between the 'Department' and 'Physician' tables, grouping the results by department ID and ordering them by the count of employees in each department, with a limit set by a placeholder for numeric values.", "virtual_table": "SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3945", "db_id": "hospital_1", "question": "How many medications are prescribed for each brand?", "rationale": ["Identify the relevant tables, which are 'Medication' and 'Prescribes'.", "Select the count of prescriptions and the brand name from the 'Medication' table.", "Join the 'Medication' table with the 'Prescribes' table on the medication code to link prescriptions to their respective medications.", "Group the results by the brand name to aggregate the count of prescriptions for each brand."], "gold_sql": "SELECT count(*) ,  T1.name FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand", "source_tables": ["prescribes", "medication"], "description": "The virtual table summarizes the count of medications prescribed, grouped by their brand names. It combines data from the 'Medication' table, which includes details about each medication such as its unique code and brand name, with the 'Prescribes' table that records the prescriptions made by physicians. The count reflects the total number of prescriptions for each brand, providing insights into the usage of different medication brands.", "virtual_table": "SELECT count(*) ,  T1.name FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand"}
{"sample_id": "train.3924", "db_id": "hospital_1", "question": "Find the patient who most recently stayed in room 111.", "rationale": ["Identify the relevant table, which is 'Stay'.", "Select the column to display, 'Patient'.", "Add a condition to filter the 'Room' column for the specified room using a placeholder for numeric values.", "Order the results by 'StayStart' in descending order to get the most recent stay.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT patient FROM stay WHERE room  =  111 ORDER BY staystart DESC LIMIT 1", "source_tables": ["stay"], "description": "The virtual table provides information about patients who have stayed in a specific room, ordered by the start date of their stay. The placeholders allow for specifying the room number and the limit on the number of results returned.", "virtual_table": "SELECT patient FROM stay WHERE room  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY staystart DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3964", "db_id": "hospital_1", "question": "What nurses are on call with block floor 1 and block code 1? Tell me their names.", "rationale": ["Identify the relevant table, which is 'On_Call'.", "Select the column to display, 'Nurse'.", "Add conditions to filter the 'BlockFloor' and 'BlockCode' columns for the specified statuses using placeholders for numeric values."], "gold_sql": "SELECT nurse FROM on_call WHERE blockfloor  =  1 AND blockcode  =  1", "source_tables": ["on_call"], "description": "The virtual table lists the identifiers of nurses who are currently on call, filtered by specific conditions regarding the blocked floor and blocked code statuses. The placeholders in the WHERE clause represent the respective statuses for the blocked floor and code.", "virtual_table": "SELECT nurse FROM on_call WHERE blockfloor  =  [PLACEHOLDER-TYPE:NUMBER] AND blockcode  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3901", "db_id": "hospital_1", "question": "Tell me the employee id of the head of the department with the least employees.", "rationale": ["Identify the relevant table, which is 'Department'.", "Select the 'head' column to get the employee ID of the department head.", "Group the results by 'DepartmentID' to aggregate the employee counts.", "Order the groups by the count of employees in ascending order to find the department with the least employees.", "Use a placeholder to limit the result to the top entry, which corresponds to the department with the least employees."], "gold_sql": "SELECT head FROM department GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["department"], "description": "The virtual table provides the employee ID of the head of the department that has the least number of employees. It groups the departments by their unique identifier and orders them based on the count of employees in each department, using a placeholder to limit the result to the department with the fewest employees.", "virtual_table": "SELECT head FROM department GROUP BY departmentID ORDER BY count(departmentID) LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3941", "db_id": "hospital_1", "question": "List the names of all the physicians who prescribe Thesisin as medication.", "rationale": ["Identify the relevant tables: 'Physician', 'Prescribes', and 'Medication'.", "Select the distinct names of physicians from the 'Physician' table.", "Join the 'Physician' table with the 'Prescribes' table on the physician's identifier to connect physicians with their prescribed medications.", "Join the 'Prescribes' table with the 'Medication' table on the medication code to filter for the specific medication name using a placeholder."], "gold_sql": "SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  'Thesisin'", "source_tables": ["physician", "prescribes", "medication"], "description": "The virtual table lists the distinct names of physicians from the 'Physician' table who have prescribed a specific medication. The query joins the 'Physician' table with the 'Prescribes' table to link physicians with their prescriptions, and further joins with the 'Medication' table to filter by the medication name using a placeholder.", "virtual_table": "SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3940", "db_id": "hospital_1", "question": "What is the names of the physicians who prescribe medication Thesisin?", "rationale": ["Identify the relevant tables: 'Physician', 'Prescribes', and 'Medication'.", "Select the distinct names of physicians from the 'Physician' table.", "Join the 'Physician' table with the 'Prescribes' table on the physician's identifier to find which medications they have prescribed.", "Join the resulting table with the 'Medication' table to filter for the specific medication name using a placeholder."], "gold_sql": "SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  'Thesisin'", "source_tables": ["physician", "prescribes", "medication"], "description": "The virtual table provides the distinct names of physicians from the 'Physician' table who have prescribed a specific medication. The query joins the 'Physician' table with the 'Prescribes' table to link physicians with their prescriptions, and then further joins with the 'Medication' table to filter by the medication's name using a placeholder.", "virtual_table": "SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3973", "db_id": "hospital_1", "question": "Which physicians are trained in procedures that are more expensive than 5000?", "rationale": ["Identify the relevant tables: 'Physician', 'Trained_In', and 'Procedures'.", "Select the 'name' column from the 'Physician' table to display the names of the physicians.", "Join the 'Trained_In' table on the physician's identifier to link physicians with their training.", "Join the 'Procedures' table on the procedure code to access the cost of the procedures.", "Add a condition to filter the procedures based on their cost using a placeholder for numeric values."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  5000", "source_tables": ["physician", "procedures", "trained_in"], "description": "The virtual table describes the names of physicians from the 'Physician' table who are trained in specific procedures that exceed a certain cost. The query joins the 'Physician', 'Trained_In', and 'Procedures' tables to filter the results based on the cost of the procedures, with a placeholder representing the cost threshold.", "virtual_table": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3905", "db_id": "hospital_1", "question": "List the names of patients who have made appointments.", "rationale": ["Identify the relevant tables, which are 'Appointment' and 'Patient'.", "Select the column to display, 'name' from the 'Patient' table.", "Join the 'Appointment' table with the 'Patient' table using the patient identifier to filter for patients who have made appointments."], "gold_sql": "SELECT name FROM appointment AS T1 JOIN patient AS T2 ON T1.patient  =  T2.ssn", "source_tables": ["patient", "appointment"], "description": "The virtual table lists the names of patients from the 'Patient' table who have made appointments. It joins the 'Appointment' table with the 'Patient' table based on the patient identifier, ensuring that only those patients who have corresponding appointment records are included.", "virtual_table": "SELECT name FROM appointment AS T1 JOIN patient AS T2 ON T1.patient  =  T2.ssn"}
{"sample_id": "train.3949", "db_id": "hospital_1", "question": "Which patient is undergoing the most recent treatment?", "rationale": ["Identify the relevant table, which is 'Undergoes'.", "Select the column to display, 'Patient'.", "Order the results by 'DateUndergoes' to get the most recent treatments.", "Use a placeholder in the LIMIT clause to specify how many recent treatments to return."], "gold_sql": "SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT 1", "source_tables": ["undergoes"], "description": "The virtual table provides a list of patients who are undergoing treatments, ordered by the date of the procedures performed. The placeholder in the LIMIT clause indicates the number of most recent treatments to retrieve.", "virtual_table": "SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3972", "db_id": "hospital_1", "question": "Find the physicians who are trained in a procedure that costs more than 5000.", "rationale": ["Identify the relevant tables: 'Physician', 'Trained_In', and 'Procedures'.", "Select the column to display, which is the 'name' of the physician from the 'Physician' table.", "Join the 'Physician' table with the 'Trained_In' table on the physician's identifier to find trained physicians.", "Join the 'Trained_In' table with the 'Procedures' table on the procedure code to access procedure details.", "Add a condition to filter the procedures based on their cost using a placeholder for numeric values."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  5000", "source_tables": ["physician", "procedures", "trained_in"], "description": "The virtual table describes the names of physicians from the 'Physician' table who are trained in specific procedures. It joins the 'Physician' table with the 'Trained_In' table to link physicians with their training, and further joins with the 'Procedures' table to filter based on the cost of the procedures. The placeholder in the WHERE clause represents the cost threshold for the procedures.", "virtual_table": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3911", "db_id": "hospital_1", "question": "What are the names of all the physicians who took appointments.", "rationale": ["Identify the relevant tables, which are 'Appointment' and 'Physician'.", "Select the 'name' column from the 'Physician' table.", "Join the 'Appointment' table with the 'Physician' table using the physician's unique identifier to filter for those who have taken appointments."], "gold_sql": "SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID", "source_tables": ["physician", "appointment"], "description": "The virtual table provides the names of physicians from the 'Physician' table who have conducted appointments. It joins the 'Appointment' table with the 'Physician' table based on the physician's unique identifier, ensuring that only those physicians who have taken appointments are included in the results.", "virtual_table": "SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID"}
{"sample_id": "train.3910", "db_id": "hospital_1", "question": "List the name of physicians who took some appointment.", "rationale": ["Identify the relevant tables, which are 'Appointment' and 'Physician'.", "Select the column to display, which is 'Name' from the 'Physician' table.", "Join the 'Appointment' table with the 'Physician' table on the physician's identifier to filter the results based on appointments."], "gold_sql": "SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID", "source_tables": ["physician", "appointment"], "description": "The virtual table lists the names of physicians from the 'Physician' table who have conducted appointments. It joins the 'Appointment' table to filter the physicians based on their involvement in appointments, using a placeholder for the physician's identifier.", "virtual_table": "SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID"}
{"sample_id": "train.3515", "db_id": "hr_1", "question": "display the department ID, full name (first and last name), salary for those employees who is highest salary in every department.", "rationale": ["Identify the relevant table, which is 'employees'.", "Select the columns to display: 'first_name', 'last_name', 'salary', and 'department_id'.", "Use the MAX function to find the highest salary within each department.", "Group the results by 'department_id' to ensure that the highest salary is calculated for each department."], "gold_sql": "SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id", "source_tables": ["employees"], "description": "The virtual table displays the department ID, full name (first and last name), and salary of employees who have the highest salary in each department. The use of the MAX function allows for the identification of the top earners within their respective departments, while the GROUP BY clause ensures that the results are organized by department.", "virtual_table": "SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id"}
{"sample_id": "train.3487", "db_id": "hr_1", "question": "What are the unique ids of those departments where any manager is managing 4 or more employees.", "rationale": ["Identify the relevant table, which is 'employees'.", "Select the column to display, 'department_id', ensuring uniqueness with DISTINCT.", "Group the results by 'department_id' and 'manager_id' to aggregate employee counts per manager.", "Add a condition in the HAVING clause to filter groups where the count of 'employee_id' is greater than or equal to a specified number using a placeholder."], "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"], "description": "The virtual table provides a list of unique department identifiers from the 'employees' table, specifically for departments where the count of employees managed by a manager is four or more. The placeholder in the HAVING clause indicates the minimum number of employees required for the condition.", "virtual_table": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3500", "db_id": "hr_1", "question": "What are the full names and hire dates for employees in the same department as someone with the first name Clara?", "rationale": ["Identify the relevant table, which is 'employees'.", "Select the columns to display: 'first_name', 'last_name', and 'hire_date'.", "Add a condition to filter the 'department_id' by using a subquery that selects the 'department_id' of an employee with a specific first name, using a placeholder for string values."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  (SELECT department_id FROM employees WHERE first_name  =  'Clara')", "source_tables": ["employees"], "description": "The virtual table provides the first and last names along with the hire dates of employees from the 'employees' table who work in the same department as a specified employee. The placeholder in the subquery represents the first name of the employee used to identify the department.", "virtual_table": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  (SELECT department_id FROM employees WHERE first_name  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.3510", "db_id": "hr_1", "question": "What are the employee ids, full names, and job ids for employees who make more than the highest earning employee with title PU_MAN?", "rationale": ["Identify the relevant table, which is 'employees'.", "Select the columns to display: 'employee_id', 'first_name', 'last_name', and 'job_id'.", "Add a condition to filter the results based on salary, comparing it to the maximum salary of a specific job title using a subquery with a placeholder for the job ID."], "gold_sql": "SELECT employee_id ,  first_name ,  last_name ,  job_id FROM employees WHERE salary  >  ( SELECT max(salary) FROM employees WHERE job_id  =  'PU_MAN' )", "source_tables": ["employees"], "description": "The virtual table provides a list of employee IDs, full names (first and last names), and job IDs from the 'employees' table. It filters the results to include only those employees whose salary exceeds the maximum salary of a specific job title, represented by a placeholder for the job ID.", "virtual_table": "SELECT employee_id ,  first_name ,  last_name ,  job_id FROM employees WHERE salary  >  ( SELECT max(salary) FROM employees WHERE job_id  =  [PLACEHOLDER-TYPE:STRING] )"}
{"sample_id": "train.3474", "db_id": "hr_1", "question": "What are the full names and department ids for the lowest paid employees across all departments.", "rationale": ["Identify the relevant table, which is 'employees'.", "Select the columns to display: 'first_name', 'last_name', and 'department_id'.", "Use a subquery to find the minimum salary for each department, filtering the main query to include only those employees whose salary matches the minimum salary for their department."], "gold_sql": "SELECT first_name ,  last_name ,  department_id FROM employees WHERE salary IN (SELECT MIN(salary) FROM employees GROUP BY department_id)", "source_tables": ["employees"], "description": "The virtual table presents the first and last names along with the department IDs of employees from the 'employees' table who are the lowest paid within their respective departments. The query utilizes a subquery to determine the minimum salary for each department, ensuring that only those employees with the lowest salaries are included in the results.", "virtual_table": "SELECT first_name ,  last_name ,  department_id FROM employees WHERE salary IN (SELECT MIN(salary) FROM employees GROUP BY department_id)"}
{"sample_id": "train.3502", "db_id": "hr_1", "question": "What are the full names and hire dates for employees in the same department as someone with the first name Clara, not including Clara?", "rationale": ["Identify the relevant table, which is 'employees'.", "Select the columns to display: 'first_name', 'last_name', and 'hire_date'.", "Add a condition to filter employees based on the department_id of another employee with a specified first name using a subquery.", "Ensure to exclude the specified employee by adding a condition that checks the first name is not equal to the specified name."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  ( SELECT department_id FROM employees WHERE first_name  =  'Clara') AND first_name != 'Clara'", "source_tables": ["employees"], "description": "The virtual table provides the first names, last names, and hire dates of employees from the 'employees' table who work in the same department as a specified employee, excluding that employee. The placeholders in the WHERE clause represent the first name of the employee to match and the first name of the employee to exclude.", "virtual_table": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  ( SELECT department_id FROM employees WHERE first_name  =  [PLACEHOLDER-TYPE:STRING]) AND first_name != [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3509", "db_id": "hr_1", "question": "display the employee number, name( first name and last name ) and job title for all employees whose salary is more than any salary of those employees whose job title is PU_MAN.", "rationale": ["Identify the relevant table, which is 'employees'.", "Select the columns to display: 'employee_id', 'first_name', 'last_name', and 'job_id'.", "Add a condition to filter employees whose salary is greater than the maximum salary of those with a specific job title, using a subquery and a placeholder for the job title."], "gold_sql": "SELECT employee_id ,  first_name ,  last_name ,  job_id FROM employees WHERE salary  >  ( SELECT max(salary) FROM employees WHERE job_id  =  'PU_MAN' )", "source_tables": ["employees"], "description": "The virtual table presents the employee number, first name, last name, and job title of employees from the 'employees' table who earn a salary greater than the maximum salary of employees holding the job title specified by the placeholder. This allows for a comparison of salaries based on job titles.", "virtual_table": "SELECT employee_id ,  first_name ,  last_name ,  job_id FROM employees WHERE salary  >  ( SELECT max(salary) FROM employees WHERE job_id  =  [PLACEHOLDER-TYPE:STRING] )"}
{"sample_id": "train.3451", "db_id": "hr_1", "question": "Find the ids of the departments where any manager is managing 4 or more employees.", "rationale": ["Identify the relevant table, which is 'employees'.", "Select the column to display, 'department_id', ensuring uniqueness with DISTINCT.", "Group the results by 'department_id' and 'manager_id' to aggregate employee counts for each manager in each department.", "Add a condition in the HAVING clause to filter groups where the count of 'employee_id' is greater than or equal to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"], "description": "The virtual table lists the unique identifiers of departments from the 'employees' table where the count of employees managed by each manager is four or more. The placeholder in the HAVING clause indicates the minimum number of employees required for a manager to be considered.", "virtual_table": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3457", "db_id": "hr_1", "question": "display job ID for those jobs that were done by two or more for more than 300 days.", "rationale": ["Identify the relevant table, which is 'job_history'.", "Select the column to display, 'job_id'.", "Add a condition to filter the job history based on the duration of jobs held using placeholders for numeric values.", "Group the results by 'job_id' to aggregate the data.", "Use the HAVING clause to filter groups that have two or more records, indicating that the job was held by multiple employees."], "gold_sql": "SELECT job_id FROM job_history WHERE end_date - start_date  > 300 GROUP BY job_id HAVING COUNT(*) >= 2", "source_tables": ["job_history"], "description": "The virtual table displays the job IDs from the 'job_history' table for jobs that have been held by two or more employees for a duration exceeding a specified number of days. The placeholders in the WHERE clause and HAVING clause represent the minimum duration in days and the minimum count of employees, respectively.", "virtual_table": "SELECT job_id FROM job_history WHERE end_date - start_date  > [PLACEHOLDER-TYPE:NUMBER] GROUP BY job_id HAVING COUNT(*) >= [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3420", "db_id": "hr_1", "question": "What are the full name, hire data, salary and department id for employees without the letter M in their first name, ordered by ascending department id?", "rationale": ["Identify the relevant table, which is 'employees'.", "Select the columns to display: 'first_name', 'last_name', 'hire_date', 'salary', and 'department_id'.", "Add a condition to filter the 'first_name' column to exclude names containing the letter 'M' using a placeholder for string values.", "Specify the ordering of the results by 'department_id' in ascending order."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id", "source_tables": ["employees"], "description": "The virtual table provides the first name, last name, hire date, salary, and department ID of employees from the 'employees' table who do not have the letter 'M' in their first name. The placeholder in the WHERE clause is used to filter out those employees based on the specified condition, and the results are ordered by department ID in ascending order.", "virtual_table": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE [PLACEHOLDER-TYPE:STRING] ORDER BY department_id"}
{"sample_id": "train.3516", "db_id": "hr_1", "question": "What are the department ids, full names, and salaries for employees who make the most in their departments?", "rationale": ["Identify the relevant table, which is 'employees'.", "Select the columns to display: 'first_name', 'last_name', 'salary', and 'department_id'.", "Use the MAX function to find the highest salary within each department.", "Group the results by 'department_id' to ensure that the maximum salary is calculated for each department."], "gold_sql": "SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id", "source_tables": ["employees"], "description": "The virtual table provides the department IDs, full names, and salaries of employees from the 'employees' table, specifically focusing on those who earn the highest salary within their respective departments. The use of a placeholder allows for the aggregation of salaries to identify the maximum salary per department.", "virtual_table": "SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id"}
{"sample_id": "train.3417", "db_id": "hr_1", "question": "display the full name (first and last), hire date, salary, and department number for those employees whose first name does not containing the letter M.", "rationale": ["Identify the relevant table, which is 'employees'.", "Select the columns to display: 'first_name', 'last_name', 'hire_date', 'salary', and 'department_id'.", "Add a condition to filter the 'first_name' column to exclude names containing the letter 'M' using a placeholder for string values."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%'", "source_tables": ["employees"], "description": "The virtual table displays the first and last names, hire date, salary, and department number of employees from the 'employees' table who do not have the letter 'M' in their first name. The placeholder in the WHERE clause is used to filter the first names accordingly.", "virtual_table": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3428", "db_id": "hr_1", "question": "Return the full names and salaries for employees with first names that end with the letter m.", "rationale": ["Identify the relevant table, which is 'employees'.", "Select the columns to display: 'first_name', 'last_name', and 'salary'.", "Add a condition to filter the 'first_name' column using a LIKE clause with a placeholder for string values to match names ending with a specific letter."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees WHERE first_name LIKE '%m'", "source_tables": ["employees"], "description": "The virtual table provides the first names, last names, and salaries of employees from the 'employees' table whose first names match a specific pattern. The placeholder in the WHERE clause is used to filter the first names based on the specified condition.", "virtual_table": "SELECT first_name ,  last_name ,  salary FROM employees WHERE first_name LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3408", "db_id": "hr_1", "question": "What are the full names and salaries for any employees earning less than 6000?", "rationale": ["Identify the relevant table, which is 'employees'.", "Select the columns to display: 'first_name', 'last_name', and 'salary'.", "Add a condition to filter the 'salary' column for values less than a specified number using a placeholder for numeric values."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees WHERE salary  <  6000", "source_tables": ["employees"], "description": "The virtual table presents the first and last names along with the salaries of employees from the 'employees' table who earn below a specified salary threshold. The placeholder in the WHERE clause indicates the maximum salary limit for filtering the results.", "virtual_table": "SELECT first_name ,  last_name ,  salary FROM employees WHERE salary  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3464", "db_id": "hr_1", "question": "Give the name of each department and the number of employees in each.", "rationale": ["Identify the relevant tables, which are 'employees' and 'departments'.", "Join the two tables on the 'department_id' to associate employees with their respective departments.", "Select the 'department_name' from the 'departments' table and count the number of employees from the 'employees' table.", "Group the results by 'department_name' to get the count of employees for each department."], "gold_sql": "SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name", "source_tables": ["employees", "departments"], "description": "The virtual table provides a summary of each department along with the count of employees associated with that department. It combines data from the 'employees' and 'departments' tables, linking them through the department identifier. The result will display the department names and the corresponding number of employees in each department.", "virtual_table": "SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name"}
{"sample_id": "train.3508", "db_id": "hr_1", "question": "What are the employee ids and job ids for employees who make less than the lowest earning employee with title MK_MAN?", "rationale": ["Identify the relevant table, which is 'employees'.", "Select the columns to display, 'employee_id' and 'job_id'.", "Add a condition to filter the 'salary' column to find employees earning less than a specified minimum salary.", "Use a subquery to determine the minimum salary for a specific job title, represented by a placeholder for string values."], "gold_sql": "SELECT employee_id ,  job_id FROM employees WHERE salary  <  ( SELECT min(salary) FROM employees WHERE job_id  =  'MK_MAN' )", "source_tables": ["employees"], "description": "The virtual table provides the employee IDs and job IDs of employees from the 'employees' table who earn less than a specified minimum salary associated with a particular job title. The placeholder in the subquery represents the job ID for which the minimum salary is being compared.", "virtual_table": "SELECT employee_id ,  job_id FROM employees WHERE salary  <  ( SELECT min(salary) FROM employees WHERE job_id  =  [PLACEHOLDER-TYPE:STRING] )"}
{"sample_id": "train.3444", "db_id": "hr_1", "question": "What are the job titles, and range of salaries for jobs with maximum salary between 12000 and 18000?", "rationale": ["Identify the relevant table, which is 'jobs'.", "Select the columns to display, 'job_title' and the difference between 'max_salary' and 'min_salary' to represent the salary range.", "Add a condition to filter the 'max_salary' column for the specified range using placeholders for numeric values."], "gold_sql": "SELECT job_title ,  max_salary - min_salary FROM jobs WHERE max_salary BETWEEN 12000 AND 18000", "source_tables": ["jobs"], "description": "The virtual table presents the job titles along with the salary range for jobs from the 'jobs' table, specifically focusing on those jobs where the maximum salary falls within a specified range. The placeholders in the WHERE clause allow for dynamic input of the maximum salary limits.", "virtual_table": "SELECT job_title ,  max_salary - min_salary FROM jobs WHERE max_salary BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3528", "db_id": "hr_1", "question": "What are full names and salaries of employees working in the city of London?", "rationale": ["Identify the relevant tables: 'employees', 'departments', and 'locations'.", "Select the columns to display: 'first_name', 'last_name', and 'salary'.", "Join the 'employees' table with the 'departments' table on 'department_id' to associate employees with their departments.", "Join the 'departments' table with the 'locations' table on 'location_id' to access location details.", "Add a condition to filter the results based on the 'city' column in the 'locations' table using a placeholder for string values."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  'London'", "source_tables": ["employees", "departments", "locations"], "description": "The virtual table provides the first names, last names, and salaries of employees from the 'employees' table who are located in a specific city. The query joins the 'employees' table with the 'departments' table to link employees to their respective departments, and then further joins with the 'locations' table to filter based on the city. The placeholder in the WHERE clause represents the city name.", "virtual_table": "SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3472", "db_id": "hr_1", "question": "What is the minimum salary in each department?", "rationale": ["Identify the relevant table, which is 'employees'.", "Select the minimum salary using the MIN function and include the department identifier.", "Group the results by 'department_id' to ensure the minimum salary is calculated for each department."], "gold_sql": "SELECT MIN(salary) ,  department_id FROM employees GROUP BY department_id", "source_tables": ["employees"], "description": "The virtual table summarizes the minimum salary for each department from the 'employees' table. It groups the results by the department identifier, allowing for the calculation of the minimum salary within each distinct department.", "virtual_table": "SELECT MIN(salary) ,  department_id FROM employees GROUP BY department_id"}
{"sample_id": "train.3463", "db_id": "hr_1", "question": "display the department name and number of employees in each of the department.", "rationale": ["Identify the relevant tables, which are 'employees' and 'departments'.", "Select the 'department_name' from the 'departments' table and count the number of employees from the 'employees' table.", "Join the two tables on the 'department_id' to associate employees with their respective departments.", "Group the results by 'department_name' to aggregate the employee counts for each department."], "gold_sql": "SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name", "source_tables": ["employees", "departments"], "description": "The virtual table displays the names of departments along with the count of employees associated with each department. It combines data from the 'employees' and 'departments' tables, linking them through the department identifier. The result is grouped by department name to provide a summary of employee distribution across departments.", "virtual_table": "SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name"}
{"sample_id": "train.3447", "db_id": "hr_1", "question": "display the employee ID for each employee and the date on which he ended his previous job.", "rationale": ["Identify the relevant table, which is 'job_history'.", "Select the 'employee_id' and the maximum 'end_date' to show when each employee ended their previous job.", "Use the GROUP BY clause to ensure that the results are aggregated by each employee's ID, allowing for the retrieval of the latest end date for each employee."], "gold_sql": "SELECT employee_id ,  MAX(end_date) FROM job_history GROUP BY employee_id", "source_tables": ["job_history"], "description": "The virtual table displays the employee IDs along with the maximum end dates of their previous jobs from the 'job_history' table. The grouping by employee ID allows for the retrieval of the latest end date for each employee's job history.", "virtual_table": "SELECT employee_id ,  MAX(end_date) FROM job_history GROUP BY employee_id"}
{"sample_id": "train.3448", "db_id": "hr_1", "question": "What are the employee ids for each employee and final dates of employment at their last job?", "rationale": ["Identify the relevant table, which is 'job_history'.", "Select the 'employee_id' and the maximum 'end_date' to find the last job's end date for each employee.", "Use the GROUP BY clause to group the results by 'employee_id' to ensure each employee's last job end date is displayed."], "gold_sql": "SELECT employee_id ,  MAX(end_date) FROM job_history GROUP BY employee_id", "source_tables": ["job_history"], "description": "The virtual table provides a list of employee IDs along with the maximum end dates of their employment from the job history records. The placeholder in the query allows for grouping the results by each employee's ID to ensure that the latest end date for each employee is retrieved.", "virtual_table": "SELECT employee_id ,  MAX(end_date) FROM job_history GROUP BY employee_id"}
{"sample_id": "train.3507", "db_id": "hr_1", "question": "display the employee number and job id for all employees whose salary is smaller than any salary of those employees whose job title is MK_MAN.", "rationale": ["Identify the relevant table, which is 'employees'.", "Select the columns to display, 'employee_id' and 'job_id'.", "Add a condition to filter the 'salary' column to be less than the minimum salary of employees with a specific job title using a subquery and a placeholder for string values."], "gold_sql": "SELECT employee_id ,  job_id FROM employees WHERE salary  <  ( SELECT min(salary) FROM employees WHERE job_id  =  'MK_MAN' )", "source_tables": ["employees"], "description": "The virtual table displays the employee numbers and job IDs of employees from the 'employees' table whose salaries are less than the minimum salary of employees holding a specific job title. The placeholder in the subquery represents the job title to be compared against.", "virtual_table": "SELECT employee_id ,  job_id FROM employees WHERE salary  <  ( SELECT min(salary) FROM employees WHERE job_id  =  [PLACEHOLDER-TYPE:STRING] )"}
{"sample_id": "train.3498", "db_id": "hr_1", "question": "What are the ids for employees who do not work in departments with managers that have ids between 100 and 200?", "rationale": ["Identify the relevant table, which is 'employees'.", "Select all columns to display employee identifiers.", "Add a condition to filter out department identifiers that fall within a specific range of manager identifiers using a subquery.", "The subquery selects department identifiers from the 'departments' table where the manager's identifier is between two specified numeric values, represented by placeholders."], "gold_sql": "SELECT * FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN 100 AND 200)", "source_tables": ["employees", "departments"], "description": "The virtual table contains the identifiers of employees from the 'employees' table who are not associated with any departments managed by individuals whose identifiers fall within a specified range. The subquery filters the departments based on the manager's identifier, using placeholders for numeric values to define the range.", "virtual_table": "SELECT * FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.3481", "db_id": "hr_1", "question": "get the details of employees who manage a department.", "rationale": ["Identify the relevant tables, which are 'employees' and 'departments'.", "Select all columns from the 'employees' table and join it with the 'departments' table based on the condition that the employee's ID matches the manager ID in the departments table.", "Use DISTINCT to ensure that each employee is listed only once, even if they manage multiple departments."], "gold_sql": "SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T1.employee_id  =  T2.manager_id", "source_tables": ["employees", "departments"], "description": "The virtual table provides details of employees from the 'employees' table who are also managers of departments from the 'departments' table. It combines information from both tables by matching the employee's ID with the manager ID in the departments table, ensuring that only those employees who manage a department are included in the results.", "virtual_table": "SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T1.employee_id  =  T2.manager_id"}
{"sample_id": "train.3497", "db_id": "hr_1", "question": "Find the ids of the employees who does not work in those departments where some employees works whose manager id within the range 100 and 200.", "rationale": ["Identify the relevant table, which is 'employees'.", "Select the column to display, which is the employee identifier.", "Add a condition to filter out department IDs that are managed by managers within a specified range using a subquery with placeholders for numeric values."], "gold_sql": "SELECT * FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN 100 AND 200)", "source_tables": ["employees", "departments"], "description": "The virtual table contains the identifiers of employees from the 'employees' table who do not belong to departments managed by individuals whose manager IDs fall within a specified numeric range. The inner query filters departments based on the manager ID range, while the outer query excludes those departments from the employee selection.", "virtual_table": "SELECT * FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.3466", "db_id": "hr_1", "question": "What is all the job history info done by employees earning a salary greater than or equal to 12000?", "rationale": ["Identify the relevant tables, which are 'job_history' and 'employees'.", "Select all columns from the job history records.", "Join the 'job_history' table with the 'employees' table based on the employee identifier.", "Add a condition to filter the results based on the salary of the employees using a placeholder for numeric values."], "gold_sql": "SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  12000", "source_tables": ["job_history", "employees"], "description": "The virtual table contains all job history records for employees from the 'job_history' table, joined with the 'employees' table. It filters the results to include only those employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary requirement.", "virtual_table": "SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3523", "db_id": "hr_1", "question": "display the full name (first and last name ) of employee with ID and name of the country presently where (s)he is working.", "rationale": ["Identify the relevant tables: 'employees', 'departments', 'locations', and 'countries'.", "Select the columns to display: 'first_name', 'last_name', 'employee_id', and 'country_name'.", "Join the 'employees' table with 'departments' using 'department_id'.", "Join the 'departments' table with 'locations' using 'location_id'.", "Join the 'locations' table with 'countries' using 'country_id' to get the country name."], "gold_sql": "SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id", "source_tables": ["countries", "employees", "departments", "locations"], "description": "The virtual table displays the first and last names of employees along with their unique employee ID and the name of the country where they are currently working. It combines data from the 'employees', 'departments', 'locations', and 'countries' tables, linking them through their respective identifiers to provide a comprehensive view of employee information and their geographical location.", "virtual_table": "SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id"}
{"sample_id": "train.2590", "db_id": "inn_1", "question": "List the names and decor of rooms that have a king bed. Sort the list by their price.", "rationale": ["Identify the relevant table, which is 'Rooms'.", "Select the columns to display, 'roomName' and 'decor'.", "Add a condition to filter the 'bedType' column for the specified bed type using a placeholder for string values.", "Include an ORDER BY clause to sort the results by 'basePrice' to ensure the list is organized by price."], "gold_sql": "SELECT roomName ,  decor FROM Rooms WHERE bedtype  =  'King' ORDER BY basePrice;", "source_tables": ["rooms"], "description": "The virtual table provides the names and decor descriptions of rooms from the 'Rooms' table that feature a specific type of bed. The results are sorted by the base price of the rooms, allowing for an organized view based on cost. The placeholder in the WHERE clause represents the type of bed being queried.", "virtual_table": "SELECT roomName ,  decor FROM Rooms WHERE bedtype  =  [PLACEHOLDER-TYPE:STRING] ORDER BY basePrice;"}
{"sample_id": "train.2582", "db_id": "inn_1", "question": "Which room has the highest rate? List the room's full name, rate, check in and check out date.", "rationale": ["Identify the relevant tables, which are 'Rooms' and 'Reservations'.", "Select the columns to display: 'roomName' from 'Rooms', and 'Rate', 'CheckIn', and 'CheckOut' from 'Reservations'.", "Join the 'Rooms' table with the 'Reservations' table using the foreign key relationship on 'Room' and 'RoomId'.", "Group the results by the room to aggregate the rates correctly.", "Order the results by the rate in descending order to find the highest rate.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT T2.roomName ,  T1.Rate ,  T1.CheckIn ,  T1.CheckOut FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY T1.Rate DESC LIMIT 1;", "source_tables": ["rooms", "reservations"], "description": "The virtual table provides information about rooms and their associated reservations, specifically focusing on the room's name, the rate charged for the reservation, and the check-in and check-out dates. The query retrieves this data by joining the 'Rooms' and 'Reservations' tables, filtering to show the room with the highest rate, and limiting the results to a specified number.", "virtual_table": "SELECT T2.roomName ,  T1.Rate ,  T1.CheckIn ,  T1.CheckOut FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY T1.Rate DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.2619", "db_id": "inn_1", "question": "How many rooms have king beds? Report the number for each decor type.", "rationale": ["Identify the relevant table, which is 'Rooms'.", "Select the column 'decor' to group the results by room decor type.", "Use the count function to tally the number of rooms for each decor type.", "Add a condition to filter the 'bedType' column for king beds using a placeholder for string values.", "Group the results by the 'decor' column to get the count for each decor type."], "gold_sql": "SELECT decor ,  count(*) FROM Rooms WHERE bedType = 'King' GROUP BY decor;", "source_tables": ["rooms"], "description": "The virtual table summarizes the count of rooms categorized by their decor type from the 'Rooms' table, specifically filtering for rooms that have king beds. The placeholder in the WHERE clause represents the type of bed being queried.", "virtual_table": "SELECT decor ,  count(*) FROM Rooms WHERE bedType = [PLACEHOLDER-TYPE:STRING] GROUP BY decor;"}
{"sample_id": "train.2639", "db_id": "inn_1", "question": "For each room, find its name and the number of times reservations were made for it.", "rationale": ["Identify the relevant tables, which are 'Rooms' and 'Reservations'.", "Select the 'roomName' from the 'Rooms' table and count the number of reservations from the 'Reservations' table.", "Join the two tables on the room identifier to associate reservations with their respective rooms.", "Group the results by the room identifier to aggregate the count of reservations for each room."], "gold_sql": "SELECT T2.roomName ,  count(*) ,  T1.Room FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room", "source_tables": ["rooms", "reservations"], "description": "The virtual table summarizes the names of rooms along with the count of reservations made for each room. It combines data from the 'Rooms' table and the 'Reservations' table, linking them through the room identifier. The count reflects the total number of reservations associated with each room, grouped by the room's unique identifier.", "virtual_table": "SELECT T2.roomName ,  count(*) ,  T1.Room FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room"}
{"sample_id": "train.2578", "db_id": "inn_1", "question": "How many kids stay in the rooms reserved by ROY SWEAZY?", "rationale": ["Identify the relevant table, which is 'Reservations'.", "Select the column to display, 'kids'.", "Add conditions to filter the 'FirstName' and 'LastName' columns for the specified guest using placeholders for string values."], "gold_sql": "SELECT kids FROM Reservations WHERE FirstName = 'ROY' AND LastName  =  'SWEAZY';", "source_tables": ["reservations"], "description": "The virtual table provides information about the number of kids staying in rooms reserved by guests from the 'Reservations' table. The placeholders in the WHERE clause represent the first and last names of the guest, allowing for specific queries based on the guest's identity.", "virtual_table": "SELECT kids FROM Reservations WHERE FirstName = [PLACEHOLDER-TYPE:STRING] AND LastName  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.2604", "db_id": "inn_1", "question": "Find the first and last names of people who payed more than the rooms' base prices.", "rationale": ["Identify the relevant tables, which are 'Reservations' and 'Rooms'.", "Select the columns to display, 'firstname' and 'lastname' from the 'Reservations' table.", "Join the 'Reservations' table with the 'Rooms' table on the room identifier to access room details.", "Add a condition to filter the results where the rate paid exceeds the base price of the room using a placeholder for numeric values."], "gold_sql": "SELECT T1.firstname ,  T1.lastname FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T1.Rate - T2.basePrice  >  0", "source_tables": ["rooms", "reservations"], "description": "The virtual table describes the first and last names of guests from the 'Reservations' table who have paid more than the base prices of the rooms they reserved. The placeholder in the WHERE clause represents the difference between the reservation rate and the room's base price, allowing for a dynamic comparison based on user input.", "virtual_table": "SELECT T1.firstname ,  T1.lastname FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T1.Rate - T2.basePrice  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2600", "db_id": "inn_1", "question": "What kind of decor has the least number of reservations?", "rationale": ["Identify the relevant tables, which are 'Reservations' and 'Rooms'.", "Select the 'decor' column from the 'Rooms' table.", "Join the 'Reservations' table with the 'Rooms' table using the room identifier.", "Group the results by the 'decor' column to aggregate the reservation counts.", "Order the results by the count of reservations in ascending order to find the least reserved decor.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT T2.decor FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T2.decor ORDER BY count(T2.decor) ASC LIMIT 1;", "source_tables": ["rooms", "reservations"], "description": "The virtual table summarizes the types of decor from the 'Rooms' table that are associated with the least number of reservations. It joins the 'Reservations' and 'Rooms' tables based on the room identifier, groups the results by the decor type, and orders them in ascending order of their reservation count. The placeholder in the LIMIT clause indicates the maximum number of decor types to return.", "virtual_table": "SELECT T2.decor FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T2.decor ORDER BY count(T2.decor) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.2605", "db_id": "inn_1", "question": "What are the first and last names of people who payed more than the rooms' base prices?", "rationale": ["Identify the relevant tables, which are 'Reservations' and 'Rooms'.", "Select the columns to display, 'firstname' and 'lastname' from the 'Reservations' table.", "Join the 'Reservations' table with the 'Rooms' table on the room identifier to access room pricing information.", "Add a condition to filter the results where the rate paid exceeds the base price of the room using a placeholder for numeric values."], "gold_sql": "SELECT T1.firstname ,  T1.lastname FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T1.Rate - T2.basePrice  >  0", "source_tables": ["rooms", "reservations"], "description": "The virtual table describes the first and last names of guests from the 'Reservations' table who have paid a rate exceeding the base price of the rooms they reserved. The placeholder in the WHERE clause represents the difference between the rate charged and the base price, allowing for a specific numeric threshold to be set.", "virtual_table": "SELECT T1.firstname ,  T1.lastname FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T1.Rate - T2.basePrice  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2601", "db_id": "inn_1", "question": "What is the least popular kind of decor?", "rationale": ["Identify the relevant tables, which are 'Rooms' and 'Reservations'.", "Join the 'Reservations' table with the 'Rooms' table on the room identifier to access decor information.", "Select the 'decor' column from the 'Rooms' table.", "Group the results by the 'decor' column to count occurrences.", "Order the results by the count of decor types in ascending order to find the least popular.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT T2.decor FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T2.decor ORDER BY count(T2.decor) ASC LIMIT 1;", "source_tables": ["rooms", "reservations"], "description": "The virtual table provides a list of room decor types from the 'Rooms' table, grouped by their description. It identifies the least popular kind of decor by counting the occurrences of each decor type in the 'Reservations' table, ordering them in ascending order, and limiting the results to a specified number. The placeholder in the LIMIT clause allows for customization of how many decor types to retrieve.", "virtual_table": "SELECT T2.decor FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T2.decor ORDER BY count(T2.decor) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.2615", "db_id": "inn_1", "question": "Which room has the highest base price?", "rationale": ["Identify the relevant table, which is 'Rooms'.", "Select the columns to display, 'RoomId' and 'roomName'.", "Order the results by 'basePrice' in descending order to find the highest price.", "Limit the results to a specific number using a placeholder for numeric values."], "gold_sql": "SELECT RoomId ,  roomName FROM Rooms ORDER BY basePrice DESC LIMIT 1;", "source_tables": ["rooms"], "description": "The virtual table provides information about rooms from the 'Rooms' table, specifically their unique identifiers and names. The results are ordered by the base price in descending order, allowing the user to identify the room with the highest base price. The placeholder in the LIMIT clause indicates the number of results to return.", "virtual_table": "SELECT RoomId ,  roomName FROM Rooms ORDER BY basePrice DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.2602", "db_id": "inn_1", "question": "List how many times the number of people in the room reached the maximum occupancy of the room. The number of people include adults and kids.", "rationale": ["Identify the relevant tables, which are 'Reservations' and 'Rooms'.", "Join the two tables on the room identifier to correlate reservations with their respective rooms.", "Count the number of records that meet the condition where the sum of adults and kids equals the maximum occupancy of the room."], "gold_sql": "SELECT count(*) FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T2.maxOccupancy  =  T1.Adults + T1.Kids;", "source_tables": ["rooms", "reservations"], "description": "The virtual table summarizes the count of reservations where the total number of occupants, including both adults and kids, matches the maximum occupancy allowed for each room. It combines data from the 'Reservations' and 'Rooms' tables, using a join on the room identifier, and applies a condition to ensure that the sum of adults and kids equals the maximum occupancy.", "virtual_table": "SELECT count(*) FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T2.maxOccupancy  =  T1.Adults + T1.Kids;"}
{"sample_id": "train.2589", "db_id": "inn_1", "question": "Find the total number of king beds available.", "rationale": ["Identify the relevant table, which is 'Rooms'.", "Select the sum of the 'beds' column to calculate the total number of beds.", "Add a condition to filter the 'bedType' column for the specified bed type using a placeholder for string values."], "gold_sql": "SELECT sum(beds) FROM Rooms WHERE bedtype  =  'King';", "source_tables": ["rooms"], "description": "The virtual table summarizes the total number of beds available in the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the type of bed being queried.", "virtual_table": "SELECT sum(beds) FROM Rooms WHERE bedtype  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.2609", "db_id": "inn_1", "question": "How many rooms have a king bed?", "rationale": ["Identify the relevant table, which is 'Rooms'.", "Select the count of rooms by using the count(*) function.", "Add a condition to filter the 'bedType' column for the specified bed type using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM Rooms WHERE bedType  =  'King';", "source_tables": ["rooms"], "description": "The virtual table provides a count of rooms from the 'Rooms' table that feature a specific type of bed. The placeholder in the WHERE clause represents the type of bed being queried.", "virtual_table": "SELECT count(*) FROM Rooms WHERE bedType  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.1513", "db_id": "insurance_and_eClaims", "question": "Find all the policy types that are used by more than 2 customers.", "rationale": ["Identify the relevant table, which is 'Policies'.", "Select the column to display, 'policy_type_code'.", "Group the results by 'policy_type_code' to aggregate the data.", "Add a condition to filter the grouped results using the HAVING clause to only include policy types that have a count greater than a specified number, represented by a placeholder for numeric values."], "gold_sql": "SELECT policy_type_code FROM policies GROUP BY policy_type_code HAVING count(*)  >  2", "source_tables": ["policies"], "description": "The virtual table summarizes the policy types from the 'Policies' table that are associated with more than a specified number of customers. The placeholder in the HAVING clause indicates the minimum count of customers required for a policy type to be included in the results.", "virtual_table": "SELECT policy_type_code FROM policies GROUP BY policy_type_code HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1536", "db_id": "insurance_and_eClaims", "question": "What are the names of the customers and staff members?", "rationale": ["Identify the relevant tables, which are 'Customers' and 'Staff'.", "Select the column 'Customer_Details' from the 'Customers' table.", "Select the column 'Staff_Details' from the 'Staff' table.", "Use the UNION operator to combine the results from both selections, ensuring that the output includes names from both customers and staff."], "gold_sql": "SELECT customer_details FROM customers UNION SELECT staff_details FROM staff", "source_tables": ["staff", "customers"], "description": "The virtual table presents a unified view of customer and staff details by combining the 'Customer_Details' from the 'Customers' table and 'Staff_Details' from the 'Staff' table. This allows for a comprehensive list of names from both entities.", "virtual_table": "SELECT customer_details FROM customers UNION SELECT staff_details FROM staff"}
{"sample_id": "train.1518", "db_id": "insurance_and_eClaims", "question": "How much amount in total were claimed in the most recently created document?", "rationale": ["Identify the relevant tables, which are 'Claim_Headers' and 'Claims_Documents'.", "Calculate the total amount claimed by summing the 'amount_claimed' column from 'Claim_Headers'.", "Join 'Claim_Headers' with 'Claims_Documents' on the claim identifier to link claims with their documents.", "Add a condition to filter the results based on the creation date of the most recent document using a subquery with a placeholder for numeric values."], "gold_sql": "SELECT sum(t1.amount_claimed) FROM claim_headers AS t1 JOIN claims_documents AS t2 ON t1.claim_header_id  =  t2.claim_id WHERE t2.created_date  =  (SELECT created_date FROM claims_documents ORDER BY created_date LIMIT 1)", "source_tables": ["claims_documents", "claim_headers"], "description": "The virtual table summarizes the total amount claimed from the 'Claim_Headers' table, specifically focusing on claims associated with the most recently created document in the 'Claims_Documents' table. The placeholder in the subquery represents the limit for retrieving the latest document's creation date.", "virtual_table": "SELECT sum(t1.amount_claimed) FROM claim_headers AS t1 JOIN claims_documents AS t2 ON t1.claim_header_id  =  t2.claim_id WHERE t2.created_date  =  (SELECT created_date FROM claims_documents ORDER BY created_date LIMIT [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.1545", "db_id": "insurance_and_eClaims", "question": "Which customer is associated with the latest policy?", "rationale": ["Identify the relevant tables, which are 'Policies' and 'Customers'.", "Select the 'customer_details' from the 'Customers' table.", "Join the 'Policies' table with the 'Customers' table on the 'customer_id' to link policies to their respective customers.", "Use a subquery to find the maximum 'start_date' from the 'Policies' table to filter for the latest policy."], "gold_sql": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)", "source_tables": ["policies", "customers"], "description": "The virtual table provides the detailed information about customers associated with their insurance policies, specifically focusing on the customer linked to the most recent policy based on the start date. The query utilizes a subquery to determine the maximum start date of policies, ensuring that the result reflects the latest policy's customer details.", "virtual_table": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)"}
{"sample_id": "train.1511", "db_id": "insurance_and_eClaims", "question": "Which type of policy is most frequently used? Give me the policy type code.", "rationale": ["Identify the relevant table, which is 'Policies'.", "Select the column to display, 'policy_type_code'.", "Group the results by 'policy_type_code' to count occurrences.", "Order the results in descending order based on the count of each policy type.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT policy_type_code FROM policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["policies"], "description": "The virtual table summarizes the policy type codes from the 'Policies' table, grouping them to identify the most frequently used policy type. The placeholder in the LIMIT clause allows for specifying the number of top results to return.", "virtual_table": "SELECT policy_type_code FROM policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1528", "db_id": "insurance_and_eClaims", "question": "Which claim processing stage has the most claims? Show the claim status name.", "rationale": ["Identify the relevant tables, which are 'claims_processing' and 'claims_processing_stages'.", "Select the column to display, 'claim_status_name' from the 'claims_processing_stages' table.", "Join the two tables on the claim stage identifier to associate claims with their processing stages.", "Group the results by the claim stage identifier to count the number of claims per stage.", "Order the results by the count of claims in descending order to find the stage with the most claims.", "Add a limit to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT t2.claim_status_name FROM claims_processing AS t1 JOIN claims_processing_stages AS t2 ON t1.claim_stage_id  =  t2.claim_stage_id GROUP BY t1.claim_stage_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["claims_processing", "claims_processing_stages"], "description": "The virtual table provides the claim status names associated with different claim processing stages from the 'claims_processing' and 'claims_processing_stages' tables. It groups the results by the claim stage identifier and orders them by the count of claims in descending order, allowing the user to identify the stage with the most claims. The placeholder in the LIMIT clause represents the number of top stages to return.", "virtual_table": "SELECT t2.claim_status_name FROM claims_processing AS t1 JOIN claims_processing_stages AS t2 ON t1.claim_stage_id  =  t2.claim_stage_id GROUP BY t1.claim_stage_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1546", "db_id": "insurance_and_eClaims", "question": "Find the customer who started a policy most recently.", "rationale": ["Identify the relevant tables, which are 'Policies' and 'Customers'.", "Join the 'Policies' table with the 'Customers' table on the 'Customer_ID' to link policies to their respective customers.", "Select the 'Customer_Details' from the 'Customers' table.", "Add a condition to filter the results to only include the policy with the maximum start date using a subquery."], "gold_sql": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)", "source_tables": ["policies", "customers"], "description": "The virtual table provides the detailed information about customers from the 'Customers' table who have the most recently started insurance policy. The query uses a subquery to find the maximum start date from the 'Policies' table, ensuring that only the customer associated with the latest policy is selected.", "virtual_table": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)"}
{"sample_id": "train.1515", "db_id": "insurance_and_eClaims", "question": "Find the total and average amount paid in claim headers.", "rationale": ["Identify the relevant table, which is 'Claim_Headers'.", "Select the columns to display, which are the sum and average of the 'Amount_Piad' column.", "The query aggregates the total and average amounts paid, providing insights into the financial aspects of claims."], "gold_sql": "SELECT sum(amount_piad) ,  avg(amount_piad) FROM claim_headers", "source_tables": ["claim_headers"], "description": "The virtual table summarizes the total and average amounts paid from the 'Claim_Headers' table. It provides aggregated financial data related to claims, specifically focusing on the 'Amount_Piad' column, which represents the total amount that has been paid out for claims. This allows users to analyze the financial performance of claims processed.", "virtual_table": "SELECT sum(amount_piad) ,  avg(amount_piad) FROM claim_headers"}
{"sample_id": "train.897", "db_id": "insurance_fnol", "question": "What are all the customer phone numbers under the most popular policy type?", "rationale": ["Identify the relevant table, which is 'Available_Policies'.", "Select the column to display, 'Customer_Phone'.", "Add a condition to filter the 'policy_type_code' column based on a subquery that groups policy types and orders them by their count, using a placeholder for the limit to specify how many top policy types to consider."], "gold_sql": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  (SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["available_policies"], "description": "The virtual table provides a list of customer phone numbers from the 'Available_Policies' table that are associated with the most popular policy type. The placeholder in the subquery represents the limit for selecting the most frequent policy type based on the count of occurrences.", "virtual_table": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  (SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.898", "db_id": "insurance_fnol", "question": "Find the phone numbers of customers using the most common policy type among the available policies.", "rationale": ["Identify the relevant table, which is 'Available_Policies'.", "Select the column to display, 'Customer_Phone'.", "Add a condition to filter the 'policy_type_code' column based on the most common policy type, using a subquery that groups and counts the policy types, ordering them by frequency and limiting the result with a placeholder for numeric values."], "gold_sql": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  (SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["available_policies"], "description": "The virtual table provides the contact phone numbers of customers from the 'Available_Policies' table who are associated with the most common type of insurance policy. The placeholder in the subquery represents the limit for selecting the most frequent policy type.", "virtual_table": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  (SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.930", "db_id": "insurance_fnol", "question": "What is the ordered list of customer ids?", "rationale": ["Identify the relevant table, which is 'Customers'.", "Select the columns to display, 'Customer_ID' and 'Customer_name'.", "Add an ORDER BY clause to sort the results by 'Customer_ID' in ascending order."], "gold_sql": "SELECT customer_id ,  customer_name FROM customers ORDER BY customer_id ASC", "source_tables": ["customers"], "description": "The virtual table contains the customer IDs and names from the 'Customers' table, sorted in ascending order by customer ID. This allows for an organized view of customer information based on their unique identifiers.", "virtual_table": "SELECT customer_id ,  customer_name FROM customers ORDER BY customer_id ASC"}
{"sample_id": "train.895", "db_id": "insurance_fnol", "question": "Which policy type has the most records in the database?", "rationale": ["Identify the relevant table, which is 'Available_Policies'.", "Select the column to display, 'policy_type_code'.", "Group the results by 'policy_type_code' to count occurrences.", "Order the results in descending order based on the count of records.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["available_policies"], "description": "The virtual table summarizes the policy types from the 'Available_Policies' table, grouping them to count the number of records for each type. The placeholder in the LIMIT clause indicates the maximum number of policy types to return, allowing for the identification of the most frequently occurring policy type.", "virtual_table": "SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.893", "db_id": "insurance_fnol", "question": "What are the customer phone numbers under the policy \"Life Insurance\"?", "rationale": ["Identify the relevant table, which is 'Available_Policies'.", "Select the column to display, 'Customer_Phone'.", "Add a condition to filter the 'policy_type_code' column for the specified policy type using a placeholder for string values."], "gold_sql": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  'Life Insurance'", "source_tables": ["available_policies"], "description": "The virtual table contains the customer phone numbers from the 'Available_Policies' table that are associated with a specific type of insurance policy. The placeholder in the WHERE clause represents the policy type code being queried.", "virtual_table": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3861", "db_id": "insurance_policies", "question": "Give me the claim date, settlement date for all the claims whose claimed amount is larger than the average.", "rationale": ["Identify the relevant table, which is 'Claims'.", "Select the columns to display, 'Date_Claim_Made' and 'Date_Claim_Settled'.", "Add a condition to filter the 'Amount_Claimed' column to include only those claims that are greater than the average claimed amount, using a subquery to calculate the average."], "gold_sql": "SELECT Date_Claim_Made ,  Date_Claim_Settled FROM Claims WHERE Amount_Claimed  >  ( SELECT avg(Amount_Claimed) FROM Claims )", "source_tables": ["claims"], "description": "The virtual table provides the claim and settlement dates for all claims from the 'Claims' table where the claimed amount exceeds the average claimed amount. The query uses a subquery to calculate the average of the 'Amount_Claimed' column, and the placeholder in the WHERE clause represents this average value.", "virtual_table": "SELECT Date_Claim_Made ,  Date_Claim_Settled FROM Claims WHERE Amount_Claimed  >  ( SELECT avg(Amount_Claimed) FROM Claims )"}
{"sample_id": "train.3895", "db_id": "insurance_policies", "question": "Which claims had exactly one settlement? For each, tell me the the date the claim was made, the date it was settled and the amount settled.", "rationale": ["Identify the relevant tables, which are 'Claims' and 'Settlements'.", "Select the columns to display: 'claim_id', 'date_claim_made', and 'Date_Claim_Settled'.", "Join the 'Claims' table with the 'Settlements' table on the 'Claim_id' to link claims with their settlements.", "Group the results by 'claim_id' to aggregate the settlements for each claim.", "Add a condition in the HAVING clause to filter for claims that have exactly one settlement using a placeholder for numeric values."], "gold_sql": "SELECT T1.claim_id ,  T1.date_claim_made ,  T1.Date_Claim_Settled FROM Claims AS T1 JOIN Settlements AS T2 ON T1.Claim_id  =  T2.Claim_id GROUP BY T1.claim_id HAVING count(*)  =  1", "source_tables": ["claims", "settlements"], "description": "The virtual table provides information about claims that have exactly one associated settlement. It includes the unique identifier for each claim, the date the claim was made, and the date it was settled. The placeholder in the HAVING clause indicates the specific number of settlements to filter the results.", "virtual_table": "SELECT T1.claim_id ,  T1.date_claim_made ,  T1.Date_Claim_Settled FROM Claims AS T1 JOIN Settlements AS T2 ON T1.Claim_id  =  T2.Claim_id GROUP BY T1.claim_id HAVING count(*)  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3880", "db_id": "insurance_policies", "question": "With which kind of payment method were the least number of payments processed?", "rationale": ["Identify the relevant table, which is 'Payments'.", "Select the column to display, 'Payment_Method_Code'.", "Group the results by 'Payment_Method_Code' to aggregate the payment counts.", "Order the results by the count of payments in ascending order to find the least used method.", "Limit the results to a specific number using a placeholder for numeric values."], "gold_sql": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) ASC LIMIT 1", "source_tables": ["payments"], "description": "The virtual table summarizes the payment methods used in the 'Payments' table, grouping the records by the payment method code. It orders the results by the count of payments processed for each method in ascending order, allowing the identification of the payment method with the least number of transactions. The placeholder in the LIMIT clause indicates the number of results to return, which can be adjusted as needed.", "virtual_table": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3859", "db_id": "insurance_policies", "question": "Find the claimed amount in the claim with the least amount settled. Show both the settlement amount and claim amount.", "rationale": ["Identify the relevant table, which is 'Claims'.", "Select the columns to display, 'Amount_Settled' and 'Amount_Claimed'.", "Order the results by 'Amount_Settled' in ascending order to find the claim with the least settled amount.", "Limit the results to a specific number using a placeholder for numeric values."], "gold_sql": "SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Settled ASC LIMIT 1", "source_tables": ["claims"], "description": "The virtual table presents the claimed amounts from the 'Claims' table, specifically focusing on the claim that has the least amount settled. It includes both the total amount claimed in the claim and the total amount settled for that claim. The placeholder in the LIMIT clause indicates that the user can specify how many records to retrieve, which in this case is limited to the one with the least settled amount.", "virtual_table": "SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Settled ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3886", "db_id": "insurance_policies", "question": "Which kind of policy type was chosen by the most customers?", "rationale": ["Identify the relevant table, which is 'Customer_Policies'.", "Select the column to display, 'Policy_Type_Code'.", "Group the results by 'Policy_Type_Code' to aggregate the data based on policy types.", "Order the results by the count of customers for each policy type in descending order to find the most chosen policy type.", "Add a limit to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT Policy_Type_Code FROM Customer_Policies GROUP BY Policy_Type_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customer_policies"], "description": "The virtual table summarizes the different types of insurance policies selected by customers from the 'Customer_Policies' table. It groups the policies by their type code and orders them based on the number of customers who chose each type, allowing for the identification of the most popular policy type. The placeholder in the LIMIT clause indicates the maximum number of policy types to return.", "virtual_table": "SELECT Policy_Type_Code FROM Customer_Policies GROUP BY Policy_Type_Code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3887", "db_id": "insurance_policies", "question": "Find the policy type the most customers choose.", "rationale": ["Identify the relevant table, which is 'Customer_Policies'.", "Select the column to display, 'Policy_Type_Code'.", "Group the results by 'Policy_Type_Code' to aggregate the data based on policy types.", "Order the results by the count of customers for each policy type in descending order to find the most chosen types.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT Policy_Type_Code FROM Customer_Policies GROUP BY Policy_Type_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customer_policies"], "description": "The virtual table summarizes the policy types chosen by customers from the 'Customer_Policies' table. It groups the results by the policy type code and orders them by the number of customers selecting each type, allowing for the identification of the most popular policy types. The placeholder in the LIMIT clause indicates the maximum number of results to return.", "virtual_table": "SELECT Policy_Type_Code FROM Customer_Policies GROUP BY Policy_Type_Code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3857", "db_id": "insurance_policies", "question": "Find the settlement amount of the claim with the largest claim amount. Show both the settlement amount and claim amount.", "rationale": ["Identify the relevant table, which is 'Claims'.", "Select the columns to display, 'Amount_Settled' and 'Amount_Claimed'.", "Order the results by 'Amount_Claimed' in descending order to get the largest claim amount first.", "Limit the results to a specific number of records using a placeholder for numeric values."], "gold_sql": "SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Claimed DESC LIMIT 1", "source_tables": ["claims"], "description": "The virtual table provides the settlement amount and the claim amount for claims in the 'Claims' table, specifically focusing on the claim with the highest amount claimed. The placeholder in the LIMIT clause indicates that the user can specify how many records to retrieve, which in this case is limited to the top claim based on the amount claimed.", "virtual_table": "SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Claimed DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3879", "db_id": "insurance_policies", "question": "Which payment method is used the most often?", "rationale": ["Identify the relevant table, which is 'Payments'.", "Select the column to display, 'Payment_Method_Code'.", "Group the results by 'Payment_Method_Code' to count occurrences.", "Order the results in descending order based on the count of each payment method.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["payments"], "description": "The virtual table summarizes the payment methods used in the 'Payments' table, grouping them by their method codes. It orders the results by the frequency of each payment method, allowing users to identify the most commonly used method. The placeholder in the LIMIT clause indicates the number of top payment methods to retrieve.", "virtual_table": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3892", "db_id": "insurance_policies", "question": "List the details of the customers who do not have any policies.", "rationale": ["Identify the relevant table, which is 'Customers'.", "Select the column to display, 'customer_details'.", "Use an EXCEPT clause to filter out customers who have policies by joining 'Customers' with 'Customer_Policies' on 'customer_id' and excluding those results."], "gold_sql": "SELECT customer_details FROM Customers EXCEPT SELECT T1.customer_details FROM Customers AS T1 JOIN Customer_Policies AS T2 ON T1.customer_id  =  T2.customer_id", "source_tables": ["customer_policies", "customers"], "description": "The virtual table provides a list of customer details from the 'Customers' table, specifically focusing on those customers who do not have any associated insurance policies. The query utilizes an EXCEPT clause to exclude customers who are linked to any records in the 'Customer_Policies' table, ensuring that only those without policies are included.", "virtual_table": "SELECT customer_details FROM Customers EXCEPT SELECT T1.customer_details FROM Customers AS T1 JOIN Customer_Policies AS T2 ON T1.customer_id  =  T2.customer_id"}
{"sample_id": "train.2262", "db_id": "machine_repair", "question": "What are the starting years shared by the technicians from the team \"CLE\" or \"CWS\"?", "rationale": ["Identify the relevant table, which is 'technician'.", "Select the column to display, 'Starting_Year'.", "Use the INTERSECT operator to find common starting years between the two specified teams, using placeholders for the team identifiers."], "gold_sql": "SELECT Starting_Year FROM technician WHERE Team  =  'CLE' INTERSECT SELECT Starting_Year FROM technician WHERE Team  =  'CWS'", "source_tables": ["technician"], "description": "The virtual table presents the starting years of technicians from the 'technician' table who belong to either the 'CLE' or 'CWS' teams. The placeholders in the WHERE clauses represent the team identifiers for filtering the results.", "virtual_table": "SELECT Starting_Year FROM technician WHERE Team  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT Starting_Year FROM technician WHERE Team  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2258", "db_id": "machine_repair", "question": "What are the names of the technicians  and how many machines are they assigned to repair?", "rationale": ["Identify the relevant tables, which are 'repair_assignment' and 'technician'.", "Select the 'Name' column from the 'technician' table and count the number of assignments from the 'repair_assignment' table.", "Join the two tables on the technician ID to link technicians with their repair assignments.", "Group the results by technician names to aggregate the count of machines assigned to each technician."], "gold_sql": "SELECT T2.Name ,  COUNT(*) FROM repair_assignment AS T1 JOIN technician AS T2 ON T1.technician_ID  =  T2.technician_ID GROUP BY T2.Name", "source_tables": ["repair_assignment", "technician"], "description": "The virtual table provides the names of technicians along with the count of machines they are assigned to repair. It combines data from the 'repair_assignment' and 'technician' tables, grouping the results by technician names to show how many machines each technician is responsible for.", "virtual_table": "SELECT T2.Name ,  COUNT(*) FROM repair_assignment AS T1 JOIN technician AS T2 ON T1.technician_ID  =  T2.technician_ID GROUP BY T2.Name"}
{"sample_id": "train.2256", "db_id": "machine_repair", "question": "What are the names of the technicians that are assigned to repair machines with more point values than 70?", "rationale": ["Identify the relevant tables: 'repair_assignment', 'machine', and 'technician'.", "Join the tables based on their relationships: 'repair_assignment' links to 'machine' through 'machine_id' and to 'technician' through 'technician_id'.", "Select the 'Name' column from the 'technician' table to display the names of the technicians.", "Add a condition to filter the machines based on their 'value_points' using a placeholder for numeric values."], "gold_sql": "SELECT T3.Name FROM repair_assignment AS T1 JOIN machine AS T2 ON T1.machine_id  =  T2.machine_id JOIN technician AS T3 ON T1.technician_ID  =  T3.technician_ID WHERE T2.value_points  >  70", "source_tables": ["machine", "repair_assignment", "technician"], "description": "The virtual table describes the names of technicians from the 'technician' table who are assigned to repair tasks for machines that have a value point greater than a specified threshold. The placeholders in the WHERE clause represent the numeric value for the machine's point value.", "virtual_table": "SELECT T3.Name FROM repair_assignment AS T1 JOIN machine AS T2 ON T1.machine_id  =  T2.machine_id JOIN technician AS T3 ON T1.technician_ID  =  T3.technician_ID WHERE T2.value_points  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2248", "db_id": "machine_repair", "question": "What are the teams with the most technicians?", "rationale": ["Identify the relevant table, which is 'technician'.", "Select the 'Team' column to display the teams.", "Group the results by the 'Team' column to aggregate the count of technicians in each team.", "Order the results in descending order based on the count of technicians to find the teams with the most technicians.", "Add a limit to restrict the number of teams returned, using a placeholder for numeric values."], "gold_sql": "SELECT Team FROM technician GROUP BY Team ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["technician"], "description": "The virtual table summarizes the teams from the 'technician' table, grouping them by their identifiers. It orders the teams based on the count of technicians in each team, allowing for the identification of the teams with the highest number of technicians. The placeholder in the LIMIT clause represents the maximum number of teams to be displayed.", "virtual_table": "SELECT Team FROM technician GROUP BY Team ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2244", "db_id": "machine_repair", "question": "What is the starting year for the oldest technician?", "rationale": ["Identify the relevant table, which is 'technician'.", "Select the column to display, 'Starting_Year'.", "Sort the results by the 'Age' column in descending order to find the oldest technician.", "Limit the results to one record using a placeholder for numeric values."], "gold_sql": "SELECT Starting_Year FROM technician ORDER BY Age DESC LIMIT 1", "source_tables": ["technician"], "description": "The virtual table provides the starting year of technicians from the 'technician' table, sorted by their age in descending order. The placeholder in the LIMIT clause indicates the number of records to return, which in this case is set to retrieve the oldest technician's starting year.", "virtual_table": "SELECT Starting_Year FROM technician ORDER BY Age DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1092", "db_id": "match_season", "question": "Show the country names and the corresponding number of players.", "rationale": ["Identify the relevant tables, which are 'country' and 'match_season'.", "Select the 'Country_name' from the 'country' table and count the number of players from the 'match_season' table.", "Join the two tables on the country identifier to associate players with their respective countries.", "Group the results by 'Country_name' to aggregate the player counts for each country."], "gold_sql": "SELECT Country_name ,  COUNT(*) FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country GROUP BY T1.Country_name", "source_tables": ["country", "match_season"], "description": "The virtual table provides a summary of country names along with the count of players associated with each country. It combines data from the 'country' table and the 'match_season' table, linking them through the country identifier. The result is grouped by country name to show the total number of players representing each country.", "virtual_table": "SELECT Country_name ,  COUNT(*) FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country GROUP BY T1.Country_name"}
{"sample_id": "train.1109", "db_id": "match_season", "question": "Return the colleges that have players who play the Midfielder position, as well as players who play the Defender position.", "rationale": ["Identify the relevant table, which is 'match_season'.", "Select the column to display, 'College'.", "Use the INTERSECT operation to combine results from two queries, each filtering for a specific player position using placeholders for string values."], "gold_sql": "SELECT College FROM match_season WHERE POSITION  =  'Midfielder' INTERSECT SELECT College FROM match_season WHERE POSITION  =  'Defender'", "source_tables": ["match_season"], "description": "The virtual table provides a list of colleges attended by players from the 'match_season' table who play either the Midfielder or Defender position. The query uses an INTERSECT operation to ensure that only colleges with players in both specified positions are included, with placeholders representing the positions being filtered.", "virtual_table": "SELECT College FROM match_season WHERE POSITION  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT College FROM match_season WHERE POSITION  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1064", "db_id": "match_season", "question": "Show the draft pick numbers and draft classes of players whose positions are defenders.", "rationale": ["Identify the relevant table, which is 'match_season'.", "Select the columns to display, 'Draft_Pick_Number' and 'Draft_Class'.", "Add a condition to filter the 'Position' column for the specified position using a placeholder for string values."], "gold_sql": "SELECT Draft_Pick_Number ,  Draft_Class FROM match_season WHERE POSITION  =  'Defender'", "source_tables": ["match_season"], "description": "The virtual table provides information about the draft pick numbers and draft classes of players from the 'match_season' table who play in a specific position. The placeholder in the WHERE clause represents the position of the players.", "virtual_table": "SELECT Draft_Pick_Number ,  Draft_Class FROM match_season WHERE POSITION  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1093", "db_id": "match_season", "question": "How many players are from each country?", "rationale": ["Identify the relevant tables, which are 'country' and 'match_season'.", "Select the 'Country_name' from the 'country' table and count the number of players from the 'match_season' table.", "Join the two tables on the country identifier to link players to their respective countries.", "Group the results by 'Country_name' to get the count of players for each country."], "gold_sql": "SELECT Country_name ,  COUNT(*) FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country GROUP BY T1.Country_name", "source_tables": ["country", "match_season"], "description": "The virtual table summarizes the count of players associated with each country by joining the 'country' and 'match_season' tables. It displays the country names alongside the total number of players representing each country. The grouping is done based on the country names to aggregate the player counts accordingly.", "virtual_table": "SELECT Country_name ,  COUNT(*) FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country GROUP BY T1.Country_name"}
{"sample_id": "train.1083", "db_id": "match_season", "question": "Who are the different players, what season do they play in, and what is the name of the team they are on?", "rationale": ["Identify the relevant tables, which are 'match_season' and 'team'.", "Select the columns to display: 'Season' and 'Player' from 'match_season', and 'Name' from 'team'.", "Join the 'match_season' table with the 'team' table on the 'Team' column to link players with their respective teams."], "gold_sql": "SELECT T1.Season ,  T1.Player ,  T2.Name FROM match_season AS T1 JOIN team AS T2 ON T1.Team  =  T2.Team_id", "source_tables": ["team", "match_season"], "description": "The virtual table provides information about players, the seasons they participate in, and the names of the teams they are associated with. It combines data from the 'match_season' table, which includes details about the season and player, with the 'team' table to retrieve the corresponding team names.", "virtual_table": "SELECT T1.Season ,  T1.Player ,  T2.Name FROM match_season AS T1 JOIN team AS T2 ON T1.Team  =  T2.Team_id"}
{"sample_id": "train.1080", "db_id": "match_season", "question": "How many distinct official languages are there among countries of players whose positions are defenders.", "rationale": ["Identify the relevant tables, which are 'country' and 'match_season'.", "Join the 'country' table with the 'match_season' table on the country identifier.", "Count the distinct values of the 'Official_native_language' column from the 'country' table.", "Add a condition to filter the 'Position' column in the 'match_season' table using a placeholder for string values."], "gold_sql": "SELECT count(DISTINCT T1.Official_native_language) FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  'Defender'", "source_tables": ["country", "match_season"], "description": "The virtual table counts the distinct official languages from the 'country' table for players in the 'match_season' table who play in a specific position. The placeholder in the WHERE clause represents the position of the players, specifically filtering for defenders.", "virtual_table": "SELECT count(DISTINCT T1.Official_native_language) FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1082", "db_id": "match_season", "question": "Show the season, the player, and the name of the team that players belong to.", "rationale": ["Identify the relevant tables, which are 'match_season' and 'team'.", "Select the columns to display: 'Season' and 'Player' from 'match_season', and 'Name' from 'team'.", "Join the two tables on the 'Team' column from 'match_season' and 'Team_id' from 'team' to associate players with their teams."], "gold_sql": "SELECT T1.Season ,  T1.Player ,  T2.Name FROM match_season AS T1 JOIN team AS T2 ON T1.Team  =  T2.Team_id", "source_tables": ["team", "match_season"], "description": "The virtual table presents the season, player names, and their corresponding team names by joining the 'match_season' and 'team' tables. The placeholders represent the specific season and player details, allowing for dynamic queries based on user input.", "virtual_table": "SELECT T1.Season ,  T1.Player ,  T2.Name FROM match_season AS T1 JOIN team AS T2 ON T1.Team  =  T2.Team_id"}
{"sample_id": "train.1094", "db_id": "match_season", "question": "Return all players sorted by college in ascending alphabetical order.", "rationale": ["Identify the relevant table, which is 'match_season'.", "Select the column to display, which is 'player'.", "Add an ORDER BY clause to sort the results based on the 'College' column in ascending order."], "gold_sql": "SELECT player FROM match_season ORDER BY College ASC", "source_tables": ["match_season"], "description": "The virtual table lists the names of players from the 'match_season' table, sorted in ascending alphabetical order based on the college they attended. This allows for easy identification of players associated with different colleges.", "virtual_table": "SELECT player FROM match_season ORDER BY College ASC"}
{"sample_id": "train.2528", "db_id": "movie_1", "question": "What are the names of reviewers who had rated 3 star and 4 star?", "rationale": ["Identify the relevant tables, which are 'Rating' and 'Reviewer'.", "Select the column to display, which is 'name' from the 'Reviewer' table.", "Join the 'Rating' table with the 'Reviewer' table using the reviewer's identifier (rID).", "Add conditions to filter the ratings for 3 stars and 4 stars using placeholders for numeric values.", "Use the INTERSECT operator to ensure that only reviewers who rated both 3 stars and 4 stars are included."], "gold_sql": "SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T1.stars  =  3 INTERSECT SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T1.stars  =  4", "source_tables": ["rating", "reviewer"], "description": "The virtual table presents the names of reviewers who have given ratings of 3 stars and 4 stars. It combines data from the 'Rating' and 'Reviewer' tables, using the reviewer's identifier to link the two tables. The placeholders in the query represent the star ratings being filtered.", "virtual_table": "SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2503", "db_id": "movie_1", "question": "For each director, what are the titles and ratings for all the movies they reviewed?", "rationale": ["Identify the relevant tables, which are 'Rating' and 'Movie'.", "Select the columns to display: 'title' from the 'Movie' table, 'stars' from the 'Rating' table, and 'director' from the 'Movie' table.", "Use a JOIN operation to link the 'Rating' and 'Movie' tables based on the movie identifier (mID).", "Add a condition to filter out a specific director using a placeholder for string values.", "Group the results by director to aggregate the maximum rating for each director's movies."], "gold_sql": "SELECT T2.title ,  T1.stars ,  T2.director ,  max(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE director != 'null' GROUP BY director", "source_tables": ["rating", "movie"], "description": "The virtual table provides a summary of movie titles, their directors, and the maximum ratings given by reviewers for each director. The placeholders in the WHERE clause allow for filtering out a specific director's movies, enabling users to focus on the ratings of other directors' films.", "virtual_table": "SELECT T2.title ,  T1.stars ,  T2.director ,  max(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE director != [PLACEHOLDER-TYPE:STRING] GROUP BY director"}
{"sample_id": "train.2531", "db_id": "movie_1", "question": "What are the names of all movies that received 3 or 4 stars?", "rationale": ["Identify the relevant tables, which are 'Rating' and 'Movie'.", "Select the column to display, which is 'title' from the 'Movie' table.", "Join the 'Rating' table with the 'Movie' table on the movie identifier 'mID'.", "Add conditions to filter the 'stars' column for the specified star ratings using placeholders for numeric values.", "Use the INTERSECT operator to combine the results of two separate queries, each targeting a different star rating."], "gold_sql": "SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  3 INTERSECT SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  4", "source_tables": ["rating", "movie"], "description": "The virtual table presents the titles of movies from the 'Movie' table that have received ratings of either 3 or 4 stars. The query utilizes an intersection of two selections, each filtering the ratings based on the specified star values, represented by placeholders for numeric values.", "virtual_table": "SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2502", "db_id": "movie_1", "question": "For each director, return the director's name together with the title of the movie they directed that received the highest rating among all of their movies, and the value of that rating. Ignore movies whose director is NULL.", "rationale": ["Identify the relevant tables, which are 'Rating' and 'Movie'.", "Select the columns to display: 'title' from the 'Movie' table, 'stars' from the 'Rating' table, and 'director' from the 'Movie' table.", "Use a JOIN operation to connect the 'Rating' and 'Movie' tables based on the movie identifier (mID).", "Add a condition to exclude directors who are NULL.", "Group the results by director to find the maximum rating for each director's movies."], "gold_sql": "SELECT T2.title ,  T1.stars ,  T2.director ,  max(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE director != 'null' GROUP BY director", "source_tables": ["rating", "movie"], "description": "The virtual table provides a list of directors along with the titles of their highest-rated movies and the corresponding rating values. It filters out any movies directed by NULL directors and groups the results by each director to ensure that only the top-rated movie per director is displayed.", "virtual_table": "SELECT T2.title ,  T1.stars ,  T2.director ,  max(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE director != [PLACEHOLDER-TYPE:STRING] GROUP BY director"}
{"sample_id": "train.2515", "db_id": "movie_1", "question": "What is the average rating for each movie that has never been reviewed by Brittany Harris?", "rationale": ["Identify the relevant tables, which are 'Rating' and 'Reviewer'.", "Select the column 'mID' and calculate the average of 'stars' for the ratings.", "Use a subquery to find all 'mID's that have been reviewed by the specified reviewer, filtering them out from the main query using the NOT IN clause.", "Group the results by 'mID' to get the average rating for each movie."], "gold_sql": "SELECT mID ,  avg(stars) FROM Rating WHERE mID NOT IN (SELECT T1.mID FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T2.name  =  'Brittany Harris') GROUP BY mID", "source_tables": ["rating", "reviewer"], "description": "The virtual table provides the average rating of movies from the 'Rating' table that have not been reviewed by a specific reviewer. It filters out movies based on the reviewer's name using a subquery, ensuring that only movies without reviews from that reviewer are included in the average calculation.", "virtual_table": "SELECT mID ,  avg(stars) FROM Rating WHERE mID NOT IN (SELECT T1.mID FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING]) GROUP BY mID"}
{"sample_id": "train.2507", "db_id": "movie_1", "question": "For each director, what is the title and score of their most poorly rated movie?", "rationale": ["Identify the relevant tables, which are 'Movie' and 'Rating'.", "Select the columns to display: 'title' from the 'Movie' table and 'stars' from the 'Rating' table.", "Join the 'Rating' table with the 'Movie' table on the movie identifier 'mID'.", "Group the results by the 'director' to ensure we get one entry per director.", "Use the aggregate function 'min' to find the lowest star rating for each director's movies."], "gold_sql": "SELECT T2.title ,  T1.stars ,  T2.director ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T2.director", "source_tables": ["rating", "movie"], "description": "The virtual table provides the title and score of the most poorly rated movie for each director from the 'Movie' and 'Rating' tables. It aggregates the ratings by director and identifies the minimum star rating for their movies, using placeholders to represent the relevant data.", "virtual_table": "SELECT T2.title ,  T1.stars ,  T2.director ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T2.director"}
{"sample_id": "train.2514", "db_id": "movie_1", "question": "Find the average rating star for each movie that are not reviewed by Brittany Harris.", "rationale": ["Identify the relevant tables, which are 'Rating' and 'Reviewer'.", "Select the column 'mID' and calculate the average of 'stars' for the ratings.", "Use a subquery to find 'mID' values that have been reviewed by the specified reviewer, filtering them out from the main query using a NOT IN clause.", "Group the results by 'mID' to get the average rating for each movie."], "gold_sql": "SELECT mID ,  avg(stars) FROM Rating WHERE mID NOT IN (SELECT T1.mID FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T2.name  =  'Brittany Harris') GROUP BY mID", "source_tables": ["rating", "reviewer"], "description": "The virtual table summarizes the average star ratings for movies from the 'Rating' table that have not been reviewed by a specific reviewer. It filters out movies based on the reviewer's name using a subquery, ensuring that only those movies without reviews from the specified reviewer are included in the average calculation.", "virtual_table": "SELECT mID ,  avg(stars) FROM Rating WHERE mID NOT IN (SELECT T1.mID FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING]) GROUP BY mID"}
{"sample_id": "train.2518", "db_id": "movie_1", "question": "Find the average rating star for each movie that received at least 2 ratings.", "rationale": ["Identify the relevant table, which is 'Rating'.", "Select the columns to display, 'mID' and the average of 'stars'.", "Group the results by 'mID' to calculate the average rating for each movie.", "Add a condition to filter the results to include only those movies that have received at least a specified number of ratings using a placeholder for numeric values."], "gold_sql": "SELECT mID ,  avg(stars) FROM Rating GROUP BY mID HAVING count(*)  >=  2", "source_tables": ["rating"], "description": "The virtual table summarizes the average star ratings for movies from the 'Rating' table. It includes the movie identifier and the average rating, filtered to only include movies that have received a minimum number of ratings, as specified by a placeholder for numeric values.", "virtual_table": "SELECT mID ,  avg(stars) FROM Rating GROUP BY mID HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2496", "db_id": "movie_1", "question": "Find the movies with the highest average rating. Return the movie titles and average rating.", "rationale": ["Identify the relevant tables, which are 'Movie' and 'Rating'.", "Select the 'title' from the 'Movie' table and calculate the average of 'stars' from the 'Rating' table.", "Join the 'Rating' table with the 'Movie' table on the movie identifier 'mID'.", "Group the results by 'mID' to ensure the average rating is calculated for each movie.", "Order the results by the average rating in descending order to get the highest rated movies first.", "Add a limit to the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT T2.title ,  avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY avg(T1.stars) DESC LIMIT 1", "source_tables": ["rating", "movie"], "description": "The virtual table provides a list of movie titles along with their average ratings from the 'Movie' and 'Rating' tables. It calculates the average rating for each movie and sorts the results in descending order, allowing the user to specify a limit on the number of movies returned.", "virtual_table": "SELECT T2.title ,  avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY avg(T1.stars) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2483", "db_id": "movie_1", "question": "What are the names of all the reviewers and movie names?", "rationale": ["Identify the relevant tables, which are 'Reviewer' and 'Movie'.", "Select the column 'name' from the 'Reviewer' table and 'title' from the 'Movie' table.", "Use the UNION operator to combine the results from both tables into a single output, allowing for a comprehensive view of both reviewers and movies."], "gold_sql": "SELECT name FROM Reviewer UNION SELECT title FROM Movie", "source_tables": ["movie", "reviewer"], "description": "The virtual table presents a combined list of reviewer names and movie titles from the 'Reviewer' and 'Movie' tables. The use of UNION allows for the merging of these two distinct sets of data into a single output, ensuring that both reviewer names and movie titles are included in the result.", "virtual_table": "SELECT name FROM Reviewer UNION SELECT title FROM Movie"}
{"sample_id": "train.2499", "db_id": "movie_1", "question": "What are the titles and average ratings for all movies that have the lowest average rating?", "rationale": ["Identify the relevant tables, which are 'Movie' and 'Rating'.", "Select the 'title' from the 'Movie' table and calculate the average of 'stars' from the 'Rating' table.", "Join the two tables on the movie identifier 'mID'.", "Group the results by 'mID' to calculate the average rating for each movie.", "Order the results by the average rating in ascending order to find the lowest ratings.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT T2.title ,  avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY avg(T1.stars) LIMIT 1", "source_tables": ["rating", "movie"], "description": "The virtual table summarizes the titles of movies along with their average ratings from the 'Movie' and 'Rating' tables. It calculates the average rating for each movie and orders the results to show those with the lowest average ratings, limited by a specified number of entries.", "virtual_table": "SELECT T2.title ,  avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY avg(T1.stars) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2497", "db_id": "movie_1", "question": "What are the movie titles with the highest average rating and what are those ratings?", "rationale": ["Identify the relevant tables, which are 'Movie' and 'Rating'.", "Select the 'title' from the 'Movie' table and calculate the average of 'stars' from the 'Rating' table.", "Join the 'Rating' table with the 'Movie' table on the movie identifier 'mID'.", "Group the results by 'mID' to calculate the average rating for each movie.", "Order the results by the average rating in descending order to get the highest ratings first.", "Use a placeholder in the LIMIT clause to specify how many top-rated movies to return."], "gold_sql": "SELECT T2.title ,  avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY avg(T1.stars) DESC LIMIT 1", "source_tables": ["rating", "movie"], "description": "The virtual table summarizes the titles of movies along with their average ratings from the 'Movie' and 'Rating' tables. It calculates the average rating for each movie and orders the results to show the movies with the highest average ratings first. The placeholder in the LIMIT clause allows for specifying the number of top-rated movies to retrieve.", "virtual_table": "SELECT T2.title ,  avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY avg(T1.stars) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2517", "db_id": "movie_1", "question": "What are the ids of all moviest hat have not been reviewed by Britanny Harris?", "rationale": ["Identify the relevant table, which is 'Rating', to find movie IDs.", "Use the EXCEPT clause to exclude movie IDs that have been reviewed by a specific reviewer.", "Join the 'Rating' table with the 'Reviewer' table to filter based on the reviewer's name using a placeholder for string values."], "gold_sql": "SELECT mID FROM Rating EXCEPT SELECT T1.mID FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T2.name  =  'Brittany Harris'", "source_tables": ["rating", "reviewer"], "description": "The virtual table lists the unique identifiers of movies from the 'Rating' table that have not received any reviews from a specific reviewer. The placeholder in the query represents the reviewer's name, allowing for dynamic filtering based on the reviewer's identity.", "virtual_table": "SELECT mID FROM Rating EXCEPT SELECT T1.mID FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2508", "db_id": "movie_1", "question": "What is the name of the movie that is rated by most of times?", "rationale": ["Identify the relevant tables, which are 'Rating' and 'Movie'.", "Join the 'Rating' table with the 'Movie' table on the movie identifier to access movie titles.", "Group the results by the movie identifier to count the number of ratings for each movie.", "Order the results in descending order based on the count of ratings to find the most rated movies.", "Use a placeholder in the LIMIT clause to specify how many top-rated movies to return."], "gold_sql": "SELECT T2.title ,  T1.mID FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY count(*) DESC LIMIT 1", "source_tables": ["rating", "movie"], "description": "The virtual table provides the titles of movies from the 'Movie' table that have received the highest number of ratings. It joins the 'Rating' table to count the ratings for each movie, grouping the results by movie identifier. The placeholder in the LIMIT clause indicates the maximum number of movie titles to return.", "virtual_table": "SELECT T2.title ,  T1.mID FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2476", "db_id": "movie_1", "question": "Find the names of all reviewers who rated Gone with the Wind.", "rationale": ["Identify the relevant tables: 'Rating', 'Movie', and 'Reviewer'.", "Select the column to display, which is the 'name' of the reviewer, ensuring distinct names are retrieved.", "Join the 'Rating' table with the 'Movie' table on the movie ID, and then join the 'Reviewer' table on the reviewer ID.", "Add a condition to filter the 'title' column in the 'Movie' table for the specified movie using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T3.name FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID JOIN Reviewer AS T3 ON T1.rID  =  T3.rID WHERE T2.title  =  'Gone with the Wind'", "source_tables": ["rating", "movie", "reviewer"], "description": "The virtual table describes the distinct names of reviewers who have rated a specific movie from the 'Rating', 'Movie', and 'Reviewer' tables. The placeholders in the WHERE clause represent the title of the movie being queried.", "virtual_table": "SELECT DISTINCT T3.name FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID JOIN Reviewer AS T3 ON T1.rID  =  T3.rID WHERE T2.title  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2511", "db_id": "movie_1", "question": "What are the titles of all movies that have between 3 and 5 stars?", "rationale": ["Identify the relevant tables, which are 'Rating' and 'Movie'.", "Select the column to display, 'title' from the 'Movie' table.", "Join the 'Rating' table with the 'Movie' table on the movie identifier 'mID'.", "Add a condition to filter the 'stars' column for the specified range using placeholders for numeric values."], "gold_sql": "SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars BETWEEN 3 AND 5", "source_tables": ["rating", "movie"], "description": "The virtual table presents the titles of movies from the 'Movie' table that have received ratings between a specified range of stars. The placeholders in the WHERE clause represent the minimum and maximum star ratings.", "virtual_table": "SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2460", "db_id": "movie_1", "question": "Find the names of all reviewers who have ratings with a NULL value for the date.", "rationale": ["Identify the relevant tables, which are 'Reviewer' and 'Rating'.", "Select the 'name' column from the 'Reviewer' table and ensure distinct values are returned.", "Join the 'Reviewer' table with the 'Rating' table on the reviewer ID to link ratings to reviewers.", "Add a condition to filter the 'ratingDate' column for NULL values using a placeholder for string values."], "gold_sql": "SELECT DISTINCT name FROM Reviewer AS T1 JOIN Rating AS T2 ON T1.rID  =  T2.rID WHERE ratingDate  =  'null'", "source_tables": ["rating", "reviewer"], "description": "The virtual table contains the distinct names of reviewers from the 'Reviewer' table who have submitted ratings with a NULL value for the rating date. The placeholder in the WHERE clause is used to filter for ratings that do not have a specified date.", "virtual_table": "SELECT DISTINCT name FROM Reviewer AS T1 JOIN Rating AS T2 ON T1.rID  =  T2.rID WHERE ratingDate  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2434", "db_id": "movie_1", "question": "Find the titles of all movies directed by steven spielberg.", "rationale": ["Identify the relevant table, which is 'Movie'.", "Select the column to display, 'title'.", "Add a condition to filter the 'director' column for the specified director using a placeholder for string values."], "gold_sql": "SELECT title FROM Movie WHERE director = 'Steven Spielberg'", "source_tables": ["movie"], "description": "The virtual table contains the titles of movies from the 'Movie' table that are directed by a specific individual. The placeholder in the WHERE clause represents the name of the director.", "virtual_table": "SELECT title FROM Movie WHERE director = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3604", "db_id": "music_1", "question": "What is the shortest and most poorly rated song for each genre, ordered alphabetically by genre?", "rationale": ["Identify the relevant tables, which are 'files' and 'song'.", "Select the minimum duration from the 'files' table and the minimum rating from the 'song' table, along with the genre associated with each song.", "Join the 'files' table with the 'song' table on the file identifier to correlate song details with their respective audio files.", "Group the results by the genre to aggregate the minimum values for each genre.", "Order the final results alphabetically by genre name."], "gold_sql": "SELECT min(T1.duration) ,  min(T2.rating) ,  T2.genre_is FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.genre_is ORDER BY T2.genre_is", "source_tables": ["files", "song"], "description": "The virtual table summarizes the shortest duration and the lowest rating of songs from the 'song' table, grouped by their respective genres. It joins the 'files' table to access the duration of the songs and filters the results to show the minimum duration and rating for each genre. The results are ordered alphabetically by genre name.", "virtual_table": "SELECT min(T1.duration) ,  min(T2.rating) ,  T2.genre_is FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.genre_is ORDER BY T2.genre_is"}
{"sample_id": "train.3603", "db_id": "music_1", "question": "What are the shortest duration and lowest rating of songs grouped by genre and ordered by genre?", "rationale": ["Identify the relevant tables, which are 'files' and 'song'.", "Select the minimum duration from the 'files' table and the minimum rating from the 'song' table.", "Join the two tables on the file identifier to correlate songs with their respective files.", "Group the results by the genre of the songs to aggregate the data accordingly.", "Order the final results by genre to present the data in a structured manner."], "gold_sql": "SELECT min(T1.duration) ,  min(T2.rating) ,  T2.genre_is FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.genre_is ORDER BY T2.genre_is", "source_tables": ["files", "song"], "description": "The virtual table summarizes the shortest duration and lowest rating of songs from the 'song' table, grouped by genre. It combines data from the 'files' table to obtain the duration of each song and filters the results based on the genre. The results are ordered by genre for better organization.", "virtual_table": "SELECT min(T1.duration) ,  min(T2.rating) ,  T2.genre_is FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.genre_is ORDER BY T2.genre_is"}
{"sample_id": "train.3624", "db_id": "music_1", "question": "What is the duration, file size, and song format for every pop song, ordered by title alphabetically?", "rationale": ["Identify the relevant tables, which are 'files' and 'song'.", "Select the columns to display: 'duration', 'file_size', and 'formats' from the 'files' table.", "Join the 'files' table with the 'song' table on the file identifier 'f_id'.", "Add a condition to filter the songs by the specified genre using a placeholder for string values.", "Order the results by the song title in alphabetical order."], "gold_sql": "SELECT T1.duration ,  T1.file_size ,  T1.formats FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T2.genre_is  =  'pop' ORDER BY T2.song_name", "source_tables": ["files", "song"], "description": "The virtual table provides the duration, file size, and formats of audio files associated with songs from the 'files' and 'song' tables. It specifically filters for songs belonging to a particular genre, represented by a placeholder, and orders the results alphabetically by the song title.", "virtual_table": "SELECT T1.duration ,  T1.file_size ,  T1.formats FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T2.genre_is  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T2.song_name"}
{"sample_id": "train.3601", "db_id": "music_1", "question": "What are the maximum duration and resolution of songs grouped and ordered by languages?", "rationale": ["Identify the relevant tables, which are 'files' and 'song'.", "Select the maximum values for 'duration' and 'resolution' from the respective tables.", "Join the 'files' table with the 'song' table on the file identifier 'f_id'.", "Group the results by the 'languages' column from the 'song' table.", "Order the results by the 'languages' column to ensure a sorted output."], "gold_sql": "SELECT max(T1.duration) ,  max(T2.resolution) ,  T2.languages FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.languages ORDER BY T2.languages", "source_tables": ["files", "song"], "description": "The virtual table provides the maximum duration and resolution of songs from the 'files' and 'song' tables, grouped by the languages in which the songs are available. The placeholders in the query allow for dynamic grouping and ordering based on the specified languages.", "virtual_table": "SELECT max(T1.duration) ,  max(T2.resolution) ,  T2.languages FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.languages ORDER BY T2.languages"}
{"sample_id": "train.3587", "db_id": "music_1", "question": "What is the language that was used most often in songs with resolution above 500?", "rationale": ["Identify the relevant table, which is 'song'.", "Select the column to display, 'artist_name'.", "Add a condition to filter the 'resolution' column for values above a specified threshold using a placeholder for numeric values.", "Group the results by the 'languages' column to aggregate the data based on language usage.", "Order the results by the count of occurrences in descending order to find the most frequent language.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT artist_name FROM song WHERE resolution  >  500 GROUP BY languages ORDER BY count(*) DESC LIMIT 1", "source_tables": ["song"], "description": "The virtual table summarizes the artist names from the 'song' table, filtered by a specified audio resolution threshold. It groups the results by the languages in which the songs are available and orders them by the frequency of occurrence, allowing users to identify the most commonly used language in songs that meet the resolution criteria. The placeholders represent the resolution limit and the number of results to return.", "virtual_table": "SELECT artist_name FROM song WHERE resolution  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY languages ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3620", "db_id": "music_1", "question": "What are the top 3 artists with the largest number of songs in the language Bangla?", "rationale": ["Identify the relevant tables, which are 'artist' and 'song'.", "Join the 'artist' table with the 'song' table on the artist's name to correlate artists with their songs.", "Filter the results based on the specified language using a placeholder for string values.", "Group the results by artist name to count the number of songs per artist.", "Order the results by the count of songs in descending order to find the top artists.", "Limit the results to the top specified number of artists."], "gold_sql": "SELECT T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.languages  =  'bangla' GROUP BY T2.artist_name ORDER BY count(*) DESC LIMIT 3", "source_tables": ["artist", "song"], "description": "The virtual table lists the names of artists from the 'artist' table who have performed songs in a specific language. It joins the 'artist' and 'song' tables based on the artist's name, filtering the results to include only those songs that are available in the specified language. The results are grouped by artist name and ordered by the count of songs in descending order, with a limit on the number of artists returned.", "virtual_table": "SELECT T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.languages  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T2.artist_name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3588", "db_id": "music_1", "question": "What is the name of the artist, for each language, that has the most songs with a higher resolution than 500?", "rationale": ["Identify the relevant table, which is 'song'.", "Select the column to display, 'artist_name'.", "Add a condition to filter the 'resolution' column for songs with a resolution greater than a specified number using a placeholder for numeric values.", "Group the results by 'languages' to get the count of songs per language.", "Order the results by the count of songs in descending order to find the artist with the most songs.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT artist_name FROM song WHERE resolution  >  500 GROUP BY languages ORDER BY count(*) DESC LIMIT 1", "source_tables": ["song"], "description": "The virtual table provides the names of artists from the 'song' table who have the most songs available in various languages, specifically those songs that have a resolution higher than a specified value. The placeholders in the WHERE clause and LIMIT allow for dynamic input of the resolution threshold and the number of results to return.", "virtual_table": "SELECT artist_name FROM song WHERE resolution  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY languages ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3569", "db_id": "music_1", "question": "Find the distinct names of all songs that have a higher resolution than some songs in English.", "rationale": ["Identify the relevant table, which is 'song'.", "Select the column to display, 'song_name', ensuring distinct values are returned.", "Add a condition to filter songs based on their resolution compared to the minimum resolution of songs in a specified language using a placeholder for string values."], "gold_sql": "SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  'english')", "source_tables": ["song"], "description": "The virtual table provides a list of distinct song names from the 'song' table that have a higher audio resolution than the minimum resolution of songs available in a specific language. The placeholder in the subquery represents the language for which the comparison is made.", "virtual_table": "SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.3575", "db_id": "music_1", "question": "List the name and gender for all artists who released songs in March.", "rationale": ["Identify the relevant tables, which are 'artist' and 'song'.", "Select the columns to display, 'artist_name' and 'gender' from the 'artist' table.", "Join the 'artist' table with the 'song' table on the 'artist_name' column to associate artists with their songs.", "Add a condition to filter the 'releasedate' column in the 'song' table to match the specified month using a placeholder for string values."], "gold_sql": "SELECT T1.artist_name ,  T1.gender FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.releasedate LIKE '%Mar%'", "source_tables": ["artist", "song"], "description": "The virtual table provides the names and genders of artists from the 'artist' table who have released songs in a specific month. The placeholder in the WHERE clause is used to filter the release date of the songs based on the specified month.", "virtual_table": "SELECT T1.artist_name ,  T1.gender FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.releasedate LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3570", "db_id": "music_1", "question": "What are the different names for all songs that have a higher resolution than English songs?", "rationale": ["Identify the relevant table, which is 'song'.", "Select the distinct column 'song_name' to ensure unique song titles are returned.", "Add a condition to filter songs based on their resolution compared to the minimum resolution of songs in a specified language using a subquery with a placeholder for string values."], "gold_sql": "SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  'english')", "source_tables": ["song"], "description": "The virtual table presents the distinct names of songs from the 'song' table that have a higher audio resolution than the minimum resolution of songs available in a specific language. The placeholder in the subquery represents the language for which the resolution is being compared.", "virtual_table": "SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.3552", "db_id": "music_1", "question": "Find the file format that is used by the most files.", "rationale": ["Identify the relevant table, which is 'files'.", "Select the 'formats' column to display the file formats.", "Group the results by the 'formats' column to aggregate the data.", "Order the results by the count of files for each format in descending order to find the most used format.", "Add a limit to specify how many top formats to return using a placeholder for numeric values."], "gold_sql": "SELECT formats FROM files GROUP BY formats ORDER BY COUNT (*) DESC LIMIT 1", "source_tables": ["files"], "description": "The virtual table summarizes the file formats available in the 'files' table, grouped by format type. It orders the results by the count of files associated with each format in descending order, allowing the user to identify the most commonly used file format. The placeholder in the LIMIT clause indicates the number of top formats to retrieve.", "virtual_table": "SELECT formats FROM files GROUP BY formats ORDER BY COUNT (*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3551", "db_id": "music_1", "question": "What is the most popular file format?", "rationale": ["Identify the relevant table, which is 'files'.", "Select the 'formats' column to display the available file formats.", "Group the results by 'formats' to count occurrences of each format.", "Order the results in descending order based on the count of each format to find the most popular one.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT formats FROM files GROUP BY formats ORDER BY COUNT (*) DESC LIMIT 1", "source_tables": ["files"], "description": "The virtual table summarizes the different file formats available in the 'files' table, grouping them to identify the most popular format based on the count of occurrences. The placeholder in the LIMIT clause allows for specifying the number of top formats to retrieve.", "virtual_table": "SELECT formats FROM files GROUP BY formats ORDER BY COUNT (*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3542", "db_id": "music_1", "question": "What are the names of the artists who sang the shortest song?", "rationale": ["Identify the relevant tables, which are 'song' and 'files'.", "Select the column to display, 'artist_name' from the 'song' table.", "Join the 'song' table with the 'files' table on the file identifier 'f_id' to access the duration of the songs.", "Order the results by the duration of the songs in ascending order to find the shortest songs.", "Use a placeholder in the LIMIT clause to specify how many artist names to return."], "gold_sql": "SELECT T1.artist_name FROM song AS T1 JOIN files AS T2 ON T1.f_id  =  T2.f_id ORDER BY T2.duration LIMIT 1", "source_tables": ["files", "song"], "description": "The virtual table provides the names of artists from the 'song' table who performed the shortest songs, by joining with the 'files' table to access the duration of each song. The placeholder in the LIMIT clause allows for specifying the number of results to return.", "virtual_table": "SELECT T1.artist_name FROM song AS T1 JOIN files AS T2 ON T1.f_id  =  T2.f_id ORDER BY T2.duration LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3530", "db_id": "music_1", "question": "What is the name of the song that was released most recently?", "rationale": ["Identify the relevant table, which is 'song'.", "Select the columns to display, 'song_name' and 'releasedate'.", "Order the results by 'releasedate' in descending order to get the most recent songs.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT song_name ,  releasedate FROM song ORDER BY releasedate DESC LIMIT 1", "source_tables": ["song"], "description": "The virtual table provides the title of songs along with their release dates from the 'song' table, ordered by the release date in descending order. The placeholder in the LIMIT clause indicates the number of most recent songs to retrieve.", "virtual_table": "SELECT song_name ,  releasedate FROM song ORDER BY releasedate DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3558", "db_id": "music_1", "question": "What countries are the female artists who sung in the language Bangla from?", "rationale": ["Identify the relevant tables, which are 'artist' and 'song'.", "Select the 'country' column from the 'artist' table.", "Join the 'artist' table with the 'song' table on the 'artist_name' column to link artists with their songs.", "Add conditions to filter the results based on the specified gender and language using placeholders for string values."], "gold_sql": "SELECT T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  'Female' AND T2.languages  =  'bangla'", "source_tables": ["artist", "song"], "description": "The virtual table provides information about the countries of female artists who have performed songs in a specific language. It combines data from the 'artist' table, which includes details about the artist's gender and country, with the 'song' table, which contains information about the languages in which the songs are available. The placeholders in the WHERE clause allow for filtering by gender and language.", "virtual_table": "SELECT T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  [PLACEHOLDER-TYPE:STRING] AND T2.languages  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3541", "db_id": "music_1", "question": "What is the name of the artist who produced the shortest song?", "rationale": ["Identify the relevant tables, which are 'song' and 'files'.", "Join the two tables on the file identifier 'f_id' to access both song and file details.", "Select the 'artist_name' from the 'song' table.", "Order the results by the 'duration' from the 'files' table to find the shortest song.", "Use a placeholder to limit the results to the top entry."], "gold_sql": "SELECT T1.artist_name FROM song AS T1 JOIN files AS T2 ON T1.f_id  =  T2.f_id ORDER BY T2.duration LIMIT 1", "source_tables": ["files", "song"], "description": "The virtual table identifies the artist associated with the shortest song by joining the 'song' and 'files' tables. It selects the artist's name and orders the results based on the duration of the songs, using a placeholder to limit the number of results returned.", "virtual_table": "SELECT T1.artist_name FROM song AS T1 JOIN files AS T2 ON T1.f_id  =  T2.f_id ORDER BY T2.duration LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3546", "db_id": "music_1", "question": "What is the count of the songs that last approximately 4 minutes?", "rationale": ["Identify the relevant table, which is 'files'.", "Select the count of all entries in the table.", "Add a condition to filter the 'duration' column for songs that last approximately 4 minutes using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM files WHERE duration LIKE '4:%'", "source_tables": ["files"], "description": "The virtual table provides a count of audio files from the 'files' table that have a duration matching a specific pattern. The placeholder in the WHERE clause allows for filtering based on the duration of the songs, which is expressed as a string.", "virtual_table": "SELECT count(*) FROM files WHERE duration LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3531", "db_id": "music_1", "question": "What is the id of the longest song?", "rationale": ["Identify the relevant table, which is 'files'.", "Select the column to display, 'f_id', which is the unique identifier for the file.", "Order the results by the 'duration' column in descending order to find the longest song.", "Limit the results to a specific number using a placeholder for numeric values."], "gold_sql": "SELECT f_id FROM files ORDER BY duration DESC LIMIT 1", "source_tables": ["files"], "description": "The virtual table provides the unique identifier for audio files from the 'files' table, specifically focusing on the longest song by ordering the results based on the duration of the songs in descending order. The placeholder in the LIMIT clause indicates the number of results to return, which can be adjusted as needed.", "virtual_table": "SELECT f_id FROM files ORDER BY duration DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3586", "db_id": "music_1", "question": "What are the languages that are used most often in songs?", "rationale": ["Identify the relevant table, which is 'song'.", "Select the column to display, 'languages'.", "Group the results by 'languages' to count occurrences.", "Order the results in descending order based on the count of occurrences.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT languages FROM song GROUP BY languages ORDER BY count(*) DESC LIMIT 1", "source_tables": ["song"], "description": "The virtual table summarizes the languages used in songs from the 'song' table, grouping them to identify the most frequently occurring languages. The placeholder in the LIMIT clause allows for specifying the number of top languages to retrieve based on their occurrence count.", "virtual_table": "SELECT languages FROM song GROUP BY languages ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3557", "db_id": "music_1", "question": "What is the country of origin of the artist who is female and produced a song in Bangla?", "rationale": ["Identify the relevant tables, which are 'artist' and 'song'.", "Select the 'country' column from the 'artist' table.", "Join the 'artist' table with the 'song' table on the 'artist_name' column to link artists with their songs.", "Add conditions to filter the 'gender' column for female artists and the 'languages' column for the specified language using placeholders for string values."], "gold_sql": "SELECT T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  'Female' AND T2.languages  =  'bangla'", "source_tables": ["artist", "song"], "description": "The virtual table describes the country of origin of female artists from the 'artist' table who have produced songs in a specific language. The placeholders in the WHERE clause represent the gender of the artist and the language of the song.", "virtual_table": "SELECT T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  [PLACEHOLDER-TYPE:STRING] AND T2.languages  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3566", "db_id": "music_1", "question": "What is the gender and name of the artist who sang the song with the smallest resolution?", "rationale": ["Identify the relevant tables, which are 'artist' and 'song'.", "Select the columns to display, 'gender' and 'artist_name' from the 'artist' table.", "Join the 'artist' table with the 'song' table on the 'artist_name' column to associate artists with their songs.", "Order the results by the 'resolution' column from the 'song' table to find the song with the smallest resolution.", "Limit the results to a single entry using a placeholder for numeric values."], "gold_sql": "SELECT T1.gender ,  T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.resolution LIMIT 1", "source_tables": ["artist", "song"], "description": "The virtual table describes the gender and name of artists from the 'artist' table who performed songs from the 'song' table. The results are ordered by the resolution of the songs, allowing the user to retrieve the artist associated with the song that has the smallest resolution, as indicated by the placeholder for limiting the number of results.", "virtual_table": "SELECT T1.gender ,  T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.resolution LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3545", "db_id": "music_1", "question": "How many songs have 4 minute duration?", "rationale": ["Identify the relevant table, which is 'files'.", "Select the count of records to display the total number of songs.", "Add a condition to filter the 'duration' column for the specified duration using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM files WHERE duration LIKE '4:%'", "source_tables": ["files"], "description": "The virtual table provides a count of audio files from the 'files' table that match a specific duration. The placeholder in the WHERE clause represents the duration of the audio files being queried.", "virtual_table": "SELECT count(*) FROM files WHERE duration LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6191", "db_id": "music_4", "question": "Show the famous titles of the artists with both volumes that lasted more than 2 weeks on top and volumes that lasted less than 2 weeks on top.", "rationale": ["Identify the relevant tables, which are 'artist' and 'volume'.", "Select the column to display, 'Famous_Title', from the 'artist' table.", "Join the 'artist' table with the 'volume' table using the 'Artist_ID' to link them.", "Add conditions to filter the results based on the number of weeks the songs stayed at the top, using placeholders for numeric values.", "Use the INTERSECT operator to find titles that meet both conditions."], "gold_sql": "SELECT T1.Famous_Title FROM artist AS T1 JOIN volume AS T2 ON T1.Artist_ID  =  T2.Artist_ID WHERE T2.Weeks_on_Top  >  2 INTERSECT SELECT T1.Famous_Title FROM artist AS T1 JOIN volume AS T2 ON T1.Artist_ID  =  T2.Artist_ID WHERE T2.Weeks_on_Top  <  2", "source_tables": ["artist", "volume"], "description": "The virtual table presents the famous titles of artists from the 'artist' table who have achieved recognition in both categories: those whose songs have spent more than a specified number of weeks at the top and those whose songs have spent less than a specified number of weeks at the top. The placeholders in the query represent the numeric values for the weeks on top.", "virtual_table": "SELECT T1.Famous_Title FROM artist AS T1 JOIN volume AS T2 ON T1.Artist_ID  =  T2.Artist_ID WHERE T2.Weeks_on_Top  >  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T1.Famous_Title FROM artist AS T1 JOIN volume AS T2 ON T1.Artist_ID  =  T2.Artist_ID WHERE T2.Weeks_on_Top  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6156", "db_id": "music_4", "question": "Return the categories of music festivals that have the result \"Awarded\".", "rationale": ["Identify the relevant table, which is 'music_festival'.", "Select the column to display, 'Category'.", "Add a condition to filter the 'Result' column for the specified outcome using a placeholder for string values."], "gold_sql": "SELECT Category FROM music_festival WHERE RESULT  =  'Awarded'", "source_tables": ["music_festival"], "description": "The virtual table provides a list of categories from the 'music_festival' table where the outcome of the festival participation is specified as awarded. The placeholder in the WHERE clause represents the result status of the festival.", "virtual_table": "SELECT Category FROM music_festival WHERE RESULT  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6167", "db_id": "music_4", "question": "Please show the songs that have result \"nominated\" at music festivals.", "rationale": ["Identify the relevant tables, which are 'music_festival' and 'volume'.", "Select the 'Song' column from the 'volume' table.", "Join the 'music_festival' table with the 'volume' table using the volume identifier.", "Add a condition to filter the results based on the specified result status using a placeholder for string values."], "gold_sql": "SELECT T2.Song FROM music_festival AS T1 JOIN volume AS T2 ON T1.Volume  =  T2.Volume_ID WHERE T1.Result  =  'Nominated'", "source_tables": ["music_festival", "volume"], "description": "The virtual table displays the songs that have received a 'nominated' result at music festivals. It combines data from the 'music_festival' and 'volume' tables, linking them through the volume identifier. The placeholder in the WHERE clause represents the specific result status being queried.", "virtual_table": "SELECT T2.Song FROM music_festival AS T1 JOIN volume AS T2 ON T1.Volume  =  T2.Volume_ID WHERE T1.Result  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6195", "db_id": "music_4", "question": "What is the issue date of the volume with the minimum weeks on top?", "rationale": ["Identify the relevant table, which is 'volume'.", "Select the column to display, 'Issue_Date'.", "Order the results by 'Weeks_on_Top' in ascending order to find the volume with the minimum weeks on top.", "Limit the results to one record using a placeholder for numeric values."], "gold_sql": "SELECT Issue_Date FROM volume ORDER BY Weeks_on_Top ASC LIMIT 1", "source_tables": ["volume"], "description": "The virtual table provides the issue date of the volume from the 'volume' table that has the least number of weeks at the top of the charts. The placeholder in the LIMIT clause indicates the number of records to return, which is set to one in this case.", "virtual_table": "SELECT Issue_Date FROM volume ORDER BY Weeks_on_Top ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6187", "db_id": "music_4", "question": "What is the song in the volume with the maximum weeks on top?", "rationale": ["Identify the relevant table, which is 'volume'.", "Select the 'Song' column to display the song identifiers.", "Order the results by 'Weeks_on_Top' in descending order to prioritize songs with the most weeks at the top.", "Limit the results to a specific number using a placeholder for numeric values."], "gold_sql": "SELECT Song FROM volume ORDER BY Weeks_on_Top DESC LIMIT 1", "source_tables": ["volume"], "description": "The virtual table contains the song identifiers from the 'volume' table, ordered by the number of weeks each song has spent at the top of the charts. The placeholder in the LIMIT clause indicates the maximum number of results to return, which is determined by the user.", "virtual_table": "SELECT Song FROM volume ORDER BY Weeks_on_Top DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6180", "db_id": "music_4", "question": "Return the famous release date for the oldest artist.", "rationale": ["Identify the relevant table, which is 'artist'.", "Select the column to display, 'Famous_Release_date'.", "Order the results by the 'Age' column in descending order to find the oldest artist.", "Limit the results to one entry using a placeholder for numeric values."], "gold_sql": "SELECT Famous_Release_date FROM artist ORDER BY Age DESC LIMIT 1", "source_tables": ["artist"], "description": "The virtual table provides the famous release date of artists from the 'artist' table, specifically focusing on the oldest artist. The query orders the artists by age in descending order and limits the result to the oldest artist using a numeric placeholder.", "virtual_table": "SELECT Famous_Release_date FROM artist ORDER BY Age DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4445", "db_id": "network_2", "question": "What are the names of every person who has a friend over 40 and under 30?", "rationale": ["Identify the relevant tables, which are 'Person' and 'PersonFriend'.", "Select the column to display, which is 'name' from the 'Person' table.", "Join the 'Person' table with the 'PersonFriend' table on the name column to link individuals with their friends.", "Use subqueries to filter friends based on the specified age conditions, one for friends over a certain age and another for friends under a certain age.", "Utilize the INTERSECT operator to find names that meet both conditions."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  40) INTERSECT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  30)", "source_tables": ["personfriend", "person"], "description": "The virtual table identifies the names of individuals from the 'Person' table who have friends that fall into two specific age categories: those over a certain age and those under a certain age. The query utilizes a join between the 'Person' and 'PersonFriend' tables to establish the relationship between individuals and their friends, and it employs subqueries to filter friends based on the specified age criteria.", "virtual_table": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  [PLACEHOLDER-TYPE:NUMBER]) INTERSECT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.4443", "db_id": "network_2", "question": "What are the different names and ages of every friend of either Dan or alice?", "rationale": ["Identify the relevant tables, which are 'Person' and 'PersonFriend'.", "Select the columns to display, 'name' and 'age', ensuring they are distinct.", "Join the 'Person' table with the 'PersonFriend' table on the name column to associate friends with their respective individuals.", "Add a condition to filter the 'friend' column for the specified individuals using placeholders for string values."], "gold_sql": "SELECT DISTINCT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Dan' OR T2.friend  =  'Alice'", "source_tables": ["personfriend", "person"], "description": "The virtual table presents the distinct names and ages of friends associated with specific individuals from the 'Person' table. It combines data from both the 'Person' and 'PersonFriend' tables, filtering for friends of the specified individuals. The placeholders in the WHERE clause represent the names of the individuals whose friends are being queried.", "virtual_table": "SELECT DISTINCT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] OR T2.friend  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4480", "db_id": "network_2", "question": "What is the total number of people who has no friend living in the city of Austin.", "rationale": ["Identify the relevant table, which is 'PersonFriend'.", "Count the distinct names to find the total number of people without friends in the specified city.", "Add a condition to filter out friends based on their city of residence using a subquery and a placeholder for string values."], "gold_sql": "SELECT count(DISTINCT name) FROM PersonFriend WHERE friend NOT IN (SELECT name FROM person WHERE city  =  'Austin')", "source_tables": ["personfriend", "person"], "description": "The virtual table provides a count of distinct individuals from the 'PersonFriend' table who do not have any friends residing in a specified city. The placeholder in the WHERE clause represents the name of the city to filter the results accordingly.", "virtual_table": "SELECT count(DISTINCT name) FROM PersonFriend WHERE friend NOT IN (SELECT name FROM person WHERE city  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.4478", "db_id": "network_2", "question": "Which person whose friends have the oldest average age?", "rationale": ["Identify the relevant tables, which are 'Person' and 'PersonFriend'.", "Select the column 'name' from 'PersonFriend' and calculate the average age from 'Person'.", "Join the two tables on the condition that the friend's name in 'PersonFriend' matches the name in 'Person'.", "Group the results by the person's name to calculate the average age of their friends.", "Order the results by the average age in descending order to find the person with the oldest average age of friends.", "Add a limit to the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT T2.name ,  avg(T1.age) FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend GROUP BY T2.name ORDER BY avg(T1.age) DESC LIMIT 1", "source_tables": ["personfriend", "person"], "description": "The virtual table summarizes the names of individuals from the 'Person' table along with the average age of their friends. It combines data from the 'Person' and 'PersonFriend' tables, grouping the results by each person's name and ordering them by the average age of their friends in descending order. The placeholder in the LIMIT clause indicates the maximum number of results to return.", "virtual_table": "SELECT T2.name ,  avg(T1.age) FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend GROUP BY T2.name ORDER BY avg(T1.age) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4444", "db_id": "network_2", "question": "Find the name of the person who has friends with age above 40 and under age 30?", "rationale": ["Identify the relevant tables, which are 'Person' and 'PersonFriend'.", "Select the column to display, which is 'name' from the 'Person' table.", "Join the 'Person' table with the 'PersonFriend' table on the name column to relate individuals with their friends.", "Use subqueries to filter friends based on age criteria, with placeholders for the specific age values."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  40) INTERSECT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  30)", "source_tables": ["personfriend", "person"], "description": "The virtual table describes the names of individuals from the 'Person' table who have friends that fall within two specific age ranges: those older than a certain age and those younger than another age. The placeholders in the query represent the age limits for filtering friends' ages.", "virtual_table": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  [PLACEHOLDER-TYPE:NUMBER]) INTERSECT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.4467", "db_id": "network_2", "question": "Whare the names, friends, and ages of all people who are older than the average age of a person?", "rationale": ["Identify the relevant tables, which are 'Person' and 'PersonFriend'.", "Select the columns to display: 'name' and 'friend' from 'PersonFriend', and 'age' from 'Person'.", "Join the two tables on the condition that the name in 'Person' matches the friend in 'PersonFriend'.", "Add a condition to filter the results where the age from 'Person' is greater than the average age calculated from the 'Person' table."], "gold_sql": "SELECT DISTINCT T2.name ,  T2.friend ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.age  >  (SELECT avg(age) FROM person)", "source_tables": ["personfriend", "person"], "description": "The virtual table provides a list of distinct names, friends, and ages of individuals from the 'Person' and 'PersonFriend' tables. It specifically filters for those individuals whose age exceeds the average age of all persons in the database. The placeholders in the query represent the necessary conditions and values for the age comparison.", "virtual_table": "SELECT DISTINCT T2.name ,  T2.friend ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.age  >  (SELECT avg(age) FROM person)"}
{"sample_id": "train.4475", "db_id": "network_2", "question": "What are the names, ages, and jobs of all people who are friends with Alice for the longest amount of time?", "rationale": ["Identify the relevant tables, which are 'Person' and 'PersonFriend'.", "Select the columns to display: 'name', 'age', and 'job' from the 'Person' table.", "Join the 'Person' table with the 'PersonFriend' table on the person's name.", "Add a condition to filter the 'friend' column for the specified friend using a placeholder for string values.", "Use a subquery to find the maximum year of friendship for the specified friend, ensuring we only get the longest friendships."], "gold_sql": "SELECT T1.name ,  T1.age ,  T1.job FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend =  'Alice' AND T2.year  =  (SELECT max(YEAR) FROM PersonFriend WHERE friend =  'Alice')", "source_tables": ["personfriend", "person"], "description": "The virtual table provides the names, ages, and job titles of individuals from the 'Person' table who have a friendship with a specified person for the longest duration. The query joins the 'Person' and 'PersonFriend' tables based on the person's name and filters the results to include only those friends of the specified individual, while also determining the maximum year of friendship established.", "virtual_table": "SELECT T1.name ,  T1.age ,  T1.job FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend =  [PLACEHOLDER-TYPE:STRING] AND T2.year  =  (SELECT max(YEAR) FROM PersonFriend WHERE friend =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.4481", "db_id": "network_2", "question": "What is the total number of people who have no friends living in Austin?", "rationale": ["Identify the relevant tables, which are 'PersonFriend' and 'Person'.", "Use the count function to determine the total number of distinct names from 'PersonFriend'.", "Add a condition to filter out friends based on the city specified using a placeholder for string values."], "gold_sql": "SELECT count(DISTINCT name) FROM PersonFriend WHERE friend NOT IN (SELECT name FROM person WHERE city  =  'Austin')", "source_tables": ["personfriend", "person"], "description": "The virtual table provides a count of distinct individuals from the 'PersonFriend' table who do not have any friends listed in the 'Person' table and reside in a specific city. The placeholder in the WHERE clause represents the name of the city.", "virtual_table": "SELECT count(DISTINCT name) FROM PersonFriend WHERE friend NOT IN (SELECT name FROM person WHERE city  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.4469", "db_id": "network_2", "question": "Which friend of Zach has the longest-lasting friendship?", "rationale": ["Identify the relevant table, which is 'PersonFriend'.", "Select the column to display, 'friend'.", "Add a condition to filter the 'name' column for the specified person using a placeholder for string values.", "Incorporate a subquery to find the maximum year of friendship for the specified person, ensuring we identify the longest-lasting friendship."], "gold_sql": "SELECT friend FROM PersonFriend WHERE name =  'Zach' AND YEAR  =  (SELECT max(YEAR) FROM PersonFriend WHERE name =  'Zach')", "source_tables": ["personfriend"], "description": "The virtual table provides the names of friends from the 'PersonFriend' table for a specific person, along with a condition to find the friend with the longest-lasting friendship. The placeholder in the WHERE clause represents the person's name, and the subquery identifies the maximum year of friendship established.", "virtual_table": "SELECT friend FROM PersonFriend WHERE name =  [PLACEHOLDER-TYPE:STRING] AND YEAR  =  (SELECT max(YEAR) FROM PersonFriend WHERE name =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.4410", "db_id": "network_2", "question": "Who is the oldest person whose job is student?", "rationale": ["Identify the relevant table, which is 'Person'.", "Select the column to display, 'name'.", "Add conditions to filter the 'job' column for the specified job title using a placeholder for string values.", "Incorporate a subquery to find the maximum age of individuals with the specified job title, ensuring that the outer query only returns the name of the oldest student."], "gold_sql": "SELECT name FROM Person WHERE job  =  'student' AND age  =  (SELECT max(age) FROM person WHERE job  =  'student' )", "source_tables": ["person"], "description": "The virtual table provides the names of individuals from the 'Person' table who are identified as students and are the oldest among that group. The query includes a condition to filter by job title and a subquery to determine the maximum age of individuals with that job title, using placeholders for the job title.", "virtual_table": "SELECT name FROM Person WHERE job  =  [PLACEHOLDER-TYPE:STRING] AND age  =  (SELECT max(age) FROM person WHERE job  =  [PLACEHOLDER-TYPE:STRING] )"}
{"sample_id": "train.4411", "db_id": "network_2", "question": "What is the name of the oldest student?", "rationale": ["Identify the relevant table, which is 'Person'.", "Select the column to display, 'name'.", "Add a condition to filter the 'job' column for the specified job title using a placeholder for string values.", "Incorporate a subquery to find the maximum age for individuals with the specified job title, ensuring that the main query only returns the oldest individual(s)."], "gold_sql": "SELECT name FROM Person WHERE job  =  'student' AND age  =  (SELECT max(age) FROM person WHERE job  =  'student' )", "source_tables": ["person"], "description": "The virtual table provides the names of individuals from the 'Person' table who hold a specific job title and are the oldest among those with the same job. The query includes a subquery that determines the maximum age for the specified job title, ensuring that only the oldest individual(s) are selected.", "virtual_table": "SELECT name FROM Person WHERE job  =  [PLACEHOLDER-TYPE:STRING] AND age  =  (SELECT max(age) FROM person WHERE job  =  [PLACEHOLDER-TYPE:STRING] )"}
{"sample_id": "train.4473", "db_id": "network_2", "question": "What are the names of all people who are friends with Alice for the shortest amount of time?", "rationale": ["Identify the relevant table, which is 'PersonFriend'.", "Select the column to display, 'name', which represents the names of people who are friends.", "Add a condition to filter the 'friend' column for the specified friend's name using a placeholder for string values.", "Incorporate a subquery to find the minimum year of friendship for the specified friend, ensuring that only the shortest friendships are included."], "gold_sql": "SELECT name FROM PersonFriend WHERE friend =  'Alice' AND YEAR  =  (SELECT min(YEAR) FROM PersonFriend WHERE friend =  'Alice')", "source_tables": ["personfriend"], "description": "The virtual table provides the names of individuals who are friends with a specified person, filtered to show only those friendships that have lasted for the shortest duration. The query utilizes a placeholder for the friend's name and another placeholder to determine the minimum year of friendship established.", "virtual_table": "SELECT name FROM PersonFriend WHERE friend =  [PLACEHOLDER-TYPE:STRING] AND YEAR  =  (SELECT min(YEAR) FROM PersonFriend WHERE friend =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.4455", "db_id": "network_2", "question": "What are the names of all of Bob's friends?", "rationale": ["Identify the relevant tables, which are 'Person' and 'PersonFriend'.", "Select the column to display, which is 'name' from the 'Person' table.", "Join the 'Person' table with the 'PersonFriend' table on the name column to link friends with their respective persons.", "Add a condition to filter the 'friend' column for the specified person's name using a placeholder for string values."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Bob'", "source_tables": ["personfriend", "person"], "description": "The virtual table describes the names of individuals from the 'Person' table who are friends of a specific person. The join operation connects the 'Person' table with the 'PersonFriend' table based on the person's name, and the placeholder in the WHERE clause represents the name of the person whose friends are being queried.", "virtual_table": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4454", "db_id": "network_2", "question": "Find the name of persons who are friends with Bob.", "rationale": ["Identify the relevant tables, which are 'Person' and 'PersonFriend'.", "Select the column to display, 'name' from the 'Person' table.", "Join the 'Person' table with the 'PersonFriend' table on the name column to establish the relationship between persons and their friends.", "Add a condition to filter the 'friend' column for the specified friend's name using a placeholder for string values."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Bob'", "source_tables": ["personfriend", "person"], "description": "The virtual table describes the names of persons from the 'Person' table who are friends with a specific individual. The placeholder in the WHERE clause represents the name of the friend being queried.", "virtual_table": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2072", "db_id": "party_people", "question": "How many events are there for each party?", "rationale": ["Identify the relevant tables, which are 'party_events' and 'party'.", "Join the 'party_events' table with the 'party' table using the party identifier to associate events with their respective parties.", "Select the 'party_name' from the 'party' table and count the number of events from the 'party_events' table.", "Group the results by the party identifier to get the count of events for each party."], "gold_sql": "SELECT T2.party_name ,  count(*) FROM party_events AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id", "source_tables": ["party", "party_events"], "description": "The virtual table summarizes the count of events organized by each political party. It combines data from the 'party_events' table, which records the events, and the 'party' table, which contains information about the political parties. The result includes the party names along with the total number of events associated with each party, grouped by the party identifier.", "virtual_table": "SELECT T2.party_name ,  count(*) FROM party_events AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id"}
{"sample_id": "train.2057", "db_id": "party_people", "question": "Show all party names and the number of members in each party.", "rationale": ["Identify the relevant tables, which are 'Member' and 'party'.", "Select the 'party_name' from the 'party' table and count the number of members from the 'Member' table.", "Join the 'Member' table with the 'party' table using the party identifier to associate members with their respective parties.", "Group the results by the party identifier to aggregate the member count for each party."], "gold_sql": "SELECT T2.party_name ,  count(*) FROM Member AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id", "source_tables": ["party", "member"], "description": "The virtual table presents the names of political parties along with the count of their respective members. It combines data from the 'Member' and 'party' tables, linking them through the party identifier. The result is grouped by each party to provide a total count of members associated with each party name.", "virtual_table": "SELECT T2.party_name ,  count(*) FROM Member AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id"}
{"sample_id": "train.2082", "db_id": "party_people", "question": "Count the number of Annual Meeting events that took place in the region of the United Kingdom.", "rationale": ["Identify the relevant tables: 'region', 'party', and 'party_events'.", "Join the 'region' table with the 'party' table on the 'Region_ID' to associate parties with their respective regions.", "Join the resulting table with the 'party_events' table on the 'Party_ID' to link events to the parties.", "Use the COUNT function to count the number of events that match the specified criteria.", "Add conditions to filter the results based on the region's name and the event's name using placeholders for string values."], "gold_sql": "SELECT count(*) FROM region AS t1 JOIN party AS t2 ON t1.region_id  =  t2.region_id JOIN party_events AS t3 ON t2.party_id  =  t3.party_id WHERE t1.region_name  =  'United Kingdom' AND t3.Event_Name  =  'Annaual Meeting'", "source_tables": ["party", "party_events", "region"], "description": "The virtual table counts the total number of Annual Meeting events organized by political parties in a specified region. It combines data from the 'region', 'party', and 'party_events' tables, filtering based on the region's name and the event's name using placeholders for both values.", "virtual_table": "SELECT count(*) FROM region AS t1 JOIN party AS t2 ON t1.region_id  =  t2.region_id JOIN party_events AS t3 ON t2.party_id  =  t3.party_id WHERE t1.region_name  =  [PLACEHOLDER-TYPE:STRING] AND t3.Event_Name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2049", "db_id": "party_people", "question": "Show all ministers who do not belong to Progress Party.", "rationale": ["Identify the relevant table, which is 'party'.", "Select the column to display, 'minister'.", "Add a condition to filter out the ministers belonging to the specified party using a placeholder for string values."], "gold_sql": "SELECT minister FROM party WHERE party_name != 'Progress Party'", "source_tables": ["party"], "description": "The virtual table presents the identifiers of ministers from the 'party' table who are not associated with a specific political party. The placeholder in the WHERE clause allows for the specification of the party name to exclude from the results.", "virtual_table": "SELECT minister FROM party WHERE party_name != [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.315", "db_id": "product_catalog", "question": "What are the entry names of catalog with the attribute possessed by most entries.", "rationale": ["Identify the relevant tables, which are 'Catalog_Contents' and 'Catalog_Contents_Additional_Attributes'.", "Select the column 'catalog_entry_name' from 'Catalog_Contents'.", "Join 'Catalog_Contents' with 'Catalog_Contents_Additional_Attributes' on 'catalog_entry_id' to link entries with their attributes.", "Use a subquery to find the most common 'attribute_value' by grouping and counting entries, ordering them in descending order.", "Add a condition to filter the results based on the most common attribute value, with a placeholder for limiting the number of results."], "gold_sql": "SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.attribute_value  =  (SELECT attribute_value FROM Catalog_Contents_Additional_Attributes GROUP BY attribute_value ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["catalog_contents", "catalog_contents_additional_attributes"], "description": "The virtual table provides the names of catalog entries from the 'Catalog_Contents' table that are associated with the attribute that is possessed by the most entries. The query uses a subquery to determine the most common attribute value based on the count of entries, with a placeholder for limiting the results to a specific number.", "virtual_table": "SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.attribute_value  =  (SELECT attribute_value FROM Catalog_Contents_Additional_Attributes GROUP BY attribute_value ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.316", "db_id": "product_catalog", "question": "Find the entry names of the catalog with the attribute that have the most entries.", "rationale": ["Identify the relevant tables, which are 'Catalog_Contents' and 'Catalog_Contents_Additional_Attributes'.", "Select the column to display, 'catalog_entry_name', from 'Catalog_Contents'.", "Join 'Catalog_Contents' with 'Catalog_Contents_Additional_Attributes' on 'catalog_entry_id' to link entries with their attributes.", "Use a subquery to find the attribute value that has the most entries by grouping and counting occurrences, ordering them in descending order, and limiting the results with a placeholder for numeric values."], "gold_sql": "SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.attribute_value  =  (SELECT attribute_value FROM Catalog_Contents_Additional_Attributes GROUP BY attribute_value ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["catalog_contents", "catalog_contents_additional_attributes"], "description": "The virtual table describes the names of catalog entries from the 'Catalog_Contents' table that are associated with the attribute having the highest number of entries. The query utilizes a join between 'Catalog_Contents' and 'Catalog_Contents_Additional_Attributes' to filter entries based on the most frequent attribute value, with a placeholder for the limit on the number of entries to consider.", "virtual_table": "SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.attribute_value  =  (SELECT attribute_value FROM Catalog_Contents_Additional_Attributes GROUP BY attribute_value ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.332", "db_id": "product_catalog", "question": "Which catalog contents have length below 3 or above 5? Find the catalog entry names.", "rationale": ["Identify the relevant table, which is 'Catalog_Contents'.", "Select the column to display, 'catalog_entry_name'.", "Add conditions to filter the entries based on the length and width measurements using placeholders for numeric values."], "gold_sql": "SELECT catalog_entry_name FROM catalog_contents WHERE LENGTH  <  3 OR width  >  5", "source_tables": ["catalog_contents"], "description": "The virtual table presents the names of catalog entries from the 'Catalog_Contents' table that have a length measurement below a specified value or above another specified value. The placeholders in the WHERE clause represent the numeric thresholds for length and width.", "virtual_table": "SELECT catalog_entry_name FROM catalog_contents WHERE LENGTH  <  [PLACEHOLDER-TYPE:NUMBER] OR width  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.331", "db_id": "product_catalog", "question": "Find the names of the products with length smaller than 3 or height greater than 5.", "rationale": ["Identify the relevant table, which is 'Catalog_Contents'.", "Select the column to display, 'catalog_entry_name'.", "Add conditions to filter the entries based on the 'length' and 'height' columns using placeholders for numeric values."], "gold_sql": "SELECT catalog_entry_name FROM catalog_contents WHERE LENGTH  <  3 OR width  >  5", "source_tables": ["catalog_contents"], "description": "The virtual table presents the names of products from the 'Catalog_Contents' table that meet specific dimensional criteria. The placeholders in the WHERE clause allow for the input of numeric values to filter products based on their length and height measurements.", "virtual_table": "SELECT catalog_entry_name FROM catalog_contents WHERE LENGTH  <  [PLACEHOLDER-TYPE:NUMBER] OR width  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.311", "db_id": "product_catalog", "question": "Which catalog publisher has published the most catalogs?", "rationale": ["Identify the relevant table, which is 'Catalogs'.", "Select the 'catalog_publisher' column to display the names of the publishers.", "Group the results by 'catalog_publisher' to count the number of catalogs each has published.", "Order the results by the count of catalogs in descending order to find the publisher with the most catalogs.", "Add a limit to restrict the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT catalog_publisher FROM catalogs GROUP BY catalog_publisher ORDER BY count(*) DESC LIMIT 1", "source_tables": ["catalogs"], "description": "The virtual table summarizes the catalog publishers from the 'Catalogs' table, grouping them by the publisher's name and counting the number of catalogs each has published. The result is ordered in descending order to identify the publisher with the highest count, with a placeholder to limit the number of results returned.", "virtual_table": "SELECT catalog_publisher FROM catalogs GROUP BY catalog_publisher ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.317", "db_id": "product_catalog", "question": "What is the entry name of the most expensive catalog (in USD)?", "rationale": ["Identify the relevant table, which is 'Catalog_Contents'.", "Select the column to display, 'catalog_entry_name'.", "Order the results by 'price_in_dollars' in descending order to get the most expensive entries first.", "Use a placeholder in the LIMIT clause to specify how many entries to return."], "gold_sql": "SELECT catalog_entry_name FROM catalog_contents ORDER BY price_in_dollars DESC LIMIT 1", "source_tables": ["catalog_contents"], "description": "The virtual table provides the names of catalog entries from the 'Catalog_Contents' table, ordered by their price in US dollars. The placeholder in the LIMIT clause indicates the number of entries to return, allowing for flexibility in specifying how many of the most expensive entries to retrieve.", "virtual_table": "SELECT catalog_entry_name FROM catalog_contents ORDER BY price_in_dollars DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.320", "db_id": "product_catalog", "question": "Find the level name of the catalog with the lowest price (in USD).", "rationale": ["Identify the relevant tables, which are 'Catalog_Contents' and 'Catalog_Structure'.", "Select the column to display, 'catalog_level_name' from 'Catalog_Structure'.", "Join the two tables on the 'catalog_level_number' to relate the catalog entries to their respective levels.", "Order the results by 'price_in_dollars' to find the lowest price.", "Use a placeholder in the LIMIT clause to specify how many results to return."], "gold_sql": "SELECT t2.catalog_level_name FROM catalog_contents AS t1 JOIN catalog_structure AS t2 ON t1.catalog_level_number  =  t2.catalog_level_number ORDER BY t1.price_in_dollars LIMIT 1", "source_tables": ["catalog_structure", "catalog_contents"], "description": "The virtual table describes the catalog level names from the 'Catalog_Contents' table, joined with the 'Catalog_Structure' table, ordered by the price in US dollars. The placeholder in the LIMIT clause indicates the number of results to return, which corresponds to the catalog entry with the lowest price.", "virtual_table": "SELECT t2.catalog_level_name FROM catalog_contents AS t1 JOIN catalog_structure AS t2 ON t1.catalog_level_number  =  t2.catalog_level_number ORDER BY t1.price_in_dollars LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5589", "db_id": "products_gen_characteristics", "question": "What are the names of products that are not 'white' in color and are not measured by the unit 'Handful'?", "rationale": ["Identify the relevant tables, which are 'Products', 'Ref_Product_Categories', and 'Ref_Colors'.", "Select the column to display, 'product_name' from the 'Products' table.", "Join the 'Products' table with 'Ref_Product_Categories' and 'Ref_Colors' to access the necessary attributes for filtering.", "Add conditions to filter the results based on the specified color and unit of measure using placeholders for string values."], "gold_sql": "SELECT t1.product_name FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code JOIN ref_colors AS t3 ON t1.color_code  =  t3.color_code WHERE t3.color_description  =  'white' AND t2.unit_of_measure != 'Handful'", "source_tables": ["products", "ref_colors", "ref_product_categories"], "description": "The virtual table describes the names of products from the 'Products' table that are filtered based on their color and unit of measure. The placeholders in the WHERE clause represent the specific color description and the unit of measure that should not be matched.", "virtual_table": "SELECT t1.product_name FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code JOIN ref_colors AS t3 ON t1.color_code  =  t3.color_code WHERE t3.color_description  =  [PLACEHOLDER-TYPE:STRING] AND t2.unit_of_measure != [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5586", "db_id": "products_gen_characteristics", "question": "Find the unit of measurement and product category code of product named \"chervil\".", "rationale": ["Identify the relevant tables, which are 'Products' and 'Ref_Product_Categories'.", "Select the columns to display, 'unit_of_measure' and 'product_category_code'.", "Join the 'Products' table with 'Ref_Product_Categories' on the product category code to access the unit of measurement.", "Add a condition to filter the 'Products' table for the specified product name using a placeholder for string values."], "gold_sql": "SELECT t2.unit_of_measure ,  t2.product_category_code FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code WHERE t1.product_name  =  'chervil'", "source_tables": ["products", "ref_product_categories"], "description": "The virtual table provides the unit of measurement and product category code for products listed in the 'Products' table, specifically for a product with a given name. The placeholder in the WHERE clause represents the name of the product being queried.", "virtual_table": "SELECT t2.unit_of_measure ,  t2.product_category_code FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5590", "db_id": "products_gen_characteristics", "question": "What is the description of the color for most products?", "rationale": ["Identify the relevant tables, which are 'Products' and 'Ref_Colors'.", "Join the 'Products' table with 'Ref_Colors' on the 'color_code' to access color descriptions.", "Group the results by 'color_description' to aggregate the data based on color.", "Order the results by the count of products associated with each color description in descending order.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) DESC LIMIT 1", "source_tables": ["products", "ref_colors"], "description": "The virtual table describes the color descriptions associated with products from the 'Products' table. It aggregates the colors by their descriptions and orders them by the count of products associated with each color, allowing for the retrieval of the most common color descriptions based on the specified limit.", "virtual_table": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5576", "db_id": "products_gen_characteristics", "question": "Count the products that have the color description \"white\" or have the characteristic name \"hot\".", "rationale": ["Identify the relevant tables: 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors'.", "Count the total number of products by using the count(*) function.", "Join 'Products' with 'Product_Characteristics' to link products to their characteristics.", "Join 'Product_Characteristics' with 'Characteristics' to access the characteristic names.", "Join 'Products' with 'Ref_Colors' to filter products based on their color description.", "Add a condition in the WHERE clause to filter products that match either the specified color description or characteristic name using placeholders."], "gold_sql": "SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  'white' OR t3.characteristic_name  =  'hot'", "source_tables": ["products", "ref_colors", "characteristics", "product_characteristics"], "description": "The virtual table counts the total number of products from the 'Products' table that either have a specific color description or a specific characteristic name. It joins multiple tables: 'Product_Characteristics' to link products with their characteristics, 'Characteristics' to access the characteristic names, and 'Ref_Colors' to filter by color description. The placeholders in the WHERE clause represent the color description and characteristic name to be specified by the user.", "virtual_table": "SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  [PLACEHOLDER-TYPE:STRING] OR t3.characteristic_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5562", "db_id": "products_gen_characteristics", "question": "List all characteristics of product named \"sesame\" with type code \"Grade\".", "rationale": ["Identify the relevant tables: 'Products', 'Product_Characteristics', and 'Characteristics'.", "Select the column to display, which is 'characteristic_name' from the 'Characteristics' table.", "Join the 'Products' table with 'Product_Characteristics' on 'product_id' to link products with their characteristics.", "Join 'Product_Characteristics' with 'Characteristics' on 'characteristic_id' to access characteristic details.", "Add conditions to filter the results based on the specified product name and characteristic type code using placeholders for string values."], "gold_sql": "SELECT t3.characteristic_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  'sesame' AND t3.characteristic_type_code  =  'Grade'", "source_tables": ["products", "characteristics", "product_characteristics"], "description": "The virtual table describes the names of characteristics associated with a specific product from the 'Products' table, filtered by the product's name and the type of characteristic. The placeholders in the WHERE clause represent the product's name and the characteristic type code.", "virtual_table": "SELECT t3.characteristic_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING] AND t3.characteristic_type_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5592", "db_id": "products_gen_characteristics", "question": "What is the description of the color used by least products?", "rationale": ["Identify the relevant tables, which are 'Products' and 'Ref_Colors'.", "Join the 'Products' table with the 'Ref_Colors' table on the color code to access color descriptions.", "Group the results by color description to count the number of products associated with each color.", "Order the results in ascending order based on the count of products to find the least used colors.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) ASC LIMIT 1", "source_tables": ["products", "ref_colors"], "description": "The virtual table describes the color descriptions from the 'Ref_Colors' table that are associated with the least number of products in the 'Products' table. The placeholder in the LIMIT clause represents the number of colors to retrieve, allowing for flexibility in specifying how many of the least used colors to return.", "virtual_table": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5579", "db_id": "products_gen_characteristics", "question": "Return the unit of measure for 'Herb' products.", "rationale": ["Identify the relevant table, which is 'Ref_Product_Categories'.", "Select the column to display, 'unit_of_measure'.", "Add a condition to filter the 'product_category_code' column for the specified product category using a placeholder for string values."], "gold_sql": "SELECT unit_of_measure FROM ref_product_categories WHERE product_category_code  =  'Herbs'", "source_tables": ["ref_product_categories"], "description": "The virtual table provides the unit of measure for products categorized under a specific product category. The placeholder in the WHERE clause represents the unique code for the product category, allowing users to specify which category they are interested in.", "virtual_table": "SELECT unit_of_measure FROM ref_product_categories WHERE product_category_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5526", "db_id": "products_gen_characteristics", "question": "Find the names of all the product characteristics.", "rationale": ["Identify the relevant table, which is 'Characteristics'.", "Select the column to display, 'characteristic_name'.", "Use DISTINCT to ensure that only unique characteristic names are returned."], "gold_sql": "SELECT DISTINCT characteristic_name FROM CHARACTERISTICS", "source_tables": ["characteristics"], "description": "The virtual table contains the distinct names of product characteristics from the 'Characteristics' table. This table allows users to retrieve unique characteristic names without duplicates.", "virtual_table": "SELECT DISTINCT characteristic_name FROM CHARACTERISTICS"}
{"sample_id": "train.5643", "db_id": "railway", "question": "Show the id and builder of the railway that are associated with the most trains.", "rationale": ["Identify the relevant tables, which are 'railway' and 'train'.", "Select the columns to display, 'Railway_ID' and 'Builder'.", "Join the 'railway' table with the 'train' table on the Railway_ID to associate trains with their respective railways.", "Group the results by Railway_ID to count the number of trains associated with each railway.", "Order the results by the count of trains in descending order to find the railway with the most trains.", "Limit the results to a specific number using a placeholder for numeric values."], "gold_sql": "SELECT T2.Railway_ID ,  T1.Builder FROM railway AS T1 JOIN train AS T2 ON T1.Railway_ID  =  T2.Railway_ID GROUP BY T2.Railway_ID ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["train", "railway"], "description": "The virtual table provides the Railway_ID and Builder of railways from the 'railway' table that are linked to the highest number of trains. The results are grouped by Railway_ID and ordered by the count of associated trains in descending order, with a limit set by a placeholder for numeric values.", "virtual_table": "SELECT T2.Railway_ID ,  T1.Builder FROM railway AS T1 JOIN train AS T2 ON T1.Railway_ID  =  T2.Railway_ID GROUP BY T2.Railway_ID ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5645", "db_id": "railway", "question": "Show the most common builder of railways.", "rationale": ["Identify the relevant table, which is 'railway'.", "Select the 'Builder' column to display the names of builders.", "Group the results by 'Builder' to count occurrences.", "Order the results in descending order based on the count of builders to find the most common one.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT Builder FROM railway GROUP BY Builder ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["railway"], "description": "The virtual table summarizes the builders of railways from the 'railway' table, grouping them to identify the most frequently occurring builder. The placeholder in the LIMIT clause allows for specifying the number of top builders to display.", "virtual_table": "SELECT Builder FROM railway GROUP BY Builder ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5633", "db_id": "railway", "question": "List the builders of railways in ascending alphabetical order.", "rationale": ["Identify the relevant table, which is 'railway'.", "Select the column to display, 'Builder'.", "Add an order clause to sort the results in ascending order based on the 'Builder' column."], "gold_sql": "SELECT Builder FROM railway ORDER BY Builder ASC", "source_tables": ["railway"], "description": "The virtual table lists the names of builders from the 'railway' table, sorted in ascending alphabetical order. This allows users to view the builders associated with various railways in a structured manner.", "virtual_table": "SELECT Builder FROM railway ORDER BY Builder ASC"}
{"sample_id": "train.1300", "db_id": "soccer_1", "question": "List the names of all left-footed players who have overall rating between 85 and 90.", "rationale": ["Identify the relevant tables, which are 'Player' and 'Player_Attributes'.", "Select the 'player_name' column from the 'Player' table.", "Join the 'Player' table with the 'Player_Attributes' table using the 'player_api_id'.", "Add conditions to filter for left-footed players and to check if their overall rating falls within the specified range using placeholders for string and numeric values."], "gold_sql": "SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.preferred_foot  =  'left' AND T2.overall_rating  >=  85 AND T2.overall_rating  <=  90", "source_tables": ["player_attributes", "player"], "description": "The virtual table lists the distinct names of players from the 'Player' table who are left-footed and have an overall skill rating within a specified range. The placeholders in the WHERE clause represent the preferred foot and the range of overall ratings.", "virtual_table": "SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.preferred_foot  =  [PLACEHOLDER-TYPE:STRING] AND T2.overall_rating  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.overall_rating  <=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1299", "db_id": "soccer_1", "question": "List the names of all players who have a crossing score higher than 90 and prefer their right foot.", "rationale": ["Identify the relevant tables, which are 'Player' and 'Player_Attributes'.", "Select the 'player_name' column from the 'Player' table.", "Join the 'Player' table with the 'Player_Attributes' table using the 'player_api_id' to link player attributes to their respective players.", "Add conditions to filter players based on their crossing score and preferred foot, using placeholders for the numeric and string values."], "gold_sql": "SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.crossing  >  90 AND T2.preferred_foot  =  'right'", "source_tables": ["player_attributes", "player"], "description": "The virtual table lists the names of players from the 'Player' table who have a crossing score exceeding a specified threshold and prefer using their right foot. The placeholders in the WHERE clause allow for dynamic input of the crossing score and preferred foot type.", "virtual_table": "SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.crossing  >  [PLACEHOLDER-TYPE:NUMBER] AND T2.preferred_foot  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1298", "db_id": "soccer_1", "question": "What are the names of players who have the best dribbling?", "rationale": ["Identify the relevant tables, which are 'Player' and 'Player_Attributes'.", "Select the 'player_name' column from the 'Player' table.", "Join the 'Player' table with the 'Player_Attributes' table on the 'player_api_id' to access player attributes.", "Use a subquery to find the maximum dribbling skill from the 'Player_Attributes' table.", "Add a condition to filter the results to include only players with the highest dribbling skill."], "gold_sql": "SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.dribbling  =  ( SELECT max(overall_rating) FROM Player_Attributes)", "source_tables": ["player_attributes", "player"], "description": "The virtual table provides the names of players from the 'Player' table who possess the highest dribbling skill. It joins the 'Player' table with the 'Player_Attributes' table to access the dribbling attribute and filters the results to include only those players whose dribbling skill matches the maximum value found in the 'Player_Attributes' table.", "virtual_table": "SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.dribbling  =  ( SELECT max(overall_rating) FROM Player_Attributes)"}
{"sample_id": "train.1306", "db_id": "soccer_1", "question": "List the names and birthdays of the top five players in terms of potential.", "rationale": ["Identify the relevant tables, which are 'Player' and 'Player_Attributes'.", "Select the columns to display, 'player_name' and 'birthday'.", "Join the 'Player' table with the 'Player_Attributes' table on the 'player_api_id' to access potential ratings.", "Order the results by the 'potential' column in descending order to get the top players.", "Use a placeholder in the LIMIT clause to specify the number of top players to return."], "gold_sql": "SELECT DISTINCT T1.player_name ,  T1.birthday FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id  =  T2.player_api_id ORDER BY potential DESC LIMIT 5", "source_tables": ["player_attributes", "player"], "description": "The virtual table provides the names and birthdays of players from the 'Player' table, specifically focusing on the top five players based on their potential skill rating. The query joins the 'Player' table with the 'Player_Attributes' table to access the potential ratings, and the placeholder in the LIMIT clause allows for specifying the number of top players to retrieve.", "virtual_table": "SELECT DISTINCT T1.player_name ,  T1.birthday FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id  =  T2.player_api_id ORDER BY potential DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1296", "db_id": "soccer_1", "question": "What is the maximum and minimum height of all players?", "rationale": ["Identify the relevant table, which is 'Player'.", "Select the maximum and minimum values of the 'height' column.", "Use aggregate functions to calculate the maximum and minimum height of all players."], "gold_sql": "SELECT max(weight) ,  min(weight) FROM Player", "source_tables": ["player"], "description": "The virtual table provides the maximum and minimum height of players from the 'Player' table. The placeholders in the SELECT statement represent the aggregate functions for height values.", "virtual_table": "SELECT max(weight) ,  min(weight) FROM Player"}
{"sample_id": "train.1305", "db_id": "soccer_1", "question": "Who are the top 3 players in terms of overall rating?", "rationale": ["Identify the relevant tables, which are 'Player' and 'Player_Attributes'.", "Join the 'Player' table with 'Player_Attributes' on the 'player_api_id' to access player names and their overall ratings.", "Select the 'player_name' column to display the names of the players.", "Order the results by 'overall_rating' in descending order to get the top players.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id  =  T2.player_api_id ORDER BY overall_rating DESC LIMIT 3", "source_tables": ["player_attributes", "player"], "description": "The virtual table lists the names of players from the 'Player' table who have the highest overall skill ratings. The results are ordered in descending order based on the overall rating, and the number of players returned is determined by a placeholder for numeric values.", "virtual_table": "SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id  =  T2.player_api_id ORDER BY overall_rating DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5015", "db_id": "soccer_2", "question": "For each position, what is the maximum number of  hours for students who spent more than 1000 hours training?", "rationale": ["Identify the relevant tables, which are 'Player' and 'Tryout'.", "Select the maximum hours from the 'HS' column in the 'Player' table and group the results by the 'pPos' column from the 'Tryout' table.", "Add a condition to filter players based on their training hours using a placeholder for numeric values."], "gold_sql": "SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  1000 GROUP BY T2.pPos", "source_tables": ["player", "tryout"], "description": "The virtual table summarizes the maximum hours of training for players based on their positions. It combines data from the 'Player' and 'Tryout' tables, filtering for players who have trained for more than a specified number of hours. The placeholder in the WHERE clause represents the threshold of training hours.", "virtual_table": "SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos"}
{"sample_id": "train.5014", "db_id": "soccer_2", "question": "What is the maximum training hours for the students whose training hours is greater than 1000 in different positions?", "rationale": ["Identify the relevant tables, which are 'Player' and 'Tryout'.", "Select the maximum training hours and the position from the respective tables.", "Join the 'Player' and 'Tryout' tables on the player ID to correlate players with their tryout positions.", "Add a condition to filter players based on their training hours using a placeholder for numeric values.", "Group the results by the position to get the maximum training hours for each position."], "gold_sql": "SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  1000 GROUP BY T2.pPos", "source_tables": ["player", "tryout"], "description": "The virtual table summarizes the maximum training hours of players from the 'Player' table who have training hours exceeding a specified threshold. It groups the results by the position the players are trying out for, as indicated in the 'Tryout' table. The placeholder in the WHERE clause represents the minimum training hours required for the selection.", "virtual_table": "SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos"}
{"sample_id": "train.5039", "db_id": "soccer_2", "question": "What are the states with colleges that have enrollments less than the some other college?", "rationale": ["Identify the relevant table, which is 'College'.", "Select the distinct 'state' column to avoid duplicates.", "Add a condition to filter the 'enr' column for colleges with enrollment numbers less than a subquery that retrieves the maximum enrollment number from the 'College' table."], "gold_sql": "SELECT DISTINCT state FROM college WHERE enr  <  (SELECT max(enr) FROM college)", "source_tables": ["college"], "description": "The virtual table provides a list of distinct states where colleges have enrollment numbers that are less than the maximum enrollment number found among all colleges. This allows users to identify states with colleges that have relatively lower student enrollments compared to the highest enrollment college.", "virtual_table": "SELECT DISTINCT state FROM college WHERE enr  <  (SELECT max(enr) FROM college)"}
{"sample_id": "train.4993", "db_id": "soccer_2", "question": "What is the name of the school with smallest enrollment size per state?", "rationale": ["Identify the relevant table, which is 'College'.", "Select the columns to display: 'cName', 'state', and the minimum enrollment number 'min(enr)'.", "Group the results by the 'state' column to find the college with the smallest enrollment size in each state."], "gold_sql": "SELECT cName ,  state ,  min(enr) FROM college GROUP BY state", "source_tables": ["college"], "description": "The virtual table summarizes the names of colleges along with their respective states and the minimum enrollment size for each state. The query groups the results by state, allowing for the identification of the college with the smallest enrollment in each state.", "virtual_table": "SELECT cName ,  state ,  min(enr) FROM college GROUP BY state"}
{"sample_id": "train.5023", "db_id": "soccer_2", "question": "How many students are enrolled in colleges that have student accepted during tryouts, and in which states are those colleges?", "rationale": ["Identify the relevant tables, which are 'College' and 'Tryout'.", "Select the columns to display, 'state' and 'enr' from the 'College' table.", "Join the 'College' table with the 'Tryout' table on the college name to filter the results based on tryout decisions.", "Add a condition to filter the results based on the decision made during the tryouts using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.state ,  T1.enr FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  'yes'", "source_tables": ["tryout", "college"], "description": "The virtual table provides a distinct list of states and enrollment numbers of colleges from the 'College' table that have accepted students during tryouts. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.", "virtual_table": "SELECT DISTINCT T1.state ,  T1.enr FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5035", "db_id": "soccer_2", "question": "What are the names of all the states with college students playing in the mid position but no goalies?", "rationale": ["Identify the relevant tables, which are 'College' and 'Tryout'.", "Join the 'College' table with the 'Tryout' table based on the college name to access the states of colleges with players trying out.", "Filter the results to include only those players trying out for a specified position using a placeholder for string values.", "Use the EXCEPT clause to exclude states where players are trying out for the goalie position, again using a placeholder for string values."], "gold_sql": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'mid' EXCEPT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'goalie'", "source_tables": ["tryout", "college"], "description": "The virtual table provides a list of states where colleges have students participating in tryouts for a specific position, excluding those states where students are trying out for the goalie position. The placeholders in the query represent the positions of interest for filtering the results.", "virtual_table": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5022", "db_id": "soccer_2", "question": "What is the state and enrollment of the colleges where have any students who got accepted in the tryout decision.", "rationale": ["Identify the relevant tables, which are 'College' and 'Tryout'.", "Select the columns to display, 'state' and 'enr' from the 'College' table.", "Join the 'College' table with the 'Tryout' table on the college name to correlate colleges with their tryout results.", "Add a condition to filter the results based on the tryout decision using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.state ,  T1.enr FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  'yes'", "source_tables": ["tryout", "college"], "description": "The virtual table provides a distinct list of states and enrollment numbers of colleges from the 'College' table that have students accepted based on their tryout decisions. The placeholder in the WHERE clause represents the decision status of the tryout.", "virtual_table": "SELECT DISTINCT T1.state ,  T1.enr FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4992", "db_id": "soccer_2", "question": "What is the name of school that has the smallest enrollment in each state?", "rationale": ["Identify the relevant table, which is 'College'.", "Select the columns to display: 'cName', 'state', and the minimum enrollment number 'min(enr)'.", "Group the results by the 'state' column to find the college with the smallest enrollment in each state."], "gold_sql": "SELECT cName ,  state ,  min(enr) FROM college GROUP BY state", "source_tables": ["college"], "description": "The virtual table provides the names of colleges along with their respective states and the minimum enrollment numbers for each state. The query groups the results by state to identify the college with the smallest enrollment in each state.", "virtual_table": "SELECT cName ,  state ,  min(enr) FROM college GROUP BY state"}
{"sample_id": "train.5003", "db_id": "soccer_2", "question": "What are the names and hours spent practicing of every student who received a yes at tryouts?", "rationale": ["Identify the relevant tables, which are 'Player' and 'Tryout'.", "Select the columns to display, 'pName' and 'HS' from the 'Player' table.", "Join the 'Player' table with the 'Tryout' table on the player ID to correlate players with their tryout results.", "Add a condition to filter the 'decision' column in the 'Tryout' table for a specific value using a placeholder for string values."], "gold_sql": "SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes'", "source_tables": ["player", "tryout"], "description": "The virtual table presents the names and high schools of players from the 'Player' table who participated in tryouts and received a positive decision. The placeholder in the WHERE clause indicates the decision status that is being filtered for.", "virtual_table": "SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4989", "db_id": "soccer_2", "question": "For each position, what is the minimum time students spent practicing?", "rationale": ["Identify the relevant tables, which are 'Tryout' and 'Player'.", "Select the minimum time spent practicing, represented by the 'HS' column from the 'Player' table, and the position from the 'Tryout' table.", "Join the 'Tryout' and 'Player' tables on the player identifier 'pID' to correlate players with their tryout positions.", "Group the results by the position to get the minimum practice time for each position."], "gold_sql": "SELECT min(T2.HS) ,   T1.pPos FROM tryout AS T1 JOIN player AS T2 ON T1.pID  =  T2.pID GROUP BY T1.pPos", "source_tables": ["player", "tryout"], "description": "The virtual table summarizes the minimum time students spent practicing for each position from the tryout data. It combines information from the 'Tryout' and 'Player' tables, linking players to their respective tryouts based on their unique identifiers. The result is grouped by position, allowing for an analysis of practice time across different roles.", "virtual_table": "SELECT min(T2.HS) ,   T1.pPos FROM tryout AS T1 JOIN player AS T2 ON T1.pID  =  T2.pID GROUP BY T1.pPos"}
{"sample_id": "train.4985", "db_id": "soccer_2", "question": "What was the most popular position at tryouts?", "rationale": ["Identify the relevant table, which is 'Tryout'.", "Select the column 'pPos' to display the positions players are trying out for.", "Group the results by 'pPos' to aggregate the data based on positions.", "Order the results by the count of players in each position in descending order to find the most popular position.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT pPos FROM tryout GROUP BY pPos ORDER BY count(*) DESC LIMIT 1", "source_tables": ["tryout"], "description": "The virtual table summarizes the positions that players are trying out for in the 'Tryout' table. It groups the results by position and orders them by the count of players in each position, allowing users to identify the most popular position at tryouts. The placeholder in the LIMIT clause indicates the number of top positions to return.", "virtual_table": "SELECT pPos FROM tryout GROUP BY pPos ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5002", "db_id": "soccer_2", "question": "Find the name and hours of the students whose tryout decision is yes.", "rationale": ["Identify the relevant tables, which are 'Player' and 'Tryout'.", "Select the columns to display, 'pName' and 'HS' from the 'Player' table.", "Join the 'Player' table with the 'Tryout' table on the player ID to correlate players with their tryout decisions.", "Add a condition to filter the 'decision' column in the 'Tryout' table for the specified decision using a placeholder for string values."], "gold_sql": "SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes'", "source_tables": ["player", "tryout"], "description": "The virtual table describes the names and high schools of players from the 'Player' table who have a positive decision regarding their tryout. The placeholder in the WHERE clause represents the decision status, allowing for filtering based on the specified value.", "virtual_table": "SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4984", "db_id": "soccer_2", "question": "Which position is most popular among players in the tryout?", "rationale": ["Identify the relevant table, which is 'Tryout'.", "Select the column 'pPos' to display the positions players are trying out for.", "Group the results by 'pPos' to aggregate the data based on positions.", "Order the results by the count of players in each position in descending order to find the most popular position.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT pPos FROM tryout GROUP BY pPos ORDER BY count(*) DESC LIMIT 1", "source_tables": ["tryout"], "description": "The virtual table summarizes the positions that players are trying out for in the 'Tryout' table. It groups the results by position and orders them by the count of players in each position, allowing users to identify the most popular position based on the number of participants. The placeholder in the LIMIT clause indicates the maximum number of results to return.", "virtual_table": "SELECT pPos FROM tryout GROUP BY pPos ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4988", "db_id": "soccer_2", "question": "What is minimum hours of the students playing in different position?", "rationale": ["Identify the relevant tables, which are 'Tryout' and 'Player'.", "Select the minimum hours from the 'Player' table and the position from the 'Tryout' table.", "Join the two tables on the player ID to correlate players with their tryout positions.", "Group the results by the position to get the minimum hours for each position."], "gold_sql": "SELECT min(T2.HS) ,   T1.pPos FROM tryout AS T1 JOIN player AS T2 ON T1.pID  =  T2.pID GROUP BY T1.pPos", "source_tables": ["player", "tryout"], "description": "The virtual table summarizes the minimum hours of students participating in tryouts for different positions. It combines data from the 'Tryout' and 'Player' tables, grouping the results by the position each player is trying out for. The placeholder in the SELECT clause represents the minimum hours associated with the players' high school attendance.", "virtual_table": "SELECT min(T2.HS) ,   T1.pPos FROM tryout AS T1 JOIN player AS T2 ON T1.pID  =  T2.pID GROUP BY T1.pPos"}
{"sample_id": "train.5007", "db_id": "soccer_2", "question": "What are the names of all students who successfully tried out for the position of striker?", "rationale": ["Identify the relevant tables, which are 'Player' and 'Tryout'.", "Select the column to display, 'pName' from the 'Player' table.", "Join the 'Player' table with the 'Tryout' table on the player ID to correlate players with their tryout results.", "Add conditions to filter the results based on the decision made in the tryout and the specific position using placeholders for string values."], "gold_sql": "SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes' AND T2.pPos  =  'striker'", "source_tables": ["player", "tryout"], "description": "The virtual table describes the names of players from the 'Player' table who have successfully tried out for a specific position. It combines data from the 'Player' and 'Tryout' tables, filtering based on the decision made regarding the tryout and the position the player is trying out for. The placeholders in the WHERE clause represent the decision status and the position of interest.", "virtual_table": "SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING] AND T2.pPos  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4957", "db_id": "soccer_2", "question": "What are the names and number of hours spent training for each player who trains for less than 1500 hours?", "rationale": ["Identify the relevant table, which is 'Player'.", "Select the columns to display, 'pName' and 'HS'.", "Add a condition to filter the training hours using a placeholder for numeric values."], "gold_sql": "SELECT pName ,  HS FROM Player WHERE HS  <  1500", "source_tables": ["player"], "description": "The virtual table presents the names of players along with the high school they attended, filtered to include only those players who have trained for fewer hours than a specified threshold. The placeholder in the WHERE clause represents the maximum number of training hours.", "virtual_table": "SELECT pName ,  HS FROM Player WHERE HS  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5010", "db_id": "soccer_2", "question": "Find the average and maximum hours for the students whose tryout decision is yes.", "rationale": ["Identify the relevant tables, which are 'Player' and 'Tryout'.", "Select the aggregate functions to calculate the average and maximum hours from the 'HS' column in the 'Player' table.", "Join the 'Player' table with the 'Tryout' table using the player identifier 'pID'.", "Add a condition to filter the results based on the 'decision' column in the 'Tryout' table using a placeholder for string values."], "gold_sql": "SELECT avg(T1.HS) ,  max(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes'", "source_tables": ["player", "tryout"], "description": "The virtual table provides the average and maximum hours associated with players from the 'Player' table who have a specific tryout decision. The join between the 'Player' and 'Tryout' tables is based on the unique player identifier, and the placeholder in the WHERE clause represents the decision status of the tryout.", "virtual_table": "SELECT avg(T1.HS) ,  max(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5009", "db_id": "soccer_2", "question": "In which state is the college that Charles attends?", "rationale": ["Identify the relevant tables: 'College', 'Tryout', and 'Player'.", "Select the 'state' column from the 'College' table.", "Join the 'Tryout' table on the college name to connect players to their respective colleges.", "Join the 'Player' table on the player ID to filter by a specific player's name using a placeholder."], "gold_sql": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName JOIN player AS T3 ON T2.pID  =  T3.pID WHERE T3.pName  =  'Charles'", "source_tables": ["player", "tryout", "college"], "description": "The virtual table provides the state of the college that a specific player, identified by their name, attends. It combines data from the 'College', 'Tryout', and 'Player' tables, linking them through the college name and player ID. The placeholder in the WHERE clause represents the player's name.", "virtual_table": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName JOIN player AS T3 ON T2.pID  =  T3.pID WHERE T3.pName  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4955", "db_id": "soccer_2", "question": "How many hours do the players train on average?", "rationale": ["Identify the relevant table, which is 'Player'.", "Select the average of the training hours, represented by the 'HS' column.", "The query aims to calculate the average value of the training hours for all players."], "gold_sql": "SELECT avg(HS) FROM Player", "source_tables": ["player"], "description": "The virtual table provides the average training hours of players from the 'Player' table. The placeholder in the SELECT clause represents the training hours of players, which is derived from the high school they attended.", "virtual_table": "SELECT avg(HS) FROM Player"}
{"sample_id": "train.4950", "db_id": "soccer_2", "question": "How many players have more than 1000 hours of training?", "rationale": ["Identify the relevant table, which is 'Player'.", "Select the count of players by using count(*) function.", "Add a condition to filter the 'HS' column for training hours greater than the specified number using a placeholder for numeric values."], "gold_sql": "SELECT count(*) FROM Player WHERE HS  >  1000", "source_tables": ["player"], "description": "The virtual table provides a count of players from the 'Player' table who have a high school training hours exceeding a specified number. The placeholder in the WHERE clause represents the threshold for training hours.", "virtual_table": "SELECT count(*) FROM Player WHERE HS  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4964", "db_id": "soccer_2", "question": "How many students whose are playing the role of goalie?", "rationale": ["Identify the relevant table, which is 'Tryout'.", "Select the count of players by using the count(*) function.", "Add a condition to filter the 'pPos' column for the specified position using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM tryout WHERE pPos  =  'goalie'", "source_tables": ["tryout"], "description": "The virtual table provides a count of players from the 'Tryout' table who are trying out for the position of goalie. The placeholder in the WHERE clause represents the specific position being queried.", "virtual_table": "SELECT count(*) FROM tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4966", "db_id": "soccer_2", "question": "Find the max, average and min training hours of all players.", "rationale": ["Identify the relevant table, which is 'Player'.", "Select the aggregate functions to calculate the average, maximum, and minimum training hours.", "Use the 'HS' column to represent the training hours, applying the aggregate functions accordingly."], "gold_sql": "SELECT avg(HS) ,  max(HS) ,  min(HS) FROM Player", "source_tables": ["player"], "description": "The virtual table summarizes the average, maximum, and minimum training hours of players from the 'Player' table. The placeholder in the SELECT clause represents the training hours of the players, which is derived from the high school column, indicating the training hours associated with each player's high school.", "virtual_table": "SELECT avg(HS) ,  max(HS) ,  min(HS) FROM Player"}
{"sample_id": "train.5013", "db_id": "soccer_2", "question": "What is the average number of hours spent practicing for students who got rejected?", "rationale": ["Identify the relevant tables, which are 'Player' and 'Tryout'.", "Select the average of the hours spent practicing, represented by the 'HS' column from the 'Player' table.", "Join the 'Player' table with the 'Tryout' table on the player ID to correlate players with their tryout decisions.", "Add a condition to filter the results based on the decision status using a placeholder for string values."], "gold_sql": "SELECT avg(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'no'", "source_tables": ["player", "tryout"], "description": "The virtual table provides the average number of hours spent practicing by players from the 'Player' table who were rejected in their tryouts. The placeholder in the WHERE clause represents the decision status of the players' tryouts.", "virtual_table": "SELECT avg(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4951", "db_id": "soccer_2", "question": "How many different players trained for more than 1000 hours?", "rationale": ["Identify the relevant table, which is 'Player'.", "Select the count of players as the output.", "Add a condition to filter the 'HS' column for training hours using a placeholder for numeric values."], "gold_sql": "SELECT count(*) FROM Player WHERE HS  >  1000", "source_tables": ["player"], "description": "The virtual table counts the number of players from the 'Player' table who have trained for a specified number of hours. The placeholder in the WHERE clause represents the threshold of training hours that players must exceed.", "virtual_table": "SELECT count(*) FROM Player WHERE HS  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4947", "db_id": "soccer_2", "question": "How many students, on average, does each college have enrolled?", "rationale": ["Identify the relevant table, which is 'College'.", "Select the column to calculate the average, which is 'enr'.", "Use the AVG function to compute the average enrollment number across all colleges."], "gold_sql": "SELECT avg(enr) FROM College", "source_tables": ["college"], "description": "The virtual table provides the average enrollment number of students from the 'College' table. This average is calculated across all colleges, giving insight into the typical student population at these institutions.", "virtual_table": "SELECT avg(enr) FROM College"}
{"sample_id": "train.4962", "db_id": "soccer_2", "question": "How many students got accepted after the tryout?", "rationale": ["Identify the relevant table, which is 'Tryout'.", "Select the count of records to determine how many players were accepted.", "Add a condition to filter the 'decision' column for the specified acceptance status using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM tryout WHERE decision  =  'yes'", "source_tables": ["tryout"], "description": "The virtual table provides a count of players from the 'Tryout' table who received an acceptance decision after their tryout. The placeholder in the WHERE clause represents the specific decision status being queried.", "virtual_table": "SELECT count(*) FROM tryout WHERE decision  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5030", "db_id": "soccer_2", "question": "How many schools have some students playing in goalie and mid positions.", "rationale": ["Identify the relevant table, which is 'Tryout'.", "Use a subquery to select the college names where players are trying out for the specified positions.", "Utilize the INTERSECT operator to find colleges that have players in both positions.", "Count the distinct colleges that meet the criteria."], "gold_sql": "SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  'goalie' INTERSECT SELECT cName FROM  tryout WHERE pPos  =  'mid')", "source_tables": ["tryout"], "description": "The virtual table counts the number of colleges from the 'Tryout' table where students are trying out for both the goalie and mid positions. The placeholders in the query represent the specific positions being queried.", "virtual_table": "SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.5000", "db_id": "soccer_2", "question": "Find the name of all students who were in the tryout sorted in alphabetic order.", "rationale": ["Identify the relevant tables, which are 'Player' and 'Tryout'.", "Select the column to display, 'pName' from the 'Player' table.", "Join the 'Player' table with the 'Tryout' table using the unique player identifier 'pID'.", "Sort the results in alphabetical order based on the 'pName' column."], "gold_sql": "SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName", "source_tables": ["player", "tryout"], "description": "The virtual table contains the names of players who participated in tryouts, sourced from the 'Player' table. The data is organized in alphabetical order based on the players' names.", "virtual_table": "SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName"}
{"sample_id": "train.4960", "db_id": "soccer_2", "question": "What are the unique types of player positions in the tryout?", "rationale": ["Identify the relevant table, which is 'Tryout'.", "Select the distinct values from the 'pPos' column to count the unique player positions.", "Use the COUNT function to aggregate the distinct player positions."], "gold_sql": "SELECT count(DISTINCT pPos) FROM tryout", "source_tables": ["tryout"], "description": "The virtual table provides a count of unique player positions from the 'Tryout' table. This count reflects the distinct values present in the 'pPos' column, which indicates the various positions players are trying out for.", "virtual_table": "SELECT count(DISTINCT pPos) FROM tryout"}
{"sample_id": "train.3370", "db_id": "sports_competition", "question": "What are the types of competition that have most 5 competitions for that type?", "rationale": ["Identify the relevant table, which is 'competition'.", "Select the column to display, 'Competition_type'.", "Group the results by 'Competition_type' to aggregate the data.", "Add a condition to filter the groups based on the count of competitions using a placeholder for numeric values."], "gold_sql": "SELECT Competition_type FROM competition GROUP BY Competition_type HAVING COUNT(*)  <=  5", "source_tables": ["competition"], "description": "The virtual table summarizes the types of competitions from the 'competition' table, grouping them by their type and filtering to show only those competition types that have a specified maximum number of competitions. The placeholder in the HAVING clause represents the upper limit for the count of competitions for each type.", "virtual_table": "SELECT Competition_type FROM competition GROUP BY Competition_type HAVING COUNT(*)  <=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3374", "db_id": "sports_competition", "question": "What are the positions of both players that have more than 20 20 points and less than 10 points?", "rationale": ["Identify the relevant table, which is 'player'.", "Select the column to display, 'Position'.", "Use the INTERSECT operator to find positions of players who meet both conditions regarding their points, utilizing placeholders for the numeric values."], "gold_sql": "SELECT POSITION FROM player WHERE Points  >  20 INTERSECT SELECT POSITION FROM player WHERE Points  <  10", "source_tables": ["player"], "description": "The virtual table presents the playing positions of players from the 'player' table who have scored more than a specified number of points and less than another specified number of points. The placeholders in the query represent the numeric values for the point thresholds.", "virtual_table": "SELECT POSITION FROM player WHERE Points  >  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT POSITION FROM player WHERE Points  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3383", "db_id": "sports_competition", "question": "which country did participated in the most number of Tournament competitions?", "rationale": ["Identify the relevant table, which is 'competition'.", "Select the 'country' column to display.", "Add a condition to filter the 'competition_type' column for tournament competitions using a placeholder for string values.", "Group the results by 'country' to aggregate the data.", "Order the results by the count of occurrences in descending order to find the country with the most participations.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT country FROM competition WHERE competition_type  =  'Tournament' GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["competition"], "description": "The virtual table summarizes the countries that participated in various competitions, specifically focusing on tournament types. It groups the results by country and orders them by the count of tournament participations in descending order, allowing for the identification of the country with the highest participation. The placeholders represent the type of competition and the limit on the number of results to return.", "virtual_table": "SELECT country FROM competition WHERE competition_type  =  [PLACEHOLDER-TYPE:STRING] GROUP BY country ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3387", "db_id": "sports_competition", "question": "Find the countries that have never participated in any competition with Friendly type.", "rationale": ["Identify the relevant table, which is 'competition'.", "Select the 'country' column to display.", "Use the EXCEPT clause to exclude countries that have participated in competitions of the specified type, utilizing a placeholder for the competition type."], "gold_sql": "SELECT country FROM competition EXCEPT SELECT country FROM competition WHERE competition_type  =  'Friendly'", "source_tables": ["competition"], "description": "The virtual table lists countries that have not participated in any competition of a specific type. It uses a placeholder to filter out countries based on the competition type, allowing users to specify the type of competition they are interested in.", "virtual_table": "SELECT country FROM competition EXCEPT SELECT country FROM competition WHERE competition_type  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3364", "db_id": "sports_competition", "question": "What are the positions of players whose average number of points scored by that position is larger than 20?", "rationale": ["Identify the relevant table, which is 'player'.", "Select the column to display, 'Position'.", "Group the results by 'Position' to calculate the average points for each position.", "Add a condition to filter the groups using the HAVING clause to include only those with an average points score above a specified number, using a placeholder for numeric values."], "gold_sql": "SELECT POSITION FROM player GROUP BY name HAVING avg(Points)  >=  20", "source_tables": ["player"], "description": "The virtual table summarizes the positions of players from the 'player' table, grouped by their playing position. It filters the results to include only those positions where the average points scored by players in that position exceeds a specified threshold. The placeholder in the HAVING clause represents the minimum average points required for inclusion.", "virtual_table": "SELECT POSITION FROM player GROUP BY name HAVING avg(Points)  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3367", "db_id": "sports_competition", "question": "List the most common type of competition.", "rationale": ["Identify the relevant table, which is 'competition'.", "Select the column 'Competition_type' to display the types of competitions.", "Group the results by 'Competition_type' to aggregate them.", "Order the results by the count of each type in descending order to find the most common types.", "Add a limit to specify how many of the most common types to return using a placeholder for numeric values."], "gold_sql": "SELECT Competition_type FROM competition GROUP BY Competition_type ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["competition"], "description": "The virtual table summarizes the types of competitions from the 'competition' table, grouping them to identify the most common type. The placeholder in the LIMIT clause allows for specifying the number of results to return, indicating how many of the most common competition types should be listed.", "virtual_table": "SELECT Competition_type FROM competition GROUP BY Competition_type ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3343", "db_id": "sports_competition", "question": "What are the types and countries of competitions?", "rationale": ["Identify the relevant table, which is 'competition'.", "Select the columns to display, 'Competition_type' and 'Country'."], "gold_sql": "SELECT Competition_type ,  Country FROM competition", "source_tables": ["competition"], "description": "The virtual table provides information about the types and countries of competitions from the 'competition' table. It includes the competition type and the country where each competition is held.", "virtual_table": "SELECT Competition_type ,  Country FROM competition"}
{"sample_id": "train.3356", "db_id": "sports_competition", "question": "What are the names and players of all the clubs?", "rationale": ["Identify the relevant tables, which are 'club' and 'player'.", "Select the columns to display, 'name' from the 'club' table and 'Player_ID' from the 'player' table.", "Join the two tables on the 'Club_ID' to associate players with their respective clubs."], "gold_sql": "SELECT T1.name ,  T2.Player_id FROM club AS T1 JOIN player AS T2 ON T1.Club_ID  =  T2.Club_ID", "source_tables": ["club", "player"], "description": "The virtual table provides the names of clubs along with the unique identifiers of players associated with each club. It combines data from the 'club' and 'player' tables based on the club's unique identifier, allowing users to see which players belong to which clubs.", "virtual_table": "SELECT T1.name ,  T2.Player_id FROM club AS T1 JOIN player AS T2 ON T1.Club_ID  =  T2.Club_ID"}
{"sample_id": "train.594", "db_id": "store_1", "question": "What is the full name of the employee who has the most customers?", "rationale": ["Identify the relevant tables, which are 'employees' and 'customers'.", "Select the columns to display, 'first_name' and 'last_name' from the 'employees' table.", "Join the 'employees' table with the 'customers' table on the support representative's identifier.", "Group the results by employee ID to aggregate the customer counts.", "Order the results by the count of customers in descending order to find the employee with the most customers.", "Add a limit to specify how many top employees to return using a placeholder for numeric values."], "gold_sql": "SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employees", "customers"], "description": "The virtual table provides the first and last names of employees from the 'employees' table who are support representatives for customers. It joins the 'employees' table with the 'customers' table based on the support representative's identifier, groups the results by employee ID, and orders them by the count of customers they support in descending order. The placeholder in the LIMIT clause indicates the number of top employees to retrieve based on the highest customer count.", "virtual_table": "SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.606", "db_id": "store_1", "question": "What are the first and last names of all the employees and how many people report to them?", "rationale": ["Identify the relevant table, which is 'employees'.", "Select the columns to display, 'first_name' and 'last_name' from the second instance of the 'employees' table (T2).", "Count the number of reports for each manager by counting the occurrences of 'reports_to' in the first instance of the 'employees' table (T1).", "Join the 'employees' table with itself to relate employees to their managers using the 'reports_to' field.", "Group the results by the manager's identifier to aggregate the count of reports.", "Order the results by the count of reports in descending order to show the most reported managers first.", "Add a limit to the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT T2.first_name , T2.last_name ,  count(T1.reports_to) FROM employees AS T1 JOIN employees AS T2 ON T1.reports_to = T2.id GROUP BY T1.reports_to ORDER BY count(T1.reports_to) DESC LIMIT 1;", "source_tables": ["employees"], "description": "The virtual table presents the first and last names of employees along with the count of how many employees report to each of them. It utilizes a self-join on the 'employees' table to correlate employees with their respective managers, grouping the results by the manager's identifier. The count of reports is aggregated and sorted in descending order, with a limit applied to the number of results returned.", "virtual_table": "SELECT T2.first_name , T2.last_name ,  count(T1.reports_to) FROM employees AS T1 JOIN employees AS T2 ON T1.reports_to = T2.id GROUP BY T1.reports_to ORDER BY count(T1.reports_to) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.593", "db_id": "store_1", "question": "Find the full name of employee who supported the most number of customers.", "rationale": ["Identify the relevant tables, which are 'employees' and 'customers'.", "Select the columns to display, 'first_name' and 'last_name' from the 'employees' table.", "Join the 'employees' table with the 'customers' table on the support representative's identifier.", "Group the results by employee ID to count the number of customers each employee supports.", "Order the results by the count of customers in descending order to find the employee who supports the most customers.", "Add a limit to specify how many top employees to return using a placeholder for numeric values."], "gold_sql": "SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employees", "customers"], "description": "The virtual table provides the first and last names of employees from the 'employees' table who are support representatives for customers. It joins the 'employees' table with the 'customers' table based on the support representative's identifier, groups the results by employee ID, and orders them by the count of customers they support in descending order. The placeholder in the LIMIT clause indicates the maximum number of employees to return.", "virtual_table": "SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.566", "db_id": "store_1", "question": "What are the states with the most invoices?", "rationale": ["Identify the relevant table, which is 'invoices'.", "Select the 'billing_state' column and count the number of invoices for each state.", "Add a condition to filter the results by 'billing_country' using a placeholder for string values.", "Group the results by 'billing_state' to aggregate the counts.", "Order the results by the count of invoices in descending order.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT 1;", "source_tables": ["invoices"], "description": "The virtual table summarizes the billing states from the 'invoices' table, counting the number of invoices issued in each state. The results are filtered by a specific country, and the states are ordered by the count of invoices in descending order, with a limit on the number of results returned.", "virtual_table": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.542", "db_id": "store_1", "question": "What are the names of the countries and average invoice size of the top countries by size?", "rationale": ["Identify the relevant table, which is 'invoices'.", "Select the 'billing_country' column and calculate the average of the 'total' column.", "Group the results by 'billing_country' to get the average invoice size for each country.", "Order the results by the average invoice size in descending order to find the top countries.", "Add a limit to restrict the number of countries returned, using a placeholder for numeric values."], "gold_sql": "SELECT billing_country ,  AVG(total) FROM invoices GROUP BY billing_country ORDER BY AVG(total) DESC LIMIT 10;", "source_tables": ["invoices"], "description": "The virtual table summarizes the billing countries and their corresponding average invoice sizes from the 'invoices' table. It groups the results by country and orders them in descending order based on the average invoice size, with a limit on the number of countries returned as specified by a placeholder.", "virtual_table": "SELECT billing_country ,  AVG(total) FROM invoices GROUP BY billing_country ORDER BY AVG(total) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.587", "db_id": "store_1", "question": "What is the title, phone and hire date of Nancy Edwards?", "rationale": ["Identify the relevant table, which is 'employees'.", "Select the columns to display: 'title', 'phone', and 'hire_date'.", "Add conditions to filter the 'first_name' and 'last_name' columns for the specified employee using placeholders for string values."], "gold_sql": "SELECT title ,  phone ,  hire_date FROM employees WHERE first_name = 'Nancy' AND last_name = 'Edwards';", "source_tables": ["employees"], "description": "The virtual table provides the title, phone number, and hire date of employees from the 'employees' table based on their first and last names. The placeholders in the WHERE clause represent the specific first and last names of the employee being queried.", "virtual_table": "SELECT title ,  phone ,  hire_date FROM employees WHERE first_name = [PLACEHOLDER-TYPE:STRING] AND last_name = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.640", "db_id": "store_1", "question": "What are the tracks that Dean Peeters bought?", "rationale": ["Identify the relevant tables: 'tracks', 'invoice_lines', 'invoices', and 'customers'.", "Select the column to display, which is the 'name' of the track from the 'tracks' table.", "Join the 'tracks' table with 'invoice_lines' on the track ID to link tracks to their respective invoices.", "Join the 'invoice_lines' table with 'invoices' on the invoice ID to connect invoices to customers.", "Join the 'invoices' table with 'customers' on the customer ID to filter by customer name.", "Add conditions to filter the results based on the specified customer's first and last name using placeholders."], "gold_sql": "SELECT T1.name FROM tracks AS T1 JOIN invoice_lines AS T2 ON T1.id = T2.track_id JOIN invoices AS T3 ON T3.id = T2.invoice_id JOIN customers AS T4 ON T4.id = T3.customer_id WHERE T4.first_name = 'Daan' AND T4.last_name = 'Peeters';", "source_tables": ["tracks", "invoice_lines", "customers", "invoices"], "description": "The virtual table describes the names of tracks from the 'tracks' table that were purchased by a specific customer. It joins the 'tracks' table with 'invoice_lines' to link tracks to invoices, then connects to the 'invoices' table to associate invoices with customers, and finally filters the results based on the customer's first and last name using placeholders.", "virtual_table": "SELECT T1.name FROM tracks AS T1 JOIN invoice_lines AS T2 ON T1.id = T2.track_id JOIN invoices AS T3 ON T3.id = T2.invoice_id JOIN customers AS T4 ON T4.id = T3.customer_id WHERE T4.first_name = [PLACEHOLDER-TYPE:STRING] AND T4.last_name = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.589", "db_id": "store_1", "question": "find the full name of employees who report to Nancy Edwards?", "rationale": ["Identify the relevant table, which is 'employees'.", "Join the 'employees' table with itself to relate employees to their managers.", "Select the columns to display, 'first_name' and 'last_name' of the employees reporting to the specified manager.", "Add conditions to filter the manager's name using placeholders for string values."], "gold_sql": "SELECT T2.first_name , T2.last_name FROM employees AS T1 JOIN employees AS T2 ON T1.id = T2.reports_to WHERE T1.first_name = 'Nancy' AND T1.last_name = 'Edwards';", "source_tables": ["employees"], "description": "The virtual table provides the first and last names of employees from the 'employees' table who report to a specific manager. The placeholders in the WHERE clause represent the first and last names of the manager.", "virtual_table": "SELECT T2.first_name , T2.last_name FROM employees AS T1 JOIN employees AS T2 ON T1.id = T2.reports_to WHERE T1.first_name = [PLACEHOLDER-TYPE:STRING] AND T1.last_name = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.632", "db_id": "store_1", "question": "What are the names of all tracks that belong to the Rock genre and whose media type is MPEG?", "rationale": ["Identify the relevant tables: 'genres', 'tracks', and 'media_types'.", "Select the column to display, which is 'name' from the 'tracks' table.", "Join the 'genres' table to the 'tracks' table on the genre identifier to filter by genre.", "Join the 'media_types' table to the 'tracks' table on the media type identifier to filter by media type.", "Add conditions to filter the results based on the specified genre and media type using placeholders for string values."], "gold_sql": "SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = 'Rock' OR T3.name = 'MPEG audio file';", "source_tables": ["tracks", "genres", "media_types"], "description": "The virtual table provides the names of tracks from the 'tracks' table that are associated with a specific genre and media type. It joins the 'genres' table to filter tracks by genre and the 'media_types' table to filter by media type, using placeholders for the genre and media type names.", "virtual_table": "SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = [PLACEHOLDER-TYPE:STRING] OR T3.name = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.608", "db_id": "store_1", "question": "How many orders does Luca Mancini have in his invoices?", "rationale": ["Identify the relevant tables, which are 'customers' and 'invoices'.", "Use a JOIN to connect the 'customers' table with the 'invoices' table based on the customer ID.", "Select the count of invoices to determine the number of orders.", "Add conditions to filter the customer based on their first and last names using placeholders."], "gold_sql": "SELECT count(*) FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id WHERE T1.first_name = 'Lucas' AND T1.last_name = 'Mancini';", "source_tables": ["customers", "invoices"], "description": "The virtual table counts the number of invoices associated with a specific customer from the 'customers' and 'invoices' tables. The placeholders in the WHERE clause represent the first and last names of the customer whose orders are being counted.", "virtual_table": "SELECT count(*) FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id WHERE T1.first_name = [PLACEHOLDER-TYPE:STRING] AND T1.last_name = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.553", "db_id": "store_1", "question": "List every album ordered by album title in ascending order.", "rationale": ["Identify the relevant table, which is 'albums'.", "Select the column to display, 'title'.", "Add an order clause to sort the results by the 'title' column in ascending order."], "gold_sql": "SELECT title FROM albums ORDER BY title;", "source_tables": ["albums"], "description": "The virtual table lists the titles of albums from the 'albums' table, ordered in ascending order by their title. This allows users to view all album titles in a sorted manner without specifying any particular album.", "virtual_table": "SELECT title FROM albums ORDER BY title;"}
{"sample_id": "train.625", "db_id": "store_1", "question": "List name of all tracks in Balls to the Wall.", "rationale": ["Identify the relevant tables, which are 'albums' and 'tracks'.", "Select the column to display, which is 'name' from the 'tracks' table.", "Join the 'albums' table with the 'tracks' table using the album identifier.", "Add a condition to filter the 'title' column of the 'albums' table for the specified album using a placeholder for string values."], "gold_sql": "SELECT T2.name FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T1.title = 'Balls to the Wall';", "source_tables": ["albums", "tracks"], "description": "The virtual table lists the names of tracks from the 'tracks' table that belong to a specific album titled 'Balls to the Wall'. The query joins the 'albums' and 'tracks' tables based on the album's identifier, and filters the results using a placeholder for the album title.", "virtual_table": "SELECT T2.name FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T1.title = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.580", "db_id": "store_1", "question": "How many customers are from California?", "rationale": ["Identify the relevant table, which is 'customers'.", "Use the count function to determine the total number of customers.", "Add a condition to filter the 'state' column for the specified state using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM customers WHERE state = 'CA';", "source_tables": ["customers"], "description": "The virtual table provides a count of customers from the 'customers' table who reside in a specific state. The placeholder in the WHERE clause represents the state name.", "virtual_table": "SELECT count(*) FROM customers WHERE state = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.623", "db_id": "store_1", "question": "What is title of album which track Balls to the Wall belongs to?", "rationale": ["Identify the relevant tables, which are 'albums' and 'tracks'.", "Select the column to display, which is 'title' from the 'albums' table.", "Join the 'albums' table with the 'tracks' table on the album identifier to associate tracks with their respective albums.", "Add a condition to filter the 'tracks' table for the specified track name using a placeholder for string values."], "gold_sql": "SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T2.name = 'Balls to the Wall';", "source_tables": ["albums", "tracks"], "description": "The virtual table provides the title of an album from the 'albums' table that contains a specific track from the 'tracks' table. The join condition links the album's identifier with the track's album identifier, while the placeholder in the WHERE clause represents the name of the track being queried.", "virtual_table": "SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T2.name = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.4939", "db_id": "store_product", "question": "What are the names of all products that are not the most frequently-used maximum page size?", "rationale": ["Identify the relevant table, which is 'product'.", "Select the column to display, 'product'.", "Add a condition to filter out products that match the most frequently used maximum page size using a subquery.", "The subquery groups the products by 'max_page_size', counts them, and orders them to find the most common size, with a placeholder for the limit."], "gold_sql": "SELECT product FROM product WHERE product != (SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["product"], "description": "The virtual table lists the names of products from the 'product' table that do not match the most frequently used maximum page size. The subquery identifies the maximum page size by counting occurrences and ordering them, with a placeholder representing the limit for the count of maximum page sizes.", "virtual_table": "SELECT product FROM product WHERE product != (SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.4943", "db_id": "store_product", "question": "What are the names of the districts that have both mall and village store style shops?", "rationale": ["Identify the relevant tables: 'store', 'store_district', and 'district'.", "Join the 'store' table with 'store_district' to link stores to their respective districts.", "Join the resulting table with the 'district' table to access district names.", "Filter the results based on the store type for both mall and village using placeholders for string values.", "Use INTERSECT to ensure that only districts with both types of stores are returned."], "gold_sql": "SELECT t3.District_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t1.Type  =  'City Mall' INTERSECT SELECT t3.District_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t1.Type  =  'Village Store'", "source_tables": ["store_district", "store", "district"], "description": "The virtual table provides the names of districts that contain both mall and village store types. It combines data from the 'store', 'store_district', and 'district' tables, filtering for the specified store types using placeholders for string values. The use of INTERSECT ensures that only districts with both store types are included in the results.", "virtual_table": "SELECT t3.District_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t1.Type  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT t3.District_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t1.Type  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4902", "db_id": "store_product", "question": "Find the list of page size which have more than 3 product listed", "rationale": ["Identify the relevant table, which is 'product'.", "Select the column to display, 'max_page_size'.", "Group the results by 'max_page_size' to aggregate the data.", "Add a condition to filter the results using the HAVING clause to include only those page sizes that have more than a specified count of products, using a placeholder for numeric values."], "gold_sql": "SELECT max_page_size FROM product GROUP BY max_page_size HAVING count(*)  >  3", "source_tables": ["product"], "description": "The virtual table provides a list of maximum page sizes from the 'product' table, grouped by each unique page size. It includes only those page sizes that have more than a specified number of products associated with them, as indicated by the placeholder in the HAVING clause.", "virtual_table": "SELECT max_page_size FROM product GROUP BY max_page_size HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4925", "db_id": "store_product", "question": "What is the city with the most number of flagship stores?", "rationale": ["Identify the relevant tables: 'store', 'store_district', and 'district'.", "Join the tables on their respective identifiers to link stores with their districts.", "Group the results by the 'headquartered_city' to aggregate the count of stores per city.", "Order the results by the count of stores in descending order to find the city with the most flagship stores.", "Use a placeholder in the LIMIT clause to specify how many results to return."], "gold_sql": "SELECT t3.headquartered_city FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id GROUP BY t3.headquartered_city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["store_district", "store", "district"], "description": "The virtual table provides a list of cities where flagship stores are headquartered, derived from the 'store', 'store_district', and 'district' tables. It groups the results by city and orders them by the count of flagship stores in descending order, allowing the user to identify the city with the highest number of such stores. The placeholder in the LIMIT clause indicates the maximum number of results to return.", "virtual_table": "SELECT t3.headquartered_city FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id GROUP BY t3.headquartered_city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4931", "db_id": "store_product", "question": "What are the products with the maximum page size A4 that also have a pages per minute color smaller than 5?", "rationale": ["Identify the relevant table, which is 'product'.", "Select the column to display, 'product'.", "Add conditions to filter the 'max_page_size' column for a specific value and the 'pages_per_minute_color' column for a numeric threshold using placeholders."], "gold_sql": "SELECT product FROM product WHERE max_page_size  =  'A4' AND pages_per_minute_color  <  5", "source_tables": ["product"], "description": "The virtual table lists the names of products from the 'product' table that meet specific criteria regarding their maximum page size and print speed. The placeholders in the WHERE clause represent the maximum page size and the threshold for pages per minute color output.", "virtual_table": "SELECT product FROM product WHERE max_page_size  =  [PLACEHOLDER-TYPE:STRING] AND pages_per_minute_color  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4933", "db_id": "store_product", "question": "What are the products with the maximum page size eqal to A4 or a pages per minute color less than 5?", "rationale": ["Identify the relevant table, which is 'product'.", "Select the column to display, 'product'.", "Add conditions to filter the 'max_page_size' for a specific size and 'pages_per_minute_color' for a specific numeric value using placeholders."], "gold_sql": "SELECT product FROM product WHERE max_page_size  =  'A4' OR pages_per_minute_color  <  5", "source_tables": ["product"], "description": "The virtual table lists products from the 'product' table that either have a maximum page size equal to a specified size or have a print speed in pages per minute for color output that is less than a specified number. The placeholders in the WHERE clause allow for dynamic input of the maximum page size and pages per minute color values.", "virtual_table": "SELECT product FROM product WHERE max_page_size  =  [PLACEHOLDER-TYPE:STRING] OR pages_per_minute_color  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4924", "db_id": "store_product", "question": "Find the city with the most number of stores.", "rationale": ["Identify the relevant tables: 'store', 'store_district', and 'district'.", "Join the 'store' table with 'store_district' to link stores to their respective districts.", "Join the resulting table with the 'district' table to access city information.", "Group the results by the 'headquartered_city' to count the number of stores in each city.", "Order the results by the count of stores in descending order to find the city with the most stores.", "Use a placeholder in the LIMIT clause to allow for dynamic specification of how many top cities to return."], "gold_sql": "SELECT t3.headquartered_city FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id GROUP BY t3.headquartered_city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["store_district", "store", "district"], "description": "The virtual table summarizes the cities where stores are located, specifically focusing on the city with the highest number of stores. It aggregates the data from the 'store', 'store_district', and 'district' tables, grouping by the city names and ordering them by the count of stores in descending order. The placeholder in the LIMIT clause allows for specifying the number of top cities to retrieve.", "virtual_table": "SELECT t3.headquartered_city FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id GROUP BY t3.headquartered_city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4934", "db_id": "store_product", "question": "Find all the product whose name contains the word \"Scanner\".", "rationale": ["Identify the relevant table, which is 'product'.", "Select the column to display, 'product'.", "Add a condition to filter the 'product' column for names that contain the specified keyword using a placeholder for string values."], "gold_sql": "SELECT product FROM product WHERE product LIKE '%Scanner%'", "source_tables": ["product"], "description": "The virtual table contains the names of products from the 'product' table that include a specific keyword in their name. The placeholder in the WHERE clause is used to represent the keyword for filtering the product names.", "virtual_table": "SELECT product FROM product WHERE product LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4928", "db_id": "store_product", "question": "What products are available at store named \"Miramichi\"?", "rationale": ["Identify the relevant tables: 'product', 'store_product', and 'store'.", "Select the column to display, which is 'product' from the 'product' table.", "Join the 'store_product' table to link products with stores using 'product_id'.", "Join the 'store' table to filter by the store's name using a placeholder for string values."], "gold_sql": "SELECT t1.product FROM product AS t1 JOIN store_product AS t2 ON t1.product_id  =  t2.product_id JOIN store AS t3 ON t2.store_id  =  t3.store_id WHERE t3.store_name  =  'Miramichi'", "source_tables": ["store", "store_product", "product"], "description": "The virtual table describes the products available in a specific store by joining the 'product', 'store_product', and 'store' tables. The placeholder in the WHERE clause represents the name of the store, allowing users to filter the results based on the store they are interested in.", "virtual_table": "SELECT t1.product FROM product AS t1 JOIN store_product AS t2 ON t1.product_id  =  t2.product_id JOIN store AS t3 ON t2.store_id  =  t3.store_id WHERE t3.store_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4917", "db_id": "store_product", "question": "What are the names of all the stores located in Khanewal District?", "rationale": ["Identify the relevant tables: 'store', 'store_district', and 'district'.", "Select the column to display, which is 'store_name' from the 'store' table.", "Join the 'store' table with the 'store_district' table on 'store_id' to link stores with their districts.", "Join the 'store_district' table with the 'district' table on 'district_id' to access district information.", "Add a condition to filter the 'district_name' column for the specified district using a placeholder for string values."], "gold_sql": "SELECT t1.store_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t3.district_name  =  'Khanewal District'", "source_tables": ["store_district", "store", "district"], "description": "The virtual table describes the names of stores from the 'store' table that are located in a specific district. It joins the 'store' table with the 'store_district' table to associate stores with their respective districts, and further joins with the 'district' table to filter by the district's name. The placeholder in the WHERE clause represents the name of the district being queried.", "virtual_table": "SELECT t1.store_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t3.district_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.81", "db_id": "student_assessment", "question": "How many registed students do each course have? List course name and the number of their registered students?", "rationale": ["Identify the relevant tables: 'Students', 'Student_Course_Registrations', and 'Courses'.", "Join the 'Students' table with 'Student_Course_Registrations' to associate students with their course registrations.", "Join the resulting table with the 'Courses' table to access course names.", "Group the results by course ID to count the number of registered students for each course, ensuring the course name is displayed alongside the count."], "gold_sql": "SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id", "source_tables": ["courses", "student_course_registrations", "students"], "description": "The virtual table summarizes the course names along with the count of registered students for each course. It combines data from the 'Students', 'Student_Course_Registrations', and 'Courses' tables, linking students to their respective course registrations and retrieving the course names. The count of students is aggregated for each course, providing a clear overview of student enrollment per course.", "virtual_table": "SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id"}
{"sample_id": "train.78", "db_id": "student_assessment", "question": "What are the details of the student who registered for the most number of courses?", "rationale": ["Identify the relevant tables, which are 'Students' and 'Student_Course_Registrations'.", "Select the 'student_details' column from the 'Students' table.", "Join the 'Students' table with the 'Student_Course_Registrations' table on the student ID.", "Group the results by student ID to count the number of course registrations for each student.", "Order the results in descending order based on the count of registrations to find the student with the most registrations.", "Limit the results using a placeholder for numeric values to specify how many top students to retrieve."], "gold_sql": "SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_course_registrations", "students"], "description": "The virtual table provides details of students from the 'Students' table who have registered for courses. It joins the 'Students' table with the 'Student_Course_Registrations' table to count the number of courses each student has registered for. The results are grouped by student ID and ordered in descending order based on the count of registrations, with a limit set by a placeholder for numeric values to specify how many top students to retrieve.", "virtual_table": "SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.59", "db_id": "student_assessment", "question": "What are the ids of the students who registered for some courses but had the least number of courses for all students?", "rationale": ["Identify the relevant table, which is 'Student_Course_Registrations'.", "Select the 'student_id' column to display the identifiers of students.", "Group the results by 'student_id' to aggregate course registrations for each student.", "Order the results by the count of courses registered to find those with the least registrations.", "Use a placeholder in the LIMIT clause to specify how many student IDs to return."], "gold_sql": "SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT 1", "source_tables": ["student_course_registrations"], "description": "The virtual table provides the identifiers of students from the 'Student_Course_Registrations' table who have registered for courses. It groups the results by student ID and orders them by the count of courses they have registered for, allowing for the identification of those with the least number of registrations. The placeholder in the LIMIT clause indicates the maximum number of student IDs to return.", "virtual_table": "SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.58", "db_id": "student_assessment", "question": "what is id of students who registered some courses but the least number of courses in these students?", "rationale": ["Identify the relevant table, which is 'Student_Course_Registrations'.", "Select the 'student_id' column to display the identifiers of students.", "Group the results by 'student_id' to aggregate course registrations for each student.", "Order the results by the count of courses registered to find those with the least registrations.", "Use a placeholder in the LIMIT clause to specify how many student IDs to return."], "gold_sql": "SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT 1", "source_tables": ["student_course_registrations"], "description": "The virtual table provides a list of student identifiers from the 'Student_Course_Registrations' table, grouped by each student. It orders the results based on the count of courses each student has registered for, allowing for the identification of students with the least number of course registrations. The placeholder in the LIMIT clause indicates the number of results to return, which can be adjusted as needed.", "virtual_table": "SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.56", "db_id": "student_assessment", "question": "which course has most number of registered students?", "rationale": ["Identify the relevant tables, which are 'Courses' and 'Student_Course_Registrations'.", "Select the 'course_name' from the 'Courses' table.", "Join the 'Courses' table with the 'Student_Course_Registrations' table on the course ID to link courses with their registrations.", "Group the results by course ID to count the number of registrations for each course.", "Order the results by the count of registrations in descending order to find the course with the most registrations.", "Add a limit to specify how many courses to return, using a placeholder for numeric values."], "gold_sql": "SELECT T1.course_name FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_Id GROUP BY T1.course_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["courses", "student_course_registrations"], "description": "The virtual table provides the names of courses from the 'Courses' table that have the highest number of registered students. It aggregates the data by counting the registrations for each course and orders the results in descending order, allowing the user to specify a limit on the number of courses returned.", "virtual_table": "SELECT T1.course_name FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_Id GROUP BY T1.course_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.104", "db_id": "student_assessment", "question": "What are all details of the students who registered but did not attend any course?", "rationale": ["Identify the relevant table, which is 'Student_Course_Registrations'.", "Select all columns to display the details of the students.", "Add a condition to filter out students whose IDs are present in the 'Student_Course_Attendance' table using a subquery with a NOT IN clause."], "gold_sql": "SELECT * FROM student_course_registrations WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)", "source_tables": ["student_course_attendance", "student_course_registrations"], "description": "The virtual table contains all details of students from the 'Student_Course_Registrations' table who have registered for courses but have not attended any of them. The query uses a subquery to filter out students based on their attendance records, ensuring that only those who have no corresponding entries in the 'Student_Course_Attendance' table are included.", "virtual_table": "SELECT * FROM student_course_registrations WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)"}
{"sample_id": "train.67", "db_id": "student_assessment", "question": "What is detail of the student who most recently registered course?", "rationale": ["Identify the relevant tables, which are 'Students' and 'Student_Course_Registrations'.", "Join the 'Student_Course_Registrations' table with the 'Students' table to access student details based on their registration.", "Order the results by the 'registration_date' in descending order to get the most recent registration at the top.", "Use a placeholder in the LIMIT clause to specify how many records to return."], "gold_sql": "SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT 1", "source_tables": ["student_course_registrations", "students"], "description": "The virtual table provides details of students from the 'Students' table who have registered for courses, specifically focusing on the most recent registration. The placeholder in the LIMIT clause indicates the number of records to return, allowing for flexibility in the query.", "virtual_table": "SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.65", "db_id": "student_assessment", "question": "What are the ids of all students who have attended at least one course?", "rationale": ["Identify the relevant table, which is 'Student_Course_Attendance'.", "Select the column to display, 'student_id'.", "The query aims to retrieve all student IDs that have at least one attendance record, implying that the selection is based on existing entries in the attendance table."], "gold_sql": "SELECT student_id FROM student_course_attendance", "source_tables": ["student_course_attendance"], "description": "The virtual table contains the identifiers of students from the 'Student_Course_Attendance' table who have participated in at least one course. This table focuses on the unique student IDs associated with course attendance records.", "virtual_table": "SELECT student_id FROM student_course_attendance"}
{"sample_id": "train.93", "db_id": "student_assessment", "question": "Find distinct cities of address of students?", "rationale": ["Identify the relevant tables: 'Addresses', 'People_Addresses', and 'Students'.", "Select the 'city' column from the 'Addresses' table and ensure distinct values are returned.", "Join the 'People_Addresses' table to link addresses to people, and then join the 'Students' table to filter for student-related addresses."], "gold_sql": "SELECT DISTINCT T1.city FROM addresses AS T1 JOIN people_addresses AS T2 ON T1.address_id = T2.address_id JOIN students AS T3 ON T2.person_id = T3.student_id", "source_tables": ["addresses", "people_addresses", "students"], "description": "The virtual table provides a list of distinct cities from the addresses associated with students. It combines data from the 'Addresses', 'People_Addresses', and 'Students' tables to ensure that only unique city entries are retrieved for students' addresses.", "virtual_table": "SELECT DISTINCT T1.city FROM addresses AS T1 JOIN people_addresses AS T2 ON T1.address_id = T2.address_id JOIN students AS T3 ON T2.person_id = T3.student_id"}
{"sample_id": "dev.542", "db_id": "student_transcripts_tracking", "question": "What is the first, middle, and last name, along with the id and number of enrollments, for the student who enrolled the most in any program?", "rationale": ["Identify the relevant tables, which are 'Students' and 'Student_Enrolment'.", "Select the columns to display: 'student_id', 'first_name', 'middle_name', 'last_name', and a count of enrollments.", "Join the 'Students' table with the 'Student_Enrolment' table on the student ID to link students with their enrollments.", "Group the results by student ID to aggregate the count of enrollments for each student.", "Order the results by the count of enrollments in descending order to find the student with the most enrollments.", "Limit the results to a specific number using a placeholder for numeric values."], "gold_sql": "SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "students"], "description": "The virtual table provides information about students, including their unique identifier, first name, middle name, and last name, along with a count of their enrollments in various degree programs. The query aggregates the enrollment data by student and orders the results to identify the student with the highest number of enrollments, using a placeholder to limit the results to a specific number.", "virtual_table": "SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.561", "db_id": "student_transcripts_tracking", "question": "Which address holds the most number of students currently? List the address id and all lines.", "rationale": ["Identify the relevant tables, which are 'Addresses' and 'Students'.", "Select the columns to display: 'address_id', 'line_1', and 'line_2' from the 'Addresses' table.", "Join the 'Addresses' table with the 'Students' table on the current address ID.", "Group the results by 'address_id' to aggregate student counts per address.", "Order the results in descending order based on the count of students to find the address with the most students.", "Use a placeholder in the LIMIT clause to specify the number of results to return."], "gold_sql": "SELECT T1.address_id ,  T1.line_1 ,  T1.line_2 FROM Addresses AS T1 JOIN Students AS T2 ON T1.address_id  =  T2.current_address_id GROUP BY T1.address_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "students"], "description": "The virtual table provides a summary of addresses from the 'Addresses' table that are currently associated with students. It includes the unique identifier for each address and the primary and secondary address lines. The results are grouped by address ID and ordered by the number of students linked to each address, allowing for the identification of the address with the highest student count. The placeholder in the LIMIT clause indicates the maximum number of results to return.", "virtual_table": "SELECT T1.address_id ,  T1.line_1 ,  T1.line_2 FROM Addresses AS T1 JOIN Students AS T2 ON T1.address_id  =  T2.current_address_id GROUP BY T1.address_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.541", "db_id": "student_transcripts_tracking", "question": "Which student has enrolled for the most times in any program? List the id, first name, middle name, last name, the number of enrollments and student id.", "rationale": ["Identify the relevant tables, which are 'Students' and 'Student_Enrolment'.", "Select the columns to display: student_id, first_name, middle_name, last_name, and the count of enrollments.", "Join the 'Students' table with the 'Student_Enrolment' table on the student_id to link students with their enrollments.", "Group the results by student_id to aggregate the enrollment counts for each student.", "Order the results by the count of enrollments in descending order to find the student with the most enrollments.", "Use a placeholder in the LIMIT clause to specify how many results to return."], "gold_sql": "SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "students"], "description": "The virtual table provides information about students, including their unique identifiers, first names, middle names, and last names, along with a count of their enrollments in degree programs. The query aggregates the enrollment data by student, allowing for the identification of the student with the highest number of enrollments. The placeholder in the LIMIT clause specifies the maximum number of results to return.", "virtual_table": "SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.550", "db_id": "student_transcripts_tracking", "question": "What are the last name of the students who live in North Carolina but have not registered in any degree programs?", "rationale": ["Identify the relevant tables, which are 'Students' and 'Addresses'.", "Select the 'last_name' column from the 'Students' table.", "Join the 'Students' table with the 'Addresses' table to filter based on the current address.", "Add a condition to filter the 'state_province_county' column for the specified state using a placeholder for string values.", "Use the EXCEPT clause to exclude students who have registered in any degree programs by checking against the 'Student_Enrolment' table."], "gold_sql": "SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  'NorthCarolina' EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id", "source_tables": ["addresses", "student_enrolment", "students"], "description": "The virtual table provides the last names of students from the 'Students' table who currently reside in a specific state, while excluding those who are enrolled in any degree programs. The placeholder in the WHERE clause represents the state name, and the EXCEPT clause ensures that only students without any enrolment records are included.", "virtual_table": "SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id"}
{"sample_id": "dev.534", "db_id": "student_transcripts_tracking", "question": "What are the first, middle, and last names, along with the ids, of all students who enrolled in 2 degree programs in one semester?", "rationale": ["Identify the relevant table, which is 'Students', to retrieve student names and IDs.", "Join the 'Student_Enrolment' table to link students with their enrolment records.", "Group the results by student ID to aggregate enrolment counts.", "Use the HAVING clause to filter for students enrolled in exactly two degree programs, represented by a placeholder for numeric values."], "gold_sql": "SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  2", "source_tables": ["student_enrolment", "students"], "description": "The virtual table provides the first, middle, and last names, along with the unique identifiers of students from the 'Students' table who are enrolled in exactly two degree programs during a single semester. The placeholder in the HAVING clause indicates the number of degree programs the students must be enrolled in.", "virtual_table": "SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.533", "db_id": "student_transcripts_tracking", "question": "Who are enrolled in 2 degree programs in one semester? List the first name, middle name and last name and the id.", "rationale": ["Identify the relevant table, which is 'Students', to retrieve student names and IDs.", "Join the 'Student_Enrolment' table to associate students with their enrolment records.", "Group the results by student ID to aggregate enrolment counts.", "Use a HAVING clause to filter students based on the specified number of degree programs they are enrolled in, using a placeholder for numeric values."], "gold_sql": "SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  2", "source_tables": ["student_enrolment", "students"], "description": "The virtual table provides the first name, middle name, last name, and unique identifier of students from the 'Students' table who are enrolled in a specific number of degree programs during a single semester. The placeholder in the HAVING clause indicates the required count of degree programs for filtering the results.", "virtual_table": "SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.572", "db_id": "student_transcripts_tracking", "question": "What is the maximum number of times that a course shows up in different transcripts and what is that course's enrollment id?", "rationale": ["Identify the relevant table, which is 'Transcript_Contents'.", "Count the occurrences of each 'student_course_id' to determine how many times each course shows up in transcripts.", "Group the results by 'student_course_id' to aggregate the counts for each course.", "Order the results by the count in descending order to prioritize the most frequently appearing courses.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT count(*) ,  student_course_id FROM Transcript_Contents GROUP BY student_course_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["transcript_contents"], "description": "The virtual table provides a count of how many times each course appears in different transcripts, along with the corresponding student course enrollment ID. The results are grouped by the student course ID and ordered by the count in descending order, allowing for the identification of the most frequently appearing course based on the specified limit.", "virtual_table": "SELECT count(*) ,  student_course_id FROM Transcript_Contents GROUP BY student_course_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.554", "db_id": "student_transcripts_tracking", "question": "What is the mobile phone number of the student named Timmothy Ward ?", "rationale": ["Identify the relevant table, which is 'Students'.", "Select the column to display, 'cell_mobile_number'.", "Add conditions to filter the 'first_name' and 'last_name' columns for the specified student using placeholders for string values."], "gold_sql": "select cell_mobile_number from students where first_name  =  'timmothy' and last_name  =  'ward'", "source_tables": ["students"], "description": "The virtual table provides the mobile phone number of students from the 'Students' table based on their first and last names. The placeholders in the WHERE clause represent the specific first and last names of the student being queried.", "virtual_table": "select cell_mobile_number from students where first_name  =  [PLACEHOLDER-TYPE:STRING] and last_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.584", "db_id": "student_transcripts_tracking", "question": "What are the first names of the students who live in Haiti permanently or have the cell phone number 09700166582 ?", "rationale": ["Identify the relevant tables, which are 'Students' and 'Addresses'.", "Select the column to display, which is 'first_name' from the 'Students' table.", "Join the 'Students' table with the 'Addresses' table on the permanent address identifier.", "Add conditions to filter the results based on the country of the address and the student's mobile phone number using placeholders for string values."], "gold_sql": "select t1.first_name from students as t1 join addresses as t2 on t1.permanent_address_id  =  t2.address_id where t2.country  =  'haiti' or t1.cell_mobile_number  =  '09700166582'", "source_tables": ["addresses", "students"], "description": "The virtual table provides the first names of students from the 'Students' table who either have a permanent address in a specific country or possess a specific mobile phone number. The placeholders in the WHERE clause allow for filtering based on the country and mobile number criteria.", "virtual_table": "select t1.first_name from students as t1 join addresses as t2 on t1.permanent_address_id  =  t2.address_id where t2.country  =  [PLACEHOLDER-TYPE:STRING] or t1.cell_mobile_number  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.583", "db_id": "student_transcripts_tracking", "question": "Find the first name of the students who permanently live in the country Haiti or have the cell phone number 09700166582 .", "rationale": ["Identify the relevant tables, which are 'Students' and 'Addresses'.", "Select the column to display, 'first_name' from the 'Students' table.", "Join the 'Students' table with the 'Addresses' table on the permanent address identifier.", "Add conditions to filter the results based on the country of the address or the student's cell phone number using placeholders for string values."], "gold_sql": "select t1.first_name from students as t1 join addresses as t2 on t1.permanent_address_id  =  t2.address_id where t2.country  =  'haiti' or t1.cell_mobile_number  =  '09700166582'", "source_tables": ["addresses", "students"], "description": "The virtual table provides the first names of students from the 'Students' table who either have a permanent address in a specific country or possess a particular cell phone number. The placeholders in the WHERE clause allow for filtering based on the country and cell phone number criteria.", "virtual_table": "select t1.first_name from students as t1 join addresses as t2 on t1.permanent_address_id  =  t2.address_id where t2.country  =  [PLACEHOLDER-TYPE:STRING] or t1.cell_mobile_number  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.578", "db_id": "student_transcripts_tracking", "question": "What are the different addresses that have students living there?", "rationale": ["Identify the relevant table, which is 'Students'.", "Count the distinct values of 'current_address_id' to determine the number of unique addresses.", "The query focuses on the current addresses of students, ensuring that only those addresses are counted."], "gold_sql": "SELECT count(DISTINCT current_address_id) FROM Students", "source_tables": ["students"], "description": "The virtual table provides a count of distinct addresses associated with students currently residing at those addresses. The placeholder in the query represents the unique identifier for the current address of each student, allowing for the identification of different addresses where students live.", "virtual_table": "SELECT count(DISTINCT current_address_id) FROM Students"}
{"sample_id": "dev.579", "db_id": "student_transcripts_tracking", "question": "List all the student details in reversed lexicographical order.", "rationale": ["Identify the relevant table, which is 'Students'.", "Select the column 'other_student_details' to display additional information about the students.", "Add an ORDER BY clause to sort the results in descending order, which represents reversed lexicographical order."], "gold_sql": "SELECT other_student_details FROM Students ORDER BY other_student_details DESC", "source_tables": ["students"], "description": "The virtual table contains the details of students from the 'Students' table, specifically focusing on any additional information related to each student. The results are sorted in reversed lexicographical order based on the additional details provided.", "virtual_table": "SELECT other_student_details FROM Students ORDER BY other_student_details DESC"}
{"sample_id": "train.4328", "db_id": "tracking_grants_for_research", "question": "Find the organisation ids and details of the organisations which are involved in", "rationale": ["Identify the relevant tables, which are 'Grants' and 'Organisations'.", "Select the columns to display, 'organisation_id' and 'organisation_details' from the 'Organisations' table.", "Join the 'Grants' table with the 'Organisations' table on the 'organisation_id' to link grants to their respective organisations.", "Group the results by 'organisation_id' to aggregate the grant amounts for each organisation.", "Add a condition in the HAVING clause to filter organisations based on the total grant amount using a placeholder for numeric values."], "gold_sql": "SELECT T2.organisation_id ,  T2.organisation_details FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id GROUP BY T2.organisation_id HAVING sum(T1.grant_amount)  >  6000", "source_tables": ["grants", "organisations"], "description": "The virtual table provides the organisation IDs and details of organisations that are involved in grants, specifically those that have received a total grant amount exceeding a specified threshold. The query joins the 'Grants' and 'Organisations' tables based on the organisation ID, ensuring that only relevant organisations are included in the results. The placeholder in the HAVING clause allows for filtering based on the total grant amount received by each organisation.", "virtual_table": "SELECT T2.organisation_id ,  T2.organisation_details FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id GROUP BY T2.organisation_id HAVING sum(T1.grant_amount)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4323", "db_id": "tracking_grants_for_research", "question": "What are the details of the project that is producing both patents and papers as outcomes?", "rationale": ["Identify the relevant table, which is 'Projects'.", "Select the column to display, 'project_details'.", "Join the 'Projects' table with 'Project_Outcomes' to link projects with their outcomes.", "Use an INTERSECT to filter projects that produce both specified outcomes, ensuring both conditions are met.", "Placeholders are used in the WHERE clauses to represent the outcome codes for patents and papers."], "gold_sql": "SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  'Paper' INTERSECT SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  'Patent'", "source_tables": ["project_outcomes", "projects"], "description": "The virtual table provides details of projects from the 'Projects' table that are associated with specific outcomes, namely patents and papers. It utilizes an intersection of two queries to ensure that only projects producing both types of outcomes are included. The placeholders in the WHERE clauses represent the unique codes for the respective outcomes.", "virtual_table": "SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4327", "db_id": "tracking_grants_for_research", "question": "From what date and to what date do the staff work on a project that has the most staff and has staff in a leader role?", "rationale": ["Identify the relevant table, which is 'Project_Staff'.", "Select the columns to display, 'date_from' and 'date_to'.", "Use a subquery to find the project IDs with the most staff members by grouping and counting them, ordering by count in descending order, and limiting the results to a specified number.", "Add a condition to filter for staff members with a specific role code, ensuring that the role is a leadership position."], "gold_sql": "SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT 1 ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  'leader'", "source_tables": ["project_staff"], "description": "The virtual table provides the start and end dates of staff involvement in projects. It specifically focuses on projects that have the highest number of staff members, while also ensuring that at least one of those staff members holds a leadership role. The placeholders in the query allow for the specification of the number of top projects to consider and the role code for the leadership position.", "virtual_table": "SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4361", "db_id": "tracking_grants_for_research", "question": "What are the ids, types, and details of the organization with the most research staff?", "rationale": ["Identify the relevant tables, which are 'Organisations' and 'Research_Staff'.", "Select the columns to display: 'organisation_id', 'organisation_type', and 'organisation_details'.", "Join the 'Organisations' table with the 'Research_Staff' table on the organization ID to link research staff to their respective organizations.", "Group the results by 'organisation_id' to aggregate the count of research staff for each organization.", "Order the results by the count of research staff in descending order to find the organization with the most research staff.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "description": "The virtual table provides the identifiers, types, and details of organizations that employ research staff. It aggregates the data from the 'Organisations' table and joins it with the 'Research_Staff' table to count the number of research staff associated with each organization. The results are sorted in descending order based on the count of research staff, allowing the user to identify the organization with the highest number of research staff, limited by a specified number of results.", "virtual_table": "SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4360", "db_id": "tracking_grants_for_research", "question": "Which organisation hired the most number of research staff? List the organisation id, type and detail.", "rationale": ["Identify the relevant tables, which are 'Organisations' and 'Research_Staff'.", "Select the columns to display: 'organisation_id', 'organisation_type', and 'organisation_details'.", "Join the 'Organisations' table with the 'Research_Staff' table on the organisation ID to link the data.", "Group the results by 'organisation_id' to count the number of research staff per organisation.", "Order the results in descending order based on the count of research staff to identify the organisation with the most hires.", "Limit the results using a placeholder for numeric values to specify how many organisations to return."], "gold_sql": "SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "description": "The virtual table provides a list of organisations along with their unique identifiers, types, and details, specifically focusing on those that have employed research staff. The data is aggregated to show the organisations with the highest number of research staff, with a limit set by a placeholder for numeric values to specify how many organisations to return.", "virtual_table": "SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4338", "db_id": "tracking_grants_for_research", "question": "List the project details of the projects which did not hire any staff for a researcher role.", "rationale": ["Identify the relevant table, which is 'Projects'.", "Select the column to display, 'project_details'.", "Add a condition to filter projects that do not have any associated staff members for a specific role by using a subquery on the 'Project_Staff' table.", "Use a placeholder for the role code in the subquery to allow for dynamic input."], "gold_sql": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_Staff WHERE role_code  =  'researcher' )", "source_tables": ["project_staff", "projects"], "description": "The virtual table provides the project details of projects from the 'Projects' table that have not hired any staff members for a specific researcher role. The placeholder in the subquery represents the role code for the researcher role, allowing users to specify which role they are interested in filtering out.", "virtual_table": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING] )"}
{"sample_id": "train.4332", "db_id": "tracking_grants_for_research", "question": "Which organisation type hires most research staff?", "rationale": ["Identify the relevant tables, which are 'Organisations' and 'Research_Staff'.", "Join the two tables on the organisation ID to link research staff to their respective organisations.", "Group the results by organisation type to count the number of research staff for each type.", "Order the results in descending order based on the count of research staff to identify which organisation type hires the most.", "Use a placeholder in the LIMIT clause to allow the user to specify how many organisation types to return."], "gold_sql": "SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "description": "The virtual table provides a list of organisation types that employ research staff, sorted by the number of staff members associated with each type. The placeholder in the LIMIT clause allows for specifying the maximum number of organisation types to return.", "virtual_table": "SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4377", "db_id": "tracking_grants_for_research", "question": "How many project members were leaders or started working before '1989-04-24 23:51:54'?", "rationale": ["Identify the relevant table, which is 'Project_Staff'.", "Select the count of records to display the total number of project members.", "Add conditions to filter the records based on the 'role_code' for leadership and 'date_from' for the start date using placeholders for string values."], "gold_sql": "SELECT count(*) FROM Project_Staff WHERE role_code  =  'leader' OR date_from  <  '1989-04-24 23:51:54'", "source_tables": ["project_staff"], "description": "The virtual table counts the number of project staff members from the 'Project_Staff' table who either hold a specific leadership role or began their involvement in a project before a certain date. The placeholders in the WHERE clause represent the role code and the date for filtering the results.", "virtual_table": "SELECT count(*) FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING] OR date_from  <  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4392", "db_id": "tracking_grants_for_research", "question": "What are the staff roles of the staff who", "rationale": ["Identify the relevant table, which is 'Project_Staff'.", "Select the column to display, 'role_code'.", "Add conditions to filter the 'date_from' and 'date_to' columns for the specified date range using placeholders for string values."], "gold_sql": "SELECT role_code FROM Project_Staff WHERE date_from  >  '2003-04-19 15:06:20' AND date_to  <  '2016-03-15 00:33:18'", "source_tables": ["project_staff"], "description": "The virtual table provides a list of role codes for staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.", "virtual_table": "SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4372", "db_id": "tracking_grants_for_research", "question": "What are all the details of the organisations described as 'Sponsor'? Sort the result in an ascending order.", "rationale": ["Identify the relevant tables, which are 'Organisations' and 'Organisation_Types'.", "Select the column to display, 'organisation_details'.", "Join the two tables on the organisation type to filter the results based on the specified organisation type description using a placeholder for string values.", "Add an ORDER BY clause to sort the results in ascending order based on 'organisation_details'."], "gold_sql": "SELECT organisation_details FROM Organisations AS T1 JOIN organisation_Types AS T2 ON T1.organisation_type  =  T2.organisation_type WHERE T2.organisation_type_description  =  'Sponsor' ORDER BY organisation_details", "source_tables": ["organisation_types", "organisations"], "description": "The virtual table provides details of organisations from the 'Organisations' table that are classified under a specific type, which is indicated by a description in the 'Organisation_Types' table. The results are sorted in ascending order based on the organisation details, with a placeholder for the organisation type description used in the filtering condition.", "virtual_table": "SELECT organisation_details FROM Organisations AS T1 JOIN organisation_Types AS T2 ON T1.organisation_type  =  T2.organisation_type WHERE T2.organisation_type_description  =  [PLACEHOLDER-TYPE:STRING] ORDER BY organisation_details"}
{"sample_id": "train.4397", "db_id": "tracking_grants_for_research", "question": "What is the most common role for the staff?", "rationale": ["Identify the relevant table, which is 'Project_Staff'.", "Select the 'role_code' column to display the roles of staff members.", "Group the results by 'role_code' to aggregate the data based on roles.", "Order the results by the count of each role in descending order to find the most common role.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT role_code FROM Project_Staff GROUP BY role_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_staff"], "description": "The virtual table summarizes the role codes of staff members from the 'Project_Staff' table, grouped by their roles. It orders the results by the frequency of each role, allowing users to identify the most common role among the staff. The placeholder in the LIMIT clause indicates the number of top roles to return.", "virtual_table": "SELECT role_code FROM Project_Staff GROUP BY role_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4369", "db_id": "tracking_grants_for_research", "question": "For each grant id, how many documents does it have, and which one has the most?", "rationale": ["Identify the relevant table, which is 'Documents'.", "Select the 'grant_id' and count the number of documents for each grant using the COUNT function.", "Group the results by 'grant_id' to aggregate the document counts.", "Order the results in descending order based on the document count to find the grant with the most documents.", "Use a placeholder in the LIMIT clause to allow the user to specify how many top results they want."], "gold_sql": "SELECT grant_id ,  count(*) FROM Documents GROUP BY grant_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["documents"], "description": "The virtual table summarizes the number of documents associated with each grant ID from the 'Documents' table. It also identifies the grant ID that has the highest number of documents. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.", "virtual_table": "SELECT grant_id ,  count(*) FROM Documents GROUP BY grant_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4363", "db_id": "tracking_grants_for_research", "question": "For each staff id, what is the description of the role that is involved with the most number of projects?", "rationale": ["Identify the relevant tables: 'Staff_Roles' for role descriptions and 'Project_Staff' for staff identifiers.", "Join 'Staff_Roles' with 'Project_Staff' on the role code to associate staff with their roles.", "Group the results by staff ID to aggregate the data for each staff member.", "Count the number of projects associated with each staff member's role and order the results in descending order to find the most involved roles.", "Limit the results based on a placeholder for numeric values to control the output size."], "gold_sql": "SELECT T1.role_description ,  T2.staff_id FROM Staff_Roles AS T1 JOIN Project_Staff AS T2 ON T1.role_code  =  T2.role_code JOIN Project_outcomes AS T3 ON T2.project_id  =  T3.project_id GROUP BY T2.staff_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "project_staff", "staff_roles"], "description": "The virtual table provides the role descriptions of staff members along with their unique identifiers, specifically focusing on the roles that are associated with the highest number of projects. The results are grouped by staff ID and ordered by the count of projects in descending order, with a limit set by a placeholder for numeric values.", "virtual_table": "SELECT T1.role_description ,  T2.staff_id FROM Staff_Roles AS T1 JOIN Project_Staff AS T2 ON T1.role_code  =  T2.role_code JOIN Project_outcomes AS T3 ON T2.project_id  =  T3.project_id GROUP BY T2.staff_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4350", "db_id": "tracking_grants_for_research", "question": "How many staff does each project has? List the project id and the number in an ascending order.", "rationale": ["Identify the relevant tables, which are 'Project_Staff' and 'Projects'.", "Select the 'project_id' from 'Project_Staff' and count the number of staff members associated with each project.", "Join 'Project_Staff' with 'Projects' on the 'project_id' to ensure the correct association between staff and projects.", "Group the results by 'project_id' to aggregate the staff count for each project.", "Order the results by the count of staff in ascending order."], "gold_sql": "SELECT T1.project_id ,  count(*) FROM Project_Staff AS T1 JOIN Projects AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) ASC", "source_tables": ["project_staff", "projects"], "description": "The virtual table provides a count of staff members associated with each project from the 'Project_Staff' table. It includes the project ID and the total number of staff for each project, sorted in ascending order based on the staff count.", "virtual_table": "SELECT T1.project_id ,  count(*) FROM Project_Staff AS T1 JOIN Projects AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) ASC"}
{"sample_id": "train.4393", "db_id": "tracking_grants_for_research", "question": "What roles did staff members play between '2003-04-19 15:06:20' and '2016-03-15 00:33:18'?", "rationale": ["Identify the relevant table, which is 'Project_Staff'.", "Select the column to display, 'role_code'.", "Add conditions to filter the 'date_from' and 'date_to' columns for the specified date range using placeholders for string values."], "gold_sql": "SELECT role_code FROM Project_Staff WHERE date_from  >  '2003-04-19 15:06:20' AND date_to  <  '2016-03-15 00:33:18'", "source_tables": ["project_staff"], "description": "The virtual table describes the role codes of staff members from the 'Project_Staff' table who were involved in projects during a specified date range. The placeholders in the WHERE clause represent the start and end dates for filtering the records.", "virtual_table": "SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4396", "db_id": "tracking_grants_for_research", "question": "Which role is most common for the staff?", "rationale": ["Identify the relevant table, which is 'Project_Staff'.", "Select the 'role_code' column to display the roles of staff members.", "Group the results by 'role_code' to aggregate the counts of each role.", "Order the results by the count of each role in descending order to find the most common role.", "Use a placeholder in the LIMIT clause to specify how many top roles to return."], "gold_sql": "SELECT role_code FROM Project_Staff GROUP BY role_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_staff"], "description": "The virtual table summarizes the role codes of staff members from the 'Project_Staff' table, grouped by their role. It orders the results by the count of occurrences in descending order, allowing the user to identify the most common role among the staff. The placeholder in the LIMIT clause indicates the number of top roles to return.", "virtual_table": "SELECT role_code FROM Project_Staff GROUP BY role_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4385", "db_id": "tracking_grants_for_research", "question": "What are the details for the projects which were launched by the organization with the most projects?", "rationale": ["Identify the relevant table, which is 'Projects'.", "Select the column to display, 'project_details'.", "Use a subquery to find the 'organisation_id' of the organization with the most projects by grouping and counting the projects, ordering them in descending order, and limiting the results to one organization."], "gold_sql": "SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT 1 )", "source_tables": ["projects"], "description": "The virtual table provides details of projects from the 'Projects' table that were launched by the organization with the highest number of projects. The placeholder in the subquery limits the results to the top organization based on project count.", "virtual_table": "SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] )"}
{"sample_id": "train.4330", "db_id": "tracking_grants_for_research", "question": "What is the organisation type and id of the organisation which has the most number of research staff?", "rationale": ["Identify the relevant tables, which are 'Organisations' and 'Research_Staff'.", "Select the columns to display, 'organisation_type' and 'organisation_id'.", "Join the two tables on the organisation ID to link research staff to their respective organisations.", "Group the results by 'organisation_id' to count the number of research staff per organisation.", "Order the results by the count of research staff in descending order to find the organisation with the most staff.", "Add a limit to the results using a placeholder for numeric values."], "gold_sql": "SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "description": "The virtual table provides the organisation type and identifier for organisations that employ research staff. It aggregates the data from the 'Organisations' and 'Research_Staff' tables, grouping by organisation ID to count the number of research staff associated with each organisation. The results are ordered by the count in descending order, allowing the user to identify the organisation with the highest number of research staff, with a placeholder to limit the number of results returned.", "virtual_table": "SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4342", "db_id": "tracking_grants_for_research", "question": "When do all the researcher role staff start to work, and when do they stop working?", "rationale": ["Identify the relevant table, which is 'Project_Staff'.", "Select the columns to display, 'date_from' and 'date_to', which represent the start and end dates of employment.", "Add a condition to filter the 'role_code' column for the specified researcher role using a placeholder for string values."], "gold_sql": "SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  'researcher'", "source_tables": ["project_staff"], "description": "The virtual table provides the start and end dates of employment for staff members associated with projects, specifically filtering for those in a researcher role. The placeholder in the WHERE clause allows for the specification of the role code to identify the relevant staff members.", "virtual_table": "SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4337", "db_id": "tracking_grants_for_research", "question": "What is the response received date for the document described as Regular that was granted more than 100 dollars?", "rationale": ["Identify the relevant tables: 'Documents', 'Document_Types', and 'Grants'.", "Select the column 'response_received_date' from the 'Documents' table.", "Join 'Documents' with 'Document_Types' on 'document_type_code' to filter by document description.", "Join 'Documents' with 'Grants' on 'grant_id' to filter by grant amount.", "Add conditions in the WHERE clause to filter based on the specified document description and grant amount using placeholders."], "gold_sql": "SELECT T1.response_received_date FROM Documents AS T1 JOIN Document_Types AS T2 ON T1.document_type_code  =  T2.document_type_code JOIN Grants AS T3 ON T1.grant_id  =  T3.grant_id WHERE T2.document_description  =  'Regular' OR T3.grant_amount  >  100", "source_tables": ["grants", "document_types", "documents"], "description": "The virtual table provides the response received date for documents from the 'Documents' table that are associated with a specific document type and grants exceeding a certain amount. The placeholders in the WHERE clause allow for filtering based on the document description and the grant amount.", "virtual_table": "SELECT T1.response_received_date FROM Documents AS T1 JOIN Document_Types AS T2 ON T1.document_type_code  =  T2.document_type_code JOIN Grants AS T3 ON T1.grant_id  =  T3.grant_id WHERE T2.document_description  =  [PLACEHOLDER-TYPE:STRING] OR T3.grant_amount  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4349", "db_id": "tracking_grants_for_research", "question": "What are the details for the project whose research has been published?", "rationale": ["Identify the relevant tables: 'Projects', 'Project_Outcomes', and 'Research_Outcomes'.", "Select the column to display, which is 'project_details' from the 'Projects' table.", "Join 'Projects' with 'Project_Outcomes' on 'project_id' to connect projects with their outcomes.", "Join 'Project_Outcomes' with 'Research_Outcomes' on 'outcome_code' to filter based on research outcomes.", "Add a condition to filter the results based on the 'outcome_description' using a placeholder for string values."], "gold_sql": "SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id JOIN Research_outcomes AS T3 ON T2.outcome_code  =  T3.outcome_code WHERE T3.outcome_description LIKE '%Published%'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "description": "The virtual table provides details of projects from the 'Projects' table that have associated research outcomes published. It joins the 'Projects' table with the 'Project_Outcomes' table to link projects with their outcomes, and further joins with the 'Research_Outcomes' table to filter based on the description of the research outcome. The placeholder in the WHERE clause allows for specifying the desired outcome description.", "virtual_table": "SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id JOIN Research_outcomes AS T3 ON T2.outcome_code  =  T3.outcome_code WHERE T3.outcome_description LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4394", "db_id": "tracking_grants_for_research", "question": "What are the descriptions of all the project outcomes?", "rationale": ["Identify the relevant tables, which are 'Research_Outcomes' and 'Project_Outcomes'.", "Select the column to display, 'outcome_description' from 'Research_Outcomes'.", "Join the two tables on the 'outcome_code' to ensure that only matching outcomes are retrieved."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code", "source_tables": ["project_outcomes", "research_outcomes"], "description": "The virtual table provides the descriptions of project outcomes by joining the 'Research_Outcomes' and 'Project_Outcomes' tables. It retrieves the 'outcome_description' from 'Research_Outcomes' where the 'outcome_code' matches in both tables, allowing for a comprehensive view of the outcomes associated with various projects.", "virtual_table": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code"}
{"sample_id": "train.4324", "db_id": "tracking_grants_for_research", "question": "What is the total grant amount of the organisations described as research?", "rationale": ["Identify the relevant tables: 'Grants', 'Organisations', and 'Organisation_Types'.", "Select the sum of the 'grant_amount' from the 'Grants' table.", "Join the 'Grants' table with the 'Organisations' table using the organisation ID.", "Join the 'Organisations' table with the 'Organisation_Types' table to access the organisation type description.", "Add a condition to filter the organisation type description using a placeholder for string values."], "gold_sql": "SELECT sum(grant_amount) FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id JOIN organisation_Types AS T3 ON T2.organisation_type  =  T3.organisation_type WHERE T3.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations"], "description": "The virtual table summarizes the total grant amount from the 'Grants' table for organisations classified under a specific type, which is defined in the 'Organisation_Types' table. The query joins the 'Grants' and 'Organisations' tables based on the organisation ID, and further joins with the 'Organisation_Types' table to filter organisations by their type description. The placeholder in the WHERE clause represents the description of the organisation type being queried.", "virtual_table": "SELECT sum(grant_amount) FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id JOIN organisation_Types AS T3 ON T2.organisation_type  =  T3.organisation_type WHERE T3.organisation_type_description  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4364", "db_id": "tracking_grants_for_research", "question": "Which document type is described with the prefix 'Initial'?", "rationale": ["Identify the relevant table, which is 'Document_Types'.", "Select the column to display, 'document_type_code'.", "Add a condition to filter the 'document_description' column using a placeholder for string values that represent the prefix."], "gold_sql": "SELECT document_type_code FROM Document_Types WHERE document_description LIKE 'Initial%'", "source_tables": ["document_types"], "description": "The virtual table provides the unique code for document types from the 'Document_Types' table that match a specific description pattern. The placeholder in the WHERE clause allows for filtering based on a description that includes a specified prefix.", "virtual_table": "SELECT document_type_code FROM Document_Types WHERE document_description LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4353", "db_id": "tracking_grants_for_research", "question": "What is the complete description of the job of a researcher?", "rationale": ["Identify the relevant table, which is 'Staff_Roles'.", "Select the column to display, 'role_description'.", "Add a condition to filter the 'role_code' column for the specified role using a placeholder for string values."], "gold_sql": "SELECT role_description FROM Staff_Roles WHERE role_code  =  'researcher'", "source_tables": ["staff_roles"], "description": "The virtual table provides the descriptions of roles from the 'Staff_Roles' table based on a specific role code. The placeholder in the WHERE clause represents the unique code for the role of a researcher.", "virtual_table": "SELECT role_description FROM Staff_Roles WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4380", "db_id": "tracking_grants_for_research", "question": "What are the result description of the project whose detail is 'sint'?", "rationale": ["Identify the relevant tables: 'Research_Outcomes', 'Project_Outcomes', and 'Projects'.", "Select the column to display, which is 'outcome_description' from 'Research_Outcomes'.", "Join 'Research_Outcomes' with 'Project_Outcomes' on the outcome code to link outcomes to projects.", "Join 'Project_Outcomes' with 'Projects' on the project ID to filter by project details.", "Add a condition to filter the 'project_details' column for the specified project detail using a placeholder for string values."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code JOIN Projects AS T3 ON T2.project_id  =  T3.project_id WHERE T3.project_details  =  'sint'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "description": "The virtual table describes the outcome descriptions of projects from the 'Research_Outcomes' table that are linked to specific projects in the 'Projects' table. The placeholder in the WHERE clause represents the detailed description of the project being queried.", "virtual_table": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code JOIN Projects AS T3 ON T2.project_id  =  T3.project_id WHERE T3.project_details  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5867", "db_id": "tracking_share_transactions", "question": "Show the maximum and minimum share count of different transaction types.", "rationale": ["Identify the relevant table, which is 'Transactions'.", "Select the columns to display, including 'transaction_type_code', maximum share count, and minimum share count.", "Use the GROUP BY clause to aggregate the results based on 'transaction_type_code', allowing for the calculation of maximum and minimum share counts for each transaction type."], "gold_sql": "SELECT transaction_type_code ,  max(share_count) ,  min(share_count) FROM TRANSACTIONS GROUP BY transaction_type_code", "source_tables": ["transactions"], "description": "The virtual table summarizes the maximum and minimum share counts associated with various transaction types from the 'Transactions' table. The placeholder in the GROUP BY clause represents the unique transaction type codes, allowing for aggregation of share counts for each type.", "virtual_table": "SELECT transaction_type_code ,  max(share_count) ,  min(share_count) FROM TRANSACTIONS GROUP BY transaction_type_code"}
{"sample_id": "train.5883", "db_id": "tracking_share_transactions", "question": "What are the details of all sales and purchases?", "rationale": ["Identify the relevant tables, which are 'Sales' and 'Purchases'.", "Select the column 'sales_details' from the 'Sales' table and 'purchase_details' from the 'Purchases' table.", "Use the UNION operator to combine the results from both tables into a single virtual table."], "gold_sql": "SELECT sales_details FROM sales UNION SELECT purchase_details FROM purchases", "source_tables": ["sales", "purchases"], "description": "The virtual table combines details of sales transactions from the 'Sales' table and purchase transactions from the 'Purchases' table. It provides a unified view of the sales and purchase details, allowing for easy comparison and analysis of both types of transactions.", "virtual_table": "SELECT sales_details FROM sales UNION SELECT purchase_details FROM purchases"}
{"sample_id": "train.5865", "db_id": "tracking_share_transactions", "question": "What are the lot details of lots associated with transactions whose share count is bigger than 100 and whose type code is \"PUR\"?", "rationale": ["Identify the relevant tables: 'Lots', 'Transactions_Lots', and 'Transactions'.", "Select the column to display, which is 'lot_details' from the 'Lots' table.", "Join the 'Lots' table with 'Transactions_Lots' to link lots to transactions.", "Join the 'Transactions_Lots' table with 'Transactions' to access transaction details.", "Add conditions to filter transactions based on share count and transaction type code, using placeholders for the respective values."], "gold_sql": "SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON  T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  >  100 AND T3.transaction_type_code  =  'PUR'", "source_tables": ["lots", "transactions_lots", "transactions"], "description": "The virtual table provides the lot details from the 'Lots' table for lots that are linked to transactions meeting specific criteria. It filters transactions based on a minimum share count and a specific transaction type code, using placeholders for the numeric share count and the string transaction type code.", "virtual_table": "SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON  T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  >  [PLACEHOLDER-TYPE:NUMBER] AND T3.transaction_type_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5845", "db_id": "tracking_share_transactions", "question": "Show all investor details.", "rationale": ["Identify the relevant table, which is 'Investors'.", "Select the column to display, 'Investor_details'.", "No filtering conditions are needed since the request is to show all investor details."], "gold_sql": "SELECT Investor_details FROM INVESTORS", "source_tables": ["investors"], "description": "The virtual table contains detailed information about investors from the 'Investors' table. The query retrieves all entries in the 'Investor_details' column, providing a comprehensive view of each investor's information.", "virtual_table": "SELECT Investor_details FROM INVESTORS"}
{"sample_id": "train.5851", "db_id": "tracking_share_transactions", "question": "Show all dates of transactions whose type code is \"SALE\".", "rationale": ["Identify the relevant table, which is 'Transactions'.", "Select the column to display, 'date_of_transaction'.", "Add a condition to filter the 'transaction_type_code' column for the specified transaction type using a placeholder for string values."], "gold_sql": "SELECT date_of_transaction FROM TRANSACTIONS WHERE transaction_type_code  =  'SALE'", "source_tables": ["transactions"], "description": "The virtual table displays the dates of transactions from the 'Transactions' table that correspond to a specific type of transaction. The placeholder in the WHERE clause represents the transaction type code, allowing users to filter the results based on their input.", "virtual_table": "SELECT date_of_transaction FROM TRANSACTIONS WHERE transaction_type_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5494", "db_id": "voter_2", "question": "Find the distinct first names of all the students who have vice president votes and whose city code is not PIT.", "rationale": ["Identify the relevant tables, which are 'Student' and 'Voting_record'.", "Select the distinct 'Fname' column from the 'Student' table.", "Join the 'Student' table with the 'Voting_record' table on the condition that the 'StuID' matches the 'Vice_President_Vote'.", "Use the EXCEPT clause to exclude students whose 'city_code' matches the specified value, utilizing a placeholder for the city code."], "gold_sql": "SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_PRESIDENT_Vote EXCEPT SELECT DISTINCT Fname FROM STUDENT WHERE city_code  =  'PIT'", "source_tables": ["student", "voting_record"], "description": "The virtual table presents the distinct first names of students who have cast votes for the vice president, while excluding those who reside in a specific city. The query utilizes a join between the 'Student' and 'Voting_record' tables based on the student identifier, and it incorporates a condition to filter out students based on their city code using a placeholder for string values.", "virtual_table": "SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_PRESIDENT_Vote EXCEPT SELECT DISTINCT Fname FROM STUDENT WHERE city_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5497", "db_id": "voter_2", "question": "What are the distinct last names of the students who have president votes but do not have 2192 as the advisor?", "rationale": ["Identify the relevant tables, which are 'Student' and 'Voting_record'.", "Select the distinct last names from the 'Student' table.", "Join the 'Student' table with the 'Voting_record' table based on the student ID and the presidential vote.", "Use an EXCEPT clause to filter out students who have a specific advisor, using a placeholder for the advisor's name."], "gold_sql": "SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote EXCEPT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  '2192'", "source_tables": ["student", "voting_record"], "description": "The virtual table describes the distinct last names of students from the 'Student' table who have cast votes for the presidential candidate in the 'Voting_record' table, while excluding those students whose advisor is a specific individual. The placeholders in the query represent the advisor's name.", "virtual_table": "SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote EXCEPT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5510", "db_id": "voter_2", "question": "What is the most common major among female (sex is F) students?", "rationale": ["Identify the relevant table, which is 'Student'.", "Select the column to display, 'Major'.", "Add a condition to filter the 'Sex' column for female students using a placeholder for string values.", "Group the results by the 'Major' column to aggregate the data.", "Order the results by the count of each major in descending order to find the most common one.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT Major FROM STUDENT WHERE Sex  =  'F' GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "description": "The virtual table summarizes the majors of female students from the 'Student' table. It groups the results by major and orders them by their frequency in descending order, allowing for the identification of the most common major among this demographic. The placeholders in the WHERE clause and the LIMIT clause represent the gender and the number of results to return, respectively.", "virtual_table": "SELECT Major FROM STUDENT WHERE Sex  =  [PLACEHOLDER-TYPE:STRING] GROUP BY major ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5483", "db_id": "voter_2", "question": "What are the first and last names of all the female students who have president votes?", "rationale": ["Identify the relevant tables, which are 'Student' and 'Voting_record'.", "Select the columns to display, 'Fname' and 'LName' from the 'Student' table.", "Join the 'Student' table with the 'Voting_record' table on the 'StuID' to link students with their voting records.", "Add a condition to filter the 'Sex' column for female students using a placeholder for string values.", "Ensure that the voting record includes a vote for the president by checking the 'President_Vote' column."], "gold_sql": "SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.President_VOTE WHERE T1.sex  =  'F'", "source_tables": ["student", "voting_record"], "description": "The virtual table describes the first and last names of female students from the 'Student' table who have cast votes for the presidential candidate. The placeholder in the WHERE clause represents the gender of the students.", "virtual_table": "SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.President_VOTE WHERE T1.sex  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5485", "db_id": "voter_2", "question": "What are the first names and last names of the students who are 18 years old and have vice president votes.", "rationale": ["Identify the relevant tables, which are 'Student' and 'Voting_record'.", "Select the columns to display, 'Fname' and 'LName' from the 'Student' table.", "Join the 'Student' table with the 'Voting_record' table on the condition that the student's ID matches the vice president vote.", "Add a condition to filter the 'Age' column for students who are 18 years old using a placeholder for numeric values."], "gold_sql": "SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_President_VOTE WHERE T1.age  =  18", "source_tables": ["student", "voting_record"], "description": "The virtual table describes the distinct first and last names of students from the 'Student' table who are 18 years old and have cast votes for the vice president. The placeholder in the WHERE clause represents the age of the students.", "virtual_table": "SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_President_VOTE WHERE T1.age  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5511", "db_id": "voter_2", "question": "Find the major that is studied by the most female students.", "rationale": ["Identify the relevant table, which is 'Student'.", "Select the column to display, 'Major'.", "Add a condition to filter the 'Sex' column for female students using a placeholder for string values.", "Group the results by 'Major' to aggregate the counts of female students in each major.", "Order the results by the count of students in descending order to find the most popular major.", "Limit the results to return only the top entry using a placeholder for numeric values."], "gold_sql": "SELECT Major FROM STUDENT WHERE Sex  =  'F' GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "description": "The virtual table summarizes the majors studied by students from the 'Student' table, specifically filtering for female students. It groups the results by major and orders them by the count of female students in descending order, allowing for the identification of the major with the highest enrollment of female students. The placeholders represent the gender and the limit for the number of results returned.", "virtual_table": "SELECT Major FROM STUDENT WHERE Sex  =  [PLACEHOLDER-TYPE:STRING] GROUP BY major ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5508", "db_id": "voter_2", "question": "Which major has the most students?", "rationale": ["Identify the relevant table, which is 'Student'.", "Select the 'Major' column to group by.", "Use the COUNT function to count the number of students in each major.", "Order the results in descending order based on the count of students.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT Major FROM STUDENT GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "description": "The virtual table summarizes the majors of students from the 'Student' table, grouping them to count the number of students in each major. The result is ordered in descending order based on the count, allowing the identification of the major with the highest number of students. The placeholder in the LIMIT clause indicates the maximum number of results to return.", "virtual_table": "SELECT Major FROM STUDENT GROUP BY major ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5467", "db_id": "voter_2", "question": "Show all the distinct president votes made on 08/30/2015.", "rationale": ["Identify the relevant table, which is 'Voting_record'.", "Select the column to display, 'President_Vote', ensuring that only distinct values are retrieved.", "Add a condition to filter the 'Registration_Date' column for the specified date using a placeholder for string values."], "gold_sql": "SELECT DISTINCT PRESIDENT_Vote FROM VOTING_RECORD WHERE Registration_Date  =  '08/30/2015'", "source_tables": ["voting_record"], "description": "The virtual table presents the distinct presidential votes recorded in the 'Voting_record' table for a specific registration date. The placeholder in the WHERE clause represents the date of registration for filtering the votes.", "virtual_table": "SELECT DISTINCT PRESIDENT_Vote FROM VOTING_RECORD WHERE Registration_Date  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5478", "db_id": "voter_2", "question": "Find the distinct Advisor of students who have treasurer votes in the spring election cycle.", "rationale": ["Identify the relevant tables, which are 'Student' and 'Voting_record'.", "Select the distinct column 'Advisor' from the 'Student' table.", "Join the 'Student' table with the 'Voting_record' table on the 'StuID' and 'Treasurer_Vote' columns to link students with their voting records.", "Add a condition to filter the 'Election_Cycle' column for the specified cycle using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.Advisor FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Treasurer_Vote WHERE T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "description": "The virtual table describes the distinct advisors of students from the 'Student' table who have cast votes for the treasurer in the 'Voting_record' table during a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.", "virtual_table": "SELECT DISTINCT T1.Advisor FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Treasurer_Vote WHERE T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5491", "db_id": "voter_2", "question": "What is the average age of students who have city code \"NYC\" and have secretary votes for the spring election cycle?", "rationale": ["Identify the relevant tables, which are 'Student' and 'Voting_record'.", "Select the column to calculate the average, which is 'Age' from the 'Student' table.", "Join the 'Student' table with the 'Voting_record' table on the 'StuID' to link students with their voting records.", "Add conditions to filter students based on the specified city code and the election cycle using placeholders for string values."], "gold_sql": "SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.city_code  =  'NYC' AND T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "description": "The virtual table calculates the average age of students from the 'Student' table who reside in a specific city and have cast votes for the secretary position in a particular election cycle. The placeholders in the WHERE clause represent the city code and the election cycle identifier.", "virtual_table": "SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.city_code  =  [PLACEHOLDER-TYPE:STRING] AND T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5477", "db_id": "voter_2", "question": "What are the distinct ages of students who have secretary votes in the fall election cycle?", "rationale": ["Identify the relevant tables, which are 'Student' and 'Voting_record'.", "Select the 'Age' column from the 'Student' table and ensure distinct values are returned.", "Join the 'Student' table with the 'Voting_record' table on the 'StuID' to link students with their voting records.", "Add a condition to filter the results based on the 'Election_Cycle' column using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.Age FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Secretary_Vote WHERE T2.Election_Cycle  =  'Fall'", "source_tables": ["student", "voting_record"], "description": "The virtual table presents the distinct ages of students from the 'Student' table who have cast votes for the secretary position in the 'Voting_record' table during a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.", "virtual_table": "SELECT DISTINCT T1.Age FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Secretary_Vote WHERE T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5465", "db_id": "voter_2", "question": "Return all the distinct secretary votes made in the fall election cycle.", "rationale": ["Identify the relevant table, which is 'Voting_record'.", "Select the column to display, 'Secretary_Vote', ensuring that only distinct values are returned.", "Add a condition to filter the 'Election_Cycle' column for the specified election cycle using a placeholder for string values."], "gold_sql": "SELECT DISTINCT Secretary_Vote FROM VOTING_RECORD WHERE ELECTION_CYCLE  =  'Fall'", "source_tables": ["voting_record"], "description": "The virtual table contains distinct votes cast for the secretary position from the voting records associated with students. The placeholder in the WHERE clause represents the specific election cycle during which these votes were recorded.", "virtual_table": "SELECT DISTINCT Secretary_Vote FROM VOTING_RECORD WHERE ELECTION_CYCLE  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5479", "db_id": "voter_2", "question": "Who served as an advisor for students who have treasurer votes in the spring election cycle?", "rationale": ["Identify the relevant tables, which are 'Student' and 'Voting_record'.", "Select the 'Advisor' column from the 'Student' table, ensuring distinct values are returned.", "Join the 'Student' table with the 'Voting_record' table on the 'StuID' to link students with their voting records.", "Add a condition to filter the results based on the 'Election_Cycle' using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.Advisor FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Treasurer_Vote WHERE T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "description": "The virtual table provides a list of unique advisors for students who participated in the treasurer voting during a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.", "virtual_table": "SELECT DISTINCT T1.Advisor FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Treasurer_Vote WHERE T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5487", "db_id": "voter_2", "question": "Count the number of male students who had class senator votes in the fall election cycle.", "rationale": ["Identify the relevant tables, which are 'Student' and 'Voting_record'.", "Join the 'Student' table with the 'Voting_record' table on the 'StuID' and 'Class_Senator_Vote' columns to link students with their voting records.", "Count the total number of records that meet the criteria of being male and having participated in the specified election cycle, using placeholders for the gender and election cycle."], "gold_sql": "SELECT count(*) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  Class_Senator_Vote WHERE T1.Sex  =  'M' AND T2.Election_Cycle  =  'Fall'", "source_tables": ["student", "voting_record"], "description": "The virtual table counts the number of male students from the 'Student' table who participated in the voting for class senator during a specific election cycle. The placeholders in the WHERE clause represent the gender of the students and the election cycle identifier.", "virtual_table": "SELECT count(*) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  Class_Senator_Vote WHERE T1.Sex  =  [PLACEHOLDER-TYPE:STRING] AND T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5475", "db_id": "voter_2", "question": "What are the distinct first names of the students who have class president votes?", "rationale": ["Identify the relevant tables, which are 'Student' and 'Voting_record'.", "Select the distinct 'Fname' column from the 'Student' table.", "Join the 'Student' table with the 'Voting_record' table using the 'StuID' to filter for students who have class president votes."], "gold_sql": "SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.CLASS_Senator_VOTE", "source_tables": ["student", "voting_record"], "description": "The virtual table presents the distinct first names of students from the 'Student' table who have participated in voting for class president. The join condition links the 'Student' table with the 'Voting_record' table based on the unique student identifier, ensuring that only those students who have cast a vote for class president are included in the results.", "virtual_table": "SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.CLASS_Senator_VOTE"}
{"sample_id": "train.5457", "db_id": "voter_2", "question": "List the major of each male student.", "rationale": ["Identify the relevant table, which is 'Student'.", "Select the column to display, 'Major'.", "Add a condition to filter the 'Sex' column for male students using a placeholder for string values."], "gold_sql": "SELECT Major FROM STUDENT WHERE Sex  =  'M'", "source_tables": ["student"], "description": "The virtual table provides a list of majors for male students from the 'Student' table. The placeholder in the WHERE clause is used to specify the gender of the students being queried.", "virtual_table": "SELECT Major FROM STUDENT WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6582", "db_id": "wine_1", "question": "What are the countries for appelations with at most 3 wines?", "rationale": ["Identify the relevant tables, which are 'appellations' and 'wine'.", "Select the 'County' column from the 'appellations' table.", "Join the 'appellations' table with the 'wine' table on the 'Appelation' column to correlate wines with their respective appellations.", "Group the results by the 'Appelation' to aggregate the wine counts for each appellation.", "Add a condition in the HAVING clause to filter for appellations that have a count of wines less than or equal to the specified placeholder."], "gold_sql": "SELECT T1.County FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation GROUP BY T2.Appelation HAVING count(*)  <=  3", "source_tables": ["wine", "appellations"], "description": "The virtual table provides a list of counties associated with appellations that have a limited number of wines, specifically those with three or fewer entries. The placeholder in the HAVING clause allows for the specification of the maximum number of wines per appellation.", "virtual_table": "SELECT T1.County FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation GROUP BY T2.Appelation HAVING count(*)  <=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6547", "db_id": "wine_1", "question": "Find the the grape whose white color grapes are used to produce wines with scores higher than 90.", "rationale": ["Identify the relevant tables, which are 'grapes' and 'wine'.", "Select the distinct column 'Grape' from the 'grapes' table.", "Join the 'grapes' table with the 'wine' table on the 'Grape' column to correlate grape varieties with their respective wines.", "Add a condition to filter the 'Color' column for white grapes using a placeholder for string values.", "Add another condition to filter the 'Score' column for wines with scores higher than a specified number using a placeholder for numeric values."], "gold_sql": "SELECT DISTINCT T1.Grape FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'White' AND T2.score  >  90", "source_tables": ["wine", "grapes"], "description": "The virtual table describes the distinct grape varieties from the 'grapes' table that are white in color and are used to produce wines with a score greater than a specified threshold. The placeholders in the WHERE clause represent the color of the grapes and the minimum score for the wines.", "virtual_table": "SELECT DISTINCT T1.Grape FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING] AND T2.score  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6597", "db_id": "wine_1", "question": "Find the county where produces the most number of wines with score higher than 90.", "rationale": ["Identify the relevant tables, which are 'appellations' and 'wine'.", "Join the two tables on the appellation column to combine their data.", "Select the 'County' column from the 'appellations' table.", "Add a condition to filter the wines based on their score using a placeholder for numeric values.", "Group the results by county to count the number of wines per county.", "Order the results in descending order based on the count of wines and limit the output to a specified number using placeholders."], "gold_sql": "SELECT T1.County FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T2.Score  >  90 GROUP BY T1.County ORDER BY count(*) DESC LIMIT 1", "source_tables": ["wine", "appellations"], "description": "The virtual table provides information about the counties associated with appellations that produce wines scoring above a certain threshold. It aggregates the data to identify which county has the highest number of such wines, using placeholders to specify the score limit and the number of results to return.", "virtual_table": "SELECT T1.County FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T2.Score  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.County ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6588", "db_id": "wine_1", "question": "Which 3 wineries produce the most wines made from white grapes?", "rationale": ["Identify the relevant tables, which are 'grapes' and 'wine'.", "Join the two tables on the grape variety to connect the wine entries with their corresponding grape types.", "Filter the results to include only those wines made from grapes of a specific color, using a placeholder for string values.", "Group the results by winery to aggregate the count of wines produced by each winery.", "Order the results in descending order based on the count of wines to identify the top producers.", "Limit the output to a specified number of wineries using a placeholder for numeric values."], "gold_sql": "SELECT T2.Winery FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.GRAPE  =  T2.GRAPE WHERE T1.Color  =  'White' GROUP BY T2.Winery ORDER BY count(*) DESC LIMIT 3", "source_tables": ["wine", "grapes"], "description": "The virtual table provides a list of wineries that produce wines made from a specific color of grapes, in this case, white grapes. It joins the 'grapes' and 'wine' tables based on the grape variety, filters the results by the color of the grapes, groups the results by winery, and orders them by the count of wines produced, limiting the output to a specified number of wineries.", "virtual_table": "SELECT T2.Winery FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.GRAPE  =  T2.GRAPE WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T2.Winery ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6566", "db_id": "wine_1", "question": "Give the color of the grape whose wine products have the highest average price?", "rationale": ["Identify the relevant tables, which are 'grapes' and 'wine'.", "Select the 'Color' column from the 'grapes' table.", "Join the 'grapes' table with the 'wine' table on the grape variety.", "Group the results by grape variety to calculate the average price of wines for each grape.", "Order the results by the average price in descending order to find the highest priced wines.", "Add a limit placeholder to specify how many results to return."], "gold_sql": "SELECT T1.Color FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape GROUP BY T2.Grape ORDER BY AVG(Price) DESC LIMIT 1", "source_tables": ["wine", "grapes"], "description": "The virtual table describes the color of grape varieties from the 'grapes' table that are associated with wines from the 'wine' table. The results are grouped by grape variety, and the ordering is based on the average price of the wines, with a placeholder indicating the limit for the number of results returned.", "virtual_table": "SELECT T1.Color FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape GROUP BY T2.Grape ORDER BY AVG(Price) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6544", "db_id": "wine_1", "question": "Give the names and scores of wines made from white grapes.", "rationale": ["Identify the relevant tables, which are 'grapes' and 'wine'.", "Join the 'grapes' table with the 'wine' table on the 'Grape' column to associate each wine with its corresponding grape variety.", "Select the columns to display, which are 'Name' and 'Score' from the 'wine' table.", "Add a condition to filter the 'Color' column in the 'grapes' table for white grapes using a placeholder for string values."], "gold_sql": "SELECT T2.Name ,   T2.Score FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'White'", "source_tables": ["wine", "grapes"], "description": "The virtual table presents the names and scores of wines derived from specific grape varieties categorized as white grapes. The placeholder in the WHERE clause is used to filter the grape color, allowing users to specify the desired color of grapes.", "virtual_table": "SELECT T2.Name ,   T2.Score FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6543", "db_id": "wine_1", "question": "What are the names and scores of wines that are made of white color grapes?", "rationale": ["Identify the relevant tables, which are 'grapes' and 'wine'.", "Join the 'grapes' table with the 'wine' table on the 'Grape' column to link grape varieties with their corresponding wines.", "Select the columns to display, 'Name' and 'Score' from the 'wine' table.", "Add a condition to filter the 'Color' column in the 'grapes' table for the specified color using a placeholder for string values."], "gold_sql": "SELECT T2.Name ,   T2.Score FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'White'", "source_tables": ["wine", "grapes"], "description": "The virtual table describes the names and scores of wines from the 'wine' table that are produced using grape varieties from the 'grapes' table, specifically those that are classified as white grapes. The placeholder in the WHERE clause represents the color of the grapes.", "virtual_table": "SELECT T2.Name ,   T2.Score FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6533", "db_id": "wine_1", "question": "List the names of all distinct wines that are made of red color grape.", "rationale": ["Identify the relevant tables, which are 'grapes' and 'wine'.", "Select the distinct 'Name' column from the 'wine' table.", "Join the 'grapes' table with the 'wine' table on the 'Grape' column.", "Add a condition to filter the 'Color' column in the 'grapes' table for red grapes using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T2.Name FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'Red'", "source_tables": ["wine", "grapes"], "description": "The virtual table lists the distinct names of wines produced from grape varieties that are classified as red. The query joins the 'grapes' and 'wine' tables based on the grape variety, filtering the results to include only those grapes with a specified color, represented by a placeholder.", "virtual_table": "SELECT DISTINCT T2.Name FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6531", "db_id": "wine_1", "question": "List the names of all distinct wines that have scores higher than 90.", "rationale": ["Identify the relevant table, which is 'wine'.", "Select the column to display, 'Name'.", "Add a condition to filter the 'Score' column for values greater than a specified number using a placeholder for numeric values."], "gold_sql": "SELECT Name FROM WINE WHERE score  >  90", "source_tables": ["wine"], "description": "The virtual table lists the names of wines from the 'wine' table that have a score exceeding a specified threshold. The placeholder in the WHERE clause represents the minimum score required to filter the wines.", "virtual_table": "SELECT Name FROM WINE WHERE score  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6517", "db_id": "wine_1", "question": "What is the name of the highest rated wine?", "rationale": ["Identify the relevant table, which is 'wine'.", "Select the column to display, 'Name'.", "Order the results by the 'Score' column to find the highest rated wine.", "Use a placeholder in the LIMIT clause to specify how many top results to return."], "gold_sql": "SELECT Name FROM WINE ORDER BY Score LIMIT 1", "source_tables": ["wine"], "description": "The virtual table provides the names of wines from the 'wine' table, ordered by their rating scores. The placeholder in the LIMIT clause indicates the number of top-rated wines to retrieve.", "virtual_table": "SELECT Name FROM WINE ORDER BY Score LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6560", "db_id": "wine_1", "question": "What are the names of wines, sorted in alphabetical order?", "rationale": ["Identify the relevant table, which is 'wine'.", "Select the column to display, 'Name', ensuring that only distinct entries are shown.", "Add an ORDER BY clause to sort the results alphabetically by the 'Name' column."], "gold_sql": "SELECT DISTINCT Name FROM WINE ORDER BY Name", "source_tables": ["wine"], "description": "The virtual table lists the distinct names of wines from the 'wine' table, sorted in alphabetical order. This allows users to view all unique wine names without duplicates, organized for easy reference.", "virtual_table": "SELECT DISTINCT Name FROM WINE ORDER BY Name"}
{"sample_id": "train.6520", "db_id": "wine_1", "question": "What is the winery at which the wine with the highest score was made?", "rationale": ["Identify the relevant table, which is 'wine'.", "Select the column to display, 'Winery'.", "Order the results by the 'Score' column in descending order to find the highest score.", "Limit the results to one entry using a placeholder for numeric values."], "gold_sql": "SELECT Winery FROM WINE ORDER BY SCORE LIMIT 1", "source_tables": ["wine"], "description": "The virtual table provides information about the winery associated with the highest-rated wine from the 'wine' table. The query orders the wines by their score and limits the result to the top entry, represented by a placeholder for numeric values.", "virtual_table": "SELECT Winery FROM WINE ORDER BY SCORE LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.783", "db_id": "world_1", "question": "Return the codes of countries that do not speak English and do not have Republics for governments.", "rationale": ["Identify the relevant tables, which are 'country' and 'countrylanguage'.", "Select the 'Code' column from the 'country' table.", "Add a condition to filter out countries with a specific government form using a placeholder for string values.", "Use the EXCEPT clause to exclude countries that have English as a spoken language, represented by a placeholder for the language."], "gold_sql": "SELECT Code FROM country WHERE GovernmentForm != 'Republic' EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  'English'", "source_tables": ["country", "countrylanguage"], "description": "The virtual table provides a list of country codes from the 'country' table that do not have a government form classified as a Republic and are not associated with the English language in the 'countrylanguage' table. The placeholders in the query represent the specific government form and language to filter the results accordingly.", "virtual_table": "SELECT Code FROM country WHERE GovernmentForm != [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.777", "db_id": "world_1", "question": "What are the Asian countries which have a population larger than that of any country in Africa?", "rationale": ["Identify the relevant table, which is 'country'.", "Select the column to display, 'Name'.", "Add a condition to filter the 'Continent' column for the specified continent using a placeholder for string values.", "Include a subquery to find the minimum population of countries in another specified continent, ensuring the population condition is met."], "gold_sql": "SELECT Name FROM country WHERE Continent  =  'Asia'  AND population  >  (SELECT min(population) FROM country WHERE Continent  =  'Africa')", "source_tables": ["country"], "description": "The virtual table lists the names of countries from the 'country' table that are located in a specific continent and have a population greater than the minimum population of any country in another specified continent. The placeholders in the query represent the continent names for filtering the results accordingly.", "virtual_table": "SELECT Name FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING]  AND population  >  (SELECT min(population) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "dev.820", "db_id": "world_1", "question": "What are the codes of countries where Spanish is spoken by the largest percentage of people?", "rationale": ["Identify the relevant table, which is 'countrylanguage'.", "Select the column 'CountryCode' and the maximum value of 'Percentage' to find the highest percentage of speakers.", "Add a condition to filter the 'Language' column for the specified language using a placeholder for string values.", "Group the results by 'CountryCode' to ensure we get the maximum percentage for each country."], "gold_sql": "SELECT CountryCode ,  max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  'Spanish' GROUP BY CountryCode", "source_tables": ["countrylanguage"], "description": "The virtual table provides the country codes of countries where a specific language is spoken, specifically focusing on the maximum percentage of speakers for that language. The placeholder in the WHERE clause allows for the specification of the language in question, while the GROUP BY clause organizes the results by country code to identify the highest percentage of speakers.", "virtual_table": "SELECT CountryCode ,  max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING] GROUP BY CountryCode"}
{"sample_id": "dev.767", "db_id": "world_1", "question": "How many people live in countries that do not speak English?", "rationale": ["Identify the relevant table, which is 'country'.", "Select the column to display, which is the sum of the 'Population'.", "Add a condition to filter countries based on the absence of English as an official language using a subquery that joins 'country' and 'countrylanguage' tables.", "The placeholder in the subquery represents the language to be excluded."], "gold_sql": "SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English')", "source_tables": ["country", "countrylanguage"], "description": "The virtual table summarizes the total population of countries from the 'country' table that do not have English as an official language. It uses a subquery to filter out countries where English is spoken, represented by a placeholder for the language name.", "virtual_table": "SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "dev.796", "db_id": "world_1", "question": "Find the government form name and total population for each government form whose average life expectancy is longer than 72.", "rationale": ["Identify the relevant table, which is 'country'.", "Select the columns to display, which are the sum of the 'Population' and 'GovernmentForm'.", "Group the results by 'GovernmentForm' to aggregate the population for each type of government.", "Add a condition in the HAVING clause to filter the groups based on the average life expectancy using a placeholder for numeric values."], "gold_sql": "SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  72", "source_tables": ["country"], "description": "The virtual table summarizes the total population and the government form for each type of government in the 'country' table, specifically for those governments where the average life expectancy exceeds a certain threshold. The placeholder in the HAVING clause represents the minimum average life expectancy required for inclusion in the results.", "virtual_table": "SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.797", "db_id": "world_1", "question": "What are the different government forms and what is the total population of each for government forms that have an average life expectancy greater than 72?", "rationale": ["Identify the relevant table, which is 'country'.", "Select the column 'GovernmentForm' to group the results by different forms of government.", "Use the 'Population' column to calculate the total population for each government form.", "Add a condition to filter the results based on the average life expectancy using a placeholder for numeric values."], "gold_sql": "SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  72", "source_tables": ["country"], "description": "The virtual table summarizes the total population of countries grouped by their government forms, specifically for those government forms that have an average life expectancy exceeding a certain threshold. The placeholder in the HAVING clause represents the minimum average life expectancy required for inclusion in the results.", "virtual_table": "SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.799", "db_id": "world_1", "question": "What are the different continents and the total popuation and average life expectancy corresponding to each, for continents that have an average life expectancy less than 72?", "rationale": ["Identify the relevant table, which is 'country'.", "Select the columns to display: total population (using sum) and average life expectancy (using avg), along with the continent name.", "Group the results by continent to aggregate the population and life expectancy data.", "Add a condition to filter the results based on the average life expectancy being less than a specified numeric value using a placeholder."], "gold_sql": "SELECT sum(Population) ,  avg(LifeExpectancy) ,  Continent FROM country GROUP BY Continent HAVING avg(LifeExpectancy)  <  72", "source_tables": ["country"], "description": "The virtual table summarizes the total population and average life expectancy for each continent from the 'country' table. It groups the data by continent and filters the results to include only those continents where the average life expectancy is below a specified threshold, represented by a placeholder for numeric values.", "virtual_table": "SELECT sum(Population) ,  avg(LifeExpectancy) ,  Continent FROM country GROUP BY Continent HAVING avg(LifeExpectancy)  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.782", "db_id": "world_1", "question": "What are the codes of the countries that do not speak English and whose government forms are not Republic?", "rationale": ["Identify the relevant table, which is 'country'.", "Select the 'Code' column to display the country codes.", "Add a condition to filter the 'GovernmentForm' column for values that are not equal to the specified government form using a placeholder for string values.", "Use the EXCEPT clause to exclude country codes that are associated with the English language in the 'countrylanguage' table, using a placeholder for the language."], "gold_sql": "SELECT Code FROM country WHERE GovernmentForm != 'Republic' EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  'English'", "source_tables": ["country", "countrylanguage"], "description": "The virtual table provides a list of country codes from the 'country' table that do not have a government form classified as a Republic and are not associated with the English language in the 'countrylanguage' table. The placeholders in the query allow for the specification of the government form and language to filter the results accordingly.", "virtual_table": "SELECT Code FROM country WHERE GovernmentForm != [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.754", "db_id": "world_1", "question": "What are the countries where either English or Dutch is the official language ?", "rationale": ["Identify the relevant tables, which are 'country' and 'countrylanguage'.", "Select the column to display, which is 'name' from the 'country' table.", "Join the 'country' table with the 'countrylanguage' table on the country code.", "Add conditions to filter for the specified languages (English and Dutch) and check if they are official languages using placeholders for string values."], "gold_sql": "select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  'english' and isofficial  =  't' union select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  'dutch' and isofficial  =  't'", "source_tables": ["country", "countrylanguage"], "description": "The virtual table lists the names of countries from the 'country' table that have either English or Dutch as an official language. The query combines results from two separate conditions using a union, where each condition checks for a specific language and its official status using placeholders for the language names and their official status.", "virtual_table": "select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  [PLACEHOLDER-TYPE:STRING] and isofficial  =  [PLACEHOLDER-TYPE:STRING] union select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  [PLACEHOLDER-TYPE:STRING] and isofficial  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.758", "db_id": "world_1", "question": "Which languages are spoken by only one country in republic governments?", "rationale": ["Identify the relevant tables, which are 'country' and 'countrylanguage'.", "Join the 'country' table with the 'countrylanguage' table on the country code to associate languages with their respective countries.", "Filter the results to include only those countries with a republican form of government using a placeholder for string values.", "Group the results by language to count how many countries speak each language.", "Use a HAVING clause to filter the grouped results to include only those languages that are spoken by exactly one country, using a placeholder for numeric values."], "gold_sql": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.GovernmentForm  =  'Republic' GROUP BY T2.Language HAVING COUNT(*)  =  1", "source_tables": ["country", "countrylanguage"], "description": "The virtual table describes the languages spoken in countries that have a republican form of government, specifically focusing on those languages that are unique to only one country. The placeholders in the WHERE clause represent the type of government and the count of countries speaking each language.", "virtual_table": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.GovernmentForm  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T2.Language HAVING COUNT(*)  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.821", "db_id": "world_1", "question": "Return the codes of countries for which Spanish is the predominantly spoken language.", "rationale": ["Identify the relevant table, which is 'countrylanguage'.", "Select the column 'CountryCode' and the maximum 'Percentage' to find the predominant language spoken in each country.", "Add a condition to filter the 'Language' column for the specified language using a placeholder for string values.", "Group the results by 'CountryCode' to ensure each country is represented only once."], "gold_sql": "SELECT CountryCode ,  max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  'Spanish' GROUP BY CountryCode", "source_tables": ["countrylanguage"], "description": "The virtual table provides the country codes of countries where a specific language, in this case, Spanish, is predominantly spoken. It aggregates the data by country code and uses a placeholder to specify the language of interest, allowing users to filter for any language they choose.", "virtual_table": "SELECT CountryCode ,  max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING] GROUP BY CountryCode"}
{"sample_id": "dev.766", "db_id": "world_1", "question": "What is the total number of people living in the nations that do not use English?", "rationale": ["Identify the relevant table, which is 'country'.", "Select the 'Population' column to calculate the total number of people.", "Add a condition to exclude countries that use English by using a subquery that joins 'country' and 'countrylanguage' tables, filtering for the specified language using a placeholder for string values."], "gold_sql": "SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English')", "source_tables": ["country", "countrylanguage"], "description": "The virtual table summarizes the total population of countries that do not have English as an official language. It utilizes a subquery to filter out countries where English is spoken, ensuring that only the populations of non-English speaking nations are included in the sum.", "virtual_table": "SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "dev.723", "db_id": "world_1", "question": "How many people live in Asia, and what is the largest GNP among them?", "rationale": ["Identify the relevant table, which is 'country'.", "Select the columns to display, which are the sum of the 'Population' and the maximum 'GNP'.", "Add a condition to filter the 'Continent' column for the specified continent using a placeholder for string values."], "gold_sql": "SELECT sum(Population) ,  max(GNP) FROM country WHERE Continent  =  'Asia'", "source_tables": ["country"], "description": "The virtual table summarizes the total population and the maximum Gross National Product (GNP) of countries located in a specific continent. The placeholder in the WHERE clause represents the continent's name, allowing users to specify which continent they are interested in.", "virtual_table": "SELECT sum(Population) ,  max(GNP) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.778", "db_id": "world_1", "question": "What are the country codes for countries that do not speak English?", "rationale": ["Identify the relevant table, which is 'countrylanguage'.", "Select the column to display, 'CountryCode'.", "Use the EXCEPT clause to filter out country codes where the specified language is spoken, utilizing a placeholder for string values."], "gold_sql": "SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  'English'", "source_tables": ["countrylanguage"], "description": "The virtual table provides a list of country codes from the 'countrylanguage' table, excluding those countries where English is spoken. The placeholder in the query represents the language to be filtered out, allowing users to specify any language they wish to exclude from the results.", "virtual_table": "SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.742", "db_id": "world_1", "question": "Which continent has the most diverse languages?", "rationale": ["Identify the relevant tables, which are 'country' and 'countrylanguage'.", "Join the two tables on the country code to relate countries to their languages.", "Group the results by continent to count the number of languages for each continent.", "Order the results in descending order based on the count of languages to find the most diverse continent.", "Use a placeholder in the LIMIT clause to allow the user to specify how many top continents to return."], "gold_sql": "SELECT T1.Continent FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["country", "countrylanguage"], "description": "The virtual table summarizes the continents along with the count of diverse languages spoken in each continent. It joins the 'country' table with the 'countrylanguage' table to aggregate the number of languages per continent. The placeholder in the LIMIT clause allows for specifying the number of top continents to retrieve based on language diversity.", "virtual_table": "SELECT T1.Continent FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.735", "db_id": "world_1", "question": "How many different forms of governments are there in Africa?", "rationale": ["Identify the relevant table, which is 'country'.", "Select the distinct values of the 'GovernmentForm' column to count the different forms of government.", "Add a condition to filter the 'Continent' column for the specified continent using a placeholder for string values."], "gold_sql": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  'Africa'", "source_tables": ["country"], "description": "The virtual table provides a count of the distinct forms of government found in countries located in a specific continent. The placeholder in the WHERE clause represents the continent's name, allowing users to specify 'Africa' or any other continent as needed.", "virtual_table": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.734", "db_id": "world_1", "question": "How many type of governments are in Africa?", "rationale": ["Identify the relevant table, which is 'country'.", "Select the distinct values of the 'GovernmentForm' column to count the different types of governments.", "Add a condition to filter the 'Continent' column for the specified continent using a placeholder for string values."], "gold_sql": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  'Africa'", "source_tables": ["country"], "description": "The virtual table provides a count of distinct types of government forms present in countries located in a specific continent. The placeholder in the WHERE clause represents the continent's name, allowing users to specify which continent they are interested in.", "virtual_table": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.779", "db_id": "world_1", "question": "Return the country codes for countries that do not speak English.", "rationale": ["Identify the relevant table, which is 'countrylanguage'.", "Select the column to display, 'CountryCode'.", "Use the EXCEPT clause to filter out country codes where the specified language is spoken, using a placeholder for string values."], "gold_sql": "SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  'English'", "source_tables": ["countrylanguage"], "description": "The virtual table provides a list of country codes from the 'countrylanguage' table, excluding those countries where English is spoken. The placeholder in the query represents the language to be excluded, which in this case is English.", "virtual_table": "SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.730", "db_id": "world_1", "question": "What is the average GNP and total population in all nations whose government is US territory?", "rationale": ["Identify the relevant table, which is 'country'.", "Select the columns to display, which are the average GNP and the sum of the population.", "Add a condition to filter the 'GovernmentForm' column for the specified government type using a placeholder for string values."], "gold_sql": "SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  'US Territory'", "source_tables": ["country"], "description": "The virtual table provides the average Gross National Product (GNP) and the total population of countries from the 'country' table that have a specific type of government. The placeholder in the WHERE clause represents the government form being queried.", "virtual_table": "SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.789", "db_id": "world_1", "question": "Give the name, year of independence, and surface area of the country that has the lowest population.", "rationale": ["Identify the relevant table, which is 'country'.", "Select the columns to display: 'Name', 'SurfaceArea', and 'IndepYear'.", "Order the results by the 'Population' column to find the country with the lowest population.", "Use a placeholder in the LIMIT clause to restrict the output to only one country."], "gold_sql": "SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT 1", "source_tables": ["country"], "description": "The virtual table provides the name, year of independence, and surface area of countries from the 'country' table, ordered by their population. The placeholder in the LIMIT clause indicates that only the country with the lowest population will be selected.", "virtual_table": "SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.812", "db_id": "world_1", "question": "What are the cities whose population is between 160000 and 900000?", "rationale": ["Identify the relevant table, which is 'city'.", "Select the column to display, 'name'.", "Add a condition to filter the 'Population' column using the BETWEEN clause with placeholders for numeric values."], "gold_sql": "SELECT name FROM city WHERE Population BETWEEN 160000 AND 900000", "source_tables": ["city"], "description": "The virtual table lists the names of cities from the 'city' table that have a population within a specified range. The placeholders in the WHERE clause represent the lower and upper limits of the population range.", "virtual_table": "SELECT name FROM city WHERE Population BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.725", "db_id": "world_1", "question": "Give the average life expectancy for countries in Africa which are republics?", "rationale": ["Identify the relevant table, which is 'country'.", "Select the column to calculate the average, 'LifeExpectancy'.", "Add conditions to filter the 'Continent' and 'GovernmentForm' columns for the specified values using placeholders for string values."], "gold_sql": "SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  'Africa' AND GovernmentForm  =  'Republic'", "source_tables": ["country"], "description": "The virtual table provides the average life expectancy of countries from the 'country' table that are located in a specific continent and have a particular form of government. The placeholders in the WHERE clause represent the continent and the type of government.", "virtual_table": "SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING] AND GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.705", "db_id": "world_1", "question": "How many countries have governments that are republics?", "rationale": ["Identify the relevant table, which is 'country'.", "Select the count of records to display using count(*).", "Add a condition to filter the 'GovernmentForm' column for the specified type of government using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM country WHERE GovernmentForm  =  'Republic'", "source_tables": ["country"], "description": "The virtual table provides a count of countries from the 'country' table that have a specific type of government, specifically those classified as republics. The placeholder in the WHERE clause represents the type of government being queried.", "virtual_table": "SELECT count(*) FROM country WHERE GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.745", "db_id": "world_1", "question": "What is the number of nations that use English and Dutch?", "rationale": ["Identify the relevant tables, which are 'country' and 'countrylanguage'.", "Use a subquery to select the names of countries that speak English and another for those that speak Dutch.", "Utilize the INTERSECT operator to find countries that appear in both subqueries.", "Count the total number of unique countries that meet the criteria."], "gold_sql": "SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English' INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'Dutch')", "source_tables": ["country", "countrylanguage"], "description": "The virtual table provides a count of nations that have both English and Dutch as spoken languages. It combines data from the 'country' and 'countrylanguage' tables, filtering for countries where the specified languages are spoken. The placeholders represent the languages being queried.", "virtual_table": "SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "dev.486", "db_id": "wta_1", "question": "Find the number of left handed winners who participated in the WTA Championships.", "rationale": ["Identify the relevant table, which is 'matches'.", "Select the count of distinct 'winner_name' to get the number of unique left-handed winners.", "Add conditions to filter the 'tourney_name' for the specified tournament and 'winner_hand' for left-handed players using placeholders for string values."], "gold_sql": "SELECT count(DISTINCT winner_name) FROM matches WHERE tourney_name  =  'WTA Championships' AND winner_hand  =  'L'", "source_tables": ["matches"], "description": "The virtual table summarizes the count of distinct winners from the 'matches' table who are left-handed and participated in a specific tournament. The placeholders in the WHERE clause represent the tournament name and the winner's hand preference.", "virtual_table": "SELECT count(DISTINCT winner_name) FROM matches WHERE tourney_name  =  [PLACEHOLDER-TYPE:STRING] AND winner_hand  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.464", "db_id": "wta_1", "question": "What is the name of the winner who has won the most matches, and how many rank points does this player have?", "rationale": ["Identify the relevant table, which is 'matches'.", "Select the columns to display, 'winner_name' and 'winner_rank_points'.", "Group the results by 'winner_name' to count the number of matches won by each player.", "Order the results by the count of matches won in descending order to find the top winner.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT winner_name ,  winner_rank_points FROM matches GROUP BY winner_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["matches"], "description": "The virtual table provides the names of winners from the 'matches' table along with their corresponding ranking points. The results are grouped by the winner's name and ordered by the count of matches won in descending order, allowing for the identification of the player with the most victories. The placeholder in the LIMIT clause specifies the number of top winners to retrieve.", "virtual_table": "SELECT winner_name ,  winner_rank_points FROM matches GROUP BY winner_name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.476", "db_id": "wta_1", "question": "What is the code of the country with the most players?", "rationale": ["Identify the relevant table, which is 'players'.", "Select the 'country_code' column to display.", "Group the results by 'country_code' to aggregate the player counts.", "Order the results by the count of players in descending order to find the country with the most players.", "Use a placeholder in the LIMIT clause to specify how many top results to return."], "gold_sql": "SELECT country_code FROM players GROUP BY country_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["players"], "description": "The virtual table provides a list of country codes from the 'players' table, grouped by each unique country code. It orders the results by the count of players associated with each country in descending order, allowing the identification of the country with the most players. The placeholder in the LIMIT clause indicates the number of top results to return.", "virtual_table": "SELECT country_code FROM players GROUP BY country_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.471", "db_id": "wta_1", "question": "Find the total ranking points for each player and their first name.", "rationale": ["Identify the relevant tables, which are 'players' and 'rankings'.", "Select the columns to display, which are the sum of 'ranking_points' and 'first_name' from the 'players' table.", "Join the 'players' table with the 'rankings' table on the 'player_id' to associate players with their ranking points.", "Group the results by 'first_name' to aggregate the total ranking points for each player."], "gold_sql": "SELECT sum(ranking_points) ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.first_name", "source_tables": ["rankings", "players"], "description": "The virtual table summarizes the total ranking points for each player along with their first names. It combines data from the 'players' table, which contains player identifiers and names, with the 'rankings' table, which holds the ranking points associated with each player. The results are grouped by the player's first name to provide a total ranking points count for each individual.", "virtual_table": "SELECT sum(ranking_points) ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.first_name"}
{"sample_id": "dev.469", "db_id": "wta_1", "question": "Find the average ranking for each player and their first name.", "rationale": ["Identify the relevant tables, which are 'players' and 'rankings'.", "Select the average of the 'ranking' column and the 'first_name' column from the 'players' table.", "Join the two tables on the 'player_id' to associate players with their rankings.", "Group the results by 'first_name' to compute the average ranking for each player."], "gold_sql": "SELECT avg(ranking) ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.first_name", "source_tables": ["rankings", "players"], "description": "The virtual table provides the average ranking of players along with their first names. It combines data from the 'players' table and the 'rankings' table, linking them through the unique player identifier. The results are grouped by the players' first names to calculate the average ranking for each player.", "virtual_table": "SELECT avg(ranking) ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.first_name"}
{"sample_id": "dev.439", "db_id": "wta_1", "question": "Find the highest rank of losers in all matches.", "rationale": ["Identify the relevant table, which is 'matches'.", "Select the 'loser_rank' column to find the minimum value.", "Use the MIN function to aggregate the ranks and determine the highest rank of losers across all matches."], "gold_sql": "SELECT min(loser_rank) FROM matches", "source_tables": ["matches"], "description": "The virtual table provides the minimum rank of losing players from the 'matches' table, which reflects the highest rank among all losers in the matches. This is determined by aggregating the 'loser_rank' column to find the lowest value, indicating the best performance of the losing players.", "virtual_table": "SELECT min(loser_rank) FROM matches"}
