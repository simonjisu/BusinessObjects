{"sample_id": "train.56", "db_id": "student_assessment", "question": "which course has most number of registered students?", "rationale": ["Identify the tables involved: Courses, Students, and Student_Course_Registrations.", "Join the Courses table with the Student_Course_Registrations table on course_id to link courses with their registrations.", "Join the result with the Students table on student_id to ensure we are counting registered students.", "Group the results by course_id to count the number of students registered for each course.", "Order the results in descending order based on the count of registered students to find the course with the most registrations.", "Limit the result to 1 to get only the course with the highest number of registered students."], "gold_sql": "SELECT T1.course_name FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_Id GROUP BY T1.course_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["courses", "student_course_registrations"], "pred_sql": "SELECT c.course_name, COUNT(scr.student_id) AS number_of_students\nFROM Courses c\nJOIN Student_Course_Registrations scr ON c.course_id = scr.course_id\nJOIN Students s ON scr.student_id = s.student_id\nGROUP BY c.course_id\nORDER BY number_of_students DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve the course names. The result is grouped by course ID to count the number of students per course.\"\n}\n"}
{"sample_id": "train.64", "db_id": "student_assessment", "question": "List the id of students who attended some courses?", "rationale": ["We need to find the IDs of students who have attended courses.", "The relevant table for attendance is 'Student_Course_Attendance', which contains the 'student_id' of students who attended courses.", "To get a unique list of student IDs, we will use the DISTINCT keyword to avoid duplicates.", "The final SQL query will select the distinct 'student_id' from the 'Student_Course_Attendance' table."], "gold_sql": "SELECT student_id FROM student_course_attendance", "source_tables": ["student_course_attendance"], "pred_sql": "SELECT DISTINCT Student_Course_Attendance.student_id\nFROM Student_Course_Attendance;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve the course names. The result is grouped by course ID to count the number of students per course.\"\n}\n"}
{"sample_id": "train.65", "db_id": "student_assessment", "question": "What are the ids of all students who have attended at least one course?", "rationale": ["We need to find the IDs of students who have attended at least one course.", "To do this, we will query the 'Student_Course_Attendance' table, which records attendance of students for courses.", "We will select the 'student_id' from this table.", "Using DISTINCT ensures that we only get unique student IDs, avoiding duplicates if a student attended multiple courses."], "gold_sql": "SELECT student_id FROM student_course_attendance", "source_tables": ["student_course_attendance"], "pred_sql": "SELECT DISTINCT student_id FROM Student_Course_Attendance;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve the course names. The result is grouped by course ID to count the number of students per course.\"\n}\n"}
{"sample_id": "train.76", "db_id": "student_assessment", "question": "What is the id of the candidate who most recently accessed the course?", "rationale": ["Identify the relevant tables: Candidates, Student_Course_Attendance, and Student_Course_Registrations.", "Join the Candidates table with Student_Course_Attendance on candidate_id and student_id to find candidates who attended courses.", "Join the result with Student_Course_Registrations to ensure we are looking at the correct course registrations.", "Order the results by date_of_attendance in descending order to get the most recent attendance first.", "Limit the results to 1 to get only the most recent candidate who accessed a course."], "gold_sql": "SELECT candidate_id FROM candidate_assessments ORDER BY assessment_date DESC LIMIT 1", "source_tables": ["candidate_assessments"], "pred_sql": "SELECT DISTINCT c.candidate_id\nFROM Candidates c\nJOIN Student_Course_Attendance sca ON c.candidate_id = sca.student_id\nJOIN Student_Course_Registrations scr ON sca.student_id = scr.student_id AND sca.course_id = scr.course_id\nORDER BY sca.date_of_attendance DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.77", "db_id": "student_assessment", "question": "What is detail of the student who registered the most number of courses?", "rationale": ["Identify the relevant tables: Students and Student_Course_Registrations.", "Join the Students table with the Student_Course_Registrations table to link students to their course registrations.", "Group the results by student_id to count the number of courses each student has registered for.", "Order the results in descending order based on the count of registered courses to find the student with the most registrations.", "Limit the results to 1 to get only the student who registered for the most courses."], "gold_sql": "SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_course_registrations", "students"], "pred_sql": "SELECT s.student_id, s.student_details \nFROM Students s \nJOIN Student_Course_Registrations scr ON s.student_id = scr.student_id \nGROUP BY s.student_id \nORDER BY COUNT(scr.course_id) DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve the course names. The result is grouped by course ID to count the number of students per course.\"\n}\n"}
{"sample_id": "train.82", "db_id": "student_assessment", "question": "For each course id, how many students are registered and what are the course names?", "rationale": ["Identify the tables involved: Courses, Student_Course_Registrations.", "We need to count the number of students registered for each course, so we will join the Courses table with the Student_Course_Registrations table on course_id.", "Use COUNT() function to count the number of student registrations for each course.", "Select the course_id and course_name from the Courses table along with the count of students.", "Group the results by course_id to get the count of students for each course."], "gold_sql": "SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id", "source_tables": ["courses", "student_course_registrations", "students"], "pred_sql": "SELECT Courses.course_id, COUNT(Student_Course_Registrations.student_id) AS student_count, Courses.course_name \nFROM Courses \nLEFT JOIN Student_Course_Registrations ON Courses.course_id = Student_Course_Registrations.course_id \nGROUP BY Courses.course_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve the course names. The result is grouped by course ID to count the number of students per course.\"\n}\n"}
{"sample_id": "train.90", "db_id": "student_assessment", "question": "What are the ids of the students who registered for course 301 most recently?", "rationale": ["Identify the relevant table for course registrations, which is 'Student_Course_Registrations'.", "Filter the records to only include those where the 'course_id' is '301'.", "Order the results by 'registration_date' in descending order to get the most recent registration first.", "Limit the results to 1 to get only the most recent student registration for course 301."], "gold_sql": "SELECT student_id FROM student_course_attendance WHERE course_id = 301 ORDER BY date_of_attendance DESC LIMIT 1", "source_tables": ["student_course_attendance"], "pred_sql": "SELECT student_id FROM Student_Course_Registrations WHERE course_id = '301' ORDER BY registration_date DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve the course names. The result is grouped by course ID to count the number of students per course.\"\n}\n"}
{"sample_id": "train.93", "db_id": "student_assessment", "question": "Find distinct cities of address of students?", "rationale": ["We need to find distinct cities of addresses associated with students.", "To do this, we will need to join the Addresses table with the People_Addresses table to link addresses to people.", "Next, we will join the resulting table with the Students table to filter for only those people who are students.", "Finally, we will select the distinct cities from the Addresses table."], "gold_sql": "SELECT DISTINCT T1.city FROM addresses AS T1 JOIN people_addresses AS T2 ON T1.address_id = T2.address_id JOIN students AS T3 ON T2.person_id = T3.student_id", "source_tables": ["addresses", "people_addresses", "students"], "pred_sql": "SELECT DISTINCT a.city\nFROM Addresses a\nJOIN People_Addresses pa ON a.address_id = pa.address_id\nJOIN Students s ON pa.person_id = s.student_id;", "hint": "\n"}
{"sample_id": "train.104", "db_id": "student_assessment", "question": "What are all details of the students who registered but did not attend any course?", "rationale": ["We need to find students who registered for courses but did not attend any.", "To do this, we will use the Students table and join it with the Student_Course_Registrations table to get the registrations.", "Next, we will perform a LEFT JOIN with the Student_Course_Attendance table to check for attendance.", "We will filter the results to include only those students who have a registration (i.e., scr.student_id IS NOT NULL) and do not have any attendance records (i.e., sca.student_id IS NULL).", "Finally, we will select the relevant details from the Students table."], "gold_sql": "SELECT * FROM student_course_registrations WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)", "source_tables": ["student_course_attendance", "student_course_registrations"], "pred_sql": "SELECT s.student_id, s.student_details \nFROM Students s \nLEFT JOIN Student_Course_Registrations scr ON s.student_id = scr.student_id \nLEFT JOIN Student_Course_Attendance sca ON scr.student_id = sca.student_id AND scr.course_id = sca.course_id \nWHERE scr.student_id IS NOT NULL AND sca.student_id IS NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve the course names. The result is grouped by course ID to count the number of students per course.\"\n}\n"}
{"sample_id": "train.105", "db_id": "student_assessment", "question": "List the id of students who registered course statistics in the order of registration date.", "rationale": ["Identify the relevant tables: Students, Student_Course_Registrations, and Courses.", "Join the Students table with the Student_Course_Registrations table to link students to their course registrations.", "Join the result with the Courses table to filter for the course named 'Statistics'.", "Select the student_id from the resulting joined table.", "Order the results by the registration_date to get the students in the order they registered."], "gold_sql": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = 'statistics' ORDER BY T2.registration_date", "source_tables": ["courses", "student_course_registrations"], "pred_sql": "SELECT s.student_id \nFROM Students s \nJOIN Student_Course_Registrations scr ON s.student_id = scr.student_id \nJOIN Courses c ON scr.course_id = c.course_id \nWHERE c.course_name = 'Statistics' \nORDER BY scr.registration_date;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve the course names. The result is grouped by course ID to count the number of students per course.\"\n}\n"}
{"sample_id": "train.106", "db_id": "student_assessment", "question": "What are the ids of the students who registered course statistics by order of registration date?", "rationale": ["Identify the relevant tables: Students, Student_Course_Registrations, and Courses.", "Join the Students table with the Student_Course_Registrations table to link students to their course registrations.", "Join the result with the Courses table to filter for the course named 'Statistics'.", "Select the student_id from the resulting joined table.", "Order the results by the registration_date to get the ids in the order of registration."], "gold_sql": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = 'statistics' ORDER BY T2.registration_date", "source_tables": ["courses", "student_course_registrations"], "pred_sql": "SELECT s.student_id \nFROM Students s \nJOIN Student_Course_Registrations scr ON s.student_id = scr.student_id \nJOIN Courses c ON scr.course_id = c.course_id \nWHERE c.course_name = 'Statistics' \nORDER BY scr.registration_date;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve the course names. The result is grouped by course ID to count the number of students per course.\"\n}\n"}
{"sample_id": "train.123", "db_id": "bike_1", "question": "For each zip code, return the average mean temperature of August there.", "rationale": ["We need to calculate the average mean temperature for each zip code in August.", "To do this, we will select the 'zip_code' and the average of 'mean_temperature_f' from the 'weather' table.", "We will filter the records to include only those from August. In SQLite, we can extract the month from the 'date' using the strftime function, checking if it equals '08'.", "Finally, we will group the results by 'zip_code' to get the average temperature for each zip code."], "gold_sql": "SELECT zip_code  ,  avg(mean_temperature_f) FROM weather WHERE date LIKE '8/%' GROUP BY zip_code", "source_tables": ["weather"], "pred_sql": "SELECT zip_code, AVG(mean_temperature_f) AS average_mean_temperature\nFROM weather\nWHERE strftime('%m', date) = '08'\nGROUP BY zip_code;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the cloud cover data from the 'weather' table for a specific zip code. The results are grouped by cloud cover values and ordered by the frequency of each cloud cover value, allowing users to see the most common cloud cover conditions for the specified area, limited to a certain number of results.\",\n    \"1\": \"This virtual table identifies unique trip IDs from the 'trip' table for users whose starting zip code corresponds to weather reports with an average mean temperature above a specified threshold. The placeholder in the HAVING clause represents the temperature limit for filtering the results.\",\n    \"2\": \"This virtual table identifies unique trip IDs from the 'trip' table for users whose starting zip code corresponds to weather reports with an average mean temperature above a specified threshold. The placeholder in the HAVING clause represents the temperature limit for filtering the results.\"\n}\n"}
{"sample_id": "train.135", "db_id": "bike_1", "question": "Which bike traveled the most often in zip code 94002?", "rationale": ["Identify the relevant table for trips, which is the 'trip' table.", "Filter the trips based on the specified zip code (94002).", "Group the results by 'bike_id' to count how many times each bike was used.", "Order the results in descending order based on the count of trips to find the most frequently used bike.", "Limit the results to 1 to get the bike that traveled the most often."], "gold_sql": "SELECT bike_id FROM trip WHERE zip_code  =  94002 GROUP BY bike_id ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["trip"], "pred_sql": "SELECT bike_id, COUNT(*) as trip_count \nFROM trip \nWHERE zip_code = '94002' \nGROUP BY bike_id \nORDER BY trip_count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of bike stations located in a specific city, excluding those stations that have been used as end stations for trips more than a specified number of times. The placeholders in the WHERE clause represent the city name and the count of trips.\",\n    \"1\": \"This virtual table lists the names of bike stations that have an average number of bikes available greater than a specified number, excluding those located in a specific city. The query combines data from the 'station' and 'status' tables, grouping by station ID to calculate the average bikes available, and uses placeholders for the average bike count and city name.\",\n    \"2\": \"This virtual table provides a list of bike stations from which trips started, along with their unique identifiers. The results are filtered by a specific start date pattern, grouped by the station name, and ordered by the number of trips in descending order, limited to a specified number of results. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the date pattern and the number of results to return.\"\n}\n"}
{"sample_id": "train.136", "db_id": "bike_1", "question": "What is the id of the bike that traveled the most in 94002?", "rationale": ["Identify the relevant table for trips, which is the 'trip' table.", "Filter the trips based on the zip code '94002' to focus on the specific area.", "Group the results by 'bike_id' to aggregate the total duration of trips for each bike.", "Use the SUM function to calculate the total duration of trips for each bike.", "Order the results in descending order based on the total duration to find the bike that traveled the most.", "Limit the results to 1 to get only the bike with the maximum travel duration."], "gold_sql": "SELECT bike_id FROM trip WHERE zip_code  =  94002 GROUP BY bike_id ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["trip"], "pred_sql": "SELECT bike_id, SUM(duration) AS total_duration\nFROM trip\nWHERE zip_code = '94002'\nGROUP BY bike_id\nORDER BY total_duration DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of bike stations located in a specific city, excluding those stations that have been used as end stations for trips more than a specified number of times. The placeholders in the WHERE clause represent the city name and the count of trips.\",\n    \"1\": \"This virtual table lists the names of bike stations that have an average number of bikes available greater than a specified number, excluding those located in a specific city. The query combines data from the 'station' and 'status' tables, grouping by station ID to calculate the average bikes available, and uses placeholders for the average bike count and city name.\",\n    \"2\": \"This virtual table provides a list of bike stations from which trips started, along with their unique identifiers. The results are filtered by a specific start date pattern, grouped by the station name, and ordered by the number of trips in descending order, limited to a specified number of results. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the date pattern and the number of results to return.\"\n}\n"}
{"sample_id": "train.143", "db_id": "bike_1", "question": "What are the names and ids of stations that had more than 14 bikes available on average or were installed in December?", "rationale": ["Identify the relevant tables: 'station' for station details and 'status' for bike availability.", "Join the 'station' table with the 'status' table on the station ID to access bike availability data.", "Group the results by station ID to calculate the average number of bikes available for each station.", "Use the HAVING clause to filter for stations with an average of more than 14 bikes available or those installed in December (checking the month of the installation date).", "Select the station names and IDs as required in the output."], "gold_sql": "SELECT T1.name ,  T1.id FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(T2.bikes_available)  >  14 UNION SELECT name ,  id FROM station WHERE installation_date LIKE '12/%'", "source_tables": ["status", "station"], "pred_sql": "SELECT s.name, s.id \nFROM station s \nLEFT JOIN status st ON s.id = st.station_id \nGROUP BY s.id \nHAVING AVG(st.bikes_available) > 14 OR strftime('%m', s.installation_date) = '12';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of bike stations that have an average number of bikes available greater than a specified number, excluding those located in a specific city. The query combines data from the 'station' and 'status' tables, grouping by station ID to calculate the average bikes available, and uses placeholders for the average bike count and city name.\",\n    \"1\": \"This virtual table lists the names of bike stations located in a specific city, excluding those stations that have been used as end stations for trips more than a specified number of times. The placeholders in the WHERE clause represent the city name and the count of trips.\",\n    \"2\": \"This virtual table identifies the unique station IDs from the 'station' table located in a specific city. It intersects with the 'status' table to find stations that have an average number of available bikes greater than a specified threshold. The placeholders in the WHERE clause and HAVING clause represent the city name and the minimum average bikes available, respectively.\"\n}\n"}
{"sample_id": "train.144", "db_id": "bike_1", "question": "What are the names and ids of all stations that have more than 14 bikes available on average or had bikes installed in December?", "rationale": ["We need to select the names and ids of all stations that meet two conditions: having more than 14 bikes available on average or having bikes installed in December.", "To achieve this, we will join the 'station' table with the 'status' table on the station ID.", "We will group the results by station ID to calculate the average number of bikes available for each station.", "We will use the HAVING clause to filter the results based on the average number of bikes available, checking if it is greater than 14.", "Additionally, we will check if the installation date of the station falls in December using the strftime function to extract the month from the installation_date."], "gold_sql": "SELECT T1.name ,  T1.id FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(T2.bikes_available)  >  14 UNION SELECT name ,  id FROM station WHERE installation_date LIKE '12/%'", "source_tables": ["status", "station"], "pred_sql": "SELECT s.name, s.id \nFROM station s \nJOIN status st ON s.id = st.station_id \nGROUP BY s.id \nHAVING AVG(st.bikes_available) > 14 \n   OR strftime('%m', s.installation_date) = '12';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of bike stations that have an average number of bikes available greater than a specified number, excluding those located in a specific city. The query combines data from the 'station' and 'status' tables, grouping by station ID to calculate the average bikes available, and uses placeholders for the average bike count and city name.\",\n    \"1\": \"This virtual table lists the names of bike stations located in a specific city, excluding those stations that have been used as end stations for trips more than a specified number of times. The placeholders in the WHERE clause represent the city name and the count of trips.\",\n    \"2\": \"This virtual table identifies the unique station IDs from the 'station' table located in a specific city. It intersects with the 'status' table to find stations that have an average number of available bikes greater than a specified threshold. The placeholders in the WHERE clause and HAVING clause represent the city name and the minimum average bikes available, respectively.\"\n}\n"}
{"sample_id": "train.145", "db_id": "bike_1", "question": "What is the 3 most common cloud cover rates in the region of zip code 94107?", "rationale": ["Identify the relevant table: The 'weather' table contains the cloud cover data.", "Filter by zip code: We need to focus on the records where the zip code is 94107.", "Group by cloud cover: To find the most common cloud cover rates, we will group the results by the 'cloud_cover' column.", "Count occurrences: We will count how many times each cloud cover value appears using COUNT(cloud_cover).", "Order by frequency: To get the most common rates, we will order the results in descending order based on the frequency count.", "Limit the results: We will limit the output to the top 3 most common cloud cover rates."], "gold_sql": "SELECT cloud_cover FROM weather WHERE zip_code  =  94107 GROUP BY cloud_cover ORDER BY COUNT (*) DESC LIMIT 3", "source_tables": ["weather"], "pred_sql": "SELECT cloud_cover, COUNT(cloud_cover) AS frequency\nFROM weather\nWHERE zip_code = 94107\nGROUP BY cloud_cover\nORDER BY frequency DESC\nLIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the cloud cover data from the 'weather' table for a specific zip code. The results are grouped by cloud cover values and ordered by the frequency of each cloud cover value, allowing users to see the most common cloud cover conditions for the specified area, limited to a certain number of results.\",\n    \"1\": \"This virtual table provides a list of unique zip codes from the 'weather' table that do not have any weather reports with a maximum dew point above a specified threshold. The placeholder in the query represents the maximum dew point value that is being used to filter the results.\",\n    \"2\": \"This virtual table identifies unique trip IDs from the 'trip' table for users whose starting zip code corresponds to weather reports with an average mean temperature above a specified threshold. The placeholder in the HAVING clause represents the temperature limit for filtering the results.\"\n}\n"}
{"sample_id": "train.161", "db_id": "bike_1", "question": "For each trip, return its ending station's installation date.", "rationale": ["We need to return the installation date of the ending station for each trip.", "The 'trip' table contains the 'end_station_id' which can be used to identify the ending station.", "The 'station' table contains the 'installation_date' for each station, which we want to retrieve.", "To get the installation date, we will perform a JOIN between the 'trip' table and the 'station' table on the 'end_station_id' and 'id' respectively."], "gold_sql": "SELECT T1.id ,  T2.installation_date FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id", "source_tables": ["trip", "station"], "pred_sql": "SELECT s.installation_date \nFROM trip t \nJOIN station s ON t.end_station_id = s.id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and identifiers of bike stations from which trips started, filtered by a specific start date. The results are grouped by station name and ordered by the number of trips, allowing users to see the most popular starting stations for that date. The placeholders in the WHERE clause represent the start date and the limit for the number of results returned.\",\n    \"1\": \"This virtual table provides a list of bike stations from which trips started, along with their unique identifiers. The results are filtered by a specific start date pattern, grouped by the station name, and ordered by the number of trips in descending order, limited to a specified number of results. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the date pattern and the number of results to return.\",\n    \"2\": \"This virtual table lists the names of bike stations located in a specific city, excluding those stations that have been used as end stations for trips more than a specified number of times. The placeholders in the WHERE clause represent the city name and the count of trips.\"\n}\n"}
{"sample_id": "train.162", "db_id": "bike_1", "question": "What is the installation date for each ending station on all the trips?", "rationale": ["We need to find the installation date for each ending station on all the trips.", "The relevant tables are 'station' and 'trip'.", "We will join the 'station' table with the 'trip' table on the condition that the station's id matches the end station id in the trip.", "We select the distinct installation dates from the 'station' table to ensure we get unique dates for each ending station."], "gold_sql": "SELECT T1.id ,  T2.installation_date FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id", "source_tables": ["trip", "station"], "pred_sql": "SELECT DISTINCT s.installation_date \nFROM station s \nJOIN trip t ON s.id = t.end_station_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and identifiers of bike stations from which trips started, filtered by a specific start date. The results are grouped by station name and ordered by the number of trips, allowing users to see the most popular starting stations for that date. The placeholders in the WHERE clause represent the start date and the limit for the number of results returned.\",\n    \"1\": \"This virtual table provides a list of bike stations from which trips started, along with their unique identifiers. The results are filtered by a specific start date pattern, grouped by the station name, and ordered by the number of trips in descending order, limited to a specified number of results. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the date pattern and the number of results to return.\",\n    \"2\": \"This virtual table lists the names of bike stations located in a specific city, excluding those stations that have been used as end stations for trips more than a specified number of times. The placeholders in the WHERE clause represent the city name and the count of trips.\"\n}\n"}
{"sample_id": "train.163", "db_id": "bike_1", "question": "Which trip started from the station with the largest dock count? Give me the trip id.", "rationale": ["Identify the relevant tables: We need to look at the 'trip' table for trip IDs and the 'station' table for dock counts.", "Join the 'trip' table with the 'station' table on the station ID to access the dock count for each trip's starting station.", "Use a subquery to find the maximum dock count from the 'station' table.", "Filter the results to only include trips that started from the station with the maximum dock count."], "gold_sql": "SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT 1", "source_tables": ["trip", "station"], "pred_sql": "SELECT trip.id \nFROM trip \nJOIN station ON trip.start_station_id = station.id \nWHERE station.dock_count = (SELECT MAX(dock_count) FROM station);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and identifiers of bike stations from which trips started, filtered by a specific start date. The results are grouped by station name and ordered by the number of trips, allowing users to see the most popular starting stations for that date. The placeholders in the WHERE clause represent the start date and the limit for the number of results returned.\",\n    \"1\": \"This virtual table provides a list of bike stations from which trips started, along with their unique identifiers. The results are filtered by a specific start date pattern, grouped by the station name, and ordered by the number of trips in descending order, limited to a specified number of results. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the date pattern and the number of results to return.\",\n    \"2\": \"This virtual table lists the names of bike stations located in a specific city, excluding those stations that have been used as end stations for trips more than a specified number of times. The placeholders in the WHERE clause represent the city name and the count of trips.\"\n}\n"}
{"sample_id": "train.165", "db_id": "bike_1", "question": "Count the number of trips that did not end in San Francisco city.", "rationale": ["Identify the main goal: Count the number of trips that did not end in San Francisco city.", "To achieve this, we need to look at the 'trip' table, specifically the 'end_station_name' column.", "We will filter the trips based on the condition that the 'end_station_name' is not in the list of station names located in San Francisco.", "To get the list of station names in San Francisco, we can use a subquery that selects names from the 'station' table where the city is 'San Francisco'.", "The final SQL query will count all trips where the end station is not in the list of San Francisco stations."], "gold_sql": "SELECT count(*) FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id WHERE T2.city !=  'San Francisco'", "source_tables": ["trip", "station"], "pred_sql": "SELECT COUNT(*) \nFROM trip \nWHERE end_station_name NOT IN (SELECT name FROM station WHERE city = 'San Francisco');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of bike stations located in a specific city, excluding those stations that have been used as end stations for trips more than a specified number of times. The placeholders in the WHERE clause represent the city name and the count of trips.\",\n    \"1\": \"This virtual table provides a list of bike stations from which trips started, along with their unique identifiers. The results are filtered by a specific start date pattern, grouped by the station name, and ordered by the number of trips in descending order, limited to a specified number of results. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the date pattern and the number of results to return.\",\n    \"2\": \"This virtual table provides the names and identifiers of bike stations from which trips started, filtered by a specific start date. The results are grouped by station name and ordered by the number of trips, allowing users to see the most popular starting stations for that date. The placeholders in the WHERE clause represent the start date and the limit for the number of results returned.\"\n}\n"}
{"sample_id": "train.166", "db_id": "bike_1", "question": "How many trips did not end in San Francisco?", "rationale": ["Identify the relevant table: The 'trip' table contains information about trips, including the end station name.", "Determine the condition: We need to count trips that did not end in San Francisco, which means we will filter out trips where the 'end_station_name' is 'San Francisco'.", "Construct the SQL query: We will use the COUNT function to count the number of trips that meet the condition, and we will select from the 'trip' table where the 'end_station_name' is not equal to 'San Francisco'."], "gold_sql": "SELECT count(*) FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id WHERE T2.city != 'San Francisco'", "source_tables": ["trip", "station"], "pred_sql": "SELECT COUNT(*) AS trips_not_ending_in_sf\nFROM trip\nWHERE end_station_name != 'San Francisco';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of bike stations located in a specific city, excluding those stations that have been used as end stations for trips more than a specified number of times. The placeholders in the WHERE clause represent the city name and the count of trips.\",\n    \"1\": \"This virtual table provides a list of bike stations from which trips started, along with their unique identifiers. The results are filtered by a specific start date pattern, grouped by the station name, and ordered by the number of trips in descending order, limited to a specified number of results. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the date pattern and the number of results to return.\",\n    \"2\": \"This virtual table provides the names and identifiers of bike stations from which trips started, filtered by a specific start date. The results are grouped by station name and ordered by the number of trips, allowing users to see the most popular starting stations for that date. The placeholders in the WHERE clause represent the start date and the limit for the number of results returned.\"\n}\n"}
{"sample_id": "train.167", "db_id": "bike_1", "question": "In zip code 94107, on which day neither Fog nor Rain was not observed?", "rationale": ["Identify the relevant table: The 'weather' table contains the necessary information about weather events and zip codes.", "Filter by zip code: We need to focus on the records where the zip code is 94107.", "Exclude specific weather events: We want to find days where neither Fog nor Rain was observed, so we will use the NOT LIKE operator to filter out any records that contain these events in the 'events' column.", "Select distinct dates: We want to retrieve unique dates that meet the criteria, so we will use SELECT DISTINCT to avoid duplicates."], "gold_sql": "SELECT date FROM weather WHERE zip_code  =  94107 AND EVENTS != 'Fog' AND EVENTS != 'Rain'", "source_tables": ["weather"], "pred_sql": "SELECT DISTINCT date \nFROM weather \nWHERE zip_code = 94107 \nAND events NOT LIKE '%Fog%' \nAND events NOT LIKE '%Rain%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique zip codes from the 'weather' table that do not have any weather reports with a maximum dew point above a specified threshold. The placeholder in the query represents the maximum dew point value that is being used to filter the results.\",\n    \"1\": \"This virtual table provides the cloud cover data from the 'weather' table for a specific zip code. The results are grouped by cloud cover values and ordered by the frequency of each cloud cover value, allowing users to see the most common cloud cover conditions for the specified area, limited to a certain number of results.\",\n    \"2\": \"This virtual table identifies unique trip IDs from the 'trip' table for users whose starting zip code corresponds to weather reports with an average mean temperature above a specified threshold. The placeholder in the HAVING clause represents the temperature limit for filtering the results.\"\n}\n"}
{"sample_id": "train.168", "db_id": "bike_1", "question": "On which day has it neither been foggy nor rained in the zip code of 94107?", "rationale": ["Identify the relevant table: The 'weather' table contains the necessary information about weather conditions.", "Filter by zip code: We need to focus on the zip code 94107, so we will include a WHERE clause for this zip code.", "Check for no rain: We will check that the total precipitation for the day is 0 inches, indicating no rain.", "Check for no fog: Fog is typically indicated by a dew point above a certain threshold, so we will check that the maximum dew point is 0, indicating no fog.", "Select the date: We want to retrieve the date of the days that meet these conditions."], "gold_sql": "SELECT date FROM weather WHERE zip_code  =  94107 AND EVENTS != 'Fog' AND EVENTS != 'Rain'", "source_tables": ["weather"], "pred_sql": "SELECT date FROM weather WHERE zip_code = 94107 AND precipitation_inches = 0 AND max_dew_point_f = 0;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique zip codes from the 'weather' table that do not have any weather reports with a maximum dew point above a specified threshold. The placeholder in the query represents the maximum dew point value that is being used to filter the results.\",\n    \"1\": \"This virtual table provides the cloud cover data from the 'weather' table for a specific zip code. The results are grouped by cloud cover values and ordered by the frequency of each cloud cover value, allowing users to see the most common cloud cover conditions for the specified area, limited to a certain number of results.\",\n    \"2\": \"This virtual table identifies unique trip IDs from the 'trip' table for users whose starting zip code corresponds to weather reports with an average mean temperature above a specified threshold. The placeholder in the HAVING clause represents the temperature limit for filtering the results.\"\n}\n"}
{"sample_id": "train.183", "db_id": "bike_1", "question": "List all the cities in a decreasing order of each city's stations' highest latitude.", "rationale": ["We need to list all the cities from the station table.", "To find the highest latitude for each city, we will use the MAX function on the 'lat' column.", "We will group the results by 'city' to ensure we get the highest latitude for each city.", "Finally, we will order the results in descending order based on the highest latitude."], "gold_sql": "SELECT city FROM station GROUP BY city ORDER BY max(lat) DESC", "source_tables": ["station"], "pred_sql": "SELECT city, MAX(lat) AS highest_latitude\nFROM station\nGROUP BY city\nORDER BY highest_latitude DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of bike stations located in a specific city, excluding those stations that have been used as end stations for trips more than a specified number of times. The placeholders in the WHERE clause represent the city name and the count of trips.\",\n    \"1\": \"This virtual table provides a list of bike stations from which trips started, along with their unique identifiers. The results are filtered by a specific start date pattern, grouped by the station name, and ordered by the number of trips in descending order, limited to a specified number of results. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the date pattern and the number of results to return.\",\n    \"2\": \"This virtual table provides the names and identifiers of bike stations from which trips started, filtered by a specific start date. The results are grouped by station name and ordered by the number of trips, allowing users to see the most popular starting stations for that date. The placeholders in the WHERE clause represent the start date and the limit for the number of results returned.\"\n}\n"}
{"sample_id": "train.184", "db_id": "bike_1", "question": "For each city, list their names in decreasing order by their highest station latitude.", "rationale": ["We need to select the city and name of the bike stations from the station table.", "To get the highest latitude for each city, we will order the results by the latitude (lat) column in descending order.", "The final output will list the names of the stations for each city, sorted by their latitude."], "gold_sql": "SELECT city FROM station GROUP BY city ORDER BY max(lat) DESC", "source_tables": ["station"], "pred_sql": "SELECT city, name FROM station ORDER BY lat DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of bike stations located in a specific city, excluding those stations that have been used as end stations for trips more than a specified number of times. The placeholders in the WHERE clause represent the city name and the count of trips.\",\n    \"1\": \"This virtual table provides the names and identifiers of bike stations from which trips started, filtered by a specific start date. The results are grouped by station name and ordered by the number of trips, allowing users to see the most popular starting stations for that date. The placeholders in the WHERE clause represent the start date and the limit for the number of results returned.\",\n    \"2\": \"This virtual table provides a list of bike stations from which trips started, along with their unique identifiers. The results are filtered by a specific start date pattern, grouped by the station name, and ordered by the number of trips in descending order, limited to a specified number of results. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the date pattern and the number of results to return.\"\n}\n"}
{"sample_id": "train.189", "db_id": "bike_1", "question": "For each station, return its longitude and the average duration of trips that started from the station.", "rationale": ["We need to select the longitude of each station and the average duration of trips that started from that station.", "The 'station' table contains the longitude information, while the 'trip' table contains the duration of trips and the station IDs where trips started.", "To get the average duration of trips for each station, we will join the 'station' table with the 'trip' table on the station ID.", "We will group the results by the station ID to calculate the average duration for each station.", "Finally, we will select the longitude from the 'station' table and the average duration of trips from the 'trip' table."], "gold_sql": "SELECT T1.name ,  T1.long ,  avg(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id GROUP BY T2.start_station_id", "source_tables": ["trip", "station"], "pred_sql": "SELECT s.long, AVG(t.duration) AS average_duration\nFROM station s\nJOIN trip t ON s.id = t.start_station_id\nGROUP BY s.id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of bike stations that have an average number of bikes available greater than a specified number, excluding those located in a specific city. The query combines data from the 'station' and 'status' tables, grouping by station ID to calculate the average bikes available, and uses placeholders for the average bike count and city name.\",\n    \"1\": \"This virtual table provides the names and identifiers of bike stations from which trips started, filtered by a specific start date. The results are grouped by station name and ordered by the number of trips, allowing users to see the most popular starting stations for that date. The placeholders in the WHERE clause represent the start date and the limit for the number of results returned.\",\n    \"2\": \"This virtual table provides a list of bike stations from which trips started, along with their unique identifiers. The results are filtered by a specific start date pattern, grouped by the station name, and ordered by the number of trips in descending order, limited to a specified number of results. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the date pattern and the number of results to return.\"\n}\n"}
{"sample_id": "train.190", "db_id": "bike_1", "question": "For each start station id, what is its name, longitude and average duration of trips started there?", "rationale": ["Identify the relevant tables: We need data from the 'station' table for station details and the 'trip' table for trip durations.", "Join the 'station' table with the 'trip' table on the station ID to link trips to their starting stations.", "Select the station ID, name, and longitude from the 'station' table, and calculate the average duration of trips from the 'trip' table using the AVG() function.", "Group the results by station ID, name, and longitude to ensure we get the average duration for each station."], "gold_sql": "SELECT T1.name ,  T1.long ,  avg(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id GROUP BY T2.start_station_id", "source_tables": ["trip", "station"], "pred_sql": "SELECT s.id, s.name, s.long, AVG(t.duration) AS average_duration\nFROM station s\nJOIN trip t ON s.id = t.start_station_id\nGROUP BY s.id, s.name, s.long;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and identifiers of bike stations from which trips started, filtered by a specific start date. The results are grouped by station name and ordered by the number of trips, allowing users to see the most popular starting stations for that date. The placeholders in the WHERE clause represent the start date and the limit for the number of results returned.\",\n    \"1\": \"This virtual table provides a list of bike stations from which trips started, along with their unique identifiers. The results are filtered by a specific start date pattern, grouped by the station name, and ordered by the number of trips in descending order, limited to a specified number of results. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the date pattern and the number of results to return.\",\n    \"2\": \"This virtual table lists the names of bike stations located in a specific city, excluding those stations that have been used as end stations for trips more than a specified number of times. The placeholders in the WHERE clause represent the city name and the count of trips.\"\n}\n"}
{"sample_id": "train.192", "db_id": "bike_1", "question": "For each end station id, what is its name, latitude, and minimum duration for trips ended there?", "rationale": ["We need to retrieve the end station id, name, latitude, and the minimum duration of trips that ended at each station.", "To do this, we will join the 'station' table with the 'trip' table on the condition that the station id in the 'station' table matches the end station id in the 'trip' table.", "We will select the station id, name, latitude from the 'station' table and the minimum duration from the 'trip' table.", "We will group the results by the station id, name, and latitude to ensure we get one result per station with the minimum trip duration."], "gold_sql": "SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id", "source_tables": ["trip", "station"], "pred_sql": "SELECT s.id, s.name, s.lat, MIN(t.duration) AS min_duration\nFROM station s\nJOIN trip t ON s.id = t.end_station_id\nGROUP BY s.id, s.name, s.lat;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of bike stations located in a specific city, excluding those stations that have been used as end stations for trips more than a specified number of times. The placeholders in the WHERE clause represent the city name and the count of trips.\",\n    \"1\": \"This virtual table provides the names and identifiers of bike stations from which trips started, filtered by a specific start date. The results are grouped by station name and ordered by the number of trips, allowing users to see the most popular starting stations for that date. The placeholders in the WHERE clause represent the start date and the limit for the number of results returned.\",\n    \"2\": \"This virtual table provides a list of bike stations from which trips started, along with their unique identifiers. The results are filtered by a specific start date pattern, grouped by the station name, and ordered by the number of trips in descending order, limited to a specified number of results. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the date pattern and the number of results to return.\"\n}\n"}
{"sample_id": "train.196", "db_id": "bike_1", "question": "What are all the different zip codes that have a maximum dew point that was always below 70?", "rationale": ["The question asks for unique zip codes with a maximum dew point always below 70.", "We need to select distinct zip codes from the 'weather' table.", "We will filter the results where the 'max_dew_point_f' is less than 70."], "gold_sql": "SELECT DISTINCT zip_code FROM weather EXCEPT SELECT DISTINCT zip_code FROM weather WHERE max_dew_point_f  >=  70", "source_tables": ["weather"], "pred_sql": "SELECT DISTINCT zip_code FROM weather WHERE max_dew_point_f < 70", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique zip codes from the 'weather' table that do not have any weather reports with a maximum dew point above a specified threshold. The placeholder in the query represents the maximum dew point value that is being used to filter the results.\",\n    \"1\": \"This virtual table provides the cloud cover data from the 'weather' table for a specific zip code. The results are grouped by cloud cover values and ordered by the frequency of each cloud cover value, allowing users to see the most common cloud cover conditions for the specified area, limited to a certain number of results.\",\n    \"2\": \"This virtual table identifies unique trip IDs from the 'trip' table for users whose starting zip code corresponds to weather reports with an average mean temperature above a specified threshold. The placeholder in the HAVING clause represents the temperature limit for filtering the results.\"\n}\n"}
{"sample_id": "train.205", "db_id": "bike_1", "question": "Give me the zip code where the average mean humidity is below 70 and at least 100 trips took place.", "rationale": ["We need to find zip codes where the average mean humidity is below 70 and at least 100 trips took place.", "To achieve this, we will use the 'trip' table since it contains the 'zip_code' and 'id' columns.", "We will group the results by 'zip_code' to calculate the average mean humidity and count the number of trips for each zip code.", "The HAVING clause will be used to filter the groups: we want those with a count of trips (id) greater than or equal to 100 and an average mean humidity less than 70."], "gold_sql": "SELECT zip_code FROM weather GROUP BY zip_code HAVING avg(mean_humidity)  <  70 INTERSECT SELECT zip_code FROM trip GROUP BY zip_code HAVING count(*)  >=  100", "source_tables": ["weather", "trip"], "pred_sql": "SELECT zip_code\nFROM trip\nGROUP BY zip_code\nHAVING COUNT(id) >= 100 AND AVG(mean_humidity) < 70;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies unique trip IDs from the 'trip' table for users whose starting zip code corresponds to weather reports with an average mean temperature above a specified threshold. The placeholder in the HAVING clause represents the temperature limit for filtering the results.\",\n    \"1\": \"This virtual table identifies unique trip IDs from the 'trip' table for users whose starting zip code corresponds to weather reports with an average mean temperature above a specified threshold. The placeholder in the HAVING clause represents the temperature limit for filtering the results.\",\n    \"2\": \"This virtual table provides a list of unique zip codes from the 'weather' table that do not have any weather reports with a maximum dew point above a specified threshold. The placeholder in the query represents the maximum dew point value that is being used to filter the results.\"\n}\n"}
{"sample_id": "train.206", "db_id": "bike_1", "question": "What are the zip codes that have an average mean humidity below 70 and had at least 100 trips come through there?", "rationale": ["We need to find zip codes with an average mean humidity below 70 and at least 100 trips.", "We will use the 'trip' table to group by 'zip_code' since it contains the zip codes of users starting their trips.", "We will count the number of trips (using the 'id' column) for each zip code and filter those with at least 100 trips using the HAVING clause.", "We will also calculate the average mean humidity for each zip code, which requires joining the 'trip' table with the 'weather' table on the zip code.", "Finally, we will filter the results to include only those zip codes where the average mean humidity is below 70."], "gold_sql": "SELECT zip_code FROM weather GROUP BY zip_code HAVING avg(mean_humidity)  <  70 INTERSECT SELECT zip_code FROM trip GROUP BY zip_code HAVING count(*)  >=  100", "source_tables": ["weather", "trip"], "pred_sql": "SELECT zip_code\nFROM trip\nGROUP BY zip_code\nHAVING COUNT(id) >= 100 AND AVG(mean_humidity) < 70;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique zip codes from the 'weather' table that do not have any weather reports with a maximum dew point above a specified threshold. The placeholder in the query represents the maximum dew point value that is being used to filter the results.\",\n    \"1\": \"This virtual table identifies unique trip IDs from the 'trip' table for users whose starting zip code corresponds to weather reports with an average mean temperature above a specified threshold. The placeholder in the HAVING clause represents the temperature limit for filtering the results.\",\n    \"2\": \"This virtual table identifies unique trip IDs from the 'trip' table for users whose starting zip code corresponds to weather reports with an average mean temperature above a specified threshold. The placeholder in the HAVING clause represents the temperature limit for filtering the results.\"\n}\n"}
{"sample_id": "train.304", "db_id": "product_catalog", "question": "What are the attribute data types with more than 3 attribute definitions?", "rationale": ["Identify the table that contains the attribute definitions, which is 'Attribute_Definitions'.", "We need to find the attribute data types, so we will select the 'attribute_data_type' column.", "To find the count of attribute definitions for each data type, we will group the results by 'attribute_data_type'.", "We want only those data types that have more than 3 attribute definitions, so we will use the HAVING clause with COUNT(attribute_id) > 3."], "gold_sql": "SELECT attribute_data_type FROM Attribute_Definitions GROUP BY attribute_data_type HAVING count(*)  >  3", "source_tables": ["attribute_definitions"], "pred_sql": "SELECT attribute_data_type\nFROM Attribute_Definitions\nGROUP BY attribute_data_type\nHAVING COUNT(attribute_id) > 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that have a specific attribute value. The query joins the 'Catalog_Contents' table with the 'Catalog_Contents_Additional_Attributes' table to filter entries based on the most common attribute value, represented by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.316", "db_id": "product_catalog", "question": "Find the entry names of the catalog with the attribute that have the most entries.", "rationale": ["Identify the relevant tables: 'Catalog_Contents' for entry names and 'Catalog_Contents_Additional_Attributes' for attributes.", "Join 'Catalog_Contents' with 'Catalog_Contents_Additional_Attributes' to link entries with their attributes.", "Use a subquery to find the attribute_id that has the most entries by grouping and counting the entries for each attribute.", "Filter the main query to only include entries that have the most common attribute identified in the subquery."], "gold_sql": "SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.attribute_value  =  (SELECT attribute_value FROM Catalog_Contents_Additional_Attributes GROUP BY attribute_value ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["catalog_contents", "catalog_contents_additional_attributes"], "pred_sql": "SELECT cc.catalog_entry_name\nFROM Catalog_Contents cc\nJOIN Catalog_Contents_Additional_Attributes cca ON cc.catalog_entry_id = cca.catalog_entry_id\nWHERE cca.attribute_id = (\n    SELECT attribute_id\n    FROM Catalog_Contents_Additional_Attributes\n    GROUP BY attribute_id\n    ORDER BY COUNT(*) DESC\n    LIMIT 1\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that have a specific attribute value. The query joins the 'Catalog_Contents' table with the 'Catalog_Contents_Additional_Attributes' table to filter entries based on the most common attribute value, represented by a placeholder for numeric values.\",\n    \"1\": \"The virtual table provides the latest revision dates of catalogs from the 'Catalogs' table, grouped by the revision date. The placeholder in the HAVING clause represents the minimum count of catalogs that must share the same revision date.\"\n}\n"}
{"sample_id": "train.317", "db_id": "product_catalog", "question": "What is the entry name of the most expensive catalog (in USD)?", "rationale": ["Identify the relevant tables: Catalog_Contents for entry names and prices, and Catalogs for catalog information.", "We need to find the most expensive catalog entry based on the price in USD, which is stored in the price_in_dollars column of the Catalog_Contents table.", "To get the entry name of the most expensive catalog, we will order the entries by price in descending order.", "We will limit the results to 1 to get only the most expensive entry.", "The final SQL query will select the catalog_entry_name from Catalog_Contents, ordering by price_in_dollars."], "gold_sql": "SELECT catalog_entry_name FROM catalog_contents ORDER BY price_in_dollars DESC LIMIT 1", "source_tables": ["catalog_contents"], "pred_sql": "SELECT cc.catalog_entry_name\nFROM Catalog_Contents cc\nJOIN Catalogs c ON cc.catalog_level_number = c.catalog_id\nORDER BY CAST(cc.price_in_dollars AS REAL) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that have a specific attribute value. The query joins the 'Catalog_Contents' table with the 'Catalog_Contents_Additional_Attributes' table to filter entries based on the most common attribute value, represented by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.330", "db_id": "product_catalog", "question": "What are the names of catalog entries with level number 8?", "rationale": ["Identify the table that contains the catalog entry names, which is 'Catalog_Contents'.", "Determine the condition needed to filter the entries, which is the 'catalog_level_number' being equal to '8'.", "Construct the SQL query to select the 'catalog_entry_name' from 'Catalog_Contents' where the 'catalog_level_number' matches the specified value."], "gold_sql": "SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.catalog_level_number  =  '8'", "source_tables": ["catalog_contents", "catalog_contents_additional_attributes"], "pred_sql": "SELECT catalog_entry_name FROM Catalog_Contents WHERE catalog_level_number = '8';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that have a specific attribute value. The query joins the 'Catalog_Contents' table with the 'Catalog_Contents_Additional_Attributes' table to filter entries based on the most common attribute value, represented by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.331", "db_id": "product_catalog", "question": "Find the names of the products with length smaller than 3 or height greater than 5.", "rationale": ["Identify the table that contains product information, which is the Catalog_Contents table.", "Determine the relevant columns needed for the query: catalog_entry_name for product names, length for the length condition, and height for the height condition.", "Construct the SQL SELECT statement to retrieve the catalog_entry_name from the Catalog_Contents table.", "Add the WHERE clause to filter products based on the conditions: length smaller than 3 or height greater than 5."], "gold_sql": "SELECT catalog_entry_name FROM catalog_contents WHERE LENGTH  <  3 OR width  >  5", "source_tables": ["catalog_contents"], "pred_sql": "SELECT catalog_entry_name \nFROM Catalog_Contents \nWHERE length < 3 OR height > 5;", "hint": "\n"}
{"sample_id": "train.332", "db_id": "product_catalog", "question": "Which catalog contents have length below 3 or above 5? Find the catalog entry names.", "rationale": ["Identify the relevant table: The 'Catalog_Contents' table contains the 'length' and 'catalog_entry_name' columns.", "Determine the filtering criteria: We need to find entries where the length is below 3 or above 5.", "Construct the SQL query: Use a SELECT statement to retrieve 'catalog_entry_name' from 'Catalog_Contents' where the length conditions are met."], "gold_sql": "SELECT catalog_entry_name FROM catalog_contents WHERE LENGTH  <  3 OR width  >  5", "source_tables": ["catalog_contents"], "pred_sql": "SELECT catalog_entry_name FROM Catalog_Contents WHERE length < 3 OR length > 5;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that have a specific attribute value. The query joins the 'Catalog_Contents' table with the 'Catalog_Contents_Additional_Attributes' table to filter entries based on the most common attribute value, represented by a placeholder for numeric values.\",\n    \"1\": \"The virtual table provides the latest revision dates of catalogs from the 'Catalogs' table, grouped by the revision date. The placeholder in the HAVING clause represents the minimum count of catalogs that must share the same revision date.\"\n}\n"}
{"sample_id": "train.338", "db_id": "product_catalog", "question": "On which days more than one revisions were made on catalogs.", "rationale": ["Identify the relevant table: The 'Catalogs' table contains the information about catalog revisions, specifically the 'date_of_latest_revision' column.", "Group the results by 'date_of_latest_revision' to count how many catalogs were revised on each date.", "Use the COUNT function to count the number of catalogs for each revision date.", "Apply the HAVING clause to filter the results to only include dates where the count of revisions is greater than one."], "gold_sql": "SELECT date_of_latest_revision FROM Catalogs GROUP BY date_of_latest_revision HAVING count(*)  >  1", "source_tables": ["catalogs"], "pred_sql": "SELECT date_of_latest_revision, COUNT(catalog_id) AS revision_count\nFROM Catalogs\nGROUP BY date_of_latest_revision\nHAVING COUNT(catalog_id) > 1;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table provides the latest revision dates of catalogs from the 'Catalogs' table, grouped by the revision date. The placeholder in the HAVING clause represents the minimum count of catalogs that must share the same revision date.\",\n    \"1\": \"This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that have a specific attribute value. The query joins the 'Catalog_Contents' table with the 'Catalog_Contents_Additional_Attributes' table to filter entries based on the most common attribute value, represented by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.388", "db_id": "flight_1", "question": "What are the origins of all flights that are headed to Honolulu?", "rationale": ["Identify the relevant table: The 'flight' table contains information about flight origins and destinations.", "Determine the required information: We need the origins of flights that are headed to Honolulu.", "Construct the SQL query: Use SELECT to get distinct origins from the flight table where the destination is 'Honolulu'."], "gold_sql": "SELECT origin FROM Flight WHERE destination  =  'Honolulu'", "source_tables": ["flight"], "pred_sql": "SELECT DISTINCT origin FROM flight WHERE destination = 'Honolulu';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average distance and average price of flights originating from a specific location. The placeholder in the WHERE clause represents the origin of the flights.\"\n}\n"}
{"sample_id": "train.390", "db_id": "flight_1", "question": "What are the departure and arrival dates of all flights from LA to Honolulu?", "rationale": ["Identify the relevant table: The 'flight' table contains the necessary information about flights, including departure and arrival dates.", "Determine the required columns: We need 'departure_date' and 'arrival_date' for the flights.", "Specify the conditions: We want flights that originate from 'LA' and have 'Honolulu' as their destination.", "Construct the SQL query: Use a SELECT statement to retrieve the specified columns from the 'flight' table with the appropriate WHERE clause."], "gold_sql": "SELECT departure_date ,  arrival_date FROM Flight WHERE origin  =  'Los Angeles' AND destination  =  'Honolulu'", "source_tables": ["flight"], "pred_sql": "SELECT departure_date, arrival_date FROM flight WHERE origin = 'LA' AND destination = 'Honolulu';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average distance and average price of flights originating from a specific location. The placeholder in the WHERE clause represents the origin of the flights.\"\n}\n"}
{"sample_id": "train.394", "db_id": "flight_1", "question": "What is the average price for flights from LA to Honolulu?", "rationale": ["Identify the relevant table: The 'flight' table contains the necessary information about flights, including their prices and origins.", "Determine the required calculation: We need to calculate the average price of flights, which can be done using the AVG() function.", "Specify the conditions: We need to filter the flights to only include those that originate from 'LA' and have 'Honolulu' as their destination.", "Construct the SQL query: Combine the SELECT statement with the AVG() function, the FROM clause to specify the 'flight' table, and the WHERE clause to filter the results based on the specified origin and destination."], "gold_sql": "SELECT avg(price) FROM Flight WHERE origin  =  'Los Angeles' AND destination  =  'Honolulu'", "source_tables": ["flight"], "pred_sql": "SELECT AVG(price) AS average_price FROM flight WHERE origin = 'LA' AND destination = 'Honolulu';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average distance and average price of flights originating from a specific location. The placeholder in the WHERE clause represents the origin of the flights.\"\n}\n"}
{"sample_id": "train.415", "db_id": "flight_1", "question": "Show aircraft names and number of flights for each aircraft.", "rationale": ["Identify the tables needed: We need data from the 'aircraft' table for aircraft names and the 'flight' table for the number of flights.", "Join the 'aircraft' table with the 'flight' table on the aircraft ID (aid) to associate each flight with its corresponding aircraft.", "Use a LEFT JOIN to ensure we include all aircraft, even those with no flights.", "Count the number of flights (flno) for each aircraft using COUNT() function.", "Group the results by aircraft ID and name to get the count of flights for each aircraft."], "gold_sql": "SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid", "source_tables": ["aircraft", "flight"], "pred_sql": "SELECT a.name, COUNT(f.flno) AS number_of_flights\nFROM aircraft a\nLEFT JOIN flight f ON a.aid = f.aid\nGROUP BY a.aid, a.name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of aircraft that have been certified by employees, filtered by the maximum distance the aircraft can travel. The results are grouped by aircraft ID and ordered based on the count of certifications that meet a specified threshold.\",\n    \"1\": \"This virtual table provides the names of aircraft that have been certified by employees, filtered by the maximum distance the aircraft can travel. The results are grouped by aircraft ID and ordered based on the count of certifications that meet a specified threshold.\",\n    \"2\": \"This virtual table provides the names of employees who hold certificates for aircraft that can travel a distance greater than a specified value. The results are grouped by employee ID and ordered by the number of certificates held, with a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.416", "db_id": "flight_1", "question": "What is the name of each aircraft and how many flights does each one complete?", "rationale": ["Identify the tables involved: We need data from the 'aircraft' table for aircraft names and the 'flight' table for counting flights.", "Join the 'aircraft' table with the 'flight' table on the aircraft ID (aid) to associate each flight with its corresponding aircraft.", "Use a LEFT JOIN to ensure we include all aircraft, even those with no flights.", "Count the number of flights (flno) for each aircraft using COUNT() function.", "Group the results by aircraft ID to get the count of flights for each aircraft.", "Select the aircraft name and the count of flights as the final output."], "gold_sql": "SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid", "source_tables": ["aircraft", "flight"], "pred_sql": "SELECT aircraft.name, COUNT(flight.flno) AS flight_count\nFROM aircraft\nLEFT JOIN flight ON aircraft.aid = flight.aid\nGROUP BY aircraft.aid;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of aircraft that have been certified by employees, filtered by the maximum distance the aircraft can travel. The results are grouped by aircraft ID and ordered based on the count of certifications that meet a specified threshold.\",\n    \"1\": \"This virtual table provides the names of aircraft that have been certified by employees, filtered by the maximum distance the aircraft can travel. The results are grouped by aircraft ID and ordered based on the count of certifications that meet a specified threshold.\",\n    \"2\": \"This virtual table provides the names of employees who hold certificates for aircraft that can travel a distance greater than a specified value. The results are grouped by employee ID and ordered by the number of certificates held, with a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.430", "db_id": "flight_1", "question": "What are the names of all employees who are not certified to fly Boeing 737-800s?", "rationale": ["Identify the employees from the 'employee' table.", "We need to find employees who do not hold a certificate for the Boeing 737-800.", "To do this, we will use a subquery to find all employee IDs (eid) that are certified to fly the Boeing 737-800.", "The subquery will select the employee IDs from the 'certificate' table where the aircraft ID (aid) corresponds to the Boeing 737-800.", "We will then use the 'aid' to find the specific aircraft in the 'aircraft' table by filtering on the name 'Boeing 737-800'.", "Finally, we will select the names of employees whose IDs are not in the list of certified employee IDs."], "gold_sql": "SELECT name FROM Employee EXCEPT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  'Boeing 737-800'", "source_tables": ["employee", "certificate", "aircraft"], "pred_sql": "SELECT name FROM employee WHERE eid NOT IN (SELECT eid FROM certificate WHERE aid IN (SELECT aid FROM aircraft WHERE name = 'Boeing 737-800'));", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of employees from the 'Employee' table who do not hold a certificate for a specific aircraft model. The placeholder in the query represents the name of the aircraft model.\",\n    \"1\": \"This virtual table provides the names of employees who hold certificates for aircraft that can travel a distance greater than a specified value. The results are grouped by employee ID and ordered by the number of certificates held, with a limit on the number of results returned.\",\n    \"2\": \"This virtual table provides the names of aircraft that have been certified by employees, filtered by the maximum distance the aircraft can travel. The results are grouped by aircraft ID and ordered based on the count of certifications that meet a specified threshold.\"\n}\n"}
{"sample_id": "train.431", "db_id": "flight_1", "question": "Show the name of aircraft which fewest people have its certificate.", "rationale": ["Identify the relevant tables: 'aircraft' for aircraft names and 'certificate' for certification details.", "Join the 'aircraft' table with the 'certificate' table on the aircraft ID (aid) to link aircraft with their certifications.", "Group the results by aircraft ID to count the number of certificates each aircraft has.", "Order the results by the count of certificates in ascending order to find the aircraft with the fewest certifications.", "Limit the results to 1 to get only the aircraft with the fewest certifications."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["aircraft", "certificate"], "pred_sql": "SELECT a.name\nFROM aircraft a\nJOIN certificate c ON a.aid = c.aid\nGROUP BY a.aid\nORDER BY COUNT(c.eid) ASC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of aircraft that have been certified by employees, filtered by the maximum distance the aircraft can travel. The results are grouped by aircraft ID and ordered based on the count of certifications that meet a specified threshold.\",\n    \"1\": \"This virtual table provides the names of aircraft that have been certified by employees, filtered by the maximum distance the aircraft can travel. The results are grouped by aircraft ID and ordered based on the count of certifications that meet a specified threshold.\",\n    \"2\": \"This virtual table lists the names of employees from the 'Employee' table who do not hold a certificate for a specific aircraft model. The placeholder in the query represents the name of the aircraft model.\"\n}\n"}
{"sample_id": "train.432", "db_id": "flight_1", "question": "What are the names of the aircraft that the least people are certified to fly?", "rationale": ["Identify the relevant tables: We need to find aircraft names and the number of certifications, so we will use the 'aircraft' and 'certificate' tables.", "Join the tables: We will perform a LEFT JOIN between 'aircraft' and 'certificate' on the aircraft ID (aid) to get all aircraft and their corresponding certification counts.", "Group the results: We will group the results by aircraft ID to count the number of certifications for each aircraft.", "Order the results: We will order the results by the count of certifications in ascending order to find the aircraft with the least certifications.", "Limit the results: We will limit the results to 1 to get only the aircraft with the least number of certifications."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["aircraft", "certificate"], "pred_sql": "SELECT a.name\nFROM aircraft a\nLEFT JOIN certificate c ON a.aid = c.aid\nGROUP BY a.aid\nORDER BY COUNT(c.eid) ASC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of aircraft that have been certified by employees, filtered by the maximum distance the aircraft can travel. The results are grouped by aircraft ID and ordered based on the count of certifications that meet a specified threshold.\",\n    \"1\": \"This virtual table provides the names of aircraft that have been certified by employees, filtered by the maximum distance the aircraft can travel. The results are grouped by aircraft ID and ordered based on the count of certifications that meet a specified threshold.\",\n    \"2\": \"This virtual table lists the names of employees from the 'Employee' table who do not hold a certificate for a specific aircraft model. The placeholder in the query represents the name of the aircraft model.\"\n}\n"}
{"sample_id": "train.438", "db_id": "flight_1", "question": "What is the salaray and name of the employee with the most certificates to fly planes more than 5000?", "rationale": ["Identify the relevant tables: employee, certificate, and aircraft.", "We need to find employees who hold certificates for aircraft that can travel more than 5000 miles or kilometers.", "Join the employee table with the certificate table on employee ID (eid) and then join with the aircraft table on aircraft ID (aid).", "Filter the results to include only those aircraft with a distance greater than 5000.", "Group the results by employee ID to count the number of certificates each employee holds.", "Order the results by the count of certificates in descending order to find the employee with the most certificates.", "Limit the results to 1 to get only the top employee."], "gold_sql": "SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  5000 GROUP BY T1.eid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employee", "certificate", "aircraft"], "pred_sql": "SELECT e.name, e.salary\nFROM employee e\nJOIN certificate c ON e.eid = c.eid\nJOIN aircraft a ON c.aid = a.aid\nWHERE a.distance > 5000\nGROUP BY e.eid\nORDER BY COUNT(c.aid) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of employees who hold certificates for aircraft that can travel a distance greater than a specified value. The results are grouped by employee ID and ordered by the number of certificates held, with a limit on the number of results returned.\",\n    \"1\": \"This virtual table provides the names of aircraft that have been certified by employees, filtered by the maximum distance the aircraft can travel. The results are grouped by aircraft ID and ordered based on the count of certifications that meet a specified threshold.\",\n    \"2\": \"This virtual table provides the names of aircraft that have been certified by employees, filtered by the maximum distance the aircraft can travel. The results are grouped by aircraft ID and ordered based on the count of certifications that meet a specified threshold.\"\n}\n"}
{"sample_id": "train.448", "db_id": "allergy_1", "question": "What are all the different food allergies?", "rationale": ["The question asks for all the different food allergies, which implies we need to retrieve unique allergy names.", "We will use the 'Allergy_Type' table since it contains the 'Allergy' column that lists the names of allergies.", "To ensure we get only unique allergy names, we will use the DISTINCT keyword in our SQL query."], "gold_sql": "SELECT DISTINCT allergy FROM Allergy_type WHERE allergytype  =  'food'", "source_tables": ["allergy_type"], "pred_sql": "SELECT DISTINCT Allergy FROM Allergy_Type;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of allergies and their types for students based on their first name. The placeholders in the WHERE clause allow for filtering by a specific student's first name.\",\n    \"1\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.\",\n    \"2\": \"This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the query represent the gender of the students and the type of allergy they have.\"\n}\n"}
{"sample_id": "train.452", "db_id": "allergy_1", "question": "How many animal type allergies exist?", "rationale": ["Identify the relevant table: The Allergy_Type table contains the allergy names and their types.", "Determine the specific type of allergy: The question asks about animal type allergies, so we need to filter by AllergyType = 'Animal'.", "Count the distinct allergies: We need to count how many unique allergies fall under the animal category, which can be done using COUNT(DISTINCT Allergy).", "Construct the SQL query: Combine the elements into a complete SQL query that selects the count of distinct allergies from the Allergy_Type table where the AllergyType is 'Animal'."], "gold_sql": "SELECT count(*) FROM Allergy_type WHERE allergytype  =  'animal'", "source_tables": ["allergy_type"], "pred_sql": "SELECT COUNT(DISTINCT Allergy) AS Animal_Allergy_Count\nFROM Allergy_Type\nWHERE AllergyType = 'Animal';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.\",\n    \"1\": \"This virtual table provides a list of allergies and their types for students based on their first name. The placeholders in the WHERE clause allow for filtering by a specific student's first name.\",\n    \"2\": \"This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the query represent the gender of the students and the type of allergy they have.\"\n}\n"}
{"sample_id": "train.455", "db_id": "allergy_1", "question": "Which allergy type has most number of allergies?", "rationale": ["Identify the tables involved: Allergy_Type and Has_Allergy are relevant for this query.", "We need to count the number of allergies for each allergy type, so we will use COUNT() function.", "Join the Allergy_Type table with the Has_Allergy table on the Allergy column to get the relationship between allergies and their types.", "Group the results by AllergyType to aggregate the counts for each type of allergy.", "Order the results by the count of allergies in descending order to find the type with the most allergies.", "Limit the results to 1 to get only the allergy type with the highest count."], "gold_sql": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT 1", "source_tables": ["allergy_type"], "pred_sql": "SELECT AllergyType, COUNT(Allergy) AS AllergyCount\nFROM Allergy_Type\nJOIN Has_Allergy ON Allergy_Type.Allergy = Has_Allergy.Allergy\nGROUP BY AllergyType\nORDER BY AllergyCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.\",\n    \"1\": \"This virtual table provides a list of allergies and their types for students based on their first name. The placeholders in the WHERE clause allow for filtering by a specific student's first name.\",\n    \"2\": \"This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the query represent the gender of the students and the type of allergy they have.\"\n}\n"}
{"sample_id": "train.458", "db_id": "allergy_1", "question": "Which allergy type is the least common?", "rationale": ["To find the least common allergy type, we need to count how many students have each type of allergy.", "We will join the 'Has_Allergy' table with the 'Allergy_Type' table on the 'Allergy' column to get the allergy types associated with each allergy.", "We will group the results by 'AllergyType' to count the number of occurrences of each type.", "We will order the results in ascending order based on the count of students for each allergy type.", "Finally, we will limit the results to 1 to get the least common allergy type."], "gold_sql": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) ASC LIMIT 1", "source_tables": ["allergy_type"], "pred_sql": "SELECT AllergyType, COUNT(*) AS AllergyCount\nFROM Has_Allergy\nJOIN Allergy_Type ON Has_Allergy.Allergy = Allergy_Type.Allergy\nGROUP BY AllergyType\nORDER BY AllergyCount ASC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.\",\n    \"1\": \"This virtual table provides a list of allergies and their types for students based on their first name. The placeholders in the WHERE clause allow for filtering by a specific student's first name.\",\n    \"2\": \"This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the query represent the gender of the students and the type of allergy they have.\"\n}\n"}
{"sample_id": "train.462", "db_id": "allergy_1", "question": "What are the full names of all students", "rationale": ["Identify the table that contains student names, which is the 'Student' table.", "Determine the columns needed to get the full names of the students, which are 'Fname' and 'LName'.", "Construct the SQL query to select 'Fname' and 'LName' from the 'Student' table."], "gold_sql": "SELECT Fname ,  Lname FROM Student", "source_tables": ["student"], "pred_sql": "SELECT Fname, LName FROM Student;", "hint": "\n"}
{"sample_id": "train.472", "db_id": "allergy_1", "question": "What are the student ids for all male students?", "rationale": ["Identify the table that contains student information, which is the 'Student' table.", "Determine the relevant column for filtering male students, which is the 'Sex' column.", "Construct a SQL SELECT statement to retrieve the 'StuID' of students where 'Sex' is equal to 'Male'."], "gold_sql": "SELECT StuID FROM Student WHERE Sex  =  'M'", "source_tables": ["student"], "pred_sql": "SELECT StuID FROM Student WHERE Sex = 'Male';", "hint": "\n"}
{"sample_id": "train.492", "db_id": "allergy_1", "question": "What is the largest major?", "rationale": ["Identify the table that contains the major information, which is the 'Student' table.", "To find the largest major, we need to count how many students are in each major.", "We will use the COUNT function to count the number of students for each major.", "We will group the results by the 'Major' column to get the count for each major.", "To find the largest major, we will order the results in descending order based on the count of students.", "Finally, we will limit the results to 1 to get only the largest major."], "gold_sql": "SELECT major FROM Student GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Major FROM Student GROUP BY Major ORDER BY COUNT(*) DESC LIMIT 1;", "hint": "\n"}
{"sample_id": "train.502", "db_id": "allergy_1", "question": "Give the advisor with the most students.", "rationale": ["Identify the relevant table: The 'Student' table contains the 'Advisor' and 'StuID' columns.", "Count the number of students for each advisor: Use COUNT(StuID) to count the number of students associated with each advisor.", "Group the results by advisor: Use GROUP BY Advisor to aggregate the counts for each advisor.", "Order the results: Use ORDER BY StudentCount DESC to sort the advisors by the number of students in descending order.", "Limit the results to the top advisor: Use LIMIT 1 to get only the advisor with the most students."], "gold_sql": "SELECT advisor FROM Student GROUP BY advisor ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Advisor, COUNT(StuID) AS StudentCount\nFROM Student\nGROUP BY Advisor\nORDER BY StudentCount DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.503", "db_id": "allergy_1", "question": "How many students have cat allergies?", "rationale": ["Identify the relevant tables: We need to find students with cat allergies, so we will use the Has_Allergy table to find students with a specific allergy.", "Determine the condition: We are looking for students who have a specific allergy, which is 'cat'.", "Count the distinct students: We need to count the number of unique students (StuID) who have this allergy, so we will use COUNT(DISTINCT StuID).", "Construct the SQL query: Combine the above elements into a SQL query that selects the count of distinct student IDs from the Has_Allergy table where the allergy is 'cat'."], "gold_sql": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  'Cat'", "source_tables": ["has_allergy"], "pred_sql": "SELECT COUNT(DISTINCT Has_Allergy.StuID) AS StudentCount\nFROM Has_Allergy\nWHERE Has_Allergy.Allergy = 'cat';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.\",\n    \"1\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the types of allergies to exclude.\",\n    \"2\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the allergy types to be excluded.\"\n}\n"}
{"sample_id": "train.504", "db_id": "allergy_1", "question": "How many students are affected by cat allergies?", "rationale": ["Identify the relevant tables: We need to find students with cat allergies, so we will use the Has_Allergy table.", "Determine the necessary columns: We need to count the unique student IDs (StuID) from the Has_Allergy table where the allergy is 'cat'.", "Construct the SQL query: We will use COUNT(DISTINCT StuID) to get the number of unique students with cat allergies."], "gold_sql": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  'Cat'", "source_tables": ["has_allergy"], "pred_sql": "SELECT COUNT(DISTINCT Has_Allergy.StuID) AS StudentCount\nFROM Has_Allergy\nWHERE Has_Allergy.Allergy = 'cat';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.\",\n    \"1\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the allergy types to be excluded.\",\n    \"2\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the types of allergies to exclude.\"\n}\n"}
{"sample_id": "train.510", "db_id": "allergy_1", "question": "How many students who are female are allergic to milk or eggs?", "rationale": ["Identify the relevant tables: We need to use the 'Student' table to filter by gender and the 'Has_Allergy' table to check for specific allergies.", "We need to count the number of distinct students, so we will use COUNT(DISTINCT Student.StuID).", "We will join the 'Student' table with the 'Has_Allergy' table on the StuID to link students with their allergies.", "We will filter the results to include only female students by adding a WHERE clause for Student.Sex = 'Female'.", "We will also filter for students who have allergies to either milk or eggs using the IN clause: Has_Allergy.Allergy IN ('Milk', 'Eggs').", "Combine all these elements to form the final SQL query."], "gold_sql": "SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  'F' AND T1.allergy  =  'Milk' OR T1.allergy  =  'Eggs'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT COUNT(DISTINCT Student.StuID) \nFROM Student \nJOIN Has_Allergy ON Student.StuID = Has_Allergy.StuID \nWHERE Student.Sex = 'Female' \nAND Has_Allergy.Allergy IN ('Milk', 'Eggs');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the query represent the gender of the students and the type of allergy they have.\",\n    \"1\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.\",\n    \"2\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the types of allergies to exclude.\"\n}\n"}
{"sample_id": "train.514", "db_id": "allergy_1", "question": "Which allergy is the most common?", "rationale": ["To find the most common allergy, we need to count how many students have each type of allergy.", "We will use the Has_Allergy table, which links students to their allergies.", "We will group the results by the Allergy column to get the count of students for each allergy.", "We will order the results in descending order based on the count of students for each allergy.", "Finally, we will limit the results to 1 to get the most common allergy."], "gold_sql": "SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT 1", "source_tables": ["has_allergy"], "pred_sql": "SELECT Allergy, COUNT(*) as AllergyCount\nFROM Has_Allergy\nGROUP BY Allergy\nORDER BY AllergyCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.\",\n    \"1\": \"This virtual table provides a list of allergies and their types for students based on their first name. The placeholders in the WHERE clause allow for filtering by a specific student's first name.\",\n    \"2\": \"This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the query represent the gender of the students and the type of allergy they have.\"\n}\n"}
{"sample_id": "train.519", "db_id": "allergy_1", "question": "Find the last name and age of the student who has allergy to both milk and cat.", "rationale": ["Identify the tables needed: We need to retrieve student information (last name and age) and their allergies, so we will use the Student and Has_Allergy tables.", "Determine the relationships: The Has_Allergy table links students to their allergies via the StuID. We will need to join the Has_Allergy table twice to check for both allergies (milk and cat).", "Construct the SELECT statement: We want to select the last name (LName) and age (Age) of the students.", "Set up the JOINs: We will join the Student table with the Has_Allergy table twice, once for each allergy type (milk and cat).", "Add the WHERE clause: We will filter the results to include only those students who have both allergies by specifying the conditions for each join."], "gold_sql": "SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT S.LName, S.Age \nFROM Student S \nJOIN Has_Allergy HA1 ON S.StuID = HA1.StuID \nJOIN Has_Allergy HA2 ON S.StuID = HA2.StuID \nWHERE HA1.Allergy = 'milk' AND HA2.Allergy = 'cat';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.\",\n    \"1\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the allergy types to be excluded.\",\n    \"2\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the types of allergies to exclude.\"\n}\n"}
{"sample_id": "train.520", "db_id": "allergy_1", "question": "What are the last names and ages of the students who are allergic to milk and cat?", "rationale": ["Identify the tables needed: We need to retrieve student information (last names and ages) and their allergies, so we will use the 'Student' and 'Has_Allergy' tables.", "Determine the relationship: The 'Has_Allergy' table links students to their allergies via the 'StuID' column, which is also present in the 'Student' table.", "Select the required columns: We need the last names (LName) and ages (Age) of the students, so we will select these columns from the 'Student' table.", "Filter the results: We need to filter the students who have specific allergies, in this case, 'milk' and 'cat'. This can be done using a WHERE clause with the IN operator.", "Join the tables: We will perform an INNER JOIN between 'Student' and 'Has_Allergy' on the 'StuID' column to combine the relevant data from both tables.", "Group the results: Since we are interested in unique students, we will group the results by 'StuID' to avoid duplicates."], "gold_sql": "SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT S.LName, S.Age \nFROM Student S \nJOIN Has_Allergy HA ON S.StuID = HA.StuID \nWHERE HA.Allergy IN ('milk', 'cat') \nGROUP BY S.StuID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.\",\n    \"1\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the allergy types to be excluded.\",\n    \"2\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the types of allergies to exclude.\"\n}\n"}
{"sample_id": "train.523", "db_id": "allergy_1", "question": "Find the first name and gender of the student who has allergy to milk but not cat.", "rationale": ["Identify the relevant tables: We need to retrieve student information from the 'Student' table and allergy information from the 'Has_Allergy' table.", "Determine the conditions: We want students who have an allergy to 'milk' and do not have an allergy to 'cat'.", "Use subqueries to filter students: The first subquery selects students with a 'milk' allergy, and the second subquery excludes students with a 'cat' allergy.", "Combine the results: Use the 'IN' clause to filter the 'StuID' from the 'Student' table based on the results of the subqueries.", "Select the required fields: We need to select the 'Fname' and 'Sex' of the students who meet the criteria."], "gold_sql": "SELECT fname ,  sex FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' EXCEPT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT Fname, Sex \nFROM Student \nWHERE StuID IN (\n    SELECT StuID \n    FROM Has_Allergy \n    WHERE Allergy = 'milk'\n) \nAND StuID NOT IN (\n    SELECT StuID \n    FROM Has_Allergy \n    WHERE Allergy = 'cat'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of allergies and their types for students based on their first name. The placeholders in the WHERE clause allow for filtering by a specific student's first name.\",\n    \"1\": \"This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the query represent the gender of the students and the type of allergy they have.\",\n    \"2\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.\"\n}\n"}
{"sample_id": "train.524", "db_id": "allergy_1", "question": "What are the first name and gender of the students who have allergy to milk but can put up with cats?", "rationale": ["Identify the required fields: first name (Fname) and gender (Sex) of students.", "Filter students who have an allergy to milk. This requires a subquery on the Has_Allergy table to find StuIDs with 'milk'.", "Filter out students who have an allergy to cats. This requires another subquery on the Has_Allergy table to find StuIDs with 'cats'.", "Combine the results using the IN and NOT IN clauses to get the desired students' first names and genders."], "gold_sql": "SELECT fname ,  sex FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' EXCEPT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT Fname, Sex \nFROM Student \nWHERE StuID IN (\n    SELECT StuID \n    FROM Has_Allergy \n    WHERE Allergy = 'milk'\n) \nAND StuID NOT IN (\n    SELECT StuID \n    FROM Has_Allergy \n    WHERE Allergy = 'cats'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of allergies and their types for students based on their first name. The placeholders in the WHERE clause allow for filtering by a specific student's first name.\",\n    \"1\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.\",\n    \"2\": \"This virtual table provides the first names and majors of students from the 'Student' table who do not have a specific allergy. The placeholder in the subquery represents the name of the allergy that is being checked against the students' allergies.\"\n}\n"}
{"sample_id": "train.525", "db_id": "allergy_1", "question": "Find the average age of the students who have allergies with food and animal types.", "rationale": ["Identify the tables needed: We need to get student ages from the 'Student' table and filter based on allergies from the 'Has_Allergy' and 'Allergy_Type' tables.", "Join the tables: We will join 'Student' with 'Has_Allergy' on 'StuID' and then join 'Has_Allergy' with 'Allergy_Type' on 'Allergy' to access the allergy types.", "Filter the results: We need to filter the results to include only those students who have allergies categorized as 'food' or 'animal'.", "Calculate the average age: We will use the AVG() function to calculate the average age of the filtered students. We need to cast the 'Age' column to an integer for accurate calculation."], "gold_sql": "SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food' INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'animal')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT AVG(CAST(S.Age AS INTEGER)) AS Average_Age\nFROM Student S\nJOIN Has_Allergy HA ON S.StuID = HA.StuID\nJOIN Allergy_Type AT ON HA.Allergy = AT.Allergy\nWHERE AT.AllergyType IN ('food', 'animal');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.\",\n    \"1\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the allergy types to be excluded.\",\n    \"2\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the types of allergies to exclude.\"\n}\n"}
{"sample_id": "train.528", "db_id": "allergy_1", "question": "What is the full name of each student who is not allergic to any type of food.", "rationale": ["Identify the main goal: to find the full names of students who are not allergic to any type of food.", "To achieve this, we need to select the first and last names from the 'Student' table.", "We will use a subquery to filter out students who have any food allergies.", "The subquery will select 'StuID' from the 'Has_Allergy' table, joining it with the 'Allergy_Type' table to check for allergies of type 'Food'.", "The main query will then select the full name (concatenation of first and last names) of students whose 'StuID' is not in the list returned by the subquery."], "gold_sql": "SELECT fname ,  lname FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT Fname || ' ' || LName AS FullName \nFROM Student \nWHERE StuID NOT IN (\n    SELECT StuID \n    FROM Has_Allergy \n    JOIN Allergy_Type ON Has_Allergy.Allergy = Allergy_Type.Allergy \n    WHERE AllergyType = 'Food'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first names and majors of students from the 'Student' table who do not have a specific allergy. The placeholder in the subquery represents the name of the allergy that is being checked against the students' allergies.\",\n    \"1\": \"This virtual table provides a list of allergies and their types for students based on their first name. The placeholders in the WHERE clause allow for filtering by a specific student's first name.\",\n    \"2\": \"This virtual table provides the first and last names of students from the 'Student' table who do not have a specific type of allergy. The placeholder in the subquery represents the allergy type that is being filtered out.\"\n}\n"}
{"sample_id": "train.530", "db_id": "allergy_1", "question": "How many male students (sex is 'M') are allergic to any type of food?", "rationale": ["Identify the tables needed: Student, Has_Allergy, and Allergy_Type.", "We need to count male students, so we will filter the Student table by Sex = 'M'.", "We need to find students with allergies, so we will join the Has_Allergy table on StuID.", "We also need to filter for allergies that are of type 'Food', so we will join the Allergy_Type table on Allergy and filter by AllergyType = 'Food'.", "Finally, we will count the distinct StuID from the resulting joined tables to get the number of male students allergic to food."], "gold_sql": "SELECT count(*) FROM Student WHERE sex  =  'M' AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT COUNT(DISTINCT s.StuID) \nFROM Student s \nJOIN Has_Allergy ha ON s.StuID = ha.StuID \nJOIN Allergy_Type at ON ha.Allergy = at.Allergy \nWHERE s.Sex = 'M' AND at.AllergyType = 'Food';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the query represent the gender of the students and the type of allergy they have.\",\n    \"1\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.\",\n    \"2\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the allergy types to be excluded.\"\n}\n"}
{"sample_id": "train.531", "db_id": "allergy_1", "question": "Find the different first names and cities of the students who have allergy to milk or cat.", "rationale": ["Identify the tables needed: We need data from the Student and Has_Allergy tables.", "Determine the columns to select: We want distinct first names (Fname) and city codes (city_code) of students.", "Establish the relationship: Use a JOIN to connect the Student table with the Has_Allergy table on StuID.", "Filter the results: We need to include only those students who have allergies to either 'milk' or 'cat'.", "Construct the SQL query using the SELECT statement, JOIN, and WHERE clause."], "gold_sql": "SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  'Milk' OR T2.Allergy  =  'Cat'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT DISTINCT Student.Fname, Student.city_code \nFROM Student \nJOIN Has_Allergy ON Student.StuID = Has_Allergy.StuID \nWHERE Has_Allergy.Allergy IN ('milk', 'cat');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of allergies and their types for students based on their first name. The placeholders in the WHERE clause allow for filtering by a specific student's first name.\",\n    \"1\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.\",\n    \"2\": \"This virtual table provides the first names and majors of students from the 'Student' table who do not have a specific allergy. The placeholder in the subquery represents the name of the allergy that is being checked against the students' allergies.\"\n}\n"}
{"sample_id": "train.532", "db_id": "allergy_1", "question": "What are the distinct first names and cities of the students who have allergy either to milk or to cat?", "rationale": ["Identify the tables needed: We need information from the Student table for first names and city codes, and from the Has_Allergy table to check for allergies.", "Determine the relationship: The Has_Allergy table links students to their allergies via StuID, which is a foreign key in Has_Allergy referencing Student.", "Select distinct values: We want distinct first names and city codes, so we will use SELECT DISTINCT.", "Filter the allergies: We need to filter the results to include only those students who have allergies to either 'milk' or 'cat'. This is done using a WHERE clause with the IN operator."], "gold_sql": "SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  'Milk' OR T2.Allergy  =  'Cat'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT DISTINCT Student.Fname, Student.city_code \nFROM Student \nJOIN Has_Allergy ON Student.StuID = Has_Allergy.StuID \nWHERE Has_Allergy.Allergy IN ('milk', 'cat');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of allergies and their types for students based on their first name. The placeholders in the WHERE clause allow for filtering by a specific student's first name.\",\n    \"1\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.\",\n    \"2\": \"This virtual table provides the first names and majors of students from the 'Student' table who do not have a specific allergy. The placeholder in the subquery represents the name of the allergy that is being checked against the students' allergies.\"\n}\n"}
{"sample_id": "train.542", "db_id": "store_1", "question": "What are the names of the countries and average invoice size of the top countries by size?", "rationale": ["We need to find the names of the countries and the average invoice size for each country.", "To do this, we will select the 'billing_country' from the 'invoices' table and calculate the average of the 'total' column, which represents the invoice size.", "We will group the results by 'billing_country' to get the average invoice size for each country.", "Finally, we will order the results by the average invoice size in descending order to get the top countries by size."], "gold_sql": "SELECT billing_country ,  AVG(total) FROM invoices GROUP BY billing_country ORDER BY AVG(total) DESC LIMIT 10;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_country AS country, AVG(total) AS average_invoice_size\nFROM invoices\nGROUP BY billing_country\nORDER BY AVG(total) DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of invoices issued per state within a specific country. The placeholder in the WHERE clause represents the country's name, and the placeholder in the LIMIT clause specifies the maximum number of states to return, ordered by the count of invoices in descending order.\",\n    \"1\": \"This virtual table summarizes the total number of invoices and the total amount billed for a specific billing state from the 'invoices' table. The placeholder in the WHERE clause represents the billing state being queried.\"\n}\n"}
{"sample_id": "train.564", "db_id": "store_1", "question": "How many invoices were billed from each state?", "rationale": ["We need to count the number of invoices for each state.", "The relevant table for invoices is the 'invoices' table, which contains a column for 'billing_state'.", "We will use the COUNT() function to count the number of invoices for each state.", "To group the results by state, we will use the GROUP BY clause on 'billing_state'."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_state, COUNT(*) AS invoice_count \nFROM invoices \nGROUP BY billing_state;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of invoices and the total amount billed for a specific billing state from the 'invoices' table. The placeholder in the WHERE clause represents the billing state being queried.\",\n    \"1\": \"This virtual table summarizes the number of invoices issued per state within a specific country. The placeholder in the WHERE clause represents the country's name, and the placeholder in the LIMIT clause specifies the maximum number of states to return, ordered by the count of invoices in descending order.\"\n}\n"}
{"sample_id": "train.566", "db_id": "store_1", "question": "What are the states with the most invoices?", "rationale": ["Identify the relevant table: invoices, which contains billing information.", "We need to count the number of invoices per state, so we will use the COUNT() function.", "Group the results by billing_state to get the count for each state.", "Order the results in descending order to find the states with the most invoices."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT 1;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_state, COUNT(*) AS invoice_count \nFROM invoices \nGROUP BY billing_state \nORDER BY invoice_count DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of invoices issued per state within a specific country. The placeholder in the WHERE clause represents the country's name, and the placeholder in the LIMIT clause specifies the maximum number of states to return, ordered by the count of invoices in descending order.\",\n    \"1\": \"This virtual table summarizes the total number of invoices and the total amount billed for a specific billing state from the 'invoices' table. The placeholder in the WHERE clause represents the billing state being queried.\"\n}\n"}
{"sample_id": "train.568", "db_id": "store_1", "question": "What is the number of invoices and total money billed in them from CA?", "rationale": ["Identify the relevant table: The 'invoices' table contains the necessary information about invoices and their total amounts.", "Determine the required fields: We need to count the number of invoices and sum the total amount billed, which corresponds to the 'id' and 'total' columns in the 'invoices' table.", "Apply the filter: We need to filter the results to only include invoices from California (CA), which is done using a WHERE clause on the 'billing_state' column.", "Construct the SQL query: Combine the COUNT and SUM functions with the appropriate SELECT statement and WHERE clause to form the complete SQL query."], "gold_sql": "SELECT billing_state ,  COUNT(*) ,  SUM(total) FROM invoices WHERE billing_state  =  'CA';", "source_tables": ["invoices"], "pred_sql": "SELECT COUNT(*) AS number_of_invoices, SUM(total) AS total_billed FROM invoices WHERE billing_state = 'CA';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of invoices and the total amount billed for a specific billing state from the 'invoices' table. The placeholder in the WHERE clause represents the billing state being queried.\",\n    \"1\": \"This virtual table summarizes the number of invoices issued per state within a specific country. The placeholder in the WHERE clause represents the country's name, and the placeholder in the LIMIT clause specifies the maximum number of states to return, ordered by the count of invoices in descending order.\"\n}\n"}
{"sample_id": "train.575", "db_id": "store_1", "question": "What is Astrid Gruber's email and phone number?", "rationale": ["Identify the relevant table: The 'employees' table contains the information needed (email and phone number).", "Determine the specific employee: The query needs to filter for the employee with the first name 'Astrid' and last name 'Gruber'.", "Construct the SQL SELECT statement: Use SELECT to specify the columns 'email' and 'phone' from the 'employees' table.", "Add the WHERE clause: Filter the results to only include the row where first_name is 'Astrid' and last_name is 'Gruber'."], "gold_sql": "SELECT email ,  phone FROM customers WHERE first_name = 'Astrid' AND last_name = 'Gruber';", "source_tables": ["customers"], "pred_sql": "SELECT email, phone FROM employees WHERE first_name = 'Astrid' AND last_name = 'Gruber';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the titles, phone numbers, and hire dates of employees from the 'employees' table who have a specific first and last name. The placeholders in the WHERE clause represent the first and last names of the employee.\"\n}\n"}
{"sample_id": "train.580", "db_id": "store_1", "question": "How many customers are from California?", "rationale": ["Identify the relevant table: The 'customers' table contains information about customers, including their state of residence.", "Determine the specific condition: We need to count customers who are from California, which is specified in the 'state' column.", "Construct the SQL query: Use the COUNT function to count the number of customers where the state is 'California'."], "gold_sql": "SELECT count(*) FROM customers WHERE state = 'CA';", "source_tables": ["customers"], "pred_sql": "SELECT COUNT(*) AS customer_count FROM customers WHERE state = 'California';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of invoices issued per state within a specific country. The placeholder in the WHERE clause represents the country's name, and the placeholder in the LIMIT clause specifies the maximum number of states to return, ordered by the count of invoices in descending order.\"\n}\n"}
{"sample_id": "train.593", "db_id": "store_1", "question": "Find the full name of employee who supported the most number of customers.", "rationale": ["Identify the relevant tables: employees and customers.", "Join the employees table with the customers table on the support representative ID.", "Group the results by employee ID to count the number of customers each employee supports.", "Order the results by the count of customers in descending order to find the employee with the most customers.", "Limit the results to 1 to get only the top employee."], "gold_sql": "SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employees", "customers"], "pred_sql": "SELECT e.first_name || ' ' || e.last_name AS full_name\nFROM employees e\nJOIN customers c ON e.id = c.support_rep_id\nGROUP BY e.id\nORDER BY COUNT(c.id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees who serve as support representatives for customers. The results are grouped by the employee's unique identifier and ordered by the number of customers they support in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of employees to return.\",\n    \"1\": \"This virtual table provides a summary of employees and their managers from the 'employees' table. It lists the first and last names of managers along with the count of employees reporting to each manager. The results are grouped by the manager's identifier and ordered by the number of reports in descending order, with a limit on the number of results returned based on a specified number.\"\n}\n"}
{"sample_id": "train.608", "db_id": "store_1", "question": "How many orders does Luca Mancini have in his invoices?", "rationale": ["Identify the relevant tables: invoices and customers.", "Determine the relationship between invoices and customers: invoices have a customer_id that links to customers.id.", "Filter the customers table to find the specific customer 'Luca Mancini' using first_name and last_name.", "Count the number of invoices associated with this customer by using COUNT(*) and grouping by the customer."], "gold_sql": "SELECT count(*) FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id WHERE T1.first_name = 'Lucas' AND T1.last_name = 'Mancini';", "source_tables": ["customers", "invoices"], "pred_sql": "SELECT COUNT(*) AS order_count \nFROM invoices \nJOIN customers ON invoices.customer_id = customers.id \nWHERE customers.first_name = 'Luca' AND customers.last_name = 'Mancini';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of invoices issued per state within a specific country. The placeholder in the WHERE clause represents the country's name, and the placeholder in the LIMIT clause specifies the maximum number of states to return, ordered by the count of invoices in descending order.\",\n    \"1\": \"This virtual table summarizes the total number of invoices and the total amount billed for a specific billing state from the 'invoices' table. The placeholder in the WHERE clause represents the billing state being queried.\"\n}\n"}
{"sample_id": "train.623", "db_id": "store_1", "question": "What is title of album which track Balls to the Wall belongs to?", "rationale": ["Identify the tables involved: We need to find the album title for a specific track, so we will use the 'albums' and 'tracks' tables.", "Determine the relationship: The 'tracks' table has a foreign key 'album_id' that links to the 'albums' table's 'id'.", "Formulate the SQL query: We will select the 'title' from the 'albums' table where the 'id' matches the 'album_id' in the 'tracks' table for the track named 'Balls to the Wall'.", "Use a JOIN to connect the 'albums' and 'tracks' tables based on the album_id and id relationship."], "gold_sql": "SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T2.name = 'Balls to the Wall';", "source_tables": ["albums", "tracks"], "pred_sql": "SELECT albums.title \nFROM albums \nJOIN tracks ON albums.id = tracks.album_id \nWHERE tracks.name = 'Balls to the Wall';", "hint": "\n"}
{"sample_id": "train.626", "db_id": "store_1", "question": "What is the name of all tracks in the album named Balls to the Wall?", "rationale": ["Identify the relevant tables: tracks and albums.", "We need to find tracks that belong to a specific album, so we will join the tracks table with the albums table using the album_id foreign key.", "The condition for the join will be that the album's title matches 'Balls to the Wall'.", "Select the name of the tracks from the resulting joined table."], "gold_sql": "SELECT T2.name FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T1.title = 'Balls to the Wall';", "source_tables": ["albums", "tracks"], "pred_sql": "SELECT tracks.name \nFROM tracks \nJOIN albums ON tracks.album_id = albums.id \nWHERE albums.title = 'Balls to the Wall';", "hint": "\n"}
{"sample_id": "train.630", "db_id": "store_1", "question": "What are the names of all Rock tracks that are stored on MPEG audio files?", "rationale": ["Identify the relevant tables: tracks, media_types, and genres are needed to get track names, media type, and genre respectively.", "Join the tracks table with media_types on media_type_id to filter tracks based on their media type.", "Join the tracks table with genres on genre_id to filter tracks based on their genre.", "Use a WHERE clause to specify that we want tracks that are of the genre 'Rock' and are stored in 'MPEG audio' files."], "gold_sql": "SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = 'Rock' AND T3.name = 'MPEG audio file';", "source_tables": ["tracks", "genres", "media_types"], "pred_sql": "SELECT tracks.name \nFROM tracks \nJOIN media_types ON tracks.media_type_id = media_types.id \nJOIN genres ON tracks.genre_id = genres.id \nWHERE genres.name = 'Rock' AND media_types.name = 'MPEG audio';", "hint": "\n"}
{"sample_id": "train.632", "db_id": "store_1", "question": "What are the names of all tracks that belong to the Rock genre and whose media type is MPEG?", "rationale": ["Identify the tables involved: tracks, genres, and media_types.", "We need to select the track names from the tracks table.", "To filter tracks by genre, we join the genres table on the genre_id column of the tracks table.", "To filter tracks by media type, we join the media_types table on the media_type_id column of the tracks table.", "We apply the conditions to filter for the genre 'Rock' and media type 'MPEG'."], "gold_sql": "SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = 'Rock' OR T3.name = 'MPEG audio file';", "source_tables": ["tracks", "genres", "media_types"], "pred_sql": "SELECT tracks.name \nFROM tracks \nJOIN genres ON tracks.genre_id = genres.id \nJOIN media_types ON tracks.media_type_id = media_types.id \nWHERE genres.name = 'Rock' AND media_types.name = 'MPEG';", "hint": "\n"}
{"sample_id": "train.640", "db_id": "store_1", "question": "What are the tracks that Dean Peeters bought?", "rationale": ["Identify the relevant tables: tracks, invoice_lines, invoices, and customers are needed to find the tracks bought by a specific customer.", "Join the tables: We need to join tracks with invoice_lines to get the track details associated with each invoice line. Then, join invoice_lines with invoices to link the invoices to customers. Finally, join invoices with customers to filter by the specific customer.", "Filter by customer name: Use a WHERE clause to filter the results to only include tracks bought by the customer with the first name 'Dean' and last name 'Peeters'.", "Select the track names: The final output should only include the names of the tracks that match the criteria."], "gold_sql": "SELECT T1.name FROM tracks AS T1 JOIN invoice_lines AS T2 ON T1.id = T2.track_id JOIN invoices AS T3 ON T3.id = T2.invoice_id JOIN customers AS T4 ON T4.id = T3.customer_id WHERE T4.first_name = 'Daan' AND T4.last_name = 'Peeters';", "source_tables": ["tracks", "invoice_lines", "customers", "invoices"], "pred_sql": "SELECT tracks.name \nFROM tracks \nJOIN invoice_lines ON tracks.id = invoice_lines.track_id \nJOIN invoices ON invoice_lines.invoice_id = invoices.id \nJOIN customers ON invoices.customer_id = customers.id \nWHERE customers.first_name = 'Dean' AND customers.last_name = 'Peeters';", "hint": "\n"}
{"sample_id": "train.686", "db_id": "customers_card_transactions", "question": "What are the full names of customers who do not have any accounts?", "rationale": ["Identify the tables involved: Customers and Accounts.", "We need to find customers who do not have any accounts, which means we need to look for customer IDs in the Customers table that are not present in the Accounts table.", "Use a subquery to select customer_ids from the Accounts table.", "Use the NOT IN clause to filter out those customer_ids from the Customers table.", "Select the full names by concatenating the first and last names from the Customers table."], "gold_sql": "SELECT customer_first_name ,  customer_last_name FROM Customers EXCEPT SELECT T1.customer_first_name ,  T1.customer_last_name FROM Customers AS T1 JOIN Accounts AS T2 ON T1.customer_id  =  T2.customer_id", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT customer_first_name || ' ' || customer_last_name AS full_name\nFROM Customers\nWHERE customer_id NOT IN (\n    SELECT customer_id\n    FROM Accounts\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of customer first and last names along with their associated customer IDs from the 'Accounts' and 'Customers' tables. The data is grouped by customer ID and ordered by the count of accounts associated with each customer in ascending order, with a limit on the number of results returned as specified by the placeholder.\",\n    \"1\": \"This virtual table provides a list of customer IDs and their first names from the 'Customers' table, excluding those customers who have a specific type of card. The placeholder in the EXCEPT clause represents the card type code that is used to filter out customers who possess that card type.\",\n    \"2\": \"This virtual table provides a list of customer IDs and their first names from the 'Customers' table, excluding those customers who have a specific type of card. The placeholder in the EXCEPT clause represents the card type code that is used to filter out customers who possess that card type.\"\n}\n"}
{"sample_id": "train.688", "db_id": "customers_card_transactions", "question": "What are the full names of customers who have accounts?", "rationale": ["Identify the tables involved: Customers and Accounts.", "Determine the relationship between the tables: Customers are linked to Accounts via customer_id.", "Select the relevant columns: customer_first_name and customer_last_name from Customers.", "Use a JOIN clause to combine the Customers and Accounts tables based on the customer_id.", "Construct the SQL query to retrieve the full names of customers who have accounts."], "gold_sql": "SELECT DISTINCT T1.customer_first_name ,  T1.customer_last_name FROM Customers AS T1 JOIN Accounts AS T2 ON T1.customer_id  =  T2.customer_id", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT c.customer_first_name, c.customer_last_name\nFROM Customers c\nJOIN Accounts a ON c.customer_id = a.customer_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of customer first and last names along with their associated customer IDs from the 'Accounts' and 'Customers' tables. The data is grouped by customer ID and ordered by the count of accounts associated with each customer in ascending order, with a limit on the number of results returned as specified by the placeholder.\",\n    \"1\": \"This virtual table provides a list of customer IDs along with their first and last names from the 'Customers' table, specifically for customers who have a certain number of cards associated with them. The placeholder in the HAVING clause represents the minimum count of cards a customer must have to be included in the results.\",\n    \"2\": \"This virtual table provides a list of customer IDs and their first names from the 'Customers' table, excluding those customers who have a specific type of card. The placeholder in the EXCEPT clause represents the card type code that is used to filter out customers who possess that card type.\"\n}\n"}
{"sample_id": "train.704", "db_id": "customers_card_transactions", "question": "Return the full name and phone of the customer who has card number 4560596484842.", "rationale": ["Identify the tables needed: We need to retrieve customer information, which is in the 'Customers' table, and we need to link it to the 'Customers_Cards' table to filter by card number.", "Determine the columns to select: We need the customer's first name, last name, and phone number, which are in the 'Customers' table.", "Establish the relationship between tables: We will join 'Customers' and 'Customers_Cards' on 'customer_id' to link customers to their cards.", "Add the filter condition: We need to filter the results to only include the customer with the specified card number '4560596484842'.", "Construct the SQL query using the SELECT statement, JOIN clause, and WHERE condition."], "gold_sql": "SELECT T2.customer_first_name ,  T2.customer_last_name ,  T2.customer_phone FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T1.card_number  =  '4560596484842'", "source_tables": ["customers", "customers_cards"], "pred_sql": "SELECT c.customer_first_name, c.customer_last_name, c.customer_phone \nFROM Customers c \nJOIN Customers_Cards cc ON c.customer_id = cc.customer_id \nWHERE cc.card_number = '4560596484842';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of customer first and last names along with their associated customer IDs from the 'Accounts' and 'Customers' tables. The data is grouped by customer ID and ordered by the count of accounts associated with each customer in ascending order, with a limit on the number of results returned as specified by the placeholder.\",\n    \"1\": \"This virtual table provides a list of customer IDs along with their first and last names from the 'Customers' table, specifically for customers who have a certain number of cards associated with them. The placeholder in the HAVING clause represents the minimum count of cards a customer must have to be included in the results.\",\n    \"2\": \"This virtual table provides a list of customer IDs and their first names from the 'Customers' table, excluding those customers who have a specific type of card. The placeholder in the EXCEPT clause represents the card type code that is used to filter out customers who possess that card type.\"\n}\n"}
{"sample_id": "train.717", "db_id": "customers_card_transactions", "question": "What is the customer id, first and last name with least number of accounts.", "rationale": ["Identify the relevant tables: Customers and Accounts.", "Join the Customers table with the Accounts table on the customer_id field to link customers with their accounts.", "Group the results by customer_id, customer_first_name, and customer_last_name to aggregate the account counts for each customer.", "Use COUNT(a.account_id) to count the number of accounts associated with each customer.", "Order the results in ascending order based on the count of accounts to find the customer with the least number of accounts.", "Limit the results to 1 to get only the customer with the least number of accounts."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) ASC LIMIT 1", "source_tables": ["customers", "customers_cards"], "pred_sql": "SELECT c.customer_id, c.customer_first_name, c.customer_last_name \nFROM Customers c \nJOIN Accounts a ON c.customer_id = a.customer_id \nGROUP BY c.customer_id, c.customer_first_name, c.customer_last_name \nORDER BY COUNT(a.account_id) ASC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of customer first and last names along with their associated customer IDs from the 'Accounts' and 'Customers' tables. The data is grouped by customer ID and ordered by the count of accounts associated with each customer in ascending order, with a limit on the number of results returned as specified by the placeholder.\",\n    \"1\": \"This virtual table provides a list of customer IDs along with their first and last names from the 'Customers' table, specifically for customers who have a certain number of cards associated with them. The placeholder in the HAVING clause represents the minimum count of cards a customer must have to be included in the results.\",\n    \"2\": \"This virtual table provides a list of customer IDs and their first names from the 'Customers' table, excluding those customers who have a specific type of card. The placeholder in the EXCEPT clause represents the card type code that is used to filter out customers who possess that card type.\"\n}\n"}
{"sample_id": "train.718", "db_id": "customers_card_transactions", "question": "Return the id and full name of the customer who has the fewest accounts.", "rationale": ["Identify the tables involved: Customers and Accounts.", "We need to retrieve customer information, specifically the customer ID and full name (first and last name).", "Join the Customers table with the Accounts table on the customer_id to link customers with their accounts.", "Group the results by customer_id to count the number of accounts each customer has.", "Order the results by the count of accounts in ascending order to find the customer with the fewest accounts.", "Limit the results to 1 to get only the customer with the fewest accounts."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) ASC LIMIT 1", "source_tables": ["customers", "customers_cards"], "pred_sql": "SELECT c.customer_id, c.customer_first_name || ' ' || c.customer_last_name AS full_name\nFROM Customers c\nJOIN Accounts a ON c.customer_id = a.customer_id\nGROUP BY c.customer_id\nORDER BY COUNT(a.account_id) ASC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of customer first and last names along with their associated customer IDs from the 'Accounts' and 'Customers' tables. The data is grouped by customer ID and ordered by the count of accounts associated with each customer in ascending order, with a limit on the number of results returned as specified by the placeholder.\",\n    \"1\": \"This virtual table provides a list of customer IDs along with their first and last names from the 'Customers' table, specifically for customers who have a certain number of cards associated with them. The placeholder in the HAVING clause represents the minimum count of cards a customer must have to be included in the results.\",\n    \"2\": \"This virtual table provides a list of customer IDs and their first names from the 'Customers' table, excluding those customers who have a specific type of card. The placeholder in the EXCEPT clause represents the card type code that is used to filter out customers who possess that card type.\"\n}\n"}
{"sample_id": "train.721", "db_id": "customers_card_transactions", "question": "What is the card type code with most number of cards?", "rationale": ["Identify the relevant table: Customers_Cards contains the card_type_code and card_id.", "Count the number of cards for each card_type_code using COUNT(card_id).", "Group the results by card_type_code to aggregate the counts.", "Order the results in descending order to get the card type with the most cards at the top.", "Limit the results to 1 to get only the card type code with the highest count."], "gold_sql": "SELECT card_type_code FROM Customers_cards GROUP BY card_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers_cards"], "pred_sql": "SELECT card_type_code, COUNT(card_id) AS card_count \nFROM Customers_Cards \nGROUP BY card_type_code \nORDER BY card_count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of customer IDs along with their first and last names from the 'Customers' table, specifically for customers who have a certain number of cards associated with them. The placeholder in the HAVING clause represents the minimum count of cards a customer must have to be included in the results.\"\n}\n"}
{"sample_id": "train.735", "db_id": "customers_card_transactions", "question": "Show the number of transaction types.", "rationale": ["Identify the table that contains transaction types, which is the Financial_Transactions table.", "To count the number of each transaction type, we need to use the COUNT() function.", "We will group the results by transaction_type to get the count for each type.", "The final SQL query will select the transaction_type and the count of transactions for each type."], "gold_sql": "SELECT count(DISTINCT transaction_type) FROM Financial_Transactions", "source_tables": ["financial_transactions"], "pred_sql": "SELECT transaction_type, COUNT(*) AS transaction_count \nFROM Financial_Transactions \nGROUP BY transaction_type;", "hint": "\n"}
{"sample_id": "train.743", "db_id": "customers_card_transactions", "question": "What is the transaction type that has processed the greatest total amount in transactions?", "rationale": ["Identify the relevant table: Financial_Transactions contains the transaction details including type and amount.", "We need to group the transactions by their type to calculate the total amount for each type.", "Use the SUM function to calculate the total amount for each transaction type.", "Order the results in descending order to find the transaction type with the greatest total amount.", "Limit the results to 1 to get only the top transaction type."], "gold_sql": "SELECT transaction_type FROM Financial_transactions GROUP BY transaction_type ORDER BY sum(transaction_amount) DESC LIMIT 1", "source_tables": ["financial_transactions"], "pred_sql": "SELECT transaction_type, SUM(transaction_amount) AS total_amount\nFROM Financial_Transactions\nGROUP BY transaction_type\nORDER BY total_amount DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.893", "db_id": "insurance_fnol", "question": "What are the customer phone numbers under the policy \"Life Insurance\"?", "rationale": ["Identify the relevant tables: Available_Policies, Customers_Policies, and Services are needed to find customer phone numbers related to a specific policy.", "Join the Available_Policies table with the Customers_Policies table on Policy_ID to link policies to customers.", "Join the Services table to filter the policies by the service name 'Life Insurance'.", "Select the distinct Customer_Phone from the resulting joined tables to avoid duplicates."], "gold_sql": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  'Life Insurance'", "source_tables": ["available_policies"], "pred_sql": "SELECT DISTINCT ap.Customer_Phone \nFROM Available_Policies ap \nJOIN Customers_Policies cp ON ap.Policy_ID = cp.Policy_ID \nJOIN Services s ON s.Service_ID = ap.Policy_ID \nWHERE s.Service_name = 'Life Insurance';", "hint": "\n"}
{"sample_id": "train.895", "db_id": "insurance_fnol", "question": "Which policy type has the most records in the database?", "rationale": ["We need to find out which policy type has the most records in the database.", "To do this, we will count the number of occurrences of each policy type in the 'Available_Policies' table.", "We will join the 'Available_Policies' table with the 'Customers_Policies' table on the 'Policy_ID' to get the relevant records.", "We will group the results by 'policy_type_code' to aggregate the counts for each policy type.", "We will order the results in descending order based on the count of policies to get the most common policy type at the top.", "Finally, we will limit the results to 1 to get only the policy type with the highest count."], "gold_sql": "SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["available_policies"], "pred_sql": "SELECT policy_type_code, COUNT(*) as policy_count \nFROM Available_Policies \nJOIN Customers_Policies ON Available_Policies.Policy_ID = Customers_Policies.Policy_ID \nGROUP BY policy_type_code \nORDER BY policy_count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the unique policy types from the 'Available_Policies' table that have been issued more than a specified number of times. The placeholder in the HAVING clause represents the minimum count of policies required to be included in the results.\",\n    \"1\": \"This virtual table provides a list of unique policy types from the 'Available_Policies' table that have been issued more than a specified number of times. The placeholder in the HAVING clause represents the minimum count of policies required to be included in the results.\"\n}\n"}
{"sample_id": "train.897", "db_id": "insurance_fnol", "question": "What are all the customer phone numbers under the most popular policy type?", "rationale": ["Identify the relevant tables: We need to access customer phone numbers and policy types, so we will use the Customers, Available_Policies, and Customers_Policies tables.", "Determine the most popular policy type: We need to find the policy type that has been issued the most. This can be done by grouping the Available_Policies table by policy_type_code and counting the occurrences.", "Use a subquery to find the maximum count of policies: We will create a subquery that counts the number of policies for each type and then selects the maximum count.", "Filter the main query by the most popular policy type: We will use the result of the subquery to filter the main query to only include customers with the most popular policy type.", "Select distinct customer phone numbers: Finally, we will select distinct customer phone numbers from the result set to avoid duplicates."], "gold_sql": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  (SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["available_policies"], "pred_sql": "SELECT DISTINCT ap.Customer_Phone \nFROM Available_Policies ap \nJOIN Customers_Policies cp ON ap.Policy_ID = cp.Policy_ID \nJOIN Customers c ON cp.Customer_ID = c.Customer_ID \nWHERE ap.policy_type_code = (\n    SELECT policy_type_code \n    FROM Available_Policies \n    GROUP BY policy_type_code \n    HAVING COUNT(*) = (\n        SELECT MAX(policy_count) \n        FROM (\n            SELECT COUNT(*) AS policy_count \n            FROM Available_Policies \n            GROUP BY policy_type_code\n        )\n    )\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the unique policy types from the 'Available_Policies' table that have been issued more than a specified number of times. The placeholder in the HAVING clause represents the minimum count of policies required to be included in the results.\",\n    \"1\": \"This virtual table provides a list of unique policy types from the 'Available_Policies' table that have been issued more than a specified number of times. The placeholder in the HAVING clause represents the minimum count of policies required to be included in the results.\"\n}\n"}
{"sample_id": "train.898", "db_id": "insurance_fnol", "question": "Find the phone numbers of customers using the most common policy type among the available policies.", "rationale": ["Identify the relevant tables: We need to find customer phone numbers and the policy types they are using, so we will work with the Customers, Available_Policies, and Customers_Policies tables.", "Join the tables: We will join the Customers_Policies table with the Available_Policies table to link customers with their policies, and then join with the Customers table to get the customer phone numbers.", "Determine the most common policy type: We will create a subquery that counts the occurrences of each policy type in the Available_Policies table and identifies the maximum count.", "Filter the results: We will filter the main query to only include customers whose policy type matches the most common policy type identified in the subquery."], "gold_sql": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  (SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["available_policies"], "pred_sql": "SELECT DISTINCT ap.Customer_Phone\nFROM Available_Policies ap\nJOIN Customers_Policies cp ON ap.Policy_ID = cp.Policy_ID\nJOIN Customers c ON cp.Customer_ID = c.Customer_ID\nWHERE ap.policy_type_code = (\n    SELECT policy_type_code\n    FROM Available_Policies\n    GROUP BY policy_type_code\n    HAVING COUNT(*) = (\n        SELECT MAX(policy_count)\n        FROM (\n            SELECT COUNT(*) AS policy_count\n            FROM Available_Policies\n            GROUP BY policy_type_code\n        )\n    )\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the unique policy types from the 'Available_Policies' table that have been issued more than a specified number of times. The placeholder in the HAVING clause represents the minimum count of policies required to be included in the results.\",\n    \"1\": \"This virtual table provides a list of unique policy types from the 'Available_Policies' table that have been issued more than a specified number of times. The placeholder in the HAVING clause represents the minimum count of policies required to be included in the results.\"\n}\n"}
{"sample_id": "train.1060", "db_id": "match_season", "question": "Show the players from college UCLA.", "rationale": ["Identify the relevant tables: We need to retrieve player information, so we will use the 'player' table.", "Determine the condition: We want players from the college 'UCLA'.", "Join the 'player' table with the 'match_season' table on the 'Team' column to ensure we can filter by college.", "Use a SELECT statement to get distinct player names from the joined tables where the college is 'UCLA'."], "gold_sql": "SELECT Player FROM match_season WHERE College  =  'UCLA'", "source_tables": ["match_season"], "pred_sql": "SELECT DISTINCT p.Player \nFROM player p \nJOIN match_season ms ON p.Team = ms.Team \nWHERE ms.College = 'UCLA';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the colleges attended by players who play in two specified positions during the match season. The placeholders in the WHERE clause represent the positions of the players being compared.\"\n}\n"}
{"sample_id": "train.1082", "db_id": "match_season", "question": "Show the season, the player, and the name of the team that players belong to.", "rationale": ["Identify the columns needed: Season, Player, and Team Name.", "The Season and Player are from the match_season table.", "The Team Name is from the team table.", "To get the Team Name, we need to join the match_season table with the team table on the Team identifier.", "Construct the SQL SELECT statement to retrieve the required columns from the joined tables."], "gold_sql": "SELECT T1.Season ,  T1.Player ,  T2.Name FROM match_season AS T1 JOIN team AS T2 ON T1.Team  =  T2.Team_id", "source_tables": ["team", "match_season"], "pred_sql": "SELECT match_season.Season, match_season.Player, team.Name \nFROM match_season \nJOIN team ON match_season.Team = team.Team_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides information about the draft pick number and draft class of players from the 'match_season' table who play in a specific position. The placeholder in the WHERE clause represents the position of the player.\"\n}\n"}
{"sample_id": "train.1092", "db_id": "match_season", "question": "Show the country names and the corresponding number of players.", "rationale": ["Identify the tables needed: 'country' for country names and 'match_season' for player participation.", "Join the 'country' table with the 'match_season' table on the country identifier to link players to their respective countries.", "Use the COUNT function to count the number of players from each country in the match_season table.", "Group the results by country name to get the count of players for each country."], "gold_sql": "SELECT Country_name ,  COUNT(*) FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country GROUP BY T1.Country_name", "source_tables": ["country", "match_season"], "pred_sql": "SELECT country.Country_name, COUNT(match_season.Player) AS Number_of_Players\nFROM country\nJOIN match_season ON country.Country_id = match_season.Country\nGROUP BY country.Country_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the names of countries represented by players who occupy a specific position in matches. It uses an intersection to find countries where players in that position are participating in matches, ensuring that only countries with players in that position are returned. The placeholders in the query represent the position of the players being filtered.\",\n    \"1\": \"This virtual table provides a count of matches played by players from each country, by joining the 'country' table with the 'match_season' table. The placeholder in the SELECT clause represents the country names, and the COUNT function aggregates the number of matches for each country.\"\n}\n"}
{"sample_id": "train.1098", "db_id": "match_season", "question": "Show the top 3 most common colleges of players in match seasons.", "rationale": ["Identify the relevant table: The 'match_season' table contains information about players and their colleges.", "We need to count the occurrences of each college, so we will use the COUNT() function.", "To get the most common colleges, we will group the results by the 'College' column.", "We will order the results in descending order based on the count of players from each college.", "Finally, we will limit the results to the top 3 colleges."], "gold_sql": "SELECT College FROM match_season GROUP BY College ORDER BY count(*) DESC LIMIT 3", "source_tables": ["match_season"], "pred_sql": "SELECT College, COUNT(*) as College_Count \nFROM match_season \nGROUP BY College \nORDER BY College_Count DESC \nLIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the colleges attended by players who play in two specified positions during the match season. The placeholders in the WHERE clause represent the positions of the players being compared.\"\n}\n"}
{"sample_id": "train.1099", "db_id": "match_season", "question": "What are the three colleges from which the most players are from?", "rationale": ["Identify the relevant table: The 'match_season' table contains information about players and their colleges.", "We need to count the number of players from each college, so we will use the COUNT() function.", "Group the results by 'College' to aggregate the player counts for each college.", "Order the results in descending order based on the player count to get the colleges with the most players at the top.", "Limit the results to the top three colleges using LIMIT 3."], "gold_sql": "SELECT College FROM match_season GROUP BY College ORDER BY count(*) DESC LIMIT 3", "source_tables": ["match_season"], "pred_sql": "SELECT College, COUNT(*) as Player_Count\nFROM match_season\nGROUP BY College\nORDER BY Player_Count DESC\nLIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the colleges attended by players who play in two specified positions during the match season. The placeholders in the WHERE clause represent the positions of the players being compared.\"\n}\n"}
{"sample_id": "train.1107", "db_id": "match_season", "question": "Return the names of countries that have players that play the Forward position, as well as players who play the Defender position.", "rationale": ["Identify the relevant tables: We need to retrieve country names, so we will use the 'country' table.", "We need to find players who play in specific positions (Forward and Defender), which is found in the 'match_season' table.", "Join the 'country' table with the 'match_season' table on the country identifier to link players to their respective countries.", "Use a WHERE clause to filter the results to only include players in the Forward and Defender positions.", "Select distinct country names to avoid duplicates in the results."], "gold_sql": "SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  'Forward' INTERSECT SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  'Defender'", "source_tables": ["country", "match_season"], "pred_sql": "SELECT DISTINCT c.Country_name \nFROM country c \nJOIN match_season ms ON c.Country_id = ms.Country \nWHERE ms.Position IN ('Forward', 'Defender');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the names of countries represented by players who occupy a specific position in matches. It uses an intersection to find countries where players in that position are participating in matches, ensuring that only countries with players in that position are returned. The placeholders in the query represent the position of the players being filtered.\",\n    \"1\": \"This virtual table retrieves the colleges attended by players who play in two specified positions during the match season. The placeholders in the WHERE clause represent the positions of the players being compared.\"\n}\n"}
{"sample_id": "train.1109", "db_id": "match_season", "question": "Return the colleges that have players who play the Midfielder position, as well as players who play the Defender position.", "rationale": ["Identify the relevant table: The 'match_season' table contains information about players, including their positions and the colleges they attended.", "Determine the required positions: We need to filter players who play as 'Midfielder' or 'Defender'.", "Use the DISTINCT keyword: Since we want unique colleges, we will use DISTINCT to avoid duplicate entries in the result.", "Construct the SQL query: The query selects the 'College' column from the 'match_season' table where the 'Position' is either 'Midfielder' or 'Defender'."], "gold_sql": "SELECT College FROM match_season WHERE POSITION  =  'Midfielder' INTERSECT SELECT College FROM match_season WHERE POSITION  =  'Defender'", "source_tables": ["match_season"], "pred_sql": "SELECT DISTINCT College \nFROM match_season \nWHERE Position IN ('Midfielder', 'Defender');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the colleges attended by players who play in two specified positions during the match season. The placeholders in the WHERE clause represent the positions of the players being compared.\",\n    \"1\": \"This virtual table identifies the names of countries represented by players who occupy a specific position in matches. It uses an intersection to find countries where players in that position are participating in matches, ensuring that only countries with players in that position are returned. The placeholders in the query represent the position of the players being filtered.\",\n    \"2\": \"This virtual table provides information about the draft pick number and draft class of players from the 'match_season' table who play in a specific position. The placeholder in the WHERE clause represents the position of the player.\"\n}\n"}
{"sample_id": "train.1222", "db_id": "apartment_rentals", "question": "What are the booking start and end dates of the apartments with type code \"Duplex\"?", "rationale": ["Identify the relevant tables: Apartments and Apartment_Bookings are needed to get the apartment type and booking dates.", "Join the Apartments table with the Apartment_Bookings table on the apt_id to link apartments with their bookings.", "Filter the results to only include apartments with the type code 'Duplex'.", "Select the booking start and end dates from the joined tables."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.apt_type_code  =  'Duplex'", "source_tables": ["apartment_bookings", "apartments"], "pred_sql": "SELECT ab.booking_start_date, ab.booking_end_date \nFROM Apartments a \nJOIN Apartment_Bookings ab ON a.apt_id = ab.apt_id \nWHERE a.apt_type_code = 'Duplex';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the types of apartments available in the 'Apartments' table, displaying the apartment type code along with the count of bathrooms and bedrooms. The results are grouped by apartment type and ordered by the total number of rooms in descending order, with a limit on the number of results returned based on a specified numeric value.\",\n    \"1\": \"This virtual table provides a summary of the types of apartments available in the 'Apartments' table that have a specified number of bathrooms. The results are grouped by the apartment type code and ordered by the count of apartments in each type, allowing users to see which types are most common based on the bathroom count. The placeholders in the WHERE clause and LIMIT clause represent the minimum number of bathrooms and the maximum number of results to return, respectively.\"\n}\n"}
{"sample_id": "train.1224", "db_id": "apartment_rentals", "question": "What are the booking start and end dates of the apartments with more than 2 bedrooms?", "rationale": ["Identify the relevant tables: Apartment_Bookings for booking dates and Apartments for bedroom count.", "We need to select the booking start and end dates, which are in the Apartment_Bookings table.", "To filter apartments with more than 2 bedrooms, we will join the Apartments table on the apt_id from Apartment_Bookings and apply a WHERE clause to check for bedroom_count > 2."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  2", "source_tables": ["apartment_bookings", "apartments"], "pred_sql": "SELECT ab.booking_start_date, ab.booking_end_date \nFROM Apartment_Bookings ab \nJOIN Apartments a ON ab.apt_id = a.apt_id \nWHERE a.bedroom_count > 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the types of apartments available in the 'Apartments' table, displaying the apartment type code along with the count of bathrooms and bedrooms. The results are grouped by apartment type and ordered by the total number of rooms in descending order, with a limit on the number of results returned based on a specified numeric value.\",\n    \"1\": \"This virtual table provides a summary of the types of apartments available in the 'Apartments' table that have a specified number of bathrooms. The results are grouped by the apartment type code and ordered by the count of apartments in each type, allowing users to see which types are most common based on the bathroom count. The placeholders in the WHERE clause and LIMIT clause represent the minimum number of bathrooms and the maximum number of results to return, respectively.\"\n}\n"}
{"sample_id": "train.1225", "db_id": "apartment_rentals", "question": "Find the booking start date and end date for the apartments that have more than two bedrooms.", "rationale": ["Identify the relevant tables: Apartment_Bookings for booking dates and Apartments for bedroom count.", "Determine the columns needed: booking_start_date and booking_end_date from Apartment_Bookings.", "Filter the apartments based on the condition of having more than two bedrooms, which is found in the Apartments table.", "Join the Apartment_Bookings table with the Apartments table on the apt_id to correlate bookings with their respective apartments.", "Construct the SQL query to select the required columns with the appropriate join and where clause."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  2", "source_tables": ["apartment_bookings", "apartments"], "pred_sql": "SELECT ab.booking_start_date, ab.booking_end_date \nFROM Apartment_Bookings ab \nJOIN Apartments a ON ab.apt_id = a.apt_id \nWHERE a.bedroom_count > 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the types of apartments available in the 'Apartments' table, displaying the apartment type code along with the count of bathrooms and bedrooms. The results are grouped by apartment type and ordered by the total number of rooms in descending order, with a limit on the number of results returned based on a specified numeric value.\",\n    \"1\": \"This virtual table provides a summary of the types of apartments available in the 'Apartments' table that have a specified number of bathrooms. The results are grouped by the apartment type code and ordered by the count of apartments in each type, allowing users to see which types are most common based on the bathroom count. The placeholders in the WHERE clause and LIMIT clause represent the minimum number of bathrooms and the maximum number of results to return, respectively.\"\n}\n"}
{"sample_id": "train.1229", "db_id": "apartment_rentals", "question": "Which apartments have bookings with status code \"Confirmed\"? Return their apartment numbers.", "rationale": ["Identify the relevant tables: Apartments and Apartment_Bookings are needed to find apartments with confirmed bookings.", "Join the Apartments table with the Apartment_Bookings table on the apt_id to link apartments with their bookings.", "Filter the results to include only those bookings where the booking_status_code is 'Confirmed'.", "Select the apt_number from the filtered results to return the apartment numbers that meet the criteria."], "gold_sql": "SELECT DISTINCT T2.apt_number FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T1.booking_status_code  =  'Confirmed'", "source_tables": ["apartment_bookings", "apartments"], "pred_sql": "SELECT a.apt_number \nFROM Apartments a \nJOIN Apartment_Bookings ab ON a.apt_id = ab.apt_id \nWHERE ab.booking_status_code = 'Confirmed';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the types of apartments available in the 'Apartments' table, displaying the apartment type code along with the count of bathrooms and bedrooms. The results are grouped by apartment type and ordered by the total number of rooms in descending order, with a limit on the number of results returned based on a specified numeric value.\",\n    \"1\": \"This virtual table provides a summary of the types of apartments available in the 'Apartments' table that have a specified number of bathrooms. The results are grouped by the apartment type code and ordered by the count of apartments in each type, allowing users to see which types are most common based on the bathroom count. The placeholders in the WHERE clause and LIMIT clause represent the minimum number of bathrooms and the maximum number of results to return, respectively.\"\n}\n"}
{"sample_id": "train.1232", "db_id": "apartment_rentals", "question": "Show the guest first names, start dates, and end dates of all the apartment bookings.", "rationale": ["Identify the required fields: guest first names, booking start dates, and booking end dates.", "Determine the relevant tables: Guests for guest information and Apartment_Bookings for booking details.", "Establish the relationship between the tables: Apartment_Bookings is linked to Guests through guest_id.", "Construct the SQL SELECT statement to retrieve the desired fields from the joined tables."], "gold_sql": "SELECT T2.guest_first_name ,  T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id", "source_tables": ["apartment_bookings", "guests"], "pred_sql": "SELECT Guests.guest_first_name, Apartment_Bookings.booking_start_date, Apartment_Bookings.booking_end_date\nFROM Apartment_Bookings\nJOIN Guests ON Apartment_Bookings.guest_id = Guests.guest_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the types of apartments available in the 'Apartments' table, displaying the apartment type code along with the count of bathrooms and bedrooms. The results are grouped by apartment type and ordered by the total number of rooms in descending order, with a limit on the number of results returned based on a specified numeric value.\",\n    \"1\": \"This virtual table provides a summary of the types of apartments available in the 'Apartments' table that have a specified number of bathrooms. The results are grouped by the apartment type code and ordered by the count of apartments in each type, allowing users to see which types are most common based on the bathroom count. The placeholders in the WHERE clause and LIMIT clause represent the minimum number of bathrooms and the maximum number of results to return, respectively.\"\n}\n"}
{"sample_id": "train.1234", "db_id": "apartment_rentals", "question": "Show the start dates and end dates of all the apartment bookings made by guests with gender code \"Female\".", "rationale": ["Identify the relevant tables: Apartment_Bookings for booking dates and Guests for gender information.", "Determine the columns needed: booking_start_date and booking_end_date from Apartment_Bookings.", "Establish the relationship between tables: Join Apartment_Bookings with Guests on guest_id.", "Filter the results to include only those bookings made by guests with gender code 'Female'."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id WHERE T2.gender_code  =  'Female'", "source_tables": ["apartment_bookings", "guests"], "pred_sql": "SELECT Apartment_Bookings.booking_start_date, Apartment_Bookings.booking_end_date \nFROM Apartment_Bookings \nJOIN Guests ON Apartment_Bookings.guest_id = Guests.guest_id \nWHERE Guests.gender_code = 'Female';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the types of apartments available in the 'Apartments' table, displaying the apartment type code along with the count of bathrooms and bedrooms. The results are grouped by apartment type and ordered by the total number of rooms in descending order, with a limit on the number of results returned based on a specified numeric value.\",\n    \"1\": \"This virtual table provides a summary of the types of apartments available in the 'Apartments' table that have a specified number of bathrooms. The results are grouped by the apartment type code and ordered by the count of apartments in each type, allowing users to see which types are most common based on the bathroom count. The placeholders in the WHERE clause and LIMIT clause represent the minimum number of bathrooms and the maximum number of results to return, respectively.\"\n}\n"}
{"sample_id": "train.1238", "db_id": "apartment_rentals", "question": "Show the facility codes of apartments with more than 4 bedrooms.", "rationale": ["Identify the relevant tables: We need to retrieve facility codes from the Apartment_Facilities table and filter apartments based on the number of bedrooms from the Apartments table.", "Join the tables: We will join the Apartment_Facilities table with the Apartments table using the apt_id to link them together.", "Apply the filter: We need to filter the apartments to only include those with more than 4 bedrooms, which is done using a WHERE clause.", "Select distinct facility codes: Since we only want the unique facility codes, we will use SELECT DISTINCT to avoid duplicates."], "gold_sql": "SELECT T1.facility_code FROM Apartment_Facilities AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  4", "source_tables": ["apartments", "apartment_facilities"], "pred_sql": "SELECT DISTINCT af.facility_code \nFROM Apartment_Facilities af \nJOIN Apartments a ON af.apt_id = a.apt_id \nWHERE a.bedroom_count > 4;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the types of apartments available in the 'Apartments' table, displaying the apartment type code along with the count of bathrooms and bedrooms. The results are grouped by apartment type and ordered by the total number of rooms in descending order, with a limit on the number of results returned based on a specified numeric value.\",\n    \"1\": \"This virtual table provides a summary of the types of apartments available in the 'Apartments' table that have a specified number of bathrooms. The results are grouped by the apartment type code and ordered by the count of apartments in each type, allowing users to see which types are most common based on the bathroom count. The placeholders in the WHERE clause and LIMIT clause represent the minimum number of bathrooms and the maximum number of results to return, respectively.\"\n}\n"}
{"sample_id": "train.1256", "db_id": "apartment_rentals", "question": "Show the top 3 apartment type codes sorted by the average number of rooms in descending order.", "rationale": ["Identify the relevant table: The Apartments table contains the apartment type codes and the number of rooms.", "Select the columns needed: We need the apartment type code (apt_type_code) and the average number of rooms (room_count).", "Calculate the average number of rooms: Use the AVG() function to calculate the average of room_count for each apartment type code.", "Group the results: Use GROUP BY to group the results by apt_type_code to get the average for each type.", "Sort the results: Use ORDER BY to sort the results in descending order based on the average number of rooms.", "Limit the results: Use LIMIT to restrict the output to the top 3 apartment type codes."], "gold_sql": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY avg(room_count) DESC LIMIT 3", "source_tables": ["apartments"], "pred_sql": "SELECT apt_type_code, AVG(room_count) AS average_rooms\nFROM Apartments\nGROUP BY apt_type_code\nORDER BY average_rooms DESC\nLIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the types of apartments available in the 'Apartments' table, displaying the apartment type code along with the count of bathrooms and bedrooms. The results are grouped by apartment type and ordered by the total number of rooms in descending order, with a limit on the number of results returned based on a specified numeric value.\",\n    \"1\": \"This virtual table provides a summary of the types of apartments available in the 'Apartments' table that have a specified number of bathrooms. The results are grouped by the apartment type code and ordered by the count of apartments in each type, allowing users to see which types are most common based on the bathroom count. The placeholders in the WHERE clause and LIMIT clause represent the minimum number of bathrooms and the maximum number of results to return, respectively.\"\n}\n"}
{"sample_id": "train.1258", "db_id": "apartment_rentals", "question": "Show the apartment type code that has the largest number of total rooms, together with the number of bathrooms and number of bedrooms.", "rationale": ["Identify the relevant columns needed: apt_type_code, bathroom_count, bedroom_count from the Apartments table.", "To find the apartment type code with the largest number of total rooms, we need to order the results by room_count in descending order.", "We will limit the results to 1 to get only the top result, which will be the apartment type with the largest number of total rooms."], "gold_sql": "SELECT apt_type_code ,  bathroom_count ,  bedroom_count FROM Apartments GROUP BY apt_type_code ORDER BY sum(room_count) DESC LIMIT 1", "source_tables": ["apartments"], "pred_sql": "SELECT apt_type_code, bathroom_count, bedroom_count \nFROM Apartments \nORDER BY room_count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the types of apartments available in the 'Apartments' table, displaying the apartment type code along with the count of bathrooms and bedrooms. The results are grouped by apartment type and ordered by the total number of rooms in descending order, with a limit on the number of results returned based on a specified numeric value.\",\n    \"1\": \"This virtual table provides a summary of the types of apartments available in the 'Apartments' table that have a specified number of bathrooms. The results are grouped by the apartment type code and ordered by the count of apartments in each type, allowing users to see which types are most common based on the bathroom count. The placeholders in the WHERE clause and LIMIT clause represent the minimum number of bathrooms and the maximum number of results to return, respectively.\"\n}\n"}
{"sample_id": "train.1261", "db_id": "apartment_rentals", "question": "Which apartment type code appears the most often?", "rationale": ["Identify the relevant table: The Apartments table contains the apartment type codes.", "Count occurrences: We need to count how many times each apartment type code appears.", "Group by apartment type code: Use GROUP BY to aggregate the counts for each type code.", "Order by count: To find the most common type, we will order the results by the count in descending order.", "Limit the results: Since we only want the most common type, we will limit the results to 1."], "gold_sql": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["apartments"], "pred_sql": "SELECT apt_type_code, COUNT(*) as type_count \nFROM Apartments \nGROUP BY apt_type_code \nORDER BY type_count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the types of apartments available in the 'Apartments' table, displaying the apartment type code along with the count of bathrooms and bedrooms. The results are grouped by apartment type and ordered by the total number of rooms in descending order, with a limit on the number of results returned based on a specified numeric value.\",\n    \"1\": \"This virtual table provides a summary of the types of apartments available in the 'Apartments' table that have a specified number of bathrooms. The results are grouped by the apartment type code and ordered by the count of apartments in each type, allowing users to see which types are most common based on the bathroom count. The placeholders in the WHERE clause and LIMIT clause represent the minimum number of bathrooms and the maximum number of results to return, respectively.\"\n}\n"}
{"sample_id": "train.1262", "db_id": "apartment_rentals", "question": "Show the most common apartment type code among apartments with more than 1 bathroom.", "rationale": ["Identify the relevant table: The Apartments table contains the apartment type codes and the number of bathrooms.", "Filter the apartments: We need to filter apartments that have more than 1 bathroom, which can be done using a WHERE clause.", "Group the results: To find the most common apartment type code, we will group the results by the apartment type code using GROUP BY.", "Count the apartments: We will count the number of apartments for each type code using COUNT(*) and alias it as apartment_count.", "Order the results: To find the most common type, we will order the results in descending order based on the count of apartments.", "Limit the results: Since we only want the most common type, we will limit the results to 1 using LIMIT 1."], "gold_sql": "SELECT apt_type_code FROM Apartments WHERE bathroom_count  >  1 GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["apartments"], "pred_sql": "SELECT apt_type_code, COUNT(*) as apartment_count \nFROM Apartments \nWHERE bathroom_count > 1 \nGROUP BY apt_type_code \nORDER BY apartment_count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the types of apartments available in the 'Apartments' table that have a specified number of bathrooms. The results are grouped by the apartment type code and ordered by the count of apartments in each type, allowing users to see which types are most common based on the bathroom count. The placeholders in the WHERE clause and LIMIT clause represent the minimum number of bathrooms and the maximum number of results to return, respectively.\",\n    \"1\": \"This virtual table summarizes the types of apartments available in the 'Apartments' table, displaying the apartment type code along with the count of bathrooms and bedrooms. The results are grouped by apartment type and ordered by the total number of rooms in descending order, with a limit on the number of results returned based on a specified numeric value.\"\n}\n"}
{"sample_id": "train.1272", "db_id": "apartment_rentals", "question": "Show the apartment numbers of apartments with unit status availability of both 0 and 1.", "rationale": ["Identify the relevant table: The Apartments table contains the apartment numbers we want to retrieve.", "Determine the condition for availability: We need to check the availability status from the View_Unit_Status table, which indicates if an apartment is available or not.", "Use a subquery to filter apartments: We will use a subquery to select the apt_id from View_Unit_Status where the available_yn column indicates both 'Yes' (1) and 'No' (0).", "Join the results: The main query will select the apt_number from the Apartments table where the apt_id matches the results from the subquery."], "gold_sql": "SELECT T1.apt_number FROM Apartments AS T1 JOIN View_Unit_Status AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.available_yn  =  0 INTERSECT SELECT T1.apt_number FROM Apartments AS T1 JOIN View_Unit_Status AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.available_yn  =  1", "source_tables": ["view_unit_status", "apartments"], "pred_sql": "SELECT apt_number FROM Apartments WHERE apt_id IN (SELECT apt_id FROM View_Unit_Status WHERE available_yn IN ('Yes', 'No'));", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the types of apartments available in the 'Apartments' table, displaying the apartment type code along with the count of bathrooms and bedrooms. The results are grouped by apartment type and ordered by the total number of rooms in descending order, with a limit on the number of results returned based on a specified numeric value.\",\n    \"1\": \"This virtual table provides a summary of the types of apartments available in the 'Apartments' table that have a specified number of bathrooms. The results are grouped by the apartment type code and ordered by the count of apartments in each type, allowing users to see which types are most common based on the bathroom count. The placeholders in the WHERE clause and LIMIT clause represent the minimum number of bathrooms and the maximum number of results to return, respectively.\"\n}\n"}
{"sample_id": "train.1294", "db_id": "soccer_1", "question": "How many leagues are there in England?", "rationale": ["Identify the relevant table: The question pertains to leagues, so we will use the 'League' table.", "Determine the condition: We need to filter the leagues to only those in England.", "Construct the SQL query: We will use the COUNT function to count the number of leagues that match the condition."], "gold_sql": "SELECT count(*) FROM Country AS T1 JOIN League AS T2 ON T1.id  =  T2.country_id WHERE T1.name  =  'England'", "source_tables": ["country", "league"], "pred_sql": "SELECT COUNT(*) AS league_count FROM League WHERE name = 'England';", "hint": "\n"}
{"sample_id": "train.1303", "db_id": "soccer_1", "question": "List all of the player ids with a height of at least 180cm and an overall rating higher than 85.", "rationale": ["Identify the relevant tables: Player and Player_Attributes.", "We need to select player ids, which are in the Player table.", "We need to filter players based on height (at least 180cm) and overall rating (higher than 85).", "Join the Player table with Player_Attributes table on player_api_id to access both height and overall rating.", "Construct the SQL query to select the player ids with the specified conditions."], "gold_sql": "SELECT player_api_id FROM Player WHERE height  >=  180 INTERSECT SELECT player_api_id FROM Player_Attributes WHERE overall_rating  >  85", "source_tables": ["player_attributes", "player"], "pred_sql": "SELECT p.id \nFROM Player p \nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id \nWHERE p.height >= 180 AND pa.overall_rating > 85;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct names of players from the 'Player' table who have a specific preferred foot and whose overall skill rating falls within a defined range. The placeholders in the WHERE clause represent the preferred foot and the minimum and maximum overall ratings.\",\n    \"1\": \"This virtual table lists the distinct names of players from the 'Player' table who have a crossing ability greater than a specified value and have a preferred foot that matches a given specification. The placeholders in the WHERE clause represent the crossing ability threshold and the preferred foot of the players.\"\n}\n"}
{"sample_id": "train.1304", "db_id": "soccer_1", "question": "List all of the ids for left-footed players with a height between 180cm and 190cm.", "rationale": ["Identify the relevant tables: Player and Player_Attributes.", "We need to select the 'id' from the Player table.", "Join the Player table with Player_Attributes on the player_api_id to access player attributes.", "Filter the results to include only left-footed players by checking 'preferred_foot' column.", "Further filter the results to include only players with height between 180cm and 190cm using the 'height' column."], "gold_sql": "SELECT player_api_id FROM Player WHERE height  >=  180 AND height  <=  190 INTERSECT SELECT player_api_id FROM Player_Attributes WHERE preferred_foot  =  'left'", "source_tables": ["player_attributes", "player"], "pred_sql": "SELECT Player.id FROM Player JOIN Player_Attributes ON Player.player_api_id = Player_Attributes.player_api_id WHERE Player_Attributes.preferred_foot = 'left' AND Player.height BETWEEN 180 AND 190;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct names of players from the 'Player' table who have a specific preferred foot and whose overall skill rating falls within a defined range. The placeholders in the WHERE clause represent the preferred foot and the minimum and maximum overall ratings.\",\n    \"1\": \"This virtual table lists the distinct names of players from the 'Player' table who have a crossing ability greater than a specified value and have a preferred foot that matches a given specification. The placeholders in the WHERE clause represent the crossing ability threshold and the preferred foot of the players.\"\n}\n"}
{"sample_id": "train.1306", "db_id": "soccer_1", "question": "List the names and birthdays of the top five players in terms of potential.", "rationale": ["Identify the relevant tables: Player and Player_Attributes are needed to get player names and birthdays along with their potential.", "Use a JOIN clause to combine Player and Player_Attributes on the player_api_id, which is the common key between these two tables.", "Select the player_name and birthday columns from the Player table.", "Order the results by the potential column in descending order to get the top players.", "Limit the results to the top five players by using the LIMIT clause."], "gold_sql": "SELECT DISTINCT T1.player_name ,  T1.birthday FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id  =  T2.player_api_id ORDER BY potential DESC LIMIT 5", "source_tables": ["player_attributes", "player"], "pred_sql": "SELECT player_name, birthday \nFROM Player \nJOIN Player_Attributes ON Player.player_api_id = Player_Attributes.player_api_id \nORDER BY potential DESC \nLIMIT 5;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct names of players from the 'Player' table who have a specific preferred foot and whose overall skill rating falls within a defined range. The placeholders in the WHERE clause represent the preferred foot and the minimum and maximum overall ratings.\",\n    \"1\": \"This virtual table lists the distinct names of players from the 'Player' table who have a crossing ability greater than a specified value and have a preferred foot that matches a given specification. The placeholders in the WHERE clause represent the crossing ability threshold and the preferred foot of the players.\"\n}\n"}
{"sample_id": "train.1511", "db_id": "insurance_and_eClaims", "question": "Which type of policy is most frequently used? Give me the policy type code.", "rationale": ["Identify the table that contains the policy type information, which is the 'Policies' table.", "To find the most frequently used policy type, we need to count the occurrences of each 'Policy_Type_Code'.", "Use the COUNT() function to count the number of policies for each type.", "Group the results by 'Policy_Type_Code' to aggregate the counts for each type.", "Order the results in descending order based on the frequency count to get the most common policy type at the top.", "Limit the results to 1 to get only the most frequently used policy type."], "gold_sql": "SELECT policy_type_code FROM policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["policies"], "pred_sql": "SELECT Policy_Type_Code, COUNT(*) AS Frequency\nFROM Policies\nGROUP BY Policy_Type_Code\nORDER BY Frequency DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.1513", "db_id": "insurance_and_eClaims", "question": "Find all the policy types that are used by more than 2 customers.", "rationale": ["Identify the relevant table: The Policies table contains the Policy_Type_Code and Customer_ID, which are needed to answer the question.", "Determine the condition: We need to find policy types that are used by more than 2 customers. This means we need to count the number of distinct customers for each policy type.", "Use GROUP BY: We will group the results by Policy_Type_Code to count the number of customers associated with each policy type.", "Use HAVING clause: We will use the HAVING clause to filter out policy types that have 2 or fewer customers.", "Construct the SQL query: Combine the SELECT, FROM, WHERE, GROUP BY, and HAVING clauses to form the complete SQL query."], "gold_sql": "SELECT policy_type_code FROM policies GROUP BY policy_type_code HAVING count(*)  >  2", "source_tables": ["policies"], "pred_sql": "SELECT Policy_Type_Code\nFROM Policies\nWHERE Customer_ID IN (\n    SELECT Customer_ID\n    FROM Policies\n    GROUP BY Customer_ID\n    HAVING COUNT(DISTINCT Customer_ID) > 2\n)\nGROUP BY Policy_Type_Code;", "hint": "\n"}
{"sample_id": "train.1516", "db_id": "insurance_and_eClaims", "question": "What are the total amount and average amount paid in claim headers?", "rationale": ["Identify the relevant table: Claim_Headers, which contains the Amount_Paid column.", "To find the total amount paid, use the SUM() function on the Amount_Paid column.", "To find the average amount paid, use the AVG() function on the Amount_Paid column.", "Construct the SQL query to select both the total and average amounts from the Claim_Headers table."], "gold_sql": "SELECT sum(amount_piad) ,  avg(amount_piad) FROM claim_headers", "source_tables": ["claim_headers"], "pred_sql": "SELECT SUM(Amount_Paid) AS Total_Amount_Paid, AVG(Amount_Paid) AS Average_Amount_Paid FROM Claim_Headers;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the total amount claimed from the 'Claim_Headers' table for claims that have associated documents created on a specific date. The placeholder in the subquery represents the limit for selecting the created date of the documents.\"\n}\n"}
{"sample_id": "train.1518", "db_id": "insurance_and_eClaims", "question": "How much amount in total were claimed in the most recently created document?", "rationale": ["Identify the relevant tables: Claim_Headers for the amount claimed and Claims_Documents for the document creation date.", "We need to sum the 'Amount_Claimed' from the Claim_Headers table.", "Join Claim_Headers with Claims_Documents on the Claim_ID to link claims with their documents.", "Filter the results to only include claims that have documents created on the most recent date.", "Use a subquery to find the maximum 'Created_Date' from the Claims_Documents table to get the most recent document creation date."], "gold_sql": "SELECT sum(t1.amount_claimed) FROM claim_headers AS t1 JOIN claims_documents AS t2 ON t1.claim_header_id  =  t2.claim_id WHERE t2.created_date  =  (SELECT created_date FROM claims_documents ORDER BY created_date LIMIT 1)", "source_tables": ["claims_documents", "claim_headers"], "pred_sql": "SELECT SUM(ch.Amount_Claimed) AS Total_Claimed_Amount\nFROM Claim_Headers ch\nJOIN Claims_Documents cd ON ch.Claim_Header_ID = cd.Claim_ID\nWHERE cd.Created_Date = (\n    SELECT MAX(Created_Date)\n    FROM Claims_Documents\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the total amount claimed from the 'Claim_Headers' table for claims that have associated documents created on a specific date. The placeholder in the subquery represents the limit for selecting the created date of the documents.\"\n}\n"}
{"sample_id": "train.1519", "db_id": "insurance_and_eClaims", "question": "What is the name of the customer who has made the largest amount of claim in a single claim?", "rationale": ["Identify the relevant tables: Customers, Policies, and Claim_Headers are needed to find the customer details and their claims.", "Join the Customers table with the Policies table on Customer_ID to link customers to their policies.", "Join the resulting table with the Claim_Headers table on Policy_ID to access the claims made by each customer.", "Order the results by the Amount_Claimed in descending order to get the claim with the largest amount at the top.", "Limit the results to 1 to get only the customer with the largest claim."], "gold_sql": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_claimed  =  (SELECT max(amount_claimed) FROM claim_headers)", "source_tables": ["policies", "customers", "claim_headers"], "pred_sql": "SELECT c.Customer_Details\nFROM Customers c\nJOIN Policies p ON c.Customer_ID = p.Customer_ID\nJOIN Claim_Headers ch ON p.Policy_ID = ch.Policy_ID\nORDER BY ch.Amount_Claimed DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the total amount claimed from the 'Claim_Headers' table for claims that have associated documents created on a specific date. The placeholder in the subquery represents the limit for selecting the created date of the documents.\"\n}\n"}
{"sample_id": "train.1521", "db_id": "insurance_and_eClaims", "question": "What is the name of the customer who has made the minimum amount of payment in one claim?", "rationale": ["Identify the relevant tables: Customers, Policies, and Claim_Headers.", "We need to find the customer who has made the minimum amount of payment in one claim, which involves the Amount_Paid column in the Claim_Headers table.", "Join the Customers table with the Policies table on Customer_ID to link customers to their policies.", "Then, join the Claim_Headers table on Policy_ID to link policies to their claims.", "Use ORDER BY to sort the claims by Amount_Paid in ascending order to find the minimum payment.", "Limit the results to 1 to get the customer with the minimum payment."], "gold_sql": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)", "source_tables": ["policies", "customers", "claim_headers"], "pred_sql": "SELECT c.Customer_Details \nFROM Customers c \nJOIN Policies p ON c.Customer_ID = p.Customer_ID \nJOIN Claim_Headers ch ON p.Policy_ID = ch.Policy_ID \nORDER BY ch.Amount_Paid ASC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.1531", "db_id": "insurance_and_eClaims", "question": "Find the names of the customers who have an deputy policy.", "rationale": ["Identify the relevant tables: Customers and Policies.", "Determine the relationship between the tables: Customers are linked to Policies through Customer_ID.", "Select the Customer_Details from the Customers table.", "Filter the results to include only those policies with a Policy_Type_Code of 'deputy'.", "Use DISTINCT to ensure that each customer's name appears only once in the results."], "gold_sql": "SELECT DISTINCT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.policy_type_code  =  'Deputy'", "source_tables": ["policies", "customers"], "pred_sql": "SELECT DISTINCT Customers.Customer_Details \nFROM Customers \nJOIN Policies ON Customers.Customer_ID = Policies.Customer_ID \nWHERE Policies.Policy_Type_Code = 'deputy';", "hint": "\n"}
{"sample_id": "train.1533", "db_id": "insurance_and_eClaims", "question": "Find the names of customers who either have an deputy policy or uniformed policy.", "rationale": ["Identify the relevant tables: Customers and Policies.", "Determine the relationship between the tables: Customers are linked to Policies through Customer_ID.", "Select the required fields: We need the Customer_Details from the Customers table.", "Filter the results based on the Policy_Type_Code: We want policies that are either 'deputy' or 'uniformed'.", "Construct the SQL query using JOIN to combine the tables and apply the WHERE clause for filtering."], "gold_sql": "SELECT DISTINCT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.policy_type_code  =  'Deputy' OR t1.policy_type_code  =  'Uniform'", "source_tables": ["policies", "customers"], "pred_sql": "SELECT DISTINCT Customers.Customer_Details \nFROM Customers \nJOIN Policies ON Customers.Customer_ID = Policies.Customer_ID \nWHERE Policies.Policy_Type_Code IN ('deputy', 'uniformed');", "hint": "\n"}
{"sample_id": "train.1546", "db_id": "insurance_and_eClaims", "question": "Find the customer who started a policy most recently.", "rationale": ["Identify the relevant tables: Customers and Policies.", "We need to find the customer who started a policy most recently, so we will join the Customers table with the Policies table on the Customer_ID.", "We will select the Customer_ID and Customer_Details from the Customers table, and the Start_Date from the Policies table.", "To find the most recent policy start date, we will order the results by Start_Date in descending order.", "Finally, we will limit the results to 1 to get only the most recent customer."], "gold_sql": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)", "source_tables": ["policies", "customers"], "pred_sql": "SELECT Customers.Customer_ID, Customers.Customer_Details, Policies.Start_Date\nFROM Customers\nJOIN Policies ON Customers.Customer_ID = Policies.Customer_ID\nORDER BY Policies.Start_Date DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.1553", "db_id": "customers_and_invoices", "question": "Show the id, the account name, and other account details for all accounts by the customer with first name 'Meaghan'.", "rationale": ["Identify the relevant tables: Accounts and Customers are needed to get account details for a specific customer.", "Determine the columns to select: We need account_id, account_name, and other_account_details from the Accounts table.", "Establish the relationship between tables: Use the customer_id to join Accounts and Customers tables.", "Filter the results: We need to filter the results to only include accounts for the customer with the first name 'Meaghan'.", "Construct the SQL query using SELECT, JOIN, and WHERE clauses."], "gold_sql": "SELECT T1.account_id ,  T1.date_account_opened ,  T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  'Meaghan'", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT a.account_id, a.account_name, a.other_account_details \nFROM Accounts a \nJOIN Customers c ON a.customer_id = c.customer_id \nWHERE c.customer_first_name = 'Meaghan';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, and last name, along with the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\",\n    \"1\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, last name, and the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\",\n    \"2\": \"This virtual table summarizes the total number of financial transactions associated with each account. It displays the account name and account ID from the 'Accounts' table, along with a count of transactions from the 'Financial_Transactions' table, grouped by account ID.\"\n}\n"}
{"sample_id": "train.1556", "db_id": "customers_and_invoices", "question": "What are the names and other details for accounts corresponding to the customer named Meaghan Keeling?", "rationale": ["Identify the relevant tables: Accounts and Customers are needed to get account details for a specific customer.", "Join the Accounts table with the Customers table on the customer_id to link accounts to the customer.", "Filter the results to only include the customer named Meaghan Keeling by using the WHERE clause with the customer's first and last name.", "Select the desired columns from the Accounts table, which include account_id, account_name, date_account_opened, and other_account_details."], "gold_sql": "SELECT T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  'Meaghan' AND T2.customer_last_name  =  'Keeling'", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT a.account_id, a.account_name, a.date_account_opened, a.other_account_details \nFROM Accounts a \nJOIN Customers c ON a.customer_id = c.customer_id \nWHERE c.customer_first_name = 'Meaghan' AND c.customer_last_name = 'Keeling';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, and last name, along with the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\",\n    \"1\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, last name, and the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\",\n    \"2\": \"This virtual table summarizes the total number of financial transactions associated with each account. It displays the account name and account ID from the 'Accounts' table, along with a count of transactions from the 'Financial_Transactions' table, grouped by account ID.\"\n}\n"}
{"sample_id": "train.1558", "db_id": "customers_and_invoices", "question": "What are the full names of customers with the account name 900?", "rationale": ["Identify the relevant tables: Customers and Accounts are needed to get customer names and account details.", "Join the Customers table with the Accounts table on the customer_id to link customers with their accounts.", "Filter the results to only include accounts with the name '900'.", "Select the full name of the customers by concatenating their first and last names."], "gold_sql": "SELECT T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T1.account_name  =  '900'", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT customer_first_name || ' ' || customer_last_name AS full_name \nFROM Customers \nJOIN Accounts ON Customers.customer_id = Accounts.customer_id \nWHERE Accounts.account_name = '900';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, and last name, along with the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\",\n    \"1\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, last name, and the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\"\n}\n"}
{"sample_id": "train.1568", "db_id": "customers_and_invoices", "question": "Return the id and full name of the customer with the most accounts.", "rationale": ["Identify the relevant tables: Customers and Accounts are needed to get customer details and their associated accounts.", "Join the Customers table with the Accounts table on the customer_id to link customers with their accounts.", "Group the results by customer_id to count the number of accounts each customer has.", "Order the results by the count of accounts in descending order to find the customer with the most accounts.", "Limit the results to 1 to get only the customer with the highest account count."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT c.customer_id, c.customer_first_name || ' ' || c.customer_last_name AS full_name\nFROM Accounts a\nJOIN Customers c ON a.customer_id = c.customer_id\nGROUP BY c.customer_id\nORDER BY COUNT(a.account_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, and last name, along with the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\",\n    \"1\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, last name, and the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\",\n    \"2\": \"This virtual table summarizes the total number of financial transactions associated with each account. It displays the account name and account ID from the 'Accounts' table, along with a count of transactions from the 'Financial_Transactions' table, grouped by account ID.\"\n}\n"}
{"sample_id": "train.1579", "db_id": "customers_and_invoices", "question": "How many transaction does each account have? Show the number and account id.", "rationale": ["We need to count the number of transactions for each account, which involves the 'Accounts' and 'Financial_Transactions' tables.", "We will select the 'account_id' from the 'Accounts' table and count the 'transaction_id' from the 'Financial_Transactions' table.", "To get the count of transactions per account, we will use a LEFT JOIN to ensure we include accounts even if they have no transactions.", "We will group the results by 'account_id' to get the count of transactions for each account."], "gold_sql": "SELECT count(*) ,  account_id FROM Financial_transactions", "source_tables": ["financial_transactions"], "pred_sql": "SELECT a.account_id, COUNT(ft.transaction_id) AS transaction_count\nFROM Accounts a\nLEFT JOIN Financial_Transactions ft ON a.account_id = ft.account_id\nGROUP BY a.account_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of financial transactions associated with each account. It displays the account name and account ID from the 'Accounts' table, along with a count of transactions from the 'Financial_Transactions' table, grouped by account ID.\",\n    \"1\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, last name, and the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\",\n    \"2\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, and last name, along with the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\"\n}\n"}
{"sample_id": "train.1589", "db_id": "customers_and_invoices", "question": "Show the account name, id and the number of transactions for each account.", "rationale": ["We need to retrieve the account name and account ID from the Accounts table.", "We also need to count the number of transactions associated with each account from the Financial_Transactions table.", "To achieve this, we will perform a LEFT JOIN between the Accounts table and the Financial_Transactions table on the account_id.", "We will use COUNT() to count the transaction IDs for each account, which will give us the number of transactions.", "Finally, we will group the results by account_id and account_name to ensure we get the correct counts for each account."], "gold_sql": "SELECT T2.account_name ,  T1.account_id ,  count(*) FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id GROUP BY T1.account_id", "source_tables": ["accounts", "financial_transactions"], "pred_sql": "SELECT a.account_name, a.account_id, COUNT(ft.transaction_id) AS number_of_transactions\nFROM Accounts a\nLEFT JOIN Financial_Transactions ft ON a.account_id = ft.account_id\nGROUP BY a.account_id, a.account_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of financial transactions associated with each account. It displays the account name and account ID from the 'Accounts' table, along with a count of transactions from the 'Financial_Transactions' table, grouped by account ID.\",\n    \"1\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, last name, and the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\",\n    \"2\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, and last name, along with the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\"\n}\n"}
{"sample_id": "train.1599", "db_id": "customers_and_invoices", "question": "Show the invoice number and the number of transactions for each invoice.", "rationale": ["Identify the tables involved: Invoices and Financial_Transactions.", "We need to retrieve the invoice number from the Invoices table.", "We need to count the number of transactions associated with each invoice from the Financial_Transactions table.", "Join the Invoices table with the Financial_Transactions table on the invoice_number field to associate transactions with their respective invoices.", "Use COUNT() function to count the number of transactions for each invoice.", "Group the results by invoice_number to get the count for each invoice."], "gold_sql": "SELECT invoice_number ,  count(*) FROM Financial_transactions GROUP BY invoice_number", "source_tables": ["financial_transactions"], "pred_sql": "SELECT Invoices.invoice_number, COUNT(Financial_Transactions.transaction_id) AS transaction_count\nFROM Invoices\nLEFT JOIN Financial_Transactions ON Invoices.invoice_number = Financial_Transactions.invoice_number\nGROUP BY Invoices.invoice_number;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of financial transactions associated with each account. It displays the account name and account ID from the 'Accounts' table, along with a count of transactions from the 'Financial_Transactions' table, grouped by account ID.\",\n    \"1\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, last name, and the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\",\n    \"2\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, and last name, along with the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\"\n}\n"}
{"sample_id": "train.1602", "db_id": "customers_and_invoices", "question": "What is the invoice number and invoice date corresponding to the invoice with the greatest number of transactions?", "rationale": ["We need to find the invoice number and invoice date for the invoice with the greatest number of transactions.", "To do this, we will first summarize the total number of transactions associated with each invoice using the Financial_Transactions table.", "We will group the results by invoice_number and count the number of transaction_ids for each invoice.", "Next, we will join this summary with the Invoices table to get the corresponding invoice details.", "Finally, we will order the results by the transaction count in descending order and limit the results to 1 to get the invoice with the greatest number of transactions."], "gold_sql": "SELECT T2.invoice_number ,  T2.invoice_date FROM Financial_transactions AS T1 JOIN Invoices AS T2 ON T1.invoice_number  =  T2.invoice_number GROUP BY T1.invoice_number ORDER BY count(*) DESC LIMIT 1", "source_tables": ["invoices", "financial_transactions"], "pred_sql": "SELECT i.invoice_number, i.invoice_date\nFROM Invoices i\nJOIN (\n    SELECT ft.invoice_number, COUNT(ft.transaction_id) AS transaction_count\n    FROM Financial_Transactions ft\n    GROUP BY ft.invoice_number\n) AS transaction_summary ON i.invoice_number = transaction_summary.invoice_number\nORDER BY transaction_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of financial transactions associated with each account. It displays the account name and account ID from the 'Accounts' table, along with a count of transactions from the 'Financial_Transactions' table, grouped by account ID.\",\n    \"1\": \"This virtual table provides a list of order IDs and their corresponding details from the 'Orders' table, specifically for those orders that are associated with invoices. The results are grouped by order ID, and only those orders that have more than a specified number of associated invoices are included. The placeholder in the HAVING clause represents the minimum count of invoices required for an order to be displayed.\"\n}\n"}
{"sample_id": "train.1617", "db_id": "customers_and_invoices", "question": "Show the order ids and the number of items in each order.", "rationale": ["Identify the relevant table: The 'Order_Items' table contains the order details and the items associated with each order.", "Select the order_id: We need to retrieve the order IDs from the 'Order_Items' table.", "Count the number of items: Use the COUNT function to count the distinct order_item_id for each order_id.", "Group the results: Use GROUP BY to group the results by order_id to get the count of items for each order."], "gold_sql": "SELECT order_id ,  count(*) FROM Order_items GROUP BY order_id", "source_tables": ["order_items"], "pred_sql": "SELECT oi.order_id, COUNT(oi.order_item_id) AS number_of_items\nFROM Order_Items oi\nGROUP BY oi.order_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of distinct products associated with each order from the 'Order_Items' table. The placeholder in the SELECT clause represents the order identifier, while the count function calculates the unique product count for each order.\",\n    \"1\": \"This virtual table provides a list of order IDs and their corresponding details from the 'Orders' table, specifically for those orders that are associated with invoices. The results are grouped by order ID, and only those orders that have more than a specified number of associated invoices are included. The placeholder in the HAVING clause represents the minimum count of invoices required for an order to be displayed.\",\n    \"2\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, last name, and the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\"\n}\n"}
{"sample_id": "train.2049", "db_id": "party_people", "question": "Show all ministers who do not belong to Progress Party.", "rationale": ["Identify the relevant tables: 'party' for political parties and 'member' for members.", "We need to find ministers, which are associated with the 'party' table.", "Join the 'party' table with the 'member' table on the Party_ID to get the members associated with each party.", "Filter the results to exclude members from the 'Progress Party'.", "Also, ensure that we only select members who are currently in office (In_office = 'Yes').", "Select distinct ministers from the resulting joined table."], "gold_sql": "SELECT minister FROM party WHERE party_name != 'Progress Party'", "source_tables": ["party"], "pred_sql": "SELECT DISTINCT minister.* \nFROM party AS p \nJOIN member AS m ON p.Party_ID = m.Party_ID \nWHERE p.Party_name != 'Progress Party' AND m.In_office = 'Yes';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of members associated with each political party from the 'Member' and 'Party' tables. The placeholder in the SELECT statement represents the party's name, and the count function aggregates the total number of members for each party.\",\n    \"1\": \"This virtual table summarizes the number of events organized by each political party from the 'party_events' table. It joins the 'party' table to retrieve the party names associated with the events. The placeholder in the SELECT clause represents the party name, while the count function aggregates the total number of events for each party.\"\n}\n"}
{"sample_id": "train.2058", "db_id": "party_people", "question": "How many members are in each party?", "rationale": ["Identify the tables involved: 'member' and 'party'.", "We need to count the number of members in each party, so we will use the COUNT() function.", "Join the 'party' table with the 'member' table on the Party_ID to associate members with their respective parties.", "Group the results by party name to get the count of members for each party."], "gold_sql": "SELECT T2.party_name ,  count(*) FROM Member AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id", "source_tables": ["party", "member"], "pred_sql": "SELECT party.Party_name, COUNT(member.Member_ID) AS Member_Count\nFROM party\nLEFT JOIN member ON party.Party_ID = member.Party_ID\nGROUP BY party.Party_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of members associated with each political party from the 'Member' and 'Party' tables. The placeholder in the SELECT statement represents the party's name, and the count function aggregates the total number of members for each party.\",\n    \"1\": \"This virtual table summarizes the number of events organized by each political party from the 'party_events' table. It joins the 'party' table to retrieve the party names associated with the events. The placeholder in the SELECT clause represents the party name, while the count function aggregates the total number of events for each party.\"\n}\n"}
{"sample_id": "train.2071", "db_id": "party_people", "question": "Show party names and the number of events for each party.", "rationale": ["We need to retrieve the names of the political parties and the number of events they have organized.", "To do this, we will select the 'Party_name' from the 'party' table.", "We will use the COUNT function to count the number of events from the 'party_events' table.", "To link the two tables, we will perform a LEFT JOIN on the 'Party_ID' column, which is common to both tables.", "Finally, we will group the results by 'Party_name' to get the count of events for each party."], "gold_sql": "SELECT T2.party_name ,  count(*) FROM party_events AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id", "source_tables": ["party", "party_events"], "pred_sql": "SELECT party.Party_name, COUNT(party_events.Event_ID) AS Number_of_Events\nFROM party\nLEFT JOIN party_events ON party.Party_ID = party_events.Party_ID\nGROUP BY party.Party_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of events organized by each political party from the 'party_events' table. It joins the 'party' table to retrieve the party names associated with the events. The placeholder in the SELECT clause represents the party name, while the count function aggregates the total number of events for each party.\",\n    \"1\": \"This virtual table summarizes the number of members associated with each political party from the 'Member' and 'Party' tables. The placeholder in the SELECT statement represents the party's name, and the count function aggregates the total number of members for each party.\"\n}\n"}
{"sample_id": "train.2081", "db_id": "party_people", "question": "How many Annual Meeting events happened in the United Kingdom region?", "rationale": ["Identify the relevant tables: 'party_events', 'party', and 'region'.", "We need to count the number of events, so we will use the COUNT() function.", "Join the 'party_events' table with the 'party' table on Party_ID to get the party names associated with the events.", "Join the 'party' table with the 'region' table on Region_ID to filter events by the region name.", "Add a WHERE clause to filter for events specifically named 'Annual Meeting'.", "Add another condition in the WHERE clause to filter for the region name 'United Kingdom'.", "Select the count of events that meet these criteria."], "gold_sql": "SELECT count(*) FROM region AS t1 JOIN party AS t2 ON t1.region_id  =  t2.region_id JOIN party_events AS t3 ON t2.party_id  =  t3.party_id WHERE t1.region_name  =  'United Kingdom' AND t3.Event_Name  =  'Annaual Meeting'", "source_tables": ["party", "party_events", "region"], "pred_sql": "SELECT COUNT(*) AS Annual_Meeting_Count \nFROM party_events pe \nJOIN party p ON pe.Party_ID = p.Party_ID \nJOIN region r ON p.Region_ID = r.Region_ID \nWHERE pe.Event_Name = 'Annual Meeting' \nAND r.Region_name = 'United Kingdom';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of events organized by each political party from the 'party_events' table. It joins the 'party' table to retrieve the party names associated with the events. The placeholder in the SELECT clause represents the party name, while the count function aggregates the total number of events for each party.\"\n}\n"}
{"sample_id": "train.2176", "db_id": "formula_1", "question": "What are the names and years of all races that had a driver with the last name Lewis?", "rationale": ["We need to find the names and years of all races that had a driver with the last name 'Lewis'.", "To do this, we will join the 'races' table with the 'results' table on the raceId, as the results table contains the driverId for each race.", "Next, we will join the 'drivers' table to get the surname of the drivers associated with each result.", "Finally, we will filter the results to only include those where the driver's surname is 'Lewis'.", "We will select the distinct names of the races and their corresponding years to avoid duplicates."], "gold_sql": "SELECT T2.name ,  T2.year FROM results AS T1 JOIN races AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T1.driverid = T3.driverid WHERE T3.forename = 'Lewis'", "source_tables": ["results", "drivers", "races"], "pred_sql": "SELECT DISTINCT races.name, races.year \nFROM races \nJOIN results ON races.raceId = results.raceId \nJOIN drivers ON results.driverId = drivers.driverId \nWHERE drivers.surname = 'Lewis';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of drivers who participated in a specific race, excluding those who also participated in another specified race. The placeholders in the WHERE clause represent the names of the races.\",\n    \"1\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n    \"2\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\"\n}\n"}
{"sample_id": "train.2182", "db_id": "formula_1", "question": "What are the first and last names of all drivers who participated in the Australian Grand Prix but not the Chinese Grand Prix?", "rationale": ["Identify the tables needed: We need the 'drivers' table to get the first and last names, and the 'results' and 'races' tables to filter by race participation.", "Join the 'drivers' table with the 'results' table to link drivers to their race results.", "Join the 'results' table with the 'races' table to filter for the Australian Grand Prix.", "Use a subquery to find drivers who participated in the Chinese Grand Prix and exclude them from the main query results.", "Select the first and last names of drivers who participated in the Australian Grand Prix but not in the Chinese Grand Prix."], "gold_sql": "SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Australian Grand Prix' EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Chinese Grand Prix'", "source_tables": ["races", "drivers", "results"], "pred_sql": "SELECT d.forename, d.surname \nFROM drivers d \nJOIN results r1 ON d.driverId = r1.driverId \nJOIN races ra ON r1.raceId = ra.raceId \nWHERE ra.name = 'Australian Grand Prix' \nAND d.driverId NOT IN (\n    SELECT d2.driverId \n    FROM drivers d2 \n    JOIN results r2 ON d2.driverId = r2.driverId \n    JOIN races rb ON r2.raceId = rb.raceId \n    WHERE rb.name = 'Chinese Grand Prix'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of drivers who participated in a specific race, excluding those who also participated in another specified race. The placeholders in the WHERE clause represent the names of the races.\",\n    \"1\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n    \"2\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\"\n}\n"}
{"sample_id": "train.2183", "db_id": "formula_1", "question": "Find all the forenames of distinct drivers who was in position 1 as standing and won?", "rationale": ["Identify the relevant tables: drivers and driverStandings.", "We need to find distinct drivers who were in position 1 and also won races.", "Join the drivers table with the driverStandings table on driverId to access both driver information and their standings.", "Filter the results where the position in the standings is 1 and the number of wins is greater than 0.", "Select the distinct forenames of the drivers that meet these criteria."], "gold_sql": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = 1 AND T2.wins = 1", "source_tables": ["drivers", "driverstandings"], "pred_sql": "SELECT DISTINCT d.forename \nFROM drivers d \nJOIN driverStandings ds ON d.driverId = ds.driverId \nWHERE ds.position = 1 AND ds.wins > 0;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n    \"1\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n    \"2\": \"This virtual table describes the first and last names of drivers who participated in a specific race, excluding those who also participated in another specified race. The placeholders in the WHERE clause represent the names of the races.\"\n}\n"}
{"sample_id": "train.2185", "db_id": "formula_1", "question": "Find all the forenames of distinct drivers who won in position 1 as driver standing and had more than 20 points?", "rationale": ["We need to find distinct drivers who won in position 1 and had more than 20 points.", "To do this, we will select the 'forename' from the 'drivers' table.", "We will join the 'drivers' table with the 'driverStandings' table on the 'driverId' to get the standings of each driver.", "We will filter the results where the 'position' in the standings is 1 (indicating a win) and the 'points' are greater than 20.", "Using DISTINCT ensures that we only get unique forenames of the drivers."], "gold_sql": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = 1 AND T2.wins = 1 AND T2.points > 20", "source_tables": ["drivers", "driverstandings"], "pred_sql": "SELECT DISTINCT d.forename \nFROM drivers d \nJOIN driverStandings ds ON d.driverId = ds.driverId \nWHERE ds.position = 1 AND ds.points > 20;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n    \"1\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n    \"2\": \"This virtual table describes the first and last names of drivers who participated in a specific race, excluding those who also participated in another specified race. The placeholders in the WHERE clause represent the names of the races.\"\n}\n"}
{"sample_id": "train.2186", "db_id": "formula_1", "question": "What are the first names of the different drivers who won in position 1 as driver standing and had more than 20 points?", "rationale": ["Identify the relevant table: We need to find drivers who won in position 1 and had more than 20 points, which involves the 'drivers' and 'driverStandings' tables.", "Join the 'drivers' table with the 'driverStandings' table on the 'driverId' to access both driver information and their standings.", "Filter the results to include only those drivers who have a position of 1 in the standings and have more than 20 points.", "Select the distinct first names of these drivers to avoid duplicates."], "gold_sql": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = 1 AND T2.wins = 1 AND T2.points > 20", "source_tables": ["drivers", "driverstandings"], "pred_sql": "SELECT DISTINCT d.forename \nFROM drivers d \nJOIN driverStandings ds ON d.driverId = ds.driverId \nWHERE ds.position = 1 AND ds.points > 20;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n    \"1\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n    \"2\": \"This virtual table describes the first and last names of drivers who participated in a specific race, excluding those who also participated in another specified race. The placeholders in the WHERE clause represent the names of the races.\"\n}\n"}
{"sample_id": "train.2189", "db_id": "formula_1", "question": "What are the numbers of races for each constructor id?", "rationale": ["We need to find the number of races for each constructor id.", "The relevant table for this information is 'constructorResults', which links constructors to races.", "We will use the COUNT function to count the number of races (raceId) for each constructor (constructorId).", "We will group the results by constructorId to get the count for each constructor."], "gold_sql": "SELECT count(*) ,  constructorid FROM constructorStandings GROUP BY constructorid", "source_tables": ["constructorstandings"], "pred_sql": "SELECT constructorId, COUNT(raceId) AS number_of_races\nFROM constructorResults\nGROUP BY constructorId;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n    \"1\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n    \"2\": \"This virtual table counts the distinct number of drivers who participated in races, excluding those that took place in a specific year. The placeholder in the WHERE clause represents the year to filter out races.\"\n}\n"}
{"sample_id": "train.2218", "db_id": "formula_1", "question": "What are the names of all the Japanese constructors that have earned more than 5 points?", "rationale": ["Identify the table that contains information about constructors, which is the 'constructors' table.", "We need to filter constructors based on their nationality, specifically 'Japanese'.", "We also need to check if these constructors have earned more than 5 points.", "To do this, we will use a subquery on the 'constructorResults' table to sum the points for each constructor and filter those with a sum greater than 5.", "The final query will select the names of constructors from the 'constructors' table where the nationality is 'Japanese' and the constructorId is in the list of constructorIds that have more than 5 points."], "gold_sql": "SELECT T1.name FROM constructors AS T1 JOIN constructorstandings AS T2 ON T1.constructorid = T2.constructorid WHERE T1.nationality = 'Japanese' AND T2.points > 5", "source_tables": ["constructorstandings", "constructors"], "pred_sql": "SELECT name FROM constructors WHERE nationality = 'Japanese' AND constructorId IN (SELECT constructorId FROM constructorResults GROUP BY constructorId HAVING SUM(points) > 5);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n    \"1\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\"\n}\n"}
{"sample_id": "train.2220", "db_id": "formula_1", "question": "What is the average fastest lap speed for the Monaco Grand Prix in 2008?", "rationale": ["Identify the relevant tables: lapTimes, races, and circuits are needed to find the average fastest lap speed for a specific race.", "The lapTimes table contains the fastest lap speed, while the races table provides the year and the circuitId for the Monaco Grand Prix in 2008.", "The circuits table is used to filter for the specific race name 'Monaco Grand Prix'.", "Join the lapTimes table with the races table on raceId, and then join the races table with the circuits table on circuitId.", "Filter the results to only include the Monaco Grand Prix in the year 2008.", "Calculate the average of the fastest lap speeds using the AVG() function."], "gold_sql": "SELECT avg(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "pred_sql": "SELECT AVG(fastestLapSpeed) AS average_fastest_lap_speed\nFROM lapTimes\nJOIN races ON lapTimes.raceId = races.raceId\nJOIN circuits ON races.circuitId = circuits.circuitId\nWHERE circuits.name = 'Monaco Grand Prix' AND races.year = 2008;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the maximum fastest lap speed recorded for each race, along with the official name of the race and the year it took place. The placeholder in the WHERE clause represents the year threshold for filtering the races.\",\n    \"1\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n    \"2\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\"\n}\n"}
{"sample_id": "train.2221", "db_id": "formula_1", "question": "What is the maximum fastest lap speed in race named 'Monaco Grand Prix' in 2008 ?", "rationale": ["Identify the relevant tables: We need to find the fastest lap speed for a specific race, which involves the 'results' and 'races' tables.", "Determine the filtering criteria: The race name is 'Monaco Grand Prix' and the year is 2008.", "Join the 'results' table with the 'races' table on the raceId to access the race details along with the results.", "Use the MAX function to find the maximum fastest lap speed from the results for the specified race."], "gold_sql": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "pred_sql": "SELECT MAX(fastestLapSpeed) AS max_fastest_lap_speed \nFROM results \nJOIN races ON results.raceId = races.raceId \nWHERE races.name = 'Monaco Grand Prix' AND races.year = 2008;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the maximum fastest lap speed recorded for each race, along with the official name of the race and the year it took place. The placeholder in the WHERE clause represents the year threshold for filtering the races.\",\n    \"1\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n    \"2\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\"\n}\n"}
{"sample_id": "train.2222", "db_id": "formula_1", "question": "What is the maximum fastest lap speed in the Monaco Grand Prix in 2008?", "rationale": ["Identify the relevant tables: races and lapTimes are needed to find the fastest lap speed for the Monaco Grand Prix in 2008.", "We need to join the races table with the lapTimes table on the raceId to access the fastest lap speed for the specific race.", "Filter the results to only include the Monaco Grand Prix in the year 2008 using the WHERE clause.", "Use the MAX function to find the maximum fastest lap speed from the filtered results."], "gold_sql": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "pred_sql": "SELECT MAX(lapTimes.fastestLapSpeed) AS max_fastest_lap_speed\nFROM races\nJOIN lapTimes ON races.raceId = lapTimes.raceId\nWHERE races.name = 'Monaco Grand Prix' AND races.year = 2008;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the maximum fastest lap speed recorded for each race, along with the official name of the race and the year it took place. The placeholder in the WHERE clause represents the year threshold for filtering the races.\",\n    \"1\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n    \"2\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\"\n}\n"}
{"sample_id": "train.2224", "db_id": "formula_1", "question": "For each race name, What is the maximum fastest lap speed for races after 2004 ordered by year?", "rationale": ["Identify the relevant tables: We need data from the 'races' table for race names and years, and the 'lapTimes' table for fastest lap speeds.", "Join the 'races' table with the 'lapTimes' table on the raceId to correlate races with their lap times.", "Filter the results to include only races that occurred after the year 2004 using the WHERE clause.", "Group the results by race name and year to calculate the maximum fastest lap speed for each race.", "Select the race name and the maximum fastest lap speed, and order the results by year."], "gold_sql": "SELECT max(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "pred_sql": "SELECT r.name, MAX(l.fastestLapSpeed) AS max_fastest_lap_speed\nFROM races r\nJOIN lapTimes l ON r.raceId = l.raceId\nWHERE r.year > 2004\nGROUP BY r.name, r.year\nORDER BY r.year;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the maximum fastest lap speed recorded for each race, along with the official name of the race and the year it took place. The placeholder in the WHERE clause represents the year threshold for filtering the races.\",\n    \"1\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n    \"2\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\"\n}\n"}
{"sample_id": "train.2225", "db_id": "formula_1", "question": "What are the average fastest lap speed in races held after 2004 grouped by race name and ordered by year?", "rationale": ["Identify the relevant tables: We need the 'races' table for race names and years, and the 'lapTimes' table for fastest lap speeds.", "Join the 'races' table with the 'lapTimes' table on the raceId to associate each lap time with its corresponding race.", "Filter the results to include only races held after the year 2004 using a WHERE clause.", "Group the results by race name to calculate the average fastest lap speed for each race.", "Use the AVG() function to calculate the average fastest lap speed for each race.", "Order the results by year to see the average fastest lap speeds in chronological order."], "gold_sql": "SELECT avg(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "pred_sql": "SELECT r.name AS race_name, AVG(lap.fastestLapSpeed) AS average_fastest_lap_speed\nFROM races r\nJOIN lapTimes lap ON r.raceId = lap.raceId\nWHERE r.year > 2004\nGROUP BY r.name\nORDER BY r.year;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the maximum fastest lap speed recorded for each race, along with the official name of the race and the year it took place. The placeholder in the WHERE clause represents the year threshold for filtering the races.\",\n    \"1\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n    \"2\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\"\n}\n"}
{"sample_id": "train.2226", "db_id": "formula_1", "question": "What is the average fastest lap speed for races held after 2004, for each race, ordered by year?", "rationale": ["Identify the relevant tables: races, results, and lapTimes are needed to get the race year, results, and fastest lap speed.", "Join the races table with the results table on raceId to link races with their results.", "Join the results table with the lapTimes table on raceId and driverId to get the fastest lap speed for each driver in each race.", "Filter the results to include only races held after the year 2004 using the WHERE clause.", "Group the results by year to calculate the average fastest lap speed for each race year using AVG function.", "Order the final results by year to present the data in chronological order."], "gold_sql": "SELECT avg(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "pred_sql": "SELECT r.year, AVG(lap.fastestLapSpeed) AS average_fastest_lap_speed\nFROM races r\nJOIN results res ON r.raceId = res.raceId\nJOIN lapTimes lap ON res.raceId = lap.raceId AND res.driverId = lap.driverId\nWHERE r.year > 2004\nGROUP BY r.year\nORDER BY r.year;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the maximum fastest lap speed recorded for each race, along with the official name of the race and the year it took place. The placeholder in the WHERE clause represents the year threshold for filtering the races.\",\n    \"1\": \"This virtual table counts the distinct number of drivers who participated in races, excluding those that took place in a specific year. The placeholder in the WHERE clause represents the year to filter out races.\",\n    \"2\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\"\n}\n"}
{"sample_id": "train.2243", "db_id": "machine_repair", "question": "What is the starting year of the oldest technicians?", "rationale": ["Identify the relevant table: The 'technician' table contains the information about technicians, including their starting years.", "Determine the required information: We need to find the oldest starting year among all technicians.", "Use the MIN() function: To find the oldest starting year, we can use the MIN() function on the 'Starting_Year' column.", "Construct the SQL query: The query will select the minimum starting year from the technician table."], "gold_sql": "SELECT Starting_Year FROM technician ORDER BY Age DESC LIMIT 1", "source_tables": ["technician"], "pred_sql": "SELECT MIN(Starting_Year) AS oldest_starting_year FROM technician;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the starting years of technicians from the 'technician' table who belong to two specific teams. The placeholders in the WHERE clause represent the identifiers for the teams being compared.\",\n    \"1\": \"This virtual table provides a summary of the number of repair assignments handled by each technician. It joins the 'repair_assignment' table with the 'technician' table to associate each assignment with the technician's name. The result is grouped by the technician's name, allowing for a count of assignments per technician.\"\n}\n"}
{"sample_id": "train.2248", "db_id": "machine_repair", "question": "What are the teams with the most technicians?", "rationale": ["We need to find the teams with the most technicians, which requires counting the number of technicians in each team.", "We will select the 'Team' column from the 'technician' table and count the number of 'technician_id' for each team.", "To get the count of technicians per team, we will use the GROUP BY clause on the 'Team' column.", "Finally, we will order the results in descending order based on the count of technicians to identify the teams with the most technicians."], "gold_sql": "SELECT Team FROM technician GROUP BY Team ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["technician"], "pred_sql": "SELECT Team, COUNT(technician_id) AS technician_count\nFROM technician\nGROUP BY Team\nORDER BY technician_count DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the starting years of technicians from the 'technician' table who belong to two specific teams. The placeholders in the WHERE clause represent the identifiers for the teams being compared.\",\n    \"1\": \"This virtual table provides a summary of the number of repair assignments handled by each technician. It joins the 'repair_assignment' table with the 'technician' table to associate each assignment with the technician's name. The result is grouped by the technician's name, allowing for a count of assignments per technician.\"\n}\n"}
{"sample_id": "train.2258", "db_id": "machine_repair", "question": "What are the names of the technicians  and how many machines are they assigned to repair?", "rationale": ["Identify the tables needed: technician and repair_assignment.", "We need the names of technicians, which are in the technician table.", "We also need to count the number of machines assigned to each technician, which can be found in the repair_assignment table.", "Join the technician table with the repair_assignment table on the technician_id to associate technicians with their repair assignments.", "Use COUNT() to count the number of Machine_IDs for each technician, which represents the number of machines they are assigned to.", "Group the results by technician's name to get the count for each technician."], "gold_sql": "SELECT T2.Name ,  COUNT(*) FROM repair_assignment AS T1 JOIN technician AS T2 ON T1.technician_ID  =  T2.technician_ID GROUP BY T2.Name", "source_tables": ["repair_assignment", "technician"], "pred_sql": "SELECT technician.Name, COUNT(repair_assignment.Machine_ID) AS machine_count\nFROM technician\nLEFT JOIN repair_assignment ON technician.technician_id = repair_assignment.technician_id\nGROUP BY technician.Name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the number of repair assignments handled by each technician. It joins the 'repair_assignment' table with the 'technician' table to associate each assignment with the technician's name. The result is grouped by the technician's name, allowing for a count of assignments per technician.\",\n    \"1\": \"This virtual table retrieves the starting years of technicians from the 'technician' table who belong to two specific teams. The placeholders in the WHERE clause represent the identifiers for the teams being compared.\"\n}\n"}
{"sample_id": "train.2328", "db_id": "csu_1", "question": "Find all the campuses opened in 1958.", "rationale": ["Identify the relevant table: Campuses, as it contains information about the year campuses were opened.", "Focus on the 'Year' column to filter campuses opened in 1958.", "Construct the SQL query to select the 'Campus' from the 'Campuses' table where the 'Year' is '1958'."], "gold_sql": "SELECT campus FROM campuses WHERE YEAR  =  1958", "source_tables": ["campuses"], "pred_sql": "SELECT Campus FROM Campuses WHERE Year = '1958';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\",\n    \"1\": \"This virtual table summarizes the total number of degrees awarded for each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.\",\n    \"2\": \"This virtual table summarizes the total number of degrees awarded by campus for a specific county and year range. The placeholders in the WHERE clause represent the county name and the minimum year for filtering the data.\"\n}\n"}
{"sample_id": "train.2334", "db_id": "csu_1", "question": "Find the name of the campuses that is in Northridge, Los Angeles or in San Francisco, San Francisco.", "rationale": ["Identify the relevant table: The 'Campuses' table contains the information about campus names and their locations.", "Determine the conditions: We need to find campuses that are either in 'Northridge, Los Angeles' or in 'San Francisco, San Francisco'.", "Construct the SQL query: Use a SELECT statement to retrieve the 'Campus' column from the 'Campuses' table, applying a WHERE clause to filter based on the specified locations and counties. The OR operator is used to combine the two conditions."], "gold_sql": "SELECT campus FROM campuses WHERE LOCATION  =  'Northridge' AND county  =  'Los Angeles' UNION SELECT campus FROM campuses WHERE LOCATION  =  'San Francisco' AND county  =  'San Francisco'", "source_tables": ["campuses"], "pred_sql": "SELECT Campus FROM Campuses WHERE (Location = 'Northridge' AND County = 'Los Angeles') OR (Location = 'San Francisco' AND County = 'San Francisco');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\",\n    \"1\": \"This virtual table retrieves the names of campuses from the 'Campuses' table that are located in a specific geographical location and county. The query uses placeholders for the location and county to allow for flexible input.\",\n    \"2\": \"This virtual table lists the campuses from the 'Campuses' table that have a number of faculty members within a specified range. The query joins the 'Campuses' table with the 'faculty' table based on the campus identifier, and filters the results based on the number of faculty members and the year of the data record. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the specific year.\"\n}\n"}
{"sample_id": "train.2350", "db_id": "csu_1", "question": "Which campus has the most faculties in year 2003?", "rationale": ["Identify the relevant tables: 'Campuses' and 'faculty' are needed to find the campus with the most faculty members.", "Join the 'Campuses' table with the 'faculty' table on the campus identifier to combine campus names with their respective faculty counts.", "Filter the results to only include records from the year 2003, as specified in the question.", "Order the results by the number of faculty members in descending order to get the campus with the most faculty at the top.", "Limit the results to 1 to get only the campus with the highest number of faculty members."], "gold_sql": "SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  2003 ORDER BY T2.faculty DESC LIMIT 1", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT c.Campus, f.Faculty \nFROM Campuses c \nJOIN faculty f ON c.Id = f.Campus \nWHERE f.Year = 2003 \nORDER BY f.Faculty DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\",\n    \"1\": \"This virtual table lists the campuses from the 'Campuses' table that have a number of faculty members within a specified range. The query joins the 'Campuses' table with the 'faculty' table based on the campus identifier, and filters the results based on the number of faculty members and the year of the data record. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the specific year.\",\n    \"2\": \"This virtual table summarizes the total number of degrees awarded for each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.\"\n}\n"}
{"sample_id": "train.2356", "db_id": "csu_1", "question": "report the total number of degrees granted between 1998 and 2002.", "rationale": ["Identify the relevant table: The 'degrees' table contains information about degrees awarded, including the year and the number of degrees.", "Determine the columns needed: We need to sum the 'Degrees' column to get the total number of degrees awarded.", "Apply the filter: We need to filter the records for the years between 1998 and 2002 using the WHERE clause with the BETWEEN operator.", "Construct the SQL query: Combine the SELECT statement with the SUM function and the WHERE clause to form the complete SQL query."], "gold_sql": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  1998 AND T2.year  <=  2002 GROUP BY T1.campus", "source_tables": ["degrees", "campuses"], "pred_sql": "SELECT SUM(Degrees) AS TotalDegrees\nFROM degrees\nWHERE Year BETWEEN '1998' AND '2002';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of degrees awarded for each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.\",\n    \"1\": \"This virtual table summarizes the total number of degrees awarded by campus for a specific county and year range. The placeholders in the WHERE clause represent the county name and the minimum year for filtering the data.\",\n    \"2\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\"\n}\n"}
{"sample_id": "train.2359", "db_id": "csu_1", "question": "What is the total number of degrees granted after 2000 for each Orange county campus?", "rationale": ["Identify the relevant tables: degrees and Campuses.", "We need to count the total number of degrees granted after the year 2000, so we will use the COUNT function on the Degrees column from the degrees table.", "We need to filter the results to only include campuses located in Orange county and degrees awarded after the year 2000.", "To achieve this, we will join the degrees table with the Campuses table on the Campus identifier.", "We will use a WHERE clause to filter for the county 'Orange' and years greater than 2000.", "Finally, we will group the results by the Campus name to get the total degrees for each campus."], "gold_sql": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  'Orange' AND T2.year  >=  2000 GROUP BY T1.campus", "source_tables": ["degrees", "campuses"], "pred_sql": "SELECT Campuses.Campus, COUNT(degrees.Degrees) AS TotalDegrees\nFROM degrees\nJOIN Campuses ON degrees.Campus = Campuses.Id\nWHERE Campuses.County = 'Orange' AND degrees.Year > '2000'\nGROUP BY Campuses.Campus;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of degrees awarded by campus for a specific county and year range. The placeholders in the WHERE clause represent the county name and the minimum year for filtering the data.\",\n    \"1\": \"This virtual table summarizes the total number of degrees awarded for each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.\",\n    \"2\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\"\n}\n"}
{"sample_id": "train.2362", "db_id": "csu_1", "question": "What campus had more than 400 total enrollment but more than 200 full time enrollment in year 1956?", "rationale": ["Identify the relevant tables: Campuses and enrollments.", "We need to find campuses with specific enrollment criteria: total enrollment greater than 400 and full-time equivalent (FTE) enrollment greater than 200.", "Join the Campuses table with the enrollments table on the campus identifier.", "Filter the results based on the specified conditions for total enrollment and FTE enrollment for the year 1956."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN enrollments AS t2 ON t1.id  =  t2.campus WHERE t2.year  =  1956 AND totalenrollment_ay  >  400 AND FTE_AY  >  200", "source_tables": ["enrollments", "campuses"], "pred_sql": "SELECT c.Campus \nFROM Campuses c \nJOIN enrollments e ON c.Id = e.Campus \nWHERE e.TotalEnrollment_AY > 400 \nAND e.FTE_AY > 200 \nAND e.Year = '1956';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\",\n    \"1\": \"This virtual table lists the campuses from the 'Campuses' table that have a number of faculty members within a specified range. The query joins the 'Campuses' table with the 'faculty' table based on the campus identifier, and filters the results based on the number of faculty members and the year of the data record. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the specific year.\",\n    \"2\": \"This virtual table summarizes the total number of degrees awarded for each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.\"\n}\n"}
{"sample_id": "train.2363", "db_id": "csu_1", "question": "What campus started in year 1956, has more than 200 full time students, and more than 400 students enrolled?", "rationale": ["Identify the relevant tables: Campuses, enrollments, and faculty are needed to answer the question.", "Join the Campuses table with the enrollments and faculty tables using the campus identifier.", "Filter the results to only include campuses that started in the year 1956.", "Add conditions to ensure that the full-time equivalent (FTE) enrollments are greater than 200 and total enrollments are greater than 400."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN enrollments AS t2 ON t1.id  =  t2.campus WHERE t2.year  =  1956 AND totalenrollment_ay  >  400 AND FTE_AY  >  200", "source_tables": ["enrollments", "campuses"], "pred_sql": "SELECT c.Campus, e.TotalEnrollment_AY, f.FTE_AY \nFROM Campuses c \nJOIN enrollments e ON c.Id = e.Campus \nJOIN faculty f ON c.Id = f.Campus \nWHERE c.Year = '1956' \nAND f.FTE_AY > '200' \nAND e.TotalEnrollment_AY > '400';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\",\n    \"1\": \"This virtual table summarizes the total number of degrees awarded for each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.\",\n    \"2\": \"This virtual table lists the campuses from the 'Campuses' table that have a number of faculty members within a specified range. The query joins the 'Campuses' table with the 'faculty' table based on the campus identifier, and filters the results based on the number of faculty members and the year of the data record. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the specific year.\"\n}\n"}
{"sample_id": "train.2366", "db_id": "csu_1", "question": "List the campuses in Los Angeles county.", "rationale": ["Identify the relevant table: The 'Campuses' table contains information about campuses, including their location and county.", "Determine the filtering criteria: We need to filter campuses based on the county, specifically 'Los Angeles'.", "Construct the SQL query: Use a SELECT statement to retrieve the 'Campus' names from the 'Campuses' table where the 'County' matches 'Los Angeles'."], "gold_sql": "SELECT campus FROM campuses WHERE county  =  'Los Angeles'", "source_tables": ["campuses"], "pred_sql": "SELECT Campus FROM Campuses WHERE County = 'Los Angeles';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the names of campuses from the 'Campuses' table that are located in a specific geographical location and county. The query uses placeholders for the location and county to allow for flexible input.\",\n    \"1\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\",\n    \"2\": \"This virtual table summarizes the total number of degrees awarded by campus for a specific county and year range. The placeholders in the WHERE clause represent the county name and the minimum year for filtering the data.\"\n}\n"}
{"sample_id": "train.2368", "db_id": "csu_1", "question": "How many degrees were conferred in \"San Jose State University\" in 2000?", "rationale": ["Identify the relevant tables: degrees and Campuses.", "We need to find the total number of degrees conferred, so we will use the SUM function on the Degrees column from the degrees table.", "We need to filter the results to only include degrees awarded in the year 2000, so we will add a WHERE clause for the Year column.", "We also need to filter by the specific campus, 'San Jose State University', so we will join the degrees table with the Campuses table on the Campus identifier and add another condition in the WHERE clause."], "gold_sql": "SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  'San Jose State University' AND t2.year  =  2000", "source_tables": ["degrees", "campuses"], "pred_sql": "SELECT SUM(Degrees) AS TotalDegreesConferred \nFROM degrees \nJOIN Campuses ON degrees.Campus = Campuses.Id \nWHERE Campuses.Campus = 'San Jose State University' AND degrees.Year = '2000';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of degrees awarded for each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.\",\n    \"1\": \"This virtual table summarizes the total number of degrees awarded by campus for a specific county and year range. The placeholders in the WHERE clause represent the county name and the minimum year for filtering the data.\",\n    \"2\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\"\n}\n"}
{"sample_id": "train.2374", "db_id": "csu_1", "question": "What is the number of faculty lines in campus \"Long Beach State University\" in 2002?", "rationale": ["Identify the relevant tables: 'faculty' for faculty data and 'Campuses' for campus names.", "Join the 'faculty' table with the 'Campuses' table on the campus identifier to filter by campus name.", "Filter the results to only include records for 'Long Beach State University' and the year 2002.", "Count the number of faculty lines for the specified campus and year."], "gold_sql": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  2002 AND T2.campus  =  'Long Beach State University'", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT COUNT(*) AS NumberOfFacultyLines \nFROM faculty f \nJOIN Campuses c ON f.Campus = c.Id \nWHERE c.Campus = 'Long Beach State University' AND f.Year = 2002;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\",\n    \"1\": \"This virtual table lists the campuses from the 'Campuses' table that have a number of faculty members within a specified range. The query joins the 'Campuses' table with the 'faculty' table based on the campus identifier, and filters the results based on the number of faculty members and the year of the data record. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the specific year.\",\n    \"2\": \"This virtual table summarizes the total number of degrees awarded for each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.\"\n}\n"}
{"sample_id": "train.2376", "db_id": "csu_1", "question": "How many faculty lines are there in \"San Francisco State University\" in year 2004?", "rationale": ["Identify the relevant tables: 'faculty' for faculty data and 'Campuses' for campus names.", "Join the 'faculty' table with the 'Campuses' table on the campus identifier to filter by campus name.", "Filter the results to only include records for 'San Francisco State University' and the year 2004.", "Count the number of faculty lines for the specified campus and year."], "gold_sql": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  2004 AND T2.campus  =  'San Francisco State University'", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT COUNT(*) AS FacultyCount \nFROM faculty f \nJOIN Campuses c ON f.Campus = c.Id \nWHERE c.Campus = 'San Francisco State University' AND f.Year = 2004;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\",\n    \"1\": \"This virtual table lists the campuses from the 'Campuses' table that have a number of faculty members within a specified range. The query joins the 'Campuses' table with the 'faculty' table based on the campus identifier, and filters the results based on the number of faculty members and the year of the data record. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the specific year.\",\n    \"2\": \"This virtual table summarizes the total number of degrees awarded for each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.\"\n}\n"}
{"sample_id": "train.2377", "db_id": "csu_1", "question": "How many faculty lines are there at San Francisco State University in 2004?", "rationale": ["Identify the relevant tables: 'faculty' for faculty data and 'Campuses' for campus names.", "Join the 'faculty' table with the 'Campuses' table on the campus identifier to access the campus name.", "Filter the results to only include records for 'San Francisco State University' and the year 2004.", "Count the number of faculty lines for the specified campus and year."], "gold_sql": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  2004 AND T2.campus  =  'San Francisco State University'", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT COUNT(*) AS FacultyCount \nFROM faculty \nJOIN Campuses ON faculty.Campus = Campuses.Id \nWHERE Campuses.Campus = 'San Francisco State University' AND faculty.Year = 2004;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\",\n    \"1\": \"This virtual table lists the campuses from the 'Campuses' table that have a number of faculty members within a specified range. The query joins the 'Campuses' table with the 'faculty' table based on the campus identifier, and filters the results based on the number of faculty members and the year of the data record. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the specific year.\",\n    \"2\": \"This virtual table summarizes the total number of degrees awarded for each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.\"\n}\n"}
{"sample_id": "train.2381", "db_id": "csu_1", "question": "How many faculty members did the university that conferred the most degrees in 2002 have?", "rationale": ["Identify the year of interest, which is 2002, for the degrees awarded.", "Determine which campus conferred the most degrees in 2002 by grouping the degrees table by campus and counting the number of degrees awarded, ordering by the count in descending order, and limiting the result to the top campus.", "Join the faculty table with the degrees table on the campus identifier to get the faculty count for the campus that awarded the most degrees in 2002.", "Select the faculty count for that specific campus."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2002 ORDER BY t3.degrees DESC LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "pred_sql": "SELECT f.Faculty \nFROM faculty f \nJOIN degrees d ON f.Campus = d.Campus \nWHERE d.Year = '2002' \nAND d.Campus = (SELECT d2.Campus \n                FROM degrees d2 \n                WHERE d2.Year = '2002' \n                GROUP BY d2.Campus \n                ORDER BY COUNT(d2.Degrees) DESC \n                LIMIT 1)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\",\n    \"1\": \"This virtual table summarizes the total number of degrees awarded for each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.\",\n    \"2\": \"This virtual table summarizes the total number of degrees awarded by campus for a specific county and year range. The placeholders in the WHERE clause represent the county name and the minimum year for filtering the data.\"\n}\n"}
{"sample_id": "train.2382", "db_id": "csu_1", "question": "How many faculty lines are there in the university that conferred the least number of degrees in year 2001?", "rationale": ["Identify the year of interest, which is 2001, to filter the degrees awarded.", "Join the faculty table with the degrees table on the Campus identifier to correlate faculty data with degree data.", "Group the results by campus to count the number of degrees awarded for each campus in 2001.", "Order the campuses by the count of degrees awarded in ascending order to find the campus with the least number of degrees conferred.", "Limit the results to 1 to get only the campus with the least number of degrees awarded.", "Count the number of faculty lines associated with that campus."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2001 ORDER BY t3.degrees LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "pred_sql": "SELECT COUNT(faculty.Campus) AS FacultyCount\nFROM faculty\nJOIN degrees ON faculty.Campus = degrees.Campus\nWHERE degrees.Year = '2001'\nGROUP BY faculty.Campus\nORDER BY COUNT(degrees.Degrees) ASC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\",\n    \"1\": \"This virtual table summarizes the total number of degrees awarded for each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.\",\n    \"2\": \"This virtual table summarizes the total number of degrees awarded by campus for a specific county and year range. The placeholders in the WHERE clause represent the county name and the minimum year for filtering the data.\"\n}\n"}
{"sample_id": "train.2383", "db_id": "csu_1", "question": "How many faculty members are at the university that gave the least number of degrees in 2001?", "rationale": ["Identify the year of interest, which is 2001, for both degrees and faculty.", "Create a subquery to count the total number of degrees awarded for each campus in 2001.", "Order the results of the subquery by the total number of degrees in ascending order to find the campus with the least degrees awarded.", "Limit the results of the subquery to 1 to get only the campus with the least degrees.", "Join the faculty table with the subquery on the campus identifier to get the faculty count for that campus.", "Select the faculty count for the campus that awarded the least number of degrees in 2001."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2001 ORDER BY t3.degrees LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "pred_sql": "SELECT f.Faculty \nFROM faculty f \nJOIN (\n    SELECT Campus, COUNT(Degrees) AS TotalDegrees \n    FROM degrees \n    WHERE Year = '2001' \n    GROUP BY Campus \n    ORDER BY TotalDegrees ASC \n    LIMIT 1\n) d ON f.Campus = d.Campus \nWHERE f.Year = '2001';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\",\n    \"1\": \"This virtual table summarizes the total number of degrees awarded for each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.\",\n    \"2\": \"This virtual table summarizes the total number of degrees awarded by campus for a specific county and year range. The placeholders in the WHERE clause represent the county name and the minimum year for filtering the data.\"\n}\n"}
{"sample_id": "train.2385", "db_id": "csu_1", "question": "How many undergraduates are there at San Jose State", "rationale": ["Identify the relevant table for undergraduate enrollments, which is 'discipline_enrollments'.", "Determine the specific campus of interest, which is 'San Jose State'.", "Use a subquery to find the 'Id' of 'San Jose State' from the 'Campuses' table.", "Sum the 'Undergraduate' column from the 'discipline_enrollments' table where the 'Campus' matches the 'Id' of 'San Jose State'."], "gold_sql": "SELECT sum(t1.undergraduate) FROM discipline_enrollments AS t1 JOIN campuses AS t2 ON t1.campus  =  t2.id WHERE t1.year  =  2004 AND t2.campus  =  'San Jose State University'", "source_tables": ["discipline_enrollments", "campuses"], "pred_sql": "SELECT SUM(Undergraduate) AS TotalUndergraduates\nFROM discipline_enrollments\nWHERE Campus = (SELECT Id FROM Campuses WHERE Campus = 'San Jose State');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\",\n    \"1\": \"This virtual table summarizes the total number of degrees awarded for each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.\",\n    \"2\": \"This virtual table summarizes the total number of degrees awarded by campus for a specific county and year range. The placeholders in the WHERE clause represent the county name and the minimum year for filtering the data.\"\n}\n"}
{"sample_id": "train.2397", "db_id": "candidate_poll", "question": "Return the poll resource associated with the most candidates.", "rationale": ["Identify the relevant table: The 'candidate' table contains the 'Poll_Source' and 'Candidate_ID' columns needed for this query.", "Count the number of candidates associated with each poll source: Use COUNT(Candidate_ID) to count the candidates for each Poll_Source.", "Group the results by Poll_Source: Use GROUP BY Poll_Source to aggregate the counts for each source.", "Order the results by the count of candidates in descending order: Use ORDER BY Candidate_Count DESC to get the poll source with the most candidates at the top.", "Limit the results to the top entry: Use LIMIT 1 to return only the poll source associated with the most candidates."], "gold_sql": "SELECT poll_source FROM candidate GROUP BY poll_source ORDER BY count(*) DESC LIMIT 1", "source_tables": ["candidate"], "pred_sql": "SELECT Poll_Source, COUNT(Candidate_ID) AS Candidate_Count\nFROM candidate\nGROUP BY Poll_Source\nORDER BY Candidate_Count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the support, consideration, and opposition rates of candidates from the 'candidate' table, ordered by the rate of respondents who are unsure about the candidates. The placeholders in the SELECT clause represent the respective rates of support, consideration, and opposition.\",\n    \"1\": \"This virtual table provides the support, consideration, and opposition rates of candidates from the 'candidate' table, ordered by the rate of respondents who are unsure about the candidates. The placeholders in the SELECT clause represent the respective rates of support, consideration, and opposition.\"\n}\n"}
{"sample_id": "train.2405", "db_id": "candidate_poll", "question": "Return the poll source corresponding to the candidate who has the oppose rate.", "rationale": ["Identify the relevant table: The 'candidate' table contains the 'Poll_Source' and 'Oppose_rate' columns.", "Determine the condition: We need to find candidates who have an oppose rate, which implies checking for non-null values in the 'Oppose_rate' column.", "Construct the SQL query: We will select the 'Poll_Source' from the 'candidate' table where the 'Oppose_rate' is not null."], "gold_sql": "SELECT poll_source FROM candidate ORDER BY oppose_rate DESC LIMIT 1", "source_tables": ["candidate"], "pred_sql": "SELECT Poll_Source FROM candidate WHERE Oppose_rate IS NOT NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the support, consideration, and opposition rates of candidates from the 'candidate' table, ordered by the rate of respondents who are unsure about the candidates. The placeholders in the SELECT clause represent the respective rates of support, consideration, and opposition.\",\n    \"1\": \"This virtual table provides the support, consideration, and opposition rates of candidates from the 'candidate' table, ordered by the rate of respondents who are unsure about the candidates. The placeholders in the SELECT clause represent the respective rates of support, consideration, and opposition.\"\n}\n"}
{"sample_id": "train.2417", "db_id": "candidate_poll", "question": "For each sex, what is the name and sex of the candidate with the oppose rate for their sex?", "rationale": ["Identify the relevant tables: 'candidate' for candidate data and 'people' for personal details.", "Join the 'candidate' table with the 'people' table on the 'People_ID' to access both candidate and personal information.", "We need to find the candidate with the highest oppose rate for each sex. This requires a subquery to find the maximum oppose rate for each sex.", "The subquery selects the maximum oppose rate from the 'candidate' table, grouped by the sex of the candidates.", "The main query selects the name and sex of the candidates whose oppose rate matches the maximum oppose rate for their respective sex.", "Finally, order the results by sex to group the candidates accordingly."], "gold_sql": "SELECT t1.name ,  t1.sex ,  min(oppose_rate) FROM people AS t1 JOIN candidate AS t2 ON t1.people_id  =  t2.people_id GROUP BY t1.sex", "source_tables": ["candidate", "people"], "pred_sql": "SELECT p.Name, p.Sex, c.Oppose_rate \nFROM candidate c \nJOIN people p ON c.People_ID = p.People_ID \nWHERE c.Oppose_rate = (SELECT MAX(Oppose_rate) \n                       FROM candidate c2 \n                       JOIN people p2 ON c2.People_ID = p2.People_ID \n                       WHERE p2.Sex = p.Sex) \nORDER BY p.Sex;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the support, consideration, and opposition rates of candidates from the 'candidate' table, ordered by the rate of respondents who are unsure about the candidates. The placeholders in the SELECT clause represent the respective rates of support, consideration, and opposition.\",\n    \"1\": \"This virtual table provides the support, consideration, and opposition rates of candidates from the 'candidate' table, ordered by the rate of respondents who are unsure about the candidates. The placeholders in the SELECT clause represent the respective rates of support, consideration, and opposition.\"\n}\n"}
{"sample_id": "train.2434", "db_id": "movie_1", "question": "Find the titles of all movies directed by steven spielberg.", "rationale": ["Identify the relevant table: The 'Movie' table contains the information about movie titles and their directors.", "Determine the required columns: We need the 'title' column from the 'Movie' table.", "Specify the condition: We want movies directed by 'steven spielberg', so we will filter the results where the 'director' column matches 'steven spielberg'.", "Construct the SQL query: Using the SELECT statement to retrieve the titles from the Movie table with the specified condition."], "gold_sql": "SELECT title FROM Movie WHERE director = 'Steven Spielberg'", "source_tables": ["movie"], "pred_sql": "SELECT title FROM Movie WHERE director = 'steven spielberg';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the titles and directors of movies from the 'Movie' table that have the same director but different titles. The query uses a self-join on the 'Movie' table to compare movies directed by the same person, ensuring that the titles are not the same. The results are ordered by the director's name and the movie title.\",\n    \"1\": \"This virtual table provides a summary of movie ratings, displaying the title of each movie, the number of stars given, the director's name, and the minimum star rating for each director. The data is aggregated by director, allowing for a comparison of the lowest ratings received by movies directed by the same individual.\",\n    \"2\": \"This virtual table describes the titles of movies that have received a specific number of stars from two different reviewers. The placeholders in the WHERE clause represent the star ratings given by the reviewers.\"\n}\n"}
{"sample_id": "train.2461", "db_id": "movie_1", "question": "What are the different names of all reviewers whose ratings do not have a date field?", "rationale": ["Identify the tables involved: Reviewer and Rating.", "We need to find reviewers whose ratings do not have a date field, which means we need to check for NULL values in the ratingDate column of the Rating table.", "Join the Reviewer table with the Rating table on the reviewer ID (rID) to access the names of the reviewers along with their ratings.", "Use a SELECT DISTINCT statement to ensure we get unique reviewer names.", "Apply a WHERE clause to filter the results where the ratingDate is NULL."], "gold_sql": "SELECT DISTINCT name FROM Reviewer AS T1 JOIN Rating AS T2 ON T1.rID  =  T2.rID WHERE ratingDate  =  'null'", "source_tables": ["rating", "reviewer"], "pred_sql": "SELECT DISTINCT Reviewer.name \nFROM Reviewer \nJOIN Rating ON Reviewer.rID = Rating.rID \nWHERE Rating.ratingDate IS NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of movie ratings by reviewers. It displays the title of the movie, the unique identifier of the reviewer, the number of stars given in the rating, and the minimum stars given by each reviewer. The placeholders represent the relevant identifiers and ratings.\",\n    \"1\": \"This virtual table provides the average star ratings of movies from the 'Rating' table, excluding those rated by a specific reviewer. The placeholder in the subquery represents the reviewer's name whose ratings are to be excluded.\",\n    \"2\": \"This virtual table provides the average star ratings of movies from the 'Rating' table, excluding those rated by a specific reviewer. The placeholder in the subquery represents the reviewer's name whose ratings are to be excluded.\"\n}\n"}
{"sample_id": "train.2476", "db_id": "movie_1", "question": "Find the names of all reviewers who rated Gone with the Wind.", "rationale": ["Identify the tables involved: Movie, Reviewer, and Rating.", "We need to find the names of reviewers, so we will select the 'name' column from the Reviewer table.", "To link reviewers to their ratings, we will use the Rating table, which connects reviewers to movies via rID.", "We also need to filter the results to only include ratings for the movie 'Gone with the Wind', which requires joining the Movie table and using a WHERE clause to specify the title.", "The final SQL query will join these tables and apply the necessary filters to retrieve the desired information."], "gold_sql": "SELECT DISTINCT T3.name FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID JOIN Reviewer AS T3 ON T1.rID  =  T3.rID WHERE T2.title  =  'Gone with the Wind'", "source_tables": ["rating", "movie", "reviewer"], "pred_sql": "SELECT Reviewer.name \nFROM Reviewer \nJOIN Rating ON Reviewer.rID = Rating.rID \nJOIN Movie ON Rating.mID = Movie.mID \nWHERE Movie.title = 'Gone with the Wind';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of movie ratings by reviewers. It displays the title of the movie, the unique identifier of the reviewer, the number of stars given in the rating, and the minimum stars given by each reviewer. The placeholders represent the relevant identifiers and ratings.\",\n    \"1\": \"This virtual table provides a summary of movie ratings, displaying the title of each movie, the number of stars given, the director's name, and the minimum star rating for each director. The data is aggregated by director, allowing for a comparison of the lowest ratings received by movies directed by the same individual.\",\n    \"2\": \"This virtual table describes the titles of movies that have received a specific number of stars from two different reviewers. The placeholders in the WHERE clause represent the star ratings given by the reviewers.\"\n}\n"}
{"sample_id": "train.2483", "db_id": "movie_1", "question": "What are the names of all the reviewers and movie names?", "rationale": ["We need to retrieve the names of all reviewers and the titles of the movies they rated.", "To do this, we will join the Reviewer table with the Rating table on the reviewer ID (rID).", "Next, we will join the resulting table with the Movie table on the movie ID (mID) to get the movie titles.", "The final SQL query will select the reviewer's name and the movie title from the joined tables."], "gold_sql": "SELECT name FROM Reviewer UNION SELECT title FROM Movie", "source_tables": ["movie", "reviewer"], "pred_sql": "SELECT Reviewer.name, Movie.title\nFROM Reviewer\nJOIN Rating ON Reviewer.rID = Rating.rID\nJOIN Movie ON Rating.mID = Movie.mID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of movie ratings by reviewers. It displays the title of the movie, the unique identifier of the reviewer, the number of stars given in the rating, and the minimum stars given by each reviewer. The placeholders represent the relevant identifiers and ratings.\",\n    \"1\": \"This virtual table describes the titles of movies that have received a specific number of stars from two different reviewers. The placeholders in the WHERE clause represent the star ratings given by the reviewers.\",\n    \"2\": \"This virtual table provides a summary of movie ratings, displaying the title of each movie, the number of stars given, the director's name, and the minimum star rating for each director. The data is aggregated by director, allowing for a comparison of the lowest ratings received by movies directed by the same individual.\"\n}\n"}
{"sample_id": "train.2495", "db_id": "movie_1", "question": "For each director, how many reviews have they received?", "rationale": ["We need to find out how many reviews each director has received.", "To do this, we will join the Movie table with the Rating table on the movie ID (mID).", "We will select the director's name from the Movie table and count the number of ratings (reviews) from the Rating table.", "The COUNT function will be used to count the number of reviews for each director.", "Finally, we will group the results by the director's name to get the total count of reviews for each director."], "gold_sql": "SELECT count(*) ,  T1.director FROM Movie AS T1 JOIN Rating AS T2 ON T1.mID  =  T2.mID GROUP BY T1.director", "source_tables": ["rating", "movie"], "pred_sql": "SELECT Movie.director, COUNT(Rating.rID) AS review_count\nFROM Movie\nJOIN Rating ON Movie.mID = Rating.mID\nGROUP BY Movie.director;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of movie ratings, displaying the title of each movie, the number of stars given, the director's name, and the minimum star rating for each director. The data is aggregated by director, allowing for a comparison of the lowest ratings received by movies directed by the same individual.\",\n    \"1\": \"This virtual table provides a summary of movie ratings by reviewers. It displays the title of the movie, the unique identifier of the reviewer, the number of stars given in the rating, and the minimum stars given by each reviewer. The placeholders represent the relevant identifiers and ratings.\",\n    \"2\": \"This virtual table describes the titles of movies that have received a specific number of stars from two different reviewers. The placeholders in the WHERE clause represent the star ratings given by the reviewers.\"\n}\n"}
{"sample_id": "train.2500", "db_id": "movie_1", "question": "What are the names and years of the movies that has the top 3 highest rating star?", "rationale": ["Identify the main goal: to find the names and years of movies with the top 3 highest ratings.", "The relevant tables are Movie and Rating, as we need movie details and their ratings.", "To get the top 3 highest ratings, we will first query the Rating table, ordering by the stars in descending order and limiting the results to 3.", "We will then use the mID from this subquery to filter the Movie table to get the corresponding titles and years.", "The final SQL query will select the title and year from the Movie table where the mID matches the top 3 ratings from the Rating table."], "gold_sql": "SELECT T2.title ,  T2.year FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID ORDER BY T1.stars DESC LIMIT 3", "source_tables": ["rating", "movie"], "pred_sql": "SELECT title, year \nFROM Movie \nWHERE mID IN (\n    SELECT mID \n    FROM Rating \n    ORDER BY stars DESC \n    LIMIT 3\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the titles of movies that have received a specific number of stars from two different reviewers. The placeholders in the WHERE clause represent the star ratings given by the reviewers.\",\n    \"1\": \"This virtual table provides a summary of movie ratings, displaying the title of each movie, the number of stars given, the director's name, and the minimum star rating for each director. The data is aggregated by director, allowing for a comparison of the lowest ratings received by movies directed by the same individual.\",\n    \"2\": \"This virtual table provides a summary of movie ratings by reviewers. It displays the title of the movie, the unique identifier of the reviewer, the number of stars given in the rating, and the minimum stars given by each reviewer. The placeholders represent the relevant identifiers and ratings.\"\n}\n"}
{"sample_id": "train.2502", "db_id": "movie_1", "question": "For each director, return the director's name together with the title of the movie they directed that received the highest rating among all of their movies, and the value of that rating. Ignore movies whose director is NULL.", "rationale": ["We need to retrieve the director's name, the title of the movie they directed, and the highest rating for that movie.", "We will join the Movie table with the Rating table on the movie ID (mID) to access the ratings for each movie.", "We will filter out any movies where the director is NULL using a WHERE clause.", "To find the highest rating for each director, we will use the MAX function on the stars column from the Rating table.", "We will group the results by director and title to ensure we get the highest rating for each movie directed by the same director.", "Finally, we will use a HAVING clause to ensure that we only return the movie with the highest rating for each director. This involves a subquery that finds the maximum stars for movies directed by the same director."], "gold_sql": "SELECT T2.title ,  T1.stars ,  T2.director ,  max(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE director != 'null' GROUP BY director", "source_tables": ["rating", "movie"], "pred_sql": "SELECT m.director, m.title, MAX(r.stars) AS highest_rating\nFROM Movie m\nJOIN Rating r ON m.mID = r.mID\nWHERE m.director IS NOT NULL\nGROUP BY m.director, m.title\nHAVING MAX(r.stars) = (SELECT MAX(stars) FROM Rating WHERE mID IN (SELECT mID FROM Movie WHERE director = m.director))", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of movie ratings, displaying the title of each movie, the number of stars given, the director's name, and the minimum star rating for each director. The data is aggregated by director, allowing for a comparison of the lowest ratings received by movies directed by the same individual.\",\n    \"1\": \"This virtual table lists the titles and directors of movies from the 'Movie' table that have the same director but different titles. The query uses a self-join on the 'Movie' table to compare movies directed by the same person, ensuring that the titles are not the same. The results are ordered by the director's name and the movie title.\",\n    \"2\": \"This virtual table provides the unique movie identifiers along with the average star ratings from the 'Rating' table. It groups the results by movie ID and filters to include only those movies that have received a minimum number of ratings, as specified by the placeholder.\"\n}\n"}
{"sample_id": "train.2503", "db_id": "movie_1", "question": "For each director, what are the titles and ratings for all the movies they reviewed?", "rationale": ["We need to retrieve the titles of movies, their ratings, and the names of the directors.", "The relevant tables are Movie, Rating, and Reviewer.", "We will join the Movie table with the Rating table on the movie ID (mID) to get the ratings for each movie.", "Next, we will join the Reviewer table on the reviewer ID (rID) to associate the ratings with the reviewers.", "Finally, we will select the title of the movie, the stars given in the rating, and the director's name.", "To organize the results, we will order the output by director and then by movie title."], "gold_sql": "SELECT T2.title ,  T1.stars ,  T2.director ,  max(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE director != 'null' GROUP BY director", "source_tables": ["rating", "movie"], "pred_sql": "SELECT Movie.title, Rating.stars, Movie.director \nFROM Movie \nJOIN Rating ON Movie.mID = Rating.mID \nJOIN Reviewer ON Rating.rID = Reviewer.rID \nORDER BY Movie.director, Movie.title;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of movie ratings, displaying the title of each movie, the number of stars given, the director's name, and the minimum star rating for each director. The data is aggregated by director, allowing for a comparison of the lowest ratings received by movies directed by the same individual.\",\n    \"1\": \"This virtual table provides a summary of movie ratings by reviewers. It displays the title of the movie, the unique identifier of the reviewer, the number of stars given in the rating, and the minimum stars given by each reviewer. The placeholders represent the relevant identifiers and ratings.\",\n    \"2\": \"This virtual table describes the titles of movies that have received a specific number of stars from two different reviewers. The placeholders in the WHERE clause represent the star ratings given by the reviewers.\"\n}\n"}
{"sample_id": "train.2505", "db_id": "movie_1", "question": "For each reviewer id, what is the title and rating for the movie with the smallest rating?", "rationale": ["We need to find the title and rating for the movie with the smallest rating for each reviewer id.", "To achieve this, we will first identify the minimum rating for each reviewer using a subquery that groups by reviewer id (rID) and selects the minimum stars.", "Next, we will join this result with the Rating table to get the corresponding movie id (mID) and stars for each reviewer.", "Finally, we will join the resulting table with the Movie table to get the title of the movie associated with each rating.", "The final query will select the reviewer id, movie title, and the minimum stars from the joined tables."], "gold_sql": "SELECT T2.title ,  T1.rID ,  T1.stars ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.rID", "source_tables": ["rating", "movie"], "pred_sql": "SELECT r.rID, m.title, r.stars \nFROM Rating r \nJOIN Movie m ON r.mID = m.mID \nWHERE (r.rID, r.stars) IN (\n    SELECT r2.rID, MIN(r2.stars) \n    FROM Rating r2 \n    GROUP BY r2.rID\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of movie ratings by reviewers. It displays the title of the movie, the unique identifier of the reviewer, the number of stars given in the rating, and the minimum stars given by each reviewer. The placeholders represent the relevant identifiers and ratings.\",\n    \"1\": \"This virtual table provides a summary of movie ratings, displaying the title of each movie, the number of stars given, the director's name, and the minimum star rating for each director. The data is aggregated by director, allowing for a comparison of the lowest ratings received by movies directed by the same individual.\",\n    \"2\": \"This virtual table describes the titles of movies that have received a specific number of stars from two different reviewers. The placeholders in the WHERE clause represent the star ratings given by the reviewers.\"\n}\n"}
{"sample_id": "train.2507", "db_id": "movie_1", "question": "For each director, what is the title and score of their most poorly rated movie?", "rationale": ["We need to find the title and score of the most poorly rated movie for each director.", "To do this, we will join the Movie table with the Rating table on the movie ID (mID).", "We will select the title of the movie, the director's name, and the minimum star rating for each movie.", "We will group the results by director and movie title to aggregate the ratings.", "To find the most poorly rated movie for each director, we will use a HAVING clause to filter the results to only include movies that have the minimum star rating for that director."], "gold_sql": "SELECT T2.title ,  T1.stars ,  T2.director ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T2.director", "source_tables": ["rating", "movie"], "pred_sql": "SELECT m.title, m.director, MIN(r.stars) AS min_stars\nFROM Movie m\nJOIN Rating r ON m.mID = r.mID\nGROUP BY m.director, m.title\nHAVING min_stars = (SELECT MIN(stars) FROM Rating WHERE mID = m.mID)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of movie ratings, displaying the title of each movie, the number of stars given, the director's name, and the minimum star rating for each director. The data is aggregated by director, allowing for a comparison of the lowest ratings received by movies directed by the same individual.\",\n    \"1\": \"This virtual table provides a summary of movie ratings by reviewers. It displays the title of the movie, the unique identifier of the reviewer, the number of stars given in the rating, and the minimum stars given by each reviewer. The placeholders represent the relevant identifiers and ratings.\",\n    \"2\": \"This virtual table describes the titles of movies that have received a specific number of stars from two different reviewers. The placeholders in the WHERE clause represent the star ratings given by the reviewers.\"\n}\n"}
{"sample_id": "train.2508", "db_id": "movie_1", "question": "What is the name of the movie that is rated by most of times?", "rationale": ["Identify the goal: We need to find the name of the movie that has been rated the most times.", "To achieve this, we will use the Rating table to count the number of ratings for each movie.", "We will group the results by movie ID (mID) to aggregate the ratings for each movie.", "Next, we will order the grouped results by the count of ratings in descending order to get the movie with the highest count at the top.", "Finally, we will limit the results to just one movie to get the top-rated movie.", "We will then select the title of that movie from the Movie table using the mID obtained from the previous step."], "gold_sql": "SELECT T2.title ,  T1.mID FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY count(*) DESC LIMIT 1", "source_tables": ["rating", "movie"], "pred_sql": "SELECT title FROM Movie WHERE mID IN (SELECT mID FROM Rating GROUP BY mID ORDER BY COUNT(*) DESC LIMIT 1);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the titles of movies that have received a specific number of stars from two different reviewers. The placeholders in the WHERE clause represent the star ratings given by the reviewers.\",\n    \"1\": \"This virtual table provides a summary of movie ratings, displaying the title of each movie, the number of stars given, the director's name, and the minimum star rating for each director. The data is aggregated by director, allowing for a comparison of the lowest ratings received by movies directed by the same individual.\",\n    \"2\": \"This virtual table provides a summary of movie ratings by reviewers. It displays the title of the movie, the unique identifier of the reviewer, the number of stars given in the rating, and the minimum stars given by each reviewer. The placeholders represent the relevant identifiers and ratings.\"\n}\n"}
{"sample_id": "train.2509", "db_id": "movie_1", "question": "What is the name of the movie that has been reviewed the most?", "rationale": ["To find the movie that has been reviewed the most, we need to count the number of reviews for each movie.", "We can achieve this by using the Rating table, where each entry corresponds to a review for a movie.", "We will group the results by the movie ID (mID) to count how many reviews each movie has received.", "Next, we will order these counts in descending order so that the movie with the most reviews comes first.", "Finally, we will limit the results to just one entry to get the top movie with the most reviews.", "We will then select the title of that movie from the Movie table using the mID obtained from the previous query."], "gold_sql": "SELECT T2.title ,  T1.mID FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY count(*) DESC LIMIT 1", "source_tables": ["rating", "movie"], "pred_sql": "SELECT title\nFROM Movie\nWHERE mID IN (\n    SELECT mID\n    FROM Rating\n    GROUP BY mID\n    ORDER BY COUNT(rID) DESC\n    LIMIT 1\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the titles of movies that have received a specific number of stars from two different reviewers. The placeholders in the WHERE clause represent the star ratings given by the reviewers.\",\n    \"1\": \"This virtual table provides a summary of movie ratings by reviewers. It displays the title of the movie, the unique identifier of the reviewer, the number of stars given in the rating, and the minimum stars given by each reviewer. The placeholders represent the relevant identifiers and ratings.\",\n    \"2\": \"This virtual table provides a summary of movie ratings, displaying the title of each movie, the number of stars given, the director's name, and the minimum star rating for each director. The data is aggregated by director, allowing for a comparison of the lowest ratings received by movies directed by the same individual.\"\n}\n"}
{"sample_id": "train.2517", "db_id": "movie_1", "question": "What are the ids of all moviest hat have not been reviewed by Britanny Harris?", "rationale": ["Identify the movies that have not been reviewed by Britanny Harris.", "To do this, we need to find the IDs of the movies that have ratings from reviewers.", "We will first find the rID of Britanny Harris from the Reviewer table.", "Next, we will find all mIDs from the Rating table where the rID matches Britanny Harris's rID.", "Finally, we will select all mIDs from the Movie table that are not in the list of mIDs found in the previous step."], "gold_sql": "SELECT mID FROM Rating EXCEPT SELECT T1.mID FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T2.name  =  'Brittany Harris'", "source_tables": ["rating", "reviewer"], "pred_sql": "SELECT mID FROM Movie WHERE mID NOT IN (SELECT mID FROM Rating WHERE rID = (SELECT rID FROM Reviewer WHERE name = 'Britanny Harris'));", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of movie ratings by reviewers. It displays the title of the movie, the unique identifier of the reviewer, the number of stars given in the rating, and the minimum stars given by each reviewer. The placeholders represent the relevant identifiers and ratings.\",\n    \"1\": \"This virtual table describes the titles of movies that have received a specific number of stars from two different reviewers. The placeholders in the WHERE clause represent the star ratings given by the reviewers.\",\n    \"2\": \"This virtual table provides the unique movie identifiers along with the average star ratings from the 'Rating' table. It groups the results by movie ID and filters to include only those movies that have received a minimum number of ratings, as specified by the placeholder.\"\n}\n"}
{"sample_id": "train.2518", "db_id": "movie_1", "question": "Find the average rating star for each movie that received at least 2 ratings.", "rationale": ["We need to find the average rating star for each movie that received at least 2 ratings.", "To do this, we will join the 'Movie' table with the 'Rating' table on the movie ID (mID).", "We will select the movie title and calculate the average of the stars given in the ratings using AVG(Rating.stars).", "We will group the results by the movie ID to ensure we get the average rating for each movie.", "Finally, we will use the HAVING clause to filter the results to include only those movies that have received at least 2 ratings, which we can count using COUNT(Rating.rID)."], "gold_sql": "SELECT mID ,  avg(stars) FROM Rating GROUP BY mID HAVING count(*)  >=  2", "source_tables": ["rating"], "pred_sql": "SELECT Movie.title, AVG(Rating.stars) AS average_rating\nFROM Movie\nJOIN Rating ON Movie.mID = Rating.mID\nGROUP BY Movie.mID\nHAVING COUNT(Rating.rID) >= 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the unique movie identifiers along with the average star ratings from the 'Rating' table. It groups the results by movie ID and filters to include only those movies that have received a minimum number of ratings, as specified by the placeholder.\",\n    \"1\": \"This virtual table describes the titles of movies that have received a specific number of stars from two different reviewers. The placeholders in the WHERE clause represent the star ratings given by the reviewers.\",\n    \"2\": \"This virtual table provides a summary of movie ratings, displaying the title of each movie, the number of stars given, the director's name, and the minimum star rating for each director. The data is aggregated by director, allowing for a comparison of the lowest ratings received by movies directed by the same individual.\"\n}\n"}
{"sample_id": "train.2528", "db_id": "movie_1", "question": "What are the names of reviewers who had rated 3 star and 4 star?", "rationale": ["We need to find the names of reviewers who rated movies with 3 stars and 4 stars.", "To do this, we will join the Reviewer table with the Rating table on the reviewer ID (rID).", "We will select the distinct names of reviewers to avoid duplicates.", "In the WHERE clause, we will filter the ratings to include only those that are either 3 or 4 stars."], "gold_sql": "SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T1.stars  =  3 INTERSECT SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T1.stars  =  4", "source_tables": ["rating", "reviewer"], "pred_sql": "SELECT DISTINCT Reviewer.name \nFROM Reviewer \nJOIN Rating ON Reviewer.rID = Rating.rID \nWHERE Rating.stars IN ('3', '4');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of movie ratings by reviewers. It displays the title of the movie, the unique identifier of the reviewer, the number of stars given in the rating, and the minimum stars given by each reviewer. The placeholders represent the relevant identifiers and ratings.\",\n    \"1\": \"This virtual table describes the titles of movies that have received a specific number of stars from two different reviewers. The placeholders in the WHERE clause represent the star ratings given by the reviewers.\",\n    \"2\": \"This virtual table describes the names of reviewers who have given a specific number of stars to movies. The query uses an INTERSECT operation to find reviewers who rated two different movies with the same star rating. The placeholders in the WHERE clause represent the number of stars given in the ratings.\"\n}\n"}
{"sample_id": "train.2530", "db_id": "movie_1", "question": "What are the names of movies that get 3 star and 4 star?", "rationale": ["We need to find the names of movies that received both 3-star and 4-star ratings.", "To do this, we will join the Movie table with the Rating table on the movie ID (mID).", "We will filter the ratings to include only those that are either 3 or 4 stars using the WHERE clause.", "To ensure that we only get movies that have received both ratings, we will group the results by the movie title.", "Finally, we will use the HAVING clause to ensure that the count of distinct star ratings for each movie is 2, meaning it has received both 3 and 4 stars."], "gold_sql": "SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  3 INTERSECT SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  4", "source_tables": ["rating", "movie"], "pred_sql": "SELECT DISTINCT Movie.title \nFROM Movie \nJOIN Rating ON Movie.mID = Rating.mID \nWHERE Rating.stars IN ('3', '4') \nGROUP BY Movie.title \nHAVING COUNT(DISTINCT Rating.stars) = 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the titles of movies that have received a specific number of stars from two different reviewers. The placeholders in the WHERE clause represent the star ratings given by the reviewers.\",\n    \"1\": \"This virtual table provides a summary of movie ratings by reviewers. It displays the title of the movie, the unique identifier of the reviewer, the number of stars given in the rating, and the minimum stars given by each reviewer. The placeholders represent the relevant identifiers and ratings.\",\n    \"2\": \"This virtual table provides a summary of movie ratings, displaying the title of each movie, the number of stars given, the director's name, and the minimum star rating for each director. The data is aggregated by director, allowing for a comparison of the lowest ratings received by movies directed by the same individual.\"\n}\n"}
{"sample_id": "train.2576", "db_id": "inn_1", "question": "Find the most popular room in the hotel. The most popular room is the room that had seen the largest number of reservations.", "rationale": ["Identify the tables involved: Rooms and Reservations.", "To find the most popular room, we need to count the number of reservations for each room.", "Join the Rooms table with the Reservations table on the RoomId to get the room names along with their reservation counts.", "Use COUNT() to count the number of reservations for each room, grouping by the RoomId.", "Order the results by the count of reservations in descending order to get the most popular room at the top.", "Limit the results to 1 to get only the most popular room."], "gold_sql": "SELECT T2.roomName FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT r.roomName, COUNT(res.Code) AS reservation_count\nFROM Rooms r\nJOIN Reservations res ON r.RoomId = res.Room\nGROUP BY r.RoomId\nORDER BY reservation_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of room reservations, showing the room names along with the count of reservations for each room. The placeholders in the query allow for dynamic filtering based on room identifiers.\",\n    \"1\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\",\n    \"2\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the bed type being queried.\"\n}\n"}
{"sample_id": "train.2577", "db_id": "inn_1", "question": "Which room has the largest number of reservations?", "rationale": ["Identify the tables involved: Rooms and Reservations.", "We need to count the number of reservations for each room, so we will use a COUNT function on the Reservations table.", "Join the Rooms table with the Reservations table on the RoomId to get the room names along with their reservation counts.", "Group the results by the RoomId to aggregate the reservation counts for each room.", "Order the results by the reservation count in descending order to find the room with the largest number of reservations.", "Limit the results to 1 to get only the room with the highest count."], "gold_sql": "SELECT T2.roomName FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT Rooms.roomName, COUNT(Reservations.Code) AS reservation_count\nFROM Rooms\nLEFT JOIN Reservations ON Rooms.RoomId = Reservations.Room\nGROUP BY Rooms.RoomId\nORDER BY reservation_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of room reservations, showing the room names along with the count of reservations for each room. The placeholders in the query allow for dynamic filtering based on room identifiers.\",\n    \"1\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\",\n    \"2\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the bed type being queried.\"\n}\n"}
{"sample_id": "train.2578", "db_id": "inn_1", "question": "How many kids stay in the rooms reserved by ROY SWEAZY?", "rationale": ["Identify the relevant table: Reservations contains the information about guests and their kids.", "We need to sum the number of kids from the Reservations table.", "Filter the results to only include reservations made by ROY SWEAZY by using the LastName and FirstName columns.", "Use the SUM function to calculate the total number of kids across all reservations for ROY SWEAZY."], "gold_sql": "SELECT kids FROM Reservations WHERE FirstName = 'ROY' AND LastName  =  'SWEAZY';", "source_tables": ["reservations"], "pred_sql": "SELECT SUM(Kids) AS TotalKids\nFROM Reservations\nWHERE LastName = 'SWEAZY' AND FirstName = 'ROY';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of room reservations, showing the room names along with the count of reservations for each room. The placeholders in the query allow for dynamic filtering based on room identifiers.\",\n    \"1\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\",\n    \"2\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the bed type being queried.\"\n}\n"}
{"sample_id": "train.2582", "db_id": "inn_1", "question": "Which room has the highest rate? List the room's full name, rate, check in and check out date.", "rationale": ["Identify the tables involved: Rooms and Reservations.", "Determine the columns needed: roomName from Rooms, Rate, CheckIn, and CheckOut from Reservations.", "Join the Rooms table with the Reservations table on the RoomId and Room columns respectively.", "Order the results by Rate in descending order to find the highest rate.", "Limit the results to 1 to get only the room with the highest rate."], "gold_sql": "SELECT T2.roomName ,  T1.Rate ,  T1.CheckIn ,  T1.CheckOut FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY T1.Rate DESC LIMIT 1;", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT r.roomName, res.Rate, res.CheckIn, res.CheckOut \nFROM Rooms r \nJOIN Reservations res ON r.RoomId = res.Room \nORDER BY res.Rate DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of room reservations, showing the room names along with the count of reservations for each room. The placeholders in the query allow for dynamic filtering based on room identifiers.\",\n    \"1\": \"This virtual table provides the names and decor descriptions of rooms from the 'Rooms' table that have a specific type of bed. The results are ordered by the base price of the rooms. The placeholder in the WHERE clause represents the type of bed being queried.\",\n    \"2\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\"\n}\n"}
{"sample_id": "train.2583", "db_id": "inn_1", "question": "Return the name, rate, check in and check out date for the room with the highest rate.", "rationale": ["Identify the required fields: room name, rate, check-in date, and check-out date.", "The data is spread across two tables: Rooms and Reservations. We need to join these tables on the RoomId.", "Use a JOIN clause to combine the Rooms and Reservations tables based on the RoomId and Room fields.", "To find the room with the highest rate, we will order the results by the Rate in descending order.", "Finally, we will limit the results to only one entry to get the room with the highest rate."], "gold_sql": "SELECT T2.roomName ,  T1.Rate ,  T1.CheckIn ,  T1.CheckOut FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY T1.Rate DESC LIMIT 1;", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT r.roomName, res.Rate, res.CheckIn, res.CheckOut \nFROM Rooms r \nJOIN Reservations res ON r.RoomId = res.Room \nORDER BY res.Rate DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of room reservations, showing the room names along with the count of reservations for each room. The placeholders in the query allow for dynamic filtering based on room identifiers.\",\n    \"1\": \"This virtual table provides the names and decor descriptions of rooms from the 'Rooms' table that have a specific type of bed. The results are ordered by the base price of the rooms. The placeholder in the WHERE clause represents the type of bed being queried.\",\n    \"2\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\"\n}\n"}
{"sample_id": "train.2589", "db_id": "inn_1", "question": "Find the total number of king beds available.", "rationale": ["Identify the requirement: We need to find the total number of king beds available.", "Refer to the schema: The 'Rooms' table contains a column 'bedType' which indicates the type of beds in each room.", "Use the COUNT function to count the number of rooms that have 'king' as their bed type.", "Construct the SQL query to select the count from the 'Rooms' table where 'bedType' is 'king'."], "gold_sql": "SELECT sum(beds) FROM Rooms WHERE bedtype  =  'King';", "source_tables": ["rooms"], "pred_sql": "SELECT COUNT(*) AS TotalKingBeds FROM Rooms WHERE bedType = 'king';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\",\n    \"1\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the bed type being queried.\",\n    \"2\": \"This virtual table provides a summary of room reservations, showing the room names along with the count of reservations for each room. The placeholders in the query allow for dynamic filtering based on room identifiers.\"\n}\n"}
{"sample_id": "train.2590", "db_id": "inn_1", "question": "List the names and decor of rooms that have a king bed. Sort the list by their price.", "rationale": ["Identify the relevant table: Rooms.", "Determine the columns needed: roomName and decor.", "Filter the results to include only rooms with a king bed by using a WHERE clause: bedType = 'king'.", "Sort the results by the base price of the rooms using ORDER BY basePrice."], "gold_sql": "SELECT roomName ,  decor FROM Rooms WHERE bedtype  =  'King' ORDER BY basePrice;", "source_tables": ["rooms"], "pred_sql": "SELECT roomName, decor FROM Rooms WHERE bedType = 'king' ORDER BY basePrice;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and decor descriptions of rooms from the 'Rooms' table that have a specific type of bed. The results are ordered by the base price of the rooms. The placeholder in the WHERE clause represents the type of bed being queried.\",\n    \"1\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\",\n    \"2\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the bed type being queried.\"\n}\n"}
{"sample_id": "train.2594", "db_id": "inn_1", "question": "What is the decor of room Recluse and defiance?", "rationale": ["Identify the relevant table: The question pertains to the decor of specific rooms, which are stored in the 'Rooms' table.", "Determine the columns needed: We need the 'decor' column to answer the question.", "Filter the results: We need to filter the rooms by their names, which are 'Recluse' and 'defiance'.", "Construct the SQL query: Use a SELECT statement to retrieve the 'decor' from the 'Rooms' table where the 'roomName' matches the specified names."], "gold_sql": "SELECT decor FROM Rooms WHERE roomName  =  'Recluse and defiance';", "source_tables": ["rooms"], "pred_sql": "SELECT decor FROM Rooms WHERE roomName IN ('Recluse', 'defiance');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\",\n    \"1\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the bed type being queried.\",\n    \"2\": \"This virtual table provides the names and decor descriptions of rooms from the 'Rooms' table that have a specific type of bed. The results are ordered by the base price of the rooms. The placeholder in the WHERE clause represents the type of bed being queried.\"\n}\n"}
{"sample_id": "train.2604", "db_id": "inn_1", "question": "Find the first and last names of people who payed more than the rooms' base prices.", "rationale": ["Identify the tables involved: Reservations and Rooms.", "We need to retrieve the first and last names of guests, which are in the Reservations table.", "We also need to compare the Rate from the Reservations table with the basePrice from the Rooms table.", "To do this, we will join the Reservations table with the Rooms table on the RoomId.", "The condition for the query is that the Rate in Reservations must be greater than the basePrice in Rooms.", "Finally, we select the FirstName and LastName from the Reservations table where the condition is met."], "gold_sql": "SELECT T1.firstname ,  T1.lastname FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T1.Rate - T2.basePrice  >  0", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT Reservations.FirstName, Reservations.LastName\nFROM Reservations\nJOIN Rooms ON Reservations.Room = Rooms.RoomId\nWHERE Reservations.Rate > Rooms.basePrice;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and decor descriptions of rooms from the 'Rooms' table that have a specific type of bed. The results are ordered by the base price of the rooms. The placeholder in the WHERE clause represents the type of bed being queried.\"\n}\n"}
{"sample_id": "train.2609", "db_id": "inn_1", "question": "How many rooms have a king bed?", "rationale": ["Identify the table to query: The question is about rooms, so we will use the 'Rooms' table.", "Determine the relevant column: We need to filter rooms based on the type of bed, which is in the 'bedType' column.", "Count the rooms: We need to count how many rooms have a king bed, so we will use the COUNT() function.", "Construct the SQL query: We will select the count of rooms from the 'Rooms' table where the 'bedType' is 'king'."], "gold_sql": "SELECT count(*) FROM Rooms WHERE bedType  =  'King';", "source_tables": ["rooms"], "pred_sql": "SELECT COUNT(*) AS RoomCount FROM Rooms WHERE bedType = 'king';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\",\n    \"1\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the bed type being queried.\",\n    \"2\": \"This virtual table provides the names and decor descriptions of rooms from the 'Rooms' table that have a specific type of bed. The results are ordered by the base price of the rooms. The placeholder in the WHERE clause represents the type of bed being queried.\"\n}\n"}
{"sample_id": "train.2612", "db_id": "inn_1", "question": "Find the name of the room with the maximum occupancy.", "rationale": ["Identify the table that contains room information, which is the 'Rooms' table.", "Determine the column that holds the maximum occupancy information, which is 'maxOccupancy'.", "To find the room with the maximum occupancy, we need to select the room name from the 'Rooms' table where the 'maxOccupancy' is equal to the maximum value of 'maxOccupancy' in the same table.", "Use a subquery to find the maximum occupancy value from the 'Rooms' table and compare it in the main query to filter the room name."], "gold_sql": "SELECT roomName FROM Rooms ORDER BY maxOccupancy DESC LIMIT 1;", "source_tables": ["rooms"], "pred_sql": "SELECT roomName FROM Rooms WHERE maxOccupancy = (SELECT MAX(maxOccupancy) FROM Rooms);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of room reservations, showing the room names along with the count of reservations for each room. The placeholders in the query allow for dynamic filtering based on room identifiers.\",\n    \"1\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\",\n    \"2\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the bed type being queried.\"\n}\n"}
{"sample_id": "train.2621", "db_id": "inn_1", "question": "What is the average minimum and price of the rooms for each different decor.", "rationale": ["Identify the required information: average and minimum price of rooms grouped by decor.", "The relevant table is 'Rooms' which contains the 'basePrice' and 'decor' columns.", "Use the AVG() function to calculate the average price and MIN() function to find the minimum price.", "Group the results by the 'decor' column to get the average and minimum prices for each decor type."], "gold_sql": "SELECT decor , avg(basePrice) ,  min(basePrice) FROM Rooms GROUP BY decor;", "source_tables": ["rooms"], "pred_sql": "SELECT decor, AVG(basePrice) AS averagePrice, MIN(basePrice) AS minimumPrice \nFROM Rooms \nGROUP BY decor;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and decor descriptions of rooms from the 'Rooms' table that have a specific type of bed. The results are ordered by the base price of the rooms. The placeholder in the WHERE clause represents the type of bed being queried.\",\n    \"1\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\",\n    \"2\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the bed type being queried.\"\n}\n"}
{"sample_id": "train.2628", "db_id": "inn_1", "question": "List the name of rooms with king or queen bed.", "rationale": ["Identify the relevant table: The 'Rooms' table contains the information about room names and bed types.", "Determine the required columns: We need the 'roomName' column from the 'Rooms' table.", "Specify the condition: We want rooms that have either a 'king' or 'queen' bed, which means we need to filter the results based on the 'bedType' column.", "Construct the SQL query: Use a SELECT statement to retrieve 'roomName' from 'Rooms' where 'bedType' is either 'king' or 'queen'."], "gold_sql": "SELECT roomName FROM Rooms WHERE bedType  =  'King' OR bedType  =  'Queen';", "source_tables": ["rooms"], "pred_sql": "SELECT roomName FROM Rooms WHERE bedType IN ('king', 'queen');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and decor descriptions of rooms from the 'Rooms' table that have a specific type of bed. The results are ordered by the base price of the rooms. The placeholder in the WHERE clause represents the type of bed being queried.\",\n    \"1\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\",\n    \"2\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the bed type being queried.\"\n}\n"}
{"sample_id": "train.2639", "db_id": "inn_1", "question": "For each room, find its name and the number of times reservations were made for it.", "rationale": ["We need to find the name of each room and the number of reservations made for it.", "To achieve this, we will select the 'roomName' from the 'Rooms' table.", "We also need to count the number of reservations for each room, which can be done using COUNT on the 'Code' column from the 'Reservations' table.", "Since a room may not have any reservations, we will use a LEFT JOIN to include all rooms even if they have zero reservations.", "We will join the 'Rooms' table with the 'Reservations' table on the 'RoomId' and 'Room' columns respectively.", "Finally, we will group the results by 'RoomId' and 'roomName' to get the count of reservations for each room."], "gold_sql": "SELECT T2.roomName ,  count(*) ,  T1.Room FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT Rooms.roomName, COUNT(Reservations.Code) AS reservationCount \nFROM Rooms \nLEFT JOIN Reservations ON Rooms.RoomId = Reservations.Room \nGROUP BY Rooms.RoomId, Rooms.roomName;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of room reservations, showing the room names along with the count of reservations for each room. The placeholders in the query allow for dynamic filtering based on room identifiers.\",\n    \"1\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\",\n    \"2\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the bed type being queried.\"\n}\n"}
{"sample_id": "train.2846", "db_id": "customer_deliveries", "question": "Show the details of all trucks in the order of their license number.", "rationale": ["Identify the table needed: The question asks for details of trucks, so we will use the 'Trucks' table.", "Select all columns: We need all details, so we will use SELECT *.", "Order by license number: The question specifies to order the results by the truck's license number, so we will add ORDER BY truck_licence_number."], "gold_sql": "SELECT truck_details FROM trucks ORDER BY truck_licence_number", "source_tables": ["trucks"], "pred_sql": "SELECT * FROM Trucks ORDER BY truck_licence_number;", "hint": "\n"}
{"sample_id": "train.2848", "db_id": "customer_deliveries", "question": "Find the names of customers who are not living in the state of California.", "rationale": ["Identify the relevant tables: Customers, Customer_Addresses, and Addresses.", "Join the Customers table with Customer_Addresses to link customers to their addresses.", "Join the Customer_Addresses table with Addresses to access the state information.", "Filter the results to exclude customers living in California by using a WHERE clause that checks if the state is not 'California'.", "Select distinct customer names to avoid duplicates in the result."], "gold_sql": "SELECT customer_name FROM customers EXCEPT SELECT t1.customer_name FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id WHERE t3.state_province_county  =  'California'", "source_tables": ["addresses", "customers", "customer_addresses"], "pred_sql": "SELECT DISTINCT c.customer_name \nFROM Customers c \nJOIN Customer_Addresses ca ON c.customer_id = ca.customer_id \nJOIN Addresses a ON ca.address_id = a.address_id \nWHERE a.state_province_county != 'California';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the count of customer addresses grouped by state, province, or county from the 'Customer_Addresses' and 'Addresses' tables. The placeholder in the SELECT statement represents the state, province, or county being counted.\"\n}\n"}
{"sample_id": "train.2856", "db_id": "customer_deliveries", "question": "Find the name of route that has the highest number of deliveries.", "rationale": ["Identify the relevant tables: Delivery_Routes, Delivery_Route_Locations, and Order_Deliveries are needed to find the route with the highest number of deliveries.", "Join the Delivery_Routes table with Delivery_Route_Locations on route_id to link routes to their locations.", "Join the resulting table with Order_Deliveries on location_code to associate deliveries with their respective routes.", "Group the results by route_name to count the number of deliveries for each route.", "Order the results in descending order based on the count of deliveries to find the route with the highest number.", "Limit the results to 1 to get only the top route."], "gold_sql": "SELECT t1.route_name FROM Delivery_Routes AS t1 JOIN Delivery_Route_Locations AS t2 ON t1.route_id  =  t2.route_id GROUP BY t1.route_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["delivery_route_locations", "delivery_routes"], "pred_sql": "SELECT route_name\nFROM Delivery_Routes\nJOIN Delivery_Route_Locations ON Delivery_Routes.route_id = Delivery_Route_Locations.route_id\nJOIN Order_Deliveries ON Delivery_Route_Locations.location_code = Order_Deliveries.location_code\nGROUP BY route_name\nORDER BY COUNT(Order_Deliveries.actual_order_id) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3175", "db_id": "college_1", "question": "How many professors are teaching class with code ACCT-211?", "rationale": ["Identify the relevant tables: CLASS and PROFESSOR are needed to find professors teaching a specific class.", "Determine the relationship: CLASS.PROF_NUM links to PROFESSOR.EMP_NUM, allowing us to find which professors are teaching which classes.", "Filter the results: We need to filter the classes to only those with the code 'ACCT-211'.", "Count the distinct professors: Use COUNT(DISTINCT) to ensure we count each professor only once, even if they teach multiple sections of the same class."], "gold_sql": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["class"], "pred_sql": "SELECT COUNT(DISTINCT PROFESSOR.EMP_NUM) AS professor_count \nFROM CLASS \nJOIN PROFESSOR ON CLASS.PROF_NUM = PROFESSOR.EMP_NUM \nWHERE CLASS.CRS_CODE = 'ACCT-211';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree level being queried.\",\n    \"1\": \"This virtual table provides a distinct list of first names and dates of birth of professors from the 'employee' table who are teaching classes associated with a specific course code. The placeholder in the WHERE clause represents the course code for which the professors are being queried.\",\n    \"2\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\"\n}\n"}
{"sample_id": "train.3176", "db_id": "college_1", "question": "How many professors teach a class with the code ACCT-211?", "rationale": ["Identify the relevant tables: CLASS and EMPLOYEE are needed to find professors teaching a specific class.", "We need to count the number of distinct professors, so we will use COUNT(DISTINCT EMPLOYEE.EMP_NUM).", "Join the CLASS table with the EMPLOYEE table on the condition that CLASS.PROF_NUM matches EMPLOYEE.EMP_NUM to get the professors for the classes.", "Filter the results to only include classes with the code 'ACCT-211' using a WHERE clause.", "Construct the SQL query to select the count of distinct professors for the specified class code."], "gold_sql": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["class"], "pred_sql": "SELECT COUNT(DISTINCT EMPLOYEE.EMP_NUM) AS professor_count\nFROM CLASS\nJOIN EMPLOYEE ON CLASS.PROF_NUM = EMPLOYEE.EMP_NUM\nWHERE CLASS.CRS_CODE = 'ACCT-211';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree level being queried.\",\n    \"1\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n    \"2\": \"This virtual table provides a distinct list of first names and dates of birth of professors from the 'employee' table who are teaching classes associated with a specific course code. The placeholder in the WHERE clause represents the course code for which the professors are being queried.\"\n}\n"}
{"sample_id": "train.3179", "db_id": "college_1", "question": "What are the first names and date of birth of professors teaching course ACCT-211?", "rationale": ["Identify the tables needed: EMPLOYEE for professor details, PROFESSOR to link professors to classes, and CLASS to find classes associated with the course.", "Join the EMPLOYEE table with the PROFESSOR table on EMP_NUM to get the professors' details.", "Join the resulting table with the CLASS table on the PROFESSOR's EMP_NUM to find which classes they teach.", "Filter the results by the specific course code 'ACCT-211' to get only those professors teaching that course.", "Select the first names (EMP_FNAME) and dates of birth (EMP_DOB) of the professors from the final result."], "gold_sql": "SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["employee", "class"], "pred_sql": "SELECT EMP_FNAME, EMP_DOB \nFROM EMPLOYEE \nJOIN PROFESSOR ON EMPLOYEE.EMP_NUM = PROFESSOR.EMP_NUM \nJOIN CLASS ON PROFESSOR.EMP_NUM = CLASS.PROF_NUM \nWHERE CLASS.CRS_CODE = 'ACCT-211';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a distinct list of first names and dates of birth of professors from the 'employee' table who are teaching classes associated with a specific course code. The placeholder in the WHERE clause represents the course code for which the professors are being queried.\",\n    \"1\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the department's name.\"\n}\n"}
{"sample_id": "train.3188", "db_id": "college_1", "question": "Where is the history department?", "rationale": ["Identify the relevant table: The DEPARTMENT table contains information about department names and their addresses.", "Determine the specific department: The user is asking for the 'history department', so we need to filter the DEPARTMENT table for the department name that matches 'History'.", "Construct the SQL query: We will select the department name and address from the DEPARTMENT table where the department name is 'History'."], "gold_sql": "SELECT dept_address FROM department WHERE dept_name  =  'History'", "source_tables": ["department"], "pred_sql": "SELECT DEPT_NAME, DEPT_ADDRESS \nFROM DEPARTMENT \nWHERE DEPT_NAME = 'History';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n    \"1\": \"This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree level being queried.\",\n    \"2\": \"This virtual table summarizes the academic performance of students by department. It calculates the maximum, average, and minimum GPA for students in each department, grouping the results by the department code.\"\n}\n"}
{"sample_id": "train.3190", "db_id": "college_1", "question": "What are the different locations of the school with the code BUS?", "rationale": ["Identify the table that contains the school locations, which is the DEPARTMENT table.", "Determine the relevant column for the address, which is DEPT_ADDRESS.", "Use the SCHOOL_CODE column to filter the results for the specific school code 'BUS'.", "Select distinct addresses to avoid duplicates in the results."], "gold_sql": "SELECT count(DISTINCT dept_address) FROM department WHERE school_code  =  'BUS'", "source_tables": ["department"], "pred_sql": "SELECT DISTINCT DEPT_ADDRESS FROM DEPARTMENT WHERE SCHOOL_CODE = 'BUS';", "hint": "\n"}
{"sample_id": "train.3201", "db_id": "college_1", "question": "What is the total credit does each department offer?", "rationale": ["Identify the relevant tables: DEPARTMENT and COURSE are needed to get the department information and the credit hours for courses offered by each department.", "Determine the relationship: The DEPARTMENT table is linked to the COURSE table through the DEPT_CODE column.", "Select the required fields: We need the department code (DEPT_CODE), department name (DEPT_NAME), and the total credit hours (SUM of CRS_CREDIT) offered by each department.", "Group the results: To get the total credits per department, we will group the results by DEPT_CODE and DEPT_NAME.", "Construct the SQL query: Combine the SELECT statement with JOIN and GROUP BY clauses to form the complete SQL query."], "gold_sql": "SELECT sum(crs_credit) ,  dept_code FROM course GROUP BY dept_code", "source_tables": ["course"], "pred_sql": "SELECT DEPARTMENT.DEPT_CODE, DEPARTMENT.DEPT_NAME, SUM(COURSE.CRS_CREDIT) AS TOTAL_CREDIT\nFROM DEPARTMENT\nJOIN COURSE ON DEPARTMENT.DEPT_CODE = COURSE.DEPT_CODE\nGROUP BY DEPARTMENT.DEPT_CODE, DEPARTMENT.DEPT_NAME;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the academic performance of students by department. It calculates the maximum, average, and minimum GPA for students in each department, grouping the results by the department code.\",\n    \"1\": \"This virtual table summarizes the academic performance of students by department. It calculates the maximum, average, and minimum GPA of students grouped by their respective department codes. The placeholders in the SELECT statement represent the GPA metrics and department code.\",\n    \"2\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\"\n}\n"}
{"sample_id": "train.3202", "db_id": "college_1", "question": "How many credits does the department offer?", "rationale": ["The question asks for the total number of credits offered by the department.", "To find this, we need to sum the credits from the COURSE table.", "The COURSE table contains a column 'CRS_CREDIT' which represents the number of credit hours for each course.", "We also need to ensure that we are considering the courses offered by departments, so we will join the COURSE table with the DEPARTMENT table on the DEPT_CODE column.", "The final SQL query will select the sum of the CRS_CREDIT from the COURSE table after joining it with the DEPARTMENT table."], "gold_sql": "SELECT sum(crs_credit) ,  dept_code FROM course GROUP BY dept_code", "source_tables": ["course"], "pred_sql": "SELECT SUM(CRS_CREDIT) AS total_credits\nFROM COURSE\nJOIN DEPARTMENT ON COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the academic performance of students by department. It calculates the maximum, average, and minimum GPA for students in each department, grouping the results by the department code.\",\n    \"1\": \"This virtual table summarizes the academic performance of students by department. It calculates the maximum, average, and minimum GPA of students grouped by their respective department codes. The placeholders in the SELECT statement represent the GPA metrics and department code.\",\n    \"2\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\"\n}\n"}
{"sample_id": "train.3213", "db_id": "college_1", "question": "Which school has the smallest amount of professors?", "rationale": ["We need to find the school with the smallest number of professors.", "To do this, we will join the DEPARTMENT and PROFESSOR tables on the DEPT_CODE.", "We will count the number of professors (PROF_NUM) for each school (SCHOOL_CODE).", "We will group the results by SCHOOL_CODE to get the count of professors per school.", "Finally, we will order the results by the count of professors in ascending order and limit the results to 1 to get the school with the smallest number of professors."], "gold_sql": "SELECT T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code ORDER BY count(*) LIMIT 1", "source_tables": ["department", "professor"], "pred_sql": "SELECT SCHOOL_CODE, COUNT(PROF_NUM) AS PROFESSOR_COUNT \nFROM DEPARTMENT \nJOIN PROFESSOR ON DEPARTMENT.DEPT_CODE = PROFESSOR.DEPT_CODE \nGROUP BY SCHOOL_CODE \nORDER BY PROFESSOR_COUNT ASC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree level being queried.\",\n    \"1\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n    \"2\": \"This virtual table provides a list of department names and their corresponding department codes from the 'professor' and 'department' tables. It filters the results based on the highest degree obtained by professors, using a placeholder for the degree type. The results are grouped by department code and ordered by the number of professors in each department, limited to a specified number of results.\"\n}\n"}
{"sample_id": "train.3215", "db_id": "college_1", "question": "Find the number of professors with a Ph.D. degree in each department.", "rationale": ["We need to find the number of professors with a Ph.D. degree in each department.", "To do this, we will join the PROFESSOR table with the DEPARTMENT table on the DEPT_CODE column, which is common to both tables.", "We will filter the results to include only those professors whose highest degree is 'Ph.D.' using a WHERE clause.", "Next, we will group the results by DEPARTMENT.DEPT_CODE to aggregate the count of professors in each department.", "Finally, we will select the department name and the count of professors, using COUNT() to get the number of professors with a Ph.D. in each department."], "gold_sql": "SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  'Ph.D.' GROUP BY dept_code", "source_tables": ["professor"], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME, COUNT(PROFESSOR.EMP_NUM) AS NumberOfProfessors\nFROM PROFESSOR\nJOIN DEPARTMENT ON PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE\nWHERE PROFESSOR.PROF_HIGH_DEGREE = 'Ph.D.'\nGROUP BY DEPARTMENT.DEPT_CODE;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree level being queried.\",\n    \"1\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n    \"2\": \"This virtual table provides a list of department names and their corresponding department codes from the 'professor' and 'department' tables. It filters the results based on the highest degree obtained by professors, using a placeholder for the degree type. The results are grouped by department code and ordered by the number of professors in each department, limited to a specified number of results.\"\n}\n"}
{"sample_id": "train.3217", "db_id": "college_1", "question": "Find the number of students for each department.", "rationale": ["To find the number of students for each department, we need to count the students grouped by their department.", "The relevant tables are DEPARTMENT and STUDENT, where DEPARTMENT contains department information and STUDENT contains student enrollment details.", "We will perform a LEFT JOIN between DEPARTMENT and STUDENT on the DEPT_CODE to ensure we get all departments even if they have no students enrolled.", "We will use COUNT(STUDENT.STU_NUM) to count the number of students in each department.", "Finally, we will group the results by DEPARTMENT.DEPT_CODE and DEPARTMENT.DEPT_NAME to get the count for each department."], "gold_sql": "SELECT count(*) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT DEPARTMENT.DEPT_CODE, DEPARTMENT.DEPT_NAME, COUNT(STUDENT.STU_NUM) AS NUM_STUDENTS\nFROM DEPARTMENT\nLEFT JOIN STUDENT ON DEPARTMENT.DEPT_CODE = STUDENT.DEPT_CODE\nGROUP BY DEPARTMENT.DEPT_CODE, DEPARTMENT.DEPT_NAME;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree level being queried.\",\n    \"1\": \"This virtual table summarizes the academic performance of students by department. It calculates the maximum, average, and minimum GPA for students in each department, grouping the results by the department code.\",\n    \"2\": \"This virtual table provides a list of department names and their corresponding department codes from the 'professor' and 'department' tables. It filters the results based on the highest degree obtained by professors, using a placeholder for the degree type. The results are grouped by department code and ordered by the number of professors in each department, limited to a specified number of results.\"\n}\n"}
{"sample_id": "train.3219", "db_id": "college_1", "question": "Find the total number of hours have done for all students in each department.", "rationale": ["We need to find the total number of hours completed by students in each department.", "The relevant table for student information is the STUDENT table, which contains the total credit hours completed (STU_HRS) and the department code (DEPT_CODE).", "We also need to reference the DEPARTMENT table to group the results by department.", "To get the total hours for each department, we will use the SUM function on the STU_HRS column and group the results by DEPT_CODE.", "The SQL query will involve a JOIN between the STUDENT and DEPARTMENT tables on the DEPT_CODE column to ensure we can group by department while summing the hours."], "gold_sql": "SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT DEPARTMENT.DEPT_CODE, SUM(STUDENT.STU_HRS) AS TOTAL_HOURS\nFROM STUDENT\nJOIN DEPARTMENT ON STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE\nGROUP BY DEPARTMENT.DEPT_CODE;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the academic performance of students by department. It calculates the maximum, average, and minimum GPA for students in each department, grouping the results by the department code.\",\n    \"1\": \"This virtual table summarizes the academic performance of students by department. It calculates the maximum, average, and minimum GPA of students grouped by their respective department codes. The placeholders in the SELECT statement represent the GPA metrics and department code.\",\n    \"2\": \"This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree level being queried.\"\n}\n"}
{"sample_id": "train.3240", "db_id": "college_1", "question": "Which department offers the most credits all together?", "rationale": ["Identify the relevant tables: DEPARTMENT and COURSE are needed to find the department and the credits associated with courses.", "Join the DEPARTMENT table with the COURSE table on the DEPT_CODE to associate courses with their respective departments.", "Use the SUM function to calculate the total credits for each department by summing the CRS_CREDIT from the COURSE table.", "Group the results by DEPARTMENT.DEPT_CODE to aggregate the credits for each department.", "Order the results in descending order based on the total credits to find the department with the most credits.", "Limit the results to 1 to get only the department that offers the most credits."], "gold_sql": "SELECT T3.dept_name FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code JOIN department AS T3 ON T1.dept_code  =  T3.dept_code GROUP BY T1.dept_code ORDER BY sum(T1.crs_credit) DESC LIMIT 1", "source_tables": ["course", "department", "class"], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME, SUM(COURSE.CRS_CREDIT) AS TOTAL_CREDITS\nFROM DEPARTMENT\nJOIN COURSE ON DEPARTMENT.DEPT_CODE = COURSE.DEPT_CODE\nGROUP BY DEPARTMENT.DEPT_CODE\nORDER BY TOTAL_CREDITS DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the academic performance of students by department. It calculates the maximum, average, and minimum GPA for students in each department, grouping the results by the department code.\",\n    \"1\": \"This virtual table summarizes the academic performance of students by department. It calculates the maximum, average, and minimum GPA of students grouped by their respective department codes. The placeholders in the SELECT statement represent the GPA metrics and department code.\",\n    \"2\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\"\n}\n"}
{"sample_id": "train.3243", "db_id": "college_1", "question": "What is the first name of each student enrolled in class ACCT-211?", "rationale": ["Identify the tables involved: STUDENT, ENROLL, and CLASS.", "Determine the relationship between the tables: STUDENT is linked to ENROLL through STU_NUM, and ENROLL is linked to CLASS through CLASS_CODE.", "We need to select the first names of students, which is in the STUDENT table.", "We need to filter the results to only include students enrolled in the class with CLASS_CODE 'ACCT-211'.", "Construct the SQL query using JOINs to connect the tables and apply the WHERE clause for filtering."], "gold_sql": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  'ACCT-211'", "source_tables": ["student", "class", "enroll"], "pred_sql": "SELECT DISTINCT STUDENT.STU_FNAME \nFROM STUDENT \nJOIN ENROLL ON STUDENT.STU_NUM = ENROLL.STU_NUM \nJOIN CLASS ON ENROLL.CLASS_CODE = CLASS.CLASS_CODE \nWHERE CLASS.CLASS_CODE = 'ACCT-211';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the department's name.\",\n    \"1\": \"This virtual table provides a distinct list of first names and dates of birth of professors from the 'employee' table who are teaching classes associated with a specific course code. The placeholder in the WHERE clause represents the course code for which the professors are being queried.\"\n}\n"}
{"sample_id": "train.3245", "db_id": "college_1", "question": "What is the first name of students enrolled in class ACCT-211 and got grade C?", "rationale": ["Identify the tables needed: STUDENT, ENROLL, and CLASS are required to get the first names of students enrolled in a specific class and their grades.", "The STUDENT table contains the first names of students, while the ENROLL table links students to the classes they are enrolled in, including their grades.", "The CLASS table provides the class code to filter for the specific class 'ACCT-211'.", "Join the STUDENT table with the ENROLL table on the student number (STU_NUM) to get the enrollment details for each student.", "Join the resulting table with the CLASS table on the class code (CLASS_CODE) to filter for the specific class 'ACCT-211'.", "Add a WHERE clause to filter for students who received a grade of 'C' in that class.", "Select the first names of the students who meet these criteria."], "gold_sql": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  'ACCT-211' AND T2.enroll_grade  =  'C'", "source_tables": ["student", "class", "enroll"], "pred_sql": "SELECT STUDENT.STU_FNAME \nFROM STUDENT \nJOIN ENROLL ON STUDENT.STU_NUM = ENROLL.STU_NUM \nJOIN CLASS ON ENROLL.CLASS_CODE = CLASS.CLASS_CODE \nWHERE CLASS.CLASS_CODE = 'ACCT-211' AND ENROLL.ENROLL_GRADE = 'C';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the department's name.\",\n    \"1\": \"This virtual table summarizes the academic performance of students by department. It calculates the maximum, average, and minimum GPA of students grouped by their respective department codes. The placeholders in the SELECT statement represent the GPA metrics and department code.\",\n    \"2\": \"This virtual table provides a distinct list of first names and dates of birth of professors from the 'employee' table who are teaching classes associated with a specific course code. The placeholder in the WHERE clause represents the course code for which the professors are being queried.\"\n}\n"}
{"sample_id": "train.3254", "db_id": "college_1", "question": "What is the name of the department with the most students enrolled?", "rationale": ["To find the department with the most students enrolled, we need to count the number of students in each department.", "We can achieve this by grouping the STUDENT table by DEPT_CODE and counting the number of students (STU_NUM) in each group.", "Next, we will order the results in descending order based on the count of students to get the department with the highest number of students at the top.", "Finally, we will limit the results to just one department to get the one with the most students.", "To get the name of the department, we will join this result with the DEPARTMENT table using the DEPT_CODE."], "gold_sql": "SELECT T4.dept_name FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code GROUP BY T3.dept_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["course", "department", "class", "enroll"], "pred_sql": "SELECT DEPT_NAME\nFROM DEPARTMENT\nWHERE DEPT_CODE IN (\n    SELECT DEPT_CODE\n    FROM STUDENT\n    GROUP BY DEPT_CODE\n    ORDER BY COUNT(STU_NUM) DESC\n    LIMIT 1\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the department's name.\",\n    \"1\": \"This virtual table summarizes the academic performance of students by department. It calculates the maximum, average, and minimum GPA for students in each department, grouping the results by the department code.\",\n    \"2\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\"\n}\n"}
{"sample_id": "train.3257", "db_id": "college_1", "question": "List the codes of all courses that take place in room KLR209.", "rationale": ["Identify the relevant table: The CLASS table contains information about classes, including the room where they are held and the course code associated with each class.", "Determine the required columns: We need the course codes (CRS_CODE) for classes held in room KLR209.", "Construct the SQL query: Use a SELECT statement to retrieve distinct course codes from the CLASS table where the CLASS_ROOM matches 'KLR209'."], "gold_sql": "SELECT class_code FROM CLASS WHERE class_room  =  'KLR209'", "source_tables": ["class"], "pred_sql": "SELECT DISTINCT CLASS.CRS_CODE\nFROM CLASS\nWHERE CLASS.CLASS_ROOM = 'KLR209';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\"\n}\n"}
{"sample_id": "train.3258", "db_id": "college_1", "question": "What are the codes of all the courses that are located in room KLR209?", "rationale": ["Identify the relevant table: The CLASS table contains information about classes, including the room they are held in and the course code associated with each class.", "Determine the specific requirement: We need to find the course codes for classes held in room KLR209.", "Construct the SQL query: Use a SELECT statement to retrieve distinct course codes (CRS_CODE) from the CLASS table where the CLASS_ROOM matches 'KLR209'."], "gold_sql": "SELECT class_code FROM CLASS WHERE class_room  =  'KLR209'", "source_tables": ["class"], "pred_sql": "SELECT DISTINCT CLASS.CRS_CODE \nFROM CLASS \nWHERE CLASS.CLASS_ROOM = 'KLR209';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n    \"1\": \"This virtual table provides a distinct list of first names and dates of birth of professors from the 'employee' table who are teaching classes associated with a specific course code. The placeholder in the WHERE clause represents the course code for which the professors are being queried.\"\n}\n"}
{"sample_id": "train.3267", "db_id": "college_1", "question": "What is the first name of students who got grade C in any class?", "rationale": ["Identify the relevant tables: STUDENT and ENROLL are needed to find students and their grades.", "Join the STUDENT table with the ENROLL table on the student number (STU_NUM) to link students with their grades.", "Filter the results to include only those students who received a grade of 'C' in any class by using a WHERE clause."], "gold_sql": "SELECT DISTINCT stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE enroll_grade  =  'C'", "source_tables": ["enroll", "student"], "pred_sql": "SELECT STUDENT.STU_FNAME \nFROM STUDENT \nJOIN ENROLL ON STUDENT.STU_NUM = ENROLL.STU_NUM \nWHERE ENROLL.ENROLL_GRADE = 'C';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the department's name.\"\n}\n"}
{"sample_id": "train.3273", "db_id": "college_1", "question": "What are the first names of the professors who do not teach a class.", "rationale": ["Identify the relevant table: We need to find professors, so we will focus on the EMPLOYEE table.", "Determine the condition: We want professors who do not teach any class. This means we need to find professors whose EMP_NUM is not present in the CLASS table's PROF_NUM column.", "Construct the subquery: We will create a subquery that selects all PROF_NUM from the CLASS table, which represents professors who are teaching classes.", "Combine the main query and the subquery: We will select the first names (EMP_FNAME) from the EMPLOYEE table where the EMP_NUM is not in the list of PROF_NUM from the CLASS table."], "gold_sql": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  'PROF' EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num", "source_tables": ["employee", "class"], "pred_sql": "SELECT EMP_FNAME \nFROM EMPLOYEE \nWHERE EMP_NUM NOT IN (SELECT PROF_NUM FROM CLASS)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a distinct list of first names and dates of birth of professors from the 'employee' table who are teaching classes associated with a specific course code. The placeholder in the WHERE clause represents the course code for which the professors are being queried.\"\n}\n"}
{"sample_id": "train.3274", "db_id": "college_1", "question": "What are the first names of all professors not teaching any classes?", "rationale": ["Identify the relevant table: We need to find professors, so we will focus on the EMPLOYEE table.", "Determine the criteria: We want professors who are not teaching any classes. This means we need to find professors whose EMP_NUM is not present in the CLASS table's PROF_NUM column.", "Construct the subquery: The subquery will select distinct PROF_NUM from the CLASS table to get a list of professors who are teaching classes.", "Combine the main query and subquery: The main query will select the first names of professors from the EMPLOYEE table where their EMP_NUM is not in the list generated by the subquery."], "gold_sql": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  'PROF' EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num", "source_tables": ["employee", "class"], "pred_sql": "SELECT EMP_FNAME \nFROM EMPLOYEE \nWHERE EMP_NUM NOT IN (\n    SELECT DISTINCT PROF_NUM \n    FROM CLASS\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a distinct list of first names and dates of birth of professors from the 'employee' table who are teaching classes associated with a specific course code. The placeholder in the WHERE clause represents the course code for which the professors are being queried.\",\n    \"1\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\"\n}\n"}
{"sample_id": "train.3288", "db_id": "college_1", "question": "How many professors attained either Ph.D. or Masters degrees?", "rationale": ["Identify the relevant table: The PROFESSOR table contains information about professors, including their highest degree obtained.", "Determine the criteria: We need to count professors who have either a Ph.D. or a Masters degree.", "Construct the SQL query: Use the COUNT function to count the number of professors that meet the criteria, filtering with a WHERE clause that checks if the PROF_HIGH_DEGREE is either 'Ph.D.' or 'Masters'."], "gold_sql": "SELECT count(*) FROM professor WHERE prof_high_degree  =  'Ph.D.' OR prof_high_degree  =  'MA'", "source_tables": ["professor"], "pred_sql": "SELECT COUNT(*) AS total_professors\nFROM PROFESSOR\nWHERE PROF_HIGH_DEGREE IN ('Ph.D.', 'Masters');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n    \"1\": \"This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree level being queried.\",\n    \"2\": \"This virtual table provides a list of department names and their corresponding department codes from the 'professor' and 'department' tables. It filters the results based on the highest degree obtained by professors, using a placeholder for the degree type. The results are grouped by department code and ordered by the number of professors in each department, limited to a specified number of results.\"\n}\n"}
{"sample_id": "train.3292", "db_id": "college_1", "question": "What is the first name of the professor who is teaching CIS-220 and QM-261?", "rationale": ["Identify the tables involved: EMPLOYEE, PROFESSOR, and CLASS are relevant for this query.", "We need to find the first name of professors teaching specific courses (CIS-220 and QM-261).", "Join the EMPLOYEE table with the PROFESSOR table on EMP_NUM to get professor details.", "Join the resulting table with the CLASS table on the PROFESSOR's EMP_NUM to find the classes they teach.", "Filter the results to include only those classes with CRS_CODE 'CIS-220' or 'QM-261'.", "To ensure we get professors who teach both courses, we can use GROUP BY on the professor's first name and use HAVING to check that the count of distinct course codes is 2."], "gold_sql": "SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  'CIS-220' INTERSECT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  'QM-261'", "source_tables": ["employee", "class"], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME \nFROM EMPLOYEE \nJOIN PROFESSOR ON EMPLOYEE.EMP_NUM = PROFESSOR.EMP_NUM \nJOIN CLASS ON PROFESSOR.EMP_NUM = CLASS.PROF_NUM \nWHERE CLASS.CRS_CODE IN ('CIS-220', 'QM-261') \nGROUP BY EMPLOYEE.EMP_FNAME \nHAVING COUNT(DISTINCT CLASS.CRS_CODE) = 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a distinct list of first names and dates of birth of professors from the 'employee' table who are teaching classes associated with a specific course code. The placeholder in the WHERE clause represents the course code for which the professors are being queried.\",\n    \"1\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the department's name.\",\n    \"2\": \"This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree level being queried.\"\n}\n"}
{"sample_id": "train.3293", "db_id": "college_1", "question": "Find the first name of student who is taking classes from accounting and Computer Info. Systems departments", "rationale": ["Identify the tables needed: STUDENT, CLASS, ENROLL, COURSE, and DEPARTMENT.", "Join the STUDENT table with the ENROLL table to get the classes each student is enrolled in.", "Join the CLASS table with the COURSE table to get the department information for each class.", "Use the DEPARTMENT table to filter for the specific departments: Accounting and Computer Info. Systems.", "Use the INTERSECT operation to find students who are enrolled in classes from both departments, ensuring that only those students who meet the criteria in both cases are included."], "gold_sql": "SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Accounting' INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Computer Info. Systems'", "source_tables": ["course", "enroll", "department", "class", "student"], "pred_sql": "SELECT DISTINCT STUDENT.STU_FNAME \nFROM STUDENT \nJOIN CLASS ON STUDENT.STU_NUM = ENROLL.STU_NUM \nJOIN ENROLL ON CLASS.CLASS_CODE = ENROLL.CLASS_CODE \nJOIN COURSE ON CLASS.CRS_CODE = COURSE.CRS_CODE \nJOIN DEPARTMENT AS D1 ON COURSE.DEPT_CODE = D1.DEPT_CODE \nJOIN DEPARTMENT AS D2 ON COURSE.DEPT_CODE = D2.DEPT_CODE \nWHERE D1.DEPT_NAME = 'Accounting' \nINTERSECT \nSELECT DISTINCT STUDENT.STU_FNAME \nFROM STUDENT \nJOIN CLASS ON STUDENT.STU_NUM = ENROLL.STU_NUM \nJOIN ENROLL ON CLASS.CLASS_CODE = ENROLL.CLASS_CODE \nJOIN COURSE ON CLASS.CRS_CODE = COURSE.CRS_CODE \nJOIN DEPARTMENT AS D3 ON COURSE.DEPT_CODE = D3.DEPT_CODE \nWHERE D3.DEPT_NAME = 'Computer Info. Systems';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the department's name.\",\n    \"1\": \"This virtual table provides a distinct list of first names of employees and their highest degrees from the 'CLASS', 'EMPLOYEE', 'PROFESSOR', and 'DEPARTMENT' tables. The results are filtered based on a specific department name provided as a placeholder.\",\n    \"2\": \"This virtual table provides a distinct list of first names and dates of birth of professors from the 'employee' table who are teaching classes associated with a specific course code. The placeholder in the WHERE clause represents the course code for which the professors are being queried.\"\n}\n"}
{"sample_id": "train.3308", "db_id": "college_1", "question": "What are the first names and office of the professors who are in the history department and have a Ph.D?", "rationale": ["Identify the tables needed: PROFESSOR for professor details, DEPARTMENT for department information, and EMPLOYEE for employee details.", "We need to select the first names and office locations of professors, so we will select EMPLOYEE.EMP_FNAME and PROFESSOR.PROF_OFFICE.", "To filter for professors in the history department, we will join the PROFESSOR table with the DEPARTMENT table on DEPT_CODE and filter where DEPARTMENT.DEPT_NAME is 'History'.", "To filter for professors with a Ph.D., we will add a condition in the WHERE clause to check that PROFESSOR.PROF_HIGH_DEGREE is 'Ph.D'.", "Combine all these elements into a SQL SELECT statement that retrieves the desired information."], "gold_sql": "SELECT T1.emp_fname ,  T2.prof_office FROM employee AS T1 JOIN professor AS T2 ON T1.emp_num  =  T2.emp_num JOIN department AS T3 ON T3.dept_code  =  T2.dept_code WHERE T3.dept_name  =  'History' AND T2.prof_high_degree  =  'Ph.D.'", "source_tables": ["employee", "professor", "department"], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME, PROFESSOR.PROF_OFFICE \nFROM PROFESSOR \nJOIN DEPARTMENT ON PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE \nJOIN EMPLOYEE ON PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM \nWHERE DEPARTMENT.DEPT_NAME = 'History' AND PROFESSOR.PROF_HIGH_DEGREE = 'Ph.D';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n    \"1\": \"This virtual table provides a distinct list of first names and dates of birth of professors from the 'employee' table who are teaching classes associated with a specific course code. The placeholder in the WHERE clause represents the course code for which the professors are being queried.\",\n    \"2\": \"This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree level being queried.\"\n}\n"}
{"sample_id": "train.3319", "db_id": "college_1", "question": "Find names of all students who took some course and got A or C.", "rationale": ["Identify the tables needed: STUDENT for student names, ENROLL for enrollment details, and CLASS for class information.", "Join the STUDENT table with the ENROLL table on the student number to get the courses they are enrolled in.", "Join the resulting table with the CLASS table to access the class details.", "Filter the results to include only those students who received grades 'A' or 'C' in their enrolled classes.", "Select distinct first and last names of the students to avoid duplicates."], "gold_sql": "SELECT T1.stu_fname ,  T1.stu_lname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE T2.enroll_grade  =  'C' OR T2.enroll_grade  =  'A'", "source_tables": ["enroll", "student"], "pred_sql": "SELECT DISTINCT S.STU_FNAME, S.STU_LNAME \nFROM STUDENT S \nJOIN ENROLL E ON S.STU_NUM = E.STU_NUM \nJOIN CLASS C ON E.CLASS_CODE = C.CLASS_CODE \nWHERE E.ENROLL_GRADE IN ('A', 'C');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the department's name.\"\n}\n"}
{"sample_id": "train.3324", "db_id": "college_1", "question": "What are the different first names and highest degree attained for professors teaching in the Computer Information Systems department?", "rationale": ["Identify the tables needed: EMPLOYEE, PROFESSOR, and DEPARTMENT are required to get the first names and highest degrees of professors in a specific department.", "Determine the relationships: PROFESSOR is linked to EMPLOYEE through EMP_NUM, and DEPARTMENT is linked to PROFESSOR through DEPT_CODE.", "Filter the results: We need to filter the results to only include professors from the 'Computer Information Systems' department.", "Select the required columns: We need to select the first names (EMP_FNAME) from the EMPLOYEE table and the highest degree (PROF_HIGH_DEGREE) from the PROFESSOR table."], "gold_sql": "SELECT DISTINCT T2.emp_fname ,  T3.prof_high_degree FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN professor AS T3 ON T2.emp_num  =  T3.emp_num JOIN department AS T4 ON T4.dept_code  =  T3.dept_code WHERE T4.dept_name  =  'Computer Info. Systems'", "source_tables": ["employee", "professor", "class", "department"], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME, PROFESSOR.PROF_HIGH_DEGREE \nFROM EMPLOYEE \nJOIN PROFESSOR ON EMPLOYEE.EMP_NUM = PROFESSOR.EMP_NUM \nJOIN DEPARTMENT ON PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE \nWHERE DEPARTMENT.DEPT_NAME = 'Computer Information Systems';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n    \"1\": \"This virtual table provides a distinct list of first names of employees and their highest degrees from the 'CLASS', 'EMPLOYEE', 'PROFESSOR', and 'DEPARTMENT' tables. The results are filtered based on a specific department name provided as a placeholder.\",\n    \"2\": \"This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree level being queried.\"\n}\n"}
{"sample_id": "train.3333", "db_id": "college_1", "question": "Find the name of department that offers the class whose description has the word \"Statistics\".", "rationale": ["Identify the relevant tables: DEPARTMENT, COURSE, and CLASS are needed to find the department name for a specific class description.", "The relationship between these tables is established through foreign keys: CLASS.CRS_CODE links to COURSE.CRS_CODE, and COURSE.DEPT_CODE links to DEPARTMENT.DEPT_CODE.", "To find the department name for classes with descriptions containing 'Statistics', we need to filter the COURSE table based on the CRS_DESCRIPTION column.", "Use a JOIN operation to combine the DEPARTMENT, COURSE, and CLASS tables based on their relationships.", "The WHERE clause will filter the results to only include courses whose descriptions contain the word 'Statistics'.", "Finally, select the DEPARTMENT.DEPT_NAME to get the name of the department offering the class."], "gold_sql": "SELECT T2.dept_name FROM course AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.crs_description LIKE '%Statistics%'", "source_tables": ["course", "department"], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME \nFROM DEPARTMENT \nJOIN COURSE ON DEPARTMENT.DEPT_CODE = COURSE.DEPT_CODE \nJOIN CLASS ON COURSE.CRS_CODE = CLASS.CRS_CODE \nWHERE COURSE.CRS_DESCRIPTION LIKE '%Statistics%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n    \"1\": \"This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree level being queried.\",\n    \"2\": \"This virtual table provides a list of department names and their corresponding department codes from the 'professor' and 'department' tables. It filters the results based on the highest degree obtained by professors, using a placeholder for the degree type. The results are grouped by department code and ordered by the number of professors in each department, limited to a specified number of results.\"\n}\n"}
{"sample_id": "train.3343", "db_id": "sports_competition", "question": "What are the types and countries of competitions?", "rationale": ["Identify the relevant tables: The 'competition' table contains the types and countries of competitions.", "Select the columns needed: We need 'Competition_type' and 'Country' from the 'competition' table.", "Use DISTINCT to ensure unique combinations of competition types and countries are returned.", "Construct the SQL query to select the distinct competition types and their corresponding countries."], "gold_sql": "SELECT Competition_type ,  Country FROM competition", "source_tables": ["competition"], "pred_sql": "SELECT DISTINCT Competition_type, Country FROM competition;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the countries that hosted competitions of two specific types. The placeholders in the query represent the types of competitions being compared.\",\n    \"1\": \"This virtual table identifies the countries that hosted competitions of a specific type, by finding the intersection of countries from two separate queries for the same competition type. The placeholders in the WHERE clause represent the type of competition being queried.\",\n    \"2\": \"This virtual table lists the countries where competitions were held, excluding those countries that hosted competitions of a specific type. The placeholder in the WHERE clause represents the type of competition to be excluded.\"\n}\n"}
{"sample_id": "train.3355", "db_id": "sports_competition", "question": "Please show the names and the players of clubs.", "rationale": ["Identify the tables needed: 'club' for club names and 'player' for player names.", "Determine the relationship between the tables: 'player' has a foreign key 'Club_ID' that references 'club'.", "Use a JOIN operation to combine data from both tables based on the 'Club_ID'.", "Select the desired columns: the name of the club and the name of the player."], "gold_sql": "SELECT T1.name ,  T2.Player_id FROM club AS T1 JOIN player AS T2 ON T1.Club_ID  =  T2.Club_ID", "source_tables": ["club", "player"], "pred_sql": "SELECT c.name AS club_name, p.name AS player_name \nFROM club c \nJOIN player p ON c.Club_ID = p.Club_ID;", "hint": "\n"}
{"sample_id": "train.3364", "db_id": "sports_competition", "question": "What are the positions of players whose average number of points scored by that position is larger than 20?", "rationale": ["Identify the relevant table: The 'player' table contains the information about players and their positions.", "Determine the required calculation: We need to calculate the average number of points scored by players in each position.", "Group the results: Use GROUP BY to group the players by their Position.", "Apply the condition: Use HAVING to filter the groups where the average points scored is greater than 20."], "gold_sql": "SELECT POSITION FROM player GROUP BY name HAVING avg(Points)  >=  20", "source_tables": ["player"], "pred_sql": "SELECT Position FROM player GROUP BY Position HAVING AVG(Points) > 20;", "hint": "\n"}
{"sample_id": "train.3374", "db_id": "sports_competition", "question": "What are the positions of both players that have more than 20 20 points and less than 10 points?", "rationale": ["Identify the table that contains player information, which is the 'player' table.", "Determine the relevant column for player positions, which is 'Position'.", "Identify the column that contains the points scored by players, which is 'Points'.", "Formulate the condition to filter players with more than 20 points or less than 10 points.", "Construct the SQL query to select the 'Position' of players that meet the specified conditions."], "gold_sql": "SELECT POSITION FROM player WHERE Points  >  20 INTERSECT SELECT POSITION FROM player WHERE Points  <  10", "source_tables": ["player"], "pred_sql": "SELECT Position FROM player WHERE Points > 20 OR Points < 10;", "hint": "\n"}
{"sample_id": "train.3383", "db_id": "sports_competition", "question": "which country did participated in the most number of Tournament competitions?", "rationale": ["Identify the relevant table: The 'competition' table contains information about competitions, including their type and country.", "Filter for tournament competitions: We need to focus on rows where the 'Competition_type' is 'tournament'.", "Count the number of tournaments per country: Use the COUNT function to count the occurrences of each country in the filtered results.", "Group the results by country: Use GROUP BY to aggregate the counts for each country.", "Order the results: Sort the results in descending order based on the count of tournaments.", "Limit the results to the top entry: Use LIMIT 1 to get the country with the most tournaments."], "gold_sql": "SELECT country FROM competition WHERE competition_type  =  'Tournament' GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["competition"], "pred_sql": "SELECT Country, COUNT(*) as Tournament_Count \nFROM competition \nWHERE Competition_type = 'tournament' \nGROUP BY Country \nORDER BY Tournament_Count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the countries that hosted competitions of two specific types. The placeholders in the query represent the types of competitions being compared.\",\n    \"1\": \"This virtual table identifies the countries that hosted competitions of a specific type, by finding the intersection of countries from two separate queries for the same competition type. The placeholders in the WHERE clause represent the type of competition being queried.\",\n    \"2\": \"This virtual table lists the countries where competitions were held, excluding those countries that hosted competitions of a specific type. The placeholder in the WHERE clause represents the type of competition to be excluded.\"\n}\n"}
{"sample_id": "train.3384", "db_id": "sports_competition", "question": "what is the name of the country that participated in the most tournament competitions?", "rationale": ["Identify the relevant table: The 'competition' table contains information about competitions, including the type and country.", "Filter for tournament competitions: We need to focus on rows where the 'Competition_type' is 'tournament'.", "Count the occurrences: We will count how many times each country appears in the filtered results to determine participation.", "Group by country: We will group the results by 'Country' to aggregate the counts for each country.", "Order the results: We will order the results in descending order based on the count of tournaments to find the country with the most participation.", "Limit the results: Finally, we will limit the results to 1 to get the country with the highest count."], "gold_sql": "SELECT country FROM competition WHERE competition_type  =  'Tournament' GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["competition"], "pred_sql": "SELECT Country, COUNT(*) as Tournament_Count\nFROM competition\nWHERE Competition_type = 'tournament'\nGROUP BY Country\nORDER BY Tournament_Count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the countries that hosted competitions of two specific types. The placeholders in the query represent the types of competitions being compared.\",\n    \"1\": \"This virtual table identifies the countries that hosted competitions of a specific type, by finding the intersection of countries from two separate queries for the same competition type. The placeholders in the WHERE clause represent the type of competition being queried.\",\n    \"2\": \"This virtual table lists the countries where competitions were held, excluding those countries that hosted competitions of a specific type. The placeholder in the WHERE clause represents the type of competition to be excluded.\"\n}\n"}
{"sample_id": "train.3388", "db_id": "sports_competition", "question": "What are the countries that have never participated in any friendly-type competitions?", "rationale": ["Identify the countries that have hosted competitions by querying the competition table.", "Use a subquery to find countries that have hosted friendly-type competitions.", "Select distinct countries from the competition table that are not in the list of countries that hosted friendly-type competitions."], "gold_sql": "SELECT country FROM competition EXCEPT SELECT country FROM competition WHERE competition_type  =  'Friendly'", "source_tables": ["competition"], "pred_sql": "SELECT DISTINCT Country FROM competition WHERE Country NOT IN (SELECT Country FROM competition WHERE Competition_type = 'friendly')", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the countries where competitions were held, excluding those countries that hosted competitions of a specific type. The placeholder in the WHERE clause represents the type of competition to be excluded.\",\n    \"1\": \"This virtual table identifies the countries that hosted competitions of two specific types. The placeholders in the query represent the types of competitions being compared.\",\n    \"2\": \"This virtual table identifies the countries that hosted competitions of a specific type, by finding the intersection of countries from two separate queries for the same competition type. The placeholders in the WHERE clause represent the type of competition being queried.\"\n}\n"}
{"sample_id": "train.3407", "db_id": "hr_1", "question": "List the full name (first and last name), and salary for those employees who earn below 6000.", "rationale": ["Identify the relevant table: The 'employees' table contains the necessary information about employees, including their first name, last name, and salary.", "Determine the columns to select: We need to select the 'FIRST_NAME', 'LAST_NAME', and 'SALARY' columns from the 'employees' table.", "Set the condition for filtering: We want to filter the employees who earn below 6000, which will be done using a WHERE clause that checks if 'SALARY' is less than 6000."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees WHERE salary  <  6000", "source_tables": ["employees"], "pred_sql": "SELECT FIRST_NAME, LAST_NAME, SALARY FROM employees WHERE SALARY < 6000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\",\n    \"1\": \"This virtual table provides the first and last names of employees along with their department identifiers from the 'employees' table, specifically targeting those employees who earn the minimum salary within their respective departments. The subquery identifies the minimum salary for each department, and the placeholder in the WHERE clause allows for dynamic filtering based on salary criteria.\",\n    \"2\": \"This virtual table provides the first and last names of employees along with their department identifiers from the 'employees' table, specifically targeting those employees who earn the minimum salary within their respective departments. The subquery identifies the minimum salary for each department, and the placeholder in the WHERE clause allows for dynamic filtering based on salary criteria.\"\n}\n"}
{"sample_id": "train.3418", "db_id": "hr_1", "question": "What are the full name, hire date, salary, and department id for employees without the letter M in their first name?", "rationale": ["Identify the required fields: full name (concatenation of first and last names), hire date, salary, and department ID.", "To get the full name, we will concatenate the FIRST_NAME and LAST_NAME fields from the employees table.", "We need to filter employees whose first names do not contain the letter 'M'. This can be done using the NOT LIKE operator in the WHERE clause.", "Construct the SQL SELECT statement to retrieve the specified fields from the employees table with the appropriate filtering condition."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%'", "source_tables": ["employees"], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, HIRE_DATE, SALARY, DEPARTMENT_ID \nFROM employees \nWHERE FIRST_NAME NOT LIKE '%M%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\",\n    \"1\": \"This virtual table provides a list of employees' first names, last names, hire dates, salaries, and their department identifiers from the 'employees' table, excluding those whose first names match a specific pattern. The placeholder in the WHERE clause allows for filtering based on the first name criteria.\",\n    \"2\": \"This virtual table provides the first and last names of employees along with their department identifiers from the 'employees' table, specifically targeting those employees who earn the minimum salary within their respective departments. The subquery identifies the minimum salary for each department, and the placeholder in the WHERE clause allows for dynamic filtering based on salary criteria.\"\n}\n"}
{"sample_id": "train.3419", "db_id": "hr_1", "question": "display the full name (first and last), hire date, salary, and department number for those employees whose first name does not containing the letter M and make the result set in ascending order by department number.", "rationale": ["Identify the required fields: full name (first and last), hire date, salary, and department number.", "To get the full name, concatenate FIRST_NAME and LAST_NAME with a space in between.", "Filter employees whose first name does not contain the letter 'M'. This can be done using the NOT LIKE operator with a wildcard.", "Sort the results in ascending order by department number, which corresponds to the DEPARTMENT_ID column.", "Construct the SQL SELECT statement with the identified fields, filtering condition, and ordering clause."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, HIRE_DATE, SALARY, DEPARTMENT_ID \nFROM employees \nWHERE FIRST_NAME NOT LIKE '%M%' \nORDER BY DEPARTMENT_ID ASC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of employees' first names, last names, hire dates, salaries, and their department identifiers from the 'employees' table, excluding those whose first names match a specific pattern. The placeholder in the WHERE clause allows for filtering based on the first name criteria.\",\n    \"1\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\",\n    \"2\": \"This virtual table provides the first and last names of employees along with their department identifiers from the 'employees' table, specifically targeting those employees who earn the minimum salary within their respective departments. The subquery identifies the minimum salary for each department, and the placeholder in the WHERE clause allows for dynamic filtering based on salary criteria.\"\n}\n"}
{"sample_id": "train.3420", "db_id": "hr_1", "question": "What are the full name, hire data, salary and department id for employees without the letter M in their first name, ordered by ascending department id?", "rationale": ["Identify the required fields: full name (concatenation of first and last name), hire date, salary, and department ID.", "Use the 'employees' table to retrieve the necessary information.", "Filter the results to exclude employees whose first name contains the letter 'M'. This is done using the WHERE clause with the NOT LIKE operator.", "Order the results by department ID in ascending order using the ORDER BY clause."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, HIRE_DATE, SALARY, DEPARTMENT_ID \nFROM employees \nWHERE FIRST_NAME NOT LIKE '%M%' \nORDER BY DEPARTMENT_ID ASC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\",\n    \"1\": \"This virtual table provides a list of employees' first names, last names, hire dates, salaries, and their department identifiers from the 'employees' table, excluding those whose first names match a specific pattern. The placeholder in the WHERE clause allows for filtering based on the first name criteria.\",\n    \"2\": \"This virtual table provides the first and last names of employees along with their department identifiers from the 'employees' table, specifically targeting those employees who earn the minimum salary within their respective departments. The subquery identifies the minimum salary for each department, and the placeholder in the WHERE clause allows for dynamic filtering based on salary criteria.\"\n}\n"}
{"sample_id": "train.3442", "db_id": "hr_1", "question": "Which job titles correspond to jobs with salaries over 9000?", "rationale": ["Identify the relevant tables: We need to look at the 'jobs' table for job titles and the 'employees' table for salaries.", "Join the 'jobs' table with the 'employees' table on the JOB_ID to link job titles with employee salaries.", "Filter the results to include only those employees whose salary is greater than 9000.", "Select distinct job titles to avoid duplicates in the results."], "gold_sql": "SELECT job_title FROM jobs WHERE min_salary  >  9000", "source_tables": ["jobs"], "pred_sql": "SELECT DISTINCT jobs.JOB_TITLE \nFROM jobs \nJOIN employees ON jobs.JOB_ID = employees.JOB_ID \nWHERE employees.SALARY > 9000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of employees, including their unique identifiers, first names, last names, and job identifiers, who earn a salary greater than the maximum salary for a specified job. The placeholder in the subquery represents the job identifier for which the maximum salary is being compared.\",\n    \"1\": \"This virtual table provides a list of employees, including their unique identifiers, first names, last names, and job identifiers, who earn a salary greater than the maximum salary for a specified job. The placeholder in the subquery represents the job identifier for which the maximum salary is being compared.\",\n    \"2\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\"\n}\n"}
{"sample_id": "train.3444", "db_id": "hr_1", "question": "What are the job titles, and range of salaries for jobs with maximum salary between 12000 and 18000?", "rationale": ["Identify the relevant table: The 'jobs' table contains the job titles and salary information.", "Determine the required columns: We need 'JOB_TITLE', 'MIN_SALARY', and 'MAX_SALARY'.", "Specify the condition: We want jobs where the 'MAX_SALARY' is between 12000 and 18000.", "Construct the SQL query using SELECT to retrieve the specified columns from the 'jobs' table with the appropriate WHERE clause."], "gold_sql": "SELECT job_title ,  max_salary - min_salary FROM jobs WHERE max_salary BETWEEN 12000 AND 18000", "source_tables": ["jobs"], "pred_sql": "SELECT JOB_TITLE, MIN_SALARY, MAX_SALARY \nFROM jobs \nWHERE MAX_SALARY BETWEEN 12000 AND 18000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of employees, including their unique identifiers, first names, last names, and job identifiers, who earn a salary greater than the maximum salary for a specified job. The placeholder in the subquery represents the job identifier for which the maximum salary is being compared.\",\n    \"1\": \"This virtual table provides a list of employees, including their unique identifiers, first names, last names, and job identifiers, who earn a salary greater than the maximum salary for a specified job. The placeholder in the subquery represents the job identifier for which the maximum salary is being compared.\",\n    \"2\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\"\n}\n"}
{"sample_id": "train.3448", "db_id": "hr_1", "question": "What are the employee ids for each employee and final dates of employment at their last job?", "rationale": ["We need to retrieve the employee IDs and the final dates of employment at their last job.", "The relevant tables for this query are 'employees' and 'job_history'.", "We will join the 'employees' table with the 'job_history' table on the EMPLOYEE_ID column to get the necessary information.", "To find the last job's end date for each employee, we will use a subquery that selects the maximum END_DATE from the job_history table for each employee.", "The final SQL query will select the EMPLOYEE_ID from the employees table and the corresponding END_DATE from the job_history table, ensuring we only get the last job's end date for each employee."], "gold_sql": "SELECT employee_id ,  MAX(end_date) FROM job_history GROUP BY employee_id", "source_tables": ["job_history"], "pred_sql": "SELECT e.EMPLOYEE_ID, jh.END_DATE\nFROM employees e\nJOIN job_history jh ON e.EMPLOYEE_ID = jh.EMPLOYEE_ID\nWHERE jh.END_DATE = (SELECT MAX(END_DATE) FROM job_history WHERE EMPLOYEE_ID = e.EMPLOYEE_ID)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\",\n    \"1\": \"This virtual table provides a list of employees' first names, last names, hire dates, salaries, and their department identifiers from the 'employees' table, excluding those whose first names match a specific pattern. The placeholder in the WHERE clause allows for filtering based on the first name criteria.\",\n    \"2\": \"This virtual table provides the first and last names of employees along with their department identifiers from the 'employees' table, specifically targeting those employees who earn the minimum salary within their respective departments. The subquery identifies the minimum salary for each department, and the placeholder in the WHERE clause allows for dynamic filtering based on salary criteria.\"\n}\n"}
{"sample_id": "train.3453", "db_id": "hr_1", "question": "display the average salary of employees for each department who gets a commission percentage.", "rationale": ["We need to display the average salary of employees for each department who gets a commission percentage.", "To achieve this, we will select the department ID and the average salary of employees.", "We will join the 'employees' table with the 'departments' table on the DEPARTMENT_ID to associate employees with their respective departments.", "We will filter the employees to include only those who have a non-null COMMISSION_PCT, indicating they receive a commission.", "Finally, we will group the results by DEPARTMENT_ID to calculate the average salary for each department."], "gold_sql": "SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != 'null' GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT d.DEPARTMENT_ID, AVG(e.SALARY) AS average_salary\nFROM employees e\nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID\nWHERE e.COMMISSION_PCT IS NOT NULL\nGROUP BY d.DEPARTMENT_ID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the identifiers of departments from the 'employees' table that have more than a specified number of employees receiving a commission. The placeholder in the HAVING clause represents the minimum count of employees with a commission percentage.\",\n    \"1\": \"This virtual table provides a list of employees, including their unique identifier, first name, last name, and salary, from the 'employees' table. It filters the results to show only those employees whose salary is greater than the average salary of all employees and belong to departments where the first name of at least one employee matches a specified pattern.\",\n    \"2\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\"\n}\n"}
{"sample_id": "train.3454", "db_id": "hr_1", "question": "What is the average salary of employees who have a commission percentage that is not null?", "rationale": ["Identify the table that contains salary information, which is the 'employees' table.", "Determine the condition for filtering employees, which is that the 'COMMISSION_PCT' should not be null.", "Use the AVG() function to calculate the average salary of the filtered employees.", "Construct the SQL query to select the average salary from the 'employees' table with the specified condition."], "gold_sql": "SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != 'null' GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT AVG(SALARY) AS average_salary\nFROM employees\nWHERE COMMISSION_PCT IS NOT NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the identifiers of departments from the 'employees' table that have more than a specified number of employees receiving a commission. The placeholder in the HAVING clause represents the minimum count of employees with a commission percentage.\",\n    \"1\": \"This virtual table provides a list of employees, including their unique identifier, first name, last name, and salary, from the 'employees' table. It filters the results to show only those employees whose salary is greater than the average salary of all employees and belong to departments where the first name of at least one employee matches a specified pattern.\",\n    \"2\": \"This virtual table provides a list of employees, including their unique identifiers, first names, last names, and job identifiers, who earn a salary greater than the maximum salary for a specified job. The placeholder in the subquery represents the job identifier for which the maximum salary is being compared.\"\n}\n"}
{"sample_id": "train.3455", "db_id": "hr_1", "question": "display the country ID and number of cities for each country.", "rationale": ["Identify the required columns: COUNTRY_ID from countries and the count of cities from locations.", "To get the number of cities for each country, we need to join the countries table with the locations table on the COUNTRY_ID.", "Use the COUNT function to count the number of cities for each country.", "Group the results by COUNTRY_ID to ensure we get a count for each country."], "gold_sql": "SELECT country_id ,  COUNT(*) FROM locations GROUP BY country_id", "source_tables": ["locations"], "pred_sql": "SELECT countries.COUNTRY_ID, COUNT(locations.CITY) AS number_of_cities\nFROM countries\nJOIN locations ON countries.COUNTRY_ID = locations.COUNTRY_ID\nGROUP BY countries.COUNTRY_ID;", "hint": "\n"}
{"sample_id": "train.3456", "db_id": "hr_1", "question": "Give the country id and corresponding count of cities in each country.", "rationale": ["Identify the tables needed: We need data from the 'countries' table for country IDs and from the 'locations' table for cities.", "Determine the relationship: The 'locations' table has a foreign key 'COUNTRY_ID' that links to the 'countries' table.", "Use a JOIN to combine the 'countries' and 'locations' tables on 'COUNTRY_ID'.", "Count the number of cities for each country using COUNT() function and group the results by 'COUNTRY_ID'.", "Select the 'COUNTRY_ID' and the count of cities as 'CITY_COUNT' in the final output."], "gold_sql": "SELECT country_id ,  COUNT(*) FROM locations GROUP BY country_id", "source_tables": ["locations"], "pred_sql": "SELECT c.COUNTRY_ID, COUNT(l.CITY) AS CITY_COUNT\nFROM countries c\nJOIN locations l ON c.COUNTRY_ID = l.COUNTRY_ID\nGROUP BY c.COUNTRY_ID;", "hint": "\n"}
{"sample_id": "train.3465", "db_id": "hr_1", "question": "Can you return all detailed info of jobs which was done by any of the employees who is presently earning a salary on and above 12000?", "rationale": ["The query needs to return detailed information about jobs done by employees earning a salary of 12000 or more.", "To achieve this, we will select all columns from the 'jobs' table.", "We need to filter the jobs based on the job IDs of employees who meet the salary condition.", "We will use a subquery to select the JOB_IDs from the 'employees' table where the SALARY is greater than or equal to 12000.", "Finally, we will use the IN clause to match the JOB_IDs from the 'jobs' table with those obtained from the subquery."], "gold_sql": "SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  12000", "source_tables": ["job_history", "employees"], "pred_sql": "SELECT jobs.* \nFROM jobs \nWHERE jobs.JOB_ID IN (\n    SELECT employees.JOB_ID \n    FROM employees \n    WHERE employees.SALARY >= 12000\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of employees, including their unique identifiers, first names, last names, and job identifiers, who earn a salary greater than the maximum salary for a specified job. The placeholder in the subquery represents the job identifier for which the maximum salary is being compared.\",\n    \"1\": \"This virtual table provides a list of employees, including their unique identifiers, first names, last names, and job identifiers, who earn a salary greater than the maximum salary for a specified job. The placeholder in the subquery represents the job identifier for which the maximum salary is being compared.\",\n    \"2\": \"This virtual table provides a list of employees, including their unique identifier, first name, last name, and salary, from the 'employees' table. It filters the results to show only those employees whose salary is greater than the average salary of all employees and belong to departments where the first name of at least one employee matches a specified pattern.\"\n}\n"}
{"sample_id": "train.3482", "db_id": "hr_1", "question": "What is all the information regarding employees who are managers?", "rationale": ["Identify the employees who are managers by checking the MANAGER_ID field in the employees table.", "Use a subquery to select unique MANAGER_IDs from the employees table, ensuring that we only include those who are not null.", "The main query selects all information from the employees table where the EMPLOYEE_ID matches any of the MANAGER_IDs identified in the subquery."], "gold_sql": "SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T1.employee_id  =  T2.manager_id", "source_tables": ["employees", "departments"], "pred_sql": "SELECT * FROM employees WHERE EMPLOYEE_ID IN (SELECT MANAGER_ID FROM employees WHERE MANAGER_ID IS NOT NULL)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists unique department identifiers from the 'employees' table, grouped by department and manager. It filters the results to include only those departments that have a specified minimum number of employees, represented by a placeholder for numeric values.\",\n    \"1\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\",\n    \"2\": \"This virtual table provides a list of employees, including their unique identifier, first name, last name, and salary, from the 'employees' table. It filters the results to show only those employees whose salary is greater than the average salary of all employees and belong to departments where the first name of at least one employee matches a specified pattern.\"\n}\n"}
{"sample_id": "train.3487", "db_id": "hr_1", "question": "What are the unique ids of those departments where any manager is managing 4 or more employees.", "rationale": ["We need to find departments where any manager is managing 4 or more employees.", "To do this, we will use the 'employees' table, which contains information about employees and their respective departments and managers.", "We will select the 'DEPARTMENT_ID' from the 'employees' table.", "We will group the results by 'DEPARTMENT_ID' and 'MANAGER_ID' to count the number of employees under each manager in each department.", "Finally, we will use the HAVING clause to filter the groups to only include those where the count of employees is 4 or more."], "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"], "pred_sql": "SELECT DEPARTMENT_ID\nFROM employees\nGROUP BY DEPARTMENT_ID, MANAGER_ID\nHAVING COUNT(EMPLOYEE_ID) >= 4;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists unique department identifiers from the 'employees' table, grouped by department and manager. It filters the results to include only those departments that have a specified minimum number of employees, represented by a placeholder for numeric values.\",\n    \"1\": \"This virtual table lists the identifiers of departments from the 'employees' table that have more than a specified number of employees receiving a commission. The placeholder in the HAVING clause represents the minimum count of employees with a commission percentage.\",\n    \"2\": \"This virtual table describes the employee ID, first name, and last name of employees from the 'employees' table who belong to the same department as a specified employee. The placeholder in the WHERE clause allows for filtering based on the first name of the employee.\"\n}\n"}
{"sample_id": "train.3488", "db_id": "hr_1", "question": "Give the distinct department ids of departments in which a manager is in charge of 4 or more employees?", "rationale": ["We need to find distinct department IDs where a manager oversees 4 or more employees.", "To achieve this, we will use the 'employees' table, which contains the 'DEPARTMENT_ID' and 'MANAGER_ID'.", "We will group the results by 'DEPARTMENT_ID' and 'MANAGER_ID' to count the number of employees in each department managed by each manager.", "Using the HAVING clause, we will filter the groups to include only those with a count of employees greater than or equal to 4."], "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"], "pred_sql": "SELECT DEPARTMENT_ID\nFROM employees\nGROUP BY DEPARTMENT_ID, MANAGER_ID\nHAVING COUNT(EMPLOYEE_ID) >= 4;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists unique department identifiers from the 'employees' table, grouped by department and manager. It filters the results to include only those departments that have a specified minimum number of employees, represented by a placeholder for numeric values.\",\n    \"1\": \"This virtual table lists the identifiers of departments from the 'employees' table that have more than a specified number of employees receiving a commission. The placeholder in the HAVING clause represents the minimum count of employees with a commission percentage.\",\n    \"2\": \"This virtual table describes the employee ID, first name, and last name of employees from the 'employees' table who belong to the same department as a specified employee. The placeholder in the WHERE clause allows for filtering based on the first name of the employee.\"\n}\n"}
{"sample_id": "train.3496", "db_id": "hr_1", "question": "What is all the information regarding employees with salaries above the minimum and under 2500?", "rationale": ["Identify the relevant table: The 'employees' table contains the information about employees and their salaries.", "Determine the conditions: We need to find employees with salaries above the minimum salary for their job and below 2500.", "Use a subquery to get the minimum salary for each job: This is done by selecting MIN_SALARY from the 'jobs' table where JOB_ID matches the JOB_ID of the employee.", "Combine the conditions in the WHERE clause: We will filter employees based on the two conditions using the AND operator."], "gold_sql": "SELECT * FROM employees WHERE salary BETWEEN (SELECT MIN(salary) FROM employees) AND 2500", "source_tables": ["employees"], "pred_sql": "SELECT * FROM employees WHERE SALARY > (SELECT MIN_SALARY FROM jobs WHERE JOB_ID = employees.JOB_ID) AND SALARY < 2500;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of employees, including their unique identifiers, first names, last names, and job identifiers, who earn a salary greater than the maximum salary for a specified job. The placeholder in the subquery represents the job identifier for which the maximum salary is being compared.\",\n    \"1\": \"This virtual table provides a list of employees, including their unique identifiers, first names, last names, and job identifiers, who earn a salary greater than the maximum salary for a specified job. The placeholder in the subquery represents the job identifier for which the maximum salary is being compared.\",\n    \"2\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\"\n}\n"}
{"sample_id": "train.3500", "db_id": "hr_1", "question": "What are the full names and hire dates for employees in the same department as someone with the first name Clara?", "rationale": ["Identify the requirement to find full names and hire dates of employees in the same department as Clara.", "To get the full names, we need to concatenate the first and last names of employees.", "We need to filter employees based on their department ID, which can be obtained by finding Clara's department ID.", "A subquery is used to select the DEPARTMENT_ID of the employee with the first name 'Clara'.", "The main query selects the full names and hire dates of employees whose DEPARTMENT_ID matches that of Clara."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  (SELECT department_id FROM employees WHERE first_name  =  'Clara')", "source_tables": ["employees"], "pred_sql": "SELECT e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.HIRE_DATE \nFROM employees e \nWHERE e.DEPARTMENT_ID = (SELECT e2.DEPARTMENT_ID \n                         FROM employees e2 \n                         WHERE e2.FIRST_NAME = 'Clara')", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of employees' first names, last names, hire dates, salaries, and their department identifiers from the 'employees' table, excluding those whose first names match a specific pattern. The placeholder in the WHERE clause allows for filtering based on the first name criteria.\",\n    \"1\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\",\n    \"2\": \"This virtual table describes the employee ID, first name, and last name of employees from the 'employees' table who belong to the same department as a specified employee. The placeholder in the WHERE clause allows for filtering based on the first name of the employee.\"\n}\n"}
{"sample_id": "train.3502", "db_id": "hr_1", "question": "What are the full names and hire dates for employees in the same department as someone with the first name Clara, not including Clara?", "rationale": ["Identify the requirement to find full names and hire dates of employees in the same department as Clara.", "Use the employees table to get the first name, last name, and hire date.", "To get the full name, concatenate the first name and last name using '||'.", "Filter employees by department using a subquery that selects the DEPARTMENT_ID of the employee named Clara.", "Ensure that Clara is excluded from the results by adding a condition to filter out her first name."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  ( SELECT department_id FROM employees WHERE first_name  =  'Clara') AND first_name != 'Clara'", "source_tables": ["employees"], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, HIRE_DATE \nFROM employees \nWHERE DEPARTMENT_ID = (SELECT DEPARTMENT_ID \n                       FROM employees \n                       WHERE FIRST_NAME = 'Clara') \nAND FIRST_NAME != 'Clara';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of employees' first names, last names, hire dates, salaries, and their department identifiers from the 'employees' table, excluding those whose first names match a specific pattern. The placeholder in the WHERE clause allows for filtering based on the first name criteria.\",\n    \"1\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\",\n    \"2\": \"This virtual table provides the first and last names of employees along with their department identifiers from the 'employees' table, specifically targeting those employees who earn the minimum salary within their respective departments. The subquery identifies the minimum salary for each department, and the placeholder in the WHERE clause allows for dynamic filtering based on salary criteria.\"\n}\n"}
{"sample_id": "train.3503", "db_id": "hr_1", "question": "display the employee number and name( first name and last name ) for all employees who work in a department with any employee whose name contains a \u2019T\u2019.", "rationale": ["We need to display the employee number and name for employees who work in a department with any employee whose name contains a 'T'.", "To achieve this, we will select the EMPLOYEE_ID, FIRST_NAME, and LAST_NAME from the employees table.", "We will use a subquery to find the DEPARTMENT_IDs of employees whose FIRST_NAME or LAST_NAME contains 'T'.", "The subquery will filter employees based on the condition that their names contain 'T' using the LIKE operator.", "Finally, we will use the IN clause to filter the main query based on the DEPARTMENT_IDs obtained from the subquery."], "gold_sql": "SELECT employee_id ,  first_name ,  last_name FROM employees WHERE department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE '%T%' )", "source_tables": ["employees"], "pred_sql": "SELECT e.EMPLOYEE_ID, e.FIRST_NAME, e.LAST_NAME \nFROM employees e \nWHERE e.DEPARTMENT_ID IN (\n    SELECT e2.DEPARTMENT_ID \n    FROM employees e2 \n    WHERE e2.FIRST_NAME LIKE '%T%' OR e2.LAST_NAME LIKE '%T%'\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the employee ID, first name, and last name of employees from the 'employees' table who belong to the same department as a specified employee. The placeholder in the WHERE clause allows for filtering based on the first name of the employee.\",\n    \"1\": \"This virtual table provides a list of employees' first names, last names, hire dates, salaries, and their department identifiers from the 'employees' table, excluding those whose first names match a specific pattern. The placeholder in the WHERE clause allows for filtering based on the first name criteria.\",\n    \"2\": \"This virtual table lists unique department identifiers from the 'employees' table, grouped by department and manager. It filters the results to include only those departments that have a specified minimum number of employees, represented by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.3507", "db_id": "hr_1", "question": "display the employee number and job id for all employees whose salary is smaller than any salary of those employees whose job title is MK_MAN.", "rationale": ["Identify the main table to query: 'employees' for employee details.", "Select the columns needed: 'EMPLOYEE_ID' and 'JOB_ID'.", "Establish the condition for filtering: salary must be less than a certain value.", "Use a subquery to find the minimum salary of employees with the job title 'MK_MAN'.", "Join the 'employees' table with the 'jobs' table to access the job title for filtering.", "Construct the final SQL query using the selected columns and the filtering condition."], "gold_sql": "SELECT employee_id ,  job_id FROM employees WHERE salary  <  ( SELECT min(salary) FROM employees WHERE job_id  =  'MK_MAN' )", "source_tables": ["employees"], "pred_sql": "SELECT EMPLOYEE_ID, JOB_ID FROM employees WHERE SALARY < (SELECT MIN(SALARY) FROM employees JOIN jobs ON employees.JOB_ID = jobs.JOB_ID WHERE JOB_TITLE = 'MK_MAN')", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of employees, including their unique identifiers, first names, last names, and job identifiers, who earn a salary greater than the maximum salary for a specified job. The placeholder in the subquery represents the job identifier for which the maximum salary is being compared.\",\n    \"1\": \"This virtual table provides a list of employees, including their unique identifiers, first names, last names, and job identifiers, who earn a salary greater than the maximum salary for a specified job. The placeholder in the subquery represents the job identifier for which the maximum salary is being compared.\",\n    \"2\": \"This virtual table provides the first and last names of employees along with their department identifiers from the 'employees' table, specifically targeting those employees who earn the minimum salary within their respective departments. The subquery identifies the minimum salary for each department, and the placeholder in the WHERE clause allows for dynamic filtering based on salary criteria.\"\n}\n"}
{"sample_id": "train.3512", "db_id": "hr_1", "question": "What are total salaries and department id for each department that has more than 2 employees?", "rationale": ["We need to find the total salaries and department IDs for departments with more than 2 employees.", "To achieve this, we will use the 'employees' table which contains the necessary information about employee salaries and their department IDs.", "We will use the SUM function to calculate the total salary for each department.", "We will group the results by DEPARTMENT_ID to aggregate the salaries for each department.", "To filter departments with more than 2 employees, we will use the HAVING clause with COUNT(EMPLOYEE_ID) > 2."], "gold_sql": "SELECT department_id ,  SUM(salary) FROM employees GROUP BY department_id HAVING count(*)  >=  2", "source_tables": ["employees"], "pred_sql": "SELECT DEPARTMENT_ID, SUM(SALARY) AS TOTAL_SALARY \nFROM employees \nGROUP BY DEPARTMENT_ID \nHAVING COUNT(EMPLOYEE_ID) > 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\",\n    \"1\": \"This virtual table provides the first and last names of employees along with their department identifiers from the 'employees' table, specifically targeting those employees who earn the minimum salary within their respective departments. The subquery identifies the minimum salary for each department, and the placeholder in the WHERE clause allows for dynamic filtering based on salary criteria.\",\n    \"2\": \"This virtual table provides the first and last names of employees along with their department identifiers from the 'employees' table, specifically targeting those employees who earn the minimum salary within their respective departments. The subquery identifies the minimum salary for each department, and the placeholder in the WHERE clause allows for dynamic filtering based on salary criteria.\"\n}\n"}
{"sample_id": "train.3515", "db_id": "hr_1", "question": "display the department ID, full name (first and last name), salary for those employees who is highest salary in every department.", "rationale": ["We need to display the department ID, full name (first and last name), and salary of employees with the highest salary in each department.", "To achieve this, we will select the DEPARTMENT_ID, concatenate FIRST_NAME and LAST_NAME to create FULL_NAME, and select the SALARY from the employees table.", "We will use a subquery to find the maximum salary for each department. The subquery will select the MAX(SALARY) from the employees table, filtering by the DEPARTMENT_ID of the outer query.", "The outer query will filter the employees to only include those whose salary matches the maximum salary found in the subquery for their respective department."], "gold_sql": "SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT e.DEPARTMENT_ID, e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.SALARY \nFROM employees e \nWHERE e.SALARY = (SELECT MAX(SALARY) \n                   FROM employees \n                   WHERE DEPARTMENT_ID = e.DEPARTMENT_ID)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\",\n    \"1\": \"This virtual table provides a list of employees, including their unique identifier, first name, last name, and salary, from the 'employees' table. It filters the results to show only those employees whose salary is greater than the average salary of all employees and belong to departments where the first name of at least one employee matches a specified pattern.\",\n    \"2\": \"This virtual table provides the first and last names of employees along with their department identifiers from the 'employees' table, specifically targeting those employees who earn the minimum salary within their respective departments. The subquery identifies the minimum salary for each department, and the placeholder in the WHERE clause allows for dynamic filtering based on salary criteria.\"\n}\n"}
{"sample_id": "train.3520", "db_id": "hr_1", "question": "What are the full names and cities of employees who have the letter Z in their first names?", "rationale": ["Identify the required fields: full names (first and last) and cities of employees.", "To get the full name, concatenate the first name and last name using '||'.", "The employees table contains first names and last names, while the cities are in the locations table.", "To connect employees to their locations, join the employees table with the departments table on DEPARTMENT_ID, and then join the departments table with the locations table on LOCATION_ID.", "Filter the results to include only those employees whose first names contain the letter 'Z' using the LIKE operator."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T3.city FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id WHERE T1.first_name LIKE '%z%'", "source_tables": ["employees", "departments", "locations"], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, CITY \nFROM employees \nJOIN departments ON employees.DEPARTMENT_ID = departments.DEPARTMENT_ID \nJOIN locations ON departments.LOCATION_ID = locations.LOCATION_ID \nWHERE FIRST_NAME LIKE '%Z%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\",\n    \"1\": \"This virtual table provides a list of employees' first names, last names, hire dates, salaries, and their department identifiers from the 'employees' table, excluding those whose first names match a specific pattern. The placeholder in the WHERE clause allows for filtering based on the first name criteria.\"\n}\n"}
{"sample_id": "train.3523", "db_id": "hr_1", "question": "display the full name (first and last name ) of employee with ID and name of the country presently where (s)he is working.", "rationale": ["Identify the tables needed: employees, departments, locations, and countries.", "We need to join these tables to get the employee's full name and the country they are currently working in.", "The employee's full name can be constructed by concatenating the FIRST_NAME and LAST_NAME from the employees table.", "To find the country, we need to join the employees table with the departments table on DEPARTMENT_ID, then join with the locations table on LOCATION_ID, and finally join with the countries table on COUNTRY_ID.", "The WHERE clause will filter the results to only include the employee with the specified EMPLOYEE_ID."], "gold_sql": "SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id", "source_tables": ["countries", "employees", "departments", "locations"], "pred_sql": "SELECT e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, c.COUNTRY_NAME \nFROM employees e \nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nJOIN locations l ON d.LOCATION_ID = l.LOCATION_ID \nJOIN countries c ON l.COUNTRY_ID = c.COUNTRY_ID \nWHERE e.EMPLOYEE_ID = ?;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the employee ID, first name, and last name of employees from the 'employees' table who belong to the same department as a specified employee. The placeholder in the WHERE clause allows for filtering based on the first name of the employee.\",\n    \"1\": \"This virtual table provides a list of employees' first names, last names, hire dates, salaries, and their department identifiers from the 'employees' table, excluding those whose first names match a specific pattern. The placeholder in the WHERE clause allows for filtering based on the first name criteria.\",\n    \"2\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\"\n}\n"}
{"sample_id": "train.3525", "db_id": "hr_1", "question": "display the department name and number of employees in each of the department.", "rationale": ["We need to display the department name and the number of employees in each department.", "To achieve this, we will select the 'DEPARTMENT_NAME' from the 'departments' table.", "We will also count the number of employees associated with each department, which can be done using the COUNT function on 'EMPLOYEE_ID' from the 'employees' table.", "To link the departments with their employees, we will perform a LEFT JOIN between the 'departments' table and the 'employees' table on the 'DEPARTMENT_ID'.", "Finally, we will group the results by 'DEPARTMENT_NAME' to get the count of employees for each department."], "gold_sql": "SELECT department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY department_name", "source_tables": ["employees", "departments"], "pred_sql": "SELECT d.DEPARTMENT_NAME, COUNT(e.EMPLOYEE_ID) AS NUMBER_OF_EMPLOYEES\nFROM departments d\nLEFT JOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID\nGROUP BY d.DEPARTMENT_NAME;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists unique department identifiers from the 'employees' table, grouped by department and manager. It filters the results to include only those departments that have a specified minimum number of employees, represented by a placeholder for numeric values.\",\n    \"1\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\",\n    \"2\": \"This virtual table lists the identifiers of departments from the 'employees' table that have more than a specified number of employees receiving a commission. The placeholder in the HAVING clause represents the minimum count of employees with a commission percentage.\"\n}\n"}
{"sample_id": "train.3526", "db_id": "hr_1", "question": "What are the department names and how many employees work in each of them?", "rationale": ["We need to retrieve the names of departments and the count of employees in each department.", "The relevant tables for this query are 'departments' and 'employees'.", "We will use a LEFT JOIN to connect the 'departments' table with the 'employees' table on the 'DEPARTMENT_ID' column.", "We will select the 'DEPARTMENT_NAME' from the 'departments' table and count the 'EMPLOYEE_ID' from the 'employees' table to get the number of employees in each department.", "Finally, we will group the results by 'DEPARTMENT_NAME' to get the count of employees for each department."], "gold_sql": "SELECT department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY department_name", "source_tables": ["employees", "departments"], "pred_sql": "SELECT d.DEPARTMENT_NAME, COUNT(e.EMPLOYEE_ID) AS EMPLOYEE_COUNT\nFROM departments d\nLEFT JOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID\nGROUP BY d.DEPARTMENT_NAME;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\",\n    \"1\": \"This virtual table lists unique department identifiers from the 'employees' table, grouped by department and manager. It filters the results to include only those departments that have a specified minimum number of employees, represented by a placeholder for numeric values.\",\n    \"2\": \"This virtual table provides the first and last names of employees along with their department identifiers from the 'employees' table, specifically targeting those employees who earn the minimum salary within their respective departments. The subquery identifies the minimum salary for each department, and the placeholder in the WHERE clause allows for dynamic filtering based on salary criteria.\"\n}\n"}
{"sample_id": "train.3527", "db_id": "hr_1", "question": "display the full name (first and last name), and salary of those employees who working in any department located in London.", "rationale": ["We need to display the full name (first and last name) and salary of employees.", "The relevant table for employee information is the 'employees' table, which contains first names, last names, and salaries.", "To find the departments where these employees work, we need to join the 'departments' table using the DEPARTMENT_ID.", "Next, we need to filter these departments based on their location, which is found in the 'locations' table.", "We will join the 'locations' table using the LOCATION_ID from the 'departments' table.", "Finally, we will filter the results to only include departments located in London by using a WHERE clause that checks if the CITY in the 'locations' table is 'London'."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  'London'", "source_tables": ["employees", "departments", "locations"], "pred_sql": "SELECT e.FIRST_NAME, e.LAST_NAME, e.SALARY \nFROM employees e \nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nJOIN locations l ON d.LOCATION_ID = l.LOCATION_ID \nWHERE l.CITY = 'London';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\",\n    \"1\": \"This virtual table provides the first and last names of employees along with their department identifiers from the 'employees' table, specifically targeting those employees who earn the minimum salary within their respective departments. The subquery identifies the minimum salary for each department, and the placeholder in the WHERE clause allows for dynamic filtering based on salary criteria.\",\n    \"2\": \"This virtual table provides the first and last names of employees along with their department identifiers from the 'employees' table, specifically targeting those employees who earn the minimum salary within their respective departments. The subquery identifies the minimum salary for each department, and the placeholder in the WHERE clause allows for dynamic filtering based on salary criteria.\"\n}\n"}
{"sample_id": "train.3528", "db_id": "hr_1", "question": "What are full names and salaries of employees working in the city of London?", "rationale": ["Identify the relevant tables: employees, departments, locations, and countries are needed to get employee names and salaries based on their location.", "To get the full names of employees, concatenate the FIRST_NAME and LAST_NAME from the employees table.", "To filter employees based on the city, join the employees table with the departments table to access the LOCATION_ID, then join with the locations table to filter by CITY.", "Finally, join the locations table with the countries table to ensure the data integrity, although in this case, we are only interested in the city of London."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  'London'", "source_tables": ["employees", "departments", "locations"], "pred_sql": "SELECT e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.SALARY \nFROM employees e \nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nJOIN locations l ON d.LOCATION_ID = l.LOCATION_ID \nJOIN countries c ON l.COUNTRY_ID = c.COUNTRY_ID \nWHERE l.CITY = 'London';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\",\n    \"1\": \"This virtual table provides a list of employees' first names, last names, hire dates, salaries, and their department identifiers from the 'employees' table, excluding those whose first names match a specific pattern. The placeholder in the WHERE clause allows for filtering based on the first name criteria.\",\n    \"2\": \"This virtual table provides a list of employees, including their unique identifier, first name, last name, and salary, from the 'employees' table. It filters the results to show only those employees whose salary is greater than the average salary of all employees and belong to departments where the first name of at least one employee matches a specified pattern.\"\n}\n"}
{"sample_id": "train.3532", "db_id": "music_1", "question": "Find the id of the song that lasts the longest.", "rationale": ["Identify the goal: We need to find the id of the song that lasts the longest.", "Understand the schema: The 'song' table contains the 'duration' column which we can use to find the longest song.", "Use a subquery to find the maximum duration from the 'song' table.", "Select the song name from the 'song' table where the duration matches the maximum duration found in the subquery."], "gold_sql": "SELECT f_id FROM files ORDER BY duration DESC LIMIT 1", "source_tables": ["files"], "pred_sql": "SELECT song_name FROM song WHERE duration = (SELECT MAX(duration) FROM song);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the maximum duration and resolution of audio files, along with the languages in which the songs are available. The data is aggregated by languages, allowing users to see the longest audio files and their highest resolutions for each language category.\",\n    \"1\": \"This virtual table provides a list of song titles from the 'files' and 'song' tables based on specific criteria. It retrieves song names associated with files that match a certain duration and also includes song names that are available in a specified language. The placeholders in the WHERE clause represent the duration format and the language of the songs.\",\n    \"2\": \"This virtual table provides a list of song titles from the 'files' and 'song' tables based on specific criteria. It retrieves song names associated with files that match a certain duration and also includes song names from the 'song' table that are available in a specified language. The placeholders in the WHERE clause represent the duration format and the language of the songs.\"\n}\n"}
{"sample_id": "train.3542", "db_id": "music_1", "question": "What are the names of the artists who sang the shortest song?", "rationale": ["Identify the relevant table: The 'song' table contains information about songs, including their duration and the artist's name.", "Determine the requirement: We need to find the names of artists who sang the shortest song, which means we need to find the minimum duration of songs.", "Use a subquery to find the minimum duration: We can use a subquery to select the minimum duration from the 'song' table.", "Filter the main query: We will filter the main query to select artist names where the song's duration matches the minimum duration found in the subquery."], "gold_sql": "SELECT T1.artist_name FROM song AS T1 JOIN files AS T2 ON T1.f_id  =  T2.f_id ORDER BY T2.duration LIMIT 1", "source_tables": ["files", "song"], "pred_sql": "SELECT artist_name FROM song WHERE duration = (SELECT MIN(duration) FROM song);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, sorted in descending order based on the count of songs per language, and limited to a specified number of results.\",\n    \"1\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, and ordered by the count of songs in descending order, limited to a specified number of results.\",\n    \"2\": \"This virtual table lists the names of artists from the 'artist' table who have songs available in a specific language. The query joins the 'artist' and 'song' tables on the artist's name, filters the results based on the specified language, groups the results by artist name, and orders them by the number of songs in descending order, limiting the output to a specified number of artists.\"\n}\n"}
{"sample_id": "train.3545", "db_id": "music_1", "question": "How many songs have 4 minute duration?", "rationale": ["Identify the relevant table: The 'song' table contains the duration of songs.", "Determine the condition: We need to find songs with a duration of 4 minutes, which is represented as '4:00'.", "Construct the SQL query: Use the COUNT function to count the number of records in the 'song' table that meet the duration condition."], "gold_sql": "SELECT count(*) FROM files WHERE duration LIKE '4:%'", "source_tables": ["files"], "pred_sql": "SELECT COUNT(*) FROM song WHERE duration = '4:00';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the minimum duration of audio files and the minimum rating of songs grouped by their genre. The placeholders represent the necessary fields from the 'files' and 'song' tables, allowing users to analyze the relationship between audio file durations and song ratings across different genres.\",\n    \"1\": \"This virtual table provides the maximum duration and resolution of audio files, along with the languages in which the songs are available. The data is aggregated by languages, allowing users to see the longest audio files and their highest resolutions for each language category.\",\n    \"2\": \"This virtual table provides a list of song titles from the 'files' and 'song' tables based on specific criteria. It retrieves song names associated with files that match a certain duration and also includes song names that are available in a specified language. The placeholders in the WHERE clause represent the duration format and the language of the songs.\"\n}\n"}
{"sample_id": "train.3549", "db_id": "music_1", "question": "What is the average rating of songs produced by female artists?", "rationale": ["Identify the tables needed: We need the 'song' table to get the ratings and the 'artist' table to filter by gender.", "Join the 'song' table with the 'artist' table on the 'artist_name' column to access both song ratings and artist gender.", "Filter the results to include only female artists by adding a WHERE clause that checks if the gender is 'female'.", "Use the AVG() function to calculate the average rating of the songs produced by female artists."], "gold_sql": "SELECT avg(T2.rating) FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  'Female'", "source_tables": ["artist", "song"], "pred_sql": "SELECT AVG(s.rating) AS average_rating\nFROM song s\nJOIN artist a ON s.artist_name = a.artist_name\nWHERE a.gender = 'female';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the minimum duration of audio files and the minimum rating of songs grouped by their genre. The placeholders represent the necessary fields from the 'files' and 'song' tables, allowing users to analyze the relationship between audio file durations and song ratings across different genres.\",\n    \"1\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, sorted in descending order based on the count of songs per language, and limited to a specified number of results.\",\n    \"2\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, and ordered by the count of songs in descending order, limited to a specified number of results.\"\n}\n"}
{"sample_id": "train.3552", "db_id": "music_1", "question": "Find the file format that is used by the most files.", "rationale": ["To find the file format used by the most files, we need to count the occurrences of each format in the 'files' table.", "We will use the COUNT() function to count the number of files for each format.", "We will group the results by the 'formats' column to aggregate the counts for each format.", "To get the format that is used the most, we will order the results in descending order based on the count of files.", "Finally, we will limit the results to 1 to get only the most used file format."], "gold_sql": "SELECT formats FROM files GROUP BY formats ORDER BY COUNT (*) DESC LIMIT 1", "source_tables": ["files"], "pred_sql": "SELECT formats, COUNT(*) as file_count \nFROM files \nGROUP BY formats \nORDER BY file_count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the maximum duration and resolution of audio files, along with the languages in which the songs are available. The data is aggregated by languages, allowing users to see the longest audio files and their highest resolutions for each language category.\",\n    \"1\": \"This virtual table provides the minimum duration of audio files and the minimum rating of songs grouped by their genre. The placeholders represent the necessary fields from the 'files' and 'song' tables, allowing users to analyze the relationship between audio file durations and song ratings across different genres.\",\n    \"2\": \"This virtual table provides a list of song titles from the 'files' and 'song' tables based on specific criteria. It retrieves song names associated with files that match a certain duration and also includes song names that are available in a specified language. The placeholders in the WHERE clause represent the duration format and the language of the songs.\"\n}\n"}
{"sample_id": "train.3556", "db_id": "music_1", "question": "What is the id of the files that are available in the format of mp4 and a resolution smaller than 1000?", "rationale": ["Identify the relevant table: The 'files' table contains the 'f_id', 'formats', and 'resolution' columns needed for the query.", "Determine the conditions: We need to filter files that are in the 'mp4' format and have a resolution smaller than 1000.", "Use the LIKE operator to check for 'mp4' in the 'formats' column, and use a comparison operator to check if 'resolution' is less than 1000.", "Since 'resolution' is stored as text, we need to cast it to an integer for the comparison to work correctly.", "Construct the SQL query to select 'f_id' from the 'files' table with the specified conditions."], "gold_sql": "SELECT f_id FROM files WHERE formats  =  'mp4' INTERSECT SELECT f_id FROM song WHERE resolution  <  1000", "source_tables": ["files", "song"], "pred_sql": "SELECT f_id FROM files WHERE formats LIKE '%mp4%' AND CAST(resolution AS INTEGER) < 1000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the maximum duration and resolution of audio files, along with the languages in which the songs are available. The data is aggregated by languages, allowing users to see the longest audio files and their highest resolutions for each language category.\",\n    \"1\": \"This virtual table provides the minimum duration of audio files and the minimum rating of songs grouped by their genre. The placeholders represent the necessary fields from the 'files' and 'song' tables, allowing users to analyze the relationship between audio file durations and song ratings across different genres.\",\n    \"2\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, and ordered by the count of songs in descending order, limited to a specified number of results.\"\n}\n"}
{"sample_id": "train.3557", "db_id": "music_1", "question": "What is the country of origin of the artist who is female and produced a song in Bangla?", "rationale": ["Identify the relevant tables: 'artist' and 'song'.", "We need to find artists who are female, so we will filter the 'artist' table by gender.", "We also need to find songs that are in Bangla, so we will filter the 'song' table by the 'languages' column.", "To get the country of origin of the artist, we will select the 'country' column from the 'artist' table.", "We will join the 'artist' and 'song' tables on the 'artist_name' column to link artists with their songs.", "The final SQL query will select the country of female artists who have produced songs in Bangla."], "gold_sql": "SELECT T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  'Female' AND T2.languages  =  'bangla'", "source_tables": ["artist", "song"], "pred_sql": "SELECT artist.country FROM artist JOIN song ON artist.artist_name = song.artist_name WHERE artist.gender = 'female' AND song.languages LIKE '%Bangla%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of artists from the 'artist' table who have songs available in a specific language. The query joins the 'artist' and 'song' tables on the artist's name, filters the results based on the specified language, groups the results by artist name, and orders them by the number of songs in descending order, limiting the output to a specified number of artists.\",\n    \"1\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, sorted in descending order based on the count of songs per language, and limited to a specified number of results.\",\n    \"2\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, and ordered by the count of songs in descending order, limited to a specified number of results.\"\n}\n"}
{"sample_id": "train.3558", "db_id": "music_1", "question": "What countries are the female artists who sung in the language Bangla from?", "rationale": ["Identify the relevant tables: We need to use the 'artist' table to get the countries of female artists and the 'song' table to filter by the language Bangla.", "Filter the 'artist' table for female artists by using the condition 'gender = 'female'',' and select the 'country' column.", "To find artists who have sung in Bangla, we need to join the 'artist' table with the 'song' table based on the 'artist_name'.", "Use a subquery to select 'artist_name' from the 'song' table where the 'languages' column contains 'Bangla'.", "Combine the conditions to filter the 'artist' table based on gender and the results of the subquery to get the final list of countries."], "gold_sql": "SELECT T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  'Female' AND T2.languages  =  'bangla'", "source_tables": ["artist", "song"], "pred_sql": "SELECT country FROM artist WHERE gender = 'female' AND artist_name IN (SELECT artist_name FROM song WHERE languages LIKE '%Bangla%');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of artists from the 'artist' table who have songs available in a specific language. The query joins the 'artist' and 'song' tables on the artist's name, filters the results based on the specified language, groups the results by artist name, and orders them by the number of songs in descending order, limiting the output to a specified number of artists.\",\n    \"1\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, sorted in descending order based on the count of songs per language, and limited to a specified number of results.\",\n    \"2\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, and ordered by the count of songs in descending order, limited to a specified number of results.\"\n}\n"}
{"sample_id": "train.3566", "db_id": "music_1", "question": "What is the gender and name of the artist who sang the song with the smallest resolution?", "rationale": ["Identify the tables needed: We need information from the 'artist' table for gender and name, and the 'song' table to link artists to their songs.", "To find the song with the smallest resolution, we need to join the 'files' table to access the resolution data.", "We will use a subquery to find the minimum resolution from the 'files' table.", "Join the 'artist' table with the 'song' table on 'artist_name' and the 'files' table on 'f_id' to get the required information.", "Select the gender and name of the artist where the resolution matches the minimum resolution found in the subquery."], "gold_sql": "SELECT T1.gender ,  T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.resolution LIMIT 1", "source_tables": ["artist", "song"], "pred_sql": "SELECT artist.gender, artist.artist_name \nFROM artist \nJOIN song ON artist.artist_name = song.artist_name \nJOIN files ON song.f_id = files.f_id \nWHERE files.resolution = (SELECT MIN(resolution) FROM files)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, sorted in descending order based on the count of songs per language, and limited to a specified number of results.\",\n    \"1\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, and ordered by the count of songs in descending order, limited to a specified number of results.\",\n    \"2\": \"This virtual table provides the maximum duration and resolution of audio files, along with the languages in which the songs are available. The data is aggregated by languages, allowing users to see the longest audio files and their highest resolutions for each language category.\"\n}\n"}
{"sample_id": "train.3567", "db_id": "music_1", "question": "For each file format, return the number of artists who released songs in that format.", "rationale": ["Identify the relevant tables: We need to consider the 'files' table for file formats and the 'song' table to link songs to their respective files.", "Join the 'files' table with the 'song' table on the 'f_id' column to associate each file format with the songs that use it.", "Group the results by the 'formats' column to count the number of distinct artists for each file format.", "Use COUNT(DISTINCT artist_name) to ensure we count each artist only once per format, regardless of how many songs they have in that format."], "gold_sql": "SELECT count(*) ,  formats FROM files GROUP BY formats", "source_tables": ["files"], "pred_sql": "SELECT formats, COUNT(DISTINCT artist_name) AS artist_count \nFROM files \nJOIN song ON files.f_id = song.f_id \nGROUP BY formats;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, and ordered by the count of songs in descending order, limited to a specified number of results.\",\n    \"1\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, sorted in descending order based on the count of songs per language, and limited to a specified number of results.\",\n    \"2\": \"This virtual table lists the names of artists from the 'artist' table who have songs available in a specific language. The query joins the 'artist' and 'song' tables on the artist's name, filters the results based on the specified language, groups the results by artist name, and orders them by the number of songs in descending order, limiting the output to a specified number of artists.\"\n}\n"}
{"sample_id": "train.3576", "db_id": "music_1", "question": "What are the names and genders of all artists who released songs in the month of March?", "rationale": ["Identify the tables needed: We need information from the 'artist' table for names and genders, and from the 'song' table to filter by release date.", "Determine the relationship between the tables: The 'artist' table can be joined with the 'song' table on the 'artist_name' column.", "Filter the songs released in March: Use the strftime function to extract the month from the 'releasedate' column in the 'song' table and check if it equals '03'.", "Select the required columns: We need to select 'artist_name' and 'gender' from the 'artist' table."], "gold_sql": "SELECT T1.artist_name ,  T1.gender FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.releasedate LIKE '%Mar%'", "source_tables": ["artist", "song"], "pred_sql": "SELECT artist.artist_name, artist.gender \nFROM artist \nJOIN song ON artist.artist_name = song.artist_name \nWHERE strftime('%m', song.releasedate) = '03';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, sorted in descending order based on the count of songs per language, and limited to a specified number of results.\",\n    \"1\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, and ordered by the count of songs in descending order, limited to a specified number of results.\",\n    \"2\": \"This virtual table lists the names of artists from the 'artist' table who have songs available in a specific language. The query joins the 'artist' and 'song' tables on the artist's name, filters the results based on the specified language, groups the results by artist name, and orders them by the number of songs in descending order, limiting the output to a specified number of artists.\"\n}\n"}
{"sample_id": "train.3586", "db_id": "music_1", "question": "What are the languages that are used most often in songs?", "rationale": ["Identify the relevant table: The 'song' table contains the 'languages' column which we need to analyze.", "Count the occurrences of each language: We will use COUNT(*) to count how many songs are available in each language.", "Group the results by language: We will use GROUP BY languages to aggregate the counts for each language.", "Order the results: We will order the results in descending order based on the count of songs per language to find the most used languages.", "Construct the SQL query: Combine all the elements into a complete SQL query."], "gold_sql": "SELECT languages FROM song GROUP BY languages ORDER BY count(*) DESC LIMIT 1", "source_tables": ["song"], "pred_sql": "SELECT languages, COUNT(*) as song_count \nFROM song \nGROUP BY languages \nORDER BY song_count DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of artists from the 'artist' table who have songs available in a specific language. The query joins the 'artist' and 'song' tables on the artist's name, filters the results based on the specified language, groups the results by artist name, and orders them by the number of songs in descending order, limiting the output to a specified number of artists.\",\n    \"1\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, sorted in descending order based on the count of songs per language, and limited to a specified number of results.\",\n    \"2\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, and ordered by the count of songs in descending order, limited to a specified number of results.\"\n}\n"}
{"sample_id": "train.3590", "db_id": "music_1", "question": "What are the names of all male British artists?", "rationale": ["Identify the relevant table: The 'artist' table contains information about artists, including their country and gender.", "Determine the filtering criteria: We need to filter artists based on their country (Britain) and gender (male).", "Construct the SQL query: Use a SELECT statement to retrieve the 'artist_name' from the 'artist' table where the conditions for country and gender are met."], "gold_sql": "SELECT artist_name FROM artist WHERE country  =  'UK' AND gender  =  'Male'", "source_tables": ["artist"], "pred_sql": "SELECT artist_name FROM artist WHERE country = 'Britain' AND gender = 'male';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, sorted in descending order based on the count of songs per language, and limited to a specified number of results.\",\n    \"1\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, and ordered by the count of songs in descending order, limited to a specified number of results.\",\n    \"2\": \"This virtual table lists the names of artists from the 'artist' table who have songs available in a specific language. The query joins the 'artist' and 'song' tables on the artist's name, filters the results based on the specified language, groups the results by artist name, and orders them by the number of songs in descending order, limiting the output to a specified number of artists.\"\n}\n"}
{"sample_id": "train.3598", "db_id": "music_1", "question": "What is the average rating and resolution of all bangla songs?", "rationale": ["Identify the relevant tables: We need to use the 'song' table to get the ratings and resolutions of songs.", "Determine the columns needed: We need the 'rating' and 'resolution' columns from the 'song' table.", "Filter the results: We need to filter the songs to only include those that belong to the 'Bangla' genre.", "Calculate the average: We will use the AVG() function to calculate the average rating and resolution for the filtered songs."], "gold_sql": "SELECT avg(rating) ,  avg(resolution) FROM song WHERE languages  =  'bangla'", "source_tables": ["song"], "pred_sql": "SELECT AVG(s.rating) AS average_rating, AVG(s.resolution) AS average_resolution \nFROM song s \nWHERE s.genre_is = 'Bangla';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the maximum duration and resolution of audio files, along with the languages in which the songs are available. The data is aggregated by languages, allowing users to see the longest audio files and their highest resolutions for each language category.\",\n    \"1\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, sorted in descending order based on the count of songs per language, and limited to a specified number of results.\",\n    \"2\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, and ordered by the count of songs in descending order, limited to a specified number of results.\"\n}\n"}
{"sample_id": "train.3599", "db_id": "music_1", "question": "What are the maximum and minimum resolution of songs whose duration is 3 minutes?", "rationale": ["Identify the relevant tables: The 'song' table contains the resolution and duration of songs.", "Determine the required fields: We need the maximum and minimum resolution of songs.", "Apply the condition: We need to filter songs based on the duration being exactly 3 minutes.", "Construct the SQL query: Use the MAX() and MIN() functions to get the required resolutions and filter by duration."], "gold_sql": "SELECT max(T2.resolution) ,  min(T2.resolution) FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.duration LIKE '3:%'", "source_tables": ["files", "song"], "pred_sql": "SELECT MAX(resolution) AS max_resolution, MIN(resolution) AS min_resolution \nFROM song \nWHERE duration = '3 minutes';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the maximum duration and resolution of audio files, along with the languages in which the songs are available. The data is aggregated by languages, allowing users to see the longest audio files and their highest resolutions for each language category.\",\n    \"1\": \"This virtual table provides the minimum duration of audio files and the minimum rating of songs grouped by their genre. The placeholders represent the necessary fields from the 'files' and 'song' tables, allowing users to analyze the relationship between audio file durations and song ratings across different genres.\",\n    \"2\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, and ordered by the count of songs in descending order, limited to a specified number of results.\"\n}\n"}
{"sample_id": "train.3601", "db_id": "music_1", "question": "What are the maximum duration and resolution of songs grouped and ordered by languages?", "rationale": ["Identify the relevant columns needed: 'duration', 'resolution', and 'languages' from the 'song' table.", "Use the MAX() function to find the maximum duration and resolution for each language.", "Group the results by 'languages' to aggregate the data accordingly.", "Order the results by 'languages' to present them in a structured manner."], "gold_sql": "SELECT max(T1.duration) ,  max(T2.resolution) ,  T2.languages FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.languages ORDER BY T2.languages", "source_tables": ["files", "song"], "pred_sql": "SELECT languages, MAX(duration) AS max_duration, MAX(resolution) AS max_resolution \nFROM song \nGROUP BY languages \nORDER BY languages;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the maximum duration and resolution of audio files, along with the languages in which the songs are available. The data is aggregated by languages, allowing users to see the longest audio files and their highest resolutions for each language category.\",\n    \"1\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, sorted in descending order based on the count of songs per language, and limited to a specified number of results.\",\n    \"2\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, and ordered by the count of songs in descending order, limited to a specified number of results.\"\n}\n"}
{"sample_id": "train.3603", "db_id": "music_1", "question": "What are the shortest duration and lowest rating of songs grouped by genre and ordered by genre?", "rationale": ["Identify the relevant tables: 'song' for song details and 'genre' for genre information.", "We need to find the shortest duration and lowest rating of songs, which requires using the MIN() function on the 'duration' and 'rating' columns from the 'song' table.", "To group the results by genre, we will use the GROUP BY clause on the genre name from the 'genre' table.", "We will join the 'song' table with the 'genre' table on the genre name to access the genre information for each song.", "Finally, we will order the results by genre name using the ORDER BY clause."], "gold_sql": "SELECT min(T1.duration) ,  min(T2.rating) ,  T2.genre_is FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.genre_is ORDER BY T2.genre_is", "source_tables": ["files", "song"], "pred_sql": "SELECT genre.g_name, MIN(song.duration) AS shortest_duration, MIN(song.rating) AS lowest_rating\nFROM song\nJOIN genre ON song.genre_is = genre.g_name\nGROUP BY genre.g_name\nORDER BY genre.g_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the minimum duration of audio files and the minimum rating of songs grouped by their genre. The placeholders represent the necessary fields from the 'files' and 'song' tables, allowing users to analyze the relationship between audio file durations and song ratings across different genres.\",\n    \"1\": \"This virtual table provides the maximum duration and resolution of audio files, along with the languages in which the songs are available. The data is aggregated by languages, allowing users to see the longest audio files and their highest resolutions for each language category.\",\n    \"2\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, sorted in descending order based on the count of songs per language, and limited to a specified number of results.\"\n}\n"}
{"sample_id": "train.3607", "db_id": "music_1", "question": "Find the name and country of origin for all artists who have release at least one song of resolution above 900.", "rationale": ["Identify the tables needed: 'artist' for artist details and 'song' for song details.", "Determine the columns to select: artist's name and country from the 'artist' table.", "Establish the relationship between the tables: join 'artist' and 'song' on 'artist_name'.", "Apply the condition to filter songs with resolution greater than 900.", "Use DISTINCT to ensure unique artist entries in the result."], "gold_sql": "SELECT T1.artist_name ,  T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.resolution  >  900 GROUP BY T2.artist_name HAVING count(*)  >=  1", "source_tables": ["artist", "song"], "pred_sql": "SELECT DISTINCT artist.artist_name, artist.country \nFROM artist \nJOIN song ON artist.artist_name = song.artist_name \nWHERE song.resolution > '900';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, sorted in descending order based on the count of songs per language, and limited to a specified number of results.\",\n    \"1\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, and ordered by the count of songs in descending order, limited to a specified number of results.\",\n    \"2\": \"This virtual table lists the names of artists from the 'artist' table who have songs available in a specific language. The query joins the 'artist' and 'song' tables on the artist's name, filters the results based on the specified language, groups the results by artist name, and orders them by the number of songs in descending order, limiting the output to a specified number of artists.\"\n}\n"}
{"sample_id": "train.3619", "db_id": "music_1", "question": "Find the top 3 artists who have the largest number of songs works whose language is Bangla.", "rationale": ["Identify the tables involved: 'artist' and 'song'.", "We need to find artists who have songs in the Bangla language, so we will join the 'artist' table with the 'song' table on the artist's name.", "Filter the results to include only those songs that have 'Bangla' in the 'languages' column.", "Group the results by artist name to count the number of songs per artist.", "Order the results by the count of songs in descending order to get the top artists.", "Limit the results to the top 3 artists."], "gold_sql": "SELECT T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.languages  =  'bangla' GROUP BY T2.artist_name ORDER BY count(*) DESC LIMIT 3", "source_tables": ["artist", "song"], "pred_sql": "SELECT artist.artist_name, COUNT(song.song_name) AS song_count\nFROM artist\nJOIN song ON artist.artist_name = song.artist_name\nWHERE song.languages LIKE '%Bangla%'\nGROUP BY artist.artist_name\nORDER BY song_count DESC\nLIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of artists from the 'artist' table who have songs available in a specific language. The query joins the 'artist' and 'song' tables on the artist's name, filters the results based on the specified language, groups the results by artist name, and orders them by the number of songs in descending order, limiting the output to a specified number of artists.\",\n    \"1\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, sorted in descending order based on the count of songs per language, and limited to a specified number of results.\",\n    \"2\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, and ordered by the count of songs in descending order, limited to a specified number of results.\"\n}\n"}
{"sample_id": "train.3623", "db_id": "music_1", "question": "List the duration, file size and format of songs whose genre is pop, ordered by title?", "rationale": ["Identify the relevant tables: 'files' for file details and 'song' for genre and title.", "Determine the fields needed: duration, file size, and format from 'files', and song title from 'song'.", "Establish the relationship between the tables using the foreign key: 'f_id' in 'files' and 'song'.", "Filter the results to include only songs where the genre is 'pop'.", "Order the results by the song title for better readability."], "gold_sql": "SELECT T1.duration ,  T1.file_size ,  T1.formats FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T2.genre_is  =  'pop' ORDER BY T2.song_name", "source_tables": ["files", "song"], "pred_sql": "SELECT f.duration, f.file_size, f.formats \nFROM files f \nJOIN song s ON f.f_id = s.f_id \nWHERE s.genre_is = 'pop' \nORDER BY s.song_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the minimum duration of audio files and the minimum rating of songs grouped by their genre. The placeholders represent the necessary fields from the 'files' and 'song' tables, allowing users to analyze the relationship between audio file durations and song ratings across different genres.\",\n    \"1\": \"This virtual table provides a list of song titles from the 'files' and 'song' tables based on specific criteria. It retrieves song names associated with files that match a certain duration and also includes song names that are available in a specified language. The placeholders in the WHERE clause represent the duration format and the language of the songs.\",\n    \"2\": \"This virtual table provides the maximum duration and resolution of audio files, along with the languages in which the songs are available. The data is aggregated by languages, allowing users to see the longest audio files and their highest resolutions for each language category.\"\n}\n"}
{"sample_id": "train.3624", "db_id": "music_1", "question": "What is the duration, file size, and song format for every pop song, ordered by title alphabetically?", "rationale": ["Identify the relevant tables: 'song' and 'files' are needed to get the duration, file size, and format of the songs.", "Determine the columns to select: We need 'duration' from the 'song' table, 'file_size' and 'formats' from the 'files' table.", "Establish the relationship between the tables: The 'song' table has a foreign key 'f_id' that links to the 'files' table's 'f_id'.", "Filter the results to only include pop songs: Use a WHERE clause to specify that 'song.genre_is' must be 'pop'.", "Order the results alphabetically by song title: Use an ORDER BY clause on 'song.song_name' in ascending order."], "gold_sql": "SELECT T1.duration ,  T1.file_size ,  T1.formats FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T2.genre_is  =  'pop' ORDER BY T2.song_name", "source_tables": ["files", "song"], "pred_sql": "SELECT song.duration, files.file_size, files.formats \nFROM song \nJOIN files ON song.f_id = files.f_id \nWHERE song.genre_is = 'pop' \nORDER BY song.song_name ASC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the maximum duration and resolution of audio files, along with the languages in which the songs are available. The data is aggregated by languages, allowing users to see the longest audio files and their highest resolutions for each language category.\",\n    \"1\": \"This virtual table provides a list of song titles from the 'files' and 'song' tables based on specific criteria. It retrieves song names associated with files that match a certain duration and also includes song names that are available in a specified language. The placeholders in the WHERE clause represent the duration format and the language of the songs.\",\n    \"2\": \"This virtual table provides the minimum duration of audio files and the minimum rating of songs grouped by their genre. The placeholders represent the necessary fields from the 'files' and 'song' tables, allowing users to analyze the relationship between audio file durations and song ratings across different genres.\"\n}\n"}
{"sample_id": "train.3631", "db_id": "baseball_1", "question": "What is average salary of the players in the team named 'Boston Red Stockings' ?", "rationale": ["Identify the relevant tables: We need the 'salary' table for salary information and the 'team' table to filter by team name.", "Join the 'salary' table with the 'team' table on 'team_id' to associate salaries with the correct team.", "Filter the results to only include records for the team named 'Boston Red Stockings'.", "Use the AVG() function to calculate the average salary of the players in that team."], "gold_sql": "SELECT avg(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings'", "source_tables": ["team", "salary"], "pred_sql": "SELECT AVG(s.salary) AS average_salary\nFROM salary s\nJOIN team t ON s.team_id = t.team_id\nWHERE t.name = 'Boston Red Stockings';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n    \"1\": \"This virtual table provides the salary records for players in two specific years from the 'salary' table. The placeholders in the WHERE clause represent the years for which the salary data is being queried.\",\n    \"2\": \"This virtual table provides the team IDs and their ranks for teams that hosted home games in a specific year. The results are grouped by team ID and ordered by the average attendance of the home games in descending order, with a limit on the number of results returned. The placeholders represent the year of the home games and the maximum number of teams to display.\"\n}\n"}
{"sample_id": "train.3650", "db_id": "baseball_1", "question": "What are the three countries that the least players are from?", "rationale": ["Identify the relevant table: The 'player' table contains information about players, including their birth countries.", "Select the 'birth_country' column and count the number of players from each country using COUNT(player_id).", "Group the results by 'birth_country' to aggregate the player counts for each country.", "Order the results in ascending order based on the player count to find the countries with the least players.", "Limit the results to the top 3 countries with the least players."], "gold_sql": "SELECT birth_country FROM player GROUP BY birth_country ORDER BY count(*) ASC LIMIT 3;", "source_tables": ["player"], "pred_sql": "SELECT birth_country, COUNT(player_id) AS player_count\nFROM player\nGROUP BY birth_country\nORDER BY player_count ASC\nLIMIT 3;", "hint": "\n"}
{"sample_id": "train.3657", "db_id": "baseball_1", "question": "What is the highest salary among each team? List the team name, id and maximum salary.", "rationale": ["To find the highest salary among each team, we need to join the 'salary' table with the 'team' table using the 'team_id' as the common key.", "We will select the team name and team ID from the 'team' table and the maximum salary from the 'salary' table.", "We will group the results by 'team.team_id' to ensure we get the maximum salary for each team."], "gold_sql": "SELECT T1.name ,  T1.team_id ,  max(T2.salary) FROM team AS T1 JOIN salary AS T2 ON T1.team_id  =  T2.team_id GROUP BY T1.team_id;", "source_tables": ["team", "salary"], "pred_sql": "SELECT team.name, team.team_id, MAX(salary.salary) AS max_salary\nFROM salary\nJOIN team ON salary.team_id = team.team_id\nGROUP BY team.team_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n    \"1\": \"This virtual table provides the names of the winning teams and their corresponding team IDs from the postseason table for a specific year. The results are grouped by the winning team ID and ordered by the number of wins in descending order, with a limit on the number of results returned.\",\n    \"2\": \"This virtual table provides the names of the winning teams and their corresponding identifiers from the postseason table for a specific year. The results are grouped by the winning team identifier and ordered by the count of wins in descending order, with a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.3658", "db_id": "baseball_1", "question": "For each team, return the team name, id and the maximum salary among the team.", "rationale": ["We need to retrieve the team name, team ID, and the maximum salary for each team.", "The relevant tables for this query are 'team' and 'salary'.", "We will join the 'team' table with the 'salary' table on the 'team_id' column to associate each team with its salary records.", "We will use the MAX() function to find the maximum salary for each team.", "Finally, we will group the results by 'team.team_id' to ensure we get one result per team."], "gold_sql": "SELECT T1.name ,  T1.team_id ,  max(T2.salary) FROM team AS T1 JOIN salary AS T2 ON T1.team_id  =  T2.team_id GROUP BY T1.team_id;", "source_tables": ["team", "salary"], "pred_sql": "SELECT team.name, team.team_id, MAX(salary.salary) AS max_salary\nFROM team\nJOIN salary ON team.team_id = salary.team_id\nGROUP BY team.team_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n    \"1\": \"This virtual table provides the names of the winning teams and their corresponding team IDs from the postseason table for a specific year. The results are grouped by the winning team ID and ordered by the number of wins in descending order, with a limit on the number of results returned.\",\n    \"2\": \"This virtual table provides the names of the winning teams and their corresponding identifiers from the postseason table for a specific year. The results are grouped by the winning team identifier and ordered by the count of wins in descending order, with a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.3659", "db_id": "baseball_1", "question": "What are the name and id of the team offering the lowest average salary?", "rationale": ["To find the team offering the lowest average salary, we need to join the 'salary' table with the 'team' table to get the team names and their IDs.", "We will group the results by 'team.team_id' to calculate the average salary for each team.", "The average salary is calculated using the AVG() function on the 'salary' column from the 'salary' table.", "To get the team with the lowest average salary, we will order the results in ascending order using ORDER BY AVG(salary.salary) ASC.", "Finally, we will limit the results to 1 to get only the team with the lowest average salary."], "gold_sql": "SELECT T1.name ,  T1.team_id FROM team AS T1 JOIN salary AS T2 ON T1.team_id = T2.team_id GROUP BY T1.team_id ORDER BY avg(T2.salary) ASC LIMIT 1;", "source_tables": ["team", "salary"], "pred_sql": "SELECT team.name, team.team_id\nFROM salary\nJOIN team ON salary.team_id = team.team_id\nGROUP BY team.team_id\nORDER BY AVG(salary.salary) ASC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n    \"1\": \"This virtual table provides the team IDs and their ranks for teams that hosted home games in a specific year. The results are grouped by team ID and ordered by the average attendance of the home games in descending order, with a limit on the number of results returned. The placeholders represent the year of the home games and the maximum number of teams to display.\",\n    \"2\": \"This virtual table provides the names of the winning teams and their corresponding team IDs from the postseason table for a specific year. The results are grouped by the winning team ID and ordered by the number of wins in descending order, with a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.3661", "db_id": "baseball_1", "question": "Find the players' first name and last name who won award both in 1960 and in 1961.", "rationale": ["Identify the relevant tables: We need to retrieve player names and their award records, so we will use the 'player' and 'player_award' tables.", "Join the 'player' table with the 'player_award' table on 'player_id' to get access to player names along with their award records.", "Filter the results to include only those records where the award year is either 1960 or 1961 using the WHERE clause.", "Group the results by player ID to ensure we get unique players.", "Use the HAVING clause to ensure that only players who have received awards in both years (count of distinct years = 2) are included in the final result."], "gold_sql": "SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1960 INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1961", "source_tables": ["player_award", "player"], "pred_sql": "SELECT p.name_first, p.name_last\nFROM player_award pa\nJOIN player p ON pa.player_id = p.player_id\nWHERE pa.year IN (1960, 1961)\nGROUP BY p.player_id\nHAVING COUNT(DISTINCT pa.year) = 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of players who received awards in two specific years. The placeholders in the WHERE clause represent the years for which the awards were given.\",\n    \"1\": \"This virtual table retrieves the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n    \"2\": \"This virtual table provides a list of players along with their first and last names from the 'player' table, who have received awards. The results are grouped by player ID to ensure uniqueness and are ordered by the number of awards received in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of players to return.\"\n}\n"}
{"sample_id": "train.3663", "db_id": "baseball_1", "question": "List players' first name and last name who have weight greater than 220 or height shorter than 75.", "rationale": ["Identify the relevant table: The 'player' table contains the first name, last name, weight, and height of players.", "Determine the conditions: We need players with a weight greater than 220 or a height shorter than 75.", "Construct the SQL query: Use a SELECT statement to retrieve 'name_first' and 'name_last' from the 'player' table, applying the specified conditions in the WHERE clause."], "gold_sql": "SELECT name_first ,  name_last FROM player WHERE weight  >  220 OR height  <  75", "source_tables": ["player"], "pred_sql": "SELECT name_first, name_last FROM player WHERE weight > 220 OR height < 75;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of players who received awards in two specific years. The placeholders in the WHERE clause represent the years for which the awards were given.\",\n    \"1\": \"This virtual table retrieves the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\"\n}\n"}
{"sample_id": "train.3664", "db_id": "baseball_1", "question": "What are the first name and last name of the players who have weight above 220 or height below 75?", "rationale": ["Identify the relevant table: The 'player' table contains the first name, last name, weight, and height of players.", "Determine the conditions: We need players with a weight greater than 220 or a height less than 75.", "Construct the SQL query: Use a SELECT statement to retrieve 'name_first' and 'name_last' from the 'player' table where the specified conditions are met."], "gold_sql": "SELECT name_first ,  name_last FROM player WHERE weight  >  220 OR height  <  75", "source_tables": ["player"], "pred_sql": "SELECT name_first, name_last FROM player WHERE weight > 220 OR height < 75;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of players who received awards in two specific years. The placeholders in the WHERE clause represent the years for which the awards were given.\",\n    \"1\": \"This virtual table retrieves the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\"\n}\n"}
{"sample_id": "train.3665", "db_id": "baseball_1", "question": "List the maximum scores of the team Boston Red Stockings when the team won in postseason?", "rationale": ["Identify the relevant tables: postseason and team.", "We need to find the maximum scores (wins) of the team Boston Red Stockings when they won in postseason.", "Join the postseason table with the team table on the winning team ID.", "Filter the results to only include the Boston Red Stockings.", "Use the MAX function to get the maximum wins from the filtered results."], "gold_sql": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings';", "source_tables": ["postseason", "team"], "pred_sql": "SELECT MAX(p.wins) AS max_wins\nFROM postseason p\nJOIN team t ON p.team_id_winner = t.team_id\nWHERE t.name = 'Boston Red Stockings'", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of the winning teams and their corresponding team IDs from the postseason table for a specific year. The results are grouped by the winning team ID and ordered by the number of wins in descending order, with a limit on the number of results returned.\",\n    \"1\": \"This virtual table provides the names of the winning teams and their corresponding identifiers from the postseason table for a specific year. The results are grouped by the winning team identifier and ordered by the count of wins in descending order, with a limit on the number of results returned.\",\n    \"2\": \"This virtual table provides the count of postseason wins for a specific team across different years. The placeholder in the WHERE clause represents the name of the team for which the postseason wins are being queried.\"\n}\n"}
{"sample_id": "train.3666", "db_id": "baseball_1", "question": "What are the maximum scores the team Boston Red Stockings got when the team won in postseason?", "rationale": ["Identify the relevant tables: postseason and team.", "We need to find the maximum scores (wins) for the team Boston Red Stockings in the postseason.", "Join the postseason table with the team table on the winning team ID.", "Filter the results to only include rows where the team name is 'Boston Red Stockings'.", "Use the MAX function to get the maximum wins for the specified team."], "gold_sql": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings';", "source_tables": ["postseason", "team"], "pred_sql": "SELECT MAX(p.wins) AS max_wins\nFROM postseason p\nJOIN team t ON p.team_id_winner = t.team_id\nWHERE t.name = 'Boston Red Stockings';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of the winning teams and their corresponding team IDs from the postseason table for a specific year. The results are grouped by the winning team ID and ordered by the number of wins in descending order, with a limit on the number of results returned.\",\n    \"1\": \"This virtual table provides the names of the winning teams and their corresponding identifiers from the postseason table for a specific year. The results are grouped by the winning team identifier and ordered by the count of wins in descending order, with a limit on the number of results returned.\",\n    \"2\": \"This virtual table provides the count of postseason wins for a specific team across different years. The placeholder in the WHERE clause represents the name of the team for which the postseason wins are being queried.\"\n}\n"}
{"sample_id": "train.3672", "db_id": "baseball_1", "question": "For each year, return the year and the number of times the team Boston Red Stockings won in the postseasons.", "rationale": ["We need to retrieve the year and the number of postseason wins for the Boston Red Stockings.", "The relevant table for postseason results is the 'postseason' table, which contains the winning team IDs and the year of the postseason.", "We will join the 'postseason' table with the 'team' table to get the team names corresponding to the winning team IDs.", "We will filter the results to only include wins by the 'Boston Red Stockings'.", "Finally, we will group the results by year and count the number of wins for each year."], "gold_sql": "SELECT count(*) ,  T1.year FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' GROUP BY T1.year", "source_tables": ["postseason", "team"], "pred_sql": "SELECT p.year, COUNT(p.team_id_winner) AS wins\nFROM postseason p\nJOIN team t ON p.team_id_winner = t.team_id\nWHERE t.name = 'Boston Red Stockings'\nGROUP BY p.year;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of the winning teams and their corresponding team IDs from the postseason table for a specific year. The results are grouped by the winning team ID and ordered by the number of wins in descending order, with a limit on the number of results returned.\",\n    \"1\": \"This virtual table provides the names of the winning teams and their corresponding identifiers from the postseason table for a specific year. The results are grouped by the winning team identifier and ordered by the count of wins in descending order, with a limit on the number of results returned.\",\n    \"2\": \"This virtual table provides the count of postseason wins for a specific team across different years. The placeholder in the WHERE clause represents the name of the team for which the postseason wins are being queried.\"\n}\n"}
{"sample_id": "train.3677", "db_id": "baseball_1", "question": "What is the total salary paid by team Boston Red Stockings in 2010?", "rationale": ["Identify the relevant tables: We need the 'salary' table to get salary information and the 'team' table to filter by team name.", "Join the 'salary' table with the 'team' table on 'team_id' to associate salaries with the correct team.", "Filter the results to only include records for the 'Boston Red Stockings' team in the year 2010.", "Use the SUM function to calculate the total salary paid by the team for that year."], "gold_sql": "SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings' AND T1.year  =  2010", "source_tables": ["team", "salary"], "pred_sql": "SELECT SUM(salary) AS total_salary \nFROM salary \nJOIN team ON salary.team_id = team.team_id \nWHERE team.name = 'Boston Red Stockings' AND salary.year = 2010;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n    \"1\": \"This virtual table provides the names of the winning teams and their corresponding team IDs from the postseason table for a specific year. The results are grouped by the winning team ID and ordered by the number of wins in descending order, with a limit on the number of results returned.\",\n    \"2\": \"This virtual table provides the salary records for players in two specific years from the 'salary' table. The placeholders in the WHERE clause represent the years for which the salary data is being queried.\"\n}\n"}
{"sample_id": "train.3681", "db_id": "baseball_1", "question": "List the 3 highest salaries of the players in 2001?", "rationale": ["Identify the relevant table: The 'salary' table contains the salary records for players.", "Specify the year: We need to filter the records for the year 2001.", "Select the required columns: We want to retrieve the 'player_id' and 'salary' columns.", "Order the results: To find the highest salaries, we will order the results by 'salary' in descending order.", "Limit the results: We only need the top 3 highest salaries, so we will limit the results to 3."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2001 ORDER BY salary DESC LIMIT 3;", "source_tables": ["salary"], "pred_sql": "SELECT player_id, salary FROM salary WHERE year = 2001 ORDER BY salary DESC LIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n    \"1\": \"This virtual table provides the salary records for players in two specific years from the 'salary' table. The placeholders in the WHERE clause represent the years for which the salary data is being queried.\",\n    \"2\": \"This virtual table describes the first and last names of players who received awards in two specific years. The placeholders in the WHERE clause represent the years for which the awards were given.\"\n}\n"}
{"sample_id": "train.3682", "db_id": "baseball_1", "question": "How much salary did the top 3 well-paid players get in 2001?", "rationale": ["Identify the relevant table: The 'salary' table contains the salary records for players.", "Specify the year: We need to filter the records for the year 2001.", "Order the results: To find the top 3 well-paid players, we need to order the results by salary in descending order.", "Limit the results: We only want the top 3 players, so we will use the LIMIT clause."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2001 ORDER BY salary DESC LIMIT 3;", "source_tables": ["salary"], "pred_sql": "SELECT player_id, salary FROM salary WHERE year = 2001 ORDER BY salary DESC LIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n    \"1\": \"This virtual table provides the salary records for players in two specific years from the 'salary' table. The placeholders in the WHERE clause represent the years for which the salary data is being queried.\",\n    \"2\": \"This virtual table describes the first and last names of players who received awards in two specific years. The placeholders in the WHERE clause represent the years for which the awards were given.\"\n}\n"}
{"sample_id": "train.3683", "db_id": "baseball_1", "question": "What were all the salary values of players in 2010 and 2001?", "rationale": ["Identify the relevant table: The 'salary' table contains the salary records for players.", "Determine the years of interest: The user wants salary values for the years 2010 and 2001.", "Construct the SQL query: Use a SELECT statement to retrieve the 'player_id' and 'salary' columns from the 'salary' table where the 'year' is either 2010 or 2001."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2010 UNION SELECT salary FROM salary WHERE YEAR  =  2001", "source_tables": ["salary"], "pred_sql": "SELECT player_id, salary FROM salary WHERE year IN (2010, 2001);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the salary records for players in two specific years from the 'salary' table. The placeholders in the WHERE clause represent the years for which the salary data is being queried.\",\n    \"1\": \"This virtual table retrieves the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n    \"2\": \"This virtual table describes the first and last names of players who received awards in two specific years. The placeholders in the WHERE clause represent the years for which the awards were given.\"\n}\n"}
{"sample_id": "train.3685", "db_id": "baseball_1", "question": "In which year did the least people enter hall of fame?", "rationale": ["We need to find the year with the least number of players inducted into the Hall of Fame.", "The relevant table for this information is the 'hall_of_fame' table, which contains the 'yearid' and 'inducted' columns.", "We will count the number of players inducted (where 'inducted' is 'Y') for each year using COUNT(*) and group the results by 'yearid'.", "To find the year with the least inductees, we will order the results in ascending order based on the count of inducted players.", "Finally, we will limit the results to 1 to get the year with the least inductees."], "gold_sql": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT 1;", "source_tables": ["hall_of_fame"], "pred_sql": "SELECT yearid, COUNT(*) AS num_inducted\nFROM hall_of_fame\nWHERE inducted = 'Y'\nGROUP BY yearid\nORDER BY num_inducted ASC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of players who received awards in two specific years. The placeholders in the WHERE clause represent the years for which the awards were given.\",\n    \"1\": \"This virtual table retrieves the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n    \"2\": \"This virtual table provides the names of the winning teams and their corresponding team IDs from the postseason table for a specific year. The results are grouped by the winning team ID and ordered by the number of wins in descending order, with a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.3686", "db_id": "baseball_1", "question": "Find the year in which the least people enter hall of fame.", "rationale": ["To find the year with the least number of people entering the Hall of Fame, we need to count the number of inductees for each year.", "The 'hall_of_fame' table contains the relevant data, specifically the 'yearid' and 'inducted' columns.", "We will filter the results to only include those who were inducted (indicated by 'inducted = 'Y'').", "Next, we will group the results by 'yearid' to count the number of inductees for each year.", "Finally, we will order the results in ascending order based on the count of inductees and limit the output to the first result, which will give us the year with the least inductees."], "gold_sql": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT 1;", "source_tables": ["hall_of_fame"], "pred_sql": "SELECT yearid, COUNT(*) AS num_inducted FROM hall_of_fame WHERE inducted = 'Y' GROUP BY yearid ORDER BY num_inducted ASC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of players who received awards in two specific years. The placeholders in the WHERE clause represent the years for which the awards were given.\",\n    \"1\": \"This virtual table provides the team IDs and their ranks for teams that hosted home games in a specific year. The results are grouped by team ID and ordered by the average attendance of the home games in descending order, with a limit on the number of results returned. The placeholders represent the year of the home games and the maximum number of teams to display.\",\n    \"2\": \"This virtual table retrieves the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\"\n}\n"}
{"sample_id": "train.3689", "db_id": "baseball_1", "question": "How many games were played in park \"Columbia Park\" in 1907?", "rationale": ["Identify the relevant table: The 'home_game' table contains information about games played in different parks.", "Determine the columns needed: We need to sum the 'games' column to get the total number of games played.", "Filter by year: We need to specify the year 1907 in the WHERE clause.", "Filter by park: We need to find the park ID for 'Columbia Park' using a subquery on the 'park' table, which will allow us to filter the results to only include games played in that park."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 1907 AND T2.park_name = 'Columbia Park';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(games) AS total_games\nFROM home_game\nWHERE year = 1907 AND park_id = (SELECT park_id FROM park WHERE park_name = 'Columbia Park');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of postseason wins for a specific team across different years. The placeholder in the WHERE clause represents the name of the team for which the postseason wins are being queried.\",\n    \"1\": \"This virtual table provides the team IDs and their ranks for teams that hosted home games in a specific year. The results are grouped by team ID and ordered by the average attendance of the home games in descending order, with a limit on the number of results returned. The placeholders represent the year of the home games and the maximum number of teams to display.\"\n}\n"}
{"sample_id": "train.3690", "db_id": "baseball_1", "question": "Count the number of games taken place in park \"Columbia Park\" in 1907.", "rationale": ["Identify the relevant tables: We need to count the number of games, which can be found in the 'home_game' table, and we need to filter by the park name, which is in the 'park' table.", "Join the 'home_game' table with the 'park' table on the park_id to access the park name.", "Use a WHERE clause to filter for the specific park name 'Columbia Park' and the year 1907.", "Count the total number of games using COUNT(*) and alias it as total_games."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 1907 AND T2.park_name = 'Columbia Park';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT COUNT(*) AS total_games\nFROM home_game\nJOIN park ON home_game.park_id = park.park_id\nWHERE park.park_name = 'Columbia Park' AND home_game.year = 1907;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of postseason wins for a specific team across different years. The placeholder in the WHERE clause represents the name of the team for which the postseason wins are being queried.\",\n    \"1\": \"This virtual table provides the team IDs and their ranks for teams that hosted home games in a specific year. The results are grouped by team ID and ordered by the average attendance of the home games in descending order, with a limit on the number of results returned. The placeholders represent the year of the home games and the maximum number of teams to display.\"\n}\n"}
{"sample_id": "train.3691", "db_id": "baseball_1", "question": "How many games were played in city Atlanta in 2000?", "rationale": ["Identify the relevant tables: We need to find the total number of games played in Atlanta in 2000, which involves the 'home_game' table for game counts and the 'team' table for city information.", "Join the 'home_game' table with the 'team' table on 'team_id' to access the city information for the teams that hosted games.", "Filter the results for the year 2000 and for teams located in Atlanta.", "Use the SUM function to calculate the total number of games played in Atlanta in that year."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year  =  2000 AND T2.city  =  'Atlanta';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(home_game.games) AS total_games\nFROM home_game\nJOIN team ON home_game.team_id = team.team_id\nWHERE home_game.year = 2000 AND home_game.league_id = team.league_id AND team.city = 'Atlanta';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of postseason wins for a specific team across different years. The placeholder in the WHERE clause represents the name of the team for which the postseason wins are being queried.\",\n    \"1\": \"This virtual table provides the team IDs and their ranks for teams that hosted home games in a specific year. The results are grouped by team ID and ordered by the average attendance of the home games in descending order, with a limit on the number of results returned. The placeholders represent the year of the home games and the maximum number of teams to display.\",\n    \"2\": \"This virtual table provides the names of the winning teams and their corresponding team IDs from the postseason table for a specific year. The results are grouped by the winning team ID and ordered by the number of wins in descending order, with a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.3692", "db_id": "baseball_1", "question": "Find the number of games taken place in city Atlanta in 2000.", "rationale": ["Identify the relevant tables: We need to find the number of games in Atlanta in 2000, so we will use the 'home_game' table for game data and the 'park' table for city information.", "Join the tables: We will join 'home_game' with 'park' on the park_id to access the city information related to the games.", "Filter the results: We will filter the results to only include games that took place in Atlanta and in the year 2000.", "Count the games: We will sum the 'games' column from the 'home_game' table to get the total number of games played in Atlanta in 2000."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year  =  2000 AND T2.city  =  'Atlanta';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(games) AS total_games\nFROM home_game\nJOIN park ON home_game.park_id = park.park_id\nWHERE park.city = 'Atlanta' AND home_game.year = 2000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of postseason wins for a specific team across different years. The placeholder in the WHERE clause represents the name of the team for which the postseason wins are being queried.\",\n    \"1\": \"This virtual table provides the team IDs and their ranks for teams that hosted home games in a specific year. The results are grouped by team ID and ordered by the average attendance of the home games in descending order, with a limit on the number of results returned. The placeholders represent the year of the home games and the maximum number of teams to display.\",\n    \"2\": \"This virtual table provides the names of the winning teams and their corresponding identifiers from the postseason table for a specific year. The results are grouped by the winning team identifier and ordered by the count of wins in descending order, with a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.3693", "db_id": "baseball_1", "question": "What is the total home game attendance of team Boston Red Stockings from 2000 to 2010?", "rationale": ["Identify the relevant tables: 'home_game' for attendance data and 'team' for team identification.", "Join the 'home_game' table with the 'team' table on 'team_id' to associate attendance with the correct team.", "Filter the results to include only the 'Boston Red Stockings' team by using the team name in the WHERE clause.", "Limit the results to the years between 2000 and 2010 using the BETWEEN clause in the WHERE condition.", "Use the SUM function to calculate the total attendance for the specified team and years."], "gold_sql": "SELECT sum(T1.attendance) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' AND T1.year BETWEEN 2000 AND 2010;", "source_tables": ["team", "home_game"], "pred_sql": "SELECT SUM(attendance) AS total_attendance \nFROM home_game \nJOIN team ON home_game.team_id = team.team_id \nWHERE team.name = 'Boston Red Stockings' \nAND home_game.year BETWEEN 2000 AND 2010;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the team IDs and their ranks for teams that hosted home games in a specific year. The results are grouped by team ID and ordered by the average attendance of the home games in descending order, with a limit on the number of results returned. The placeholders represent the year of the home games and the maximum number of teams to display.\",\n    \"1\": \"This virtual table provides the count of postseason wins for a specific team across different years. The placeholder in the WHERE clause represents the name of the team for which the postseason wins are being queried.\",\n    \"2\": \"This virtual table provides the names of the winning teams and their corresponding team IDs from the postseason table for a specific year. The results are grouped by the winning team ID and ordered by the number of wins in descending order, with a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.3698", "db_id": "baseball_1", "question": "What are the first name and last name of the players who were paid salary by team Washington Nationals in both 2005 and 2007?", "rationale": ["Identify the team ID for 'Washington Nationals' from the 'team' table.", "Select the first and last names of players from the 'player' table who have salary records in the 'salary' table.", "Filter the salary records to include only those from the years 2005 and 2007 for the identified team ID.", "Use a subquery to ensure that the player has salary records for both years (2005 and 2007)."], "gold_sql": "SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2005 AND T3.name = 'Washington Nationals' INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2007 AND T3.name = 'Washington Nationals'", "source_tables": ["team", "player", "salary"], "pred_sql": "SELECT p.name_first, p.name_last \nFROM salary s1 \nJOIN player p ON s1.player_id = p.player_id \nWHERE s1.team_id = (SELECT team_id FROM team WHERE name = 'Washington Nationals') \nAND s1.year = 2005 \nAND s1.player_id IN (\n    SELECT player_id \n    FROM salary s2 \n    WHERE s2.team_id = (SELECT team_id FROM team WHERE name = 'Washington Nationals') \n    AND s2.year = 2007\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n    \"1\": \"This virtual table describes the first and last names of players who received awards in two specific years. The placeholders in the WHERE clause represent the years for which the awards were given.\",\n    \"2\": \"This virtual table provides the salary records for players in two specific years from the 'salary' table. The placeholders in the WHERE clause represent the years for which the salary data is being queried.\"\n}\n"}
{"sample_id": "train.3702", "db_id": "baseball_1", "question": "Find the team that attended the least number of home games in 1980.", "rationale": ["Identify the relevant table: The 'home_game' table contains information about home games played by teams, including the year and team ID.", "Filter the data: We need to focus on the year 1980, so we will filter the results to include only records from that year.", "Group the results: We will group the results by 'team_id' to count the number of home games each team hosted in 1980.", "Count the home games: Use COUNT(*) to count the number of home games for each team.", "Order the results: We will order the results in ascending order based on the count of home games to find the team with the least number.", "Limit the results: Since we only want the team with the least number of home games, we will limit the results to 1."], "gold_sql": "SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = 1980 ORDER BY T1.attendance ASC LIMIT 1;", "source_tables": ["team", "home_game"], "pred_sql": "SELECT team_id, COUNT(*) AS home_games_count \nFROM home_game \nWHERE year = 1980 \nGROUP BY team_id \nORDER BY home_games_count ASC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the team IDs and their ranks for teams that hosted home games in a specific year. The results are grouped by team ID and ordered by the average attendance of the home games in descending order, with a limit on the number of results returned. The placeholders represent the year of the home games and the maximum number of teams to display.\",\n    \"1\": \"This virtual table provides the names of the winning teams and their corresponding identifiers from the postseason table for a specific year. The results are grouped by the winning team identifier and ordered by the count of wins in descending order, with a limit on the number of results returned.\",\n    \"2\": \"This virtual table provides the names of the winning teams and their corresponding team IDs from the postseason table for a specific year. The results are grouped by the winning team ID and ordered by the number of wins in descending order, with a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.3709", "db_id": "baseball_1", "question": "Which park had most attendances in 2008?", "rationale": ["Identify the relevant tables: home_game and park.", "We need to find the park with the highest attendance in 2008, so we will filter the home_game table for the year 2008.", "Join the home_game table with the park table to get the park names associated with the attendance records.", "Order the results by attendance in descending order to get the park with the highest attendance at the top.", "Limit the results to 1 to get only the park with the most attendance."], "gold_sql": "SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 2008 ORDER BY T1.attendance DESC LIMIT 1;", "source_tables": ["park", "home_game"], "pred_sql": "SELECT park.park_name, home_game.attendance \nFROM home_game \nJOIN park ON home_game.park_id = park.park_id \nWHERE home_game.year = 2008 \nORDER BY home_game.attendance DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the team IDs and their ranks for teams that hosted home games in a specific year. The results are grouped by team ID and ordered by the average attendance of the home games in descending order, with a limit on the number of results returned. The placeholders represent the year of the home games and the maximum number of teams to display.\"\n}\n"}
{"sample_id": "train.3857", "db_id": "insurance_policies", "question": "Find the settlement amount of the claim with the largest claim amount. Show both the settlement amount and claim amount.", "rationale": ["Identify the relevant tables: Claims and Settlements, since we need information about claim amounts and their corresponding settlement amounts.", "We need to find the claim with the largest claim amount, which requires a subquery to get the maximum claim amount from the Claims table.", "Join the Claims table with the Settlements table on the Claim_ID to access both the claim amount and the settlement amount.", "Select the Amount_Claimed from the Claims table and the Amount_Settled from the Settlements table where the Amount_Claimed matches the maximum claim amount found in the subquery."], "gold_sql": "SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Claimed DESC LIMIT 1", "source_tables": ["claims"], "pred_sql": "SELECT c.Amount_Claimed, s.Amount_Settled\nFROM Claims c\nJOIN Settlements s ON c.Claim_ID = s.Claim_ID\nWHERE c.Amount_Claimed = (SELECT MAX(Amount_Claimed) FROM Claims);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the dates when claims were made and settled from the 'Claims' table for those claims where the amount claimed exceeds the average amount claimed across all claims. The placeholder in the WHERE clause represents a condition based on the average amount claimed.\",\n    \"1\": \"This virtual table provides a summary of claims and their settlement dates from the 'Claims' table, specifically focusing on claims that have a certain number of associated settlements. The placeholders in the HAVING clause represent the count of settlements that must match for the claims to be included in the results.\"\n}\n"}
{"sample_id": "train.3862", "db_id": "insurance_policies", "question": "Among all the claims, which settlements have a claimed amount that is no more than the average? List the claim start date.", "rationale": ["Identify the relevant tables: Claims and Settlements.", "We need to find settlements where the claimed amount is no more than the average claimed amount across all claims.", "To do this, we will join the Claims table with the Settlements table on the Claim_ID.", "We will select the Date_Claim_Made from the Claims table and the Amount_Claimed from the Settlements table.", "We will use a subquery to calculate the average claimed amount from the Claims table and filter the results based on this average."], "gold_sql": "SELECT Date_Claim_Made FROM Claims WHERE Amount_Settled  <=  ( SELECT avg(Amount_Settled) FROM Claims )", "source_tables": ["claims"], "pred_sql": "SELECT Claims.Date_Claim_Made, Settlements.Amount_Claimed \nFROM Claims \nJOIN Settlements ON Claims.Claim_ID = Settlements.Claim_ID \nWHERE Settlements.Amount_Claimed <= (SELECT AVG(Amount_Claimed) FROM Claims);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the dates when claims were made and settled from the 'Claims' table for those claims where the amount claimed exceeds the average amount claimed across all claims. The placeholder in the WHERE clause represents a condition based on the average amount claimed.\",\n    \"1\": \"This virtual table provides a summary of claims and their settlement dates from the 'Claims' table, specifically focusing on claims that have a certain number of associated settlements. The placeholders in the HAVING clause represent the count of settlements that must match for the claims to be included in the results.\"\n}\n"}
{"sample_id": "train.3863", "db_id": "insurance_policies", "question": "Return the claim start date for the claims whose claimed amount is no more than the average", "rationale": ["Identify the relevant table: Claims, which contains the claim details including the claimed amount and the date the claim was made.", "Determine the condition: We need to find claims where the claimed amount is no more than the average claimed amount across all claims.", "Use a subquery to calculate the average claimed amount: (SELECT AVG(Amount_Claimed) FROM Claims).", "Construct the SQL query to select the Date_Claim_Made from the Claims table where the Amount_Claimed is less than or equal to the average amount calculated."], "gold_sql": "SELECT Date_Claim_Made FROM Claims WHERE Amount_Settled  <=  ( SELECT avg(Amount_Settled) FROM Claims )", "source_tables": ["claims"], "pred_sql": "SELECT Date_Claim_Made \nFROM Claims \nWHERE Amount_Claimed <= (SELECT AVG(Amount_Claimed) FROM Claims);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the dates when claims were made and settled from the 'Claims' table for those claims where the amount claimed exceeds the average amount claimed across all claims. The placeholder in the WHERE clause represents a condition based on the average amount claimed.\",\n    \"1\": \"This virtual table provides a summary of claims and their settlement dates from the 'Claims' table, specifically focusing on claims that have a certain number of associated settlements. The placeholders in the HAVING clause represent the count of settlements that must match for the claims to be included in the results.\"\n}\n"}
{"sample_id": "train.3868", "db_id": "insurance_policies", "question": "How many settlements were made on the claim with the most recent claim settlement date? List the number and the claim id.", "rationale": ["Identify the need to count settlements related to claims with the most recent settlement date.", "Join the Claims table with the Settlements table to link claims to their settlements.", "Use a subquery to find the maximum settlement date from the Claims table.", "Filter the results to only include settlements related to claims that have this maximum settlement date.", "Group the results by Claim_ID to get the count of settlements for each claim."], "gold_sql": "SELECT count(*) ,  T1.claim_id FROM Claims AS T1 JOIN Settlements AS T2 ON T1.claim_id  =  T2.claim_id GROUP BY T1.claim_id ORDER BY T1.Date_Claim_Settled DESC LIMIT 1", "source_tables": ["claims", "settlements"], "pred_sql": "SELECT COUNT(Settlements.Settlement_ID) AS Number_of_Settlements, Claims.Claim_ID\nFROM Claims\nJOIN Settlements ON Claims.Claim_ID = Settlements.Claim_ID\nWHERE Claims.Date_Claim_Settled = (\n    SELECT MAX(Date_Claim_Settled)\n    FROM Claims\n)\nGROUP BY Claims.Claim_ID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of claims and their settlement dates from the 'Claims' table, specifically focusing on claims that have a certain number of associated settlements. The placeholders in the HAVING clause represent the count of settlements that must match for the claims to be included in the results.\",\n    \"1\": \"This virtual table provides the dates when claims were made and settled from the 'Claims' table for those claims where the amount claimed exceeds the average amount claimed across all claims. The placeholder in the WHERE clause represents a condition based on the average amount claimed.\"\n}\n"}
{"sample_id": "train.3869", "db_id": "insurance_policies", "question": "Find the claim id and the number of settlements made for the claim with the most recent settlement date.", "rationale": ["Identify the relevant tables: Claims and Settlements are needed to find the claim ID and the number of settlements.", "Join the Claims table with the Settlements table on Claim_ID to link claims with their settlements.", "Use a subquery to find the maximum settlement date from the Settlements table.", "Filter the results to only include settlements that match this maximum date.", "Group the results by Claim_ID to count the number of settlements for each claim."], "gold_sql": "SELECT count(*) ,  T1.claim_id FROM Claims AS T1 JOIN Settlements AS T2 ON T1.claim_id  =  T2.claim_id GROUP BY T1.claim_id ORDER BY T1.Date_Claim_Settled DESC LIMIT 1", "source_tables": ["claims", "settlements"], "pred_sql": "SELECT Claims.Claim_ID, COUNT(Settlements.Settlement_ID) AS Number_of_Settlements\nFROM Claims\nJOIN Settlements ON Claims.Claim_ID = Settlements.Claim_ID\nWHERE Settlements.Date_Claim_Settled = (\n    SELECT MAX(Date_Claim_Settled)\n    FROM Settlements\n)\nGROUP BY Claims.Claim_ID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of claims and their settlement dates from the 'Claims' table, specifically focusing on claims that have a certain number of associated settlements. The placeholders in the HAVING clause represent the count of settlements that must match for the claims to be included in the results.\",\n    \"1\": \"This virtual table provides the dates when claims were made and settled from the 'Claims' table for those claims where the amount claimed exceeds the average amount claimed across all claims. The placeholder in the WHERE clause represents a condition based on the average amount claimed.\"\n}\n"}
{"sample_id": "train.3878", "db_id": "insurance_policies", "question": "What is the most popular payment method?", "rationale": ["Identify the relevant table: The Payments table contains information about payment transactions, including the payment method.", "Determine the required information: We need to find the most popular payment method, which implies counting the occurrences of each payment method.", "Use the COUNT function: To find out how many times each payment method was used, we will use the COUNT function on the Payment_Method_Code column.", "Group the results: We will group the results by Payment_Method_Code to aggregate the counts for each method.", "Order the results: To find the most popular method, we will order the results in descending order based on the count of each payment method.", "Limit the results: Since we only want the most popular payment method, we will limit the results to 1."], "gold_sql": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["payments"], "pred_sql": "SELECT Payment_Method_Code, COUNT(*) AS Method_Count\nFROM Payments\nGROUP BY Payment_Method_Code\nORDER BY Method_Count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3879", "db_id": "insurance_policies", "question": "Which payment method is used the most often?", "rationale": ["Identify the relevant table: The question is about payment methods, so we will focus on the Payments table.", "Determine the required information: We need to find out which payment method is used the most often, which implies counting the occurrences of each payment method.", "Use the COUNT function: We will count the number of times each Payment_Method_Code appears in the Payments table.", "Group the results: We will group the results by Payment_Method_Code to aggregate the counts for each method.", "Order the results: To find the most used payment method, we will order the results in descending order based on the count.", "Limit the results: Since we only need the most frequently used payment method, we will limit the results to 1."], "gold_sql": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["payments"], "pred_sql": "SELECT Payment_Method_Code, COUNT(*) AS Method_Count\nFROM Payments\nGROUP BY Payment_Method_Code\nORDER BY Method_Count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3880", "db_id": "insurance_policies", "question": "With which kind of payment method were the least number of payments processed?", "rationale": ["We need to find the payment method with the least number of payments processed.", "To do this, we will select the 'Payment_Method_Code' from the 'Payments' table.", "We will count the number of payments for each payment method using COUNT(Payment_ID).", "We will group the results by 'Payment_Method_Code' to aggregate the counts for each method.", "Next, we will order the results in ascending order based on the count of payments to get the least processed method at the top.", "Finally, we will limit the results to 1 to get only the payment method with the least number of payments."], "gold_sql": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) ASC LIMIT 1", "source_tables": ["payments"], "pred_sql": "SELECT Payment_Method_Code, COUNT(Payment_ID) AS Payment_Count\nFROM Payments\nGROUP BY Payment_Method_Code\nORDER BY Payment_Count ASC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3886", "db_id": "insurance_policies", "question": "Which kind of policy type was chosen by the most customers?", "rationale": ["Identify the relevant table: The question pertains to the types of policies chosen by customers, so we will focus on the 'Customer_Policies' table.", "Count distinct customers: We need to count how many distinct customers chose each policy type, which requires using COUNT(DISTINCT Customer_ID).", "Group by policy type: To get the count of customers for each policy type, we will use GROUP BY Policy_Type_Code.", "Order the results: To find the policy type chosen by the most customers, we will order the results in descending order based on the customer count.", "Limit the results: Since we only want the policy type with the highest count, we will limit the results to 1."], "gold_sql": "SELECT Policy_Type_Code FROM Customer_Policies GROUP BY Policy_Type_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customer_policies"], "pred_sql": "SELECT Policy_Type_Code, COUNT(DISTINCT Customer_ID) AS Customer_Count\nFROM Customer_Policies\nGROUP BY Policy_Type_Code\nORDER BY Customer_Count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3893", "db_id": "insurance_policies", "question": "Which customers do not have any policies? Find the details of these customers.", "rationale": ["Identify the Customers table as the primary source of customer information.", "To find customers without policies, we need to check which Customer_IDs are present in the Customer_Policies table.", "Use a subquery to select all Customer_IDs from the Customer_Policies table.", "Use the NOT IN clause to filter out those Customer_IDs from the Customers table, thus identifying customers without any policies."], "gold_sql": "SELECT customer_details FROM Customers EXCEPT SELECT T1.customer_details FROM Customers AS T1 JOIN Customer_Policies AS T2 ON T1.customer_id  =  T2.customer_id", "source_tables": ["customer_policies", "customers"], "pred_sql": "SELECT * FROM Customers WHERE Customer_ID NOT IN (SELECT Customer_ID FROM Customer_Policies);", "hint": "\n"}
{"sample_id": "train.3895", "db_id": "insurance_policies", "question": "Which claims had exactly one settlement? For each, tell me the the date the claim was made, the date it was settled and the amount settled.", "rationale": ["Identify the relevant tables: Claims and Settlements.", "We need to select the date the claim was made, the date it was settled, and the amount settled.", "Join the Claims table with the Settlements table on the Claim_ID to access settlement details for each claim.", "Group the results by Claim_ID to aggregate the settlements for each claim.", "Use the HAVING clause to filter the groups to only those claims that have exactly one settlement."], "gold_sql": "SELECT T1.claim_id ,  T1.date_claim_made ,  T1.Date_Claim_Settled FROM Claims AS T1 JOIN Settlements AS T2 ON T1.Claim_id  =  T2.Claim_id GROUP BY T1.claim_id HAVING count(*)  =  1", "source_tables": ["claims", "settlements"], "pred_sql": "SELECT c.Date_Claim_Made, c.Date_Claim_Settled, s.Amount_Settled\nFROM Claims c\nJOIN Settlements s ON c.Claim_ID = s.Claim_ID\nGROUP BY c.Claim_ID\nHAVING COUNT(s.Settlement_ID) = 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of claims and their settlement dates from the 'Claims' table, specifically focusing on claims that have a certain number of associated settlements. The placeholders in the HAVING clause represent the count of settlements that must match for the claims to be included in the results.\",\n    \"1\": \"This virtual table provides the dates when claims were made and settled from the 'Claims' table for those claims where the amount claimed exceeds the average amount claimed across all claims. The placeholder in the WHERE clause represents a condition based on the average amount claimed.\"\n}\n"}
{"sample_id": "train.3898", "db_id": "hospital_1", "question": "Which department has the largest number of employees?", "rationale": ["Identify the relevant tables: Department and Physician.", "We need to count the number of employees in each department, which involves joining the Department table with the Physician table.", "Use a LEFT JOIN to include all departments even if they have no physicians.", "Group the results by department name to count the number of employees in each department.", "Order the results by the count of employees in descending order to find the department with the largest number of employees.", "Limit the results to 1 to get only the department with the largest number of employees."], "gold_sql": "SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT 1;", "source_tables": ["department"], "pred_sql": "SELECT d.Name, COUNT(p.EmployeeID) AS EmployeeCount\nFROM Department d\nLEFT JOIN Physician p ON d.Head = p.EmployeeID\nGROUP BY d.Name\nORDER BY EmployeeCount DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3899", "db_id": "hospital_1", "question": "Find the department with the most employees.", "rationale": ["Identify the relevant tables: Department and Affiliated_With.", "We need to count the number of physicians affiliated with each department, so we will join the Department table with the Affiliated_With table on the DepartmentID.", "Use COUNT() to count the number of physicians in each department.", "Group the results by department name to get the count per department.", "Order the results by the count of employees in descending order to find the department with the most employees.", "Limit the results to 1 to get only the department with the highest count."], "gold_sql": "SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT 1;", "source_tables": ["department"], "pred_sql": "SELECT Department.Name, COUNT(Affiliated_With.Physician) AS EmployeeCount\nFROM Department\nJOIN Affiliated_With ON Department.DepartmentID = Affiliated_With.Department\nGROUP BY Department.Name\nORDER BY EmployeeCount DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3901", "db_id": "hospital_1", "question": "Tell me the employee id of the head of the department with the least employees.", "rationale": ["We need to find the head of the department with the least employees.", "To do this, we will join the Department table with the Affiliated_With table to count the number of physicians in each department.", "We will group the results by DepartmentID to get the count of physicians per department.", "Next, we will order the results by the count of physicians in ascending order to find the department with the least employees.", "Finally, we will limit the results to 1 to get only the head of that department."], "gold_sql": "SELECT head FROM department GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["department"], "pred_sql": "SELECT Department.Head\nFROM Department\nJOIN Affiliated_With ON Department.DepartmentID = Affiliated_With.Department\nGROUP BY Department.DepartmentID\nORDER BY COUNT(Affiliated_With.Physician) ASC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3902", "db_id": "hospital_1", "question": "what is the name and position of the head whose department has least number of employees?", "rationale": ["We need to find the name and position of the head of the department with the least number of employees.", "The head of a department is identified by the 'Head' column in the Department table, which corresponds to the 'EmployeeID' in the Physician table.", "To find the department with the least number of employees, we can use the Affiliated_With table to count the number of physicians affiliated with each department.", "We will group the results by department and order them by the count of physicians in ascending order, limiting the result to the first one to get the department with the least employees.", "Finally, we will join the Physician and Department tables to get the name and position of the head of that department."], "gold_sql": "SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["physician", "department"], "pred_sql": "SELECT Physician.Name, Physician.Position \nFROM Physician \nJOIN Department ON Physician.EmployeeID = Department.Head \nWHERE Department.DepartmentID = \n  (SELECT Affiliated_With.Department \n   FROM Affiliated_With \n   GROUP BY Affiliated_With.Department \n   ORDER BY COUNT(Affiliated_With.Physician) ASC \n   LIMIT 1);", "hint": "\n"}
{"sample_id": "train.3903", "db_id": "hospital_1", "question": "Find the name and position of the head of the department with the least employees.", "rationale": ["Identify the head of the department by joining the Physician and Department tables on the EmployeeID and Head columns respectively.", "To find the department with the least employees, we need to count the number of physicians affiliated with each department. This can be done using the Affiliated_With table.", "We will group the results by department and order them by the count of physicians in ascending order to get the department with the least employees.", "We will limit the results to 1 to get only the department with the least employees.", "Finally, we will use the department ID from the subquery to filter the main query to get the name and position of the head of that department."], "gold_sql": "SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["physician", "department"], "pred_sql": "SELECT Physician.Name, Physician.Position \nFROM Physician \nJOIN Department ON Physician.EmployeeID = Department.Head \nWHERE Department.DepartmentID = \n    (SELECT Affiliated_With.Department \n     FROM Affiliated_With \n     GROUP BY Affiliated_With.Department \n     ORDER BY COUNT(Affiliated_With.Physician) ASC \n     LIMIT 1);", "hint": "\n"}
{"sample_id": "train.3904", "db_id": "hospital_1", "question": "What are names of patients who made an appointment?", "rationale": ["Identify the relevant tables: Patient and Appointment.", "We need to find the names of patients who have made an appointment, which means we need to join the Patient table with the Appointment table on the Patient's SSN and the Appointment's Patient identifier.", "Use SELECT DISTINCT to ensure we get unique patient names, as a patient may have multiple appointments.", "Construct the SQL query to select the names from the Patient table, joining with the Appointment table."], "gold_sql": "SELECT name FROM appointment AS T1 JOIN patient AS T2 ON T1.patient  =  T2.ssn", "source_tables": ["patient", "appointment"], "pred_sql": "SELECT DISTINCT Patient.Name\nFROM Patient\nJOIN Appointment ON Patient.SSN = Appointment.Patient;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of physicians who are primary care physicians (PCP) for a number of patients exceeding a specified threshold. The placeholder in the HAVING clause represents the minimum number of patients a physician must have to be included in the results.\",\n    \"1\": \"This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.\",\n    \"2\": \"This virtual table describes the names of medical procedures that are less expensive than a specified cost and are also treatments that a specific physician is certified to perform. The placeholders in the query represent the cost limit and the physician's name.\"\n}\n"}
{"sample_id": "train.3914", "db_id": "hospital_1", "question": "Find the names of all physicians and their primary affiliated departments' names.", "rationale": ["Identify the tables needed: Physician, Department, and Affiliated_With.", "We need to retrieve the names of physicians and their affiliated departments, so we will select the 'Name' columns from both the Physician and Department tables.", "To link the Physician and Department tables, we will use the Affiliated_With table, which contains the relationships between physicians and departments.", "We will perform a JOIN operation between the Physician and Affiliated_With tables on the EmployeeID and Physician columns, respectively.", "Next, we will join the Department table on the DepartmentID from the Affiliated_With table to get the department names.", "Finally, we need to filter the results to include only those affiliations that are marked as primary, which is indicated by the 'PrimaryAffiliation' column in the Affiliated_With table."], "gold_sql": "SELECT T1.name ,  T3.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T2.PrimaryAffiliation  =  1", "source_tables": ["physician", "department", "affiliated_with"], "pred_sql": "SELECT Physician.Name, Department.Name \nFROM Physician \nJOIN Affiliated_With ON Physician.EmployeeID = Affiliated_With.Physician \nJOIN Department ON Affiliated_With.Department = Department.DepartmentID \nWHERE Affiliated_With.PrimaryAffiliation = 'Yes';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of physicians along with the names of their affiliated departments from the 'Physician' and 'Department' tables. The join condition links physicians to their departments through the 'Affiliated_With' table, and the placeholder in the WHERE clause indicates whether the affiliation is primary.\",\n    \"1\": \"This virtual table provides a list of physicians along with their associated departments from the 'Affiliated_With' table, filtered by whether the affiliation is marked as primary. The placeholder in the WHERE clause represents the primary affiliation status.\",\n    \"2\": \"This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.\"\n}\n"}
{"sample_id": "train.3928", "db_id": "hospital_1", "question": "How many patients do each physician take care of? List their names and number of patients they take care of.", "rationale": ["Identify the tables needed: Physician and Patient.", "Join the Physician table with the Patient table on the condition that the Physician's EmployeeID matches the Patient's PCP.", "Count the number of patients for each physician using COUNT(Patient.SSN).", "Select the Physician's Name and the count of patients, aliasing the count as NumberOfPatients.", "Group the results by Physician's EmployeeID to aggregate the patient counts."], "gold_sql": "SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid", "source_tables": ["physician", "patient"], "pred_sql": "SELECT Physician.Name, COUNT(Patient.SSN) AS NumberOfPatients\nFROM Physician\nLEFT JOIN Patient ON Physician.EmployeeID = Patient.PCP\nGROUP BY Physician.EmployeeID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.\",\n    \"1\": \"This virtual table lists the names of physicians who are primary care physicians (PCP) for a number of patients exceeding a specified threshold. The placeholder in the HAVING clause represents the minimum number of patients a physician must have to be included in the results.\",\n    \"2\": \"This virtual table describes the names of physicians along with the names of their affiliated departments from the 'Physician' and 'Department' tables. The join condition links physicians to their departments through the 'Affiliated_With' table, and the placeholder in the WHERE clause indicates whether the affiliation is primary.\"\n}\n"}
{"sample_id": "train.3930", "db_id": "hospital_1", "question": "Find the name of physicians who are in charge of more than one patient.", "rationale": ["We need to find physicians who are in charge of more than one patient, which means we are looking for primary care physicians (PCP).", "To do this, we will join the 'Physician' table with the 'Patient' table on the condition that the physician's EmployeeID matches the patient's PCP identifier.", "Next, we will group the results by the physician's EmployeeID to count how many patients each physician is responsible for.", "Finally, we will use the HAVING clause to filter the results to only include physicians who have more than one patient (i.e., COUNT(Patient.SSN) > 1).", "We will select the names of these physicians in the final output."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  1", "source_tables": ["physician", "patient"], "pred_sql": "SELECT Physician.Name\nFROM Physician\nJOIN Patient ON Physician.EmployeeID = Patient.PCP\nGROUP BY Physician.EmployeeID\nHAVING COUNT(Patient.SSN) > 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of physicians who are primary care physicians (PCP) for a number of patients exceeding a specified threshold. The placeholder in the HAVING clause represents the minimum number of patients a physician must have to be included in the results.\",\n    \"1\": \"This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.\",\n    \"2\": \"This virtual table describes the names of physicians along with the names of their affiliated departments from the 'Physician' and 'Department' tables. The join condition links physicians to their departments through the 'Affiliated_With' table, and the placeholder in the WHERE clause indicates whether the affiliation is primary.\"\n}\n"}
{"sample_id": "train.3940", "db_id": "hospital_1", "question": "What is the names of the physicians who prescribe medication Thesisin?", "rationale": ["Identify the relevant tables: Physician, Prescribes, and Medication are needed to find the names of physicians who prescribe a specific medication.", "Join the Physician table with the Prescribes table on the EmployeeID and Physician columns to link physicians with their prescriptions.", "Next, join the Prescribes table with the Medication table on the Medication code to access the medication details.", "Use a WHERE clause to filter the results to only include prescriptions for the medication named 'Thesisin'.", "Select the Name column from the Physician table to get the names of the physicians who prescribed the medication."], "gold_sql": "SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  'Thesisin'", "source_tables": ["physician", "prescribes", "medication"], "pred_sql": "SELECT Physician.Name \nFROM Physician \nJOIN Prescribes ON Physician.EmployeeID = Prescribes.Physician \nJOIN Medication ON Prescribes.Medication = Medication.Code \nWHERE Medication.Name = 'Thesisin';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of prescribed medications grouped by their brand names. It combines data from the 'medication' table and the 'prescribes' table, allowing users to see how many times each brand of medication has been prescribed.\",\n    \"1\": \"This virtual table lists the names of physicians who are primary care physicians (PCP) for a number of patients exceeding a specified threshold. The placeholder in the HAVING clause represents the minimum number of patients a physician must have to be included in the results.\",\n    \"2\": \"This virtual table describes the names of physicians along with the names of their affiliated departments from the 'Physician' and 'Department' tables. The join condition links physicians to their departments through the 'Affiliated_With' table, and the placeholder in the WHERE clause indicates whether the affiliation is primary.\"\n}\n"}
{"sample_id": "train.3941", "db_id": "hospital_1", "question": "List the names of all the physicians who prescribe Thesisin as medication.", "rationale": ["Identify the tables involved: Physician, Prescribes, and Medication.", "We need to find the names of physicians who prescribe a specific medication, which is 'Thesisin'.", "Join the Physician table with the Prescribes table on the Physician's EmployeeID and the Prescribes table's Physician field.", "Join the Prescribes table with the Medication table on the Medication's Code and the Prescribes table's Medication field.", "Filter the results to only include records where the Medication's Name is 'Thesisin'.", "Select the Name field from the Physician table to get the desired output."], "gold_sql": "SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  'Thesisin'", "source_tables": ["physician", "prescribes", "medication"], "pred_sql": "SELECT Physician.Name \nFROM Physician \nJOIN Prescribes ON Physician.EmployeeID = Prescribes.Physician \nJOIN Medication ON Prescribes.Medication = Medication.Code \nWHERE Medication.Name = 'Thesisin';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of prescribed medications grouped by their brand names. It combines data from the 'medication' table and the 'prescribes' table, allowing users to see how many times each brand of medication has been prescribed.\",\n    \"1\": \"This virtual table lists the names of physicians who are primary care physicians (PCP) for a number of patients exceeding a specified threshold. The placeholder in the HAVING clause represents the minimum number of patients a physician must have to be included in the results.\",\n    \"2\": \"This virtual table describes the names of physicians along with the names of their affiliated departments from the 'Physician' and 'Department' tables. The join condition links physicians to their departments through the 'Affiliated_With' table, and the placeholder in the WHERE clause indicates whether the affiliation is primary.\"\n}\n"}
{"sample_id": "train.3944", "db_id": "hospital_1", "question": "Find the number of medications prescribed for each brand.", "rationale": ["We need to find the number of medications prescribed for each brand.", "To do this, we will join the 'Medication' table with the 'Prescribes' table on the medication code.", "We will select the brand from the 'Medication' table and count the number of prescriptions from the 'Prescribes' table.", "Finally, we will group the results by the brand to get the count for each brand."], "gold_sql": "SELECT count(*) ,  T1.name FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand", "source_tables": ["prescribes", "medication"], "pred_sql": "SELECT m.Brand, COUNT(p.Medication) AS MedicationCount\nFROM Medication m\nJOIN Prescribes p ON m.Code = p.Medication\nGROUP BY m.Brand;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of prescribed medications grouped by their brand names. It combines data from the 'medication' table and the 'prescribes' table, allowing users to see how many times each brand of medication has been prescribed.\",\n    \"1\": \"This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.\"\n}\n"}
{"sample_id": "train.3948", "db_id": "hospital_1", "question": "Find the patient who has the most recent undergoing treatment?", "rationale": ["To find the patient who has the most recent undergoing treatment, we need to look at the 'Undergoes' table which contains information about patients undergoing procedures.", "We will join the 'Undergoes' table with the 'Patient' table to get the patient's name along with the date of the procedure.", "We will order the results by the 'DateUndergoes' in descending order to get the most recent treatment at the top.", "Finally, we will limit the results to 1 to get only the most recent patient."], "gold_sql": "SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT 1", "source_tables": ["undergoes"], "pred_sql": "SELECT Patient.Name, Undergoes.DateUndergoes \nFROM Undergoes \nJOIN Patient ON Undergoes.Patient = Patient.SSN \nORDER BY Undergoes.DateUndergoes DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.\",\n    \"1\": \"This virtual table lists the names of physicians who are primary care physicians (PCP) for a number of patients exceeding a specified threshold. The placeholder in the HAVING clause represents the minimum number of patients a physician must have to be included in the results.\",\n    \"2\": \"This virtual table describes the names of medical procedures that are less expensive than a specified cost and are also treatments that a specific physician is certified to perform. The placeholders in the query represent the cost limit and the physician's name.\"\n}\n"}
{"sample_id": "train.3949", "db_id": "hospital_1", "question": "Which patient is undergoing the most recent treatment?", "rationale": ["Identify the relevant tables: We need to find patients undergoing treatments, which involves the 'Undergoes', 'Patient', and 'Procedures' tables.", "Join the 'Undergoes' table with the 'Patient' table to get patient names, using the SSN as the linking key.", "Join the 'Undergoes' table with the 'Procedures' table to get the names of the procedures being undergone, using the procedure code as the linking key.", "Order the results by the date of the procedures in descending order to get the most recent treatment at the top.", "Limit the results to 1 to get only the most recent treatment."], "gold_sql": "SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT 1", "source_tables": ["undergoes"], "pred_sql": "SELECT Patient.Name, Procedures.Name, Undergoes.DateUndergoes \nFROM Undergoes \nJOIN Patient ON Undergoes.Patient = Patient.SSN \nJOIN Procedures ON Undergoes.Procedures = Procedures.Code \nORDER BY Undergoes.DateUndergoes DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.\",\n    \"1\": \"This virtual table describes the names of medical procedures that are less expensive than a specified cost and are also treatments that a specific physician is certified to perform. The placeholders in the query represent the cost limit and the physician's name.\",\n    \"2\": \"This virtual table lists the names of physicians who are primary care physicians (PCP) for a number of patients exceeding a specified threshold. The placeholder in the HAVING clause represents the minimum number of patients a physician must have to be included in the results.\"\n}\n"}
{"sample_id": "train.3959", "db_id": "hospital_1", "question": "Find the physician who prescribed the highest dose. What is his or her name?", "rationale": ["Identify the relevant tables: 'Physician' for physician names and 'Prescribes' for prescription details.", "Join the 'Prescribes' table with the 'Physician' table on the physician's identifier to access physician names along with their prescribed doses.", "Order the results by the 'Dose' column in descending order to get the highest dose at the top.", "Limit the results to 1 to get only the physician who prescribed the highest dose."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT 1", "source_tables": ["physician", "prescribes"], "pred_sql": "SELECT Physician.Name\nFROM Prescribes\nJOIN Physician ON Prescribes.Physician = Physician.EmployeeID\nORDER BY Prescribes.Dose DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.\",\n    \"1\": \"This virtual table provides a count of prescribed medications grouped by their brand names. It combines data from the 'medication' table and the 'prescribes' table, allowing users to see how many times each brand of medication has been prescribed.\",\n    \"2\": \"This virtual table lists the names of physicians who are primary care physicians (PCP) for a number of patients exceeding a specified threshold. The placeholder in the HAVING clause represents the minimum number of patients a physician must have to be included in the results.\"\n}\n"}
{"sample_id": "train.3960", "db_id": "hospital_1", "question": "List the physicians' employee ids together with their primary affiliation departments' ids.", "rationale": ["Identify the tables needed: Physician and Affiliated_With.", "We need to retrieve the EmployeeID from the Physician table and the Department from the Affiliated_With table.", "Join the Physician table with the Affiliated_With table on the EmployeeID and Physician identifiers respectively.", "Filter the results to include only those records where the affiliation is marked as primary (i.e., PrimaryAffiliation = 'Yes').", "Select the required columns: EmployeeID and Department."], "gold_sql": "SELECT physician ,  department FROM affiliated_with WHERE primaryaffiliation  =  1", "source_tables": ["affiliated_with"], "pred_sql": "SELECT Physician.EmployeeID, Affiliated_With.Department \nFROM Physician \nJOIN Affiliated_With ON Physician.EmployeeID = Affiliated_With.Physician \nWHERE Affiliated_With.PrimaryAffiliation = 'Yes';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of physicians along with their associated departments from the 'Affiliated_With' table, filtered by whether the affiliation is marked as primary. The placeholder in the WHERE clause represents the primary affiliation status.\",\n    \"1\": \"This virtual table describes the names of physicians along with the names of their affiliated departments from the 'Physician' and 'Department' tables. The join condition links physicians to their departments through the 'Affiliated_With' table, and the placeholder in the WHERE clause indicates whether the affiliation is primary.\",\n    \"2\": \"This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.\"\n}\n"}
{"sample_id": "train.3971", "db_id": "hospital_1", "question": "What are the three most costly procedures?", "rationale": ["Identify the relevant table: Procedures, which contains the cost of each procedure.", "Select the columns needed: Name (for the procedure name) and Cost (for the cost of the procedure).", "Order the results by Cost in descending order to get the most expensive procedures first.", "Limit the results to 3 to get only the top three most costly procedures."], "gold_sql": "SELECT name FROM procedures ORDER BY cost LIMIT 3", "source_tables": ["procedures"], "pred_sql": "SELECT Name, Cost FROM Procedures ORDER BY Cost DESC LIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of medical procedures that are less expensive than a specified cost and are also treatments that a specific physician is certified to perform. The placeholders in the query represent the cost limit and the physician's name.\",\n    \"1\": \"This virtual table provides a list of procedure names from the 'Procedures' table that have a cost greater than a specified amount. Additionally, it includes names of procedures that a specific physician is trained in, by joining the 'Physician', 'Trained_In', and 'Procedures' tables. The placeholders represent the cost threshold and the physician's name respectively.\",\n    \"2\": \"This virtual table lists the names of physicians who are primary care physicians (PCP) for a number of patients exceeding a specified threshold. The placeholder in the HAVING clause represents the minimum number of patients a physician must have to be included in the results.\"\n}\n"}
{"sample_id": "train.3972", "db_id": "hospital_1", "question": "Find the physicians who are trained in a procedure that costs more than 5000.", "rationale": ["Identify the relevant tables: Physician, Trained_In, and Procedures.", "We need to find physicians who are trained in procedures that cost more than 5000.", "Join the Physician table with the Trained_In table on the Physician's EmployeeID and the Trained_In's Physician.", "Then, join the resulting table with the Procedures table on the Trained_In's Treatment and Procedures' Code.", "Filter the results where the cost of the procedure is greater than 5000.", "Select the distinct names of the physicians from the final result."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  5000", "source_tables": ["physician", "procedures", "trained_in"], "pred_sql": "SELECT DISTINCT Physician.Name\nFROM Physician\nJOIN Trained_In ON Physician.EmployeeID = Trained_In.Physician\nJOIN Procedures ON Trained_In.Treatment = Procedures.Code\nWHERE Procedures.Cost > 5000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of medical procedures that are less expensive than a specified cost and are also treatments that a specific physician is certified to perform. The placeholders in the query represent the cost limit and the physician's name.\",\n    \"1\": \"This virtual table provides a list of procedure names from the 'Procedures' table that have a cost greater than a specified amount. Additionally, it includes names of procedures that a specific physician is trained in, by joining the 'Physician', 'Trained_In', and 'Procedures' tables. The placeholders represent the cost threshold and the physician's name respectively.\",\n    \"2\": \"This virtual table lists the names of physicians who are primary care physicians (PCP) for a number of patients exceeding a specified threshold. The placeholder in the HAVING clause represents the minimum number of patients a physician must have to be included in the results.\"\n}\n"}
{"sample_id": "train.3974", "db_id": "hospital_1", "question": "Find the physician who was trained in the most expensive procedure?", "rationale": ["Identify the tables involved: Physician, Trained_In, and Procedures.", "We need to find the physician who is trained in the most expensive procedure.", "Join the Physician table with the Trained_In table to get the treatments each physician is certified to perform.", "Then, join the Procedures table to get the details of those treatments, including their costs.", "To find the most expensive procedure, we can use a subquery to get the maximum cost from the Procedures table.", "Finally, filter the results to only include the procedure(s) that match this maximum cost."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment ORDER BY T3.cost DESC LIMIT 1", "source_tables": ["physician", "procedures", "trained_in"], "pred_sql": "SELECT p.Name, pr.Name AS ProcedureName, pr.Cost\nFROM Physician p\nJOIN Trained_In ti ON p.EmployeeID = ti.Physician\nJOIN Procedures pr ON ti.Treatment = pr.Code\nWHERE pr.Cost = (SELECT MAX(Cost) FROM Procedures)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of medical procedures that are less expensive than a specified cost and are also treatments that a specific physician is certified to perform. The placeholders in the query represent the cost limit and the physician's name.\",\n    \"1\": \"This virtual table provides a list of procedure names from the 'Procedures' table that have a cost greater than a specified amount. Additionally, it includes names of procedures that a specific physician is trained in, by joining the 'Physician', 'Trained_In', and 'Procedures' tables. The placeholders represent the cost threshold and the physician's name respectively.\",\n    \"2\": \"This virtual table lists the names of physicians who are primary care physicians (PCP) for a number of patients exceeding a specified threshold. The placeholder in the HAVING clause represents the minimum number of patients a physician must have to be included in the results.\"\n}\n"}
{"sample_id": "train.3980", "db_id": "hospital_1", "question": "Find all procedures which cost more than 1000 or which physician John Wen was trained in.", "rationale": ["Identify the tables involved: Procedures, Trained_In, and Physician.", "We need to find procedures with a cost greater than 1000, which can be done by filtering the Procedures table.", "We also need to find procedures that John Wen is trained in, which requires joining the Trained_In and Physician tables to get the relevant procedures for that physician.", "Use a LEFT JOIN to connect Procedures with Trained_In on the procedure code and then with Physician on the physician's EmployeeID.", "The WHERE clause will filter for procedures that either have a cost greater than 1000 or are associated with John Wen.", "Use DISTINCT to ensure that we do not have duplicate procedure names in the result."], "gold_sql": "SELECT name FROM procedures WHERE cost  >  1000 UNION SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  'John Wen'", "source_tables": ["procedures", "physician", "trained_in"], "pred_sql": "SELECT DISTINCT Procedures.Name \nFROM Procedures \nLEFT JOIN Trained_In ON Procedures.Code = Trained_In.Treatment \nLEFT JOIN Physician ON Trained_In.Physician = Physician.EmployeeID \nWHERE Procedures.Cost > 1000 OR Physician.Name = 'John Wen';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of procedure names from the 'Procedures' table that have a cost greater than a specified amount. Additionally, it includes names of procedures that a specific physician is trained in, by joining the 'Physician', 'Trained_In', and 'Procedures' tables. The placeholders represent the cost threshold and the physician's name respectively.\",\n    \"1\": \"This virtual table describes the names of medical procedures that are less expensive than a specified cost and are also treatments that a specific physician is certified to perform. The placeholders in the query represent the cost limit and the physician's name.\",\n    \"2\": \"This virtual table lists the names of physicians who are primary care physicians (PCP) for a number of patients exceeding a specified threshold. The placeholder in the HAVING clause represents the minimum number of patients a physician must have to be included in the results.\"\n}\n"}
{"sample_id": "train.3993", "db_id": "hospital_1", "question": "How many patients are not using Procrastin-X as medication?", "rationale": ["We need to count the number of patients who are not using a specific medication, Procrastin-X.", "First, we identify the medication code for Procrastin-X from the Medication table.", "Next, we find all patients who have been prescribed Procrastin-X by checking the Prescribes table.", "We then use this list of patients to filter out those who are using Procrastin-X from the total list of patients in the Patient table.", "Finally, we count the remaining patients who are not in the list of those using Procrastin-X."], "gold_sql": "SELECT count(*) FROM patient WHERE SSN NOT IN ( SELECT T1.patient FROM Prescribes AS T1 JOIN Medication AS T2 ON T1.Medication  =  T2.Code WHERE T2.name  =  'Procrastin-X' )", "source_tables": ["patient", "prescribes", "medication"], "pred_sql": "SELECT COUNT(*) AS PatientCount\nFROM Patient\nWHERE SSN NOT IN (\n    SELECT Patient\n    FROM Prescribes\n    WHERE Medication IN (\n        SELECT Code\n        FROM Medication\n        WHERE Brand = 'Procrastin-X'\n    )\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of prescribed medications grouped by their brand names. It combines data from the 'medication' table and the 'prescribes' table, allowing users to see how many times each brand of medication has been prescribed.\",\n    \"1\": \"This virtual table lists the names of physicians who are primary care physicians (PCP) for a number of patients exceeding a specified threshold. The placeholder in the HAVING clause represents the minimum number of patients a physician must have to be included in the results.\",\n    \"2\": \"This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.\"\n}\n"}
{"sample_id": "train.4256", "db_id": "club_1", "question": "What are the first names of all the students?", "rationale": ["Identify the table that contains the required information, which is the 'Student' table.", "Determine the specific column needed, which is 'Fname' for the first names of students.", "Construct the SQL query to select the 'Fname' column from the 'Student' table."], "gold_sql": "SELECT DISTINCT fname FROM student", "source_tables": ["student"], "pred_sql": "SELECT Fname FROM Student;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of students who are members of a specific club and belong to a certain gender. The placeholders in the WHERE clause represent the club's name and the student's gender.\"\n}\n"}
{"sample_id": "train.4271", "db_id": "club_1", "question": "Give me the first name and last name for all the female members of the club \"Bootup Baltimore\".", "rationale": ["Identify the tables needed: Student, Member_of_club, and Club.", "Determine the columns to select: first name (Fname) and last name (LName) of female members.", "Establish the relationships between the tables: Student is linked to Member_of_club via StuID, and Member_of_club is linked to Club via ClubID.", "Filter the results to include only those members who are female and belong to the club named 'Bootup Baltimore'.", "Construct the SQL query using SELECT, JOIN, and WHERE clauses to retrieve the desired information."], "gold_sql": "SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  'Bootup Baltimore' AND t3.sex  =  'F'", "source_tables": ["club", "member_of_club", "student"], "pred_sql": "SELECT Fname, LName \nFROM Student \nJOIN Member_of_club ON Student.StuID = Member_of_club.StuID \nJOIN Club ON Member_of_club.ClubID = Club.ClubID \nWHERE Club.ClubName = 'Bootup Baltimore' AND Student.Sex = 'Female';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of students who are members of a specific club and belong to a certain gender. The placeholders in the WHERE clause represent the club's name and the student's gender.\",\n    \"1\": \"This virtual table provides a list of club names from the 'Club' table that are associated with students of a specific gender. The query joins the 'Club', 'Member_of_club', and 'Student' tables to filter clubs based on the gender of the students. The results are grouped by club name and ordered by the number of members in descending order, with a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.4277", "db_id": "club_1", "question": "Find the club which has the largest number of members majoring in \"600\".", "rationale": ["Identify the tables involved: We need to find clubs and their members, so we will use the 'Club', 'Member_of_club', and 'Student' tables.", "Join the tables: We will join 'Club' with 'Member_of_club' on 'ClubID' and 'Member_of_club' with 'Student' on 'StuID' to get the necessary information about clubs and their members.", "Filter by major: We need to filter the results to only include students majoring in '600'.", "Group the results: We will group the results by club name to count the number of members in each club.", "Count members: We will use COUNT() to count the number of members for each club.", "Order the results: We will order the results by the count of members in descending order to find the club with the most members.", "Limit the results: We will limit the results to 1 to get only the club with the largest number of members."], "gold_sql": "SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.major  =  '600' GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT 1", "source_tables": ["club", "member_of_club", "student"], "pred_sql": "SELECT Club.ClubName, COUNT(Member_of_club.StuID) AS MemberCount\nFROM Club\nJOIN Member_of_club ON Club.ClubID = Member_of_club.ClubID\nJOIN Student ON Member_of_club.StuID = Student.StuID\nWHERE Student.Major = '600'\nGROUP BY Club.ClubName\nORDER BY MemberCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of clubs that students with a specific major are members of. The results are grouped by club name and ordered by the number of members in descending order, with a limit on the number of clubs returned. The placeholders in the WHERE clause and LIMIT clause represent the major of the students and the maximum number of clubs to display, respectively.\",\n    \"1\": \"This virtual table describes the first and last names of students who are members of a specific club and belong to a certain gender. The placeholders in the WHERE clause represent the club's name and the student's gender.\",\n    \"2\": \"This virtual table provides a list of club names from the 'Club' table that are associated with students of a specific gender. The query joins the 'Club', 'Member_of_club', and 'Student' tables to filter clubs based on the gender of the students. The results are grouped by club name and ordered by the number of members in descending order, with a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.4278", "db_id": "club_1", "question": "Find the name of the club that has the most female students.", "rationale": ["We need to find the name of the club with the most female students.", "To do this, we will join the 'Club', 'Member_of_club', and 'Student' tables to access the necessary information about clubs and their members.", "We will filter the results to include only female students by using a WHERE clause that checks for 'Student.Sex = 'Female'.", "Next, we will group the results by club name to count the number of female members in each club.", "We will order the results in descending order based on the count of female students to get the club with the most female members at the top.", "Finally, we will limit the results to 1 to get only the top club."], "gold_sql": "SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.sex  =  'F' GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT 1", "source_tables": ["club", "member_of_club", "student"], "pred_sql": "SELECT Club.ClubName\nFROM Club\nJOIN Member_of_club ON Club.ClubID = Member_of_club.ClubID\nJOIN Student ON Member_of_club.StuID = Student.StuID\nWHERE Student.Sex = 'Female'\nGROUP BY Club.ClubName\nORDER BY COUNT(Student.StuID) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of students who are members of a specific club and belong to a certain gender. The placeholders in the WHERE clause represent the club's name and the student's gender.\",\n    \"1\": \"This virtual table lists the names of clubs that students with a specific major are members of. The results are grouped by club name and ordered by the number of members in descending order, with a limit on the number of clubs returned. The placeholders in the WHERE clause and LIMIT clause represent the major of the students and the maximum number of clubs to display, respectively.\",\n    \"2\": \"This virtual table provides a list of club names from the 'Club' table that are associated with students of a specific gender. The query joins the 'Club', 'Member_of_club', and 'Student' tables to filter clubs based on the gender of the students. The results are grouped by club name and ordered by the number of members in descending order, with a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.4312", "db_id": "club_1", "question": "List the clubs that have at least a member with advisor \"1121\".", "rationale": ["We need to list clubs that have at least one member with a specific advisor, which is '1121'.", "To achieve this, we will join the 'Club', 'Member_of_club', and 'Student' tables.", "The 'Club' table contains the club names, while the 'Member_of_club' table links students to clubs, and the 'Student' table contains advisor information.", "We will use a JOIN operation to connect these tables based on their relationships: 'Member_of_club.ClubID' with 'Club.ClubID' and 'Member_of_club.StuID' with 'Student.StuID'.", "We will filter the results using a WHERE clause to only include students whose advisor is '1121'.", "Finally, we will select distinct club names to avoid duplicates in the results."], "gold_sql": "SELECT DISTINCT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.advisor  =  1121", "source_tables": ["club", "member_of_club", "student"], "pred_sql": "SELECT DISTINCT Club.ClubName \nFROM Club \nJOIN Member_of_club ON Club.ClubID = Member_of_club.ClubID \nJOIN Student ON Member_of_club.StuID = Student.StuID \nWHERE Student.Advisor = '1121';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of clubs that students with a specific major are members of. The results are grouped by club name and ordered by the number of members in descending order, with a limit on the number of clubs returned. The placeholders in the WHERE clause and LIMIT clause represent the major of the students and the maximum number of clubs to display, respectively.\",\n    \"1\": \"This virtual table describes the first and last names of students who are members of a specific club and belong to a certain gender. The placeholders in the WHERE clause represent the club's name and the student's gender.\",\n    \"2\": \"This virtual table provides a list of club names from the 'Club' table that are associated with students of a specific gender. The query joins the 'Club', 'Member_of_club', and 'Student' tables to filter clubs based on the gender of the students. The results are grouped by club name and ordered by the number of members in descending order, with a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.4324", "db_id": "tracking_grants_for_research", "question": "What is the total grant amount of the organisations described as research?", "rationale": ["Identify the relevant tables: Grants, Organisations, and Organisation_Types.", "We need to sum the grant amounts, so we will use the SUM function on the grant_amount column from the Grants table.", "To filter the organisations described as research, we will join the Organisations table with the Organisation_Types table using the organisation_type foreign key.", "We will filter the results where the organisation_type_description in Organisation_Types is 'research'.", "Finally, we will select the total grant amount by summing the grant_amount from the Grants table."], "gold_sql": "SELECT sum(grant_amount) FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id JOIN organisation_Types AS T3 ON T2.organisation_type  =  T3.organisation_type WHERE T3.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations"], "pred_sql": "SELECT SUM(g.grant_amount) AS total_grant_amount\nFROM Grants g\nJOIN Organisations o ON g.organisation_id = o.organisation_id\nJOIN Organisation_Types ot ON o.organisation_type = ot.organisation_type\nWHERE ot.organisation_type_description = 'research';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the grant amounts from the 'Grants' table that are associated with documents sent before a specific date and grants that are still active after a certain end date. The placeholders in the WHERE clause represent the dates for filtering the documents and grants.\",\n    \"1\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\"\n}\n"}
{"sample_id": "train.4327", "db_id": "tracking_grants_for_research", "question": "From what date and to what date do the staff work on a project that has the most staff and has staff in a leader role?", "rationale": ["Identify the role code for the leader role from the Staff_Roles table.", "Use the role code to filter the Project_Staff table to find projects that have staff in a leader role.", "Group the results by project_id and count the number of staff members for each project.", "Order the projects by the count of staff members in descending order to find the project with the most staff.", "Limit the results to 1 to get the project_id of the project with the most staff in a leader role.", "Use the project_id obtained to select the date_from and date_to from the Project_Staff table."], "gold_sql": "SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT 1 ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  'leader'", "source_tables": ["project_staff"], "pred_sql": "SELECT date_from, date_to \nFROM Project_Staff \nWHERE project_id = (SELECT project_id \n                    FROM Project_Staff \n                    WHERE role_code = (SELECT role_code \n                                      FROM Staff_Roles \n                                      WHERE role_description = 'leader') \n                    GROUP BY project_id \n                    ORDER BY COUNT(staff_id) DESC \n                    LIMIT 1)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\"\n}\n"}
{"sample_id": "train.4328", "db_id": "tracking_grants_for_research", "question": "Find the organisation ids and details of the organisations which are involved in", "rationale": ["The user wants to find the organisation ids and details of the organisations involved in projects.", "To get the organisation ids and details, we need to select the relevant columns from the Organisations table.", "The relevant columns are 'organisation_id' and 'organisation_details'.", "The query will be a simple SELECT statement from the Organisations table."], "gold_sql": "SELECT T2.organisation_id ,  T2.organisation_details FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id GROUP BY T2.organisation_id HAVING sum(T1.grant_amount)  >  6000", "source_tables": ["grants", "organisations"], "pred_sql": "SELECT organisation_id, organisation_details FROM Organisations;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\"\n}\n"}
{"sample_id": "train.4330", "db_id": "tracking_grants_for_research", "question": "What is the organisation type and id of the organisation which has the most number of research staff?", "rationale": ["Identify the relevant tables: Organisations and Research_Staff.", "Join the Organisations table with the Research_Staff table on the organisation_id and employer_organisation_id fields.", "Group the results by organisation_id and organisation_type to count the number of research staff per organisation.", "Order the results by the count of research staff in descending order to find the organisation with the most research staff.", "Limit the results to 1 to get only the top organisation."], "gold_sql": "SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT o.organisation_id, o.organisation_type \nFROM Organisations o \nJOIN Research_Staff rs ON o.organisation_id = rs.employer_organisation_id \nGROUP BY o.organisation_id, o.organisation_type \nORDER BY COUNT(rs.staff_id) DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\"\n}\n"}
{"sample_id": "train.4331", "db_id": "tracking_grants_for_research", "question": "What is the type and id of the organization that has the most research staff?", "rationale": ["Identify the relevant tables: Organisations and Research_Staff.", "Join the Organisations table with the Research_Staff table on the organisation_id.", "Group the results by organisation_id and organisation_type to count the number of research staff per organisation.", "Order the results by the count of research staff in descending order to find the organisation with the most research staff.", "Limit the results to 1 to get only the top organisation."], "gold_sql": "SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT Organisations.organisation_type, Organisations.organisation_id\nFROM Organisations\nJOIN Research_Staff ON Organisations.organisation_id = Research_Staff.employer_organisation_id\nGROUP BY Organisations.organisation_id, Organisations.organisation_type\nORDER BY COUNT(Research_Staff.staff_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\"\n}\n"}
{"sample_id": "train.4333", "db_id": "tracking_grants_for_research", "question": "What is the type of the organization with the most research staff?", "rationale": ["Identify the relevant tables: Organisations, Research_Staff, and Organisation_Types are needed to find the type of organization with the most research staff.", "Join the Organisations table with the Research_Staff table on the organisation_id to link research staff to their respective organizations.", "Join the Organisation_Types table to get the description of the organization type.", "Group the results by organisation_id to count the number of research staff per organization.", "Order the results by the count of research staff in descending order to get the organization with the most staff at the top.", "Limit the results to 1 to get only the top organization."], "gold_sql": "SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT ot.organisation_type_description \nFROM Organisations o \nJOIN Research_Staff rs ON o.organisation_id = rs.employer_organisation_id \nJOIN Organisation_Types ot ON o.organisation_type = ot.organisation_type \nGROUP BY o.organisation_id \nORDER BY COUNT(rs.staff_id) DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\"\n}\n"}
{"sample_id": "train.4334", "db_id": "tracking_grants_for_research", "question": "Find out the send dates of the documents with the grant amount of more than 5000 were granted by organisation type described", "rationale": ["Identify the relevant tables: Documents, Grants, Organisations, and Organisation_Types.", "Determine the relationships between these tables: Documents are linked to Grants via grant_id, Grants are linked to Organisations via organisation_id, and Organisations are linked to Organisation_Types via organisation_type.", "Select the 'sent_date' from the Documents table as the main output.", "Join the Grants table to filter documents based on the grant amount, specifically those greater than 5000.", "Join the Organisations table to ensure we can access the organisation type, although it is not directly used in the WHERE clause for filtering.", "Construct the SQL query to retrieve the desired information."], "gold_sql": "SELECT T1.sent_date FROM documents AS T1 JOIN Grants AS T2 ON T1.grant_id  =  T2.grant_id JOIN Organisations AS T3 ON T2.organisation_id  =  T3.organisation_id JOIN organisation_Types AS T4 ON T3.organisation_type  =  T4.organisation_type WHERE T2.grant_amount  >  5000 AND T4.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations", "documents"], "pred_sql": "SELECT Documents.sent_date \nFROM Documents \nJOIN Grants ON Documents.grant_id = Grants.grant_id \nJOIN Organisations ON Grants.organisation_id = Organisations.organisation_id \nJOIN Organisation_Types ON Organisations.organisation_type = Organisation_Types.organisation_type \nWHERE Grants.grant_amount > 5000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the grant amounts from the 'Grants' table that are associated with documents sent before a specific date and grants that are still active after a certain end date. The placeholders in the WHERE clause represent the dates for filtering the documents and grants.\",\n    \"1\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\"\n}\n"}
{"sample_id": "train.4335", "db_id": "tracking_grants_for_research", "question": "What are the send dates for all documents that have a grant amount of more than 5000 and are involved in research?", "rationale": ["Identify the relevant tables: Documents and Grants.", "Determine the relationship between the tables: Documents are linked to Grants via grant_id.", "Filter the Grants table for grant amounts greater than 5000.", "Select the sent_date from the Documents table for the filtered grants."], "gold_sql": "SELECT T1.sent_date FROM documents AS T1 JOIN Grants AS T2 ON T1.grant_id  =  T2.grant_id JOIN Organisations AS T3 ON T2.organisation_id  =  T3.organisation_id JOIN organisation_Types AS T4 ON T3.organisation_type  =  T4.organisation_type WHERE T2.grant_amount  >  5000 AND T4.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations", "documents"], "pred_sql": "SELECT Documents.sent_date \nFROM Documents \nJOIN Grants ON Documents.grant_id = Grants.grant_id \nWHERE Grants.grant_amount > 5000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the grant amounts from the 'Grants' table that are associated with documents sent before a specific date and grants that are still active after a certain end date. The placeholders in the WHERE clause represent the dates for filtering the documents and grants.\",\n    \"1\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\"\n}\n"}
{"sample_id": "train.4343", "db_id": "tracking_grants_for_research", "question": "When did researchers start and stop working?", "rationale": ["Identify the relevant table: Project_Staff contains the start and end dates of staff involvement in projects.", "Select the columns needed: date_from (start date) and date_to (end date) are the relevant columns for the question.", "Construct the SQL query: Use SELECT to retrieve date_from and date_to from Project_Staff."], "gold_sql": "SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  'researcher'", "source_tables": ["project_staff"], "pred_sql": "SELECT date_from, date_to FROM Project_Staff;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\"\n}\n"}
{"sample_id": "train.4349", "db_id": "tracking_grants_for_research", "question": "What are the details for the project whose research has been published?", "rationale": ["Identify the main table to query: Projects, as we need details for the project.", "Determine the relationship between Projects and Research outcomes: Projects are linked to outcomes through Project_Outcomes.", "Filter the Project_Outcomes table to find projects with published research outcomes by checking the Research_Outcomes table for relevant outcome descriptions.", "Use a subquery to find project_ids from Project_Outcomes that match the outcome codes from Research_Outcomes where the description indicates publication.", "Combine the results to select all details from the Projects table for the identified project_ids."], "gold_sql": "SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id JOIN Research_outcomes AS T3 ON T2.outcome_code  =  T3.outcome_code WHERE T3.outcome_description LIKE '%Published%'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "pred_sql": "SELECT * FROM Projects WHERE project_id IN (SELECT project_id FROM Project_Outcomes WHERE outcome_code IN (SELECT outcome_code FROM Research_Outcomes WHERE outcome_description LIKE '%published%'))", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the project details from the 'Projects' table that have two specific outcomes. The query uses an INTERSECT operation to find projects that meet both outcome criteria, represented by placeholders for the outcome codes.\",\n    \"1\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n    \"2\": \"This virtual table describes the project details from the 'Projects' table that have specific outcomes. It retrieves project details for projects that have two different specified outcome codes, ensuring that only projects meeting both criteria are included in the results. The placeholders in the WHERE clause represent the outcome codes being queried.\"\n}\n"}
{"sample_id": "train.4356", "db_id": "tracking_grants_for_research", "question": "Which project made the most number of outcomes? List the project details and the project id.", "rationale": ["Identify the relevant tables: Projects and Project_Outcomes are needed to get project details and their outcomes.", "Join the Projects table with the Project_Outcomes table on the project_id to link projects with their outcomes.", "Group the results by project_id and project_details to aggregate the outcomes for each project.", "Count the number of outcomes for each project using COUNT(po.outcome_code).", "Order the results in descending order to get the project with the most outcomes at the top.", "Limit the results to 1 to get only the project with the highest number of outcomes."], "gold_sql": "SELECT T1.project_details ,  T1.project_id FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "projects"], "pred_sql": "SELECT p.project_id, p.project_details\nFROM Projects p\nJOIN Project_Outcomes po ON p.project_id = po.project_id\nGROUP BY p.project_id, p.project_details\nORDER BY COUNT(po.outcome_code) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the project details from the 'Projects' table that have two specific outcomes. The query uses an INTERSECT operation to find projects that meet both outcome criteria, represented by placeholders for the outcome codes.\",\n    \"1\": \"This virtual table describes the project details from the 'Projects' table that have specific outcomes. It retrieves project details for projects that have two different specified outcome codes, ensuring that only projects meeting both criteria are included in the results. The placeholders in the WHERE clause represent the outcome codes being queried.\",\n    \"2\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\"\n}\n"}
{"sample_id": "train.4360", "db_id": "tracking_grants_for_research", "question": "Which organisation hired the most number of research staff? List the organisation id, type and detail.", "rationale": ["Identify the relevant tables: Organisations and Research_Staff.", "Join the Organisations table with the Research_Staff table on the organisation_id.", "Group the results by organisation_id, organisation_type, and organisation_details to count the number of research staff per organisation.", "Order the results by the count of research staff in descending order to find the organisation with the most staff.", "Limit the results to 1 to get only the top organisation."], "gold_sql": "SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT o.organisation_id, o.organisation_type, o.organisation_details\nFROM Organisations o\nJOIN Research_Staff rs ON o.organisation_id = rs.employer_organisation_id\nGROUP BY o.organisation_id, o.organisation_type, o.organisation_details\nORDER BY COUNT(rs.staff_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\"\n}\n"}
{"sample_id": "train.4361", "db_id": "tracking_grants_for_research", "question": "What are the ids, types, and details of the organization with the most research staff?", "rationale": ["Identify the relevant tables: Organisations and Research_Staff.", "We need to join these tables on the organisation_id to get the details of the organizations that employ research staff.", "We will group the results by organisation_id to count the number of research staff for each organization.", "To find the organization with the most research staff, we will order the results by the count of staff in descending order.", "Finally, we will limit the results to 1 to get only the organization with the highest count of research staff."], "gold_sql": "SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT o.organisation_id, o.organisation_type, o.organisation_details\nFROM Organisations o\nJOIN Research_Staff rs ON o.organisation_id = rs.employer_organisation_id\nGROUP BY o.organisation_id\nORDER BY COUNT(rs.staff_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\"\n}\n"}
{"sample_id": "train.4363", "db_id": "tracking_grants_for_research", "question": "For each staff id, what is the description of the role that is involved with the most number of projects?", "rationale": ["Identify the relevant tables: Project_Staff for staff involvement in projects and Staff_Roles for role descriptions.", "We need to find the role involved with the most number of projects for each staff id.", "To do this, we will first create a subquery that counts the number of staff members associated with each project and orders them in descending order, limiting the result to the top project.", "Next, we will join the Project_Staff table with the Staff_Roles table to get the role descriptions for the staff members involved in that project.", "Finally, we will select the staff_id and the corresponding role_description from the joined tables."], "gold_sql": "SELECT T1.role_description ,  T2.staff_id FROM Staff_Roles AS T1 JOIN Project_Staff AS T2 ON T1.role_code  =  T2.role_code JOIN Project_outcomes AS T3 ON T2.project_id  =  T3.project_id GROUP BY T2.staff_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "project_staff", "staff_roles"], "pred_sql": "SELECT ps.staff_id, sr.role_description\nFROM Project_Staff ps\nJOIN Staff_Roles sr ON ps.role_code = sr.role_code\nWHERE ps.project_id IN (\n    SELECT project_id\n    FROM Project_Staff\n    GROUP BY project_id\n    ORDER BY COUNT(staff_id) DESC\n    LIMIT 1\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n    \"1\": \"This virtual table provides a list of project details from the 'Projects' table for projects that do not have any associated staff members with a specific role. The placeholder in the WHERE clause represents the role code that is being filtered out.\",\n    \"2\": \"This virtual table provides a list of project details from the 'Projects' table for projects that do not have any associated staff members with a specific role. The placeholder in the WHERE clause represents the role code that is being filtered out.\"\n}\n"}
{"sample_id": "train.4367", "db_id": "tracking_grants_for_research", "question": "For grants that have descriptions of Regular and Initial Applications, what are their start dates?", "rationale": ["Identify the relevant tables: Grants, Documents, and Document_Types.", "We need to retrieve the start dates of grants, so we will select 'grant_start_date' from the Grants table.", "To filter the grants based on document descriptions, we will join the Documents table with the Grants table using 'grant_id'.", "Next, we will join the Document_Types table with the Documents table using 'document_type_code' to access the document descriptions.", "We will filter the results where the document descriptions are either 'Regular Applications' or 'Initial Applications'."], "gold_sql": "SELECT T1.grant_start_date FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id JOIN Document_Types AS T3 ON T2.document_type_code  =  T3.document_type_code WHERE T3.document_description  =  'Regular' INTERSECT SELECT T1.grant_start_date FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id JOIN Document_Types AS T3 ON T2.document_type_code  =  T3.document_type_code WHERE T3.document_description  =  'Initial Application'", "source_tables": ["grants", "document_types", "documents"], "pred_sql": "SELECT g.grant_start_date \nFROM Grants g \nJOIN Documents d ON g.grant_id = d.grant_id \nJOIN Document_Types dt ON d.document_type_code = dt.document_type_code \nWHERE dt.document_description IN ('Regular Applications', 'Initial Applications');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the grant amounts from the 'Grants' table that are associated with documents sent before a specific date and grants that are still active after a certain end date. The placeholders in the WHERE clause represent the dates for filtering the documents and grants.\",\n    \"1\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\"\n}\n"}
{"sample_id": "train.4369", "db_id": "tracking_grants_for_research", "question": "For each grant id, how many documents does it have, and which one has the most?", "rationale": ["Identify the relevant tables: Grants and Documents.", "We need to count the number of documents associated with each grant, so we will use a LEFT JOIN between Grants and Documents on the grant_id.", "Use COUNT() to count the number of documents for each grant.", "Group the results by grant_id to get the count for each grant.", "To find the grant with the most documents, we will order the results by the document count in descending order and limit the results to 1."], "gold_sql": "SELECT grant_id ,  count(*) FROM Documents GROUP BY grant_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["documents"], "pred_sql": "SELECT g.grant_id, COUNT(d.document_id) AS document_count, d.document_id AS most_documents\nFROM Grants g\nLEFT JOIN Documents d ON g.grant_id = d.grant_id\nGROUP BY g.grant_id\nORDER BY document_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the grant amounts from the 'Grants' table that are associated with documents sent before a specific date and grants that are still active after a certain end date. The placeholders in the WHERE clause represent the dates for filtering the documents and grants.\"\n}\n"}
{"sample_id": "train.4372", "db_id": "tracking_grants_for_research", "question": "What are all the details of the organisations described as 'Sponsor'? Sort the result in an ascending order.", "rationale": ["Identify the relevant table: Organisations.", "Determine the condition to filter organisations: organisation_type should match the type described as 'Sponsor'.", "To find the organisation_type corresponding to 'Sponsor', a subquery is needed to select the organisation_type from Organisation_Types where organisation_type_description is 'Sponsor'.", "Combine the main query and the subquery to filter the Organisations table based on the result of the subquery.", "Sort the results in ascending order by organisation_id."], "gold_sql": "SELECT organisation_details FROM Organisations AS T1 JOIN organisation_Types AS T2 ON T1.organisation_type  =  T2.organisation_type WHERE T2.organisation_type_description  =  'Sponsor' ORDER BY organisation_details", "source_tables": ["organisation_types", "organisations"], "pred_sql": "SELECT * FROM Organisations WHERE organisation_type = (SELECT organisation_type FROM Organisation_Types WHERE organisation_type_description = 'Sponsor') ORDER BY organisation_id ASC;", "hint": "\n"}
{"sample_id": "train.4380", "db_id": "tracking_grants_for_research", "question": "What are the result description of the project whose detail is 'sint'?", "rationale": ["Identify the relevant table: The question asks for project details, which are stored in the 'Projects' table.", "Determine the specific column: The 'project_details' column contains the descriptions of the projects.", "Formulate the SQL query: We need to select the 'project_id' and 'project_details' from the 'Projects' table where the 'project_details' match the specified value 'sint'."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code JOIN Projects AS T3 ON T2.project_id  =  T3.project_id WHERE T3.project_details  =  'sint'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "pred_sql": "SELECT project_id, project_details FROM Projects WHERE project_details = 'sint';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the project details from the 'Projects' table that have two specific outcomes. The query uses an INTERSECT operation to find projects that meet both outcome criteria, represented by placeholders for the outcome codes.\",\n    \"1\": \"This virtual table describes the project details from the 'Projects' table that have specific outcomes. It retrieves project details for projects that have two different specified outcome codes, ensuring that only projects meeting both criteria are included in the results. The placeholders in the WHERE clause represent the outcome codes being queried.\"\n}\n"}
{"sample_id": "train.4381", "db_id": "tracking_grants_for_research", "question": "What is the description for the results whose project detail is 'sint'?", "rationale": ["Identify the relevant tables: Projects, Project_Outcomes, and Research_Outcomes are needed to get project details and their associated outcomes.", "Determine the relationship between the tables: Projects is linked to Project_Outcomes through project_id, and Project_Outcomes is linked to Research_Outcomes through outcome_code.", "Formulate the SELECT statement: We need to select project_details from Projects and outcome_description from Research_Outcomes.", "Add the JOIN clauses to connect the tables based on their relationships.", "Include a WHERE clause to filter the results for projects with the specific detail 'sint'."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code JOIN Projects AS T3 ON T2.project_id  =  T3.project_id WHERE T3.project_details  =  'sint'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "pred_sql": "SELECT p.project_details, ro.outcome_description \nFROM Projects p \nJOIN Project_Outcomes po ON p.project_id = po.project_id \nJOIN Research_Outcomes ro ON po.outcome_code = ro.outcome_code \nWHERE p.project_details = 'sint';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the project details from the 'Projects' table that have two specific outcomes. The query uses an INTERSECT operation to find projects that meet both outcome criteria, represented by placeholders for the outcome codes.\",\n    \"1\": \"This virtual table describes the project details from the 'Projects' table that have specific outcomes. It retrieves project details for projects that have two different specified outcome codes, ensuring that only projects meeting both criteria are included in the results. The placeholders in the WHERE clause represent the outcome codes being queried.\",\n    \"2\": \"This virtual table provides a list of project details from the 'Projects' table for projects that do not have any associated staff members with a specific role. The placeholder in the WHERE clause represents the role code that is being filtered out.\"\n}\n"}
{"sample_id": "train.4383", "db_id": "tracking_grants_for_research", "question": "What is the id of the organization with the maximum number of outcomes and how many outcomes are there?", "rationale": ["We need to find the organization with the maximum number of outcomes.", "First, we will join the Project_Outcomes table with the Projects table using the project_id.", "Next, we will join the Projects table with the Organisations table using the organisation_id.", "We will then group the results by organisation_id and count the number of outcomes for each organization using COUNT(outcome_code).", "To find the organization with the maximum outcomes, we will order the results in descending order based on the count of outcomes.", "Finally, we will limit the results to 1 to get the organization with the maximum number of outcomes."], "gold_sql": "SELECT T1.organisation_id ,  count(*) FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "projects"], "pred_sql": "SELECT organisation_id, COUNT(outcome_code) AS outcome_count\nFROM Project_Outcomes\nJOIN Projects ON Project_Outcomes.project_id = Projects.project_id\nJOIN Organisations ON Projects.organisation_id = Organisations.organisation_id\nGROUP BY organisation_id\nORDER BY outcome_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.4384", "db_id": "tracking_grants_for_research", "question": "List the project details of the projects launched by the organisation", "rationale": ["Identify the relevant table: Projects contains the project details we need.", "Determine the relationship: Projects are linked to Organisations through organisation_id.", "We need to filter projects based on the organisation that launched them, which requires a subquery to find the organisation_id from the Organisations table.", "Construct the SQL query to select project_details from the Projects table where the organisation_id matches the one from the Organisations table."], "gold_sql": "SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT 1 )", "source_tables": ["projects"], "pred_sql": "SELECT project_details FROM Projects WHERE organisation_id = (SELECT organisation_id FROM Organisations WHERE organisation_id = ?)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n    \"1\": \"This virtual table provides a list of project details from the 'Projects' table for projects that do not have any associated staff members with a specific role. The placeholder in the WHERE clause represents the role code that is being filtered out.\",\n    \"2\": \"This virtual table provides a list of project details from the 'Projects' table for projects that do not have any associated staff members with a specific role. The placeholder in the WHERE clause represents the role code that is being filtered out.\"\n}\n"}
{"sample_id": "train.4392", "db_id": "tracking_grants_for_research", "question": "What are the staff roles of the staff who", "rationale": ["Identify the relevant tables: Project_Staff and Staff_Roles.", "We need to retrieve the role descriptions of staff members, which are stored in the Staff_Roles table.", "Join the Project_Staff table with the Staff_Roles table on the role_code to get the role descriptions.", "Filter the results to ensure we only include staff members who have valid start and end dates for their involvement in projects."], "gold_sql": "SELECT role_code FROM Project_Staff WHERE date_from  >  '2003-04-19 15:06:20' AND date_to  <  '2016-03-15 00:33:18'", "source_tables": ["project_staff"], "pred_sql": "SELECT sr.role_description \nFROM Project_Staff ps \nJOIN Staff_Roles sr ON ps.role_code = sr.role_code \nWHERE ps.date_from IS NOT NULL AND ps.date_to IS NOT NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\"\n}\n"}
{"sample_id": "train.4394", "db_id": "tracking_grants_for_research", "question": "What are the descriptions of all the project outcomes?", "rationale": ["The user wants to retrieve descriptions of all project outcomes, which are stored in the Project_Outcomes table.", "To get the descriptions, we need to select the relevant columns from the Project_Outcomes table, specifically 'outcome_code' and 'outcome_details'.", "The SQL query will be a simple SELECT statement that fetches these columns from the Project_Outcomes table."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code", "source_tables": ["project_outcomes", "research_outcomes"], "pred_sql": "SELECT outcome_code, outcome_details FROM Project_Outcomes;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the project details from the 'Projects' table that have specific outcomes. It retrieves project details for projects that have two different specified outcome codes, ensuring that only projects meeting both criteria are included in the results. The placeholders in the WHERE clause represent the outcome codes being queried.\",\n    \"1\": \"This virtual table describes the project details from the 'Projects' table that have two specific outcomes. The query uses an INTERSECT operation to find projects that meet both outcome criteria, represented by placeholders for the outcome codes.\",\n    \"2\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\"\n}\n"}
{"sample_id": "train.4397", "db_id": "tracking_grants_for_research", "question": "What is the most common role for the staff?", "rationale": ["To find the most common role for the staff, we need to count the occurrences of each role in the Project_Staff table.", "We will use the COUNT function to count the number of staff members for each role_code.", "We will group the results by role_code to aggregate the counts for each role.", "To determine the most common role, we will order the results in descending order based on the count of staff members.", "Finally, we will limit the results to 1 to get only the most common role."], "gold_sql": "SELECT role_code FROM Project_Staff GROUP BY role_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_staff"], "pred_sql": "SELECT role_code, COUNT(*) as role_count \nFROM Project_Staff \nGROUP BY role_code \nORDER BY role_count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\"\n}\n"}
{"sample_id": "train.4410", "db_id": "network_2", "question": "Who is the oldest person whose job is student?", "rationale": ["Identify the table to query: The relevant table is 'Person' as it contains information about individuals including their age and job.", "Filter the results: We need to filter the results to only include those whose job is 'student'.", "Sort the results: To find the oldest person, we will sort the results by age in descending order.", "Limit the results: Since we only want the oldest person, we will limit the results to 1."], "gold_sql": "SELECT name FROM Person WHERE job  =  'student' AND age  =  (SELECT max(age) FROM person WHERE job  =  'student' )", "source_tables": ["person"], "pred_sql": "SELECT name, age FROM Person WHERE job = 'student' ORDER BY age DESC LIMIT 1;", "hint": "\n"}
{"sample_id": "train.4439", "db_id": "network_2", "question": "What is the name and age of every male? Order the results by age.", "rationale": ["Identify the relevant table: The 'Person' table contains the information we need (name and age).", "Filter the results: We need to select only male individuals, so we add a WHERE clause to filter by gender.", "Select the required columns: We need to retrieve the 'name' and 'age' columns from the 'Person' table.", "Order the results: We need to order the results by age, so we add an ORDER BY clause for the 'age' column."], "gold_sql": "SELECT name FROM Person WHERE gender  =  'male' ORDER BY age", "source_tables": ["person"], "pred_sql": "SELECT name, age FROM Person WHERE gender = 'male' ORDER BY age;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n    \"1\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\"\n}\n"}
{"sample_id": "train.4441", "db_id": "network_2", "question": "What are the names and ages of every person who is a friend of both Dan and Alice?", "rationale": ["We need to find the names and ages of persons who are friends with both Dan and Alice.", "To achieve this, we will join the Person table with the PersonFriend table twice: once for Dan and once for Alice.", "The first join (PF1) will find friends of Dan, and the second join (PF2) will find friends of Alice.", "We will select the name and age from the Person table where the friend matches in both joins.", "The WHERE clause will filter the results to ensure that we only get friends of both Dan and Alice."], "gold_sql": "SELECT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Dan' INTERSECT SELECT T1.name ,   T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Alice'", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT P.name, P.age \nFROM Person P \nJOIN PersonFriend PF1 ON P.name = PF1.friend \nJOIN PersonFriend PF2 ON P.name = PF2.friend \nWHERE PF1.name = 'Dan' AND PF2.name = 'Alice';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names and ages of persons from the 'Person' table who have mutual friendships with a specific friend. The placeholders in the WHERE clause represent the names of the friends being queried.\",\n    \"1\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n    \"2\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\"\n}\n"}
{"sample_id": "train.4444", "db_id": "network_2", "question": "Find the name of the person who has friends with age above 40 and under age 30?", "rationale": ["We need to find the names of persons who have friends with specific age criteria: above 40 or under 30.", "To achieve this, we will join the 'Person' table with the 'PersonFriend' table to link persons with their friends.", "We will also join the 'Person' table again to access the age of the friends.", "The WHERE clause will filter friends based on the age conditions: greater than 40 or less than 30.", "Finally, we will use DISTINCT to ensure that we only get unique names of persons who meet the criteria."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  40) INTERSECT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  30)", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT DISTINCT P.name \nFROM Person P \nJOIN PersonFriend PF ON P.name = PF.name \nJOIN Person F ON PF.friend = F.name \nWHERE F.age > 40 OR F.age < 30;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n    \"1\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n    \"2\": \"This virtual table describes the names and ages of persons from the 'Person' table who have mutual friendships with a specific friend. The placeholders in the WHERE clause represent the names of the friends being queried.\"\n}\n"}
{"sample_id": "train.4445", "db_id": "network_2", "question": "What are the names of every person who has a friend over 40 and under 30?", "rationale": ["We need to find the names of persons who have friends that are either over 40 or under 30.", "To do this, we will join the 'Person' table with the 'PersonFriend' table to link persons with their friends.", "We will then join again with the 'Person' table to access the age of the friends.", "The WHERE clause will filter friends based on the age criteria: friends older than 40 or younger than 30.", "Finally, we will select distinct names to avoid duplicates."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  40) INTERSECT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  30)", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT DISTINCT p1.name \nFROM Person p1 \nJOIN PersonFriend pf1 ON p1.name = pf1.name \nJOIN Person p2 ON pf1.friend = p2.name \nWHERE p2.age > 40 OR p2.age < 30;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n    \"1\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n    \"2\": \"This virtual table describes the names and ages of persons from the 'Person' table who have mutual friendships with a specific friend. The placeholders in the WHERE clause represent the names of the friends being queried.\"\n}\n"}
{"sample_id": "train.4449", "db_id": "network_2", "question": "What are the names of the people who have no friends who are students?", "rationale": ["Identify the main requirement: we need the names of people who have no friends that are students.", "To find friends who are students, we can query the 'Person' table for names where the job is 'student'.", "Next, we need to find all names in the 'PersonFriend' table where the friend is in the list of students identified in the previous step.", "Finally, we select names from the 'Person' table that are not in the list of names from the 'PersonFriend' table that have friends who are students."], "gold_sql": "SELECT name FROM person EXCEPT SELECT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.job  =  'student'", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT name FROM Person WHERE name NOT IN (SELECT name FROM PersonFriend WHERE friend IN (SELECT name FROM Person WHERE job = 'student'));", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the names of individuals from the 'Person' table who do not have any friends that work in a specific occupation. The placeholder in the query allows for the specification of the job title to filter out those individuals accordingly.\",\n    \"1\": \"This virtual table describes the names and ages of persons from the 'Person' table who have mutual friendships with a specific friend. The placeholders in the WHERE clause represent the names of the friends being queried.\"\n}\n"}
{"sample_id": "train.4454", "db_id": "network_2", "question": "Find the name of persons who are friends with Bob.", "rationale": ["Identify the main goal: to find the names of persons who are friends with Bob.", "Understand the relationship between the tables: 'Person' contains personal details, while 'PersonFriend' contains friendship details.", "Use a JOIN operation to connect 'Person' and 'PersonFriend' based on the name of the person.", "Filter the results to include only those records where the friend is 'Bob'.", "Select the distinct names from the resulting dataset to avoid duplicates."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Bob'", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT DISTINCT P.name \nFROM Person P \nJOIN PersonFriend PF ON P.name = PF.name \nWHERE PF.friend = 'Bob';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names and ages of persons from the 'Person' table who have mutual friendships with a specific friend. The placeholders in the WHERE clause represent the names of the friends being queried.\",\n    \"1\": \"This virtual table provides the names, ages, and job titles of individuals from the 'Person' table who have a specific friend, along with the most recent year the friendship was established. The placeholders in the WHERE clause represent the friend's name.\",\n    \"2\": \"This virtual table provides a distinct list of names and ages of individuals from the 'Person' table who have specific friends listed in the 'PersonFriend' table. The placeholders in the WHERE clause represent the names of the friends being queried.\"\n}\n"}
{"sample_id": "train.4455", "db_id": "network_2", "question": "What are the names of all of Bob's friends?", "rationale": ["Identify the table that contains friendship information, which is 'PersonFriend'.", "Determine that we need to find friends of a specific person, in this case, 'Bob'.", "Construct a SQL query that selects the 'friend' column from the 'PersonFriend' table where the 'name' column matches 'Bob'."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Bob'", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT friend FROM PersonFriend WHERE name = 'Bob';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names and ages of persons from the 'Person' table who have mutual friendships with a specific friend. The placeholders in the WHERE clause represent the names of the friends being queried.\",\n    \"1\": \"This virtual table provides the names, ages, and job titles of individuals from the 'Person' table who have a specific friend, along with the most recent year the friendship was established. The placeholders in the WHERE clause represent the friend's name.\",\n    \"2\": \"This virtual table provides a distinct list of names and ages of individuals from the 'Person' table who have specific friends listed in the 'PersonFriend' table. The placeholders in the WHERE clause represent the names of the friends being queried.\"\n}\n"}
{"sample_id": "train.4456", "db_id": "network_2", "question": "Find the names of females who are friends with Zach", "rationale": ["Identify the relevant tables: 'Person' for personal details and 'PersonFriend' for friendship details.", "We need to find females who are friends with Zach, so we will join the 'Person' table with the 'PersonFriend' table on the name column.", "In the WHERE clause, we specify that the friend must be 'Zach' and the gender must be 'female'.", "Select the name of the individuals who meet these criteria."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Zach' AND T1.gender  =  'female'", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT P.name \nFROM Person P \nJOIN PersonFriend PF ON P.name = PF.name \nWHERE PF.friend = 'Zach' AND P.gender = 'female';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names and ages of persons from the 'Person' table who have mutual friendships with a specific friend. The placeholders in the WHERE clause represent the names of the friends being queried.\",\n    \"1\": \"This virtual table provides the names, ages, and job titles of individuals from the 'Person' table who have a specific friend, along with the most recent year the friendship was established. The placeholders in the WHERE clause represent the friend's name.\",\n    \"2\": \"This virtual table provides a distinct list of names and ages of individuals from the 'Person' table who have specific friends listed in the 'PersonFriend' table. The placeholders in the WHERE clause represent the names of the friends being queried.\"\n}\n"}
{"sample_id": "train.4465", "db_id": "network_2", "question": "What are the different names of friends who are younger than the average age for a friend?", "rationale": ["Identify the need to find friends who are younger than the average age.", "Use the PersonFriend table to access the friends of individuals.", "Join the Person table to get the ages of these friends.", "Calculate the average age from the Person table using a subquery.", "Filter the friends based on the condition that their age is less than the calculated average age.", "Select distinct names of friends to avoid duplicates."], "gold_sql": "SELECT DISTINCT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.age  <  (SELECT avg(age) FROM person)", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT DISTINCT pf.friend\nFROM PersonFriend pf\nJOIN Person p ON pf.friend = p.name\nWHERE p.age < (SELECT AVG(age) FROM Person)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n    \"1\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n    \"2\": \"This virtual table describes the names and ages of persons from the 'Person' table who have mutual friendships with a specific friend. The placeholders in the WHERE clause represent the names of the friends being queried.\"\n}\n"}
{"sample_id": "train.4466", "db_id": "network_2", "question": "Who has friends that are older than the average age? Print their friends and their ages as well", "rationale": ["Identify the need to find friends who are older than the average age.", "Calculate the average age from the Person table using AVG(age).", "Join the PersonFriend table with the Person table to access the ages of friends.", "Filter the results to include only those friends whose age is greater than the calculated average age."], "gold_sql": "SELECT DISTINCT T2.name ,  T2.friend ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.age  >  (SELECT avg(age) FROM person)", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT pf.friend, p.age \nFROM PersonFriend pf \nJOIN Person p ON pf.friend = p.name \nWHERE p.age > (SELECT AVG(age) FROM Person);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n    \"1\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n    \"2\": \"This virtual table describes the names and ages of persons from the 'Person' table who have mutual friendships with a specific friend. The placeholders in the WHERE clause represent the names of the friends being queried.\"\n}\n"}
{"sample_id": "train.4467", "db_id": "network_2", "question": "Whare the names, friends, and ages of all people who are older than the average age of a person?", "rationale": ["Identify the required fields: names, friends, and ages of people.", "We need to join the 'Person' table with the 'PersonFriend' table to get the friends of each person.", "The condition specifies that we want people who are older than the average age.", "To find the average age, we can use a subquery that calculates the average from the 'Person' table.", "The final SQL query selects the name, friend, and age from the joined tables where the age is greater than the average age."], "gold_sql": "SELECT DISTINCT T2.name ,  T2.friend ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.age  >  (SELECT avg(age) FROM person)", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT p.name, pf.friend, p.age \nFROM Person p \nJOIN PersonFriend pf ON p.name = pf.name \nWHERE p.age > (SELECT AVG(age) FROM Person);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n    \"1\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n    \"2\": \"This virtual table describes the names and ages of persons from the 'Person' table who have mutual friendships with a specific friend. The placeholders in the WHERE clause represent the names of the friends being queried.\"\n}\n"}
{"sample_id": "train.4473", "db_id": "network_2", "question": "What are the names of all people who are friends with Alice for the shortest amount of time?", "rationale": ["Identify the table that contains friendship information, which is 'PersonFriend'.", "We need to find friends of 'Alice', so we will filter the 'PersonFriend' table where the 'name' column is 'Alice'.", "To find the friends with the shortest friendship duration, we will order the results by the 'year' column in ascending order.", "Finally, we will limit the results to only one friend, as we are interested in the friend with the shortest amount of time."], "gold_sql": "SELECT name FROM PersonFriend WHERE friend =  'Alice' AND YEAR  =  (SELECT min(YEAR) FROM PersonFriend WHERE friend =  'Alice')", "source_tables": ["personfriend"], "pred_sql": "SELECT friend FROM PersonFriend WHERE name = 'Alice' ORDER BY year ASC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names and ages of persons from the 'Person' table who have mutual friendships with a specific friend. The placeholders in the WHERE clause represent the names of the friends being queried.\",\n    \"1\": \"This virtual table provides the names, ages, and job titles of individuals from the 'Person' table who have a specific friend, along with the most recent year the friendship was established. The placeholders in the WHERE clause represent the friend's name.\",\n    \"2\": \"This virtual table provides a distinct list of names and ages of individuals from the 'Person' table who have specific friends listed in the 'PersonFriend' table. The placeholders in the WHERE clause represent the names of the friends being queried.\"\n}\n"}
{"sample_id": "train.4475", "db_id": "network_2", "question": "What are the names, ages, and jobs of all people who are friends with Alice for the longest amount of time?", "rationale": ["Identify the required information: names, ages, and jobs of people who are friends with Alice.", "Use the Person table to get the names, ages, and jobs.", "Join the Person table with the PersonFriend table on the name column to find friends of Alice.", "Filter the results to only include those who are friends with Alice by using a WHERE clause.", "To find the friends who have been friends with Alice for the longest time, order the results by the year the friendship was established in ascending order.", "Limit the results to the top entry to get the friend with the longest friendship."], "gold_sql": "SELECT T1.name ,  T1.age ,  T1.job FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend =  'Alice' AND T2.year  =  (SELECT max(YEAR) FROM PersonFriend WHERE friend =  'Alice')", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT P.name, P.age, P.job \nFROM Person P \nJOIN PersonFriend PF ON P.name = PF.name \nWHERE PF.friend = 'Alice' \nORDER BY PF.year ASC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names, ages, and job titles of individuals from the 'Person' table who have a specific friend, along with the most recent year the friendship was established. The placeholders in the WHERE clause represent the friend's name.\",\n    \"1\": \"This virtual table describes the names and ages of persons from the 'Person' table who have mutual friendships with a specific friend. The placeholders in the WHERE clause represent the names of the friends being queried.\",\n    \"2\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\"\n}\n"}
{"sample_id": "train.4478", "db_id": "network_2", "question": "Which person whose friends have the oldest average age?", "rationale": ["Identify the main goal: Find the person whose friends have the oldest average age.", "To achieve this, we need to calculate the average age of friends for each person.", "Join the 'PersonFriend' table with the 'Person' table to get the ages of friends.", "Group the results by the person's name to calculate the average age of their friends.", "Order the results by the average age in descending order to find the oldest average age.", "Limit the results to 1 to get the person with the oldest average age of friends."], "gold_sql": "SELECT T2.name ,  avg(T1.age) FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend GROUP BY T2.name ORDER BY avg(T1.age) DESC LIMIT 1", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT p.name\nFROM Person p\nJOIN (\n    SELECT pf.name, AVG(CAST(p.age AS INTEGER)) AS avg_age\n    FROM PersonFriend pf\n    JOIN Person p ON pf.friend = p.name\n    GROUP BY pf.name\n) AS avg_ages ON p.name = avg_ages.name\nORDER BY avg_ages.avg_age DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n    \"1\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n    \"2\": \"This virtual table provides the names, ages, and job titles of individuals from the 'Person' table who have a specific friend, along with the most recent year the friendship was established. The placeholders in the WHERE clause represent the friend's name.\"\n}\n"}
{"sample_id": "train.4480", "db_id": "network_2", "question": "What is the total number of people who has no friend living in the city of Austin.", "rationale": ["We need to count the total number of people who have no friends living in Austin.", "To achieve this, we will use a LEFT JOIN to connect the Person table with the PersonFriend table to find all friends of each person.", "We will also LEFT JOIN the Person table again to get the city of each friend.", "We will filter the results to include only those persons whose friends either do not exist (NULL) or do not live in Austin.", "Finally, we will use COUNT(DISTINCT p.name) to count the unique persons who meet the criteria."], "gold_sql": "SELECT count(DISTINCT name) FROM PersonFriend WHERE friend NOT IN (SELECT name FROM person WHERE city  =  'Austin')", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT COUNT(DISTINCT p.name) AS total_no_friends\nFROM Person p\nLEFT JOIN PersonFriend pf ON p.name = pf.name\nLEFT JOIN Person pf_friends ON pf.friend = pf_friends.name\nWHERE pf_friends.city IS NULL OR pf_friends.city != 'Austin';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the number of distinct persons from the 'PersonFriend' table who have friends that do not reside in a specified city. The placeholder in the WHERE clause represents the name of the city to filter out friends.\",\n    \"1\": \"This virtual table identifies the names of individuals from the 'Person' table who do not have any friends that work in a specific occupation. The placeholder in the query allows for the specification of the job title to filter out those individuals accordingly.\",\n    \"2\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\"\n}\n"}
{"sample_id": "train.4503", "db_id": "document_management", "question": "Find the types of documents with more than 4 documents.", "rationale": ["Identify the table that contains the document types, which is the 'Documents' table.", "We need to count the number of documents for each type, so we will use the COUNT() function.", "To group the results by document type, we will use the GROUP BY clause on 'document_type_code'.", "We want to filter the results to only include document types that have more than 4 documents, so we will use the HAVING clause with COUNT(*) > 4."], "gold_sql": "SELECT document_type_code FROM documents GROUP BY document_type_code HAVING count(*)  >  4", "source_tables": ["documents"], "pred_sql": "SELECT document_type_code, COUNT(*) as document_count \nFROM Documents \nGROUP BY document_type_code \nHAVING COUNT(*) > 4;", "hint": "\n"}
{"sample_id": "train.4504", "db_id": "document_management", "question": "What are the codes of types of documents of which there are for or more?", "rationale": ["Identify the table that contains the document types, which is the 'Documents' table.", "We need to select the 'document_type_code' from the 'Documents' table.", "To find the document types that have four or more documents, we will group the results by 'document_type_code'.", "We will use the HAVING clause to filter the groups to only include those with a count of 'document_code' that is 4 or more."], "gold_sql": "SELECT document_type_code FROM documents GROUP BY document_type_code HAVING count(*)  >  4", "source_tables": ["documents"], "pred_sql": "SELECT document_type_code\nFROM Documents\nGROUP BY document_type_code\nHAVING COUNT(document_code) >= 4;", "hint": "\n"}
{"sample_id": "train.4505", "db_id": "document_management", "question": "Find the total access count of all documents in the most popular document type.", "rationale": ["We need to find the total access count of all documents in the most popular document type.", "First, we need to identify the most popular document type. This can be done by grouping the documents by their document_type_code and summing their access counts.", "We will order the results by the summed access count in descending order to get the most popular document type at the top.", "To get only the most popular document type, we will limit the results to 1.", "Once we have the most popular document type, we can then sum the access counts of all documents that match this type."], "gold_sql": "SELECT sum(access_count) FROM documents GROUP BY document_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["documents"], "pred_sql": "SELECT SUM(access_count) AS total_access_count\nFROM Documents\nWHERE document_type_code = (\n    SELECT document_type_code\n    FROM Documents\n    GROUP BY document_type_code\n    ORDER BY SUM(access_count) DESC\n    LIMIT 1\n);", "hint": "\n"}
{"sample_id": "train.4525", "db_id": "document_management", "question": "Find names of the document without any images.", "rationale": ["We need to find documents that do not have any associated images.", "To do this, we will use a LEFT JOIN to connect the Documents table with the Document_Sections table, as each document can have multiple sections.", "Next, we will perform another LEFT JOIN with the Document_Sections_Images table to check for images associated with those sections.", "In the WHERE clause, we will filter for cases where the image_id from Document_Sections_Images is NULL, indicating that there are no images associated with the document's sections."], "gold_sql": "SELECT document_name FROM documents EXCEPT SELECT t1.document_name FROM documents AS t1 JOIN document_sections AS t2 ON t1.document_code  =  t2.document_code JOIN document_sections_images AS t3 ON t2.section_id  =  t3.section_id", "source_tables": ["document_sections", "document_sections_images", "documents"], "pred_sql": "SELECT d.document_name \nFROM Documents d \nLEFT JOIN Document_Sections ds ON d.document_code = ds.document_code \nLEFT JOIN Document_Sections_Images dsi ON ds.section_id = dsi.section_id \nWHERE dsi.image_id IS NULL;", "hint": "\n"}
{"sample_id": "train.4532", "db_id": "document_management", "question": "Count the number of users that are logged in.", "rationale": ["The task is to count the number of users that are logged in.", "To achieve this, we need to select the count of unique user IDs from the Users table.", "The SQL function COUNT() will be used to count the number of user_id entries in the Users table, which represents the logged-in users."], "gold_sql": "SELECT count(*) FROM users WHERE user_login  =  1", "source_tables": ["users"], "pred_sql": "SELECT COUNT(user_id) AS logged_in_users FROM Users;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of user names and their corresponding passwords from the 'Users' table, grouped by their role codes. The results are ordered by the number of users in each role, showing the top roles based on user count, with a limit specified by a placeholder for numeric values.\",\n    \"1\": \"This virtual table provides a list of user names and their corresponding passwords from the 'Users' table, grouped by their role codes. The results are ordered by the number of users in each role, showing the most populated roles first, with a limit on the number of results returned as specified by the placeholder.\"\n}\n"}
{"sample_id": "train.4733", "db_id": "department_store", "question": "Return the distinct name of customers whose order status is Pending, in the order of customer id.", "rationale": ["Identify the relevant tables: Customers and Customer_Orders are needed to get customer names and their order statuses.", "Use a JOIN to connect Customers and Customer_Orders on the customer_id field, as this is the common identifier between the two tables.", "Filter the results to include only those orders with a status of 'Pending' using a WHERE clause.", "Select distinct customer names to avoid duplicates in the results.", "Order the final results by customer_id to meet the requirement of ordering the output."], "gold_sql": "SELECT DISTINCT T1.customer_name FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  'Pending' ORDER BY T2.customer_id", "source_tables": ["customer_orders", "customers"], "pred_sql": "SELECT DISTINCT c.customer_name \nFROM Customers c \nJOIN Customer_Orders co ON c.customer_id = co.customer_id \nWHERE co.order_status_code = 'Pending' \nORDER BY c.customer_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names and addresses of customers who have placed orders with a specific status. The query retrieves customer information from the 'Customers' table and filters it based on the order status from the 'Customer_Orders' table. The placeholders in the WHERE clause represent the order status codes that can be specified by the user.\",\n    \"1\": \"This virtual table describes the unique identifiers and names of customers from the 'Customers' table who have a specific address pattern and do not use a certain payment method. The placeholders in the WHERE clause represent the address pattern and the payment method code.\"\n}\n"}
{"sample_id": "train.4736", "db_id": "department_store", "question": "What are the names and addressed of customers who have both New and Pending orders?", "rationale": ["Identify the relevant tables: Customers and Customer_Orders.", "We need to retrieve customer names and addresses, so we will select 'customer_name' and 'customer_address' from the Customers table.", "To find customers with both 'New' and 'Pending' orders, we will join the Customers table with the Customer_Orders table on 'customer_id'.", "We will filter the results based on the 'order_status_code' to include only 'New' and 'Pending' statuses.", "To ensure we only get customers with both statuses, we will group the results by 'customer_id' and use the HAVING clause to count distinct order statuses, ensuring it equals 2."], "gold_sql": "SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  'New' INTERSECT SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  'Pending'", "source_tables": ["customer_orders", "customers"], "pred_sql": "SELECT DISTINCT c.customer_name, c.customer_address \nFROM Customers c \nJOIN Customer_Orders co ON c.customer_id = co.customer_id \nWHERE co.order_status_code IN ('New', 'Pending') \nGROUP BY c.customer_id \nHAVING COUNT(DISTINCT co.order_status_code) = 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names and addresses of customers who have placed orders with a specific status. The query retrieves customer information from the 'Customers' table and filters it based on the order status from the 'Customer_Orders' table. The placeholders in the WHERE clause represent the order status codes that can be specified by the user.\",\n    \"1\": \"This virtual table describes the unique identifiers and names of customers from the 'Customers' table who have a specific address pattern and do not use a certain payment method. The placeholders in the WHERE clause represent the address pattern and the payment method code.\"\n}\n"}
{"sample_id": "train.4749", "db_id": "department_store", "question": "Find the id and name of the staff who has been assigned for the shortest period.", "rationale": ["Identify the relevant table: Staff_Department_Assignments contains the staff assignments and their duration.", "To find the shortest assignment period, calculate the difference between date_assigned_to and date_assigned_from.", "Sort the results by the calculated duration in ascending order to get the shortest period first.", "Select the staff_id and staff_name from the sorted results.", "Limit the output to 1 to get only the staff with the shortest assignment period."], "gold_sql": "SELECT T1.staff_id ,  T1.staff_name FROM staff AS T1 JOIN Staff_Department_Assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY date_assigned_to - date_assigned_from LIMIT 1", "source_tables": ["staff_department_assignments", "staff"], "pred_sql": "SELECT staff_id, staff_name\nFROM Staff_Department_Assignments\nORDER BY (date_assigned_to - date_assigned_from) ASC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.4750", "db_id": "department_store", "question": "What is the id and name of the staff who has been assigned for the least amount of time?", "rationale": ["Identify the relevant table: Staff_Department_Assignments contains the assignment details of staff members.", "Select the columns needed: staff_id and staff_name from the Staff table.", "Order the results by the date_assigned_from column to find the staff member assigned for the least amount of time.", "Limit the results to 1 to get only the staff member with the earliest assignment date."], "gold_sql": "SELECT T1.staff_id ,  T1.staff_name FROM staff AS T1 JOIN Staff_Department_Assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY date_assigned_to - date_assigned_from LIMIT 1", "source_tables": ["staff_department_assignments", "staff"], "pred_sql": "SELECT staff_id, staff_name \nFROM Staff_Department_Assignments \nORDER BY date_assigned_from ASC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.4753", "db_id": "department_store", "question": "Find the ids of all distinct customers who made order after some orders that were Cancelled.", "rationale": ["Identify the Customers table to get customer IDs.", "Join the Customer_Orders table to link customers with their orders.", "Filter the orders to find those that have a status of 'Cancelled'.", "Use a subquery to find the order IDs of cancelled orders.", "Ensure that we only select customers who made orders after the cancelled ones by comparing order dates."], "gold_sql": "SELECT DISTINCT customer_id FROM Customer_Orders WHERE order_date  >  (SELECT min(order_date) FROM Customer_Orders WHERE order_status_code  =  'Cancelled')", "source_tables": ["customer_orders"], "pred_sql": "SELECT DISTINCT c.customer_id \nFROM Customers c \nJOIN Customer_Orders co ON c.customer_id = co.customer_id \nWHERE co.order_id IN (\n    SELECT co2.order_id \n    FROM Customer_Orders co2 \n    WHERE co2.order_status_code = 'Cancelled'\n) \nAND co.order_date > (\n    SELECT MAX(co3.order_date) \n    FROM Customer_Orders co3 \n    WHERE co3.order_status_code = 'Cancelled'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names and addresses of customers who have placed orders with a specific status. The query retrieves customer information from the 'Customers' table and filters it based on the order status from the 'Customer_Orders' table. The placeholders in the WHERE clause represent the order status codes that can be specified by the user.\",\n    \"1\": \"This virtual table describes the unique identifiers and names of customers from the 'Customers' table who have a specific address pattern and do not use a certain payment method. The placeholders in the WHERE clause represent the address pattern and the payment method code.\"\n}\n"}
{"sample_id": "train.4755", "db_id": "department_store", "question": "What is id of the staff who had a Staff Department Assignment earlier than any Clerical Staff?", "rationale": ["Identify the relevant table: Staff_Department_Assignments contains the staff assignments and their dates.", "Determine the condition: We need to find staff who were assigned to a department earlier than any Clerical Staff.", "Use a subquery to find the earliest assignment date of Clerical Staff: SELECT MIN(date_assigned_from) FROM Staff_Department_Assignments WHERE job_title_code = 'Clerical'.", "Construct the main query to select staff_id from Staff_Department_Assignments where their date_assigned_from is less than the result of the subquery."], "gold_sql": "SELECT staff_id FROM Staff_Department_Assignments WHERE date_assigned_to  <  (SELECT max(date_assigned_to) FROM Staff_Department_Assignments WHERE job_title_code  =  'Clerical Staff')", "source_tables": ["staff_department_assignments"], "pred_sql": "SELECT staff_id FROM Staff_Department_Assignments WHERE date_assigned_from < (SELECT MIN(date_assigned_from) FROM Staff_Department_Assignments WHERE job_title_code = 'Clerical')", "hint": "\n"}
{"sample_id": "train.4758", "db_id": "department_store", "question": "Return the names and ids of customers who have TN in their address.", "rationale": ["Identify the relevant table: Customers, which contains customer information including their addresses.", "Determine the columns needed: customer_id and customer_name are required as per the query.", "Use the WHERE clause to filter customers based on their address. The condition is that the address should contain 'TN'.", "Utilize the LIKE operator with wildcards to match any address that includes 'TN'.", "Construct the SQL query to select the specified columns from the Customers table with the appropriate filtering condition."], "gold_sql": "SELECT customer_name ,  customer_id FROM customers WHERE customer_address LIKE '%TN%'", "source_tables": ["customers"], "pred_sql": "SELECT customer_id, customer_name FROM Customers WHERE customer_address LIKE '%TN%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the unique identifiers and names of customers from the 'Customers' table who have a specific address pattern and do not use a certain payment method. The placeholders in the WHERE clause represent the address pattern and the payment method code.\",\n    \"1\": \"This virtual table describes the names and addresses of customers who have placed orders with a specific status. The query retrieves customer information from the 'Customers' table and filters it based on the order status from the 'Customer_Orders' table. The placeholders in the WHERE clause represent the order status codes that can be specified by the user.\"\n}\n"}
{"sample_id": "train.4760", "db_id": "department_store", "question": "What are the names and genders of staff who were assigned in 2016?", "rationale": ["Identify the relevant tables: Staff and Staff_Department_Assignments.", "We need to retrieve staff names and genders, so we will select staff_name and staff_gender from the Staff table.", "To find out which staff were assigned in 2016, we need to join the Staff table with the Staff_Department_Assignments table on staff_id.", "We will filter the results based on the date_assigned_from and date_assigned_to columns to ensure they fall within the year 2016."], "gold_sql": "SELECT T1.staff_name ,  T1.staff_gender FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.date_assigned_from LIKE '2016%'", "source_tables": ["staff_department_assignments", "staff"], "pred_sql": "SELECT staff_name, staff_gender \nFROM Staff \nJOIN Staff_Department_Assignments ON Staff.staff_id = Staff_Department_Assignments.staff_id \nWHERE date_assigned_from >= '2016-01-01' AND date_assigned_to <= '2016-12-31';", "hint": "\n"}
{"sample_id": "train.4762", "db_id": "department_store", "question": "What are the names of staff who have been assigned multiple jobs?", "rationale": ["Identify the relevant tables: Staff and Staff_Department_Assignments.", "We need to find staff members who have been assigned multiple jobs, which implies looking for multiple entries in the Staff_Department_Assignments table for the same staff member.", "Join the Staff table with the Staff_Department_Assignments table on staff_id to get the names of the staff along with their job assignments.", "Group the results by staff_id to aggregate the job assignments for each staff member.", "Use the HAVING clause to filter the groups where the count of distinct job_title_code is greater than 1, indicating multiple job assignments."], "gold_sql": "SELECT T1.staff_name FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id GROUP BY T2.staff_id HAVING COUNT (*)  >  1", "source_tables": ["staff_department_assignments", "staff"], "pred_sql": "SELECT staff_name\nFROM Staff\nJOIN Staff_Department_Assignments ON Staff.staff_id = Staff_Department_Assignments.staff_id\nGROUP BY Staff.staff_id\nHAVING COUNT(DISTINCT job_title_code) > 1;", "hint": "\n"}
{"sample_id": "train.4792", "db_id": "department_store", "question": "What are the ids and names of customers with addressed that contain WY and who do not use a credit card for payment?", "rationale": ["Identify the relevant table: Customers, which contains customer_id, customer_name, customer_address, and payment_method_code.", "Filter customers based on the address containing 'WY'. This is done using the LIKE operator with wildcards: '%WY%'.", "Exclude customers who use a credit card for payment by adding a condition to the WHERE clause: payment_method_code != 'CREDIT_CARD'.", "Select the required fields: customer_id and customer_name from the Customers table."], "gold_sql": "SELECT customer_id ,  customer_name FROM customers WHERE customer_address LIKE '%WY%' AND payment_method_code != 'Credit Card'", "source_tables": ["customers"], "pred_sql": "SELECT customer_id, customer_name \nFROM Customers \nWHERE customer_address LIKE '%WY%' \nAND payment_method_code != 'CREDIT_CARD';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the unique identifiers and names of customers from the 'Customers' table who have a specific address pattern and do not use a certain payment method. The placeholders in the WHERE clause represent the address pattern and the payment method code.\",\n    \"1\": \"This virtual table describes the names and addresses of customers who have placed orders with a specific status. The query retrieves customer information from the 'Customers' table and filters it based on the order status from the 'Customer_Orders' table. The placeholders in the WHERE clause represent the order status codes that can be specified by the user.\"\n}\n"}
{"sample_id": "train.4793", "db_id": "department_store", "question": "Find the average price of all product clothes.", "rationale": ["Identify the table that contains product information, which is the 'Products' table.", "Determine the relevant column for price, which is 'product_price'.", "To find the average price, use the AVG() function.", "Filter the products to only include those that are classified as 'clothes' using the 'product_type_code' column."], "gold_sql": "SELECT avg(product_price) FROM products WHERE product_type_code  =  'Clothes'", "source_tables": ["products"], "pred_sql": "SELECT AVG(product_price) AS average_price\nFROM Products\nWHERE product_type_code = 'clothes';", "hint": "\n"}
{"sample_id": "train.4795", "db_id": "department_store", "question": "Find the name of the most expensive hardware product.", "rationale": ["Identify the relevant table: Products, which contains product details including name and price.", "Filter the products to only include those of type 'hardware' using the product_type_code column.", "Sort the filtered products by product_price in descending order to get the most expensive product at the top.", "Limit the results to 1 to get only the most expensive hardware product."], "gold_sql": "SELECT product_name FROM products WHERE product_type_code  =  'Hardware' ORDER BY product_price DESC LIMIT 1", "source_tables": ["products"], "pred_sql": "SELECT product_name FROM Products WHERE product_type_code = 'hardware' ORDER BY product_price DESC LIMIT 1;", "hint": "\n"}
{"sample_id": "train.4902", "db_id": "store_product", "question": "Find the list of page size which have more than 3 product listed", "rationale": ["Identify the relevant table: The 'product' table contains the 'max_page_size' and 'product_id' columns.", "Group the results by 'max_page_size' to aggregate products with the same page size.", "Use the COUNT function to count the number of products for each 'max_page_size'.", "Apply the HAVING clause to filter groups where the count of products is greater than 3."], "gold_sql": "SELECT max_page_size FROM product GROUP BY max_page_size HAVING count(*)  >  3", "source_tables": ["product"], "pred_sql": "SELECT max_page_size FROM product GROUP BY max_page_size HAVING COUNT(product_id) > 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names or descriptions of products from the 'product' table that do not have the most common maximum page size. The placeholder in the subquery represents a numeric value used to limit the results of the maximum page size.\"\n}\n"}
{"sample_id": "train.4903", "db_id": "store_product", "question": "What is the maximum page size for everything that has more than 3 products listed?", "rationale": ["Identify the relevant tables: product, store_product, and store.", "We need to find the maximum page size for products that are listed in stores with more than 3 products.", "Join the product table with the store_product table to link products to stores.", "Join the store_product table with the store table to access store information.", "Group the results by store to count the number of products per store.", "Use the HAVING clause to filter stores that have more than 3 products listed.", "Select the maximum page size from the product table for the filtered stores."], "gold_sql": "SELECT max_page_size FROM product GROUP BY max_page_size HAVING count(*)  >  3", "source_tables": ["product"], "pred_sql": "SELECT MAX(p.max_page_size) \nFROM product p \nJOIN store_product sp ON p.product_id = sp.Product_ID \nJOIN store s ON sp.Store_ID = s.Store_ID \nGROUP BY s.Store_ID \nHAVING COUNT(sp.Product_ID) > 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names or descriptions of products from the 'product' table that do not have the most common maximum page size. The placeholder in the subquery represents a numeric value used to limit the results of the maximum page size.\"\n}\n"}
{"sample_id": "train.4913", "db_id": "store_product", "question": "What is the total number of residents for the districts with the 3 largest areas?", "rationale": ["Identify the requirement to find the total number of residents in districts with the largest areas.", "The relevant table for this information is the 'district' table, which contains 'City_Population' and 'City_Area'.", "To find the districts with the largest areas, I will order the districts by 'City_Area' in descending order and limit the results to the top 3 districts.", "Using a subquery, I will select the 'District_ID' of these top 3 districts.", "Finally, I will sum the 'City_Population' for these selected districts to get the total number of residents."], "gold_sql": "SELECT sum(city_population) FROM district ORDER BY city_area DESC LIMIT 3", "source_tables": ["district"], "pred_sql": "SELECT SUM(City_Population) AS Total_Residents\nFROM district\nWHERE District_ID IN (\n    SELECT District_ID\n    FROM district\n    ORDER BY City_Area DESC\n    LIMIT 3\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the names of districts that have stores of a specific type, intersecting the results for two different types of stores. The placeholders in the WHERE clause represent the types of stores being queried.\"\n}\n"}
{"sample_id": "train.4917", "db_id": "store_product", "question": "What are the names of all the stores located in Khanewal District?", "rationale": ["Identify the relevant tables: store, store_district, and district are needed to find store names based on district.", "Join the store table with the store_district table on Store_ID to link stores with their respective districts.", "Join the resulting table with the district table on District_ID to access district names.", "Filter the results where the district name is 'Khanewal' to get only the stores located in that district."], "gold_sql": "SELECT t1.store_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t3.district_name  =  'Khanewal District'", "source_tables": ["store_district", "store", "district"], "pred_sql": "SELECT store.Store_Name \nFROM store \nJOIN store_district ON store.Store_ID = store_district.Store_ID \nJOIN district ON store_district.District_ID = district.District_ID \nWHERE district.District_name = 'Khanewal';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the names of districts that have stores of a specific type, intersecting the results for two different types of stores. The placeholders in the WHERE clause represent the types of stores being queried.\",\n    \"1\": \"This virtual table identifies the names of districts that have stores of a specific type, ensuring that only districts with stores of the same type are returned. The placeholders in the WHERE clause represent the type of store being queried.\"\n}\n"}
{"sample_id": "train.4924", "db_id": "store_product", "question": "Find the city with the most number of stores.", "rationale": ["To find the city with the most number of stores, we need to join the store, store_district, and district tables.", "We will join the store table with the store_district table on Store_ID to get the districts associated with each store.", "Next, we will join the resulting table with the district table on District_ID to get the city names.", "We will then group the results by the Headquartered_City to count the number of stores in each city.", "Finally, we will order the results in descending order based on the count of stores and limit the result to 1 to get the city with the most stores."], "gold_sql": "SELECT t3.headquartered_city FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id GROUP BY t3.headquartered_city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["store_district", "store", "district"], "pred_sql": "SELECT d.Headquartered_City, COUNT(s.Store_ID) AS Number_of_Stores\nFROM store s\nJOIN store_district sd ON s.Store_ID = sd.Store_ID\nJOIN district d ON sd.District_ID = d.District_ID\nGROUP BY d.Headquartered_City\nORDER BY Number_of_Stores DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the names of districts that have stores of a specific type, intersecting the results for two different types of stores. The placeholders in the WHERE clause represent the types of stores being queried.\",\n    \"1\": \"This virtual table identifies the names of districts that have stores of a specific type, ensuring that only districts with stores of the same type are returned. The placeholders in the WHERE clause represent the type of store being queried.\"\n}\n"}
{"sample_id": "train.4930", "db_id": "store_product", "question": "Find products with max page size as \"A4\" and pages per minute color smaller than 5.", "rationale": ["Identify the relevant table: The 'product' table contains the necessary columns for the query.", "Determine the conditions: We need to filter products based on 'max_page_size' being 'A4' and 'pages_per_minute_color' being less than 5.", "Construct the SQL SELECT statement: We will select all relevant columns from the 'product' table.", "Add the WHERE clause to filter results based on the specified conditions."], "gold_sql": "SELECT product FROM product WHERE max_page_size  =  'A4' AND pages_per_minute_color  <  5", "source_tables": ["product"], "pred_sql": "SELECT product.product_id, product.product, product.dimensions, product.dpi, product.pages_per_minute_color, product.max_page_size, product.interface \nFROM product \nWHERE product.max_page_size = 'A4' \nAND product.pages_per_minute_color < '5';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names or descriptions of products from the 'product' table that do not have the most common maximum page size. The placeholder in the subquery represents a numeric value used to limit the results of the maximum page size.\"\n}\n"}
{"sample_id": "train.4932", "db_id": "store_product", "question": "Find products with max page size as \"A4\" or pages per minute color smaller than 5.", "rationale": ["Identify the relevant table: The 'product' table contains the columns needed for the query.", "Determine the conditions: We need to find products where the max page size is 'A4' or the pages per minute for color is less than 5.", "Construct the SQL query: Use a SELECT statement to retrieve all columns from the 'product' table where either of the conditions is met."], "gold_sql": "SELECT product FROM product WHERE max_page_size  =  'A4' OR pages_per_minute_color  <  5", "source_tables": ["product"], "pred_sql": "SELECT * FROM product WHERE max_page_size = 'A4' OR pages_per_minute_color < '5';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names or descriptions of products from the 'product' table that do not have the most common maximum page size. The placeholder in the subquery represents a numeric value used to limit the results of the maximum page size.\"\n}\n"}
{"sample_id": "train.4935", "db_id": "store_product", "question": "What are all of the products whose name includes the substring \"Scanner\"?", "rationale": ["Identify the table that contains product names or descriptions, which is the 'product' table.", "Determine the requirement to find products whose names include the substring 'Scanner'.", "Use the SQL LIKE operator with wildcards (%) to search for the substring within the product names.", "Construct the SQL query to select all columns from the 'product' table where the product name matches the condition."], "gold_sql": "SELECT product FROM product WHERE product LIKE '%Scanner%'", "source_tables": ["product"], "pred_sql": "SELECT * FROM product WHERE product LIKE '%Scanner%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names or descriptions of products from the 'product' table that do not have the most common maximum page size. The placeholder in the subquery represents a numeric value used to limit the results of the maximum page size.\",\n    \"1\": \"This virtual table identifies the names of districts that have stores of a specific type, intersecting the results for two different types of stores. The placeholders in the WHERE clause represent the types of stores being queried.\"\n}\n"}
{"sample_id": "train.4937", "db_id": "store_product", "question": "What is the most common maximum page size?", "rationale": ["Identify the column of interest: 'max_page_size' from the 'product' table.", "To find the most common maximum page size, we need to group the results by 'max_page_size'.", "Count the occurrences of each 'max_page_size' using COUNT(*) and order the results in descending order to get the most common one at the top.", "Limit the results to 1 to get only the most common maximum page size."], "gold_sql": "SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT 1", "source_tables": ["product"], "pred_sql": "SELECT max_page_size\nFROM product\nGROUP BY max_page_size\nORDER BY COUNT(*) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names or descriptions of products from the 'product' table that do not have the most common maximum page size. The placeholder in the subquery represents a numeric value used to limit the results of the maximum page size.\"\n}\n"}
{"sample_id": "train.4938", "db_id": "store_product", "question": "Find the name of the products that are not using the most frequently-used max page size.", "rationale": ["Identify the products from the 'product' table.", "Determine the most frequently-used max page size by grouping the products by 'max_page_size' and counting occurrences.", "Order the results by the count in descending order to find the most common max page size.", "Use a subquery to get the most common max page size.", "Select products that do not match this most common max page size."], "gold_sql": "SELECT product FROM product WHERE product != (SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["product"], "pred_sql": "SELECT product.product \nFROM product \nWHERE product.max_page_size != (SELECT max_page_size \n                                  FROM product \n                                  GROUP BY max_page_size \n                                  ORDER BY COUNT(*) DESC \n                                  LIMIT 1);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names or descriptions of products from the 'product' table that do not have the most common maximum page size. The placeholder in the subquery represents a numeric value used to limit the results of the maximum page size.\"\n}\n"}
{"sample_id": "train.4947", "db_id": "soccer_2", "question": "How many students, on average, does each college have enrolled?", "rationale": ["The question asks for the average number of students enrolled in each college.", "To find the average enrollment, we need to use the AVG() function on the 'enr' column from the 'College' table.", "The SQL query will select the average enrollment from the College table without any grouping since we want the overall average across all colleges."], "gold_sql": "SELECT avg(enr) FROM College", "source_tables": ["college"], "pred_sql": "SELECT AVG(enr) AS average_enrollment FROM College;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college's name, state, and the minimum enrollment number.\",\n    \"1\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college name, state, and the minimum enrollment number.\",\n    \"2\": \"This virtual table describes the names of colleges located in a specific state that have an enrollment number either less than or greater than a specified value. The placeholders in the WHERE clauses represent the enrollment numbers and the state name.\"\n}\n"}
{"sample_id": "train.4955", "db_id": "soccer_2", "question": "How many hours do the players train on average?", "rationale": ["The question asks for the average training hours of players.", "To find the average, we need to use the AVG() function in SQL.", "We assume there is a column 'training_hours' in the Player table that records the training hours for each player.", "The SQL query will select the average of the 'training_hours' column from the Player table."], "gold_sql": "SELECT avg(HS) FROM Player", "source_tables": ["player"], "pred_sql": "SELECT AVG(training_hours) AS average_training_hours FROM Player;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\",\n    \"1\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\"\n}\n"}
{"sample_id": "train.4956", "db_id": "soccer_2", "question": "Find the name and training hours of players whose hours are below 1500.", "rationale": ["Identify the relevant table: The Player table contains the names of players and their training hours.", "Determine the columns needed: We need the player's name (pName) and their training hours.", "Apply the filter: We need to filter players whose training hours are below 1500.", "Construct the SQL query: Use SELECT to get the required columns from the Player table with the specified condition."], "gold_sql": "SELECT pName ,  HS FROM Player WHERE HS  <  1500", "source_tables": ["player"], "pred_sql": "SELECT pName, hours FROM Player WHERE hours < 1500;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\",\n    \"1\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\"\n}\n"}
{"sample_id": "train.4961", "db_id": "soccer_2", "question": "What are the different types of player positions?", "rationale": ["The question asks for the different types of player positions, which suggests we need to retrieve unique values from the 'pPos' column in the 'Tryout' table.", "To get unique player positions, we can use the SQL keyword 'DISTINCT' in our query.", "The relevant table for player positions is 'Tryout', and the column we are interested in is 'pPos'.", "Thus, the SQL query will select distinct player positions from the Tryout table."], "gold_sql": "SELECT count(DISTINCT pPos) FROM tryout", "source_tables": ["tryout"], "pred_sql": "SELECT DISTINCT pPos FROM Tryout;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n    \"1\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\",\n    \"2\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\"\n}\n"}
{"sample_id": "train.4962", "db_id": "soccer_2", "question": "How many students got accepted after the tryout?", "rationale": ["Identify the relevant table: The 'Tryout' table contains information about players and their decisions after tryouts.", "Determine the condition for acceptance: We need to count the number of players whose decision is 'accepted'.", "Construct the SQL query: Use the COUNT function to count the number of rows in the 'Tryout' table where the decision is 'accepted'."], "gold_sql": "SELECT count(*) FROM tryout WHERE decision  =  'yes'", "source_tables": ["tryout"], "pred_sql": "SELECT COUNT(*) AS accepted_students\nFROM Tryout\nWHERE decision = 'accepted';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\",\n    \"1\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\",\n    \"2\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\"\n}\n"}
{"sample_id": "train.4966", "db_id": "soccer_2", "question": "Find the max, average and min training hours of all players.", "rationale": ["Identify the need to calculate maximum, average, and minimum training hours for all players.", "Recognize that the relevant table for player information is the Player table.", "Formulate the SQL query to select the maximum, average, and minimum of the training_hours column from the Player table."], "gold_sql": "SELECT avg(HS) ,  max(HS) ,  min(HS) FROM Player", "source_tables": ["player"], "pred_sql": "SELECT MAX(training_hours) AS max_hours, AVG(training_hours) AS avg_hours, MIN(training_hours) AS min_hours FROM Player;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\",\n    \"1\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\"\n}\n"}
{"sample_id": "train.4967", "db_id": "soccer_2", "question": "What is the average, maximum, and minimum for the number of hours spent training?", "rationale": ["Identify the required metrics: average, maximum, and minimum hours spent training.", "Determine the relevant table that contains training hours data, which is assumed to be a 'Training' table.", "Construct the SQL query to select the average, maximum, and minimum of the 'training_hours' column from the 'Training' table."], "gold_sql": "SELECT avg(HS) ,  max(HS) ,  min(HS) FROM Player", "source_tables": ["player"], "pred_sql": "SELECT AVG(training_hours) AS average_hours, MAX(training_hours) AS max_hours, MIN(training_hours) AS min_hours FROM Training;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\",\n    \"1\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\",\n    \"2\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college name, state, and the minimum enrollment number.\"\n}\n"}
{"sample_id": "train.4970", "db_id": "soccer_2", "question": "What are the names of players whose training hours is between 500 and 1500?", "rationale": ["Identify the table that contains player names, which is the Player table.", "Determine the relevant column for filtering, which is 'training_hours'.", "Use the BETWEEN clause to filter players whose training hours are between 500 and 1500.", "Construct the SQL query to select player names from the Player table based on the specified training hours condition."], "gold_sql": "SELECT pName FROM Player WHERE HS BETWEEN 500 AND 1500", "source_tables": ["player"], "pred_sql": "SELECT pName FROM Player WHERE training_hours BETWEEN 500 AND 1500;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n    \"1\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\",\n    \"2\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\"\n}\n"}
{"sample_id": "train.4971", "db_id": "soccer_2", "question": "What are the names of players who train between 500 and 1500 hours?", "rationale": ["Identify the relevant table: The Player table contains the names of players.", "Determine the filtering criteria: We need to find players who have trained between 500 and 1500 hours.", "Since the training hours are not directly in the schema, we assume that the Tryout table may have some indirect relation to training hours based on the number of tryouts or positions.", "Use a subquery to filter players based on the count of their tryouts, which we assume correlates with training hours.", "Group the results by position and filter using the HAVING clause to get counts between 500 and 1500.", "Finally, select the player names from the Player table based on the filtered player IDs."], "gold_sql": "SELECT pName FROM Player WHERE HS BETWEEN 500 AND 1500", "source_tables": ["player"], "pred_sql": "SELECT pName FROM Player WHERE pID IN (SELECT pID FROM Tryout WHERE pPos IN (SELECT pPos FROM Tryout GROUP BY pPos HAVING COUNT(pID) BETWEEN 500 AND 1500));", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n    \"1\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\"\n}\n"}
{"sample_id": "train.4975", "db_id": "soccer_2", "question": "What are the names and enrollment numbers for colleges that have more than 10000 enrolled and are located in Louisiana?", "rationale": ["Identify the relevant table: The 'College' table contains the necessary information about college names and enrollment numbers.", "Determine the conditions: We need colleges with an enrollment number greater than 10000 and located in Louisiana.", "Construct the SQL query: Use a SELECT statement to retrieve 'cName' and 'enr' from the 'College' table, applying the specified conditions in the WHERE clause."], "gold_sql": "SELECT cName ,  enr FROM College WHERE enr  >  10000 AND state = 'LA'", "source_tables": ["college"], "pred_sql": "SELECT cName, enr FROM College WHERE enr > 10000 AND state = 'Louisiana';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of colleges located in a specific state that have an enrollment number either less than or greater than a specified value. The placeholders in the WHERE clauses represent the enrollment numbers and the state name.\",\n    \"1\": \"This virtual table lists the distinct names of colleges from the 'College' table that have an enrollment number greater than the minimum enrollment number of colleges located in a specific state. The placeholder in the WHERE clause represents the state name.\",\n    \"2\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college name, state, and the minimum enrollment number.\"\n}\n"}
{"sample_id": "train.4981", "db_id": "soccer_2", "question": "What are the name of the players who received a card in descending order of the hours of training?", "rationale": ["Identify the relevant tables: Player and Tryout.", "Determine the condition for players who received a card, which is indicated by the decision in the Tryout table.", "Use a subquery to filter players based on the decision 'received card'.", "Select the player names from the Player table where their IDs match those in the subquery.", "Order the results by the maximum high school attended, grouped by position, in descending order."], "gold_sql": "SELECT pName FROM Player WHERE yCard  =  'yes' ORDER BY HS DESC", "source_tables": ["player"], "pred_sql": "SELECT pName FROM Player WHERE pID IN (SELECT pID FROM Tryout WHERE decision = 'received card') ORDER BY (SELECT MAX(HS) FROM Player GROUP BY pPos) DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\"\n}\n"}
{"sample_id": "train.4984", "db_id": "soccer_2", "question": "Which position is most popular among players in the tryout?", "rationale": ["To determine the most popular position among players in the tryout, we need to count how many players are trying out for each position.", "We will use the COUNT() function to count the number of players for each position (pPos) in the Tryout table.", "We will group the results by the position (pPos) to aggregate the counts for each position.", "To find the most popular position, we will order the results in descending order based on the count of players for each position.", "Finally, we will limit the results to just one entry to get the most popular position."], "gold_sql": "SELECT pPos FROM tryout GROUP BY pPos ORDER BY count(*) DESC LIMIT 1", "source_tables": ["tryout"], "pred_sql": "SELECT pPos, COUNT(*) as position_count\nFROM Tryout\nGROUP BY pPos\nORDER BY position_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n    \"1\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\",\n    \"2\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\"\n}\n"}
{"sample_id": "train.4985", "db_id": "soccer_2", "question": "What was the most popular position at tryouts?", "rationale": ["Identify the relevant table: The Tryout table contains the position information for players.", "Count the occurrences of each position: Use COUNT(pPos) to count how many players tried out for each position.", "Group the results by position: Use GROUP BY pPos to aggregate the counts for each position.", "Order the results to find the most popular position: Use ORDER BY position_count DESC to sort the positions by their count in descending order.", "Limit the results to the top position: Use LIMIT 1 to get only the most popular position."], "gold_sql": "SELECT pPos FROM tryout GROUP BY pPos ORDER BY count(*) DESC LIMIT 1", "source_tables": ["tryout"], "pred_sql": "SELECT pPos, COUNT(pPos) AS position_count \nFROM Tryout \nGROUP BY pPos \nORDER BY position_count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n    \"1\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\",\n    \"2\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\"\n}\n"}
{"sample_id": "train.4988", "db_id": "soccer_2", "question": "What is minimum hours of the students playing in different position?", "rationale": ["Identify the relevant tables: Player, Tryout, and College.", "Determine the columns needed: position (pPos) and enrollment (enr).", "Join the Player table with the Tryout table on pID to get player positions.", "Join the Tryout table with the College table on cName to access college information if needed.", "Use the MIN function to find the minimum enrollment number for each position.", "Group the results by position to get the minimum enrollment for each position."], "gold_sql": "SELECT min(T2.HS) ,   T1.pPos FROM tryout AS T1 JOIN player AS T2 ON T1.pID  =  T2.pID GROUP BY T1.pPos", "source_tables": ["player", "tryout"], "pred_sql": "SELECT pPos, MIN(enr) AS min_hours\nFROM Player\nJOIN Tryout ON Player.pID = Tryout.pID\nJOIN College ON Tryout.cName = College.cName\nGROUP BY pPos;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n    \"1\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\",\n    \"2\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\"\n}\n"}
{"sample_id": "train.4989", "db_id": "soccer_2", "question": "For each position, what is the minimum time students spent practicing?", "rationale": ["Identify the relevant tables: We need to find the minimum time students spent practicing for each position, which suggests we need a table that records practice times and player positions.", "Assume there is a 'Practice' table that records practice times along with player positions. We will group the results by position to find the minimum practice time for each.", "Use the MIN() function to calculate the minimum practice time for each position.", "Construct the SQL query to select the position and the minimum practice time, grouping by position."], "gold_sql": "SELECT min(T2.HS) ,   T1.pPos FROM tryout AS T1 JOIN player AS T2 ON T1.pID  =  T2.pID GROUP BY T1.pPos", "source_tables": ["player", "tryout"], "pred_sql": "SELECT pPos, MIN(practice_time) AS min_practice_time\nFROM Practice\nGROUP BY pPos;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n    \"1\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\",\n    \"2\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college name, state, and the minimum enrollment number.\"\n}\n"}
{"sample_id": "train.5003", "db_id": "soccer_2", "question": "What are the names and hours spent practicing of every student who received a yes at tryouts?", "rationale": ["Identify the tables involved: Player and Tryout.", "We need to select the names of players, which is in the Player table under the column pName.", "We also need to check the decision made during tryouts, which is in the Tryout table under the column decision.", "To find players who received a 'yes' at tryouts, we will filter the results where Tryout.decision = 'yes'.", "We need to join the Player and Tryout tables on the common column pID to correlate players with their tryout decisions."], "gold_sql": "SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes'", "source_tables": ["player", "tryout"], "pred_sql": "SELECT Player.pName, Tryout.decision \nFROM Player \nJOIN Tryout ON Player.pID = Tryout.pID \nWHERE Tryout.decision = 'yes';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\",\n    \"1\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\",\n    \"2\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\"\n}\n"}
{"sample_id": "train.5007", "db_id": "soccer_2", "question": "What are the names of all students who successfully tried out for the position of striker?", "rationale": ["Identify the relevant tables: Player and Tryout.", "We need to find the names of students (players) who successfully tried out for a specific position (striker).", "Join the Player table with the Tryout table on the player ID (pID) to access player names and their tryout details.", "Filter the results to include only those records where the position (pPos) is 'striker' and the decision is 'successful'.", "Select the player names (pName) from the filtered results."], "gold_sql": "SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes' AND T2.pPos  =  'striker'", "source_tables": ["player", "tryout"], "pred_sql": "SELECT Player.pName \nFROM Player \nJOIN Tryout ON Player.pID = Tryout.pID \nWHERE Tryout.pPos = 'striker' AND Tryout.decision = 'successful';", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n    \"1\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\",\n    \"2\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\"\n}\n"}
{"sample_id": "train.5013", "db_id": "soccer_2", "question": "What is the average number of hours spent practicing for students who got rejected?", "rationale": ["Identify the relevant tables: Player and Tryout are needed to find players who were rejected.", "Join the Player and Tryout tables on the pID to access player information along with their tryout decisions.", "Filter the results to include only those players whose decision was 'rejected'.", "Select the average of the hours spent practicing from the filtered results."], "gold_sql": "SELECT avg(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'no'", "source_tables": ["player", "tryout"], "pred_sql": "SELECT AVG(hours) AS average_hours_practicing\nFROM Player\nJOIN Tryout ON Player.pID = Tryout.pID\nWHERE Tryout.decision = 'rejected';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\",\n    \"1\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\",\n    \"2\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college name, state, and the minimum enrollment number.\"\n}\n"}
{"sample_id": "train.5018", "db_id": "soccer_2", "question": "Which college has any student who is a goalie and succeeded in the tryout.", "rationale": ["Identify the relevant tables: College, Player, and Tryout.", "We need to find colleges that have students who are goalies and succeeded in their tryouts.", "This requires joining the College table with the Tryout table on the college name, and the Tryout table with the Player table on the player ID.", "We filter the results where the position (pPos) is 'goalie' and the decision is 'succeeded'.", "Finally, we select distinct college names to avoid duplicates."], "gold_sql": "SELECT cName FROM  tryout WHERE decision  =  'yes' AND pPos  =  'goalie'", "source_tables": ["tryout"], "pred_sql": "SELECT DISTINCT College.cName \nFROM College \nJOIN Tryout ON College.cName = Tryout.cName \nJOIN Player ON Tryout.pID = Player.pID \nWHERE Tryout.pPos = 'goalie' AND Tryout.decision = 'succeeded';", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n    \"1\": \"This virtual table provides a list of states where colleges are located, specifically focusing on the states of colleges that have hosted tryouts for a particular position. The query uses a JOIN operation to connect the 'College' and 'Tryout' tables based on the college name, filtering the results by the player's position. The EXCEPT clause is used to exclude states from the second selection that also hosted tryouts for the same position, ensuring that only unique states are returned.\",\n    \"2\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\"\n}\n"}
{"sample_id": "train.5022", "db_id": "soccer_2", "question": "What is the state and enrollment of the colleges where have any students who got accepted in the tryout decision.", "rationale": ["Identify the relevant tables: College and Tryout.", "Determine the columns needed: state and enrollment from College, and filter based on the decision in Tryout.", "Use a JOIN to connect College and Tryout on the college name (cName).", "Add a WHERE clause to filter for accepted decisions in the Tryout table."], "gold_sql": "SELECT DISTINCT T1.state ,  T1.enr FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  'yes'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT College.state, College.enr FROM College JOIN Tryout ON College.cName = Tryout.cName WHERE Tryout.decision = 'accepted';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college name, state, and the minimum enrollment number.\",\n    \"1\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college's name, state, and the minimum enrollment number.\",\n    \"2\": \"This virtual table provides a list of states where colleges are located, specifically focusing on the states of colleges that have hosted tryouts for a particular position. The query uses a JOIN operation to connect the 'College' and 'Tryout' tables based on the college name, filtering the results by the player's position. The EXCEPT clause is used to exclude states from the second selection that also hosted tryouts for the same position, ensuring that only unique states are returned.\"\n}\n"}
{"sample_id": "train.5023", "db_id": "soccer_2", "question": "How many students are enrolled in colleges that have student accepted during tryouts, and in which states are those colleges?", "rationale": ["Identify the tables involved: College and Tryout.", "We need to find the total enrollment of colleges that have accepted students during tryouts, so we will join the College and Tryout tables on the college name (cName).", "We will filter the results to include only those tryouts where the decision was 'accepted'.", "We need to sum the enrollment numbers, which are stored as text, so we will cast them to integers for the summation.", "Finally, we will group the results by the state of the colleges to get the total enrollment per state."], "gold_sql": "SELECT DISTINCT T1.state ,  T1.enr FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  'yes'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT SUM(CAST(College.enr AS INTEGER)) AS total_enrollment, College.state \nFROM College \nJOIN Tryout ON College.cName = Tryout.cName \nWHERE Tryout.decision = 'accepted' \nGROUP BY College.state;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college name, state, and the minimum enrollment number.\",\n    \"1\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college's name, state, and the minimum enrollment number.\",\n    \"2\": \"This virtual table provides a list of states where colleges are located, specifically focusing on the states of colleges that have hosted tryouts for a particular position. The query uses a JOIN operation to connect the 'College' and 'Tryout' tables based on the college name, filtering the results by the player's position. The EXCEPT clause is used to exclude states from the second selection that also hosted tryouts for the same position, ensuring that only unique states are returned.\"\n}\n"}
{"sample_id": "train.5026", "db_id": "soccer_2", "question": "Find the names of schools that have some students playing in goalie and mid positions.", "rationale": ["Identify the relevant tables: We need to look at the 'Tryout' table since it contains the positions players are trying out for and the colleges associated with those tryouts.", "We need to find colleges where players are trying out for both 'goalie' and 'mid' positions.", "Use the SELECT statement to get distinct college names from the 'Tryout' table.", "Filter the results using a WHERE clause to include only those rows where the position (pPos) is either 'goalie' or 'mid'.", "Group the results by college name to aggregate the data for each college.", "Use the HAVING clause to ensure that only colleges with players trying out for both positions are included, which means we need to count distinct positions and ensure that count equals 2."], "gold_sql": "SELECT cName FROM  tryout WHERE pPos  =  'goalie' INTERSECT SELECT cName FROM  tryout WHERE pPos  =  'mid'", "source_tables": ["tryout"], "pred_sql": "SELECT DISTINCT Tryout.cName\nFROM Tryout\nWHERE Tryout.pPos IN ('goalie', 'mid')\nGROUP BY Tryout.cName\nHAVING COUNT(DISTINCT Tryout.pPos) = 2;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n    \"1\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\",\n    \"2\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\"\n}\n"}
{"sample_id": "train.5028", "db_id": "soccer_2", "question": "Find the names of states that have some college students playing in goalie and mid positions.", "rationale": ["Identify the tables involved: College and Tryout.", "Determine the relationship between the tables: Tryout references College through cName.", "Focus on the required output: names of states with colleges that have players trying out for 'goalie' and 'mid' positions.", "Use a JOIN to connect College and Tryout on the college name (cName).", "Filter the results using a WHERE clause to include only those records where the position (pPos) is either 'goalie' or 'mid'.", "Select distinct states to avoid duplicates in the final output."], "gold_sql": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'goalie' INTERSECT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'mid'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT DISTINCT College.state \nFROM College \nJOIN Tryout ON College.cName = Tryout.cName \nWHERE Tryout.pPos IN ('goalie', 'mid');", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n    \"1\": \"This virtual table provides a list of states where colleges are located, specifically focusing on the states of colleges that have hosted tryouts for a particular position. The query uses a JOIN operation to connect the 'College' and 'Tryout' tables based on the college name, filtering the results by the player's position. The EXCEPT clause is used to exclude states from the second selection that also hosted tryouts for the same position, ensuring that only unique states are returned.\",\n    \"2\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college's name, state, and the minimum enrollment number.\"\n}\n"}
{"sample_id": "train.5029", "db_id": "soccer_2", "question": "What are the names of the states that have some college students playing in the positions of goalie and mid-field?", "rationale": ["Identify the relevant tables: College and Tryout.", "We need to find states that have colleges with players trying out for the positions of goalie and mid-field.", "Use a JOIN operation to connect the College and Tryout tables based on the college name (cName).", "Filter the results to include only those tryouts where the position (pPos) is either 'goalie' or 'mid-field'.", "Select distinct states from the College table that meet the criteria."], "gold_sql": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'goalie' INTERSECT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'mid'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT DISTINCT College.state\nFROM College\nJOIN Tryout ON College.cName = Tryout.cName\nWHERE Tryout.pPos IN ('goalie', 'mid-field')\nGROUP BY College.state;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n    \"1\": \"This virtual table provides a list of states where colleges are located, specifically focusing on the states of colleges that have hosted tryouts for a particular position. The query uses a JOIN operation to connect the 'College' and 'Tryout' tables based on the college name, filtering the results by the player's position. The EXCEPT clause is used to exclude states from the second selection that also hosted tryouts for the same position, ensuring that only unique states are returned.\",\n    \"2\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college's name, state, and the minimum enrollment number.\"\n}\n"}
{"sample_id": "train.5030", "db_id": "soccer_2", "question": "How many schools have some students playing in goalie and mid positions.", "rationale": ["Identify the relevant positions: goalie and mid.", "We need to count distinct colleges (cName) where players are trying out for these positions.", "Use the Tryout table to filter players based on their positions.", "Group the results by college name to aggregate the data.", "Use the HAVING clause to ensure that both positions are represented for each college."], "gold_sql": "SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  'goalie' INTERSECT SELECT cName FROM  tryout WHERE pPos  =  'mid')", "source_tables": ["tryout"], "pred_sql": "SELECT COUNT(DISTINCT cName) AS school_count \nFROM Tryout \nWHERE pPos IN ('goalie', 'mid') \nGROUP BY cName \nHAVING COUNT(DISTINCT pPos) = 2;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n    \"1\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\",\n    \"2\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\"\n}\n"}
{"sample_id": "train.5037", "db_id": "soccer_2", "question": "What is the count of states with college students playing in the mid position but not as goalies?", "rationale": ["Identify the relevant tables: College and Tryout.", "We need to count distinct states from the College table where players are trying out for the 'mid' position.", "Join the College table with the Tryout table on the college name to filter the relevant tryouts.", "Add a condition to filter for players trying out for the 'mid' position.", "Use a subquery to exclude states where players are trying out for the 'goalie' position.", "The subquery selects college names from the Tryout table where the position is 'goalie' and ensures these colleges are excluded from the main query."], "gold_sql": "SELECT COUNT(*) FROM (SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'mid' EXCEPT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'goalie')", "source_tables": ["tryout", "college"], "pred_sql": "SELECT COUNT(DISTINCT College.state) \nFROM College \nJOIN Tryout ON College.cName = Tryout.cName \nWHERE Tryout.pPos = 'mid' \nAND College.cName NOT IN (\n    SELECT College.cName \n    FROM College \n    JOIN Tryout ON College.cName = Tryout.cName \n    WHERE Tryout.pPos = 'goalie'\n);", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n    \"1\": \"This virtual table provides a list of states where colleges are located, specifically focusing on the states of colleges that have hosted tryouts for a particular position. The query uses a JOIN operation to connect the 'College' and 'Tryout' tables based on the college name, filtering the results by the player's position. The EXCEPT clause is used to exclude states from the second selection that also hosted tryouts for the same position, ensuring that only unique states are returned.\",\n    \"2\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college's name, state, and the minimum enrollment number.\"\n}\n"}
{"sample_id": "train.5039", "db_id": "soccer_2", "question": "What are the states with colleges that have enrollments less than the some other college?", "rationale": ["Identify the requirement to find states with colleges that have enrollments less than some other college.", "Use a subquery to find the minimum enrollment number from the College table.", "Select distinct states from the College table where the enrollment number is less than the minimum enrollment number found in the subquery."], "gold_sql": "SELECT DISTINCT state FROM college WHERE enr  <  (SELECT max(enr) FROM college)", "source_tables": ["college"], "pred_sql": "SELECT DISTINCT state FROM College WHERE enr < (SELECT MIN(enr) FROM College)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of colleges located in a specific state that have an enrollment number either less than or greater than a specified value. The placeholders in the WHERE clauses represent the enrollment numbers and the state name.\",\n    \"1\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college name, state, and the minimum enrollment number.\",\n    \"2\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college's name, state, and the minimum enrollment number.\"\n}\n"}
{"sample_id": "train.5102", "db_id": "cre_Drama_Workshop_Groups", "question": "Show the minimum, average, maximum order quantity of all invoices.", "rationale": ["Identify the relevant table: The task requires information about invoices, specifically the order quantities, which are found in the Invoice_Items table.", "Determine the required calculations: We need to calculate the minimum, average, and maximum order quantities.", "Construct the SQL query: Use the SELECT statement to retrieve the minimum, average, and maximum order quantities from the Invoice_Items table."], "gold_sql": "SELECT min(Order_Quantity) ,  avg(Order_Quantity) ,  max(Order_Quantity) FROM INVOICES", "source_tables": ["invoices"], "pred_sql": "SELECT MIN(Order_Quantity) AS Min_Quantity, AVG(Order_Quantity) AS Avg_Quantity, MAX(Order_Quantity) AS Max_Quantity\nFROM Invoice_Items;", "hint": "\n"}
{"sample_id": "train.5118", "db_id": "cre_Drama_Workshop_Groups", "question": "What is the payment method code used by the most orders?", "rationale": ["Identify the relevant table: Invoices contains the payment_method_code and Order_ID.", "Group the results by payment_method_code to count the number of orders for each payment method.", "Use COUNT(Order_ID) to count the number of orders associated with each payment method.", "Order the results in descending order to get the payment method with the most orders at the top.", "Limit the results to 1 to get only the payment method code used by the most orders."], "gold_sql": "SELECT payment_method_code FROM INVOICES GROUP BY payment_method_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["invoices"], "pred_sql": "SELECT payment_method_code\nFROM Invoices\nGROUP BY payment_method_code\nORDER BY COUNT(Order_ID) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5127", "db_id": "cre_Drama_Workshop_Groups", "question": "Give me the descriptions of the service types that cost more than 100.", "rationale": ["Identify the relevant tables: We need to retrieve service type descriptions, which are in the Ref_Service_Types table, and we also need to check the price of services, which are in the Services table.", "Join the tables: We will join the Services table with the Ref_Service_Types table on the Service_Type_Code to get the descriptions of the service types associated with the services.", "Filter the results: We need to filter the services to only include those that cost more than 100, which will be done using a WHERE clause on the Product_Price column in the Services table."], "gold_sql": "SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Price  >  100", "source_tables": ["services", "ref_service_types"], "pred_sql": "SELECT Ref_Service_Types.Service_Type_Description \nFROM Services \nJOIN Ref_Service_Types ON Services.Service_Type_Code = Ref_Service_Types.Service_Type_Code \nWHERE Services.Product_Price > 100;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the descriptions of service types associated with a specific product name from the 'Services' table, ensuring that the same product name is used in both parts of the query. The placeholders represent the product name that the user can specify to filter the results accordingly.\"\n}\n"}
{"sample_id": "train.5134", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the names of workshop groups in which services with product name \"film\" are performed?", "rationale": ["Identify the relevant tables: 'Drama_Workshop_Groups' for workshop group names and 'Services' for the product name.", "Join the 'Drama_Workshop_Groups' table with the 'Services' table on the 'Workshop_Group_ID' to link workshop groups with their services.", "Filter the results to only include services where the product name is 'film'.", "Select distinct workshop group names to avoid duplicates in the results."], "gold_sql": "SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T2.Product_Name  =  'film'", "source_tables": ["services", "drama_workshop_groups"], "pred_sql": "SELECT DISTINCT DWG.Store_Name \nFROM Drama_Workshop_Groups DWG \nJOIN Services S ON DWG.Workshop_Group_ID = S.Workshop_Group_ID \nWHERE S.Product_Name = 'film';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the phone number and email address of stores associated with specific drama workshop groups that offer a particular product. The placeholder in the WHERE clause represents the name of the product being queried.\",\n    \"1\": \"This virtual table retrieves the descriptions of service types associated with a specific product name from the 'Services' table, ensuring that the same product name is used in both parts of the query. The placeholders represent the product name that the user can specify to filter the results accordingly.\"\n}\n"}
{"sample_id": "train.5142", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the order details of the products with price higher than 2000?", "rationale": ["Identify the relevant tables: Order_Items and Products are needed to get order details and product prices.", "Determine the columns needed: We need Order_Item_ID, Order_ID, Product_ID, Order_Quantity from Order_Items and Product_Name, Product_Price from Products.", "Establish the relationship: Use a JOIN to connect Order_Items with Products on Product_ID.", "Apply the filter: Use a WHERE clause to filter products with a price greater than 2000."], "gold_sql": "SELECT T1.Other_Item_Details FROM ORDER_ITEMS AS T1 JOIN Products AS T2 ON T1.Product_ID  =  T2.Product_ID WHERE T2.Product_price  >  2000", "source_tables": ["products", "order_items"], "pred_sql": "SELECT Order_Items.Order_Item_ID, Order_Items.Order_ID, Order_Items.Product_ID, Order_Items.Order_Quantity, Products.Product_Name, Products.Product_Price \nFROM Order_Items \nJOIN Products ON Order_Items.Product_ID = Products.Product_ID \nWHERE Products.Product_Price > 2000;", "hint": "\n"}
{"sample_id": "train.5143", "db_id": "cre_Drama_Workshop_Groups", "question": "Find the order detail for the products with price above 2000.", "rationale": ["Identify the relevant tables: Order_Items and Products.", "Determine the columns needed: Order_Item_ID, Order_ID, Product_ID, Order_Quantity from Order_Items and Product_Price from Products.", "Establish the relationship between Order_Items and Products using the Product_ID.", "Filter the results to include only those products with a price greater than 2000."], "gold_sql": "SELECT T1.Other_Item_Details FROM ORDER_ITEMS AS T1 JOIN Products AS T2 ON T1.Product_ID  =  T2.Product_ID WHERE T2.Product_price  >  2000", "source_tables": ["products", "order_items"], "pred_sql": "SELECT Order_Items.Order_Item_ID, Order_Items.Order_ID, Order_Items.Product_ID, Order_Items.Order_Quantity, Products.Product_Price \nFROM Order_Items \nJOIN Products ON Order_Items.Product_ID = Products.Product_ID \nWHERE Products.Product_Price > 2000;", "hint": "\n"}
{"sample_id": "train.5160", "db_id": "cre_Drama_Workshop_Groups", "question": "What is the most frequent status of bookings?", "rationale": ["Identify the relevant table: The question pertains to bookings, so we will use the 'Bookings' table.", "Determine the required information: We need to find the most frequent status of bookings, which means we need to count occurrences of each status code.", "Use the COUNT function: We will count the number of bookings for each status code using COUNT(*) and group the results by 'Status_Code'.", "Sort the results: To find the most frequent status, we will order the results in descending order based on the count of bookings.", "Limit the results: Since we only want the most frequent status, we will limit the results to 1."], "gold_sql": "SELECT Status_Code FROM BOOKINGS GROUP BY Status_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["bookings"], "pred_sql": "SELECT Status_Code, COUNT(*) as Frequency\nFROM Bookings\nGROUP BY Status_Code\nORDER BY Frequency DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5161", "db_id": "cre_Drama_Workshop_Groups", "question": "Which status code is the most common of all the bookings?", "rationale": ["Identify the relevant table: The question pertains to bookings, so we will use the 'Bookings' table.", "Determine the required information: We need to find the most common status code, which implies counting occurrences of each status code.", "Use the COUNT function: We will count how many times each status code appears in the 'Bookings' table.", "Group the results: We will group the results by 'Status_Code' to aggregate the counts for each unique status code.", "Order the results: To find the most common status code, we will order the results in descending order based on the count.", "Limit the results: Since we only want the most common status code, we will limit the results to 1."], "gold_sql": "SELECT Status_Code FROM BOOKINGS GROUP BY Status_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["bookings"], "pred_sql": "SELECT Status_Code, COUNT(Status_Code) AS Count\nFROM Bookings\nGROUP BY Status_Code\nORDER BY Count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5162", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the names of the workshop groups that have bookings with status code \"stop\"?", "rationale": ["Identify the relevant tables: We need to find workshop groups and their bookings, so we will use the Drama_Workshop_Groups and Bookings tables.", "Determine the relationship: The Drama_Workshop_Groups table is linked to the Bookings table through the Workshop_Group_ID.", "Select the required fields: We need the names of the workshop groups, which corresponds to the Store_Name in the Drama_Workshop_Groups table.", "Apply the filter: We need to filter the bookings to only include those with a status code of 'stop'.", "Use DISTINCT to ensure we only get unique workshop group names."], "gold_sql": "SELECT T2.Store_Name FROM Bookings AS T1 JOIN Drama_Workshop_Groups AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T1.Status_Code  =  'stop'", "source_tables": ["drama_workshop_groups", "bookings"], "pred_sql": "SELECT DISTINCT DWG.Store_Name \nFROM Drama_Workshop_Groups DWG \nJOIN Bookings B ON DWG.Workshop_Group_ID = B.Workshop_Group_ID \nWHERE B.Status_Code = 'stop';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the phone number and email address of stores associated with specific drama workshop groups that offer a particular product. The placeholder in the WHERE clause represents the name of the product being queried.\"\n}\n"}
{"sample_id": "train.5171", "db_id": "cre_Drama_Workshop_Groups", "question": "Give me the description of the service type that offers not only the photo product but also the film product.", "rationale": ["Identify the relevant tables: We need to retrieve service type descriptions, so we will use the 'Ref_Service_Types' table and the 'Services' table.", "Join the tables: We will join 'Services' with 'Ref_Service_Types' on the 'Service_Type_Code' to get the descriptions of the service types.", "Filter for specific products: We need to filter the services to only those that offer both 'photo' and 'film' products. This can be done using a WHERE clause with an IN condition.", "Group the results: We will group the results by 'Service_Type_Description' to aggregate the services that match our criteria.", "Count distinct products: We will use HAVING to ensure that only service types that offer both products are included, which means we need to count distinct product names and check that it equals 2."], "gold_sql": "SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  'photo' INTERSECT SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  'film'", "source_tables": ["services", "ref_service_types"], "pred_sql": "SELECT DISTINCT Ref_Service_Types.Service_Type_Description \nFROM Services \nJOIN Ref_Service_Types ON Services.Service_Type_Code = Ref_Service_Types.Service_Type_Code \nWHERE Services.Product_Name IN ('photo', 'film') \nGROUP BY Ref_Service_Types.Service_Type_Description \nHAVING COUNT(DISTINCT Services.Product_Name) = 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the descriptions of service types associated with a specific product name from the 'Services' table, ensuring that the same product name is used in both parts of the query. The placeholders represent the product name that the user can specify to filter the results accordingly.\",\n    \"1\": \"This virtual table provides the phone number and email address of stores associated with specific drama workshop groups that offer a particular product. The placeholder in the WHERE clause represents the name of the product being queried.\"\n}\n"}
{"sample_id": "train.5459", "db_id": "voter_2", "question": "Find the average age of female students.", "rationale": ["Identify the table needed: The 'Student' table contains the necessary information about students, including their age and gender.", "Determine the required calculation: We need to calculate the average age, which can be done using the AVG() function in SQL.", "Filter the results: We only want the average age of female students, so we will add a WHERE clause to filter by 'Sex = 'Female'.", "Construct the SQL query: Combine the SELECT statement with the AVG() function, the FROM clause to specify the 'Student' table, and the WHERE clause for filtering by gender."], "gold_sql": "SELECT avg(Age) FROM STUDENT WHERE Sex  =  'F'", "source_tables": ["student"], "pred_sql": "SELECT AVG(Age) AS Average_Age FROM Student WHERE Sex = 'Female';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n    \"1\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n    \"2\": \"This virtual table provides a list of distinct first and last names of students who voted for the presidential candidate, filtered by their gender. The placeholder in the WHERE clause represents the gender of the students.\"\n}\n"}
{"sample_id": "train.5466", "db_id": "voter_2", "question": "What are the distinct president votes on 08/30/2015?", "rationale": ["Identify the relevant table: The Voting_record table contains the voting information, including the President_Vote column.", "Determine the required information: The question asks for distinct president votes on a specific date (08/30/2015).", "Filter the records based on the date: Use the WHERE clause to filter records where the Registration_Date matches '2015-08-30'.", "Select distinct values: Use the DISTINCT keyword to ensure that only unique president votes are returned."], "gold_sql": "SELECT DISTINCT PRESIDENT_Vote FROM VOTING_RECORD WHERE Registration_Date  =  '08/30/2015'", "source_tables": ["voting_record"], "pred_sql": "SELECT DISTINCT President_Vote \nFROM Voting_record \nWHERE Registration_Date = '2015-08-30';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique last names of students who voted for a presidential candidate, excluding those who have a specific academic advisor. The placeholders in the query represent the advisor's name.\",\n    \"1\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n    \"2\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\"\n}\n"}
{"sample_id": "train.5467", "db_id": "voter_2", "question": "Show all the distinct president votes made on 08/30/2015.", "rationale": ["Identify the relevant tables: We need to retrieve data from the Student and Voting_record tables.", "Determine the necessary columns: We want distinct first and last names of students who voted for president.", "Establish the relationship between tables: The Student table is linked to the Voting_record table through the StuID column.", "Filter the results: We need to filter the voting records to only include those with a specific registration date (08/30/2015) and ensure that the president vote is not null."], "gold_sql": "SELECT DISTINCT PRESIDENT_Vote FROM VOTING_RECORD WHERE Registration_Date  =  '08/30/2015'", "source_tables": ["voting_record"], "pred_sql": "SELECT DISTINCT Student.Fname, Student.LName \nFROM Student \nJOIN Voting_record ON Student.StuID = Voting_record.StuID \nWHERE Voting_record.President_Vote IS NOT NULL \nAND Voting_record.Registration_Date = '2015-08-30';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique last names of students who voted for a presidential candidate, excluding those who have a specific academic advisor. The placeholders in the query represent the advisor's name.\",\n    \"1\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n    \"2\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\"\n}\n"}
{"sample_id": "train.5476", "db_id": "voter_2", "question": "Find the distinct ages of students who have secretary votes in the fall election cycle.", "rationale": ["Identify the relevant tables: We need to look at the 'Student' table for student details and the 'Voting_record' table for voting details.", "Determine the columns needed: We need the distinct ages of students, which is in the 'Student' table under the 'Age' column.", "Establish the relationship between tables: The 'StuID' in the 'Student' table is linked to the 'StuID' in the 'Voting_record' table, allowing us to join these tables.", "Filter the results: We need to filter for students who have cast a vote for the secretary, which means checking if 'Secretary_Vote' is not null. Additionally, we need to specify the election cycle as 'fall'.", "Construct the SQL query: Using the SELECT statement to get distinct ages, joining the two tables on 'StuID', and applying the necessary filters."], "gold_sql": "SELECT DISTINCT T1.Age FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Secretary_Vote WHERE T2.Election_Cycle  =  'Fall'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT Age FROM Student INNER JOIN Voting_record ON Student.StuID = Voting_record.StuID WHERE Voting_record.Secretary_Vote IS NOT NULL AND Voting_record.Election_Cycle = 'fall';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n    \"1\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n    \"2\": \"This virtual table provides a list of unique last names of students who voted for a presidential candidate, excluding those who have a specific academic advisor. The placeholders in the query represent the advisor's name.\"\n}\n"}
{"sample_id": "train.5479", "db_id": "voter_2", "question": "Who served as an advisor for students who have treasurer votes in the spring election cycle?", "rationale": ["Identify the relevant tables: We need to look at the 'Student' table for advisor information and the 'Voting_record' table for voting details.", "Determine the relationship: The 'Voting_record' table has a foreign key 'StuID' that links to the 'Student' table, allowing us to join these tables on 'StuID'.", "Specify the condition: We want to find students who have cast votes for treasurer, which means we need to check if 'Treasurer_Vote' is not null.", "Filter by election cycle: We need to specify that we are only interested in the spring election cycle, so we will add a condition for 'Election_Cycle'.", "Select the advisor: Finally, we want to select the distinct advisors of these students."], "gold_sql": "SELECT DISTINCT T1.Advisor FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Treasurer_Vote WHERE T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT Student.Advisor \nFROM Student \nJOIN Voting_record ON Student.StuID = Voting_record.StuID \nWHERE Voting_record.Treasurer_Vote IS NOT NULL \nAND Voting_record.Election_Cycle = 'spring';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the last names of students who have voted for a presidential candidate and are being advised by a specific academic advisor. The placeholder in the WHERE clause represents the advisor's name.\",\n    \"1\": \"This virtual table provides a list of unique last names of students who voted for a presidential candidate, excluding those who have a specific academic advisor. The placeholders in the query represent the advisor's name.\",\n    \"2\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\"\n}\n"}
{"sample_id": "train.5486", "db_id": "voter_2", "question": "How many male (sex is M) students have class senator votes in the fall election cycle?", "rationale": ["Identify the relevant tables: We need to use both the 'Student' and 'Voting_record' tables to get the required information about male students and their voting records.", "Determine the criteria: We are looking for male students (Sex = 'M') who have class senator votes in the fall election cycle.", "Join the tables: We will join the 'Student' table with the 'Voting_record' table on the StuID to link students with their voting records.", "Count distinct male students: We will count the distinct StuID from the joined tables where the conditions for sex and election cycle are met."], "gold_sql": "SELECT count(*) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  Class_Senator_Vote WHERE T1.Sex  =  'M' AND T2.Election_Cycle  =  'Fall'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT COUNT(DISTINCT Student.StuID) \nFROM Student \nJOIN Voting_record ON Student.StuID = Voting_record.StuID \nWHERE Student.Sex = 'M' \nAND Voting_record.Election_Cycle = 'fall';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct first and last names of students who voted for the presidential candidate, filtered by their gender. The placeholder in the WHERE clause represents the gender of the students.\",\n    \"1\": \"This virtual table provides a list of distinct first and last names of students from the 'Student' table who have voted for a presidential candidate, filtered by their gender. The placeholder in the WHERE clause represents the gender of the students.\",\n    \"2\": \"This virtual table provides a list of unique last names of students who voted for a presidential candidate, excluding those who have a specific academic advisor. The placeholders in the query represent the advisor's name.\"\n}\n"}
{"sample_id": "train.5491", "db_id": "voter_2", "question": "What is the average age of students who have city code \"NYC\" and have secretary votes for the spring election cycle?", "rationale": ["Identify the tables involved: We need data from the 'Student' table for age and city code, and from the 'Voting_record' table for the secretary votes and election cycle.", "Determine the conditions: We need to filter students who have the city code 'NYC' and have cast a vote for the secretary in the spring election cycle.", "Join the tables: We will join the 'Student' table with the 'Voting_record' table on the StuID to correlate students with their voting records.", "Calculate the average age: We will use the AVG() function to calculate the average age of the filtered students."], "gold_sql": "SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.city_code  =  'NYC' AND T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT AVG(Age) AS Average_Age\nFROM Student\nJOIN Voting_record ON Student.StuID = Voting_record.StuID\nWHERE Student.city_code = 'NYC' AND Voting_record.Secretary_Vote IS NOT NULL AND Voting_record.Election_Cycle = 'spring';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n    \"1\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n    \"2\": \"This virtual table provides a list of unique last names of students who voted for a presidential candidate, excluding those who have a specific academic advisor. The placeholders in the query represent the advisor's name.\"\n}\n"}
{"sample_id": "train.5492", "db_id": "voter_2", "question": "Find the average age of female (sex is F) students who have secretary votes in the spring election cycle.", "rationale": ["Identify the relevant tables: We need to use the 'Student' table to get the age and gender of students, and the 'Voting_record' table to check for secretary votes and the election cycle.", "We need to filter for female students, which means we will add a condition for 'Sex' = 'F'.", "We also need to ensure that the students have voted for the secretary, so we will check that 'Secretary_Vote' is not null in the 'Voting_record' table.", "Additionally, we need to filter for the spring election cycle, which will be done by checking the 'Election_Cycle' column in the 'Voting_record' table.", "Finally, we will calculate the average age of the filtered results using the AVG() function and select it as 'Average_Age'."], "gold_sql": "SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.Sex  =  'F' AND T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT AVG(Age) AS Average_Age\nFROM Student S\nJOIN Voting_record V ON S.StuID = V.StuID\nWHERE S.Sex = 'F' AND V.Secretary_Vote IS NOT NULL AND V.Election_Cycle = 'spring';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n    \"1\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n    \"2\": \"This virtual table provides a list of distinct first and last names of students who voted for the presidential candidate, filtered by their gender. The placeholder in the WHERE clause represents the gender of the students.\"\n}\n"}
{"sample_id": "train.5494", "db_id": "voter_2", "question": "Find the distinct first names of all the students who have vice president votes and whose city code is not PIT.", "rationale": ["We need to find distinct first names of students who voted for the vice president.", "To do this, we will join the Student table with the Voting_record table on the StuID column, which is the unique identifier for students in both tables.", "We will filter the results to include only those records where the Vice_President_Vote is not null, indicating that the student has cast a vote for the vice president.", "Additionally, we will filter out students whose city code is 'PIT' by adding a condition that city_code should not equal 'PIT'.", "Finally, we will select only the distinct first names (Fname) from the resulting dataset."], "gold_sql": "SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_PRESIDENT_Vote EXCEPT SELECT DISTINCT Fname FROM STUDENT WHERE city_code  =  'PIT'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT Fname FROM Student JOIN Voting_record ON Student.StuID = Voting_record.StuID WHERE Vice_President_Vote IS NOT NULL AND city_code != 'PIT';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique last names of students who voted for a presidential candidate, excluding those who have a specific academic advisor. The placeholders in the query represent the advisor's name.\",\n    \"1\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n    \"2\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\"\n}\n"}
{"sample_id": "train.5495", "db_id": "voter_2", "question": "What are the distinct first names of the students who have vice president votes and reside in a city whose city code is not PIT?", "rationale": ["Identify the relevant tables: We need to retrieve first names from the Student table and check voting records from the Voting_record table.", "Determine the relationship: The Student table and Voting_record table are linked by the StuID column.", "Filter criteria: We want students who have voted for the vice president, which means we need to check that the Vice_President_Vote column is not null.", "Additional filter: We also need to ensure that the city_code is not 'PIT'.", "Construct the SQL query: We will select distinct first names from the Student table, joining it with the Voting_record table, and applying the necessary filters."], "gold_sql": "SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_PRESIDENT_Vote EXCEPT SELECT DISTINCT Fname FROM STUDENT WHERE city_code  =  'PIT'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT Fname FROM Student JOIN Voting_record ON Student.StuID = Voting_record.StuID WHERE Vice_President_Vote IS NOT NULL AND city_code != 'PIT';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n    \"1\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n    \"2\": \"This virtual table provides a list of unique last names of students who voted for a presidential candidate, excluding those who have a specific academic advisor. The placeholders in the query represent the advisor's name.\"\n}\n"}
{"sample_id": "train.5496", "db_id": "voter_2", "question": "Find the distinct last names of all the students who have president votes and whose advisor is not 2192.", "rationale": ["We need to find distinct last names of students who voted for a presidential candidate.", "To do this, we will join the Student table with the Voting_record table on the StuID column, which is the unique identifier for students.", "We will filter the results to include only those records where the President_Vote is not null, indicating that the student has cast a vote for president.", "Additionally, we will exclude students whose advisor is '2192' by adding a condition in the WHERE clause.", "Finally, we will select only the distinct last names from the resulting dataset."], "gold_sql": "SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote EXCEPT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  '2192'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT Student.LName \nFROM Student \nJOIN Voting_record ON Student.StuID = Voting_record.StuID \nWHERE Voting_record.President_Vote IS NOT NULL \nAND Student.Advisor != '2192';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique last names of students who voted for a presidential candidate, excluding those who have a specific academic advisor. The placeholders in the query represent the advisor's name.\",\n    \"1\": \"This virtual table describes the last names of students who have voted for a presidential candidate and are being advised by a specific academic advisor. The placeholder in the WHERE clause represents the advisor's name.\",\n    \"2\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\"\n}\n"}
{"sample_id": "train.5499", "db_id": "voter_2", "question": "What are the distinct last names of the students who have president votes and have 8741 as the advisor?", "rationale": ["Identify the relevant tables: We need to get last names from the Student table and filter based on voting records from the Voting_record table.", "Join the Student and Voting_record tables on the StuID column to combine student information with their voting records.", "Filter the results to include only those students who have cast a vote for president (i.e., where President_Vote is not null).", "Additionally, filter the results to include only those students whose advisor is '8741'.", "Select distinct last names to ensure that we do not have duplicate entries in the result."], "gold_sql": "SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote INTERSECT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  '8741'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT Student.LName \nFROM Student \nJOIN Voting_record ON Student.StuID = Voting_record.StuID \nWHERE Voting_record.President_Vote IS NOT NULL \nAND Student.Advisor = '8741';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique last names of students who voted for a presidential candidate, excluding those who have a specific academic advisor. The placeholders in the query represent the advisor's name.\",\n    \"1\": \"This virtual table describes the last names of students who have voted for a presidential candidate and are being advised by a specific academic advisor. The placeholder in the WHERE clause represents the advisor's name.\",\n    \"2\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\"\n}\n"}
{"sample_id": "train.5510", "db_id": "voter_2", "question": "What is the most common major among female (sex is F) students?", "rationale": ["Identify the relevant table: The 'Student' table contains information about students, including their major and gender.", "Filter the records: We need to focus on female students, so we will filter the records where 'Sex' is 'F'.", "Group the results: To find the most common major, we will group the results by the 'Major' column.", "Count occurrences: For each major, we will count how many female students are enrolled in that major using COUNT(*).", "Order the results: We will order the results in descending order based on the count of students in each major to find the most common one.", "Limit the results: Since we only want the most common major, we will limit the results to 1."], "gold_sql": "SELECT Major FROM STUDENT WHERE Sex  =  'F' GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Major, COUNT(*) as MajorCount \nFROM Student \nWHERE Sex = 'F' \nGROUP BY Major \nORDER BY MajorCount DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct first and last names of students who voted for the presidential candidate, filtered by their gender. The placeholder in the WHERE clause represents the gender of the students.\",\n    \"1\": \"This virtual table provides a list of distinct first and last names of students from the 'Student' table who have voted for a presidential candidate, filtered by their gender. The placeholder in the WHERE clause represents the gender of the students.\"\n}\n"}
{"sample_id": "train.5511", "db_id": "voter_2", "question": "Find the major that is studied by the most female students.", "rationale": ["Identify the relevant table: The 'Student' table contains information about students, including their major and gender.", "Filter the records: We need to focus on female students, so we will filter the records where 'Sex' is 'Female'.", "Count the number of female students per major: We will use the COUNT function and group the results by 'Major'.", "Order the results: To find the major with the most female students, we will order the results in descending order based on the count of female students.", "Limit the results: Since we only want the major with the highest count, we will limit the results to 1."], "gold_sql": "SELECT Major FROM STUDENT WHERE Sex  =  'F' GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Major, COUNT(*) as Female_Count \nFROM Student \nWHERE Sex = 'Female' \nGROUP BY Major \nORDER BY Female_Count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct first and last names of students who voted for the presidential candidate, filtered by their gender. The placeholder in the WHERE clause represents the gender of the students.\",\n    \"1\": \"This virtual table provides a list of distinct first and last names of students from the 'Student' table who have voted for a presidential candidate, filtered by their gender. The placeholder in the WHERE clause represents the gender of the students.\",\n    \"2\": \"This virtual table describes the last names of students who have voted for a presidential candidate and are being advised by a specific academic advisor. The placeholder in the WHERE clause represents the advisor's name.\"\n}\n"}
{"sample_id": "train.5534", "db_id": "products_gen_characteristics", "question": "Find the number of products with category \"Spices\" and typically sold above 1000.", "rationale": ["Identify the relevant tables: Products and Ref_Product_Categories.", "We need to count the number of products, so we will use the COUNT() function.", "Join the Products table with the Ref_Product_Categories table on the product_category_code to filter by category.", "Add a WHERE clause to filter for products in the 'Spices' category.", "Add another condition in the WHERE clause to filter for products with a typical selling price greater than 1000."], "gold_sql": "SELECT count(*) FROM products WHERE product_category_code  =  'Spices' AND typical_buying_price  >  1000", "source_tables": ["products"], "pred_sql": "SELECT COUNT(*) AS product_count\nFROM Products\nJOIN Ref_Product_Categories ON Products.product_category_code = Ref_Product_Categories.product_category_code\nWHERE Ref_Product_Categories.product_category_description = 'Spices'\nAND Products.typical_selling_price > 1000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of products from the 'Products' table that belong to a specific product category and have a typical buying price above a certain threshold. The placeholders in the WHERE clause represent the product category code and the minimum buying price.\"\n}\n"}
{"sample_id": "train.5543", "db_id": "products_gen_characteristics", "question": "What are the descriptions of the categories that products with product descriptions that contain the letter t are in?", "rationale": ["Identify the relevant tables: We need to get product category descriptions, so we will use the Ref_Product_Categories table.", "Join the Products table with the Ref_Product_Categories table on the product_category_code to link products to their categories.", "Filter the products based on the condition that their product descriptions contain the letter 't'.", "Use the LIKE operator with wildcards to find product descriptions that contain 't'.", "Select distinct product category descriptions to avoid duplicates in the results."], "gold_sql": "SELECT T1.product_category_description FROM ref_product_categories AS T1 JOIN products AS T2 ON T1.product_category_code  =  T2.product_category_code WHERE T2.product_description LIKE '%t%'", "source_tables": ["products", "ref_product_categories"], "pred_sql": "SELECT DISTINCT rpc.product_category_description \nFROM Ref_Product_Categories rpc \nJOIN Products p ON rpc.product_category_code = p.product_category_code \nWHERE p.product_description LIKE '%t%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of products from the 'Products' table that belong to a specific product category and have a typical buying price above a certain threshold. The placeholders in the WHERE clause represent the product category code and the minimum buying price.\",\n    \"1\": \"This virtual table describes the names of products from the 'Products' table that are associated with a specific color and do not belong to a certain unit of measure. The placeholders in the WHERE clause represent the color description and the unit of measure respectively.\"\n}\n"}
{"sample_id": "train.5556", "db_id": "products_gen_characteristics", "question": "How many distinct characteristic names does the product \"cumin\" have?", "rationale": ["Identify the relevant tables: Products, Product_Characteristics, and Characteristics are needed to find the distinct characteristic names for the product 'cumin'.", "Use a JOIN to connect Products with Product_Characteristics on product_id, and then join Product_Characteristics with Characteristics on characteristic_id.", "Filter the results to only include the product with the name 'cumin' using a WHERE clause.", "Count the distinct characteristic names using COUNT(DISTINCT ...) to get the number of unique characteristic names associated with the product."], "gold_sql": "SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  'sesame'", "source_tables": ["products", "characteristics", "product_characteristics"], "pred_sql": "SELECT COUNT(DISTINCT Characteristics.characteristic_name) AS distinct_characteristic_count\nFROM Products\nJOIN Product_Characteristics ON Products.product_id = Product_Characteristics.product_id\nJOIN Characteristics ON Product_Characteristics.characteristic_id = Characteristics.characteristic_id\nWHERE Products.product_name = 'cumin';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of products from the 'Products' table that are associated with a specific color and do not belong to a certain unit of measure. The placeholders in the WHERE clause represent the color description and the unit of measure respectively.\"\n}\n"}
{"sample_id": "train.5577", "db_id": "products_gen_characteristics", "question": "How many products have their color described as 'white' or have a characteristic with the name 'hot'?", "rationale": ["Identify the tables involved: Products, Product_Characteristics, Characteristics, and Ref_Colors.", "We need to count products that either have a color described as 'white' or have a characteristic named 'hot'.", "To find products with the color 'white', we will join the Products table with the Ref_Colors table to filter by color description.", "To find products with the characteristic 'hot', we will join the Products table with Product_Characteristics and then with Characteristics to filter by characteristic name.", "Use COUNT(DISTINCT p.product_id) to ensure we count each product only once, even if it meets both conditions.", "Combine the conditions using an OR clause in the WHERE statement."], "gold_sql": "SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  'white' OR t3.characteristic_name  =  'hot'", "source_tables": ["products", "ref_colors", "characteristics", "product_characteristics"], "pred_sql": "SELECT COUNT(DISTINCT p.product_id) \nFROM Products p \nLEFT JOIN Product_Characteristics pc ON p.product_id = pc.product_id \nLEFT JOIN Characteristics c ON pc.characteristic_id = c.characteristic_id \nWHERE p.color_code = (SELECT color_code FROM Ref_Colors WHERE color_description = 'white') \n   OR c.characteristic_name = 'hot';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of products from the 'Products' table that are associated with a specific color and do not belong to a certain unit of measure. The placeholders in the WHERE clause represent the color description and the unit of measure respectively.\",\n    \"1\": \"This virtual table provides a count of products from the 'Products' table that belong to a specific product category and have a typical buying price above a certain threshold. The placeholders in the WHERE clause represent the product category code and the minimum buying price.\"\n}\n"}
{"sample_id": "train.5579", "db_id": "products_gen_characteristics", "question": "Return the unit of measure for 'Herb' products.", "rationale": ["Identify the relevant tables: We need to find the unit of measure for 'Herb' products, which involves the Products table and the Ref_Product_Categories table.", "Determine the relationship: The Products table has a foreign key relationship with the Ref_Product_Categories table through the product_category_code.", "Formulate the query: We will select the unit_of_measure from Ref_Product_Categories and join it with Products on product_category_code.", "Filter the results: We need to filter the products to only those that have 'Herb' in their product name using a LIKE clause."], "gold_sql": "SELECT unit_of_measure FROM ref_product_categories WHERE product_category_code  =  'Herbs'", "source_tables": ["ref_product_categories"], "pred_sql": "SELECT pc.unit_of_measure \nFROM Ref_Product_Categories pc \nJOIN Products p ON pc.product_category_code = p.product_category_code \nWHERE p.product_name LIKE '%Herb%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of products from the 'Products' table that are associated with a specific color and do not belong to a certain unit of measure. The placeholders in the WHERE clause represent the color description and the unit of measure respectively.\",\n    \"1\": \"This virtual table provides a count of products from the 'Products' table that belong to a specific product category and have a typical buying price above a certain threshold. The placeholders in the WHERE clause represent the product category code and the minimum buying price.\"\n}\n"}
{"sample_id": "train.5586", "db_id": "products_gen_characteristics", "question": "Find the unit of measurement and product category code of product named \"chervil\".", "rationale": ["Identify the relevant tables: Products and Ref_Product_Categories.", "We need to find the unit of measurement and product category code for a specific product named 'chervil'.", "The product category code is in the Ref_Product_Categories table, and we can join it with the Products table using the product_category_code.", "We will filter the results by the product name 'chervil' in the Products table.", "Select the required fields: product_category_code and unit_of_measure from the joined tables."], "gold_sql": "SELECT t2.unit_of_measure ,  t2.product_category_code FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code WHERE t1.product_name  =  'chervil'", "source_tables": ["products", "ref_product_categories"], "pred_sql": "SELECT pc.product_category_code, p.product_category_code\nFROM Products p\nJOIN Ref_Product_Categories pc ON p.product_category_code = pc.product_category_code\nWHERE p.product_name = 'chervil';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of products from the 'Products' table that belong to a specific product category and have a typical buying price above a certain threshold. The placeholders in the WHERE clause represent the product category code and the minimum buying price.\",\n    \"1\": \"This virtual table describes the names of products from the 'Products' table that are associated with a specific color and do not belong to a certain unit of measure. The placeholders in the WHERE clause represent the color description and the unit of measure respectively.\"\n}\n"}
{"sample_id": "train.5590", "db_id": "products_gen_characteristics", "question": "What is the description of the color for most products?", "rationale": ["Identify the relevant tables: Products and Ref_Colors are needed to get product descriptions and their associated colors.", "Join the Products table with the Ref_Colors table on the color_code to access color descriptions for each product.", "Group the results by color description to count how many products are associated with each color.", "Order the results by the count of products in descending order to find the color associated with the most products.", "Limit the results to 1 to get only the top color description."], "gold_sql": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) DESC LIMIT 1", "source_tables": ["products", "ref_colors"], "pred_sql": "SELECT Ref_Colors.color_description, COUNT(Products.product_id) AS product_count\nFROM Products\nJOIN Ref_Colors ON Products.color_code = Ref_Colors.color_code\nGROUP BY Ref_Colors.color_description\nORDER BY product_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of products from the 'Products' table that are associated with a specific color and do not belong to a certain unit of measure. The placeholders in the WHERE clause represent the color description and the unit of measure respectively.\",\n    \"1\": \"This virtual table provides a count of products from the 'Products' table that belong to a specific product category and have a typical buying price above a certain threshold. The placeholders in the WHERE clause represent the product category code and the minimum buying price.\"\n}\n"}
{"sample_id": "train.5592", "db_id": "products_gen_characteristics", "question": "What is the description of the color used by least products?", "rationale": ["We need to find the color description used by the least number of products.", "To do this, we will join the Ref_Colors table with the Products table on the color_code.", "We will group the results by color_code to count how many products are associated with each color.", "Next, we will order the results in ascending order based on the count of products, so that the color with the least products comes first.", "Finally, we will limit the results to just one entry to get the color description used by the least products."], "gold_sql": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) ASC LIMIT 1", "source_tables": ["products", "ref_colors"], "pred_sql": "SELECT c.color_description\nFROM Ref_Colors c\nJOIN Products p ON c.color_code = p.color_code\nGROUP BY c.color_code\nORDER BY COUNT(p.product_id) ASC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of products from the 'Products' table that are associated with a specific color and do not belong to a certain unit of measure. The placeholders in the WHERE clause represent the color description and the unit of measure respectively.\"\n}\n"}
{"sample_id": "train.5599", "db_id": "products_gen_characteristics", "question": "Give the names of characteristics that are in two or more products?", "rationale": ["We need to find the names of characteristics that are associated with two or more products.", "To do this, we will join the 'Characteristics' table with the 'Product_Characteristics' table using the 'characteristic_id'.", "Next, we will group the results by 'characteristic_name' to aggregate the data for each characteristic.", "We will use the HAVING clause to filter the groups, ensuring that we only include those characteristics that are linked to two or more distinct products (using COUNT(DISTINCT pc.product_id))."], "gold_sql": "SELECT t3.characteristic_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id GROUP BY t3.characteristic_name HAVING count(*)  >= 2", "source_tables": ["products", "characteristics", "product_characteristics"], "pred_sql": "SELECT c.characteristic_name\nFROM Characteristics c\nJOIN Product_Characteristics pc ON c.characteristic_id = pc.characteristic_id\nGROUP BY c.characteristic_name\nHAVING COUNT(DISTINCT pc.product_id) >= 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of products from the 'Products' table that are associated with a specific color and do not belong to a certain unit of measure. The placeholders in the WHERE clause represent the color description and the unit of measure respectively.\",\n    \"1\": \"This virtual table provides a count of products from the 'Products' table that belong to a specific product category and have a typical buying price above a certain threshold. The placeholders in the WHERE clause represent the product category code and the minimum buying price.\"\n}\n"}
{"sample_id": "train.5633", "db_id": "railway", "question": "List the builders of railways in ascending alphabetical order.", "rationale": ["Identify the relevant table: The 'railway' table contains the 'Builder' column which we need to query.", "Select the 'Builder' column: We want to list the builders, so we will select this column.", "Use DISTINCT to avoid duplicate entries: Since multiple railways can have the same builder, we will use DISTINCT to ensure each builder is listed only once.", "Order the results: We need the results in ascending alphabetical order, so we will use ORDER BY Builder ASC.", "Construct the SQL query: Combine all the elements into a complete SQL query."], "gold_sql": "SELECT Builder FROM railway ORDER BY Builder ASC", "source_tables": ["railway"], "pred_sql": "SELECT DISTINCT Builder FROM railway ORDER BY Builder ASC;", "hint": "\n"}
{"sample_id": "train.5643", "db_id": "railway", "question": "Show the id and builder of the railway that are associated with the most trains.", "rationale": ["Identify the relevant tables: railway and train.", "We need to find the railway associated with the most trains, so we will join the railway table with the train table on the Railway_ID.", "We will group the results by Railway_ID and Builder to count the number of trains associated with each railway.", "Use COUNT(train.Train_ID) to count the number of trains for each railway.", "Order the results in descending order based on the count of trains to get the railway with the most trains at the top.", "Limit the results to 1 to get only the railway associated with the most trains."], "gold_sql": "SELECT T2.Railway_ID ,  T1.Builder FROM railway AS T1 JOIN train AS T2 ON T1.Railway_ID  =  T2.Railway_ID GROUP BY T2.Railway_ID ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["train", "railway"], "pred_sql": "SELECT railway.Railway_ID, railway.Builder\nFROM railway\nJOIN train ON railway.Railway_ID = train.Railway_ID\nGROUP BY railway.Railway_ID, railway.Builder\nORDER BY COUNT(train.Train_ID) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5645", "db_id": "railway", "question": "Show the most common builder of railways.", "rationale": ["We need to find the most common builder of railways, which means we need to count how many railways each builder has constructed.", "To do this, we will select the 'Builder' column from the 'railway' table and use the COUNT function to count the occurrences of each builder.", "We will group the results by the 'Builder' to aggregate the counts for each builder.", "Next, we will order the results in descending order based on the count of railways built by each builder.", "Finally, we will limit the results to only the top entry to get the most common builder."], "gold_sql": "SELECT Builder FROM railway GROUP BY Builder ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["railway"], "pred_sql": "SELECT Builder, COUNT(*) as BuilderCount \nFROM railway \nGROUP BY Builder \nORDER BY BuilderCount DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5707", "db_id": "dorm_1", "question": "What is the last name of every student who is either female or living in a city with the code BAL or male and under 20?", "rationale": ["Identify the relevant table: The 'Student' table contains the last names and other details of students.", "Determine the criteria for selection: We need students who are either female, live in a city with the code 'BAL', or are male and under 20 years old.", "Construct the WHERE clause: The conditions can be combined using OR operators to filter the students based on the specified criteria.", "Select the last names: We only need the last names of the students that meet the criteria, so we will select the 'LName' column."], "gold_sql": "SELECT lname FROM student WHERE sex  =  'F' AND city_code  =  'BAL' UNION SELECT lname FROM student WHERE sex  =  'M' AND age  <  20", "source_tables": ["student"], "pred_sql": "SELECT LName FROM Student WHERE (Sex = 'Female' OR city_code = 'BAL' OR (Sex = 'Male' AND Age < '20'));", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of last names of students from the 'Student' table based on specific criteria. It includes students of a certain gender residing in a specific city, as well as students of the same gender who are younger than a specified age. The placeholders in the WHERE clauses represent the gender, city code, and age criteria.\",\n    \"1\": \"This virtual table provides a summary of the number of students and their average age, grouped by the city code, for a specific gender. The placeholder in the WHERE clause represents the gender of the students being queried.\"\n}\n"}
{"sample_id": "train.5738", "db_id": "dorm_1", "question": "Find the number of amenities for each of the dorms that can accommodate more than 100 students.", "rationale": ["Identify the relevant tables: Dorm and Has_amenity are needed to find the number of amenities for each dorm.", "We need to count the amenities, so we will use COUNT() function on the amenity identifier from Has_amenity table.", "We need to filter dorms based on their capacity, specifically those that can accommodate more than 100 students, which is done using a WHERE clause.", "We will join the Dorm table with the Has_amenity table on the dormid to link dorms with their amenities.", "Finally, we will group the results by dorm_name to get the count of amenities for each dorm."], "gold_sql": "SELECT count(*) ,  T1.dormid FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid WHERE T1.student_capacity  >  100 GROUP BY T1.dormid", "source_tables": ["has_amenity", "dorm"], "pred_sql": "SELECT d.dorm_name, COUNT(ha.amenid) AS amenity_count\nFROM Dorm d\nJOIN Has_amenity ha ON d.dormid = ha.dormid\nWHERE d.student_capacity > 100\nGROUP BY d.dorm_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of amenities available in dormitories that can accommodate more than a specified number of students. The placeholder in the WHERE clause represents the minimum student capacity for filtering the dormitories.\",\n    \"1\": \"This virtual table provides the names and gender designations of dormitories from the 'Dorm' table that have a student capacity exceeding or falling below a specified number. The placeholders in the WHERE clause represent the capacity limits for filtering the dormitories.\"\n}\n"}
{"sample_id": "train.5747", "db_id": "dorm_1", "question": "What are the total number of students who are living in a male dorm?", "rationale": ["Identify the tables involved: We need to count students living in male dorms, so we will use the 'Lives_in' and 'Dorm' tables.", "Determine the relationship: The 'Lives_in' table links students to dorms, and the 'Dorm' table contains gender information.", "Filter for male dorms: We will add a WHERE clause to filter dorms where the gender is 'male'.", "Count the distinct students: We will use COUNT(DISTINCT Lives_in.stuid) to get the total number of unique students living in male dorms."], "gold_sql": "SELECT count(*) FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T3.gender  =  'M'", "source_tables": ["student", "lives_in", "dorm"], "pred_sql": "SELECT COUNT(DISTINCT Lives_in.stuid) AS total_students\nFROM Lives_in\nJOIN Dorm ON Lives_in.dormid = Dorm.dormid\nWHERE Dorm.gender = 'male';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and gender designations of dormitories from the 'Dorm' table that have a student capacity exceeding or falling below a specified number. The placeholders in the WHERE clause represent the capacity limits for filtering the dormitories.\",\n    \"1\": \"This virtual table provides a count of amenities available in dormitories that can accommodate more than a specified number of students. The placeholder in the WHERE clause represents the minimum student capacity for filtering the dormitories.\",\n    \"2\": \"This virtual table provides a summary of the number of students and their average age, grouped by the city code, for a specific gender. The placeholder in the WHERE clause represents the gender of the students being queried.\"\n}\n"}
{"sample_id": "train.5756", "db_id": "dorm_1", "question": "Find the first name of students who are living in the dorm that has most number of amenities.", "rationale": ["Identify the dormitory with the most amenities by counting the number of amenities associated with each dormitory using the Has_amenity table.", "Use a subquery to select the dormid of the dormitory that has the maximum count of amenities, ordering the results in descending order and limiting the output to the top result.", "Select the students who live in that dormitory by joining the Lives_in table with the identified dormid.", "Finally, retrieve the first names of those students from the Student table using their StuID."], "gold_sql": "SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["has_amenity", "lives_in", "student", "dorm_amenity", "dorm"], "pred_sql": "SELECT Fname \nFROM Student \nWHERE StuID IN (\n    SELECT stuid \n    FROM Lives_in \n    WHERE dormid = (\n        SELECT dormid \n        FROM Has_amenity \n        GROUP BY dormid \n        ORDER BY COUNT(amenid) DESC \n        LIMIT 1\n    )\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of amenities available in dormitories that can accommodate more than a specified number of students. The placeholder in the WHERE clause represents the minimum student capacity for filtering the dormitories.\",\n    \"1\": \"This virtual table provides the names and gender designations of dormitories from the 'Dorm' table that have a student capacity exceeding or falling below a specified number. The placeholders in the WHERE clause represent the capacity limits for filtering the dormitories.\"\n}\n"}
{"sample_id": "train.5765", "db_id": "dorm_1", "question": "What is the first name and age of every student who lives in a dorm with a TV Lounge?", "rationale": ["Identify the required fields: first name and age of students.", "Determine the relationships between tables: Student, Lives_in, Dorm, Has_amenity, and Dorm_amenity.", "Join the Student table with Lives_in to get the dormitory information for each student.", "Join the Lives_in table with Dorm to access dormitory details.", "Join the Dorm table with Has_amenity to filter dorms based on amenities.", "Join Has_amenity with Dorm_amenity to specify the amenity we are interested in (TV Lounge).", "Use a WHERE clause to filter results to only those dorms that have a TV Lounge."], "gold_sql": "SELECT T1.fname ,  T1.age FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid NOT IN (SELECT T3.dormid FROM has_amenity AS T3 JOIN dorm_amenity AS T4 ON T3.amenid  =  T4.amenid WHERE T4.amenity_name  =  'TV Lounge')", "source_tables": ["has_amenity", "student", "lives_in", "dorm_amenity"], "pred_sql": "SELECT Student.Fname, Student.Age \nFROM Student \nJOIN Lives_in ON Student.StuID = Lives_in.stuid \nJOIN Dorm ON Lives_in.dormid = Dorm.dormid \nJOIN Has_amenity ON Dorm.dormid = Has_amenity.dormid \nJOIN Dorm_amenity ON Has_amenity.amenid = Dorm_amenity.amenid \nWHERE Dorm_amenity.amenity_name = 'TV Lounge';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and gender designations of dormitories from the 'Dorm' table that have a student capacity exceeding or falling below a specified number. The placeholders in the WHERE clause represent the capacity limits for filtering the dormitories.\",\n    \"1\": \"This virtual table provides a count of amenities available in dormitories that can accommodate more than a specified number of students. The placeholder in the WHERE clause represents the minimum student capacity for filtering the dormitories.\",\n    \"2\": \"This virtual table provides a summary of the number of students and their average age, grouped by the city code, for a specific gender. The placeholder in the WHERE clause represents the gender of the students being queried.\"\n}\n"}
{"sample_id": "train.5777", "db_id": "customer_complaints", "question": "What are the emails of customers who have filed complaints on the product which has had the greatest number of complaints?", "rationale": ["Identify the goal: We need to find the emails of customers who filed complaints about the product with the greatest number of complaints.", "To achieve this, we will need to join the Customers table with the Complaints table on the customer_id.", "Next, we need to determine which product has the greatest number of complaints. This can be done by grouping the Complaints table by product_id and counting the number of complaints for each product.", "We will order the results of this grouping in descending order and limit the results to 1 to get the product with the highest count of complaints.", "Finally, we will use this product_id in our main query to filter the customers who complained about that product and select their email addresses."], "gold_sql": "SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "customers"], "pred_sql": "SELECT c.email_address\nFROM Customers c\nJOIN Complaints comp ON c.customer_id = comp.customer_id\nWHERE comp.product_id = (\n    SELECT product_id\n    FROM Complaints\n    GROUP BY product_id\n    ORDER BY COUNT(*) DESC\n    LIMIT 1\n);", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the distinct product names from the 'Products' table that are associated with complaints made by customers. It joins the 'Products' table with the 'Complaints' table based on the product identifier and groups the results by customer identifier to count the number of complaints per customer. The placeholder in the LIMIT clause represents the maximum number of distinct product names to return.\"\n}\n"}
{"sample_id": "train.5778", "db_id": "customer_complaints", "question": "Which products has been complained by the customer who has filed least amount of complaints?", "rationale": ["Identify the customer who has filed the least amount of complaints by grouping the Complaints table by customer_id and counting the number of complaints for each customer.", "Order the results of the previous step in ascending order based on the count of complaints and limit the result to 1 to get the customer with the least complaints.", "Join the Products table with the Complaints table on the product_id to find the products associated with the complaints made by the identified customer.", "Select the product names from the Products table where the customer_id matches the one identified in the previous steps."], "gold_sql": "SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "products", "customers"], "pred_sql": "SELECT p.product_name \nFROM Products p \nJOIN Complaints c ON p.product_id = c.product_id \nWHERE c.customer_id = (\n    SELECT customer_id \n    FROM Complaints \n    GROUP BY customer_id \n    ORDER BY COUNT(complaint_id) ASC \n    LIMIT 1\n)\nGROUP BY p.product_id;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the distinct product names from the 'Products' table that are associated with complaints made by customers. It joins the 'Products' table with the 'Complaints' table based on the product identifier and groups the results by customer identifier to count the number of complaints per customer. The placeholder in the LIMIT clause represents the maximum number of distinct product names to return.\"\n}\n"}
{"sample_id": "train.5795", "db_id": "customer_complaints", "question": "What is the last name of the staff member in charge of the complaint on the product with the lowest price?", "rationale": ["Identify the tables involved: Staff, Complaints, and Products.", "We need to find the last name of the staff member handling a complaint related to the product with the lowest price.", "To do this, we will join the Staff table with the Complaints table on staff_id, and then join the Complaints table with the Products table on product_id.", "Next, we need to find the product with the lowest price. This can be done using a subquery that selects the minimum product_price from the Products table.", "Finally, we will filter the results to only include the staff member associated with the complaint for that product and select their last name."], "gold_sql": "SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT 1", "source_tables": ["complaints", "products", "staff"], "pred_sql": "SELECT Staff.last_name \nFROM Staff \nJOIN Complaints ON Staff.staff_id = Complaints.staff_id \nJOIN Products ON Complaints.product_id = Products.product_id \nWHERE Products.product_price = (\n    SELECT MIN(product_price) \n    FROM Products\n)", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the distinct product names from the 'Products' table that are associated with complaints made by customers. It joins the 'Products' table with the 'Complaints' table based on the product identifier and groups the results by customer identifier to count the number of complaints per customer. The placeholder in the LIMIT clause represents the maximum number of distinct product names to return.\"\n}\n"}
{"sample_id": "train.5796", "db_id": "customer_complaints", "question": "Which complaint status has more than 3 records on file?", "rationale": ["Identify the relevant table: The Complaints table contains the complaint status information.", "Determine the required information: We need to find complaint statuses that have more than 3 records.", "Group the results: Use GROUP BY to group the records by complaint_status_code.", "Count the records: Use COUNT(*) to count the number of records for each complaint status.", "Filter the results: Use HAVING to filter the groups to only include those with a count greater than 3."], "gold_sql": "SELECT complaint_status_code FROM complaints GROUP BY complaint_status_code HAVING count(*)  >  3", "source_tables": ["complaints"], "pred_sql": "SELECT complaint_status_code, COUNT(*) as complaint_count \nFROM Complaints \nGROUP BY complaint_status_code \nHAVING COUNT(*) > 3;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the distinct product names from the 'Products' table that are associated with complaints made by customers. It joins the 'Products' table with the 'Complaints' table based on the product identifier and groups the results by customer identifier to count the number of complaints per customer. The placeholder in the LIMIT clause represents the maximum number of distinct product names to return.\"\n}\n"}
{"sample_id": "train.5801", "db_id": "customer_complaints", "question": "Count the number of customers that have the customer type that is most common.", "rationale": ["Identify the most common customer type by grouping the Customers table by customer_type_code and counting occurrences.", "Use a subquery to find the customer_type_code that has the highest count.", "Count the total number of customers that have this most common customer_type_code."], "gold_sql": "SELECT count(*) FROM customers GROUP BY customer_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers"], "pred_sql": "SELECT COUNT(*) AS customer_count\nFROM Customers\nWHERE customer_type_code = (\n    SELECT customer_type_code\n    FROM Customers\n    GROUP BY customer_type_code\n    ORDER BY COUNT(*) DESC\n    LIMIT 1\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique town or city names from the 'Customers' table, filtered by a specific customer type code. The results are grouped by town or city and ordered by the count of occurrences, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the customer type code and the maximum number of results to display.\"\n}\n"}
{"sample_id": "train.5810", "db_id": "customer_complaints", "question": "What is first names of the top 5 staff who have handled the greatest number of complaints?", "rationale": ["Identify the relevant tables: Staff and Complaints.", "We need to find the first names of staff members, so we will select the 'first_name' column from the Staff table.", "To determine how many complaints each staff member has handled, we will join the Staff table with the Complaints table on the 'staff_id' column.", "We will group the results by 'staff_id' to aggregate the number of complaints handled by each staff member.", "We will use the COUNT function to count the number of complaints for each staff member.", "To get the top 5 staff members who handled the greatest number of complaints, we will order the results in descending order based on the count of complaints and limit the results to 5."], "gold_sql": "SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT 5", "source_tables": ["complaints", "staff"], "pred_sql": "SELECT first_name \nFROM Staff \nJOIN Complaints ON Staff.staff_id = Complaints.staff_id \nGROUP BY Staff.staff_id \nORDER BY COUNT(Complaints.complaint_id) DESC \nLIMIT 5;", "hint": "\n"}
{"sample_id": "train.5811", "db_id": "customer_complaints", "question": "Return the first names of the 5 staff members who have handled the most complaints.", "rationale": ["Identify the relevant tables: Staff and Complaints.", "We need to join these tables on the staff_id to link staff members with the complaints they have handled.", "We want to count the number of complaints each staff member has handled, so we will use COUNT(Complaints.complaint_id).", "We will group the results by Staff.staff_id to get the count for each staff member.", "To find the staff members who have handled the most complaints, we will order the results in descending order based on the count of complaints.", "Finally, we will limit the results to the top 5 staff members."], "gold_sql": "SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT 5", "source_tables": ["complaints", "staff"], "pred_sql": "SELECT first_name FROM Staff \nJOIN Complaints ON Staff.staff_id = Complaints.staff_id \nGROUP BY Staff.staff_id \nORDER BY COUNT(Complaints.complaint_id) DESC \nLIMIT 5;", "hint": "\n"}
{"sample_id": "train.5845", "db_id": "tracking_share_transactions", "question": "Show all investor details.", "rationale": ["The user wants to see all investor details, which means we need to select all columns from the Investors table.", "The SQL command to retrieve all columns from a table is 'SELECT *'.", "We specify the table we are selecting from, which in this case is 'Investors'."], "gold_sql": "SELECT Investor_details FROM INVESTORS", "source_tables": ["investors"], "pred_sql": "SELECT * FROM Investors;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of transactions for each investor from the 'Transactions' table, filtered by a specific transaction type. The placeholder in the WHERE clause represents the transaction type code.\"\n}\n"}
{"sample_id": "train.5858", "db_id": "tracking_share_transactions", "question": "Show details of all investors if they make any transaction with share count greater than 100.", "rationale": ["We need to show details of all investors who have made transactions with a share count greater than 100.", "To do this, we will select the investor_id and Investor_details from the Investors table.", "We will join the Investors table with the Transactions table on the investor_id to link investors with their transactions.", "We will apply a filter in the WHERE clause to only include transactions where the share_count is greater than 100."], "gold_sql": "SELECT T1.Investor_details FROM  INVESTORS AS T1 JOIN TRANSACTIONS AS T2 ON T1.investor_id  =  T2.investor_id WHERE T2.share_count  >  100", "source_tables": ["transactions", "investors"], "pred_sql": "SELECT Investors.investor_id, Investors.Investor_details \nFROM Investors \nJOIN Transactions ON Investors.investor_id = Transactions.investor_id \nWHERE Transactions.share_count > 100;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of transactions for each investor from the 'Transactions' table, filtered by a specific transaction type. The placeholder in the WHERE clause represents the transaction type code.\"\n}\n"}
{"sample_id": "train.5864", "db_id": "tracking_share_transactions", "question": "What are the lot details of lots associated with transactions with share count smaller than 50?", "rationale": ["Identify the relevant tables: Lots and Transactions.", "Determine the relationship between Lots and Transactions through the Transactions_Lots table.", "We need to select the lot details from the Lots table.", "Join the Lots table with the Transactions_Lots table on lot_id.", "Join the Transactions_Lots table with the Transactions table on transaction_id.", "Apply the filter for share count smaller than 50 in the WHERE clause."], "gold_sql": "SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  <  50", "source_tables": ["lots", "transactions_lots", "transactions"], "pred_sql": "SELECT Lots.lot_details \nFROM Lots \nJOIN Transactions_Lots ON Lots.lot_id = Transactions_Lots.lot_id \nJOIN Transactions ON Transactions_Lots.transaction_id = Transactions.transaction_id \nWHERE Transactions.share_count < 50;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of transactions for each investor from the 'Transactions' table, filtered by a specific transaction type. The placeholder in the WHERE clause represents the transaction type code.\"\n}\n"}
{"sample_id": "train.5866", "db_id": "tracking_share_transactions", "question": "Show the average transaction amount for different transaction types.", "rationale": ["We need to calculate the average transaction amount for different transaction types.", "To do this, we will select the transaction type description from the Ref_Transaction_Types table and the average of the transaction amounts from the Transactions table.", "We will join the Transactions table with the Ref_Transaction_Types table on the transaction_type_code to get the descriptions of the transaction types.", "We will use the AVG() function to calculate the average amount of transactions.", "Finally, we will group the results by the transaction type description to get the average for each type."], "gold_sql": "SELECT transaction_type_code ,  avg(amount_of_transaction) FROM TRANSACTIONS GROUP BY transaction_type_code", "source_tables": ["transactions"], "pred_sql": "SELECT rt.transaction_type_description, AVG(t.amount_of_transaction) AS average_transaction_amount\nFROM Transactions t\nJOIN Ref_Transaction_Types rt ON t.transaction_type_code = rt.transaction_type_code\nGROUP BY rt.transaction_type_description;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of transactions for each investor from the 'Transactions' table, filtered by a specific transaction type. The placeholder in the WHERE clause represents the transaction type code.\"\n}\n"}
{"sample_id": "train.5867", "db_id": "tracking_share_transactions", "question": "Show the maximum and minimum share count of different transaction types.", "rationale": ["We need to show the maximum and minimum share count of different transaction types.", "To achieve this, we will select the transaction type description from the Ref_Transaction_Types table.", "We will also select the maximum and minimum share count from the Transactions table.", "To link these two tables, we will use a JOIN on the transaction_type_code.", "We will group the results by the transaction type description to get the max and min share counts for each type."], "gold_sql": "SELECT transaction_type_code ,  max(share_count) ,  min(share_count) FROM TRANSACTIONS GROUP BY transaction_type_code", "source_tables": ["transactions"], "pred_sql": "SELECT rt.transaction_type_description, MAX(t.share_count) AS max_share_count, MIN(t.share_count) AS min_share_count\nFROM Transactions t\nJOIN Ref_Transaction_Types rt ON t.transaction_type_code = rt.transaction_type_code\nGROUP BY rt.transaction_type_description;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of transactions for each investor from the 'Transactions' table, filtered by a specific transaction type. The placeholder in the WHERE clause represents the transaction type code.\"\n}\n"}
{"sample_id": "train.5883", "db_id": "tracking_share_transactions", "question": "What are the details of all sales and purchases?", "rationale": ["Identify the tables involved: Sales and Purchases.", "Determine the columns needed: sales_transaction_id and sales_details from Sales, purchase_transaction_id and purchase_details from Purchases.", "Since we want details of all sales and purchases, we will use a FULL OUTER JOIN to include all records from both tables, even if there are no matches in the other table.", "Construct the SQL query to select the required columns from both tables using the FULL OUTER JOIN."], "gold_sql": "SELECT sales_details FROM sales UNION SELECT purchase_details FROM purchases", "source_tables": ["sales", "purchases"], "pred_sql": "SELECT Sales.sales_transaction_id, Sales.sales_details, Purchases.purchase_transaction_id, Purchases.purchase_details\nFROM Sales\nFULL OUTER JOIN Purchases ON Sales.sales_transaction_id = Purchases.purchase_transaction_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of transactions for each investor from the 'Transactions' table, filtered by a specific transaction type. The placeholder in the WHERE clause represents the transaction type code.\"\n}\n"}
{"sample_id": "train.5898", "db_id": "cre_Theme_park", "question": "What is the average price range of five star hotels that allow pets?", "rationale": ["Identify the relevant table: The Hotels table contains information about hotel star ratings, pet policies, and price ranges.", "Determine the conditions: We need to filter for five-star hotels (star_rating_code = '5') and those that allow pets (pets_allowed_yn = 'Yes').", "Calculate the average price range: Use the AVG() function to compute the average of the price_range column for the filtered hotels."], "gold_sql": "SELECT avg(price_range) FROM HOTELS WHERE star_rating_code  =  '5' AND pets_allowed_yn  =  1", "source_tables": ["hotels"], "pred_sql": "SELECT AVG(price_range) AS average_price_range \nFROM Hotels \nWHERE star_rating_code = '5' AND pets_allowed_yn = 'Yes';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, identified by their details, while excluding those attractions that have also been visited by another tourist with the same details. The placeholders in the query represent the tourist's details for filtering purposes.\"\n}\n"}
{"sample_id": "train.5904", "db_id": "cre_Theme_park", "question": "Find all the locations whose names contain the word \"film\".", "rationale": ["Identify the table that contains location names: Locations.", "Determine the column that holds the names of the locations: Location_Name.", "Use the SQL SELECT statement to retrieve all columns from the Locations table.", "Apply a WHERE clause to filter the results where Location_Name contains the word 'film'.", "Use the LIKE operator with wildcards '%' to match any location names that include 'film' anywhere in the name."], "gold_sql": "SELECT Location_Name FROM LOCATIONS WHERE Location_Name LIKE '%film%'", "source_tables": ["locations"], "pred_sql": "SELECT * FROM Locations WHERE Location_Name LIKE '%film%';", "hint": "\n"}
{"sample_id": "train.5915", "db_id": "cre_Theme_park", "question": "What are the details and opening hours of the museums?", "rationale": ["Identify the relevant tables: Museums and Tourist_Attractions.", "Determine the columns needed: Museum_ID and Museum_Details from Museums, and Opening_Hours from Tourist_Attractions.", "Establish the relationship between the tables: Museums are linked to Tourist_Attractions through the Tourist_Attraction_ID.", "Construct the SQL query to select the required details from the joined tables."], "gold_sql": "SELECT T1.Museum_Details ,  T2.Opening_Hours FROM MUSEUMS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Museum_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["tourist_attractions", "museums"], "pred_sql": "SELECT Museums.Museum_ID, Museums.Museum_Details, Tourist_Attractions.Opening_Hours \nFROM Museums \nJOIN Tourist_Attractions ON Museums.Museum_ID = Tourist_Attractions.Tourist_Attraction_ID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n    \"1\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, identified by their details, while excluding those attractions that have also been visited by another tourist with the same details. The placeholders in the query represent the tourist's details for filtering purposes.\",\n    \"2\": \"This virtual table provides a summary of tourist attractions along with the count of visits for each attraction. It combines data from the 'Tourist_Attractions' table and the 'Visits' table, grouping the results by the unique identifier of each tourist attraction. The placeholders represent the specific details of the attractions and the count of visits associated with them.\"\n}\n"}
{"sample_id": "train.5916", "db_id": "cre_Theme_park", "question": "Give me the detail and opening hour for each museum.", "rationale": ["The user wants details and opening hours for each museum.", "The relevant table for museum details is 'Museums', which contains 'Museum_Details'.", "The 'Tourist_Attractions' table contains the 'Opening_Hours' for each attraction, including museums.", "To get the opening hours for each museum, we need to join the 'Museums' table with the 'Tourist_Attractions' table on the common identifier, which is 'Museum_ID' in 'Museums' and 'Tourist_Attraction_ID' in 'Tourist_Attractions'.", "The final SQL query selects the museum details and their corresponding opening hours."], "gold_sql": "SELECT T1.Museum_Details ,  T2.Opening_Hours FROM MUSEUMS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Museum_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["tourist_attractions", "museums"], "pred_sql": "SELECT Museums.Museum_Details, Tourist_Attractions.Opening_Hours \nFROM Museums \nJOIN Tourist_Attractions ON Museums.Museum_ID = Tourist_Attractions.Tourist_Attraction_ID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n    \"1\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, identified by their details, while excluding those attractions that have also been visited by another tourist with the same details. The placeholders in the query represent the tourist's details for filtering purposes.\",\n    \"2\": \"This virtual table provides a summary of tourist attractions along with the count of visits for each attraction. It combines data from the 'Tourist_Attractions' table and the 'Visits' table, grouping the results by the unique identifier of each tourist attraction. The placeholders represent the specific details of the attractions and the count of visits associated with them.\"\n}\n"}
{"sample_id": "train.5922", "db_id": "cre_Theme_park", "question": "Which tourist attractions are related to royal family? Tell me their details and how we can get there.", "rationale": ["Identify the relevant tables: Tourist_Attractions and Royal_Family.", "Determine the relationship between the tables: Royal_Family entries are linked to Tourist_Attractions through the Tourist_Attraction_ID.", "Select the desired columns: Name, Description, and How_to_Get_There from the Tourist_Attractions table.", "Construct the SQL query using a JOIN to combine the Tourist_Attractions and Royal_Family tables based on the relationship."], "gold_sql": "SELECT T1.Royal_Family_Details ,  T2.How_to_Get_There FROM ROYAL_FAMILY AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Royal_Family_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["royal_family", "tourist_attractions"], "pred_sql": "SELECT Tourist_Attractions.Name, Tourist_Attractions.Description, Tourist_Attractions.How_to_Get_There \nFROM Tourist_Attractions \nJOIN Royal_Family ON Tourist_Attractions.Tourist_Attraction_ID = Royal_Family.Royal_Family_ID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, identified by their details, while excluding those attractions that have also been visited by another tourist with the same details. The placeholders in the query represent the tourist's details for filtering purposes.\",\n    \"1\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n    \"2\": \"This virtual table provides a summary of tourist attractions along with the count of visits for each attraction. It combines data from the 'Tourist_Attractions' table and the 'Visits' table, grouping the results by the unique identifier of each tourist attraction. The placeholders represent the specific details of the attractions and the count of visits associated with them.\"\n}\n"}
{"sample_id": "train.5923", "db_id": "cre_Theme_park", "question": "What are the details of the shops that can be accessed by walk?", "rationale": ["Identify the relevant table for shops, which is the 'Shops' table.", "Determine the relationship between shops and tourist attractions, which is through the 'Tourist_Attraction_ID'.", "Use a JOIN to connect the 'Shops' table with the 'Tourist_Attractions' table based on the 'Shop_ID' and 'Tourist_Attraction_ID'.", "Filter the results to include only those attractions that can be accessed by walking, which is indicated in the 'How_to_Get_There' column of the 'Tourist_Attractions' table.", "Select the necessary columns from the 'Shops' table to get the details of the shops."], "gold_sql": "SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  'walk'", "source_tables": ["shops", "tourist_attractions"], "pred_sql": "SELECT Shops.Shop_ID, Shops.Shop_Details \nFROM Shops \nJOIN Tourist_Attractions ON Shops.Shop_ID = Tourist_Attractions.Tourist_Attraction_ID \nWHERE Tourist_Attractions.How_to_Get_There LIKE '%walk%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, identified by their details, while excluding those attractions that have also been visited by another tourist with the same details. The placeholders in the query represent the tourist's details for filtering purposes.\",\n    \"1\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\"\n}\n"}
{"sample_id": "train.5931", "db_id": "cre_Theme_park", "question": "Which tourist attractions does the visitor with detail 'Vincent' visit?", "rationale": ["Identify the relevant tables: Tourist_Attractions, Visits, and Visitors are needed to find the attractions visited by a specific tourist.", "Join the Visits table with the Tourist_Attractions table on the Tourist_Attraction_ID to link visits to attractions.", "Join the Visits table with the Visitors table on the Tourist_ID to filter visits by the specific tourist's details.", "Use a WHERE clause to filter the results to only include visits by the tourist with the detail 'Vincent'.", "Select the Name of the tourist attractions from the Tourist_Attractions table."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID JOIN VISITORS AS T3 ON T2.Tourist_ID  =  T3.Tourist_ID WHERE T3.Tourist_Details  =  'Vincent'", "source_tables": ["visits", "visitors", "tourist_attractions"], "pred_sql": "SELECT Tourist_Attractions.Name \nFROM Tourist_Attractions \nJOIN Visits ON Tourist_Attractions.Tourist_Attraction_ID = Visits.Tourist_Attraction_ID \nJOIN Visitors ON Visits.Tourist_ID = Visitors.Tourist_ID \nWHERE Visitors.Tourist_Details = 'Vincent';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, identified by their details, while excluding those attractions that have also been visited by another tourist with the same details. The placeholders in the query represent the tourist's details for filtering purposes.\",\n    \"1\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n    \"2\": \"This virtual table provides a summary of tourist attractions along with the count of visits for each attraction. It combines data from the 'Tourist_Attractions' table and the 'Visits' table, grouping the results by the unique identifier of each tourist attraction. The placeholders represent the specific details of the attractions and the count of visits associated with them.\"\n}\n"}
{"sample_id": "train.5932", "db_id": "cre_Theme_park", "question": "Show the tourist attractions visited by the tourist whose detail is 'Vincent'.", "rationale": ["Identify the tables involved: Tourist_Attractions, Visits, and Visitors.", "We need to find the names of tourist attractions visited by a specific tourist, so we will join the Tourist_Attractions table with the Visits table on the Tourist_Attraction_ID.", "Next, we join the Visitors table to filter by the tourist's details, specifically looking for 'Vincent'.", "The final SQL query selects the Name of the tourist attractions from the joined tables where the tourist's details match 'Vincent'."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID JOIN VISITORS AS T3 ON T2.Tourist_ID  =  T3.Tourist_ID WHERE T3.Tourist_Details  =  'Vincent'", "source_tables": ["visits", "visitors", "tourist_attractions"], "pred_sql": "SELECT Tourist_Attractions.Name \nFROM Tourist_Attractions \nJOIN Visits ON Tourist_Attractions.Tourist_Attraction_ID = Visits.Tourist_Attraction_ID \nJOIN Visitors ON Visits.Tourist_ID = Visitors.Tourist_ID \nWHERE Visitors.Tourist_Details = 'Vincent';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, identified by their details, while excluding those attractions that have also been visited by another tourist with the same details. The placeholders in the query represent the tourist's details for filtering purposes.\",\n    \"1\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n    \"2\": \"This virtual table provides a summary of tourist attractions along with the count of visits for each attraction. It combines data from the 'Tourist_Attractions' table and the 'Visits' table, grouping the results by the unique identifier of each tourist attraction. The placeholders represent the specific details of the attractions and the count of visits associated with them.\"\n}\n"}
{"sample_id": "train.5941", "db_id": "cre_Theme_park", "question": "Show the details of the top 3 most expensive hotels.", "rationale": ["Identify the table that contains hotel details, which is the 'Hotels' table.", "To find the most expensive hotels, we need to order the results by the 'price_range' column in descending order.", "We want to limit the results to the top 3 hotels, so we will use the LIMIT clause with a value of 3."], "gold_sql": "SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT 3", "source_tables": ["hotels"], "pred_sql": "SELECT * FROM Hotels ORDER BY price_range DESC LIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, identified by their details, while excluding those attractions that have also been visited by another tourist with the same details. The placeholders in the query represent the tourist's details for filtering purposes.\",\n    \"1\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\"\n}\n"}
{"sample_id": "train.5942", "db_id": "cre_Theme_park", "question": "What are the details of the three most expensive hotels?", "rationale": ["Identify the table that contains hotel details, which is the 'Hotels' table.", "Determine the relevant column for hotel pricing, which is 'price_range'.", "To find the most expensive hotels, sort the results in descending order based on the 'price_range' column.", "Limit the results to the top three entries to get the three most expensive hotels."], "gold_sql": "SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT 3", "source_tables": ["hotels"], "pred_sql": "SELECT * FROM Hotels ORDER BY price_range DESC LIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n    \"1\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, identified by their details, while excluding those attractions that have also been visited by another tourist with the same details. The placeholders in the query represent the tourist's details for filtering purposes.\"\n}\n"}
{"sample_id": "train.5944", "db_id": "cre_Theme_park", "question": "What are the details and star ratings of the three hotels with the lowest price ranges?", "rationale": ["Identify the relevant tables: Hotels and Ref_Hotel_Star_Ratings.", "We need to retrieve hotel details and their star ratings, so we will select columns from both tables: hotel_id and other_hotel_details from Hotels, and star_rating_description from Ref_Hotel_Star_Ratings.", "Join the Hotels table with Ref_Hotel_Star_Ratings on the star_rating_code to get the star rating descriptions for each hotel.", "To find the hotels with the lowest price ranges, we will order the results by the price_range column in ascending order.", "Limit the results to the top 3 hotels to get only the three hotels with the lowest price ranges."], "gold_sql": "SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT 3", "source_tables": ["hotels"], "pred_sql": "SELECT h.hotel_id, h.other_hotel_details, r.star_rating_description \nFROM Hotels h \nJOIN Ref_Hotel_Star_Ratings r ON h.star_rating_code = r.star_rating_code \nORDER BY h.price_range ASC \nLIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, identified by their details, while excluding those attractions that have also been visited by another tourist with the same details. The placeholders in the query represent the tourist's details for filtering purposes.\",\n    \"1\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\"\n}\n"}
{"sample_id": "train.5945", "db_id": "cre_Theme_park", "question": "Show the transportation method most people choose to get to tourist attractions.", "rationale": ["Identify the relevant tables: Tourist_Attractions and Visits are needed to find out how tourists get to attractions and how many times they visited.", "Join the Tourist_Attractions table with the Visits table on the Tourist_Attraction_ID to link visits to their respective attractions.", "Select the How_to_Get_There column to find out the transportation methods used by tourists.", "Count the number of visits for each transportation method using COUNT(*) and group the results by How_to_Get_There.", "Order the results by the count of visits in descending order to find the most popular transportation method.", "Limit the results to 1 to get only the top transportation method."], "gold_sql": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["tourist_attractions"], "pred_sql": "SELECT How_to_Get_There, COUNT(*) as Visit_Count\nFROM Tourist_Attractions\nJOIN Visits ON Tourist_Attractions.Tourist_Attraction_ID = Visits.Tourist_Attraction_ID\nGROUP BY How_to_Get_There\nORDER BY Visit_Count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, identified by their details, while excluding those attractions that have also been visited by another tourist with the same details. The placeholders in the query represent the tourist's details for filtering purposes.\",\n    \"1\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n    \"2\": \"This virtual table provides a summary of tourist attractions along with the count of visits for each attraction. It combines data from the 'Tourist_Attractions' table and the 'Visits' table, grouping the results by the unique identifier of each tourist attraction. The placeholders in the SELECT statement represent the name of the attraction and its corresponding visit count.\"\n}\n"}
{"sample_id": "train.5946", "db_id": "cre_Theme_park", "question": "Which transportation method is used the most often to get to tourist attractions?", "rationale": ["Identify the relevant tables: Tourist_Attractions and Visits are needed to determine how tourists get to attractions and how often they visit them.", "Join the Tourist_Attractions table with the Visits table on the Tourist_Attraction_ID to link visits to their respective attractions.", "Select the How_to_Get_There column from the Tourist_Attractions table to find out the transportation methods used.", "Count the number of visits for each transportation method using COUNT(*) and group the results by How_to_Get_There.", "Order the results in descending order based on the count of visits to find the most frequently used transportation method.", "Limit the results to 1 to get only the top transportation method."], "gold_sql": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["tourist_attractions"], "pred_sql": "SELECT How_to_Get_There, COUNT(*) as Visit_Count\nFROM Tourist_Attractions\nJOIN Visits ON Tourist_Attractions.Tourist_Attraction_ID = Visits.Tourist_Attraction_ID\nGROUP BY How_to_Get_There\nORDER BY Visit_Count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, identified by their details, while excluding those attractions that have also been visited by another tourist with the same details. The placeholders in the query represent the tourist's details for filtering purposes.\",\n    \"1\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n    \"2\": \"This virtual table provides a summary of tourist attractions along with the count of visits for each attraction. It combines data from the 'Tourist_Attractions' table and the 'Visits' table, grouping the results by the unique identifier of each tourist attraction. The placeholders represent the specific details of the attractions and the count of visits associated with them.\"\n}\n"}
{"sample_id": "train.5955", "db_id": "cre_Theme_park", "question": "Show the names and ids of tourist attractions that are visited at most once.", "rationale": ["We need to find tourist attractions that have been visited at most once.", "To do this, we will join the 'Tourist_Attractions' table with the 'Visits' table on the 'Tourist_Attraction_ID'.", "We will group the results by 'Tourist_Attraction_ID' to count the number of visits for each attraction.", "Using the HAVING clause, we will filter the results to include only those attractions that have a count of visits less than or equal to 1.", "Finally, we will select the 'Name' and 'Tourist_Attraction_ID' of these attractions."], "gold_sql": "SELECT T1.Name ,  T1.Tourist_Attraction_ID FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID HAVING count(*)  <=  1", "source_tables": ["visits", "tourist_attractions"], "pred_sql": "SELECT ta.Name, ta.Tourist_Attraction_ID\nFROM Tourist_Attractions ta\nLEFT JOIN Visits v ON ta.Tourist_Attraction_ID = v.Tourist_Attraction_ID\nGROUP BY ta.Tourist_Attraction_ID\nHAVING COUNT(v.Visit_ID) <= 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, identified by their details, while excluding those attractions that have also been visited by another tourist with the same details. The placeholders in the query represent the tourist's details for filtering purposes.\",\n    \"1\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n    \"2\": \"This virtual table provides a summary of tourist attractions along with the count of visits for each attraction. It combines data from the 'Tourist_Attractions' table and the 'Visits' table, grouping the results by the unique identifier of each tourist attraction. The placeholders represent the specific details of the attractions and the count of visits associated with them.\"\n}\n"}
{"sample_id": "train.5956", "db_id": "cre_Theme_park", "question": "What are the names and ids of the tourist attractions that are visited at most once?", "rationale": ["We need to find tourist attractions that have been visited at most once.", "To do this, we will first create a subquery that counts the number of visits for each tourist attraction by grouping the results based on the 'Tourist_Attraction_ID'.", "In the subquery, we will use the HAVING clause to filter out attractions that have been visited more than once (i.e., COUNT(Tourist_ID) > 1).", "The main query will select the 'Tourist_Attraction_ID' and 'Name' from the 'Tourist_Attractions' table where the 'Tourist_Attraction_ID' is not in the list of attractions returned by the subquery."], "gold_sql": "SELECT T1.Name ,  T1.Tourist_Attraction_ID FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID HAVING count(*)  <=  1", "source_tables": ["visits", "tourist_attractions"], "pred_sql": "SELECT Tourist_Attraction_ID, Name \nFROM Tourist_Attractions \nWHERE Tourist_Attraction_ID NOT IN (\n    SELECT Tourist_Attraction_ID \n    FROM Visits \n    GROUP BY Tourist_Attraction_ID \n    HAVING COUNT(Tourist_ID) > 1\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, identified by their details, while excluding those attractions that have also been visited by another tourist with the same details. The placeholders in the query represent the tourist's details for filtering purposes.\",\n    \"1\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n    \"2\": \"This virtual table provides a summary of tourist attractions along with the count of visits for each attraction. It combines data from the 'Tourist_Attractions' table and the 'Visits' table, grouping the results by the unique identifier of each tourist attraction. The placeholders represent the specific details of the attractions and the count of visits associated with them.\"\n}\n"}
{"sample_id": "train.5959", "db_id": "cre_Theme_park", "question": "What are the names of the tourist attractions that have parking or shopping as their feature details?", "rationale": ["Identify the relevant tables: Tourist_Attractions for attraction names, Tourist_Attraction_Features for linking attractions to their features, and Features for feature details.", "Join the Tourist_Attractions table with the Tourist_Attraction_Features table on the Tourist_Attraction_ID to get the features associated with each attraction.", "Join the resulting table with the Features table on Feature_ID to access the feature details.", "Filter the results to include only those attractions that have features with details 'parking' or 'shopping'.", "Select the Name of the tourist attractions that meet the criteria."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'park' UNION SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'shopping'", "source_tables": ["features", "tourist_attractions", "tourist_attraction_features"], "pred_sql": "SELECT ta.Name \nFROM Tourist_Attractions ta \nJOIN Tourist_Attraction_Features taf ON ta.Tourist_Attraction_ID = taf.Tourist_Attraction_ID \nJOIN Features f ON taf.Feature_ID = f.Feature_ID \nWHERE f.Feature_Details IN ('parking', 'shopping');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, identified by their details, while excluding those attractions that have also been visited by another tourist with the same details. The placeholders in the query represent the tourist's details for filtering purposes.\",\n    \"1\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n    \"2\": \"This virtual table provides a summary of tourist attractions along with the count of visits for each attraction. It combines data from the 'Tourist_Attractions' table and the 'Visits' table, grouping the results by the unique identifier of each tourist attraction. The placeholders represent the specific details of the attractions and the count of visits associated with them.\"\n}\n"}
{"sample_id": "train.5960", "db_id": "cre_Theme_park", "question": "Find the tourist attractions that have parking or shopping as their feature details. What are the names of the attractions?", "rationale": ["Identify the relevant tables: Tourist_Attractions for attraction names, Tourist_Attraction_Features for linking attractions to their features, and Features for feature details.", "Join the Tourist_Attractions table with the Tourist_Attraction_Features table on the Tourist_Attraction_ID to get the features associated with each attraction.", "Join the resulting table with the Features table on Feature_ID to access the feature details.", "Filter the results to include only those attractions that have features with details 'parking' or 'shopping'.", "Select the names of the tourist attractions that meet the criteria."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'park' UNION SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'shopping'", "source_tables": ["features", "tourist_attractions", "tourist_attraction_features"], "pred_sql": "SELECT ta.Name\nFROM Tourist_Attractions ta\nJOIN Tourist_Attraction_Features taf ON ta.Tourist_Attraction_ID = taf.Tourist_Attraction_ID\nJOIN Features f ON taf.Feature_ID = f.Feature_ID\nWHERE f.Feature_Details IN ('parking', 'shopping');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, identified by their details, while excluding those attractions that have also been visited by another tourist with the same details. The placeholders in the query represent the tourist's details for filtering purposes.\",\n    \"1\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n    \"2\": \"This virtual table provides a summary of tourist attractions along with the count of visits for each attraction. It combines data from the 'Tourist_Attractions' table and the 'Visits' table, grouping the results by the unique identifier of each tourist attraction. The placeholders represent the specific details of the attractions and the count of visits associated with them.\"\n}\n"}
{"sample_id": "train.5963", "db_id": "cre_Theme_park", "question": "What are the names of the tourist attractions Vincent and Marcelle visit?", "rationale": ["Identify the tables involved: 'Tourist_Attractions' for attraction names and 'Visits' for linking tourists to attractions.", "Join the 'Tourist_Attractions' table with the 'Visits' table to get the attractions visited by tourists.", "Use two joins on the 'Visits' table to link both Vincent and Marcelle to the attractions they visited.", "Filter the results to only include attractions visited by both tourists by ensuring both are linked to the same attraction in the 'Visits' table.", "Select the names of the tourist attractions from the resulting joined table."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  'Vincent' INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  'Marcelle'", "source_tables": ["visits", "visitors", "tourist_attractions"], "pred_sql": "SELECT ta.Name \nFROM Tourist_Attractions ta \nJOIN Visits v1 ON ta.Tourist_Attraction_ID = v1.Tourist_Attraction_ID \nJOIN Visitors vincent ON v1.Tourist_ID = vincent.Tourist_ID \nJOIN Visits v2 ON ta.Tourist_Attraction_ID = v2.Tourist_Attraction_ID \nJOIN Visitors marcelle ON v2.Tourist_ID = marcelle.Tourist_ID \nWHERE vincent.Tourist_Details = 'Vincent' \nAND marcelle.Tourist_Details = 'Marcelle';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n    \"1\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, identified by their details, while excluding those attractions that have also been visited by another tourist with the same details. The placeholders in the query represent the tourist's details for filtering purposes.\",\n    \"2\": \"This virtual table provides a summary of tourist attractions along with the count of visits for each attraction. It combines data from the 'Tourist_Attractions' table and the 'Visits' table, grouping the results by the unique identifier of each tourist attraction. The placeholders represent the specific details of the attractions and the count of visits associated with them.\"\n}\n"}
{"sample_id": "train.5985", "db_id": "game_1", "question": "Which game type has most number of games?", "rationale": ["Identify the relevant table: The question asks about game types and the number of games, which relates to the 'Video_Games' table.", "Select the columns needed: We need to select the 'GType' (game type) and count the number of games (GameID) for each type.", "Group the results: To get the count of games per type, we will use GROUP BY on 'GType'.", "Order the results: To find the game type with the most games, we will order the results in descending order based on the count of games.", "Limit the results: Since we only want the game type with the most games, we will limit the results to 1."], "gold_sql": "SELECT gtype FROM Video_games GROUP BY gtype ORDER BY count(*) DESC LIMIT 1", "source_tables": ["video_games"], "pred_sql": "SELECT GType, COUNT(GameID) AS NumberOfGames\nFROM Video_Games\nGROUP BY GType\nORDER BY NumberOfGames DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of games played by each student from the 'SportsInfo' table. It includes the unique student identifier and counts the number of entries for each student, as well as the total games played, using placeholders for the respective values.\",\n    \"1\": \"This virtual table summarizes the total hours per week dedicated to sports and the total number of games played by students from the 'SportsInfo' table, filtered by the first and last names of the students from the 'Student' table. The placeholders in the WHERE clause represent the student's first and last names.\"\n}\n"}
{"sample_id": "train.5988", "db_id": "game_1", "question": "What is the type with the fewest games?", "rationale": ["Identify the relevant table: The question asks about the type with the fewest games, which relates to the Video_Games table.", "Select the GType column: We need to group the games by their type, so we will select the GType column.", "Count the number of games: We will use COUNT(GameID) to count how many games exist for each type.", "Group by GType: We will group the results by the GType to aggregate the counts for each type of game.", "Order the results: To find the type with the fewest games, we will order the results in ascending order based on the count of games.", "Limit the results: We will limit the output to 1 to get only the type with the fewest games."], "gold_sql": "SELECT gtype FROM Video_games GROUP BY gtype ORDER BY count(*) LIMIT 1", "source_tables": ["video_games"], "pred_sql": "SELECT GType, COUNT(GameID) AS TotalGames\nFROM Video_Games\nGROUP BY GType\nORDER BY TotalGames ASC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of games played by each student from the 'SportsInfo' table. It includes the unique student identifier and counts the number of entries for each student, as well as the total games played, using placeholders for the respective values.\",\n    \"1\": \"This virtual table summarizes the total hours per week dedicated to sports and the total number of games played by students from the 'SportsInfo' table, filtered by the first and last names of the students from the 'Student' table. The placeholders in the WHERE clause represent the student's first and last names.\"\n}\n"}
{"sample_id": "train.6001", "db_id": "game_1", "question": "How many students play sports?", "rationale": ["The question asks for the number of students who play sports, which implies we need to count unique student identifiers (StuID) from the SportsInfo table.", "We will use the COUNT function to count the distinct StuID values, ensuring that each student is only counted once, even if they participate in multiple sports.", "The query will select from the SportsInfo table, which contains the relevant information about students participating in sports."], "gold_sql": "SELECT count(DISTINCT StuID) FROM Sportsinfo", "source_tables": ["sportsinfo"], "pred_sql": "SELECT COUNT(DISTINCT StuID) AS NumberOfStudents\nFROM SportsInfo;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of students who participate in sports, along with a count of their participation. The results are grouped by student ID and ordered by the number of sports they are involved in, with a limit on the number of results returned based on a specified number.\",\n    \"1\": \"This virtual table summarizes the total hours per week dedicated to sports and the total number of games played by students from the 'SportsInfo' table, filtered by the first and last names of the students from the 'Student' table. The placeholders in the WHERE clause represent the student's first and last names.\",\n    \"2\": \"This virtual table summarizes the total number of games played by each student from the 'SportsInfo' table. It includes the unique student identifier and counts the number of entries for each student, as well as the total games played, using placeholders for the respective values.\"\n}\n"}
{"sample_id": "train.6003", "db_id": "game_1", "question": "List ids for all student who are on scholarship.", "rationale": ["Identify the relevant table: SportsInfo contains information about students participating in sports and their scholarship status.", "Determine the condition: We need to filter students who are on a sports scholarship, which is indicated by the 'OnScholarship' column.", "Construct the SQL query: We will select the 'StuID' from the SportsInfo table where 'OnScholarship' is 'Yes'."], "gold_sql": "SELECT StuID FROM Sportsinfo WHERE onscholarship  =  'Y'", "source_tables": ["sportsinfo"], "pred_sql": "SELECT StuID FROM SportsInfo WHERE OnScholarship = 'Yes';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies students who are majoring in a specific field of study and are also participating in sports on a scholarship. The placeholders in the query represent the major and the scholarship status.\",\n    \"1\": \"This virtual table provides the first and last names of students who participate in sports, along with a count of their participation. The results are grouped by student ID and ordered by the number of sports they are involved in, with a limit on the number of results returned based on a specified number.\"\n}\n"}
{"sample_id": "train.6004", "db_id": "game_1", "question": "What are the ids for all sporty students who are on scholarship?", "rationale": ["Identify the relevant table: SportsInfo contains information about students participating in sports.", "Determine the condition: We need to find students who are on a sports scholarship, which is indicated by the 'OnScholarship' column.", "Select the unique identifier: We want the 'StuID' of these students.", "Construct the SQL query: Use a SELECT statement to retrieve 'StuID' from the SportsInfo table where 'OnScholarship' is 'Yes'."], "gold_sql": "SELECT StuID FROM Sportsinfo WHERE onscholarship  =  'Y'", "source_tables": ["sportsinfo"], "pred_sql": "SELECT StuID FROM SportsInfo WHERE OnScholarship = 'Yes';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies students who are majoring in a specific field of study and are also participating in sports on a scholarship. The placeholders in the query represent the major and the scholarship status.\",\n    \"1\": \"This virtual table provides the first and last names of students who participate in sports, along with a count of their participation. The results are grouped by student ID and ordered by the number of sports they are involved in, with a limit on the number of results returned based on a specified number.\",\n    \"2\": \"This virtual table provides the first and last names of students who participate in sports, along with the count of their participation. The query joins the 'SportsInfo' table with the 'Student' table based on the unique student identifier. The results are grouped by student ID and ordered by the number of sports they participate in, with a limit on the number of results returned, specified by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.6006", "db_id": "game_1", "question": "What are the last names for all scholarship students?", "rationale": ["Identify the relevant tables: We need to look at the Student table for last names and the SportsInfo table to check for scholarship status.", "Join the Student table with the SportsInfo table on the StuID column to combine student information with their sports participation details.", "Filter the results to include only those students who are on a sports scholarship by checking the OnScholarship column in the SportsInfo table.", "Select the LName column from the resulting joined table to get the last names of the scholarship students."], "gold_sql": "SELECT T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T1.onscholarship  =  'Y'", "source_tables": ["sportsinfo", "student"], "pred_sql": "SELECT LName FROM Student INNER JOIN SportsInfo ON Student.StuID = SportsInfo.StuID WHERE SportsInfo.OnScholarship = 'Yes';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies students who are majoring in a specific field of study and are also participating in sports on a scholarship. The placeholders in the query represent the major and the scholarship status.\",\n    \"1\": \"This virtual table provides the first and last names of students who participate in sports, along with a count of their participation. The results are grouped by student ID and ordered by the number of sports they are involved in, with a limit on the number of results returned based on a specified number.\"\n}\n"}
{"sample_id": "train.6010", "db_id": "game_1", "question": "What is the total number of all football games played by scholarship students?", "rationale": ["Identify the relevant table: SportsInfo contains information about sports participation.", "We need to filter for football games, so we will use the condition SportName = 'Football'.", "We also need to consider only those students who are on a scholarship, so we will add the condition OnScholarship = 'Yes'.", "To get the total number of football games played by these students, we will use the SUM function on the GamesPlayed column."], "gold_sql": "SELECT sum(gamesplayed) FROM Sportsinfo WHERE sportname  =  'Football' AND onscholarship  =  'Y'", "source_tables": ["sportsinfo"], "pred_sql": "SELECT SUM(GamesPlayed) AS TotalGamesPlayed\nFROM SportsInfo\nWHERE SportName = 'Football' AND OnScholarship = 'Yes';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of games played by each student from the 'SportsInfo' table. It includes the unique student identifier and counts the number of entries for each student, as well as the total games played, using placeholders for the respective values.\",\n    \"1\": \"This virtual table identifies students who are majoring in a specific field of study and are also participating in sports on a scholarship. The placeholders in the query represent the major and the scholarship status.\",\n    \"2\": \"This virtual table summarizes the total hours per week dedicated to sports and the total number of games played by students from the 'SportsInfo' table, filtered by the first and last names of the students from the 'Student' table. The placeholders in the WHERE clause represent the student's first and last names.\"\n}\n"}
{"sample_id": "train.6014", "db_id": "game_1", "question": "What are the ids of all students along with how many sports and games did they play?", "rationale": ["We need to retrieve the IDs of all students along with the count of sports and games they play.", "To achieve this, we will select the 'StuID' from the 'Student' table.", "We will count the distinct 'SportName' from the 'SportsInfo' table to get the number of sports each student is involved in.", "We will also count the distinct 'GameID' from the 'Plays_Games' table to get the number of games each student has played.", "We will use LEFT JOIN to include all students even if they have not participated in any sports or games.", "Finally, we will group the results by 'StuID' to aggregate the counts for each student."], "gold_sql": "SELECT StuID ,  count(*) ,  sum(gamesplayed) FROM Sportsinfo GROUP BY StuID", "source_tables": ["sportsinfo"], "pred_sql": "SELECT Student.StuID, COUNT(DISTINCT SportsInfo.SportName) AS SportsCount, COUNT(DISTINCT Plays_Games.GameID) AS GamesCount\nFROM Student\nLEFT JOIN SportsInfo ON Student.StuID = SportsInfo.StuID\nLEFT JOIN Plays_Games ON Student.StuID = Plays_Games.StuID\nGROUP BY Student.StuID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of students who participate in sports, along with a count of their participation. The results are grouped by student ID and ordered by the number of sports they are involved in, with a limit on the number of results returned based on a specified number.\",\n    \"1\": \"This virtual table summarizes the total number of games played by each student from the 'SportsInfo' table. It includes the unique student identifier and counts the number of entries for each student, as well as the total games played, using placeholders for the respective values.\",\n    \"2\": \"This virtual table summarizes the total hours per week dedicated to sports and the total number of games played by students from the 'SportsInfo' table, filtered by the first and last names of the students from the 'Student' table. The placeholders in the WHERE clause represent the student's first and last names.\"\n}\n"}
{"sample_id": "train.6019", "db_id": "game_1", "question": "Which sport has most number of students on scholarship?", "rationale": ["Identify the relevant table: SportsInfo contains information about students participating in sports and their scholarship status.", "Filter the records to include only those students who are on a sports scholarship by using the condition 'OnScholarship = 'Yes'.", "Group the results by SportName to count the number of students in each sport.", "Use COUNT(StuID) to count the number of students for each sport.", "Order the results in descending order based on the count of students to find the sport with the most students on scholarship.", "Limit the results to 1 to get only the sport with the highest count."], "gold_sql": "SELECT sportname FROM Sportsinfo WHERE onscholarship  =  'Y' GROUP BY sportname ORDER BY count(*) DESC LIMIT 1", "source_tables": ["sportsinfo"], "pred_sql": "SELECT SportName, COUNT(StuID) AS NumberOfStudents\nFROM SportsInfo\nWHERE OnScholarship = 'Yes'\nGROUP BY SportName\nORDER BY NumberOfStudents DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies students who are majoring in a specific field of study and are also participating in sports on a scholarship. The placeholders in the query represent the major and the scholarship status.\",\n    \"1\": \"This virtual table provides the first and last names of students who participate in sports, along with a count of their participation. The results are grouped by student ID and ordered by the number of sports they are involved in, with a limit on the number of results returned based on a specified number.\",\n    \"2\": \"This virtual table summarizes the total number of games played by each student from the 'SportsInfo' table. It includes the unique student identifier and counts the number of entries for each student, as well as the total games played, using placeholders for the respective values.\"\n}\n"}
{"sample_id": "train.6020", "db_id": "game_1", "question": "What is the sport with the most scholarship students?", "rationale": ["Identify the relevant table: SportsInfo contains information about students participating in sports and their scholarship status.", "Filter the records to include only those students who are on a sports scholarship by using the condition 'OnScholarship = 'Yes' in the WHERE clause.", "Group the results by SportName to count how many scholarship students are in each sport using COUNT(*) and GROUP BY.", "Order the results in descending order based on the count of scholarship students to find the sport with the most scholarship students using ORDER BY ScholarshipCount DESC.", "Limit the results to only the top entry using LIMIT 1 to get the sport with the most scholarship students."], "gold_sql": "SELECT sportname FROM Sportsinfo WHERE onscholarship  =  'Y' GROUP BY sportname ORDER BY count(*) DESC LIMIT 1", "source_tables": ["sportsinfo"], "pred_sql": "SELECT SportName, COUNT(*) AS ScholarshipCount\nFROM SportsInfo\nWHERE OnScholarship = 'Yes'\nGROUP BY SportName\nORDER BY ScholarshipCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies students who are majoring in a specific field of study and are also participating in sports on a scholarship. The placeholders in the query represent the major and the scholarship status.\",\n    \"1\": \"This virtual table provides the first and last names of students who participate in sports, along with a count of their participation. The results are grouped by student ID and ordered by the number of sports they are involved in, with a limit on the number of results returned based on a specified number.\",\n    \"2\": \"This virtual table provides the first and last names of students who participate in sports, along with the count of their participation. The query joins the 'SportsInfo' table with the 'Student' table based on the unique student identifier. The results are grouped by student ID and ordered by the number of sports they participate in, with a limit on the number of results returned, specified by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.6024", "db_id": "game_1", "question": "What are the student ids for those on scholarship in major number 600?", "rationale": ["Identify the relevant table: SportsInfo contains information about students participating in sports and their scholarship status.", "Filter for students on scholarship: We need to check the 'OnScholarship' column for 'Yes'.", "Join with the Student table to filter by major: We need to ensure that the students are majoring in '600'.", "Use a subquery to get the student IDs from the Student table where the Major is '600'.", "Combine the conditions to get the final list of student IDs who are on scholarship and have the specified major."], "gold_sql": "SELECT StuID FROM Student WHERE major  =  600 INTERSECT SELECT StuID FROM Sportsinfo WHERE onscholarship  =  'Y'", "source_tables": ["sportsinfo", "student"], "pred_sql": "SELECT StuID FROM SportsInfo WHERE OnScholarship = 'Yes' AND StuID IN (SELECT StuID FROM Student WHERE Major = '600');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies students who are majoring in a specific field of study and are also participating in sports on a scholarship. The placeholders in the query represent the major and the scholarship status.\",\n    \"1\": \"This virtual table provides the first and last names of students who participate in sports, along with a count of their participation. The results are grouped by student ID and ordered by the number of sports they are involved in, with a limit on the number of results returned based on a specified number.\"\n}\n"}
{"sample_id": "train.6025", "db_id": "game_1", "question": "Show student ids who are female and play football.", "rationale": ["Identify the relevant tables: 'Student' for student information and 'SportsInfo' for sports participation.", "We need to filter students based on gender, specifically females, which is done using the 'Sex' column in the 'Student' table.", "We also need to check for students who play football, which is indicated by the 'SportName' column in the 'SportsInfo' table.", "To get the student IDs, we will select 'StuID' from the 'Student' table.", "We will use a JOIN operation to combine 'Student' and 'SportsInfo' on the 'StuID' column, ensuring we only get students who are in the 'SportsInfo' table.", "Finally, we will apply the WHERE clause to filter for female students and those who play football."], "gold_sql": "SELECT StuID FROM Student WHERE sex  =  'F' INTERSECT SELECT StuID FROM Sportsinfo WHERE sportname  =  'Football'", "source_tables": ["sportsinfo", "student"], "pred_sql": "SELECT Student.StuID \nFROM Student \nJOIN SportsInfo ON Student.StuID = SportsInfo.StuID \nWHERE Student.Sex = 'Female' AND SportsInfo.SportName = 'Football';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies students from the 'Student' table who are of a specific gender and are not participating in a specified sport. The placeholders in the WHERE clause represent the gender and the sport's name.\",\n    \"1\": \"This virtual table provides the first and last names of students who participate in sports, along with a count of their participation. The results are grouped by student ID and ordered by the number of sports they are involved in, with a limit on the number of results returned based on a specified number.\",\n    \"2\": \"This virtual table identifies students who are majoring in a specific field of study and are also participating in sports on a scholarship. The placeholders in the query represent the major and the scholarship status.\"\n}\n"}
{"sample_id": "train.6026", "db_id": "game_1", "question": "What are the ids of all female students who play football?", "rationale": ["Identify the relevant tables: We need to get information from the 'Student' table for female students and the 'SportsInfo' table to check for participation in football.", "Join the 'Student' table with the 'SportsInfo' table on the StuID to link students with their sports participation.", "Filter the results to include only female students by adding a WHERE clause for Student.Sex = 'Female'.", "Further filter the results to include only those who play football by adding another condition in the WHERE clause for SportsInfo.SportName = 'Football'.", "Select the StuID of the students who meet these criteria."], "gold_sql": "SELECT StuID FROM Student WHERE sex  =  'F' INTERSECT SELECT StuID FROM Sportsinfo WHERE sportname  =  'Football'", "source_tables": ["sportsinfo", "student"], "pred_sql": "SELECT Student.StuID \nFROM Student \nJOIN SportsInfo ON Student.StuID = SportsInfo.StuID \nWHERE Student.Sex = 'Female' AND SportsInfo.SportName = 'Football';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of students who participate in sports, along with a count of their participation. The results are grouped by student ID and ordered by the number of sports they are involved in, with a limit on the number of results returned based on a specified number.\",\n    \"1\": \"This virtual table identifies students from the 'Student' table who are of a specific gender and are not participating in a specified sport. The placeholders in the WHERE clause represent the gender and the sport's name.\",\n    \"2\": \"This virtual table identifies students who are majoring in a specific field of study and are also participating in sports on a scholarship. The placeholders in the query represent the major and the scholarship status.\"\n}\n"}
{"sample_id": "train.6028", "db_id": "game_1", "question": "What are the ids of all male students who do not play football?", "rationale": ["Identify the table to query: We need to get data from the 'Student' table.", "Filter for male students: We will add a condition to select only those students where the 'Sex' column is 'Male'.", "Exclude students who play football: We will use a subquery to find students in the 'SportsInfo' table who play 'Football' and exclude them from our main query.", "Combine the conditions: We will use the NOT IN clause to ensure that the selected male students do not appear in the list of students who play football."], "gold_sql": "SELECT StuID FROM Student WHERE sex  =  'M' EXCEPT SELECT StuID FROM Sportsinfo WHERE sportname  =  'Football'", "source_tables": ["sportsinfo", "student"], "pred_sql": "SELECT StuID FROM Student WHERE Sex = 'Male' AND StuID NOT IN (SELECT StuID FROM SportsInfo WHERE SportName = 'Football');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies students from the 'Student' table who are of a specific gender and are not participating in a specified sport. The placeholders in the WHERE clause represent the gender and the sport's name.\",\n    \"1\": \"This virtual table provides the first and last names of students who participate in sports, along with a count of their participation. The results are grouped by student ID and ordered by the number of sports they are involved in, with a limit on the number of results returned based on a specified number.\",\n    \"2\": \"This virtual table identifies students who are majoring in a specific field of study and are also participating in sports on a scholarship. The placeholders in the query represent the major and the scholarship status.\"\n}\n"}
{"sample_id": "train.6060", "db_id": "customers_and_addresses", "question": "Find the average order quantity per order.", "rationale": ["Identify the relevant table: The 'Order_Items' table contains the 'order_quantity' that we need to average.", "Use the AVG() function to calculate the average of 'order_quantity'.", "Group the results by 'order_id' to get the average order quantity for each order."], "gold_sql": "SELECT avg(order_quantity) FROM order_items", "source_tables": ["order_items"], "pred_sql": "SELECT AVG(order_quantity) AS average_order_quantity\nFROM Order_Items\nGROUP BY order_id;", "hint": "\n"}
{"sample_id": "train.6071", "db_id": "customers_and_addresses", "question": "What are the details of all products?", "rationale": ["The user wants to retrieve details of all products.", "To get all details from a table, we use the SELECT statement with a wildcard (*) to select all columns.", "The table we need to query is 'Products'.", "Thus, the SQL query will be 'SELECT * FROM Products;'"], "gold_sql": "SELECT DISTINCT product_details FROM products", "source_tables": ["products"], "pred_sql": "SELECT * FROM Products;", "hint": "\n"}
{"sample_id": "train.6075", "db_id": "customers_and_addresses", "question": "Find the detail of products whose detail contains the word \"Latte\" or the word \"Americano\"", "rationale": ["Identify the table to query: The question asks for product details, so we will query the Products table.", "Determine the condition: We need to find products whose details contain either 'Latte' or 'Americano'.", "Use the SQL LIKE operator: To search for a substring within a text field, we use the LIKE operator with wildcards (%) to match any characters before or after the search term.", "Construct the SQL query: Combine the SELECT statement with the WHERE clause to filter the results based on the specified conditions."], "gold_sql": "SELECT product_details FROM products WHERE product_details LIKE '%Latte%' OR product_details LIKE '%Americano%'", "source_tables": ["products"], "pred_sql": "SELECT * FROM Products WHERE product_details LIKE '%Latte%' OR product_details LIKE '%Americano%';", "hint": "\n"}
{"sample_id": "train.6085", "db_id": "customers_and_addresses", "question": "Which city has the most customers living in?", "rationale": ["Identify the relevant tables: We need to find the city with the most customers, so we will use the Customer_Addresses and Addresses tables.", "Join the tables: We will join Customer_Addresses with Addresses on the address_id to get the city information for each customer.", "Count distinct customers: We will count the distinct customer_id for each city to determine how many customers live in each city.", "Group by city: We will group the results by city to aggregate the customer counts.", "Order the results: We will order the results in descending order based on the customer count to find the city with the most customers.", "Limit the results: We will limit the results to 1 to get only the city with the highest customer count."], "gold_sql": "SELECT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id GROUP BY t3.city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "customers", "customer_addresses"], "pred_sql": "SELECT city, COUNT(DISTINCT customer_id) AS customer_count\nFROM Customer_Addresses\nJOIN Addresses ON Customer_Addresses.address_id = Addresses.address_id\nGROUP BY city\nORDER BY customer_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6086", "db_id": "customers_and_addresses", "question": "Find the city where the most customers live.", "rationale": ["To find the city where the most customers live, we need to count the number of customers associated with each city.", "The relevant tables are Customer_Addresses (which links customers to addresses) and Addresses (which contains city information).", "We will join the Customer_Addresses table with the Addresses table on the address_id to get the city for each customer.", "Next, we will group the results by city and count the number of customer_ids for each city to get the total number of customers per city.", "Finally, we will order the results in descending order based on the customer count and limit the results to 1 to get the city with the most customers."], "gold_sql": "SELECT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id GROUP BY t3.city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "customers", "customer_addresses"], "pred_sql": "SELECT city, COUNT(customer_id) AS customer_count\nFROM Customer_Addresses\nJOIN Addresses ON Customer_Addresses.address_id = Addresses.address_id\nGROUP BY city\nORDER BY customer_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6097", "db_id": "customers_and_addresses", "question": "Which contact channel has been used by the customer with name \"Tillman Ernser\"?", "rationale": ["Identify the relevant tables: Customers and Customer_Contact_Channels.", "Join the Customers table with the Customer_Contact_Channels table using the customer_id as the linking key.", "Filter the results to find the specific customer by name, 'Tillman Ernser'.", "Select the desired fields: customer name, channel code, and contact number."], "gold_sql": "SELECT DISTINCT channel_code FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  'Tillman Ernser'", "source_tables": ["customer_contact_channels", "customers"], "pred_sql": "SELECT c.customer_name, cc.channel_code, cc.contact_number \nFROM Customers c \nJOIN Customer_Contact_Channels cc ON c.customer_id = cc.customer_id \nWHERE c.customer_name = 'Tillman Ernser';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of customers along with the activation dates of their preferred contact channels. The data is sourced from the 'Customers' table and the 'Customer_Contact_Channels' table, linked by the customer identifier. The placeholder in the WHERE clause represents the specific contact channel code being queried.\",\n    \"1\": \"This virtual table provides the names of customers along with the activation dates of their preferred contact channels. The data is sourced from the 'Customers' table and the 'Customer_Contact_Channels' table, linked by the customer identifier. The placeholder in the WHERE clause represents the specific contact channel code being queried.\",\n    \"2\": \"This virtual table provides the channel codes and contact numbers of customer contact channels that have the longest active duration. The placeholder in the LIMIT clause allows for specifying the number of records to retrieve based on the longest active duration.\"\n}\n"}
{"sample_id": "train.6100", "db_id": "customers_and_addresses", "question": "Return the the \"active to date\" of the latest contact channel used by the customer named \"Tillman Ernser\".", "rationale": ["Identify the relevant tables: We need to retrieve the 'active_to_date' from the 'Customer_Contact_Channels' table and link it to the 'Customers' table to filter by customer name.", "Join the 'Customer_Contact_Channels' table with the 'Customers' table on 'customer_id' to access the customer name and their contact channel details.", "Filter the results to only include the customer named 'Tillman Ernser'.", "Order the results by 'active_from_date' in descending order to get the latest contact channel used.", "Limit the results to 1 to get only the latest 'active_to_date' for the specified customer."], "gold_sql": "SELECT max(t2.active_to_date) FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  'Tillman Ernser'", "source_tables": ["customer_contact_channels", "customers"], "pred_sql": "SELECT active_to_date \nFROM Customer_Contact_Channels ccc \nJOIN Customers c ON ccc.customer_id = c.customer_id \nWHERE c.customer_name = 'Tillman Ernser' \nORDER BY ccc.active_from_date DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the channel codes and contact numbers of customer contact channels that have the longest active duration. The placeholder in the LIMIT clause allows for specifying the number of records to retrieve based on the longest active duration.\",\n    \"1\": \"This virtual table provides the names of customers along with the activation dates of their preferred contact channels. The data is sourced from the 'Customers' table and the 'Customer_Contact_Channels' table, linked by the customer identifier. The placeholder in the WHERE clause represents the specific contact channel code being queried.\",\n    \"2\": \"This virtual table provides the names of customers along with the activation dates of their preferred contact channels. The data is sourced from the 'Customers' table and the 'Customer_Contact_Channels' table, linked by the customer identifier. The placeholder in the WHERE clause represents the specific contact channel code being queried.\"\n}\n"}
{"sample_id": "train.6101", "db_id": "customers_and_addresses", "question": "What is the average time span of contact channels in the database?", "rationale": ["To find the average time span of contact channels, we need to calculate the duration for each contact channel.", "The duration can be calculated by subtracting the 'active_from_date' from the 'active_to_date'.", "We will use the 'julianday' function to convert the date strings into Julian day numbers for accurate date arithmetic.", "We will select the average of these durations using the AVG function.", "We need to ensure that we only consider contact channels that have an 'active_to_date' (i.e., they have been deactivated) to get valid time spans."], "gold_sql": "SELECT avg(active_to_date - active_from_date) FROM customer_contact_channels", "source_tables": ["customer_contact_channels"], "pred_sql": "SELECT AVG(julianday(active_to_date) - julianday(active_from_date)) AS average_time_span\nFROM Customer_Contact_Channels\nWHERE active_to_date IS NOT NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the channel codes and contact numbers of customer contact channels that have the longest active duration. The placeholder in the LIMIT clause allows for specifying the number of records to retrieve based on the longest active duration.\",\n    \"1\": \"This virtual table provides the names of customers along with the activation dates of their preferred contact channels. The data is sourced from the 'Customers' table and the 'Customer_Contact_Channels' table, linked by the customer identifier. The placeholder in the WHERE clause represents the specific contact channel code being queried.\",\n    \"2\": \"This virtual table provides the names of customers along with the activation dates of their preferred contact channels. The data is sourced from the 'Customers' table and the 'Customer_Contact_Channels' table, linked by the customer identifier. The placeholder in the WHERE clause represents the specific contact channel code being queried.\"\n}\n"}
{"sample_id": "train.6103", "db_id": "customers_and_addresses", "question": "What is the channel code and contact number of the customer contact channel that was active for the longest time?", "rationale": ["Identify the relevant table: Customer_Contact_Channels contains the channel codes and contact numbers.", "Determine the columns needed: We need channel_code and contact_number.", "Calculate the duration of activity: Use the difference between active_to_date and active_from_date to determine how long each contact channel was active.", "Sort the results: Order the results by the calculated duration in descending order to get the longest active channel first.", "Limit the results: Use LIMIT 1 to get only the channel that was active for the longest time."], "gold_sql": "SELECT channel_code ,  contact_number FROM customer_contact_channels WHERE active_to_date - active_from_date  =  (SELECT active_to_date - active_from_date FROM customer_contact_channels ORDER BY (active_to_date - active_from_date) DESC LIMIT 1)", "source_tables": ["customer_contact_channels"], "pred_sql": "SELECT channel_code, contact_number FROM Customer_Contact_Channels ORDER BY (julianday(active_to_date) - julianday(active_from_date)) DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the channel codes and contact numbers of customer contact channels that have the longest active duration. The placeholder in the LIMIT clause allows for specifying the number of records to retrieve based on the longest active duration.\",\n    \"1\": \"This virtual table provides the names of customers along with the activation dates of their preferred contact channels. The data is sourced from the 'Customers' table and the 'Customer_Contact_Channels' table, linked by the customer identifier. The placeholder in the WHERE clause represents the specific contact channel code being queried.\",\n    \"2\": \"This virtual table provides the names of customers along with the activation dates of their preferred contact channels. The data is sourced from the 'Customers' table and the 'Customer_Contact_Channels' table, linked by the customer identifier. The placeholder in the WHERE clause represents the specific contact channel code being queried.\"\n}\n"}
{"sample_id": "train.6108", "db_id": "customers_and_addresses", "question": "Find the name of the customer who made the order of the largest amount of goods.", "rationale": ["Identify the relevant tables: Customers, Customer_Orders, and Order_Items are needed to find the customer who made the largest order.", "Join the Customers table with Customer_Orders on customer_id to link customers to their orders.", "Join the resulting table with Order_Items on order_id to access the quantities of items ordered.", "Group the results by customer_id to aggregate the total quantity of items ordered by each customer.", "Use SUM(oi.order_quantity) to calculate the total amount of goods ordered by each customer.", "Order the results in descending order based on the total quantity ordered to find the customer with the largest order.", "Limit the results to 1 to get only the top customer."], "gold_sql": "SELECT t1.customer_name FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id JOIN order_items AS t3 ON t2.order_id  =  t3.order_id WHERE t3.order_quantity  =  ( SELECT max(order_quantity) FROM order_items)", "source_tables": ["customer_orders", "customers", "order_items"], "pred_sql": "SELECT c.customer_name\nFROM Customers c\nJOIN Customer_Orders co ON c.customer_id = co.customer_id\nJOIN Order_Items oi ON co.order_id = oi.order_id\nGROUP BY c.customer_id\nORDER BY SUM(oi.order_quantity) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6123", "db_id": "customers_and_addresses", "question": "What is the total number of products that are in orders with status \"Cancelled\"?", "rationale": ["Identify the tables involved: We need to look at the 'Customer_Orders' table for order status and the 'Order_Items' table for product details.", "We need to count the distinct products that are associated with orders that have a status of 'Cancelled'.", "Join the 'Customer_Orders' table with the 'Order_Items' table on the 'order_id' to link orders with their respective products.", "Filter the results to include only those orders where the 'order_status' is 'Cancelled'.", "Use the COUNT function to get the total number of distinct products from the filtered results."], "gold_sql": "SELECT sum(t2.order_quantity) FROM customer_orders AS t1 JOIN order_items AS t2 ON t1.order_id  =  t2.order_id WHERE t1.order_status  =  'Cancelled'", "source_tables": ["customer_orders", "order_items"], "pred_sql": "SELECT COUNT(DISTINCT oi.product_id) AS total_cancelled_products\nFROM Customer_Orders co\nJOIN Order_Items oi ON co.order_id = oi.order_id\nWHERE co.order_status = 'Cancelled';", "hint": "\n"}
{"sample_id": "train.6130", "db_id": "customers_and_addresses", "question": "What is the most frequently ordered product? Tell me the detail of the product", "rationale": ["Identify the relevant tables: We need to find the most frequently ordered product, which involves the Order_Items and Products tables.", "Count the occurrences of each product in the Order_Items table: We will use COUNT() to tally how many times each product has been ordered.", "Join the Order_Items table with the Products table: This will allow us to retrieve product details along with the order counts.", "Group the results by product_id: This is necessary to aggregate the counts for each product.", "Order the results by the count in descending order: This will help us find the product with the highest order count.", "Limit the results to 1: Since we only want the most frequently ordered product."], "gold_sql": "SELECT t2.product_details FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["products", "order_items"], "pred_sql": "SELECT Products.product_id, Products.product_details, COUNT(Order_Items.product_id) AS order_count\nFROM Order_Items\nJOIN Products ON Order_Items.product_id = Products.product_id\nGROUP BY Order_Items.product_id\nORDER BY order_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6131", "db_id": "customers_and_addresses", "question": "Find the name and ID of the product whose total order quantity is the largest.", "rationale": ["Identify the relevant tables: Products and Order_Items.", "We need to find the product with the largest total order quantity, so we will join the Products table with the Order_Items table on the product_id.", "We will group the results by product_id and product_details to aggregate the order quantities for each product.", "Use the SUM function to calculate the total order quantity for each product.", "Order the results in descending order based on the total order quantity.", "Limit the results to 1 to get the product with the largest total order quantity."], "gold_sql": "SELECT t2.product_details ,  t2.product_id FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY sum(t1.order_quantity) LIMIT 1", "source_tables": ["products", "order_items"], "pred_sql": "SELECT P.product_id, P.product_details\nFROM Products P\nJOIN Order_Items OI ON P.product_id = OI.product_id\nGROUP BY P.product_id, P.product_details\nORDER BY SUM(OI.order_quantity) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6132", "db_id": "customers_and_addresses", "question": "What are the name and ID of the product bought the most.", "rationale": ["Identify the relevant tables: We need to look at the Order_Items table to find out which products were bought and the Products table to get the product details.", "Count the number of times each product was ordered: This can be done using the COUNT() function on the product_id from the Order_Items table.", "Join the Order_Items table with the Products table to get the product details along with the product ID.", "Group the results by product_id to aggregate the counts for each product.", "Order the results by the count of purchases in descending order to find the most bought product.", "Limit the results to 1 to get only the top product."], "gold_sql": "SELECT t2.product_details ,  t2.product_id FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY sum(t1.order_quantity) LIMIT 1", "source_tables": ["products", "order_items"], "pred_sql": "SELECT oi.product_id, p.product_details, COUNT(oi.product_id) AS purchase_count\nFROM Order_Items oi\nJOIN Products p ON oi.product_id = p.product_id\nGROUP BY oi.product_id\nORDER BY purchase_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6133", "db_id": "customers_and_addresses", "question": "Find all the addresses in East Julianaside, Texas or in Gleasonmouth, Arizona.", "rationale": ["Identify the relevant table: The 'Addresses' table contains the address information we need.", "Determine the filtering criteria: We need to filter addresses based on two specific cities and their corresponding states.", "Construct the WHERE clause: We will use an OR condition to combine the two sets of criteria for the cities and states.", "Formulate the SQL query: We will select all columns from the 'Addresses' table where the conditions are met."], "gold_sql": "SELECT address_content FROM addresses WHERE city  =  'East Julianaside' AND state_province_county  =  'Texas' UNION SELECT address_content FROM addresses WHERE city  =  'Gleasonmouth' AND state_province_county  =  'Arizona'", "source_tables": ["addresses"], "pred_sql": "SELECT * FROM Addresses WHERE (city = 'East Julianaside' AND state_province_county = 'Texas') OR (city = 'Gleasonmouth' AND state_province_county = 'Arizona');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the detailed address content from the 'Addresses' table for specific cities and states, allowing for the combination of results from two different queries based on the same criteria. The placeholders in the WHERE clauses represent the city and state names.\"\n}\n"}
{"sample_id": "train.6155", "db_id": "music_4", "question": "What are the category of music festivals with result \"Awarded\"?", "rationale": ["Identify the relevant table: The question pertains to music festivals and their results, so we will focus on the 'music_festival' table.", "Determine the required columns: We need the 'Category' column from the 'music_festival' table.", "Apply the condition: We are interested in categories where the result is 'Awarded'.", "Use DISTINCT to ensure we only get unique categories.", "Construct the SQL query using the SELECT statement with the appropriate WHERE clause."], "gold_sql": "SELECT Category FROM music_festival WHERE RESULT  =  'Awarded'", "source_tables": ["music_festival"], "pred_sql": "SELECT DISTINCT Category FROM music_festival WHERE Result = 'Awarded';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the famous titles of songs by artists who have had varying success on the charts. It retrieves titles of songs that have spent more than a certain number of weeks at the top of the charts and also those that have spent less than a different specified number of weeks. The placeholders in the WHERE clause represent the numeric values for the weeks spent at the top.\"\n}\n"}
{"sample_id": "train.6167", "db_id": "music_4", "question": "Please show the songs that have result \"nominated\" at music festivals.", "rationale": ["Identify the relevant tables: volume, artist, and music_festival.", "Determine the columns needed: we need the song identifier and the famous title from the artist table.", "Establish the relationships between the tables using JOINs: volume is linked to artist via Artist_ID, and volume is linked to music_festival via Volume.", "Filter the results to only include those records where the Result in the music_festival table is 'nominated'."], "gold_sql": "SELECT T2.Song FROM music_festival AS T1 JOIN volume AS T2 ON T1.Volume  =  T2.Volume_ID WHERE T1.Result  =  'Nominated'", "source_tables": ["music_festival", "volume"], "pred_sql": "SELECT volume.Song, artist.Famous_Title \nFROM volume \nJOIN artist ON volume.Artist_ID = artist.Artist_ID \nJOIN music_festival ON volume.Volume_ID = music_festival.Volume \nWHERE music_festival.Result = 'nominated';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the famous titles of songs by artists who have had varying success on the charts. It retrieves titles of songs that have spent more than a certain number of weeks at the top of the charts and also those that have spent less than a different specified number of weeks. The placeholders in the WHERE clause represent the numeric values for the weeks spent at the top.\"\n}\n"}
{"sample_id": "train.6180", "db_id": "music_4", "question": "Return the famous release date for the oldest artist.", "rationale": ["Identify the table that contains the release date of the famous title, which is the 'artist' table.", "To find the oldest artist, we need to sort the artists by their age in ascending order.", "We will select the 'Famous_Release_date' of the artist who is the oldest.", "Using 'ORDER BY Age ASC' will sort the artists from youngest to oldest, and 'LIMIT 1' will give us the oldest artist's release date."], "gold_sql": "SELECT Famous_Release_date FROM artist ORDER BY Age DESC LIMIT 1", "source_tables": ["artist"], "pred_sql": "SELECT Famous_Release_date FROM artist ORDER BY Age ASC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the famous titles of songs by artists who have had varying success on the charts. It retrieves titles of songs that have spent more than a certain number of weeks at the top of the charts and also those that have spent less than a different specified number of weeks. The placeholders in the WHERE clause represent the numeric values for the weeks spent at the top.\"\n}\n"}
{"sample_id": "train.6185", "db_id": "music_4", "question": "Please show the categories of the music festivals with count more than 1.", "rationale": ["Identify the table that contains the categories of music festivals, which is the 'music_festival' table.", "We need to count the occurrences of each category, so we will use the COUNT() function.", "To group the results by category, we will use the GROUP BY clause on the 'Category' column.", "To filter the results to only include categories that have more than one occurrence, we will use the HAVING clause with COUNT(*) > 1."], "gold_sql": "SELECT Category FROM music_festival GROUP BY Category HAVING COUNT(*)  >  1", "source_tables": ["music_festival"], "pred_sql": "SELECT Category, COUNT(*) as Count\nFROM music_festival\nGROUP BY Category\nHAVING COUNT(*) > 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the famous titles of songs by artists who have had varying success on the charts. It retrieves titles of songs that have spent more than a certain number of weeks at the top of the charts and also those that have spent less than a different specified number of weeks. The placeholders in the WHERE clause represent the numeric values for the weeks spent at the top.\"\n}\n"}
{"sample_id": "train.6187", "db_id": "music_4", "question": "What is the song in the volume with the maximum weeks on top?", "rationale": ["Identify the table that contains the relevant information about songs and their weeks on top, which is the 'volume' table.", "Determine that we need to find the song associated with the maximum number of weeks on top.", "Use a subquery to find the maximum value of 'Weeks_on_Top' in the 'volume' table.", "Select the 'Song' from the 'volume' table where the 'Weeks_on_Top' matches the maximum value found in the subquery."], "gold_sql": "SELECT Song FROM volume ORDER BY Weeks_on_Top DESC LIMIT 1", "source_tables": ["volume"], "pred_sql": "SELECT v.Song FROM volume v WHERE v.Weeks_on_Top = (SELECT MAX(Weeks_on_Top) FROM volume);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the famous titles of songs by artists who have had varying success on the charts. It retrieves titles of songs that have spent more than a certain number of weeks at the top of the charts and also those that have spent less than a different specified number of weeks. The placeholders in the WHERE clause represent the numeric values for the weeks spent at the top.\"\n}\n"}
{"sample_id": "train.6195", "db_id": "music_4", "question": "What is the issue date of the volume with the minimum weeks on top?", "rationale": ["Identify the table that contains the issue date and weeks on top, which is the 'volume' table.", "To find the issue date of the volume with the minimum weeks on top, we need to first determine the minimum value of 'Weeks_on_Top' in the 'volume' table.", "We can use a subquery to find the minimum 'Weeks_on_Top' value.", "Once we have the minimum weeks on top, we can select the 'Issue_Date' from the 'volume' table where 'Weeks_on_Top' matches this minimum value."], "gold_sql": "SELECT Issue_Date FROM volume ORDER BY Weeks_on_Top ASC LIMIT 1", "source_tables": ["volume"], "pred_sql": "SELECT Issue_Date FROM volume WHERE Weeks_on_Top = (SELECT MIN(Weeks_on_Top) FROM volume);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the famous titles of songs by artists who have had varying success on the charts. It retrieves titles of songs that have spent more than a certain number of weeks at the top of the charts and also those that have spent less than a different specified number of weeks. The placeholders in the WHERE clause represent the numeric values for the weeks spent at the top.\"\n}\n"}
{"sample_id": "train.6271", "db_id": "city_record", "question": "What is the match id of the competition called \"1994 FIFA World Cup qualification\"?", "rationale": ["Identify the table that contains the competition information, which is the 'match' table.", "Determine the column that holds the competition name, which is 'Competition'.", "Construct a subquery to find the Competition ID for '1994 FIFA World Cup qualification'.", "Use the result of the subquery to select the Match_ID from the 'match' table."], "gold_sql": "SELECT match_id FROM MATCH WHERE competition = '1994 FIFA World Cup qualification'", "source_tables": ["match"], "pred_sql": "SELECT Match_ID FROM match WHERE Competition = (SELECT Competition FROM match WHERE Competition = '1994 FIFA World Cup qualification');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n    \"1\": \"This virtual table identifies cities where the average temperature in March is lower than in July and that have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\"\n}\n"}
{"sample_id": "train.6274", "db_id": "city_record", "question": "Which city has hosted the most events?", "rationale": ["Identify the table that contains information about hosting events, which is the 'hosting_city' table.", "To find out which city has hosted the most events, we need to count the number of matches hosted by each city.", "We will use the COUNT function to count the number of Match_IDs for each Host_City.", "We will group the results by Host_City to aggregate the counts for each city.", "Finally, we will order the results in descending order based on the count of events and limit the result to the top city."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["hosting_city", "city"], "pred_sql": "SELECT Host_City, COUNT(Match_ID) AS Event_Count\nFROM hosting_city\nGROUP BY Host_City\nORDER BY Event_Count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of cities based on specific temperature conditions and hosting events. It retrieves cities where the average temperature in February is greater than in June, and also includes cities that have hosted matches. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n    \"1\": \"This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n    \"2\": \"This virtual table identifies cities where the average temperature in March is lower than in July and that have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\"\n}\n"}
{"sample_id": "train.6286", "db_id": "city_record", "question": "Which city has the highest temperature in February?", "rationale": ["Identify the relevant tables: We need data from the 'city' table for city names and the 'temperature' table for February temperatures.", "Join the 'city' table with the 'temperature' table on 'City_ID' to get the temperature data associated with each city.", "Select the city name and the average temperature in February from the joined tables.", "Order the results by the February temperature in descending order to find the highest temperature.", "Limit the results to 1 to get only the city with the highest temperature in February."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id ORDER BY T2.Feb DESC LIMIT 1", "source_tables": ["city", "temperature"], "pred_sql": "SELECT City, Feb FROM city JOIN temperature ON city.City_ID = temperature.City_ID ORDER BY Feb DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of cities based on specific temperature conditions and hosting events. It retrieves cities where the average temperature in February is greater than in June, and also includes cities that have hosted matches. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n    \"1\": \"This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n    \"2\": \"This virtual table identifies cities where the average temperature in March is lower than in July and that have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\"\n}\n"}
{"sample_id": "train.6287", "db_id": "city_record", "question": "In February, which city marks the highest temperature?", "rationale": ["We need to find the city with the highest average temperature in February.", "To do this, we will select the city name and the average temperature for February from the 'city' and 'temperature' tables.", "We will join the 'city' table with the 'temperature' table on the 'City_ID' to get the relevant temperature data for each city.", "Next, we will order the results by the February temperature in descending order to get the highest temperature at the top.", "Finally, we will limit the results to just one entry to get the city with the highest temperature."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id ORDER BY T2.Feb DESC LIMIT 1", "source_tables": ["city", "temperature"], "pred_sql": "SELECT c.City, t.Feb\nFROM city c\nJOIN temperature t ON c.City_ID = t.City_ID\nORDER BY t.Feb DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of cities based on specific temperature conditions and hosting events. It retrieves cities where the average temperature in February is greater than in June, and also includes cities that have hosted matches. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n    \"1\": \"This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n    \"2\": \"This virtual table identifies cities where the average temperature in March is lower than in July and that have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\"\n}\n"}
{"sample_id": "train.6288", "db_id": "city_record", "question": "Give me a list of cities whose temperature in March is lower than that in July or higher than that in Oct?", "rationale": ["Identify the relevant tables: We need data from the 'city' and 'temperature' tables.", "Determine the conditions: We want cities where the average temperature in March is lower than in July or higher than in October.", "Join the tables: We will join the 'city' table with the 'temperature' table on 'City_ID' to access both city names and their temperature data.", "Construct the SQL query: We will select the city name and its related information from the 'city' table where the temperature conditions are met."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul OR T2.Mar  >  T2.Oct", "source_tables": ["city", "temperature"], "pred_sql": "SELECT c.City, c.Hanzi, c.Hanyu_Pinyin \nFROM city c \nJOIN temperature t ON c.City_ID = t.City_ID \nWHERE (t.Mar < t.Jul OR t.Mar > t.Oct);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies cities where the average temperature in March is lower than in July and that have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n    \"1\": \"This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n    \"2\": \"This virtual table provides a list of cities based on specific temperature conditions and hosting events. It retrieves cities where the average temperature in February is greater than in June, and also includes cities that have hosted matches. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\"\n}\n"}
{"sample_id": "train.6289", "db_id": "city_record", "question": "Which cities' temperature in March is lower than that in July or higher than that in Oct?", "rationale": ["Identify the relevant tables: We need data from the 'city' and 'temperature' tables.", "Join the 'city' table with the 'temperature' table on 'City_ID' to access temperature data for each city.", "Apply the conditions: We want cities where the average temperature in March is lower than in July or higher than in October.", "Select the city name and the relevant temperature data for March, July, and October."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul OR T2.Mar  >  T2.Oct", "source_tables": ["city", "temperature"], "pred_sql": "SELECT c.City, t.Mar, t.Jul, t.Oct \nFROM city c \nJOIN temperature t ON c.City_ID = t.City_ID \nWHERE (t.Mar < t.Jul OR t.Mar > t.Oct);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies cities where the average temperature in March is lower than in July and that have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n    \"1\": \"This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n    \"2\": \"This virtual table provides a list of cities based on specific temperature conditions and hosting events. It retrieves cities where the average temperature in February is greater than in June, and also includes cities that have hosted matches. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\"\n}\n"}
{"sample_id": "train.6292", "db_id": "city_record", "question": "Give me a list of cities whose temperature in Mar is lower than that in Dec and which have never been host cities.", "rationale": ["Identify the relevant tables: We need data from the 'city' and 'temperature' tables.", "Join the 'city' table with the 'temperature' table on 'City_ID' to access temperature data for each city.", "Filter the results to include only those cities where the average temperature in March (t.Mar) is lower than in December (t.Dec).", "Additionally, we need to ensure that these cities have never hosted a match, which can be checked by ensuring that the 'City_ID' is not in the list of 'Host_City' from the 'hosting_city' table.", "Construct the SQL query using the SELECT statement to retrieve the city names and IDs that meet these criteria."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "pred_sql": "SELECT c.City_ID, c.City \nFROM city c \nJOIN temperature t ON c.City_ID = t.City_ID \nWHERE t.Mar < t.Dec \nAND c.City_ID NOT IN (SELECT Host_City FROM hosting_city)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n    \"1\": \"This virtual table identifies cities where the average temperature in March is lower than in July and that have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n    \"2\": \"This virtual table provides a list of cities based on specific temperature conditions and hosting events. It retrieves cities where the average temperature in February is greater than in June, and also includes cities that have hosted matches. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\"\n}\n"}
{"sample_id": "train.6293", "db_id": "city_record", "question": "Which cities have lower temperature in March than in Dec and have never served as host cities?", "rationale": ["Identify the relevant tables: We need data from the 'city' and 'temperature' tables, and we also need to check against the 'hosting_city' table.", "Join the 'city' table with the 'temperature' table on 'City_ID' to access temperature data for each city.", "Use a WHERE clause to filter cities where the average temperature in March (t.Mar) is lower than in December (t.Dec).", "Additionally, we need to ensure that these cities have never served as host cities, which can be checked using a NOT IN clause that selects all Host_City from the 'hosting_city' table."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "pred_sql": "SELECT c.City \nFROM city c \nJOIN temperature t ON c.City_ID = t.City_ID \nWHERE t.Mar < t.Dec \nAND c.City_ID NOT IN (SELECT Host_City FROM hosting_city)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n    \"1\": \"This virtual table identifies cities where the average temperature in March is lower than in July and that have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n    \"2\": \"This virtual table provides a list of cities based on specific temperature conditions and hosting events. It retrieves cities where the average temperature in February is greater than in June, and also includes cities that have hosted matches. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\"\n}\n"}
{"sample_id": "train.6298", "db_id": "city_record", "question": "Please give me a list of cities whose regional population is over 8000000 or under 5000000.", "rationale": ["Identify the relevant table: The 'city' table contains the information about cities and their regional populations.", "Determine the filtering criteria: We need to find cities with a regional population greater than 8000000 or less than 5000000.", "Construct the SQL query: Use a SELECT statement to retrieve the 'City' column from the 'city' table, applying the specified conditions in the WHERE clause."], "gold_sql": "SELECT city FROM city WHERE regional_population  >  10000000 UNION SELECT city FROM city WHERE regional_population  <  5000000", "source_tables": ["city"], "pred_sql": "SELECT City FROM city WHERE Regional_Population > 8000000 OR Regional_Population < 5000000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the names of cities from the 'city' table where the regional population is either greater than or less than specified numeric values. The placeholders in the WHERE clauses represent the population thresholds for filtering the cities.\",\n    \"1\": \"This virtual table provides a list of cities based on specific temperature conditions and hosting events. It retrieves cities where the average temperature in February is greater than in June, and also includes cities that have hosted matches. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\"\n}\n"}
{"sample_id": "train.6313", "db_id": "e_government", "question": "What is the name of the party form that is most common?", "rationale": ["Identify the relevant tables: Party_Forms and Forms are needed to get the form names.", "Join the Party_Forms table with the Forms table on the form_id to access the form names.", "Group the results by form_name to count how many times each form appears in Party_Forms.", "Use COUNT(*) to count the occurrences of each form name.", "Order the results in descending order based on the count to find the most common form.", "Limit the results to 1 to get only the most common form."], "gold_sql": "SELECT t1.form_name FROM forms AS t1 JOIN party_forms AS t2 ON t1.form_id  =  t2.form_id GROUP BY t2.form_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["forms", "party_forms"], "pred_sql": "SELECT form_name, COUNT(*) as form_count \nFROM Party_Forms \nJOIN Forms ON Party_Forms.form_id = Forms.form_id \nGROUP BY form_name \nORDER BY form_count DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6329", "db_id": "e_government", "question": "What are the names of the services that have never been used?", "rationale": ["Identify the relevant table: The question asks about services, so we will focus on the Services table.", "Determine the condition: We need to find services that have never been used, which means we need to check for services that do not have any entries in the Party_Services table.", "Construct the subquery: We will create a subquery that selects all service_ids from the Party_Services table, as these represent services that have been used.", "Use the NOT IN clause: In the main query, we will select service_name from the Services table where the service_id is not in the list of used service_ids from the subquery."], "gold_sql": "SELECT service_name FROM services EXCEPT SELECT t1.service_name FROM services AS t1 JOIN party_services AS t2 ON t1.service_id  =  t2.service_id", "source_tables": ["services", "party_services"], "pred_sql": "SELECT service_name FROM Services WHERE service_id NOT IN (SELECT service_id FROM Party_Services);", "hint": "\n"}
{"sample_id": "train.6330", "db_id": "e_government", "question": "Find the name of all the cities and states.", "rationale": ["Identify the relevant table: The 'Addresses' table contains the columns for town/city and state/province/county.", "Determine the columns needed: We need 'town_city' and 'state_province_county' from the 'Addresses' table.", "Use UNION to combine results: Since we want a unique list of names from both columns, we will use UNION to combine the results from both SELECT statements.", "Select distinct values: To ensure there are no duplicates in the results, we will use DISTINCT in both SELECT statements."], "gold_sql": "SELECT town_city FROM addresses UNION SELECT state_province_county FROM addresses", "source_tables": ["addresses"], "pred_sql": "SELECT DISTINCT town_city AS name FROM Addresses\nUNION\nSELECT DISTINCT state_province_county AS name FROM Addresses;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a combined list of town/city names and state/province/county names from the 'Addresses' table. The use of UNION allows for the retrieval of unique entries from both columns, ensuring that the results do not contain duplicates.\"\n}\n"}
{"sample_id": "train.6342", "db_id": "e_government", "question": "Which state can address \"6862 Kaitlyn Knolls\" possibly be in?", "rationale": ["Identify the relevant table: The 'Addresses' table contains the address information.", "Determine the specific address to search for: The address in question is '6862 Kaitlyn Knolls'.", "Select the state/province/county associated with the specified address: We need to retrieve the 'state_province_county' column.", "Use DISTINCT to ensure that we get unique results, in case there are multiple entries for the same address.", "Construct the SQL query to select the distinct state/province/county for the given address."], "gold_sql": "SELECT state_province_county FROM addresses WHERE line_1_number_building LIKE '%6862 Kaitlyn Knolls%'", "source_tables": ["addresses"], "pred_sql": "SELECT DISTINCT state_province_county FROM Addresses WHERE line_1_number_building = '6862 Kaitlyn Knolls';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a combined list of town/city names and state/province/county names from the 'Addresses' table. The use of UNION allows for the retrieval of unique entries from both columns, ensuring that the results do not contain duplicates.\"\n}\n"}
{"sample_id": "train.6346", "db_id": "e_government", "question": "Find the last name of the individuals that have been contact individuals of an organization.", "rationale": ["Identify the relevant tables: Organizations, Organization_Contact_Individuals, and Individuals.", "Determine the relationship between these tables: Organization_Contact_Individuals links individuals to organizations.", "Select the last name of individuals from the Individuals table.", "Join the Organizations table to get the organization details and the Organization_Contact_Individuals table to link individuals to organizations.", "Construct the SQL query to retrieve the last names of individuals who have contacted any organization."], "gold_sql": "SELECT DISTINCT t1.individual_last_name FROM individuals AS t1 JOIN organization_contact_individuals AS t2 ON t1.individual_id  =  t2.individual_id", "source_tables": ["organization_contact_individuals", "individuals"], "pred_sql": "SELECT i.individual_last_name \nFROM Organizations o \nJOIN Organization_Contact_Individuals oci ON o.organization_id = oci.organization_id \nJOIN Individuals i ON oci.individual_id = i.individual_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the last names of individuals who have contacted the organization with the highest VAT number. The query joins the 'organizations', 'organization_contact_individuals', and 'individuals' tables to filter the results based on the maximum VAT number and orders the results by the contact end date. The placeholder in the LIMIT clause represents the maximum number of results to return.\"\n}\n"}
{"sample_id": "train.6371", "db_id": "flight_company", "question": "What are the names and types of the companies that have ever operated a flight?", "rationale": ["Identify the relevant tables: We need information from the 'operate_company' table for company names and types, and the 'flight' table to find companies that have operated flights.", "Determine the relationship: The 'flight' table has a foreign key 'company_id' that links to the 'id' in the 'operate_company' table.", "Construct the SQL query: We will use a JOIN to combine the 'operate_company' and 'flight' tables based on the matching 'company_id' and 'id'.", "Select the distinct names and types of companies to avoid duplicates, as multiple flights may be operated by the same company."], "gold_sql": "SELECT T1.name ,  T1.type FROM operate_company AS T1 JOIN flight AS t2 ON T1.id  =  T2.company_id", "source_tables": ["flight", "operate_company"], "pred_sql": "SELECT DISTINCT operate_company.name, operate_company.Type \nFROM operate_company \nJOIN flight ON operate_company.id = flight.company_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the pilots operating flights from companies that engage in specific principal activities. The query uses an INTERSECT operation to find pilots from two different sets of operating companies that share the same principal activities, represented by placeholders in the WHERE clause.\"\n}\n"}
{"sample_id": "train.6375", "db_id": "flight_company", "question": "What is the id, name and IATA code of the airport that had most number of flights?", "rationale": ["Identify the relevant tables: 'airport' and 'flight'.", "We need to find the airport with the most flights, so we will join the 'airport' table with the 'flight' table using the foreign key relationship (airport.id = flight.airport_id).", "Select the required fields: airport.id, airport.name, and airport.IATA.", "Group the results by airport.id, airport.name, and airport.IATA to aggregate the flight counts for each airport.", "Count the number of flights for each airport using COUNT(flight.id).", "Order the results in descending order based on the flight count to get the airport with the most flights at the top.", "Limit the results to 1 to get only the airport with the highest number of flights."], "gold_sql": "SELECT T1.id ,  T1.name ,  T1.IATA FROM airport AS T1 JOIN flight AS T2 ON T1.id  =  T2.airport_id GROUP BY T2.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airport", "flight"], "pred_sql": "SELECT airport.id, airport.name, airport.IATA\nFROM airport\nJOIN flight ON airport.id = flight.airport_id\nGROUP BY airport.id, airport.name, airport.IATA\nORDER BY COUNT(flight.id) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6381", "db_id": "flight_company", "question": "How many companies operates airlines in each airport?", "rationale": ["Identify the relevant tables: airport, operate_company, and flight.", "We need to count the number of companies that operate airlines at each airport.", "Join the airport table with the flight table on airport.id and flight.airport_id.", "Join the flight table with the operate_company table on flight.company_id and operate_company.id.", "Filter the results to include only those companies that are of type 'airline'.", "Group the results by the airport name to get the count of airlines per airport."], "gold_sql": "SELECT T3.id ,  count(*) FROM operate_company AS T1 JOIN flight AS t2 ON T1.id  =  T2.company_id JOIN airport AS T3 ON T2.airport_id  =  T3.id GROUP BY T3.id", "source_tables": ["airport", "flight", "operate_company"], "pred_sql": "SELECT airport.name AS Airport_Name, COUNT(operate_company.id) AS Number_of_Airlines\nFROM airport\nJOIN flight ON airport.id = flight.airport_id\nJOIN operate_company ON flight.company_id = operate_company.id\nWHERE operate_company.Type = 'airline'\nGROUP BY airport.name;", "hint": "\n"}
{"sample_id": "train.6517", "db_id": "wine_1", "question": "What is the name of the highest rated wine?", "rationale": ["Identify the table that contains the wine names and their scores, which is the 'wine' table.", "To find the highest rated wine, we need to order the results by the 'Score' column in descending order.", "We will limit the results to 1 to get only the highest rated wine.", "The final SQL query selects the 'Name' of the wine from the 'wine' table, orders by 'Score' in descending order, and limits the result to 1."], "gold_sql": "SELECT Name FROM WINE ORDER BY Score LIMIT 1", "source_tables": ["wine"], "pred_sql": "SELECT Name FROM wine ORDER BY Score DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of counties where wines have received a score above a specified threshold. The results are grouped by county and ordered by the number of wines that meet the score criteria, allowing users to identify the most prolific counties for high-scoring wines. The placeholders in the WHERE clause and LIMIT clause represent the score threshold and the maximum number of counties to return, respectively.\",\n    \"1\": \"This virtual table lists distinct grape varieties from the 'grapes' table that have a specific color and are associated with wines that have a score above a certain threshold. The placeholders in the WHERE clause represent the color of the grape and the minimum score for the wine.\",\n    \"2\": \"This virtual table lists the names of wineries that produce wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filters the results by the specified grape color, groups the results by winery name, and orders them by the number of wines produced, limiting the output to a specified number of wineries.\"\n}\n"}
{"sample_id": "train.6518", "db_id": "wine_1", "question": "Give the name of the wine with the highest score.", "rationale": ["Identify the table that contains the wine names and their scores, which is the 'wine' table.", "To find the wine with the highest score, we need to order the results by the 'Score' column in descending order.", "Using 'LIMIT 1' will ensure that we only get the top result, which is the wine with the highest score."], "gold_sql": "SELECT Name FROM WINE ORDER BY Score LIMIT 1", "source_tables": ["wine"], "pred_sql": "SELECT Name FROM wine ORDER BY Score DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of counties where wines have received a score above a specified threshold. The results are grouped by county and ordered by the number of wines that meet the score criteria, allowing users to identify the most prolific counties for high-scoring wines. The placeholders in the WHERE clause and LIMIT clause represent the score threshold and the maximum number of counties to return, respectively.\",\n    \"1\": \"This virtual table lists distinct grape varieties from the 'grapes' table that have a specific color and are associated with wines that have a score above a certain threshold. The placeholders in the WHERE clause represent the color of the grape and the minimum score for the wine.\",\n    \"2\": \"This virtual table lists the names of wineries that produce wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filters the results by the specified grape color, groups the results by winery name, and orders them by the number of wines produced, limiting the output to a specified number of wineries.\"\n}\n"}
{"sample_id": "train.6520", "db_id": "wine_1", "question": "What is the winery at which the wine with the highest score was made?", "rationale": ["Identify the table that contains the winery information, which is the 'wine' table.", "Determine that we need to find the wine with the highest score, which requires a subquery to get the maximum score from the 'wine' table.", "Use the MAX function in a subquery to find the highest score.", "Select the winery from the 'wine' table where the score matches the highest score found in the subquery."], "gold_sql": "SELECT Winery FROM WINE ORDER BY SCORE LIMIT 1", "source_tables": ["wine"], "pred_sql": "SELECT Winery FROM wine WHERE Score = (SELECT MAX(Score) FROM wine);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of counties where wines have received a score above a specified threshold. The results are grouped by county and ordered by the number of wines that meet the score criteria, allowing users to identify the most prolific counties for high-scoring wines. The placeholders in the WHERE clause and LIMIT clause represent the score threshold and the maximum number of counties to return, respectively.\",\n    \"1\": \"This virtual table lists distinct grape varieties from the 'grapes' table that have a specific color and are associated with wines that have a score above a certain threshold. The placeholders in the WHERE clause represent the color of the grape and the minimum score for the wine.\",\n    \"2\": \"This virtual table lists the names of wineries that produce wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filters the results by the specified grape color, groups the results by winery name, and orders them by the number of wines produced, limiting the output to a specified number of wineries.\"\n}\n"}
{"sample_id": "train.6533", "db_id": "wine_1", "question": "List the names of all distinct wines that are made of red color grape.", "rationale": ["Identify the tables involved: 'wine' and 'grapes'.", "Determine the relationship between the tables: 'wine' table has a foreign key 'Grape' that references 'grapes' table.", "Select the distinct names of wines from the 'wine' table.", "Join the 'wine' table with the 'grapes' table on the 'Grape' column.", "Filter the results to include only those wines made from red color grapes by adding a WHERE clause that checks 'grapes.Color = 'red'."], "gold_sql": "SELECT DISTINCT T2.Name FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'Red'", "source_tables": ["wine", "grapes"], "pred_sql": "SELECT DISTINCT wine.Name \nFROM wine \nJOIN grapes ON wine.Grape = grapes.Grape \nWHERE grapes.Color = 'red';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of wineries that produce wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filters the results by the specified grape color, groups the results by winery name, and orders them by the number of wines produced, limiting the output to a specified number of wineries.\",\n    \"1\": \"This virtual table lists distinct grape varieties from the 'grapes' table that have a specific color and are associated with wines that have a score above a certain threshold. The placeholders in the WHERE clause represent the color of the grape and the minimum score for the wine.\",\n    \"2\": \"This virtual table provides a list of counties from the 'appellations' table that are associated with a specific number of wines produced, as indicated by the placeholder. The query joins the 'appellations' and 'wine' tables on the appellation name, groups the results by appellation, and filters the groups to include only those with a count of wines less than or equal to the specified number.\"\n}\n"}
{"sample_id": "train.6544", "db_id": "wine_1", "question": "Give the names and scores of wines made from white grapes.", "rationale": ["Identify the tables involved: 'wine' and 'grapes'.", "Determine the columns needed: 'Name' and 'Score' from the 'wine' table.", "Establish the relationship between the tables: 'wine.Grape' corresponds to 'grapes.Grape'.", "Filter the results to include only wines made from white grapes by adding a WHERE clause that specifies 'grapes.Color = 'white'.", "Construct the SQL query to select the desired columns from the joined tables with the appropriate filtering."], "gold_sql": "SELECT T2.Name ,   T2.Score FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'White'", "source_tables": ["wine", "grapes"], "pred_sql": "SELECT wine.Name, wine.Score \nFROM wine \nJOIN grapes ON wine.Grape = grapes.Grape \nWHERE grapes.Color = 'white';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists distinct grape varieties from the 'grapes' table that have a specific color and are associated with wines that have a score above a certain threshold. The placeholders in the WHERE clause represent the color of the grape and the minimum score for the wine.\",\n    \"1\": \"This virtual table lists the names of wineries that produce wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filters the results by the specified grape color, groups the results by winery name, and orders them by the number of wines produced, limiting the output to a specified number of wineries.\",\n    \"2\": \"This virtual table provides a list of counties where wines have received a score above a specified threshold. The results are grouped by county and ordered by the number of wines that meet the score criteria, allowing users to identify the most prolific counties for high-scoring wines. The placeholders in the WHERE clause and LIMIT clause represent the score threshold and the maximum number of counties to return, respectively.\"\n}\n"}
{"sample_id": "train.6547", "db_id": "wine_1", "question": "Find the the grape whose white color grapes are used to produce wines with scores higher than 90.", "rationale": ["Identify the relevant tables: 'grapes' and 'wine'.", "We need to find grape varieties that are white in color and are used in wines with scores higher than 90.", "Join the 'grapes' table with the 'wine' table on the grape variety column.", "Filter the results to include only white grapes and wines with a score greater than 90.", "Select distinct grape varieties to avoid duplicates in the results."], "gold_sql": "SELECT DISTINCT T1.Grape FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'White' AND T2.score  >  90", "source_tables": ["wine", "grapes"], "pred_sql": "SELECT DISTINCT grapes.Grape \nFROM grapes \nJOIN wine ON grapes.Grape = wine.Grape \nWHERE grapes.Color = 'white' AND wine.Score > 90;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists distinct grape varieties from the 'grapes' table that have a specific color and are associated with wines that have a score above a certain threshold. The placeholders in the WHERE clause represent the color of the grape and the minimum score for the wine.\",\n    \"1\": \"This virtual table lists the names of wineries that produce wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filters the results by the specified grape color, groups the results by winery name, and orders them by the number of wines produced, limiting the output to a specified number of wineries.\",\n    \"2\": \"This virtual table provides a list of counties where wines have received a score above a specified threshold. The results are grouped by county and ordered by the number of wines that meet the score criteria, allowing users to identify the most prolific counties for high-scoring wines. The placeholders in the WHERE clause and LIMIT clause represent the score threshold and the maximum number of counties to return, respectively.\"\n}\n"}
{"sample_id": "train.6550", "db_id": "wine_1", "question": "What are the names of wines made from red grapes and with prices above 50?", "rationale": ["Identify the relevant tables: 'wine' and 'grapes'.", "Determine the columns needed: 'Name' from 'wine' and 'Color' from 'grapes'.", "Establish the relationship between the tables: join 'wine' and 'grapes' on the 'Grape' column.", "Apply the filters: select only red grapes and wines with prices above 50.", "Use DISTINCT to ensure unique wine names are returned."], "gold_sql": "SELECT T2.Name FROM Grapes AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'Red' AND T2.price  >  50", "source_tables": ["wine", "grapes"], "pred_sql": "SELECT DISTINCT wine.Name \nFROM wine \nJOIN grapes ON wine.Grape = grapes.Grape \nWHERE grapes.Color = 'red' AND wine.Price > 50;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of wineries that produce wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filters the results by the specified grape color, groups the results by winery name, and orders them by the number of wines produced, limiting the output to a specified number of wineries.\",\n    \"1\": \"This virtual table lists distinct grape varieties from the 'grapes' table that have a specific color and are associated with wines that have a score above a certain threshold. The placeholders in the WHERE clause represent the color of the grape and the minimum score for the wine.\",\n    \"2\": \"This virtual table provides a list of counties where wines have received a score above a specified threshold. The results are grouped by county and ordered by the number of wines that meet the score criteria, allowing users to identify the most prolific counties for high-scoring wines. The placeholders in the WHERE clause and LIMIT clause represent the score threshold and the maximum number of counties to return, respectively.\"\n}\n"}
{"sample_id": "train.6558", "db_id": "wine_1", "question": "What are the distinct names of wines with prices higher than any wine from John Anthony winery.", "rationale": ["Identify the main requirement: distinct names of wines with prices higher than any wine from John Anthony winery.", "To find wines with prices higher than those from John Anthony, we need to compare prices.", "We will use a subquery to find the maximum price of wines from John Anthony winery.", "The outer query will select distinct wine names from the 'wine' table where the price is greater than the result of the subquery."], "gold_sql": "SELECT DISTINCT Name FROM WINE WHERE Price  >  (SELECT min(Price) FROM wine WHERE Winery  =  'John Anthony')", "source_tables": ["wine"], "pred_sql": "SELECT DISTINCT w.Name \nFROM wine w \nWHERE w.Price > (SELECT MAX(w2.Price) \n                  FROM wine w2 \n                  WHERE w2.Winery = 'John Anthony');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of counties where wines have received a score above a specified threshold. The results are grouped by county and ordered by the number of wines that meet the score criteria, allowing users to identify the most prolific counties for high-scoring wines. The placeholders in the WHERE clause and LIMIT clause represent the score threshold and the maximum number of counties to return, respectively.\",\n    \"1\": \"This virtual table lists the names of wineries that produce wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filters the results by the specified grape color, groups the results by winery name, and orders them by the number of wines produced, limiting the output to a specified number of wineries.\",\n    \"2\": \"This virtual table lists distinct grape varieties from the 'grapes' table that have a specific color and are associated with wines that have a score above a certain threshold. The placeholders in the WHERE clause represent the color of the grape and the minimum score for the wine.\"\n}\n"}
{"sample_id": "train.6566", "db_id": "wine_1", "question": "Give the color of the grape whose wine products have the highest average price?", "rationale": ["Identify the tables involved: 'grapes' and 'wine'.", "We need to find the color of the grape whose wine products have the highest average price.", "Join the 'grapes' table with the 'wine' table on the grape variety.", "Group the results by the color of the grape to calculate the average price of wines for each color.", "Order the results by the average price in descending order to get the highest average price at the top.", "Limit the results to 1 to get only the color of the grape with the highest average price."], "gold_sql": "SELECT T1.Color FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape GROUP BY T2.Grape ORDER BY AVG(Price) DESC LIMIT 1", "source_tables": ["wine", "grapes"], "pred_sql": "SELECT g.Color\nFROM grapes g\nJOIN wine w ON g.Grape = w.Grape\nGROUP BY g.Color\nORDER BY AVG(w.Price) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of wineries that produce wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filters the results by the specified grape color, groups the results by winery name, and orders them by the number of wines produced, limiting the output to a specified number of wineries.\",\n    \"1\": \"This virtual table lists distinct grape varieties from the 'grapes' table that have a specific color and are associated with wines that have a score above a certain threshold. The placeholders in the WHERE clause represent the color of the grape and the minimum score for the wine.\",\n    \"2\": \"This virtual table provides a list of counties where wines have received a score above a specified threshold. The results are grouped by county and ordered by the number of wines that meet the score criteria, allowing users to identify the most prolific counties for high-scoring wines. The placeholders in the WHERE clause and LIMIT clause represent the score threshold and the maximum number of counties to return, respectively.\"\n}\n"}
{"sample_id": "train.6588", "db_id": "wine_1", "question": "Which 3 wineries produce the most wines made from white grapes?", "rationale": ["Identify the relevant tables: 'wine' and 'grapes'.", "Join the 'wine' table with the 'grapes' table on the grape variety to access grape color information.", "Filter the results to include only wines made from white grapes by adding a WHERE clause for grapes.Color = 'white'.", "Group the results by winery name to count the number of wines produced by each winery.", "Count the number of wines for each winery using COUNT(*) and alias it as WineCount.", "Order the results in descending order based on the count of wines produced (WineCount).", "Limit the results to the top 3 wineries using LIMIT 3."], "gold_sql": "SELECT T2.Winery FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.GRAPE  =  T2.GRAPE WHERE T1.Color  =  'White' GROUP BY T2.Winery ORDER BY count(*) DESC LIMIT 3", "source_tables": ["wine", "grapes"], "pred_sql": "SELECT Winery, COUNT(*) AS WineCount\nFROM wine\nJOIN grapes ON wine.Grape = grapes.Grape\nWHERE grapes.Color = 'white'\nGROUP BY Winery\nORDER BY WineCount DESC\nLIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of wineries that produce wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filters the results by the specified grape color, groups the results by winery name, and orders them by the number of wines produced, limiting the output to a specified number of wineries.\",\n    \"1\": \"This virtual table lists distinct grape varieties from the 'grapes' table that have a specific color and are associated with wines that have a score above a certain threshold. The placeholders in the WHERE clause represent the color of the grape and the minimum score for the wine.\",\n    \"2\": \"This virtual table provides a list of counties where wines have received a score above a specified threshold. The results are grouped by county and ordered by the number of wines that meet the score criteria, allowing users to identify the most prolific counties for high-scoring wines. The placeholders in the WHERE clause and LIMIT clause represent the score threshold and the maximum number of counties to return, respectively.\"\n}\n"}
{"sample_id": "train.6597", "db_id": "wine_1", "question": "Find the county where produces the most number of wines with score higher than 90.", "rationale": ["We need to find the county that produces the most wines with a score higher than 90.", "To do this, we will join the 'appellations' table with the 'wine' table on the appellation name.", "We will filter the wines to include only those with a score greater than 90 using a WHERE clause.", "Next, we will group the results by county to count the number of wines per county.", "We will order the results in descending order based on the count of wines to find the county with the highest number.", "Finally, we will limit the results to just one county using the LIMIT clause."], "gold_sql": "SELECT T1.County FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T2.Score  >  90 GROUP BY T1.County ORDER BY count(*) DESC LIMIT 1", "source_tables": ["wine", "appellations"], "pred_sql": "SELECT a.County, COUNT(w.No) AS WineCount\nFROM appellations a\nJOIN wine w ON a.Appelation = w.Appelation\nWHERE w.Score > 90\nGROUP BY a.County\nORDER BY WineCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of counties where wines have received a score above a specified threshold. The results are grouped by county and ordered by the number of wines that meet the score criteria, allowing users to identify the most prolific counties for high-scoring wines. The placeholders in the WHERE clause and LIMIT clause represent the score threshold and the maximum number of counties to return, respectively.\",\n    \"1\": \"This virtual table lists distinct grape varieties from the 'grapes' table that have a specific color and are associated with wines that have a score above a certain threshold. The placeholders in the WHERE clause represent the color of the grape and the minimum score for the wine.\",\n    \"2\": \"This virtual table provides a list of counties from the 'appellations' table that are associated with a specific number of wines produced, as indicated by the placeholder. The query joins the 'appellations' and 'wine' tables on the appellation name, groups the results by appellation, and filters the groups to include only those with a count of wines less than or equal to the specified number.\"\n}\n"}
{"sample_id": "train.6626", "db_id": "driving_school", "question": "Show the detail of vehicle with id 1.", "rationale": ["Identify the table that contains vehicle details, which is the Vehicles table.", "Determine the specific vehicle we want to retrieve details for, which is identified by vehicle_id '1'.", "Construct a SQL SELECT statement to retrieve all columns from the Vehicles table where the vehicle_id matches '1'."], "gold_sql": "SELECT vehicle_details FROM Vehicles WHERE vehicle_id = 1;", "source_tables": ["vehicles"], "pred_sql": "SELECT * FROM Vehicles WHERE vehicle_id = '1';", "hint": "\n"}
{"sample_id": "train.6650", "db_id": "driving_school", "question": "How many staff live in state Georgia?", "rationale": ["Identify the relevant tables: Staff and Addresses.", "Determine the relationship between the tables: Staff has a foreign key (staff_address_id) that links to Addresses (address_id).", "We need to count the number of staff members, so we will use the COUNT() function.", "Filter the results to only include staff members who live in the state of Georgia by using a WHERE clause on the state_province_county column in the Addresses table."], "gold_sql": "SELECT count(*) FROM Addresses WHERE state_province_county = 'Georgia';", "source_tables": ["addresses"], "pred_sql": "SELECT COUNT(*) AS staff_count \nFROM Staff \nJOIN Addresses ON Staff.staff_address_id = Addresses.address_id \nWHERE Addresses.state_province_county = 'Georgia';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the number of staff members located in each city, derived from the 'Addresses' and 'Staff' tables. The placeholder in the LIMIT clause allows the user to specify the maximum number of cities to display based on the count of staff members.\"\n}\n"}
{"sample_id": "train.6665", "db_id": "driving_school", "question": "What is the status code, phone number, and email address of the customer whose last name is Kohler or whose first name is Marina?", "rationale": ["Identify the relevant table: Customers, as we need customer details.", "Determine the required fields: status code, phone number, and email address.", "Formulate the WHERE clause to filter customers by last name 'Kohler' or first name 'Marina'.", "Construct the SELECT statement to retrieve the specified fields from the Customers table."], "gold_sql": "SELECT customer_status_code ,  cell_mobile_phone_number ,  email_address FROM Customers WHERE first_name = 'Marina' OR last_name  =  'Kohler'", "source_tables": ["customers"], "pred_sql": "SELECT customer_status_code, phone_number, email_address FROM Customers WHERE last_name = 'Kohler' OR first_name = 'Marina';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of lessons attended by a specific customer identified by their first and last name, along with the status of those lessons. The placeholders in the WHERE clause represent the customer's first name, last name, and the lesson status code.\"\n}\n"}
{"sample_id": "train.6676", "db_id": "driving_school", "question": "How many lessons taken by customer with first name as Rylan and last name as Goodwin were completed?", "rationale": ["Identify the tables involved: Lessons and Customers.", "We need to count the number of lessons, so we will use the COUNT() function.", "We need to join the Lessons table with the Customers table on the customer_id to filter by customer name.", "The WHERE clause will filter for the specific first name 'Rylan' and last name 'Goodwin'.", "Additionally, we need to filter for lessons that have a status of 'completed'.", "Construct the SQL query using the identified tables, join condition, and filters."], "gold_sql": "SELECT count(*) FROM Lessons AS T1 JOIN Customers AS T2 ON T1.customer_id  = T2.customer_id WHERE T2.first_name = 'Rylan' AND T2.last_name = 'Goodwin' AND T1.lesson_status_code = 'Completed';", "source_tables": ["lessons", "customers"], "pred_sql": "SELECT COUNT(*) AS lesson_count \nFROM Lessons \nJOIN Customers ON Lessons.customer_id = Customers.customer_id \nWHERE Customers.first_name = 'Rylan' \nAND Customers.last_name = 'Goodwin' \nAND Lessons.lesson_status_code = 'completed';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of lessons attended by a specific customer identified by their first and last name, along with the status of those lessons. The placeholders in the WHERE clause represent the customer's first name, last name, and the lesson status code.\"\n}\n"}
{"sample_id": "train.6688", "db_id": "driving_school", "question": "Which city does has most number of customers?", "rationale": ["Identify the relevant tables: Customers and Addresses.", "Determine the relationship between Customers and Addresses using the foreign key customer_address_id.", "Count the number of customers grouped by city.", "Order the results by the count of customers in descending order to find the city with the most customers.", "Limit the results to 1 to get only the city with the highest count."], "gold_sql": "SELECT T2.city FROM Customers AS T1 JOIN Addresses AS T2 ON T1.customer_address_id = T2.address_id GROUP BY T2.city ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["addresses", "customers"], "pred_sql": "SELECT city, COUNT(customer_id) AS customer_count \nFROM Customers \nJOIN Addresses ON Customers.customer_address_id = Addresses.address_id \nGROUP BY city \nORDER BY customer_count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the number of staff members located in each city, derived from the 'Addresses' and 'Staff' tables. The placeholder in the LIMIT clause allows the user to specify the maximum number of cities to display based on the count of staff members.\"\n}\n"}
{"sample_id": "train.6711", "db_id": "driving_school", "question": "What are the last names that are used by customers and staff?", "rationale": ["Identify the tables that contain last names: Customers and Staff.", "Use the SELECT statement to retrieve last names from both tables.", "Use DISTINCT to ensure that each last name is unique in the results.", "Combine the results from both tables using UNION to get a single list of last names."], "gold_sql": "SELECT last_name FROM Customers INTERSECT SELECT last_name FROM Staff", "source_tables": ["staff", "customers"], "pred_sql": "SELECT DISTINCT last_name FROM Customers UNION SELECT DISTINCT last_name FROM Staff;", "hint": "\n"}
{"sample_id": "train.6714", "db_id": "driving_school", "question": "What is the id and detail of the vehicle used in lessons for most of the times?", "rationale": ["Identify the relevant tables: Lessons and Vehicles.", "We need to find the vehicle used in lessons, so we will join the Lessons table with the Vehicles table on the vehicle_id.", "We want to count how many times each vehicle has been used in lessons, so we will group the results by vehicle_id.", "To find the vehicle used the most, we will order the results by the count of lesson_id in descending order.", "Finally, we will limit the results to 1 to get the vehicle used in lessons the most times."], "gold_sql": "SELECT T1.vehicle_id ,  T1.vehicle_details FROM Vehicles AS T1 JOIN Lessons AS T2 ON T1.vehicle_id  =  T2.vehicle_id GROUP BY T1.vehicle_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["lessons", "vehicles"], "pred_sql": "SELECT v.vehicle_id, v.vehicle_details\nFROM Lessons l\nJOIN Vehicles v ON l.vehicle_id = v.vehicle_id\nGROUP BY l.vehicle_id\nORDER BY COUNT(l.lesson_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of lessons attended by a specific customer identified by their first and last name, along with the status of those lessons. The placeholders in the WHERE clause represent the customer's first name, last name, and the lesson status code.\"\n}\n"}
{"sample_id": "train.6725", "db_id": "activity_1", "question": "Show ids for all the male faculty.", "rationale": ["Identify the table that contains faculty information, which is the 'Faculty' table.", "Determine the relevant column for faculty identifiers, which is 'FacID'.", "Identify the column that indicates gender, which is 'Sex'.", "Specify the condition to filter for male faculty members by using 'WHERE Sex = 'Male''.", "Combine these elements to form the SQL query that selects the 'FacID' of male faculty members."], "gold_sql": "SELECT FacID FROM Faculty WHERE Sex  =  'M'", "source_tables": ["faculty"], "pred_sql": "SELECT FacID FROM Faculty WHERE Sex = 'Male';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of faculty members who serve as advisors to students. The results are grouped by faculty ID and ordered by the number of students they advise, with a limit on the number of faculty members returned based on a specified number.\",\n    \"1\": \"This virtual table describes the first names, last names, and contact phone numbers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.\",\n    \"2\": \"This virtual table describes the first names, last names, and contact phone numbers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.\"\n}\n"}
{"sample_id": "train.6734", "db_id": "activity_1", "question": "What are the first name and last name of all the instructors?", "rationale": ["Identify the relevant table: The 'Faculty' table contains the information about instructors.", "Determine the required fields: We need the first name (Fname) and last name (Lname) of the instructors.", "Construct the SQL query: Use a SELECT statement to retrieve Fname and Lname from the Faculty table."], "gold_sql": "SELECT fname ,  lname FROM Faculty WHERE Rank  =  'Instructor'", "source_tables": ["faculty"], "pred_sql": "SELECT Fname, Lname FROM Faculty;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of faculty members who serve as advisors to students. The results are grouped by faculty ID and ordered by the number of students they advise, with a limit on the number of faculty members returned based on a specified number.\",\n    \"1\": \"This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is grouped by each faculty member's unique identifier. The placeholders represent the faculty member's first name, last name, and the count of their participation in activities.\",\n    \"2\": \"This virtual table describes the first names, last names, and contact phone numbers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.\"\n}\n"}
{"sample_id": "train.6737", "db_id": "activity_1", "question": "Which building has most faculty members?", "rationale": ["Identify the relevant table: The Faculty table contains information about faculty members, including their building.", "Count the number of faculty members in each building: Use COUNT(FacID) to count the faculty members grouped by their building.", "Group the results by building: Use GROUP BY Building to aggregate the counts for each building.", "Order the results to find the building with the most faculty members: Use ORDER BY FacultyCount DESC to sort the counts in descending order.", "Limit the results to the top building: Use LIMIT 1 to return only the building with the highest count of faculty members."], "gold_sql": "SELECT building FROM Faculty GROUP BY building ORDER BY count(*) DESC LIMIT 1", "source_tables": ["faculty"], "pred_sql": "SELECT Building, COUNT(FacID) AS FacultyCount\nFROM Faculty\nGROUP BY Building\nORDER BY FacultyCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of buildings where faculty members of a specific academic rank are located. The query groups the results by building and filters to include only those buildings that have a certain number of faculty members, as indicated by the placeholders.\",\n    \"1\": \"This virtual table provides a list of buildings where faculty members of a specific academic rank are located. The query groups the results by building and filters to include only those buildings that have a certain number of faculty members, as indicated by the placeholders.\",\n    \"2\": \"This virtual table provides the first and last names of faculty members who serve as advisors to students. The results are grouped by faculty ID and ordered by the number of students they advise, with a limit on the number of faculty members returned based on a specified number.\"\n}\n"}
{"sample_id": "train.6747", "db_id": "activity_1", "question": "Show the number of male and female assistant professors.", "rationale": ["Identify the relevant table: The Faculty table contains information about faculty members, including their rank and gender.", "Filter for assistant professors: We need to include only those faculty members whose rank is 'Assistant Professor'.", "Group by gender: To count the number of male and female assistant professors, we will group the results by the 'Sex' column.", "Count the number of faculty members: We will use the COUNT() function to count the number of faculty members in each gender group."], "gold_sql": "SELECT sex ,  count(*) FROM Faculty WHERE rank  =  'AsstProf' GROUP BY sex", "source_tables": ["faculty"], "pred_sql": "SELECT Sex, COUNT(*) as Count \nFROM Faculty \nWHERE Rank = 'Assistant Professor' \nGROUP BY Sex;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names, last names, and contact phone numbers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.\",\n    \"1\": \"This virtual table describes the first names, last names, and contact phone numbers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.\",\n    \"2\": \"This virtual table provides the first and last names of faculty members who serve as advisors to students. The results are grouped by faculty ID and ordered by the number of students they advise, with a limit on the number of faculty members returned based on a specified number.\"\n}\n"}
{"sample_id": "train.6748", "db_id": "activity_1", "question": "How many male and female assistant professors do we have?", "rationale": ["Identify the relevant table: The Faculty table contains information about faculty members, including their rank and gender.", "Determine the criteria: We need to filter for assistant professors, which is specified by the Rank column.", "Count the number of faculty members: We will use the COUNT function to count the number of assistant professors, grouped by their gender (Sex).", "Construct the SQL query: We will select the Sex and the count of faculty members, applying the necessary filters and grouping."], "gold_sql": "SELECT sex ,  count(*) FROM Faculty WHERE rank  =  'AsstProf' GROUP BY sex", "source_tables": ["faculty"], "pred_sql": "SELECT Sex, COUNT(*) as Count\nFROM Faculty\nWHERE Rank = 'Assistant Professor'\nGROUP BY Sex;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of faculty members who serve as advisors to students. The results are grouped by faculty ID and ordered by the number of students they advise, with a limit on the number of faculty members returned based on a specified number.\",\n    \"1\": \"This virtual table describes the first names, last names, and contact phone numbers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.\",\n    \"2\": \"This virtual table describes the first names, last names, and contact phone numbers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.\"\n}\n"}
{"sample_id": "train.6750", "db_id": "activity_1", "question": "Who is the advisor of Linda Smith? Give me the first name and last name.", "rationale": ["Identify the tables needed: We need to find the advisor of a student named Linda Smith, so we will use the Student and Faculty tables.", "Determine the relationship: The Student table has a column 'Advisor' that references the 'FacID' in the Faculty table, indicating which faculty member is the advisor for each student.", "Construct the JOIN: We will join the Faculty table with the Student table on the condition that Faculty.FacID matches Student.Advisor.", "Filter the results: We need to filter the results to only include the student with the first name 'Linda' and last name 'Smith'.", "Select the required fields: We need to select the first name and last name of the faculty advisor."], "gold_sql": "SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T2.fname  =  'Linda' AND T2.lname  =  'Smith'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT Faculty.Fname, Faculty.Lname \nFROM Faculty \nJOIN Student ON Faculty.FacID = Student.Advisor \nWHERE Student.Fname = 'Linda' AND Student.Lname = 'Smith';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of faculty members who serve as advisors to students. The results are grouped by faculty ID and ordered by the number of students they advise, with a limit on the number of faculty members returned based on a specified number.\",\n    \"1\": \"This virtual table describes the first names, last names, and contact phone numbers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.\"\n}\n"}
{"sample_id": "train.6751", "db_id": "activity_1", "question": "Show the ids of students whose advisors are professors.", "rationale": ["Identify the relevant tables: We need to find students and their advisors, which involves the Student and Faculty tables.", "Determine the relationship: The Student table has a column 'Advisor' that references 'FacID' in the Faculty table, indicating which faculty member is the advisor for each student.", "Construct the SQL query: We will select the student IDs from the Student table and join it with the Faculty table on the Advisor and FacID columns to filter students whose advisors are faculty members."], "gold_sql": "SELECT T2.StuID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.rank  =  'Professor'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT Student.StuID \nFROM Student \nJOIN Faculty ON Student.Advisor = Faculty.FacID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of faculty members who serve as advisors to students. The results are grouped by faculty ID and ordered by the number of students they advise, with a limit on the number of faculty members returned based on a specified number.\",\n    \"1\": \"This virtual table provides a list of buildings where faculty members of a specific academic rank are located. The query groups the results by building and filters to include only those buildings that have a certain number of faculty members, as indicated by the placeholders.\",\n    \"2\": \"This virtual table provides a list of buildings where faculty members of a specific academic rank are located. The query groups the results by building and filters to include only those buildings that have a certain number of faculty members, as indicated by the placeholders.\"\n}\n"}
{"sample_id": "train.6752", "db_id": "activity_1", "question": "Which students have professors as their advisors? Find their student ids.", "rationale": ["Identify the relevant tables: We need to find students and their advisors, so we will use the 'Student' and 'Faculty' tables.", "Determine the relationship: The 'Advisor' column in the 'Student' table references the 'FacID' in the 'Faculty' table, indicating which faculty member is the advisor for each student.", "Construct the SQL query: We will select the student IDs from the 'Student' table where the advisor matches a faculty member in the 'Faculty' table. We will use a JOIN to connect these two tables based on the advisor relationship."], "gold_sql": "SELECT T2.StuID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.rank  =  'Professor'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT Student.StuID \nFROM Student \nJOIN Faculty ON Student.Advisor = Faculty.FacID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of faculty members who serve as advisors to students. The results are grouped by faculty ID and ordered by the number of students they advise, with a limit on the number of faculty members returned based on a specified number.\",\n    \"1\": \"This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is grouped by each faculty member's unique identifier. The placeholders represent the faculty member's first name, last name, and the count of their participation in activities.\"\n}\n"}
{"sample_id": "train.6753", "db_id": "activity_1", "question": "Show first name and last name for all the students advised by Michael Goodrich.", "rationale": ["Identify the tables needed: We need the 'Student' table to get student names and the 'Faculty' table to find the advisor's name.", "Determine the relationship: The 'Student' table has a foreign key 'Advisor' that links to 'FacID' in the 'Faculty' table.", "Select the required columns: We need to select the first name (Fname) and last name (LName) of the students.", "Filter the results: We need to filter the results to only include students whose advisor's first name is 'Michael' and last name is 'Goodrich'.", "Construct the SQL query using JOIN to combine the 'Student' and 'Faculty' tables based on the advisor relationship."], "gold_sql": "SELECT T2.fname ,  T2.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.fname  =  'Michael' AND T1.lname  =  'Goodrich'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT S.Fname, S.LName \nFROM Student S \nJOIN Faculty F ON S.Advisor = F.FacID \nWHERE F.Fname = 'Michael' AND F.Lname = 'Goodrich';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of faculty members who serve as advisors to students. The results are grouped by faculty ID and ordered by the number of students they advise, with a limit on the number of faculty members returned based on a specified number.\",\n    \"1\": \"This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is grouped by each faculty member's unique identifier. The placeholders represent the faculty member's first name, last name, and the count of their participation in activities.\",\n    \"2\": \"This virtual table describes the first names, last names, and contact phone numbers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.\"\n}\n"}
{"sample_id": "train.6756", "db_id": "activity_1", "question": "What are the faculty id and the number of students each faculty has?", "rationale": ["We need to find the faculty ID and the number of students each faculty has.", "To do this, we will join the Faculty table with the Faculty_Participates_in table to get the activities each faculty member participates in.", "Next, we will join the Participates_in table to count the number of students participating in those activities.", "We will group the results by Faculty.FacID to get the count of students for each faculty member."], "gold_sql": "SELECT T1.FacID ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID", "source_tables": ["faculty", "student"], "pred_sql": "SELECT Faculty.FacID, COUNT(Participates_in.stuid) AS student_count\nFROM Faculty\nJOIN Faculty_Participates_in ON Faculty.FacID = Faculty_Participates_in.FacID\nJOIN Participates_in ON Faculty_Participates_in.actid = Participates_in.actid\nGROUP BY Faculty.FacID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of faculty members who serve as advisors to students. The results are grouped by faculty ID and ordered by the number of students they advise, with a limit on the number of faculty members returned based on a specified number.\",\n    \"1\": \"This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is grouped by each faculty member's unique identifier. The placeholders represent the faculty member's first name, last name, and the count of their participation in activities.\",\n    \"2\": \"This virtual table provides a list of buildings where faculty members of a specific academic rank are located. The query groups the results by building and filters to include only those buildings that have a certain number of faculty members, as indicated by the placeholders.\"\n}\n"}
{"sample_id": "train.6758", "db_id": "activity_1", "question": "How many students are advised by each rank of faculty? List the rank and the number of students.", "rationale": ["We need to find out how many students are advised by each rank of faculty.", "The relevant tables for this query are 'Faculty' and 'Student'.", "The 'Faculty' table contains the rank of faculty members, and the 'Student' table contains the advisor information.", "We will join the 'Faculty' table with the 'Student' table on the condition that the faculty's ID matches the advisor ID of the students.", "We will group the results by the faculty rank to count the number of students for each rank.", "Finally, we will select the rank and the count of students advised by that rank."], "gold_sql": "SELECT T1.rank ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.rank", "source_tables": ["faculty", "student"], "pred_sql": "SELECT f.Rank, COUNT(s.StuID) AS number_of_students\nFROM Faculty f\nJOIN Student s ON f.FacID = s.Advisor\nGROUP BY f.Rank;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of faculty members who serve as advisors to students. The results are grouped by faculty ID and ordered by the number of students they advise, with a limit on the number of faculty members returned based on a specified number.\",\n    \"1\": \"This virtual table provides a list of buildings where faculty members of a specific academic rank are located. The query groups the results by building and filters to include only those buildings that have a certain number of faculty members, as indicated by the placeholders.\",\n    \"2\": \"This virtual table provides a list of buildings where faculty members of a specific academic rank are located. The query groups the results by building and filters to include only those buildings that have a certain number of faculty members, as indicated by the placeholders.\"\n}\n"}
{"sample_id": "train.6761", "db_id": "activity_1", "question": "Show the ids for all the faculty members who have at least 2 students.", "rationale": ["Identify the requirement: We need to find faculty members who have at least 2 students.", "Understand the relationship: Faculty members are linked to students through the Advisor field in the Student table.", "Create a subquery to count the number of students for each faculty member (Advisor).", "Use GROUP BY on the Advisor field to aggregate the student counts.", "Use HAVING to filter the results to only include faculty members with 2 or more students.", "Select the FacID from the Faculty table where the FacID matches the Advisors from the subquery."], "gold_sql": "SELECT T1.FacID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID HAVING count(*)  >=  2", "source_tables": ["faculty", "student"], "pred_sql": "SELECT FacID\nFROM Faculty\nWHERE FacID IN (\n    SELECT Advisor\n    FROM Student\n    GROUP BY Advisor\n    HAVING COUNT(StuID) >= 2\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of faculty members who serve as advisors to students. The results are grouped by faculty ID and ordered by the number of students they advise, with a limit on the number of faculty members returned based on a specified number.\",\n    \"1\": \"This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is grouped by each faculty member's unique identifier. The placeholders represent the faculty member's first name, last name, and the count of their participation in activities.\",\n    \"2\": \"This virtual table provides a list of buildings where faculty members of a specific academic rank are located. The query groups the results by building and filters to include only those buildings that have a certain number of faculty members, as indicated by the placeholders.\"\n}\n"}
{"sample_id": "train.6777", "db_id": "activity_1", "question": "Show the names of all the activities Mark Giuliano participates in.", "rationale": ["Identify the tables involved: We need to find activities that a specific faculty member, Mark Giuliano, participates in. This involves the 'Activity', 'Faculty_Participates_in', and 'Faculty' tables.", "Join the tables: We will join 'Activity' with 'Faculty_Participates_in' on 'actid' to get the activities associated with faculty participation. Then, we will join 'Faculty_Participates_in' with 'Faculty' on 'FacID' to get the faculty member's details.", "Filter by faculty name: We need to filter the results to only include activities where the faculty member's first name is 'Mark' and last name is 'Giuliano'.", "Select the activity names: Finally, we will select the 'activity_name' from the 'Activity' table to get the names of the activities that Mark Giuliano participates in."], "gold_sql": "SELECT T3.activity_name FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN Activity AS T3 ON T3.actid  =  T2.actid WHERE T1.fname  =  'Mark' AND T1.lname  =  'Giuliano'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT Activity.activity_name \nFROM Activity \nJOIN Faculty_Participates_in ON Activity.actid = Faculty_Participates_in.actid \nJOIN Faculty ON Faculty_Participates_in.FacID = Faculty.FacID \nWHERE Faculty.Fname = 'Mark' AND Faculty.Lname = 'Giuliano';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is grouped by each faculty member's unique identifier. The placeholders represent the faculty member's first name, last name, and the count of their participation in activities.\",\n    \"1\": \"This virtual table identifies students who participate in two specific activities from the 'Activity' table. The placeholders in the WHERE clauses represent the names of the activities being queried.\",\n    \"2\": \"This virtual table describes the last names of faculty members who participate in a specific activity. The query uses an INTERSECT operation to ensure that only faculty members who are involved in the same activity are selected. The placeholders in the WHERE clause represent the name of the activity.\"\n}\n"}
{"sample_id": "train.6779", "db_id": "activity_1", "question": "Show the first and last name of all the faculty members who participated in some activity, together with the number of activities they participated in.", "rationale": ["We need to retrieve the first and last names of faculty members who participated in activities.", "To get the count of activities each faculty member participated in, we will use the COUNT function.", "We will join the Faculty table with the Faculty_Participates_in table on the FacID to link faculty members with their activities.", "We will group the results by Faculty.FacID to ensure we get a count of activities for each faculty member.", "Finally, we will select the first name, last name, and the count of activities participated in."], "gold_sql": "SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID", "source_tables": ["faculty", "faculty_participates_in"], "pred_sql": "SELECT Faculty.Fname, Faculty.Lname, COUNT(Faculty_Participates_in.actid) AS activity_count\nFROM Faculty\nJOIN Faculty_Participates_in ON Faculty.FacID = Faculty_Participates_in.FacID\nGROUP BY Faculty.FacID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is grouped by each faculty member's unique identifier. The placeholders represent the faculty member's first name, last name, and the count of their participation in activities.\",\n    \"1\": \"This virtual table describes the last names of faculty members who participate in a specific activity. The query uses an INTERSECT operation to ensure that only faculty members who are involved in the same activity are selected. The placeholders in the WHERE clause represent the name of the activity.\",\n    \"2\": \"This virtual table provides the first and last names of faculty members who serve as advisors to students. The results are grouped by faculty ID and ordered by the number of students they advise, with a limit on the number of faculty members returned based on a specified number.\"\n}\n"}
{"sample_id": "train.6789", "db_id": "activity_1", "question": "Show the ids for all the students who participate in an activity and are under 20.", "rationale": ["Identify the relevant tables: We need to get student IDs from the 'Student' table and their participation in activities from the 'Participates_in' table.", "Join the 'Student' table with the 'Participates_in' table on the student ID to link students with their activities.", "Filter the results to include only those students who are under 20 years old by using a WHERE clause that checks if the 'Age' column is less than 20."], "gold_sql": "SELECT StuID FROM Participates_in INTERSECT SELECT StuID FROM Student WHERE age  <  20", "source_tables": ["student", "participates_in"], "pred_sql": "SELECT Student.StuID \nFROM Student \nJOIN Participates_in ON Student.StuID = Participates_in.stuid \nWHERE Student.Age < 20;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies students who participate in two specific activities from the 'Activity' table. The placeholders in the WHERE clauses represent the names of the activities being queried.\",\n    \"1\": \"This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is grouped by each faculty member's unique identifier. The placeholders represent the faculty member's first name, last name, and the count of their participation in activities.\"\n}\n"}
{"sample_id": "train.6797", "db_id": "activity_1", "question": "Find the first names of professors who are not playing Canoeing or Kayaking.", "rationale": ["Identify the main goal: to find the first names of professors who are not participating in Canoeing or Kayaking.", "Understand the structure of the tables involved: Faculty for professor details and Faculty_Participates_in for their activity participation.", "Use a subquery to find the faculty IDs of those who are participating in Canoeing or Kayaking by joining Faculty_Participates_in with Activity on actid and filtering by activity_name.", "Select the first names from the Faculty table where the faculty ID is not in the list obtained from the subquery."], "gold_sql": "SELECT lname FROM faculty WHERE rank  =  'Professor' EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT F.Fname \nFROM Faculty F \nWHERE F.FacID NOT IN (\n    SELECT FP.FacID \n    FROM Faculty_Participates_in FP \n    JOIN Activity A ON FP.actid = A.actid \n    WHERE A.activity_name IN ('Canoeing', 'Kayaking')\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of faculty members who serve as advisors to students. The results are grouped by faculty ID and ordered by the number of students they advise, with a limit on the number of faculty members returned based on a specified number.\",\n    \"1\": \"This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is grouped by each faculty member's unique identifier. The placeholders represent the faculty member's first name, last name, and the count of their participation in activities.\",\n    \"2\": \"This virtual table describes the last names of faculty members who participate in a specific activity. The query uses an INTERSECT operation to ensure that only faculty members who are involved in the same activity are selected. The placeholders in the WHERE clause represent the name of the activity.\"\n}\n"}
{"sample_id": "train.6798", "db_id": "activity_1", "question": "What are the first names of the professors who do not play Canoeing or Kayaking as activities?", "rationale": ["Identify the main entities involved: Faculty and their participation in activities.", "We need to find faculty members who do not participate in specific activities: Canoeing and Kayaking.", "To achieve this, we will use a subquery to find faculty IDs that are associated with these activities.", "The subquery will join the Faculty_Participates_in table with the Activity table to filter out faculty members participating in Canoeing or Kayaking.", "The main query will select the first names of faculty members whose IDs are not in the result of the subquery."], "gold_sql": "SELECT lname FROM faculty WHERE rank  =  'Professor' EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT F.Fname \nFROM Faculty F \nWHERE F.FacID NOT IN (\n    SELECT FP.FacID \n    FROM Faculty_Participates_in FP \n    JOIN Activity A ON FP.actid = A.actid \n    WHERE A.activity_name IN ('Canoeing', 'Kayaking')\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of faculty members who serve as advisors to students. The results are grouped by faculty ID and ordered by the number of students they advise, with a limit on the number of faculty members returned based on a specified number.\",\n    \"1\": \"This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is grouped by each faculty member's unique identifier. The placeholders represent the faculty member's first name, last name, and the count of their participation in activities.\",\n    \"2\": \"This virtual table describes the last names of faculty members who participate in a specific activity. The query uses an INTERSECT operation to ensure that only faculty members who are involved in the same activity are selected. The placeholders in the WHERE clause represent the name of the activity.\"\n}\n"}
{"sample_id": "train.6799", "db_id": "activity_1", "question": "Find the first names of the faculty members who participate in Canoeing and Kayaking.", "rationale": ["Identify the tables needed: Faculty, Faculty_Participates_in, and Activity.", "We need to find faculty members who participate in specific activities, so we will join the Faculty table with the Faculty_Participates_in table on the FacID.", "Next, we join the Faculty_Participates_in table with the Activity table on the actid to get the activity names.", "We filter the results to include only those activities that are either 'Canoeing' or 'Kayaking'.", "Finally, we select the first names of the faculty members from the Faculty table."], "gold_sql": "SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' INTERSECT SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT Faculty.Fname \nFROM Faculty \nJOIN Faculty_Participates_in ON Faculty.FacID = Faculty_Participates_in.FacID \nJOIN Activity ON Faculty_Participates_in.actid = Activity.actid \nWHERE Activity.activity_name IN ('Canoeing', 'Kayaking');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of faculty members who serve as advisors to students. The results are grouped by faculty ID and ordered by the number of students they advise, with a limit on the number of faculty members returned based on a specified number.\",\n    \"1\": \"This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is grouped by each faculty member's unique identifier. The placeholders represent the faculty member's first name, last name, and the count of their participation in activities.\",\n    \"2\": \"This virtual table describes the last names of faculty members who participate in a specific activity. The query uses an INTERSECT operation to ensure that only faculty members who are involved in the same activity are selected. The placeholders in the WHERE clause represent the name of the activity.\"\n}\n"}
{"sample_id": "train.6801", "db_id": "activity_1", "question": "Find the ids of the students who participate in Canoeing and Kayaking.", "rationale": ["Identify the relevant tables: We need to look at the 'Participates_in' table to find student IDs and the 'Activity' table to find activity names.", "Join the 'Participates_in' table with the 'Activity' table on the 'actid' column to link students with their activities.", "Use a WHERE clause to filter the activities to only include 'Canoeing' and 'Kayaking'.", "Select distinct student IDs to avoid duplicates in the results."], "gold_sql": "SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  'Canoeing' INTERSECT SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  'Kayaking'", "source_tables": ["activity", "participates_in"], "pred_sql": "SELECT DISTINCT p.stuid \nFROM Participates_in p \nJOIN Activity a ON p.actid = a.actid \nWHERE a.activity_name IN ('Canoeing', 'Kayaking');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies students who participate in two specific activities from the 'Activity' table. The placeholders in the WHERE clauses represent the names of the activities being queried.\",\n    \"1\": \"This virtual table provides the first and last names of faculty members who serve as advisors to students. The results are grouped by faculty ID and ordered by the number of students they advise, with a limit on the number of faculty members returned based on a specified number.\"\n}\n"}
{"sample_id": "train.6825", "db_id": "flight_4", "question": "Find the number of routes operated by American Airlines.", "rationale": ["Identify the relevant table: The 'routes' table contains information about the routes operated by airlines.", "Determine the specific airline: The query is focused on 'American Airlines'.", "Count the number of routes: Use the COUNT() function to count the total number of routes operated by American Airlines.", "Construct the SQL query: Use a SELECT statement to count the routes where the airline name matches 'American Airlines'."], "gold_sql": "SELECT count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid WHERE T1.name  =  'American Airlines'", "source_tables": ["routes", "airlines"], "pred_sql": "SELECT COUNT(*) AS number_of_routes \nFROM routes \nWHERE airline = 'American Airlines';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of airport names from the 'airports' table that are located in a specific country. It joins the 'airports' table with the 'routes' table to filter the airports based on their country and counts the number of routes originating from each airport. The results are grouped by airport name and ordered by the number of routes in descending order, with a limit on the number of results returned.\",\n    \"1\": \"The virtual table describes the names and cities of airports that serve as source airports for routes, along with their unique identifiers. The results are grouped by the source airport ID and ordered by the number of routes originating from each airport, limited to a specified number of results.\",\n    \"2\": \"This virtual table provides a list of destination airport names and their corresponding cities from the 'airports' table, along with the destination airport IDs from the 'routes' table. The results are grouped by destination airport ID and ordered by the count of routes to each destination, limited to a specified number of results.\"\n}\n"}
{"sample_id": "train.6826", "db_id": "flight_4", "question": "How many routes does American Airlines operate?", "rationale": ["Identify the relevant table: The 'routes' table contains information about the routes operated by airlines.", "Determine the specific airline: The question asks about 'American Airlines'.", "Count the number of routes: Use the COUNT() function to count the number of entries in the 'routes' table where the airline is 'American Airlines'.", "Construct the SQL query: Combine the elements into a complete SQL query that counts the routes for American Airlines."], "gold_sql": "SELECT count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid WHERE T1.name  =  'American Airlines'", "source_tables": ["routes", "airlines"], "pred_sql": "SELECT COUNT(*) AS route_count \nFROM routes \nWHERE airline = 'American Airlines';", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names and cities of airports that serve as source airports for routes, along with their unique identifiers. The results are grouped by the source airport ID and ordered by the number of routes originating from each airport, limited to a specified number of results.\",\n    \"1\": \"This virtual table provides a list of airport names from the 'airports' table that are located in a specific country. It joins the 'airports' table with the 'routes' table to filter the airports based on their country and counts the number of routes originating from each airport. The results are grouped by airport name and ordered by the number of routes in descending order, with a limit on the number of results returned.\",\n    \"2\": \"This virtual table provides a list of destination airport names and their corresponding cities from the 'airports' table, along with the destination airport IDs from the 'routes' table. The results are grouped by destination airport ID and ordered by the count of routes to each destination, limited to a specified number of results.\"\n}\n"}
{"sample_id": "train.6831", "db_id": "flight_4", "question": "Find the name, city, and country of the airport that has the highest latitude.", "rationale": ["Identify the relevant table: The 'airports' table contains the necessary information about airports, including their names, cities, and countries.", "Determine the criteria for selection: We need to find the airport with the highest latitude, which corresponds to the highest value in the 'y' coordinate of the airport's location.", "Construct the SQL query: We will select the 'name', 'city', and 'country' columns from the 'airports' table, order the results by the 'y' coordinate in descending order to get the highest latitude first, and limit the results to 1 to get only the top result."], "gold_sql": "SELECT name ,  city ,  country FROM airports ORDER BY elevation DESC LIMIT 1", "source_tables": ["airports"], "pred_sql": "SELECT name, city, country FROM airports ORDER BY y DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names and cities of airports that serve as source airports for routes, along with their unique identifiers. The results are grouped by the source airport ID and ordered by the number of routes originating from each airport, limited to a specified number of results.\",\n    \"1\": \"This virtual table provides a list of airport names from the 'airports' table that are located in a specific country. It joins the 'airports' table with the 'routes' table to filter the airports based on their country and counts the number of routes originating from each airport. The results are grouped by airport name and ordered by the number of routes in descending order, with a limit on the number of results returned.\",\n    \"2\": \"This virtual table provides a list of cities from the 'airports' table that are located in a specific country. The results are grouped by city, and only those cities with more than a specified number of airports are included. The placeholders in the WHERE clause represent the country's name, and the HAVING clause represents the minimum count of airports required for a city to be included in the results.\"\n}\n"}
{"sample_id": "train.6834", "db_id": "flight_4", "question": "What is the name and city of the airport that the most routes end at?", "rationale": ["We need to find the airport that has the most routes ending at it, which means we will focus on the destination airports in the 'routes' table.", "To do this, we will join the 'airports' table with the 'routes' table on the destination airport ID (dst_apid).", "We will select the name and city of the airports from the 'airports' table.", "We will group the results by the unique identifier of the airports (apid) to count the number of routes for each destination airport.", "We will order the results by the count of routes in descending order to get the airport with the most routes at the top.", "Finally, we will limit the results to 1 to get only the airport with the most routes."], "gold_sql": "SELECT T1.name ,  T1.city ,  T2.dst_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid GROUP BY T2.dst_apid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "pred_sql": "SELECT airports.name, airports.city \nFROM airports \nJOIN routes ON airports.apid = routes.dst_apid \nGROUP BY airports.apid \nORDER BY COUNT(routes.rid) DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of destination airport names and their corresponding cities from the 'airports' table, along with the destination airport IDs from the 'routes' table. The results are grouped by destination airport ID and ordered by the count of routes to each destination, limited to a specified number of results.\",\n    \"1\": \"The virtual table describes the names and cities of airports that serve as source airports for routes, along with their unique identifiers. The results are grouped by the source airport ID and ordered by the number of routes originating from each airport, limited to a specified number of results.\",\n    \"2\": \"This virtual table provides a list of airport names from the 'airports' table that are located in a specific country. It joins the 'airports' table with the 'routes' table to filter the airports based on their country and counts the number of routes originating from each airport. The results are grouped by airport name and ordered by the number of routes in descending order, with a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.6838", "db_id": "flight_4", "question": "What is the name and city of the airport from most of the routes start?", "rationale": ["Identify the relevant tables: We need information from the 'routes' and 'airports' tables.", "Determine the required fields: We need the name and city of the airport, which are in the 'airports' table.", "Establish the relationship: The 'routes' table has a foreign key 'src_apid' that links to 'apid' in the 'airports' table, allowing us to join these tables.", "Group the results: We will group by the airport ID to count the number of routes starting from each airport.", "Order the results: We will order the results by the count of routes in descending order to find the airport with the most routes starting from it.", "Limit the results: We only need the top result, so we will limit the output to 1."], "gold_sql": "SELECT T1.name ,  T1.city ,  T2.src_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T2.src_apid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "pred_sql": "SELECT airports.name, airports.city \nFROM routes \nJOIN airports ON routes.src_apid = airports.apid \nGROUP BY airports.apid \nORDER BY COUNT(routes.rid) DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names and cities of airports that serve as source airports for routes, along with their unique identifiers. The results are grouped by the source airport ID and ordered by the number of routes originating from each airport, limited to a specified number of results.\",\n    \"1\": \"This virtual table provides a list of destination airport names and their corresponding cities from the 'airports' table, along with the destination airport IDs from the 'routes' table. The results are grouped by destination airport ID and ordered by the count of routes to each destination, limited to a specified number of results.\",\n    \"2\": \"This virtual table provides a list of airport names from the 'airports' table that are located in a specific country. It joins the 'airports' table with the 'routes' table to filter the airports based on their country and counts the number of routes originating from each airport. The results are grouped by airport name and ordered by the number of routes in descending order, with a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.6841", "db_id": "flight_4", "question": "Which countries has the most number of airlines?", "rationale": ["Identify the relevant table: The 'airlines' table contains information about airlines, including their active status and country of origin.", "Filter for active airlines: We need to include only those airlines that are currently active, which is indicated by the 'active' column in the airlines table.", "Group by country: To find out how many airlines are in each country, we will group the results by the 'country' column.", "Count the number of airlines: We will use the COUNT function to count the number of airlines in each country.", "Order the results: We want the countries with the most airlines first, so we will order the results in descending order based on the count of airlines."], "gold_sql": "SELECT country FROM airlines GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airlines"], "pred_sql": "SELECT country, COUNT(*) AS airline_count \nFROM airlines \nWHERE active = 1 \nGROUP BY country \nORDER BY airline_count DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of countries where active airlines are based, grouped by country. The placeholder in the WHERE clause indicates whether to filter for active airlines, and the LIMIT placeholder specifies the maximum number of countries to return, sorted by the number of active airlines in descending order.\",\n    \"1\": \"This virtual table provides a list of countries where active airlines are based, grouped by country. The placeholder in the WHERE clause indicates whether to filter for active airlines, and the LIMIT placeholder specifies the maximum number of countries to return, ordered by the number of active airlines in descending order.\",\n    \"2\": \"This virtual table provides a list of cities from the 'airports' table that are located in a specific country. The results are grouped by city, and only those cities with more than a specified number of airports are included. The placeholders in the WHERE clause represent the country's name, and the HAVING clause represents the minimum count of airports required for a city to be included in the results.\"\n}\n"}
{"sample_id": "train.6842", "db_id": "flight_4", "question": "What is the name of the country with the most number of home airlines?", "rationale": ["Identify the relevant table: The 'airlines' table contains information about airlines, including their country and whether they are active.", "Filter for active airlines: We need to consider only those airlines that are currently active, which is indicated by the 'active' column in the 'airlines' table.", "Group by country: To find the number of home airlines per country, we will group the results by the 'country' column.", "Count the number of airlines: We will use the COUNT function to count the number of active airlines in each country.", "Order by the count: We will order the results in descending order based on the count of active airlines to find the country with the most.", "Limit the results: Since we only want the country with the most home airlines, we will limit the results to 1."], "gold_sql": "SELECT country FROM airlines GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airlines"], "pred_sql": "SELECT country FROM airlines WHERE active = 1 GROUP BY country ORDER BY COUNT(alid) DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of countries where active airlines are based, grouped by country. The placeholder in the WHERE clause indicates whether to filter for active airlines, and the LIMIT placeholder specifies the maximum number of countries to return, sorted by the number of active airlines in descending order.\",\n    \"1\": \"This virtual table provides a list of countries where active airlines are based, grouped by country. The placeholder in the WHERE clause indicates whether to filter for active airlines, and the LIMIT placeholder specifies the maximum number of countries to return, ordered by the number of active airlines in descending order.\",\n    \"2\": \"This virtual table provides a list of airport names from the 'airports' table that are located in a specific country. It joins the 'airports' table with the 'routes' table to filter the airports based on their country and counts the number of routes originating from each airport. The results are grouped by airport name and ordered by the number of routes in descending order, with a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.6858", "db_id": "flight_4", "question": "What are the cities that have more than 2 airports sorted by number of airports?", "rationale": ["We need to find cities with more than 2 airports.", "To do this, we will select the 'city' column from the 'airports' table and count the number of airports in each city using COUNT(*).", "We will group the results by 'city' to aggregate the counts for each city.", "The HAVING clause will filter the results to include only those cities where the count of airports is greater than 2.", "Finally, we will order the results by the count of airports in descending order to show the cities with the most airports first."], "gold_sql": "SELECT city FROM airports GROUP BY city HAVING count(*)  >  2 ORDER BY count(*)", "source_tables": ["airports"], "pred_sql": "SELECT city, COUNT(*) as airport_count \nFROM airports \nGROUP BY city \nHAVING COUNT(*) > 2 \nORDER BY airport_count DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of cities that have more than a specified number of airports. The placeholder in the HAVING clause represents the minimum count of airports required for a city to be included in the results.\",\n    \"1\": \"This virtual table provides a list of cities from the 'airports' table that are located in a specific country. The results are grouped by city, and only those cities with more than a specified number of airports are included. The placeholders in the WHERE clause represent the country's name, and the HAVING clause represents the minimum count of airports required for a city to be included in the results.\",\n    \"2\": \"The virtual table describes the names and cities of airports that serve as source airports for routes, along with their unique identifiers. The results are grouped by the source airport ID and ordered by the number of routes originating from each airport, limited to a specified number of results.\"\n}\n"}
{"sample_id": "train.6862", "db_id": "flight_4", "question": "For each  airport name, how many routes start at that airport, ordered from most to least?", "rationale": ["Identify the relevant table: The 'routes' table contains information about routes, including source airports.", "Determine the required information: We need to count the number of routes starting at each airport.", "Group the results: Use GROUP BY to aggregate the counts by the source airport name (src_ap).", "Count the routes: Use COUNT(rid) to count the number of routes for each source airport.", "Order the results: Use ORDER BY to sort the results in descending order based on the count of routes."], "gold_sql": "SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name ORDER BY count(*) DESC", "source_tables": ["airports", "routes"], "pred_sql": "SELECT src_ap, COUNT(rid) AS route_count \nFROM routes \nGROUP BY src_ap \nORDER BY route_count DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of airport names from the 'airports' table that are located in a specific country. It joins the 'airports' table with the 'routes' table to filter the airports based on their country and counts the number of routes originating from each airport. The results are grouped by airport name and ordered by the number of routes in descending order, with a limit on the number of results returned.\",\n    \"1\": \"The virtual table describes the names and cities of airports that serve as source airports for routes, along with their unique identifiers. The results are grouped by the source airport ID and ordered by the number of routes originating from each airport, limited to a specified number of results.\",\n    \"2\": \"This virtual table provides a list of destination airport names and their corresponding cities from the 'airports' table, along with the destination airport IDs from the 'routes' table. The results are grouped by destination airport ID and ordered by the count of routes to each destination, limited to a specified number of results.\"\n}\n"}
{"sample_id": "train.6867", "db_id": "flight_4", "question": "For each country and airline name, how many routes are there?", "rationale": ["Identify the tables needed: 'routes' for route information, 'airlines' for airline names, and 'airports' for country information.", "Join the 'routes' table with the 'airlines' table on the airline ID (alid) to get the airline names associated with each route.", "Join the 'routes' table with the 'airports' table on the source airport ID (src_apid) to get the country information for each route.", "Group the results by country and airline name to count the number of routes for each combination.", "Use COUNT() to count the number of routes (rid) for each group.", "Order the results by country and the count of routes in descending order."], "gold_sql": "SELECT T1.country ,  T1.name ,  count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.country ,  T1.name", "source_tables": ["routes", "airlines"], "pred_sql": "SELECT a.country, r.airline, COUNT(r.rid) AS route_count \nFROM routes r \nJOIN airlines a ON r.alid = a.alid \nJOIN airports ap ON r.src_apid = ap.apid \nGROUP BY a.country, r.airline \nORDER BY a.country, route_count DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of airport names from the 'airports' table that are located in a specific country. It joins the 'airports' table with the 'routes' table to filter the airports based on their country and counts the number of routes originating from each airport. The results are grouped by airport name and ordered by the number of routes in descending order, with a limit on the number of results returned.\",\n    \"1\": \"This virtual table provides a list of countries where active airlines are based, grouped by country. The placeholder in the WHERE clause indicates whether to filter for active airlines, and the LIMIT placeholder specifies the maximum number of countries to return, sorted by the number of active airlines in descending order.\",\n    \"2\": \"This virtual table provides a list of countries where active airlines are based, grouped by country. The placeholder in the WHERE clause indicates whether to filter for active airlines, and the LIMIT placeholder specifies the maximum number of countries to return, ordered by the number of active airlines in descending order.\"\n}\n"}
{"sample_id": "train.6868", "db_id": "flight_4", "question": "What is the total number of routes for each country and airline in that country?", "rationale": ["We need to find the total number of routes for each country and airline in that country.", "To achieve this, we will join the 'routes' table with the 'airlines' table to get the airline names and with the 'airports' table to get the country information.", "We will select the country from the 'airports' table, the airline name from the 'airlines' table, and count the number of routes from the 'routes' table.", "We will group the results by country and airline name to get the total routes for each combination.", "Finally, we will order the results by country and the total number of routes in descending order."], "gold_sql": "SELECT T1.country ,  T1.name ,  count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.country ,  T1.name", "source_tables": ["routes", "airlines"], "pred_sql": "SELECT a.country, al.name AS airline, COUNT(r.rid) AS total_routes\nFROM routes r\nJOIN airlines al ON r.alid = al.alid\nJOIN airports a ON r.src_apid = a.apid\nGROUP BY a.country, al.name\nORDER BY a.country, total_routes DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of airport names from the 'airports' table that are located in a specific country. It joins the 'airports' table with the 'routes' table to filter the airports based on their country and counts the number of routes originating from each airport. The results are grouped by airport name and ordered by the number of routes in descending order, with a limit on the number of results returned.\",\n    \"1\": \"This virtual table provides a list of countries where active airlines are based, grouped by country. The placeholder in the WHERE clause indicates whether to filter for active airlines, and the LIMIT placeholder specifies the maximum number of countries to return, sorted by the number of active airlines in descending order.\",\n    \"2\": \"This virtual table provides a list of countries where active airlines are based, grouped by country. The placeholder in the WHERE clause indicates whether to filter for active airlines, and the LIMIT placeholder specifies the maximum number of countries to return, ordered by the number of active airlines in descending order.\"\n}\n"}
{"sample_id": "train.6873", "db_id": "flight_4", "question": "Find the number of routes that have destination John F Kennedy International Airport.", "rationale": ["Identify the relevant table: The 'routes' table contains information about routes, including destination airports.", "Determine the condition: We need to filter the routes where the destination airport name is 'John F Kennedy International Airport'.", "Use the COUNT function: To find the number of routes, we will use the COUNT(*) function to count all rows that meet the condition.", "Construct the SQL query: Combine the SELECT statement with the COUNT function and the WHERE clause to filter by the destination airport name."], "gold_sql": "SELECT count(*) FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.name  =  'John F Kennedy International Airport'", "source_tables": ["airports", "routes"], "pred_sql": "SELECT COUNT(*) AS route_count \nFROM routes \nWHERE dst_ap = 'John F Kennedy International Airport';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of airport names from the 'airports' table that are located in a specific country. It joins the 'airports' table with the 'routes' table to filter the airports based on their country and counts the number of routes originating from each airport. The results are grouped by airport name and ordered by the number of routes in descending order, with a limit on the number of results returned.\",\n    \"1\": \"The virtual table describes the names and cities of airports that serve as source airports for routes, along with their unique identifiers. The results are grouped by the source airport ID and ordered by the number of routes originating from each airport, limited to a specified number of results.\",\n    \"2\": \"This virtual table provides a list of destination airport names and their corresponding cities from the 'airports' table, along with the destination airport IDs from the 'routes' table. The results are grouped by destination airport ID and ordered by the count of routes to each destination, limited to a specified number of results.\"\n}\n"}
{"sample_id": "train.6880", "db_id": "flight_4", "question": "What is the name of the airline with the most routes?", "rationale": ["To find the airline with the most routes, we need to count the number of routes associated with each airline.", "We will select the 'airline' column from the 'routes' table and use the COUNT function to count the number of routes for each airline.", "We will group the results by the 'airline' column to aggregate the counts for each airline.", "To get the airline with the most routes, we will order the results in descending order based on the count of routes.", "Finally, we will limit the results to 1 to get only the airline with the highest count."], "gold_sql": "SELECT T1.name FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["routes", "airlines"], "pred_sql": "SELECT airline, COUNT(*) as route_count \nFROM routes \nGROUP BY airline \nORDER BY route_count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of airport names from the 'airports' table that are located in a specific country. It joins the 'airports' table with the 'routes' table to filter the airports based on their country and counts the number of routes originating from each airport. The results are grouped by airport name and ordered by the number of routes in descending order, with a limit on the number of results returned.\",\n    \"1\": \"The virtual table describes the names and cities of airports that serve as source airports for routes, along with their unique identifiers. The results are grouped by the source airport ID and ordered by the number of routes originating from each airport, limited to a specified number of results.\",\n    \"2\": \"This virtual table provides a list of destination airport names and their corresponding cities from the 'airports' table, along with the destination airport IDs from the 'routes' table. The results are grouped by destination airport ID and ordered by the count of routes to each destination, limited to a specified number of results.\"\n}\n"}
{"sample_id": "train.6883", "db_id": "flight_4", "question": "Find the busiest destination airport that runs most number of routes in China.", "rationale": ["Identify the relevant tables: 'routes' for route information and 'airports' for airport details.", "We need to find the busiest destination airport in China, so we will filter the airports based on the country being 'China'.", "Join the 'routes' table with the 'airports' table on the destination airport ID to get the destination airport names and their corresponding route counts.", "Group the results by destination airport ID to count the number of routes for each destination airport.", "Order the results by the count of routes in descending order to find the busiest airport.", "Limit the results to 1 to get only the busiest destination airport."], "gold_sql": "SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.country  =  'China' GROUP BY T1.name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "pred_sql": "SELECT dst_ap, COUNT(rid) AS route_count \nFROM routes \nJOIN airports ON routes.dst_apid = airports.apid \nWHERE airports.country = 'China' \nGROUP BY dst_apid \nORDER BY route_count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of destination airport names and their corresponding cities from the 'airports' table, along with the destination airport IDs from the 'routes' table. The results are grouped by destination airport ID and ordered by the count of routes to each destination, limited to a specified number of results.\",\n    \"1\": \"The virtual table describes the names and cities of airports that serve as source airports for routes, along with their unique identifiers. The results are grouped by the source airport ID and ordered by the number of routes originating from each airport, limited to a specified number of results.\",\n    \"2\": \"This virtual table provides a list of airport names from the 'airports' table that are located in a specific country. It joins the 'airports' table with the 'routes' table to filter the airports based on their country and counts the number of routes originating from each airport. The results are grouped by airport name and ordered by the number of routes in descending order, with a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.6884", "db_id": "flight_4", "question": "What is the name of the airport that is the destination of the most number of routes that start in China?", "rationale": ["Identify the destination airport names from the routes table.", "Count the number of routes for each destination airport.", "Filter the source airports to only include those located in China.", "Group the results by destination airport name to aggregate the route counts.", "Order the results by the count of routes in descending order to find the most popular destination.", "Limit the results to only the top entry to get the destination airport with the most routes from China."], "gold_sql": "SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.country  =  'China' GROUP BY T1.name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "pred_sql": "SELECT dst_ap, COUNT(*) as route_count\nFROM routes\nJOIN airports ON routes.dst_apid = airports.apid\nWHERE src_apid IN (\n    SELECT apid\n    FROM airports\n    WHERE country = 'China'\n)\nGROUP BY dst_ap\nORDER BY route_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names and cities of airports that serve as source airports for routes, along with their unique identifiers. The results are grouped by the source airport ID and ordered by the number of routes originating from each airport, limited to a specified number of results.\",\n    \"1\": \"This virtual table provides a list of destination airport names and their corresponding cities from the 'airports' table, along with the destination airport IDs from the 'routes' table. The results are grouped by destination airport ID and ordered by the count of routes to each destination, limited to a specified number of results.\",\n    \"2\": \"This virtual table provides a list of airport names from the 'airports' table that are located in a specific country. It joins the 'airports' table with the 'routes' table to filter the airports based on their country and counts the number of routes originating from each airport. The results are grouped by airport name and ordered by the number of routes in descending order, with a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.6980", "db_id": "culture_company", "question": "Show all publishers which do not have a book in 1989.", "rationale": ["Identify the main goal: to find all publishers that do not have a book published in 1989.", "Use the 'book_club' table to access the 'Publisher' and 'Year' columns.", "Create a subquery to find all publishers that have books published in 1989.", "Use the DISTINCT keyword to ensure that each publisher is listed only once.", "In the main query, select distinct publishers from the 'book_club' table where the publisher is not in the list generated by the subquery."], "gold_sql": "SELECT publisher FROM book_club EXCEPT SELECT publisher FROM book_club WHERE YEAR  =  1989", "source_tables": ["book_club"], "pred_sql": "SELECT DISTINCT Publisher FROM book_club WHERE Publisher NOT IN (SELECT DISTINCT Publisher FROM book_club WHERE Year = '1989');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the publishers of books discussed in the 'book_club' table, excluding those publishers whose books were published in a specific year. The placeholder in the WHERE clause represents the year to be excluded.\"\n}\n"}
{"sample_id": "train.6990", "db_id": "culture_company", "question": "Show all director names who have a movie in the year 1999 or 2000.", "rationale": ["Identify the table that contains the information about movies, which is the 'movie' table.", "Determine the relevant column that contains the director's names, which is 'Director'.", "Identify the column that contains the year of the movie, which is 'Year'.", "Use the SQL 'SELECT' statement to retrieve distinct director names from the 'movie' table.", "Apply a 'WHERE' clause to filter the results for the years 1999 and 2000 using the 'IN' operator."], "gold_sql": "SELECT director FROM movie WHERE YEAR  =  1999 OR YEAR  =  2000", "source_tables": ["movie"], "pred_sql": "SELECT DISTINCT Director FROM movie WHERE Year IN (1999, 2000);", "hint": "\n"}
{"sample_id": "train.6991", "db_id": "culture_company", "question": "Which directors had a movie in either 1999 or 2000?", "rationale": ["Identify the relevant table: The question pertains to movie directors, so we will focus on the 'movie' table.", "Determine the columns needed: We need the 'Director' column to answer the question.", "Filter the results: We need to filter the movies based on the years 1999 and 2000.", "Use the DISTINCT keyword: Since we want to know which directors had movies in those years, we should use DISTINCT to avoid duplicate entries for directors who may have multiple movies in those years."], "gold_sql": "SELECT director FROM movie WHERE YEAR  =  1999 OR YEAR  =  2000", "source_tables": ["movie"], "pred_sql": "SELECT DISTINCT Director FROM movie WHERE Year IN (1999, 2000);", "hint": "\n"}
{"sample_id": "train.6996", "db_id": "culture_company", "question": "Show the movie titles and book titles for all companies in China.", "rationale": ["Identify the tables involved: culture_company, movie, and book_club.", "Determine the columns needed: movie titles from the movie table and book titles from the book_club table.", "Establish the relationships between the tables using JOINs: culture_company to movie and culture_company to book_club.", "Filter the results to only include companies in China using a WHERE clause on the Company_name column."], "gold_sql": "SELECT T1.title ,  T3.book_title FROM movie AS T1 JOIN culture_company AS T2 ON T1.movie_id  =  T2.movie_id JOIN book_club AS T3 ON T3.book_club_id  =  T2.book_club_id WHERE T2.incorporated_in  =  'China'", "source_tables": ["culture_company", "movie", "book_club"], "pred_sql": "SELECT movie.Title AS Movie_Title, book_club.Book_Title AS Book_Title\nFROM culture_company\nJOIN movie ON culture_company.movie_id = movie.movie_id\nJOIN book_club ON culture_company.book_club_id = book_club.book_club_id\nWHERE culture_company.Company_name = 'China';", "hint": "\n"}
{"sample_id": "dev.95", "db_id": "car_1", "question": "Which model of the car has the minimum horsepower?", "rationale": ["Identify the relevant tables: We need to find the car model with the minimum horsepower, so we will use the 'cars_data' table for horsepower and the 'car_names' table for the car model.", "Join the tables: We will join 'cars_data' and 'car_names' on the 'Id' and 'MakeId' columns respectively to get the model names along with their horsepower.", "Order the results: To find the model with the minimum horsepower, we will order the results by the 'Horsepower' column in ascending order.", "Limit the results: Since we only want the model with the minimum horsepower, we will limit the results to 1."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT Model, Horsepower FROM cars_data JOIN car_names ON cars_data.Id = car_names.MakeId ORDER BY Horsepower ASC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies car makers who have produced a significant number of car models and have those models associated with specific car names. The placeholders in the HAVING clauses represent the minimum counts of models and names that must be met for the car makers to be included in the results.\",\n    \"1\": \"This virtual table provides the make of the car and the year it was manufactured from the 'cars_data' and 'car_names' tables. The query filters the results to show only the car models that were manufactured in the earliest year recorded in the 'cars_data' table.\",\n    \"2\": \"This virtual table provides a list of distinct car models from the 'model_list' table that meet specific criteria. It filters the results based on the weight of the cars from the 'cars_data' table, ensuring that only cars lighter than a specified weight are included. Additionally, it excludes car makers based on their full name from the 'car_makers' table, using a placeholder for the name to be excluded.\"\n}\n"}
{"sample_id": "dev.103", "db_id": "car_1", "question": "Which distinct car models are the produced after 1980?", "rationale": ["We need to find distinct car models produced after 1980.", "The relevant tables for this query are 'car_names' and 'cars_data'.", "We will join 'car_names' with 'cars_data' on the 'MakeId' and 'Id' columns respectively to link car models with their production years.", "We will filter the results using a WHERE clause to include only those records where the 'Year' in 'cars_data' is greater than 1980.", "Finally, we will select distinct car models from the result set."], "gold_sql": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  1980;", "source_tables": ["model_list", "car_names", "cars_data"], "pred_sql": "SELECT DISTINCT car_names.Model \nFROM car_names \nJOIN cars_data ON car_names.MakeId = cars_data.Id \nWHERE cars_data.Year > 1980;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies car makers who have produced a significant number of car models and have those models associated with specific car names. The placeholders in the HAVING clauses represent the minimum counts of models and names that must be met for the car makers to be included in the results.\",\n    \"1\": \"This virtual table provides the make of the car and the year it was manufactured from the 'cars_data' and 'car_names' tables. The query filters the results to show only the car models that were manufactured in the earliest year recorded in the 'cars_data' table.\",\n    \"2\": \"This virtual table provides a list of distinct car models from the 'model_list' table that meet specific criteria. It filters the results based on the weight of the cars from the 'cars_data' table, ensuring that only cars lighter than a specified weight are included. Additionally, it excludes car makers based on their full name from the 'car_makers' table, using a placeholder for the name to be excluded.\"\n}\n"}
{"sample_id": "dev.106", "db_id": "car_1", "question": "What is the name of each continent and how many car makers are there in each one?", "rationale": ["We need to retrieve the names of continents and the count of car makers in each continent.", "Start by selecting the 'Continent' from the 'continents' table.", "Join the 'countries' table on the continent ID to get the countries belonging to each continent.", "Next, join the 'car_makers' table on the country ID to get the car makers associated with those countries.", "Use COUNT() to count the number of car makers for each continent.", "Group the results by continent to get the count for each one."], "gold_sql": "SELECT T1.Continent ,  count(*) FROM CONTINENTS AS T1 JOIN COUNTRIES AS T2 ON T1.ContId  =  T2.continent JOIN car_makers AS T3 ON T2.CountryId  =  T3.Country GROUP BY T1.Continent;", "source_tables": ["countries", "car_makers", "continents"], "pred_sql": "SELECT c.Continent, COUNT(cm.Id) AS CarMakerCount\nFROM continents c\nJOIN countries co ON c.ContId = co.Continent\nJOIN car_makers cm ON co.CountryId = cm.Country\nGROUP BY c.Continent;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of countries from the 'countries' table that belong to a specific continent. It joins the 'continents' table to filter countries by continent and the 'car_makers' table to ensure that the countries have car makers associated with them. The placeholders in the WHERE clause represent the continent's name and the minimum count of car makers per country.\",\n    \"1\": \"This virtual table identifies car makers who have produced a significant number of car models and have those models associated with specific car names. The placeholders in the HAVING clauses represent the minimum counts of models and names that must be met for the car makers to be included in the results.\",\n    \"2\": \"This virtual table provides the count of car makers for each country from the 'countries' and 'car_makers' tables. The placeholder in the HAVING clause represents the minimum number of car makers required for a country to be included in the results.\"\n}\n"}
{"sample_id": "dev.111", "db_id": "car_1", "question": "What is the accelerate of the car make amc hornet sportabout (sw)?", "rationale": ["Identify the relevant tables: We need to find the accelerate of a specific car make and model, which involves the 'cars_data', 'car_names', 'model_list', and 'car_makers' tables.", "Join the tables: We will join 'cars_data' with 'car_names' on the 'MakeId', then join 'car_names' with 'model_list' on 'Model', and finally join 'model_list' with 'car_makers' on 'Maker'.", "Filter the results: We need to filter the results to only include the car maker 'amc' and the model 'hornet sportabout (sw)'.", "Select the desired column: We will select the 'Accelerate' column from the 'cars_data' table."], "gold_sql": "SELECT T1.Accelerate FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Make  =  'amc hornet sportabout (sw)';", "source_tables": ["cars_data", "car_names"], "pred_sql": "SELECT cars_data.Accelerate \nFROM cars_data \nJOIN car_names ON cars_data.Id = car_names.MakeId \nJOIN model_list ON car_names.Model = model_list.Model \nJOIN car_makers ON model_list.Maker = car_makers.Id \nWHERE car_makers.Maker = 'amc' AND car_names.Model = 'hornet sportabout (sw)';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies car makers who have produced a significant number of car models and have those models associated with specific car names. The placeholders in the HAVING clauses represent the minimum counts of models and names that must be met for the car makers to be included in the results.\",\n    \"1\": \"This virtual table provides the make of the car and the year it was manufactured from the 'cars_data' and 'car_names' tables. The query filters the results to show only the car models that were manufactured in the earliest year recorded in the 'cars_data' table.\"\n}\n"}
{"sample_id": "dev.113", "db_id": "car_1", "question": "How many car makers are there in france?", "rationale": ["Identify the relevant tables: 'car_makers' for car makers and 'countries' for country information.", "We need to count the number of car makers based in France, so we will use the COUNT() function.", "Join the 'car_makers' table with the 'countries' table on the country identifier to filter car makers by country.", "Use a WHERE clause to specify that we are only interested in car makers from France by matching the 'CountryName' column in the 'countries' table."], "gold_sql": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  'france';", "source_tables": ["car_makers", "countries"], "pred_sql": "SELECT COUNT(*) AS NumberOfCarMakers\nFROM car_makers\nJOIN countries ON car_makers.Country = countries.CountryId\nWHERE countries.CountryName = 'France';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies car makers who have produced a significant number of car models and have those models associated with specific car names. The placeholders in the HAVING clauses represent the minimum counts of models and names that must be met for the car makers to be included in the results.\",\n    \"1\": \"This virtual table provides the count of car makers for each country from the 'countries' and 'car_makers' tables. The placeholder in the HAVING clause represents the minimum number of car makers required for a country to be included in the results.\",\n    \"2\": \"This virtual table provides the count of car makers for each country from the 'countries' and 'car_makers' tables. It filters the results to show only those countries that have more than a specified number of car makers, represented by a placeholder in the HAVING clause.\"\n}\n"}
{"sample_id": "dev.114", "db_id": "car_1", "question": "What is the number of makers of care in France?", "rationale": ["Identify the relevant tables: 'car_makers' for car makers and 'countries' for country information.", "We need to count the number of car makers based in France, so we will join the 'car_makers' table with the 'countries' table on the country identifier.", "Filter the results to include only those car makers whose country is France by using a WHERE clause.", "Use COUNT(*) to get the total number of car makers in France."], "gold_sql": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  'france';", "source_tables": ["car_makers", "countries"], "pred_sql": "SELECT COUNT(*) AS NumberOfMakers\nFROM car_makers cm\nJOIN countries c ON cm.Country = c.CountryId\nWHERE c.CountryName = 'France';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of car makers for each country from the 'countries' and 'car_makers' tables. It filters the results to show only those countries that have more than a specified number of car makers, represented by a placeholder in the HAVING clause.\",\n    \"1\": \"This virtual table provides the count of car makers for each country from the 'countries' and 'car_makers' tables. The placeholder in the HAVING clause represents the minimum number of car makers required for a country to be included in the results.\",\n    \"2\": \"This virtual table identifies car makers who have produced a significant number of car models and have those models associated with specific car names. The placeholders in the HAVING clauses represent the minimum counts of models and names that must be met for the car makers to be included in the results.\"\n}\n"}
{"sample_id": "dev.115", "db_id": "car_1", "question": "How many car models are produced in the usa?", "rationale": ["Identify the relevant tables: car_makers, countries, and model_list.", "We need to count the distinct car models produced in the USA.", "Join the car_makers table with the countries table to filter for the USA.", "Join the model_list table to get the car models associated with the car makers from the USA.", "Use COUNT(DISTINCT model_list.Model) to get the number of unique car models produced in the USA."], "gold_sql": "SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  'usa';", "source_tables": ["car_makers", "model_list", "countries"], "pred_sql": "SELECT COUNT(DISTINCT model_list.Model) AS NumberOfCarModels\nFROM car_makers\nJOIN countries ON car_makers.Country = countries.CountryId\nJOIN model_list ON car_makers.Id = model_list.Maker\nWHERE countries.Country = 'usa';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies car makers who have produced a significant number of car models and have those models associated with specific car names. The placeholders in the HAVING clauses represent the minimum counts of models and names that must be met for the car makers to be included in the results.\",\n    \"1\": \"This virtual table provides the make of the car and the year it was manufactured from the 'cars_data' and 'car_names' tables. The query filters the results to show only the car models that were manufactured in the earliest year recorded in the 'cars_data' table.\",\n    \"2\": \"This virtual table provides the count of car makers for each country from the 'countries' and 'car_makers' tables. The placeholder in the HAVING clause represents the minimum number of car makers required for a country to be included in the results.\"\n}\n"}
{"sample_id": "dev.129", "db_id": "car_1", "question": "Which countries in europe have at least 3 car manufacturers?", "rationale": ["Identify the relevant tables: countries, car_makers, and continents.", "Join the countries table with the car_makers table to associate countries with their car manufacturers.", "Join the continents table to filter the countries by the continent of Europe.", "Group the results by country name to count the number of car manufacturers per country.", "Use the HAVING clause to filter countries that have at least 3 car manufacturers."], "gold_sql": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  'europe' GROUP BY T1.CountryName HAVING count(*)  >=  3;", "source_tables": ["continents", "car_makers", "countries"], "pred_sql": "SELECT c.CountryName\nFROM countries c\nJOIN car_makers cm ON c.CountryId = cm.Country\nJOIN continents con ON c.Continent = con.ContId\nWHERE con.Continent = 'Europe'\nGROUP BY c.CountryName\nHAVING COUNT(cm.Id) >= 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies car makers who have produced a significant number of car models and have those models associated with specific car names. The placeholders in the HAVING clauses represent the minimum counts of models and names that must be met for the car makers to be included in the results.\",\n    \"1\": \"This virtual table lists the names of countries from the 'countries' table that belong to a specific continent. It joins the 'continents' table to filter countries by continent and the 'car_makers' table to ensure that the countries have car makers associated with them. The placeholders in the WHERE clause represent the continent's name and the minimum count of car makers per country.\",\n    \"2\": \"This virtual table provides the count of car makers for each country from the 'countries' and 'car_makers' tables. The placeholder in the HAVING clause represents the minimum number of car makers required for a country to be included in the results.\"\n}\n"}
{"sample_id": "dev.131", "db_id": "car_1", "question": "What is the maximum horsepower and the make of the car models with 3 cylinders?", "rationale": ["Identify the relevant tables: 'cars_data' for horsepower and cylinders, and 'car_names' for the make of the car.", "We need to find the maximum horsepower for car models with 3 cylinders, so we will filter the 'cars_data' table where Cylinders = 3.", "To get the make of the car, we will join 'cars_data' with 'car_names' on the appropriate foreign key (cars_data.Id = car_names.MakeId).", "We will use the MAX() function to get the maximum horsepower and group the results by the make of the car to ensure we get the make associated with that maximum horsepower."], "gold_sql": "SELECT T2.horsepower ,  T1.Make FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.cylinders  =  3 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT MAX(cars_data.Horsepower) AS MaxHorsepower, car_names.Make \nFROM cars_data \nJOIN car_names ON cars_data.Id = car_names.MakeId \nWHERE cars_data.Cylinders = 3 \nGROUP BY car_names.Make;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies car makers who have produced a significant number of car models and have those models associated with specific car names. The placeholders in the HAVING clauses represent the minimum counts of models and names that must be met for the car makers to be included in the results.\",\n    \"1\": \"This virtual table provides the make of the car and the year it was manufactured from the 'cars_data' and 'car_names' tables. The query filters the results to show only the car models that were manufactured in the earliest year recorded in the 'cars_data' table.\",\n    \"2\": \"This virtual table provides the count of car makers for each country from the 'countries' and 'car_makers' tables. The placeholder in the HAVING clause represents the minimum number of car makers required for a country to be included in the results.\"\n}\n"}
{"sample_id": "dev.133", "db_id": "car_1", "question": "Which model saves the most gasoline? That is to say, have the maximum miles per gallon.", "rationale": ["Identify the relevant tables: 'cars_data' for MPG and 'car_names' for car models.", "Join 'cars_data' and 'car_names' on the foreign key 'MakeId' to associate car models with their MPG.", "Select the 'Model' and 'MPG' columns from the joined tables.", "Order the results by 'MPG' in descending order to get the model with the highest MPG at the top.", "Limit the results to 1 to get only the model that saves the most gasoline."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.mpg DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT Model, MPG FROM cars_data JOIN car_names ON cars_data.Id = car_names.MakeId ORDER BY MPG DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies car makers who have produced a significant number of car models and have those models associated with specific car names. The placeholders in the HAVING clauses represent the minimum counts of models and names that must be met for the car makers to be included in the results.\",\n    \"1\": \"This virtual table provides the make of the car and the year it was manufactured from the 'cars_data' and 'car_names' tables. The query filters the results to show only the car models that were manufactured in the earliest year recorded in the 'cars_data' table.\",\n    \"2\": \"This virtual table provides a list of distinct car models from the 'model_list' table that meet specific criteria. It filters the results based on the weight of the cars from the 'cars_data' table, ensuring that only cars lighter than a specified weight are included. Additionally, it excludes car makers based on their full name from the 'car_makers' table, using a placeholder for the name to be excluded.\"\n}\n"}
{"sample_id": "dev.150", "db_id": "car_1", "question": "What are the names and ids of all makers with more than 3 models?", "rationale": ["Identify the relevant tables: car_makers and model_list.", "We need to join these tables on the car maker's ID to access the models associated with each maker.", "Group the results by the car maker's ID and name to count the number of models for each maker.", "Use the HAVING clause to filter the groups to only include those with more than 3 models."], "gold_sql": "SELECT T1.FullName ,  T1.Id FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >  3;", "source_tables": ["car_makers", "model_list"], "pred_sql": "SELECT cm.Id, cm.Maker \nFROM car_makers cm \nJOIN model_list ml ON cm.Id = ml.Maker \nGROUP BY cm.Id, cm.Maker \nHAVING COUNT(ml.ModelId) > 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies car makers who have produced a significant number of car models and have those models associated with specific car names. The placeholders in the HAVING clauses represent the minimum counts of models and names that must be met for the car makers to be included in the results.\",\n    \"1\": \"This virtual table provides the count of car makers for each country from the 'countries' and 'car_makers' tables. It filters the results to show only those countries that have more than a specified number of car makers, represented by a placeholder in the HAVING clause.\",\n    \"2\": \"This virtual table provides the make of the car and the year it was manufactured from the 'cars_data' and 'car_names' tables. The query filters the results to show only the car models that were manufactured in the earliest year recorded in the 'cars_data' table.\"\n}\n"}
{"sample_id": "dev.158", "db_id": "car_1", "question": "For a volvo model, how many cylinders does the version with least accelerate have?", "rationale": ["Identify the relevant tables: cars_data, car_names, model_list, and car_makers.", "We need to filter for the car maker 'Volvo'.", "Join the tables on their respective foreign keys to access the necessary columns: Cylinders and Accelerate.", "Sort the results by the Accelerate column in ascending order to find the version with the least accelerate.", "Limit the results to 1 to get only the top result, which will be the version with the least accelerate."], "gold_sql": "SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  'volvo' ORDER BY T1.accelerate ASC LIMIT 1;", "source_tables": ["cars_data", "car_names"], "pred_sql": "SELECT c.Cylinders\nFROM cars_data AS cd\nJOIN car_names AS cn ON cd.Id = cn.MakeId\nJOIN model_list AS ml ON cn.Model = ml.Model\nJOIN car_makers AS cm ON ml.Maker = cm.Id\nWHERE cm.Maker = 'Volvo'\nORDER BY cd.Accelerate ASC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies car makers who have produced a significant number of car models and have those models associated with specific car names. The placeholders in the HAVING clauses represent the minimum counts of models and names that must be met for the car makers to be included in the results.\",\n    \"1\": \"This virtual table provides the count of car makers for each country from the 'countries' and 'car_makers' tables. The placeholder in the HAVING clause represents the minimum number of car makers required for a country to be included in the results.\",\n    \"2\": \"This virtual table provides the make of the car and the year it was manufactured from the 'cars_data' and 'car_names' tables. The query filters the results to show only the car models that were manufactured in the earliest year recorded in the 'cars_data' table.\"\n}\n"}
{"sample_id": "dev.160", "db_id": "car_1", "question": "What is the number of cars with a greater accelerate than the one with the most horsepower?", "rationale": ["Identify the requirement: We need to count the number of cars with an 'Accelerate' value greater than the maximum 'Horsepower' of any car.", "To find the maximum horsepower, we will use a subquery: SELECT MAX(Horsepower) FROM cars_data.", "The main query will count all entries in the 'cars_data' table where the 'Accelerate' value is greater than the result of the subquery.", "Combine the subquery with the main query using a WHERE clause to filter the results accordingly."], "gold_sql": "SELECT COUNT(*) FROM CARS_DATA WHERE Accelerate  >  ( SELECT Accelerate FROM CARS_DATA ORDER BY Horsepower DESC LIMIT 1 );", "source_tables": ["cars_data"], "pred_sql": "SELECT COUNT(*) \nFROM cars_data \nWHERE Accelerate > (SELECT MAX(Horsepower) \n                     FROM cars_data)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies car makers who have produced a significant number of car models and have those models associated with specific car names. The placeholders in the HAVING clauses represent the minimum counts of models and names that must be met for the car makers to be included in the results.\",\n    \"1\": \"This virtual table provides the count of car makers for each country from the 'countries' and 'car_makers' tables. It filters the results to show only those countries that have more than a specified number of car makers, represented by a placeholder in the HAVING clause.\",\n    \"2\": \"This virtual table provides the count of car makers for each country from the 'countries' and 'car_makers' tables. The placeholder in the HAVING clause represents the minimum number of car makers required for a country to be included in the results.\"\n}\n"}
{"sample_id": "dev.165", "db_id": "car_1", "question": "For the cars with 4 cylinders, which model has the largest horsepower?", "rationale": ["Identify the relevant tables: cars_data for car specifications and car_names for car models.", "We need to filter the cars based on the number of cylinders, specifically those with 4 cylinders.", "We want to find the model with the largest horsepower, so we will order the results by horsepower in descending order.", "To get the model name along with horsepower, we will join the cars_data table with the car_names table on the MakeId.", "Finally, we will limit the results to only the top entry to get the model with the largest horsepower."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  4 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT Model, Horsepower \nFROM cars_data \nJOIN car_names ON cars_data.Id = car_names.MakeId \nWHERE Cylinders = 4 \nORDER BY Horsepower DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies car makers who have produced a significant number of car models and have those models associated with specific car names. The placeholders in the HAVING clauses represent the minimum counts of models and names that must be met for the car makers to be included in the results.\",\n    \"1\": \"This virtual table provides the make of the car and the year it was manufactured from the 'cars_data' and 'car_names' tables. The query filters the results to show only the car models that were manufactured in the earliest year recorded in the 'cars_data' table.\",\n    \"2\": \"This virtual table provides the count of car makers for each country from the 'countries' and 'car_makers' tables. The placeholder in the HAVING clause represents the minimum number of car makers required for a country to be included in the results.\"\n}\n"}
{"sample_id": "dev.166", "db_id": "car_1", "question": "For all of the 4 cylinder cars, which model has the most horsepower?", "rationale": ["Identify the relevant tables: We need data from the 'cars_data' and 'car_names' tables to find the model and horsepower of 4 cylinder cars.", "Filter the cars: We will filter the results to include only those cars that have 4 cylinders by using a WHERE clause.", "Select the model and horsepower: We will select the model name and the maximum horsepower from the filtered results.", "Group the results: We will group the results by model to ensure we can find the maximum horsepower for each model.", "Order the results: We will order the results in descending order based on horsepower to get the model with the highest horsepower at the top.", "Limit the results: Finally, we will limit the results to just one entry to get the model with the most horsepower."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  4 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT Model, MAX(Horsepower) AS MaxHorsepower\nFROM cars_data\nJOIN car_names ON cars_data.Id = car_names.MakeId\nWHERE Cylinders = 4\nGROUP BY Model\nORDER BY MaxHorsepower DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies car makers who have produced a significant number of car models and have those models associated with specific car names. The placeholders in the HAVING clauses represent the minimum counts of models and names that must be met for the car makers to be included in the results.\",\n    \"1\": \"This virtual table provides the make of the car and the year it was manufactured from the 'cars_data' and 'car_names' tables. The query filters the results to show only the car models that were manufactured in the earliest year recorded in the 'cars_data' table.\",\n    \"2\": \"This virtual table provides the count of car makers for each country from the 'countries' and 'car_makers' tables. The placeholder in the HAVING clause represents the minimum number of car makers required for a country to be included in the results.\"\n}\n"}
{"sample_id": "dev.168", "db_id": "car_1", "question": "Among the cars that do not have the minimum horsepower , what are the make ids and names of all those with less than 4 cylinders ?", "rationale": ["Identify the relevant tables: We need to look at the 'cars_data' table for horsepower and cylinders, and the 'car_names' table for make IDs and names.", "Determine the condition for horsepower: We need to find cars with horsepower less than the minimum horsepower across all cars, which can be obtained using a subquery.", "Determine the condition for cylinders: We need to filter for cars that have less than 4 cylinders.", "Join the 'cars_data' and 'car_names' tables on the appropriate foreign key to get the make IDs and names of the cars that meet the conditions.", "Construct the SQL query to select the MakeId and Make from the joined tables, applying the conditions for horsepower and cylinders."], "gold_sql": "select t2.makeid ,  t2.make from cars_data as t1 join car_names as t2 on t1.id  =  t2.makeid where t1.horsepower  >  (select min(horsepower) from cars_data) and t1.cylinders  <  4;", "source_tables": ["cars_data", "car_names"], "pred_sql": "SELECT car_names.MakeId, car_names.Make \nFROM cars_data \nJOIN car_names ON cars_data.Id = car_names.MakeId \nWHERE cars_data.Horsepower < (SELECT MIN(Horsepower) FROM cars_data) \nAND cars_data.Cylinders < 4;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies car makers who have produced a significant number of car models and have those models associated with specific car names. The placeholders in the HAVING clauses represent the minimum counts of models and names that must be met for the car makers to be included in the results.\",\n    \"1\": \"This virtual table provides the count of car makers for each country from the 'countries' and 'car_makers' tables. The placeholder in the HAVING clause represents the minimum number of car makers required for a country to be included in the results.\",\n    \"2\": \"This virtual table provides the make of the car and the year it was manufactured from the 'cars_data' and 'car_names' tables. The query filters the results to show only the car models that were manufactured in the earliest year recorded in the 'cars_data' table.\"\n}\n"}
{"sample_id": "dev.176", "db_id": "car_1", "question": "What are the ids and makers of all car makers that produce at least 2 models and make more than 3 cars?", "rationale": ["Identify the relevant tables: car_makers, model_list, car_names, and cars_data.", "Join these tables on their respective foreign keys to link car makers to their models and the cars associated with those models.", "Group the results by car maker's Id and Maker name to aggregate the data for each maker.", "Use the HAVING clause to filter the results: count the distinct models for each maker and ensure it is at least 2, and count the distinct cars produced by each maker to ensure it is more than 3."], "gold_sql": "SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >=  2 INTERSECT SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker JOIN CAR_NAMES AS T3 ON T2.model  =  T3.model GROUP BY T1.Id HAVING count(*)  >  3;", "source_tables": ["car_makers", "car_names", "model_list"], "pred_sql": "SELECT cm.Id, cm.Maker\nFROM car_makers cm\nJOIN model_list ml ON cm.Id = ml.Maker\nJOIN car_names cn ON ml.Model = cn.Model\nJOIN cars_data cd ON cn.MakeId = cd.Id\nGROUP BY cm.Id, cm.Maker\nHAVING COUNT(DISTINCT ml.Model) >= 2 AND COUNT(DISTINCT cd.Id) > 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies car makers who have produced a significant number of car models and have those models associated with specific car names. The placeholders in the HAVING clauses represent the minimum counts of models and names that must be met for the car makers to be included in the results.\",\n    \"1\": \"This virtual table provides the count of car makers for each country from the 'countries' and 'car_makers' tables. It filters the results to show only those countries that have more than a specified number of car makers, represented by a placeholder in the HAVING clause.\",\n    \"2\": \"This virtual table provides the make of the car and the year it was manufactured from the 'cars_data' and 'car_names' tables. The query filters the results to show only the car models that were manufactured in the earliest year recorded in the 'cars_data' table.\"\n}\n"}
{"sample_id": "dev.180", "db_id": "flight_2", "question": "What country is Jetblue Airways affiliated with?", "rationale": ["Identify the relevant table: The 'airlines' table contains information about airlines, including their names and associated countries.", "Determine the specific airline: The question asks for the country affiliated with 'Jetblue Airways'.", "Construct the SQL query: Use a SELECT statement to retrieve the 'Country' from the 'airlines' table where the 'Airline' matches 'Jetblue Airways'."], "gold_sql": "SELECT Country FROM AIRLINES WHERE Airline  =  'JetBlue Airways'", "source_tables": ["airlines"], "pred_sql": "SELECT Country FROM airlines WHERE Airline = 'Jetblue Airways';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the abbreviations and countries of airlines that operate flights. The data is aggregated by airline, showing the most frequently operating airlines based on the number of flights. The placeholder in the LIMIT clause allows the user to specify the maximum number of results to return.\",\n    \"1\": \"This virtual table lists the names of airlines that operate more than a specified number of flights. The placeholder in the HAVING clause represents the minimum number of flights an airline must operate to be included in the results.\"\n}\n"}
{"sample_id": "dev.194", "db_id": "flight_2", "question": "Give the airline with abbreviation 'UAL'.", "rationale": ["Identify the relevant table: The 'airlines' table contains the abbreviation and name of the airline.", "Formulate the query: We need to select the 'Airline' and 'Abbreviation' columns from the 'airlines' table.", "Add a condition: We want to filter the results to only include the airline with the abbreviation 'UAL'.", "Construct the SQL query: Combine the SELECT statement with the WHERE clause to get the final query."], "gold_sql": "SELECT Airline FROM AIRLINES WHERE Abbreviation  =  'UAL'", "source_tables": ["airlines"], "pred_sql": "SELECT Airline, Abbreviation FROM airlines WHERE Abbreviation = 'UAL';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the abbreviations and countries of airlines that operate flights. The data is aggregated by airline, showing the most frequently operating airlines based on the number of flights. The placeholder in the LIMIT clause allows the user to specify the maximum number of results to return.\",\n    \"1\": \"This virtual table lists the names of airlines that operate more than a specified number of flights. The placeholder in the HAVING clause represents the minimum number of flights an airline must operate to be included in the results.\",\n    \"2\": \"This virtual table lists the names of airlines from the 'airlines' table that operate more than a specified number of flights. The placeholder in the HAVING clause represents the minimum number of flights an airline must operate to be included in the results.\"\n}\n"}
{"sample_id": "dev.214", "db_id": "flight_2", "question": "Give the number of Jetblue Airways flights.", "rationale": ["Identify the airline of interest: Jetblue Airways.", "Determine the relevant table: flights, which contains flight information including the airline name.", "Use the COUNT() function to count the number of flights for Jetblue Airways.", "Construct the SQL query to select the count of flights where the Airline column matches 'Jetblue Airways'."], "gold_sql": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T1.Airline  =  T2.uid WHERE T2.Airline = 'JetBlue Airways'", "source_tables": ["flights", "airlines"], "pred_sql": "SELECT COUNT(*) AS NumberOfFlights\nFROM flights\nWHERE Airline = 'Jetblue Airways';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of airlines that operate more than a specified number of flights. The placeholder in the HAVING clause represents the minimum number of flights an airline must operate to be included in the results.\",\n    \"1\": \"This virtual table lists the names of airlines from the 'airlines' table that operate more than a specified number of flights. The placeholder in the HAVING clause represents the minimum number of flights an airline must operate to be included in the results.\",\n    \"2\": \"This virtual table lists the names of airlines from the 'airlines' table that operate fewer flights than a specified number. The placeholder in the HAVING clause represents the maximum number of flights an airline can operate.\"\n}\n"}
{"sample_id": "dev.225", "db_id": "flight_2", "question": "What is the code of airport that has the highest number of flights?", "rationale": ["Identify the relevant table: The 'flights' table contains information about flights, including the source and destination airports.", "Determine the goal: We need to find the airport code with the highest number of flights.", "Group the data: Use GROUP BY on the 'SourceAirport' to aggregate the number of flights for each airport.", "Count the flights: Use COUNT(*) to count the number of flights for each source airport.", "Order the results: Use ORDER BY COUNT(*) DESC to sort the airports by the number of flights in descending order.", "Limit the results: Use LIMIT 1 to get only the airport with the highest number of flights."], "gold_sql": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "flights"], "pred_sql": "SELECT SourceAirport AS AirportCode\nFROM flights\nGROUP BY SourceAirport\nORDER BY COUNT(*) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the abbreviations and countries of airlines that operate flights. The data is aggregated by airline, showing the most frequently operating airlines based on the number of flights. The placeholder in the LIMIT clause allows the user to specify the maximum number of results to return.\",\n    \"1\": \"This virtual table lists the names of airlines that operate more than a specified number of flights. The placeholder in the HAVING clause represents the minimum number of flights an airline must operate to be included in the results.\"\n}\n"}
{"sample_id": "dev.227", "db_id": "flight_2", "question": "What is the code of airport that has fewest number of flights?", "rationale": ["Identify the relevant table: The 'flights' table contains information about flights, including the source airport.", "Group the data: We need to group the flights by the source airport to count the number of flights for each airport.", "Count the flights: Use COUNT(*) to count the number of flights for each source airport.", "Order the results: We want to find the airport with the fewest number of flights, so we order the results in ascending order based on the count of flights.", "Limit the results: Since we only want the airport with the fewest flights, we use LIMIT 1 to get the top result."], "gold_sql": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) LIMIT 1", "source_tables": ["airports", "flights"], "pred_sql": "SELECT SourceAirport AS AirportCode\nFROM flights\nGROUP BY SourceAirport\nORDER BY COUNT(*) ASC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of airlines from the 'airlines' table that operate fewer flights than a specified number. The placeholder in the HAVING clause represents the maximum number of flights an airline can operate.\",\n    \"1\": \"This virtual table provides a summary of the abbreviations and countries of airlines that operate flights. The data is aggregated by airline, showing the most frequently operating airlines based on the number of flights. The placeholder in the LIMIT clause allows the user to specify the maximum number of results to return.\",\n    \"2\": \"This virtual table lists the names of airlines that operate more than a specified number of flights. The placeholder in the HAVING clause represents the minimum number of flights an airline must operate to be included in the results.\"\n}\n"}
{"sample_id": "dev.229", "db_id": "flight_2", "question": "Which airline has most number of flights?", "rationale": ["Identify the relevant table: The 'flights' table contains information about the airlines and their flights.", "Count the number of flights for each airline: Use COUNT(FlightNo) to count the flights grouped by the airline name.", "Group the results by airline: Use GROUP BY Airline to aggregate the flight counts for each airline.", "Order the results to find the airline with the most flights: Use ORDER BY NumberOfFlights DESC to sort the airlines by their flight counts in descending order.", "Limit the results to only the top airline: Use LIMIT 1 to return only the airline with the highest number of flights."], "gold_sql": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) DESC LIMIT 1", "source_tables": ["flights", "airlines"], "pred_sql": "SELECT Airline, COUNT(FlightNo) AS NumberOfFlights\nFROM flights\nGROUP BY Airline\nORDER BY NumberOfFlights DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of airlines that operate more than a specified number of flights. The placeholder in the HAVING clause represents the minimum number of flights an airline must operate to be included in the results.\",\n    \"1\": \"This virtual table provides a summary of the abbreviations and countries of airlines that operate flights. The data is aggregated by airline, showing the most frequently operating airlines based on the number of flights. The placeholder in the LIMIT clause allows the user to specify the maximum number of results to return.\",\n    \"2\": \"This virtual table lists the names of airlines from the 'airlines' table that operate more than a specified number of flights. The placeholder in the HAVING clause represents the minimum number of flights an airline must operate to be included in the results.\"\n}\n"}
{"sample_id": "dev.232", "db_id": "flight_2", "question": "What is the abbreviation of the airilne has the fewest flights and what country is it in?", "rationale": ["Identify the airline with the fewest flights by counting the number of flights for each airline.", "Use a subquery to group the flights by airline and count them, ordering the results in ascending order to find the airline with the least number of flights.", "Limit the results of the subquery to 1 to get only the airline with the fewest flights.", "Join the result of the subquery with the airlines table to get the abbreviation and country of that airline."], "gold_sql": "SELECT T1.Abbreviation ,  T1.Country FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) LIMIT 1", "source_tables": ["flights", "airlines"], "pred_sql": "SELECT a.Abbreviation, a.Country \nFROM airlines a \nJOIN (\n    SELECT Airline, COUNT(*) AS FlightCount \n    FROM flights \n    GROUP BY Airline \n    ORDER BY FlightCount ASC \n    LIMIT 1\n) f ON a.Airline = f.Airline;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the abbreviations and countries of airlines that operate flights. The data is aggregated by airline, showing the most frequently operating airlines based on the number of flights. The placeholder in the LIMIT clause allows the user to specify the maximum number of results to return.\",\n    \"1\": \"This virtual table lists the names of airlines from the 'airlines' table that operate fewer flights than a specified number. The placeholder in the HAVING clause represents the maximum number of flights an airline can operate.\",\n    \"2\": \"This virtual table lists the names of airlines that operate more than a specified number of flights. The placeholder in the HAVING clause represents the minimum number of flights an airline must operate to be included in the results.\"\n}\n"}
{"sample_id": "dev.244", "db_id": "flight_2", "question": "Which airlines have less than 200 flights?", "rationale": ["Identify the relevant tables: 'airlines' for airline names and 'flights' for flight counts.", "Join the 'airlines' table with the 'flights' table on the airline name to associate each airline with its flights.", "Group the results by airline name to aggregate the flight counts for each airline.", "Use the HAVING clause to filter the grouped results to only include airlines with fewer than 200 flights."], "gold_sql": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  <  200", "source_tables": ["flights", "airlines"], "pred_sql": "SELECT a.Airline \nFROM airlines a \nLEFT JOIN flights f ON a.Airline = f.Airline \nGROUP BY a.Airline \nHAVING COUNT(f.FlightNo) < 200;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of airlines from the 'airlines' table that operate fewer flights than a specified number. The placeholder in the HAVING clause represents the maximum number of flights an airline can operate.\",\n    \"1\": \"This virtual table lists the names of airlines that operate more than a specified number of flights. The placeholder in the HAVING clause represents the minimum number of flights an airline must operate to be included in the results.\",\n    \"2\": \"This virtual table lists the names of airlines from the 'airlines' table that operate more than a specified number of flights. The placeholder in the HAVING clause represents the minimum number of flights an airline must operate to be included in the results.\"\n}\n"}
{"sample_id": "dev.258", "db_id": "flight_2", "question": "Which airports do not have departing or arriving flights?", "rationale": ["Identify the airports from the 'airports' table that do not have any departing flights.", "To find airports without departing flights, we can check which AirportCodes are not present in the SourceAirport column of the 'flights' table.", "Similarly, to find airports without arriving flights, we check which AirportCodes are not present in the DestAirport column of the 'flights' table.", "We need to combine these two conditions using the NOT IN clause to filter out airports that have neither departing nor arriving flights.", "The final SQL query selects the AirportName from the 'airports' table where the AirportCode is not in the list of SourceAirport and also not in the list of DestAirport."], "gold_sql": "SELECT AirportName FROM Airports WHERE AirportCode NOT IN (SELECT SourceAirport FROM Flights UNION SELECT DestAirport FROM Flights)", "source_tables": ["airports", "flights"], "pred_sql": "SELECT AirportName FROM airports WHERE AirportCode NOT IN (SELECT SourceAirport FROM flights) AND AirportCode NOT IN (SELECT DestAirport FROM flights);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of airlines from the 'airlines' table that operate fewer flights than a specified number. The placeholder in the HAVING clause represents the maximum number of flights an airline can operate.\",\n    \"1\": \"This virtual table lists the names of airlines that operate more than a specified number of flights. The placeholder in the HAVING clause represents the minimum number of flights an airline must operate to be included in the results.\",\n    \"2\": \"This virtual table lists the names of airlines from the 'airlines' table that operate more than a specified number of flights. The placeholder in the HAVING clause represents the minimum number of flights an airline must operate to be included in the results.\"\n}\n"}
{"sample_id": "dev.308", "db_id": "cre_Doc_Template_Mgt", "question": "Count the number of documents that use the PPT template type.", "rationale": ["Identify the tables involved: We need to count documents, so we will use the 'Documents' table.", "Determine the relationship: Each document is associated with a template, so we will join the 'Documents' table with the 'Templates' table on 'Template_ID'.", "Filter by template type: We need to count only those documents that use the PPT template type. This requires filtering the results based on the 'Template_Type_Code' from the 'Templates' table, which corresponds to the 'Ref_Template_Types' table.", "Use a subquery to get the Template_Type_Code for 'PPT': We will use a subquery to find the 'Template_Type_Code' that corresponds to the 'PPT' description in the 'Ref_Template_Types' table.", "Count the distinct Document_IDs: Finally, we will count the distinct Document_IDs from the filtered results to get the total number of documents that use the PPT template type."], "gold_sql": "SELECT count(*) FROM Documents AS T1 JOIN Templates AS T2 ON T1.Template_ID  =  T2.Template_ID WHERE T2.Template_Type_Code  =  'PPT'", "source_tables": ["templates", "documents"], "pred_sql": "SELECT COUNT(DISTINCT d.Document_ID) AS Document_Count\nFROM Documents d\nJOIN Templates t ON d.Template_ID = t.Template_ID\nWHERE t.Template_Type_Code = (SELECT Template_Type_Code FROM Ref_Template_Types WHERE Template_Type_Description = 'PPT');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of paragraphs associated with each document from the 'Paragraphs' table. The results are grouped by the document identifier, allowing users to see how many paragraphs belong to each document, sorted by the document ID.\",\n    \"1\": \"This virtual table provides a summary of documents along with the count of paragraphs associated with each document. It retrieves the unique document identifier and the document name from the 'Documents' table, while counting the number of paragraphs linked to each document from the 'Paragraphs' table. The grouping is done based on the document identifier to ensure that the count reflects the number of paragraphs per document.\",\n    \"2\": \"This virtual table provides a summary of documents along with the count of paragraphs associated with each document. It retrieves the document ID and document name from the 'Documents' table and counts the number of paragraphs linked to each document from the 'Paragraphs' table. The grouping is done by document ID to aggregate the paragraph counts for each document.\"\n}\n"}
{"sample_id": "dev.311", "db_id": "cre_Doc_Template_Mgt", "question": "What is the id and type code for the template used by the most documents?", "rationale": ["Identify the relevant tables: Templates and Documents.", "We need to find the Template_ID and Template_Type_Code from the Templates table.", "Join the Templates table with the Documents table on Template_ID to associate templates with their documents.", "Group the results by Template_ID and Template_Type_Code to count how many documents are associated with each template.", "Order the results by the count of documents in descending order to find the template used by the most documents.", "Limit the results to 1 to get only the top template."], "gold_sql": "SELECT T1.template_id ,  T2.Template_Type_Code FROM Documents AS T1 JOIN Templates AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["templates", "documents"], "pred_sql": "SELECT Templates.Template_ID, Templates.Template_Type_Code\nFROM Templates\nJOIN Documents ON Templates.Template_ID = Documents.Template_ID\nGROUP BY Templates.Template_ID, Templates.Template_Type_Code\nORDER BY COUNT(Documents.Document_ID) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "dev.312", "db_id": "cre_Doc_Template_Mgt", "question": "Return the id and type code of the template that is used for the greatest number of documents.", "rationale": ["We need to find the template that is used for the greatest number of documents.", "To do this, we will join the Templates table with the Documents table on the Template_ID column.", "Next, we will group the results by Template_ID and Template_Type_Code to count the number of documents associated with each template.", "We will use the COUNT function to count the number of Document_IDs for each template.", "To find the template with the greatest number of documents, we will order the results in descending order based on the count of documents.", "Finally, we will limit the results to 1 to get only the template with the highest count."], "gold_sql": "SELECT T1.template_id ,  T2.Template_Type_Code FROM Documents AS T1 JOIN Templates AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["templates", "documents"], "pred_sql": "SELECT Templates.Template_ID, Templates.Template_Type_Code\nFROM Templates\nJOIN Documents ON Templates.Template_ID = Documents.Template_ID\nGROUP BY Templates.Template_ID, Templates.Template_Type_Code\nORDER BY COUNT(Documents.Document_ID) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "dev.341", "db_id": "cre_Doc_Template_Mgt", "question": "Show all template type codes and the number of documents using each type.", "rationale": ["Identify the tables involved: Ref_Template_Types, Templates, and Documents.", "We need to count the number of documents associated with each template type code.", "Join Ref_Template_Types with Templates on Template_Type_Code to get the template types for each template.", "Then join the resulting table with Documents on Template_ID to get the documents associated with each template.", "Use COUNT() to count the number of Document_IDs for each Template_Type_Code.", "Group the results by Template_Type_Code to get the count for each type."], "gold_sql": "SELECT T1.template_type_code ,  count(*) FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_type_code", "source_tables": ["templates", "documents"], "pred_sql": "SELECT Ref_Template_Types.Template_Type_Code, COUNT(Documents.Document_ID) AS Document_Count\nFROM Ref_Template_Types\nLEFT JOIN Templates ON Ref_Template_Types.Template_Type_Code = Templates.Template_Type_Code\nLEFT JOIN Documents ON Templates.Template_ID = Documents.Template_ID\nGROUP BY Ref_Template_Types.Template_Type_Code;", "hint": "\n"}
{"sample_id": "dev.346", "db_id": "cre_Doc_Template_Mgt", "question": "What are the codes of template types that are not used for any document?", "rationale": ["We need to find template types that are not used for any document.", "To do this, we will start by selecting the 'Template_Type_Code' from the 'Ref_Template_Types' table.", "Next, we will perform a LEFT JOIN with the 'Templates' table on 'Template_Type_Code' to include all template types, even those that do not have corresponding templates.", "Then, we will perform another LEFT JOIN with the 'Documents' table on 'Template_ID' to include all templates, even those that do not have corresponding documents.", "Finally, we will filter the results where 'Document_ID' is NULL, which indicates that there are no documents associated with those templates."], "gold_sql": "SELECT template_type_code FROM Templates EXCEPT SELECT template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id", "source_tables": ["templates", "documents"], "pred_sql": "SELECT Ref_Template_Types.Template_Type_Code\nFROM Ref_Template_Types\nLEFT JOIN Templates ON Ref_Template_Types.Template_Type_Code = Templates.Template_Type_Code\nLEFT JOIN Documents ON Templates.Template_ID = Documents.Template_ID\nWHERE Documents.Document_ID IS NULL;", "hint": "\n"}
{"sample_id": "dev.361", "db_id": "cre_Doc_Template_Mgt", "question": "Show paragraph details for paragraph with text 'Korea ' .", "rationale": ["Identify the relevant table: The 'Paragraphs' table contains the details of paragraphs, including their text content.", "Determine the filtering condition: We need to filter paragraphs based on the text content, specifically looking for paragraphs that contain the word 'Korea'.", "Construct the SQL query: Use a SELECT statement to retrieve the 'Paragraph_ID', 'Paragraph_Text', and 'Other_Details' from the 'Paragraphs' table where the 'Paragraph_Text' matches the specified condition."], "gold_sql": "select other_details from paragraphs where paragraph_text like 'korea'", "source_tables": ["paragraphs"], "pred_sql": "SELECT p.Paragraph_ID, p.Paragraph_Text, p.Other_Details \nFROM Paragraphs p \nWHERE p.Paragraph_Text LIKE '%Korea%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of paragraphs associated with each document from the 'Paragraphs' table. The results are grouped by the document identifier, allowing users to see how many paragraphs belong to each document, sorted by the document ID.\",\n    \"1\": \"This virtual table provides a summary of documents along with the count of paragraphs associated with each document. It retrieves the unique document identifier and the document name from the 'Documents' table, while counting the number of paragraphs linked to each document from the 'Paragraphs' table. The grouping is done based on the document identifier to ensure that the count reflects the number of paragraphs per document.\",\n    \"2\": \"This virtual table provides a summary of documents along with the count of paragraphs associated with each document. It retrieves the document ID and document name from the 'Documents' table and counts the number of paragraphs linked to each document from the 'Paragraphs' table. The grouping is done by document ID to aggregate the paragraph counts for each document.\"\n}\n"}
{"sample_id": "dev.367", "db_id": "cre_Doc_Template_Mgt", "question": "Show all document ids and the number of paragraphs in each document. Order by document id.", "rationale": ["Identify the tables involved: 'Documents' and 'Paragraphs'.", "We need to count the number of paragraphs for each document, which requires a join between the 'Documents' table and the 'Paragraphs' table.", "Use a LEFT JOIN to ensure we include documents even if they have no associated paragraphs.", "Select the 'Document_ID' from the 'Documents' table and count the 'Paragraph_ID' from the 'Paragraphs' table to get the number of paragraphs per document.", "Group the results by 'Document_ID' to aggregate the counts correctly.", "Order the final results by 'Document_ID' to meet the requirement of sorting the output."], "gold_sql": "SELECT document_id ,  count(*) FROM Paragraphs GROUP BY document_id ORDER BY document_id", "source_tables": ["paragraphs"], "pred_sql": "SELECT Documents.Document_ID, COUNT(Paragraphs.Paragraph_ID) AS Number_of_Paragraphs\nFROM Documents\nLEFT JOIN Paragraphs ON Documents.Document_ID = Paragraphs.Document_ID\nGROUP BY Documents.Document_ID\nORDER BY Documents.Document_ID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of paragraphs associated with each document from the 'Paragraphs' table. The results are grouped by the document identifier, allowing users to see how many paragraphs belong to each document, sorted by the document ID.\",\n    \"1\": \"This virtual table provides a summary of documents along with the count of paragraphs associated with each document. It retrieves the document ID and document name from the 'Documents' table and counts the number of paragraphs linked to each document from the 'Paragraphs' table. The grouping is done by document ID to aggregate the paragraph counts for each document.\",\n    \"2\": \"This virtual table provides a summary of documents along with the count of paragraphs associated with each document. It retrieves the unique document identifier and the document name from the 'Documents' table, while counting the number of paragraphs linked to each document from the 'Paragraphs' table. The grouping is done based on the document identifier to ensure that the count reflects the number of paragraphs per document.\"\n}\n"}
{"sample_id": "dev.439", "db_id": "wta_1", "question": "Find the highest rank of losers in all matches.", "rationale": ["Identify the relevant table: The 'matches' table contains information about the matches, including the ranks of the losers.", "Determine the required information: We need to find the highest rank of losers, which means we are interested in the 'loser_rank' column.", "Use the MIN function: To find the highest rank, we can use the MIN function on the 'loser_rank' column, as a lower rank number indicates a better rank.", "Construct the SQL query: The SQL query will select the minimum value from the 'loser_rank' column in the 'matches' table."], "gold_sql": "SELECT min(loser_rank) FROM matches", "source_tables": ["matches"], "pred_sql": "SELECT MIN(loser_rank) AS highest_rank_of_losers\nFROM matches;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the distinct names of winners from the 'matches' table who participated in a specific tournament and played with a specified hand. The placeholders in the WHERE clause represent the tournament's name and the winning player's hand.\",\n    \"1\": \"This virtual table counts the distinct names of winners from the 'matches' table who participated in a specific tournament and played with a specified hand. The placeholders in the WHERE clause represent the tournament's name and the winning player's hand.\"\n}\n"}
{"sample_id": "dev.458", "db_id": "wta_1", "question": "What are the full names of all left handed players, in order of birth date?", "rationale": ["Identify the table needed: The 'players' table contains the information about players, including their names and handedness.", "Select the columns needed: We need the 'first_name' and 'last_name' columns to create the full name.", "Use string concatenation to combine 'first_name' and 'last_name' into a single column called 'full_name'.", "Filter the results to include only left-handed players by using a WHERE clause with 'hand = 'left' '.", "Order the results by 'birth_date' to get the players in chronological order of their birth."], "gold_sql": "SELECT first_name ,  last_name FROM players WHERE hand  =  'L' ORDER BY birth_date", "source_tables": ["players"], "pred_sql": "SELECT first_name || ' ' || last_name AS full_name\nFROM players\nWHERE hand = 'left'\nORDER BY birth_date;", "hint": "\n"}
{"sample_id": "dev.464", "db_id": "wta_1", "question": "What is the name of the winner who has won the most matches, and how many rank points does this player have?", "rationale": ["We need to find the winner who has won the most matches, so we will count the number of matches won by each player.", "We will join the 'matches' table with the 'players' table to get the names of the winners.", "We also need to get the ranking points of the winner, so we will join the 'rankings' table using the player_id.", "We will group the results by the winner's name and their ranking points to count the number of matches won by each player.", "To find the player with the most wins, we will order the results by the count of matches won in descending order.", "Finally, we will limit the results to only the top player."], "gold_sql": "SELECT winner_name ,  winner_rank_points FROM matches GROUP BY winner_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["matches"], "pred_sql": "SELECT winner_name, COUNT(*) AS match_count, r.ranking_points \nFROM matches \nJOIN players ON matches.winner_id = players.player_id \nJOIN rankings r ON players.player_id = r.player_id \nGROUP BY winner_name, r.ranking_points \nORDER BY match_count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the distinct names of winners from the 'matches' table who participated in a specific tournament and played with a specified hand. The placeholders in the WHERE clause represent the tournament's name and the winning player's hand.\",\n    \"1\": \"This virtual table counts the distinct names of winners from the 'matches' table who participated in a specific tournament and played with a specified hand. The placeholders in the WHERE clause represent the tournament's name and the winning player's hand.\"\n}\n"}
{"sample_id": "dev.471", "db_id": "wta_1", "question": "Find the total ranking points for each player and their first name.", "rationale": ["We need to find the total ranking points for each player along with their first name.", "The relevant tables are 'players' and 'rankings'.", "We will join these two tables on the 'player_id' column, which is common to both tables.", "We will select the 'first_name' from the 'players' table and the sum of 'ranking_points' from the 'rankings' table.", "To get the total ranking points for each player, we will use the SUM() function and group the results by 'player_id' and 'first_name' to ensure we get one row per player."], "gold_sql": "SELECT sum(ranking_points) ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.first_name", "source_tables": ["rankings", "players"], "pred_sql": "SELECT players.first_name, SUM(rankings.ranking_points) AS total_ranking_points\nFROM players\nJOIN rankings ON players.player_id = rankings.player_id\nGROUP BY players.player_id, players.first_name;", "hint": "\n"}
{"sample_id": "dev.479", "db_id": "wta_1", "question": "Find the total number of tours for each ranking date.", "rationale": ["Identify the relevant table: The 'rankings' table contains the 'ranking_date' and 'tours' columns.", "We need to count the number of tours for each ranking date, which suggests using the COUNT() function.", "To get the total number of tours for each ranking date, we will group the results by 'ranking_date'.", "The final SQL query will select 'ranking_date' and the count of 'tours', grouping by 'ranking_date'."], "gold_sql": "SELECT sum(tours) ,  ranking_date FROM rankings GROUP BY ranking_date", "source_tables": ["rankings"], "pred_sql": "SELECT ranking_date, COUNT(tours) AS total_tours\nFROM rankings\nGROUP BY ranking_date;", "hint": "\n"}
{"sample_id": "dev.480", "db_id": "wta_1", "question": "How many total tours were there for each ranking date?", "rationale": ["The question asks for the total number of tours for each ranking date.", "We need to select the 'ranking_date' from the 'rankings' table.", "To count the distinct tours for each ranking date, we will use the COUNT function with DISTINCT on the 'tours' column.", "We will group the results by 'ranking_date' to get the count for each date."], "gold_sql": "SELECT sum(tours) ,  ranking_date FROM rankings GROUP BY ranking_date", "source_tables": ["rankings"], "pred_sql": "SELECT ranking_date, COUNT(DISTINCT tours) AS total_tours\nFROM rankings\nGROUP BY ranking_date;", "hint": "\n"}
{"sample_id": "dev.533", "db_id": "student_transcripts_tracking", "question": "Who are enrolled in 2 degree programs in one semester? List the first name, middle name and last name and the id.", "rationale": ["Identify the relevant tables: Students, Student_Enrolment, and Student_Enrolment_Courses are needed to get student details and their enrolment information.", "Join the Students table with Student_Enrolment to link students with their degree programs.", "Join the Student_Enrolment with Student_Enrolment_Courses to count the number of courses each student is enrolled in.", "Group the results by student_id to aggregate the data for each student.", "Use the HAVING clause to filter students who are enrolled in exactly 2 degree programs."], "gold_sql": "SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  2", "source_tables": ["student_enrolment", "students"], "pred_sql": "SELECT s.first_name, s.middle_name, s.last_name, s.student_id \nFROM Students s \nJOIN Student_Enrolment se ON s.student_id = se.student_id \nJOIN Student_Enrolment_Courses sec ON se.student_enrolment_id = sec.student_enrolment_id \nGROUP BY s.student_id \nHAVING COUNT(DISTINCT se.degree_program_id) = 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholders in the WHERE clause represent the name of the degree program being queried.\",\n    \"1\": \"This virtual table identifies the distinct semesters in which students are enrolled in a specific degree program. The placeholders in the query represent the name of the degree program, allowing users to specify which program they are interested in to retrieve the relevant semesters.\",\n    \"2\": \"This virtual table provides the first name, middle name, last name, and unique identifier of students from the 'Students' table who are enrolled in a specific number of courses. The placeholder in the HAVING clause represents the count of courses the students are enrolled in.\"\n}\n"}
{"sample_id": "dev.536", "db_id": "student_transcripts_tracking", "question": "What are the first, middle, and last names for everybody enrolled in a Bachelors program?", "rationale": ["Identify the relevant tables: Students, Student_Enrolment, and Degree_Programs.", "We need to join these tables to get the names of students enrolled in a Bachelors program.", "The join condition will be based on the foreign keys: Student_Enrolment.student_id = Students.student_id and Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id.", "Filter the results to include only those degree programs that have 'Bachelors' in their name using a WHERE clause.", "Select the first_name, middle_name, and last_name from the resulting joined table."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  'Bachelor'", "source_tables": ["student_enrolment", "degree_programs", "students"], "pred_sql": "SELECT first_name, middle_name, last_name \nFROM Students s \nJOIN Student_Enrolment se ON s.student_id = se.student_id \nJOIN Degree_Programs dp ON se.degree_program_id = dp.degree_program_id \nWHERE dp.degree_summary_name LIKE '%Bachelors%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholders in the WHERE clause represent the name of the degree program being queried.\",\n    \"1\": \"This virtual table provides the first name, middle name, last name, and unique identifier of students from the 'Students' table who are enrolled in a specific number of courses. The placeholder in the HAVING clause represents the count of courses the students are enrolled in.\",\n    \"2\": \"This virtual table provides a list of students along with their first, middle, and last names, and the count of their enrolments in courses. The results are grouped by each student's unique identifier and ordered by the number of enrolments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of students to return.\"\n}\n"}
{"sample_id": "dev.537", "db_id": "student_transcripts_tracking", "question": "Find the kind of program which most number of students are enrolled in?", "rationale": ["Identify the relevant tables: We need to find the degree programs and the number of students enrolled in each program, so we will use the Student_Enrolment and Degree_Programs tables.", "Join the tables: We will join the Student_Enrolment table with the Degree_Programs table on the degree_program_id to associate each enrolment with its corresponding degree program.", "Count the number of students: We will count the number of student enrolment records for each degree program using COUNT(se.student_enrolment_id).", "Group the results: We will group the results by the degree program name (dp.degree_summary_name) to get the count of students for each program.", "Order the results: We will order the results in descending order based on the student count to find the program with the most students enrolled.", "Limit the results: We will limit the results to 1 to get only the program with the highest number of students."], "gold_sql": "SELECT T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_summary_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "degree_programs"], "pred_sql": "SELECT dp.degree_summary_name, COUNT(se.student_enrolment_id) AS student_count\nFROM Student_Enrolment se\nJOIN Degree_Programs dp ON se.degree_program_id = dp.degree_program_id\nGROUP BY dp.degree_summary_name\nORDER BY student_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of students along with their first, middle, and last names, and the count of their enrolments in courses. The results are grouped by each student's unique identifier and ordered by the number of enrolments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of students to return.\",\n    \"1\": \"This virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholders in the WHERE clause represent the name of the degree program being queried.\",\n    \"2\": \"This virtual table identifies the distinct semesters in which students are enrolled in a specific degree program. The placeholders in the query represent the name of the degree program, allowing users to specify which program they are interested in to retrieve the relevant semesters.\"\n}\n"}
{"sample_id": "dev.539", "db_id": "student_transcripts_tracking", "question": "Find the program which most number of students are enrolled in. List both the id and the summary.", "rationale": ["Identify the relevant tables: Degree_Programs and Student_Enrolment are needed to find the degree programs and their enrolments.", "Join the Degree_Programs table with the Student_Enrolment table on the degree_program_id to associate each program with its enrolled students.", "Group the results by degree_program_id and degree_summary_name to count the number of students enrolled in each program.", "Order the results by the count of students in descending order to find the program with the most enrolments.", "Limit the results to 1 to get only the program with the highest number of students."], "gold_sql": "SELECT T1.degree_program_id ,  T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_program_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "degree_programs"], "pred_sql": "SELECT dp.degree_program_id, dp.degree_summary_name\nFROM Degree_Programs dp\nJOIN Student_Enrolment se ON dp.degree_program_id = se.degree_program_id\nGROUP BY dp.degree_program_id, dp.degree_summary_name\nORDER BY COUNT(se.student_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of students along with their first, middle, and last names, and the count of their enrolments in courses. The results are grouped by each student's unique identifier and ordered by the number of enrolments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of students to return.\",\n    \"1\": \"This virtual table provides a count of how many times each student course appears in the transcripts, grouped by the course identifier. The results are ordered by the count in descending order, allowing users to see the most frequently recorded courses. The placeholder in the LIMIT clause represents the maximum number of results to return.\",\n    \"2\": \"This virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholders in the WHERE clause represent the name of the degree program being queried.\"\n}\n"}
{"sample_id": "dev.541", "db_id": "student_transcripts_tracking", "question": "Which student has enrolled for the most times in any program? List the id, first name, middle name, last name, the number of enrollments and student id.", "rationale": ["Identify the relevant tables: Students and Student_Enrolment are needed to get student details and their enrolment counts.", "Join the Students table with the Student_Enrolment table on the student_id to link students with their enrolments.", "Use COUNT() to count the number of enrolments for each student.", "Group the results by student_id and their names to aggregate the enrolment counts correctly.", "Order the results by the count of enrolments in descending order to find the student with the most enrolments.", "Limit the results to 1 to get only the top student."], "gold_sql": "SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "students"], "pred_sql": "SELECT s.student_id, s.first_name, s.middle_name, s.last_name, COUNT(se.student_enrolment_id) AS number_of_enrolments\nFROM Students s\nJOIN Student_Enrolment se ON s.student_id = se.student_id\nGROUP BY s.student_id, s.first_name, s.middle_name, s.last_name\nORDER BY number_of_enrolments DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of students along with their first, middle, and last names, and the count of their enrolments in courses. The results are grouped by each student's unique identifier and ordered by the number of enrolments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of students to return.\",\n    \"1\": \"This virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholders in the WHERE clause represent the name of the degree program being queried.\",\n    \"2\": \"This virtual table provides the first name, middle name, last name, and unique identifier of students from the 'Students' table who are enrolled in a specific number of courses. The placeholder in the HAVING clause represents the count of courses the students are enrolled in.\"\n}\n"}
{"sample_id": "dev.547", "db_id": "student_transcripts_tracking", "question": "What's the name of the course with most number of enrollments?", "rationale": ["Identify the relevant tables: Courses and Student_Enrolment_Courses are needed to find course names and their enrollments.", "Join the Courses table with the Student_Enrolment_Courses table on the course_id to link courses with their enrollments.", "Group the results by course_id to aggregate the number of enrollments for each course.", "Use COUNT to count the number of enrollments for each course.", "Order the results in descending order based on the count of enrollments to find the course with the most enrollments.", "Limit the results to 1 to get only the course with the highest number of enrollments."], "gold_sql": "SELECT  T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["courses", "student_enrolment_courses"], "pred_sql": "SELECT C.course_name\nFROM Courses C\nJOIN Student_Enrolment_Courses SEC ON C.course_id = SEC.course_id\nGROUP BY C.course_id\nORDER BY COUNT(SEC.student_course_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of students along with their first, middle, and last names, and the count of their enrolments in courses. The results are grouped by each student's unique identifier and ordered by the number of enrolments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of students to return.\",\n    \"1\": \"This virtual table provides the first name, middle name, last name, and unique identifier of students from the 'Students' table who are enrolled in a specific number of courses. The placeholder in the HAVING clause represents the count of courses the students are enrolled in.\",\n    \"2\": \"This virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholders in the WHERE clause represent the name of the degree program being queried.\"\n}\n"}
{"sample_id": "dev.550", "db_id": "student_transcripts_tracking", "question": "What are the last name of the students who live in North Carolina but have not registered in any degree programs?", "rationale": ["Identify the relevant tables: Students and Addresses for student information and their current address.", "Join the Students table with the Addresses table on the current_address_id to access the state information.", "Filter the results to include only those students whose current address is in 'North Carolina'.", "Use the EXCEPT clause to exclude students who are enrolled in any degree programs by joining the Students table with the Student_Enrolment table.", "Select only the last names of the students who meet the criteria."], "gold_sql": "SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  'NorthCarolina' EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id", "source_tables": ["addresses", "student_enrolment", "students"], "pred_sql": "SELECT last_name FROM Students\nJOIN Addresses ON Students.current_address_id = Addresses.address_id\nWHERE Addresses.state_province_county = 'North Carolina'\nEXCEPT\nSELECT Students.last_name FROM Students\nJOIN Student_Enrolment ON Students.student_id = Student_Enrolment.student_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the last names of students who currently reside in a specific state, excluding those who are enrolled in any degree program. The query joins the 'Students' table with the 'Addresses' table to filter by the current address's state, and uses an EXCEPT clause to remove students who are found in the 'Student_Enrolment' table.\",\n    \"1\": \"This virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholders in the WHERE clause represent the name of the degree program being queried.\"\n}\n"}
{"sample_id": "dev.554", "db_id": "student_transcripts_tracking", "question": "What is the mobile phone number of the student named Timmothy Ward ?", "rationale": ["Identify the relevant table: The question asks for the mobile phone number of a student, which indicates that we need to look at the 'Students' table.", "Determine the necessary columns: We need the 'cell_mobile_number' column from the 'Students' table.", "Filter the results: The question specifies the student's name as 'Timmothy Ward', so we need to filter the results based on the first name and last name.", "Construct the SQL query: Using the SELECT statement to retrieve the 'cell_mobile_number' where the first name is 'Timmothy' and the last name is 'Ward'."], "gold_sql": "select cell_mobile_number from students where first_name  =  'timmothy' and last_name  =  'ward'", "source_tables": ["students"], "pred_sql": "SELECT cell_mobile_number FROM Students WHERE first_name = 'Timmothy' AND last_name = 'Ward';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of students along with their first, middle, and last names, and the count of their enrolments in courses. The results are grouped by each student's unique identifier and ordered by the number of enrolments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of students to return.\"\n}\n"}
{"sample_id": "dev.561", "db_id": "student_transcripts_tracking", "question": "Which address holds the most number of students currently? List the address id and all lines.", "rationale": ["Identify the relevant tables: Addresses and Students.", "Join the Addresses table with the Students table on the current address ID.", "Group the results by address ID to count the number of students at each address.", "Order the results by the count of students in descending order to find the address with the most students.", "Limit the results to 1 to get only the address with the highest count."], "gold_sql": "SELECT T1.address_id ,  T1.line_1 ,  T1.line_2 FROM Addresses AS T1 JOIN Students AS T2 ON T1.address_id  =  T2.current_address_id GROUP BY T1.address_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "students"], "pred_sql": "SELECT a.address_id, a.line_1, a.line_2, a.line_3\nFROM Addresses a\nJOIN Students s ON a.address_id = s.current_address_id\nGROUP BY a.address_id\nORDER BY COUNT(s.student_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the last names of students who currently reside in a specific state, excluding those who are enrolled in any degree program. The query joins the 'Students' table with the 'Addresses' table to filter by the current address's state, and uses an EXCEPT clause to remove students who are found in the 'Student_Enrolment' table.\",\n    \"1\": \"This virtual table provides a list of students along with their first, middle, and last names, and the count of their enrolments in courses. The results are grouped by each student's unique identifier and ordered by the number of enrolments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of students to return.\"\n}\n"}
{"sample_id": "dev.576", "db_id": "student_transcripts_tracking", "question": "What is the id of the semester that had both Masters and Bachelors students enrolled?", "rationale": ["Identify the relevant tables: We need to look at the Student_Enrolment table to find semesters and the Degree_Programs table to filter by degree types (Masters and Bachelors).", "Join the Student_Enrolment table with the Degree_Programs table on the degree_program_id to access the degree names associated with each enrolment.", "Filter the results to include only those records where the degree_summary_name is either 'Masters' or 'Bachelors'.", "Group the results by semester_id to aggregate the enrolments per semester.", "Use the HAVING clause to ensure that both degree types (Masters and Bachelors) are present in the results for each semester. We check that the count of distinct degree names is 2."], "gold_sql": "SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Master' INTERSECT SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Bachelor'", "source_tables": ["student_enrolment", "degree_programs"], "pred_sql": "SELECT DISTINCT se.semester_id\nFROM Student_Enrolment se\nJOIN Degree_Programs dp ON se.degree_program_id = dp.degree_program_id\nWHERE dp.degree_summary_name IN ('Masters', 'Bachelors')\nGROUP BY se.semester_id\nHAVING COUNT(DISTINCT dp.degree_summary_name) = 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the distinct semesters in which students are enrolled in a specific degree program. The placeholders in the query represent the name of the degree program, allowing users to specify which program they are interested in to retrieve the relevant semesters.\",\n    \"1\": \"This virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholders in the WHERE clause represent the name of the degree program being queried.\",\n    \"2\": \"This virtual table provides the first name, middle name, last name, and unique identifier of students from the 'Students' table who are enrolled in a specific number of courses. The placeholder in the HAVING clause represents the count of courses the students are enrolled in.\"\n}\n"}
{"sample_id": "dev.580", "db_id": "student_transcripts_tracking", "question": "What other details can you tell me about students in reverse alphabetical order?", "rationale": ["The query needs to retrieve all details about students.", "To get the students in reverse alphabetical order, we will order by their last names first, and then by their first and middle names as secondary and tertiary sorting criteria.", "The SQL query will select all columns from the Students table and apply the ORDER BY clause to sort the results accordingly."], "gold_sql": "SELECT other_student_details FROM Students ORDER BY other_student_details DESC", "source_tables": ["students"], "pred_sql": "SELECT * FROM Students ORDER BY last_name DESC, first_name DESC, middle_name DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholders in the WHERE clause represent the name of the degree program being queried.\",\n    \"1\": \"This virtual table provides a list of students along with their first, middle, and last names, and the count of their enrolments in courses. The results are grouped by each student's unique identifier and ordered by the number of enrolments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of students to return.\",\n    \"2\": \"This virtual table lists the last names of students who currently reside in a specific state, excluding those who are enrolled in any degree program. The query joins the 'Students' table with the 'Addresses' table to filter by the current address's state, and uses an EXCEPT clause to remove students who are found in the 'Student_Enrolment' table.\"\n}\n"}
{"sample_id": "dev.581", "db_id": "student_transcripts_tracking", "question": "Describe the section h.", "rationale": ["The user wants to describe a specific section identified by the name 'h'.", "To retrieve the details of the section, I will select the relevant columns from the Sections table: section_id, section_name, and section_description.", "I will use a WHERE clause to filter the results to only include the section where the section_name is 'h'."], "gold_sql": "SELECT section_description FROM Sections WHERE section_name  =  'h'", "source_tables": ["sections"], "pred_sql": "SELECT section_id, section_name, section_description \nFROM Sections \nWHERE section_name = 'h';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of course names and their corresponding identifiers from the 'Courses' table, specifically for those courses that have a number of sections less than or equal to a specified threshold. The placeholder in the HAVING clause represents the maximum number of sections allowed for the courses listed.\"\n}\n"}
{"sample_id": "dev.705", "db_id": "world_1", "question": "How many countries have governments that are republics?", "rationale": ["Identify the relevant table: The 'country' table contains information about countries, including their government forms.", "Determine the specific condition: We need to count countries where the government form is 'Republic'.", "Construct the SQL query: Use the COUNT function to count the number of countries that meet the specified condition."], "gold_sql": "SELECT count(*) FROM country WHERE GovernmentForm  =  'Republic'", "source_tables": ["country"], "pred_sql": "SELECT COUNT(*) AS RepublicCount FROM country WHERE GovernmentForm = 'Republic';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\",\n    \"1\": \"This virtual table describes the languages spoken in countries that have a specific form of government. The query retrieves the languages from the 'countrylanguage' table by joining it with the 'country' table based on the country code. The placeholder in the WHERE clause represents the type of government, and the placeholder in the HAVING clause indicates the required count of countries that speak each language.\",\n    \"2\": \"This virtual table describes the languages spoken in countries that have a specific form of government. The query retrieves the languages from the 'countrylanguage' table by joining it with the 'country' table based on the country code. The placeholder in the WHERE clause represents the type of government, and the placeholder in the HAVING clause indicates the required count of languages spoken in those countries.\"\n}\n"}
{"sample_id": "dev.730", "db_id": "world_1", "question": "What is the average GNP and total population in all nations whose government is US territory?", "rationale": ["Identify the relevant table: The 'country' table contains the GNP and population data.", "Determine the required calculations: We need to calculate the average GNP and total population.", "Filter the results: We need to filter the countries where the government form is 'US territory'.", "Construct the SQL query: Use the AVG function for GNP and SUM function for population, and apply the WHERE clause for filtering."], "gold_sql": "SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  'US Territory'", "source_tables": ["country"], "pred_sql": "SELECT AVG(GNP) AS AverageGNP, SUM(Population) AS TotalPopulation \nFROM country \nWHERE GovernmentForm = 'US territory';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total population and average life expectancy of countries grouped by continent. It filters the results to only include continents where the average life expectancy is below a specified threshold. The placeholder in the HAVING clause represents the life expectancy limit.\",\n    \"1\": \"This virtual table lists the names of countries from the 'country' table that are located in a specific continent and have a population less than the maximum population of any country within the same continent. The placeholders in the WHERE clause represent the continent's name.\",\n    \"2\": \"This virtual table lists the names of countries from the 'country' table that are located in a specific continent and have a population greater than the minimum population of countries within the same continent. The placeholders in the WHERE clause represent the continent's name.\"\n}\n"}
{"sample_id": "dev.734", "db_id": "world_1", "question": "How many type of governments are in Africa?", "rationale": ["Identify the relevant table: The 'country' table contains information about countries, including their government forms and continent.", "Filter for Africa: We need to focus on countries located in Africa, which can be done by adding a WHERE clause that specifies the continent as 'Africa'.", "Select distinct government forms: To find out how many types of governments are present, we can use the DISTINCT keyword to get unique government forms from the filtered results."], "gold_sql": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  'Africa'", "source_tables": ["country"], "pred_sql": "SELECT DISTINCT GovernmentForm FROM country WHERE Continent = 'Africa';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\",\n    \"1\": \"This virtual table describes the languages spoken in countries that have a specific form of government. The query retrieves the languages from the 'countrylanguage' table by joining it with the 'country' table based on the country code. The placeholder in the WHERE clause represents the type of government, and the placeholder in the HAVING clause indicates the required count of countries that speak each language.\",\n    \"2\": \"This virtual table describes the languages spoken in countries that have a specific form of government. The query retrieves the languages from the 'countrylanguage' table by joining it with the 'country' table based on the country code. The placeholder in the WHERE clause represents the type of government, and the placeholder in the HAVING clause indicates the required count of languages spoken in those countries.\"\n}\n"}
{"sample_id": "dev.735", "db_id": "world_1", "question": "How many different forms of governments are there in Africa?", "rationale": ["Identify the relevant table: The 'country' table contains information about countries, including their government forms and continent.", "Filter for Africa: We need to focus on countries located in Africa, which can be done by adding a WHERE clause that specifies the continent as 'Africa'.", "Select distinct government forms: To find out how many different forms of governments there are, we can use the DISTINCT keyword to ensure we only get unique government forms from the results."], "gold_sql": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  'Africa'", "source_tables": ["country"], "pred_sql": "SELECT DISTINCT GovernmentForm FROM country WHERE Continent = 'Africa';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\",\n    \"1\": \"This virtual table describes the languages spoken in countries that have a specific form of government. The query retrieves the languages from the 'countrylanguage' table by joining it with the 'country' table based on the country code. The placeholder in the WHERE clause represents the type of government, and the placeholder in the HAVING clause indicates the required count of countries that speak each language.\",\n    \"2\": \"This virtual table describes the languages spoken in countries that have a specific form of government. The query retrieves the languages from the 'countrylanguage' table by joining it with the 'country' table based on the country code. The placeholder in the WHERE clause represents the type of government, and the placeholder in the HAVING clause indicates the required count of languages spoken in those countries.\"\n}\n"}
{"sample_id": "dev.742", "db_id": "world_1", "question": "Which continent has the most diverse languages?", "rationale": ["To determine which continent has the most diverse languages, we need to count the distinct languages spoken in each continent.", "We will join the 'country' table with the 'countrylanguage' table using the country code to access the languages spoken in each country.", "We will filter the languages to only include those that are official by checking the 'IsOfficial' column in the 'countrylanguage' table.", "Next, we will group the results by continent to count the number of distinct languages for each continent.", "Finally, we will order the results in descending order based on the count of distinct languages and limit the output to the top result to find the continent with the most diverse languages."], "gold_sql": "SELECT T1.Continent FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT c.Continent, COUNT(DISTINCT cl.Language) AS LanguageCount\nFROM country c\nJOIN countrylanguage cl ON c.Code = cl.CountryCode\nWHERE cl.IsOfficial = 'T'\nGROUP BY c.Continent\nORDER BY LanguageCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct city names from the 'city' table that are located in countries where a specific language is spoken officially. The query filters the results based on whether the language is official, the name of the language, and the continent the country belongs to. The placeholders in the WHERE clause represent the official status of the language, the language name, and the continent name.\",\n    \"1\": \"This virtual table lists the names of countries where a specific language is spoken as an official language. The placeholders in the query represent the language name and the official status of the language.\",\n    \"2\": \"This virtual table describes the languages spoken in countries that have a specific form of government. The query retrieves the languages from the 'countrylanguage' table by joining it with the 'country' table based on the country code. The placeholder in the WHERE clause represents the type of government, and the placeholder in the HAVING clause indicates the required count of countries that speak each language.\"\n}\n"}
{"sample_id": "dev.743", "db_id": "world_1", "question": "Which continent speaks the most languages?", "rationale": ["Identify the relevant tables: 'country' and 'countrylanguage' are needed to find the continent and the languages spoken.", "Join the 'country' table with the 'countrylanguage' table on the 'Code' and 'CountryCode' fields to associate countries with their languages.", "Filter the results to include only official languages by checking the 'IsOfficial' column in the 'countrylanguage' table.", "Group the results by continent to count the number of official languages spoken in each continent.", "Order the results in descending order based on the count of languages to find the continent with the most languages.", "Limit the results to 1 to get only the continent that speaks the most languages."], "gold_sql": "SELECT T1.Continent FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT c.Continent, COUNT(cl.Language) AS LanguageCount\nFROM country c\nJOIN countrylanguage cl ON c.Code = cl.CountryCode\nWHERE cl.IsOfficial = 'T'\nGROUP BY c.Continent\nORDER BY LanguageCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of countries where a specific language is spoken as an official language. The placeholders in the query represent the language name and the official status of the language.\",\n    \"1\": \"This virtual table provides a list of distinct city names from the 'city' table that are located in countries where a specific language is spoken officially. The query filters the results based on whether the language is official, the name of the language, and the continent the country belongs to. The placeholders in the WHERE clause represent the official status of the language, the language name, and the continent name.\",\n    \"2\": \"This virtual table lists the names of countries from the 'country' table that are located in a specific continent and have a population less than the maximum population of any country within the same continent. The placeholders in the WHERE clause represent the continent's name.\"\n}\n"}
{"sample_id": "dev.746", "db_id": "world_1", "question": "What are the names of nations speak both English and French?", "rationale": ["Identify the languages of interest: English and French.", "Use the countrylanguage table to find countries where English is an official language.", "Use the countrylanguage table again to find countries where French is an official language.", "To find countries that speak both languages, use an INTERSECT operation between the two queries that find countries for each language.", "Join the countrylanguage table with the country table to get the names of the countries along with their codes.", "Select the country names from the results of the INTERSECT operation."], "gold_sql": "SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English' INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'French'", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT cl1.CountryCode, c.Name \nFROM countrylanguage cl1 \nJOIN country c ON cl1.CountryCode = c.Code \nWHERE cl1.Language = 'English' AND cl1.IsOfficial = 'T' \nINTERSECT \nSELECT cl2.CountryCode, c2.Name \nFROM countrylanguage cl2 \nJOIN country c2 ON cl2.CountryCode = c2.Code \nWHERE cl2.Language = 'French' AND cl2.IsOfficial = 'T';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of countries where a specific language is spoken as an official language. The placeholders in the query represent the language name and the official status of the language.\",\n    \"1\": \"This virtual table provides a list of distinct city names from the 'city' table that are located in countries where a specific language is spoken officially. The query filters the results based on whether the language is official, the name of the language, and the continent the country belongs to. The placeholders in the WHERE clause represent the official status of the language, the language name, and the continent name.\",\n    \"2\": \"This virtual table describes the languages spoken in countries that have a specific form of government. The query retrieves the languages from the 'countrylanguage' table by joining it with the 'country' table based on the country code. The placeholder in the WHERE clause represents the type of government, and the placeholder in the HAVING clause indicates the required count of countries that speak each language.\"\n}\n"}
{"sample_id": "dev.755", "db_id": "world_1", "question": "Which countries have either English or Dutch as an official language?", "rationale": ["Identify the tables involved: We need to look at the 'country' and 'countrylanguage' tables to find countries with specific official languages.", "Determine the relationship: The 'countrylanguage' table has a foreign key 'CountryCode' that relates to the 'Code' in the 'country' table.", "Select the relevant columns: We want the name of the countries, so we will select 'country.Name'.", "Filter for official languages: We need to filter the results to include only those languages that are marked as official (IsOfficial = 'T').", "Specify the languages: We need to include a condition to check for either 'English' or 'Dutch' as the language spoken.", "Combine the conditions: Use an OR condition to combine the language checks in the WHERE clause."], "gold_sql": "SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English' AND IsOfficial  =  'T' UNION SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'Dutch' AND IsOfficial  =  'T'", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT DISTINCT country.Name \nFROM country \nJOIN countrylanguage ON country.Code = countrylanguage.CountryCode \nWHERE countrylanguage.IsOfficial = 'T' \nAND (countrylanguage.Language = 'English' OR countrylanguage.Language = 'Dutch');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of countries where a specific language is spoken as an official language. The placeholders in the query represent the language name and the official status of the language.\",\n    \"1\": \"This virtual table describes the languages spoken in countries that have a specific form of government. The query retrieves the languages from the 'countrylanguage' table by joining it with the 'country' table based on the country code. The placeholder in the WHERE clause represents the type of government, and the placeholder in the HAVING clause indicates the required count of countries that speak each language.\",\n    \"2\": \"This virtual table provides a list of distinct city names from the 'city' table that are located in countries where a specific language is spoken officially. The query filters the results based on whether the language is official, the name of the language, and the continent the country belongs to. The placeholders in the WHERE clause represent the official status of the language, the language name, and the continent name.\"\n}\n"}
{"sample_id": "dev.766", "db_id": "world_1", "question": "What is the total number of people living in the nations that do not use English?", "rationale": ["Identify the requirement to find the total population of countries that do not use English as an official language.", "To achieve this, we need to sum the population from the 'country' table.", "We need to filter out countries that have English as an official language, which can be done using a subquery.", "The subquery selects the CountryCode from the 'countrylanguage' table where the Language is 'English' and IsOfficial is 'T'.", "The main query then sums the population of countries whose Code is not in the list returned by the subquery."], "gold_sql": "SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English')", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT SUM(Population) \nFROM country \nWHERE Code NOT IN (\n    SELECT CountryCode \n    FROM countrylanguage \n    WHERE Language = 'English' AND IsOfficial = 'T'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\",\n    \"1\": \"This virtual table lists the names of countries where a specific language is spoken as an official language. The placeholders in the query represent the language name and the official status of the language.\",\n    \"2\": \"This virtual table provides the count of countries and the maximum percentage of speakers for a specific language from the 'countrylanguage' table. The placeholder in the WHERE clause represents the language name being queried.\"\n}\n"}
{"sample_id": "dev.767", "db_id": "world_1", "question": "How many people live in countries that do not speak English?", "rationale": ["Identify the requirement: We need to find the total population of countries that do not speak English as an official language.", "To achieve this, we will first need to identify the countries that have English as an official language. This can be done by querying the 'countrylanguage' table where Language is 'English' and IsOfficial is 'T'.", "Next, we will use the results from the previous step to filter out these countries from the 'country' table.", "Finally, we will sum the populations of the remaining countries to get the total population of countries that do not speak English."], "gold_sql": "SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English')", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT SUM(Population) AS TotalPopulation\nFROM country\nWHERE Code NOT IN (\n    SELECT CountryCode\n    FROM countrylanguage\n    WHERE Language = 'English' AND IsOfficial = 'T'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of countries where a specific language is spoken as an official language. The placeholders in the query represent the language name and the official status of the language.\",\n    \"1\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\",\n    \"2\": \"This virtual table describes the languages spoken in countries that have a specific form of government. The query retrieves the languages from the 'countrylanguage' table by joining it with the 'country' table based on the country code. The placeholder in the WHERE clause represents the type of government, and the placeholder in the HAVING clause indicates the required count of countries that speak each language.\"\n}\n"}
{"sample_id": "dev.783", "db_id": "world_1", "question": "Return the codes of countries that do not speak English and do not have Republics for governments.", "rationale": ["Identify the countries that do not speak English as an official language.", "Use the 'countrylanguage' table to find countries where English is an official language by filtering on 'Language' and 'IsOfficial'.", "Select the 'CountryCode' from the 'countrylanguage' table where the language is 'English' and it is marked as official.", "Use a subquery to exclude these country codes from the main query.", "Next, filter the countries in the 'country' table to exclude those with a government form that includes 'Republic'.", "Combine these conditions in the main query to get the final list of country codes."], "gold_sql": "SELECT Code FROM country WHERE GovernmentForm != 'Republic' EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  'English'", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT Code FROM country WHERE Code NOT IN (SELECT CountryCode FROM countrylanguage WHERE Language = 'English' AND IsOfficial = 'T') AND GovernmentForm NOT LIKE '%Republic%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\",\n    \"1\": \"This virtual table lists the names of countries where a specific language is spoken as an official language. The placeholders in the query represent the language name and the official status of the language.\",\n    \"2\": \"This virtual table describes the languages spoken in countries that have a specific form of government. The query retrieves the languages from the 'countrylanguage' table by joining it with the 'country' table based on the country code. The placeholder in the WHERE clause represents the type of government, and the placeholder in the HAVING clause indicates the required count of countries that speak each language.\"\n}\n"}
{"sample_id": "dev.784", "db_id": "world_1", "question": "Which cities are in European countries where English is not the official language?", "rationale": ["Identify the relevant tables: 'city' for city names and 'country' for country details.", "Join the 'city' table with the 'country' table on the 'CountryCode' to filter cities based on their countries.", "Filter the results to include only those countries that are in Europe by checking the 'Continent' column in the 'country' table.", "Use a subquery to exclude countries where English is an official language by checking the 'countrylanguage' table for 'English' with 'IsOfficial' set to 'T'.", "Select the city names from the filtered results."], "gold_sql": "SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  'Europe' AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  'T' AND T4.Language  =  'English')", "source_tables": ["country", "city", "countrylanguage"], "pred_sql": "SELECT c.Name \nFROM city c \nJOIN country co ON c.CountryCode = co.Code \nWHERE co.Continent = 'Europe' \nAND c.CountryCode NOT IN (\n    SELECT cl.CountryCode \n    FROM countrylanguage cl \n    WHERE cl.Language = 'English' \n    AND cl.IsOfficial = 'T'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of countries where a specific language is spoken as an official language. The placeholders in the query represent the language name and the official status of the language.\",\n    \"1\": \"This virtual table provides a list of distinct city names from the 'city' table that are located in countries where a specific language is spoken officially. The query filters the results based on whether the language is official, the name of the language, and the continent the country belongs to. The placeholders in the WHERE clause represent the official status of the language, the language name, and the continent name.\",\n    \"2\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\"\n}\n"}
{"sample_id": "dev.785", "db_id": "world_1", "question": "What are the names of cities in Europe for which English is not the official language?", "rationale": ["Identify the relevant tables: We need to use the 'city' and 'country' tables to get city names and their corresponding countries.", "Join the 'city' table with the 'country' table on the 'CountryCode' to access the continent information.", "Filter the results to include only cities located in Europe by checking the 'Continent' column in the 'country' table.", "To find cities where English is not the official language, we need to exclude countries where English is an official language. This can be done using a subquery that selects 'CountryCode' from the 'countrylanguage' table where 'Language' is 'English' and 'IsOfficial' is 'T'.", "Combine all these conditions to form the final SQL query."], "gold_sql": "SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  'Europe' AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  'T' AND T4.Language  =  'English')", "source_tables": ["country", "city", "countrylanguage"], "pred_sql": "SELECT city.Name \nFROM city \nJOIN country ON city.CountryCode = country.Code \nWHERE country.Continent = 'Europe' \nAND city.CountryCode NOT IN (\n    SELECT CountryCode \n    FROM countrylanguage \n    WHERE Language = 'English' \n    AND IsOfficial = 'T'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of countries where a specific language is spoken as an official language. The placeholders in the query represent the language name and the official status of the language.\",\n    \"1\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\",\n    \"2\": \"This virtual table provides a list of distinct city names from the 'city' table that are located in countries where a specific language is spoken officially. The query filters the results based on whether the language is official, the name of the language, and the continent the country belongs to. The placeholders in the WHERE clause represent the official status of the language, the language name, and the continent name.\"\n}\n"}
{"sample_id": "dev.788", "db_id": "world_1", "question": "What are the name, independence year, and surface area of the country with the smallest population?", "rationale": ["Identify the required fields: Name, Independence Year (IndepYear), and Surface Area from the country table.", "Determine the condition to find the country with the smallest population, which involves using the MIN function on the Population column.", "Construct a subquery to find the minimum population from the country table.", "Use the result of the subquery to filter the main query to get the country details that match the smallest population."], "gold_sql": "SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT 1", "source_tables": ["country"], "pred_sql": "SELECT Name, IndepYear, SurfaceArea FROM country WHERE Population = (SELECT MIN(Population) FROM country);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of countries from the 'country' table that are located in a specific continent and have a population less than the maximum population of any country within the same continent. The placeholders in the WHERE clause represent the continent's name.\",\n    \"1\": \"This virtual table lists the names of countries from the 'country' table that are located in a specific continent and have a population greater than the minimum population of countries within the same continent. The placeholders in the WHERE clause represent the continent's name.\",\n    \"2\": \"This virtual table summarizes the total population and average life expectancy of countries grouped by continent. It filters the results to only include continents where the average life expectancy is below a specified threshold. The placeholder in the HAVING clause represents the life expectancy limit.\"\n}\n"}
{"sample_id": "dev.789", "db_id": "world_1", "question": "Give the name, year of independence, and surface area of the country that has the lowest population.", "rationale": ["Identify the required fields: Name, year of independence (IndepYear), and surface area (SurfaceArea) from the country table.", "Determine the condition to find the country with the lowest population, which involves using a subquery to select the minimum population from the country table.", "Construct the main query to select the desired fields from the country table where the population matches the minimum population found in the subquery."], "gold_sql": "SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT 1", "source_tables": ["country"], "pred_sql": "SELECT Name, IndepYear, SurfaceArea FROM country WHERE Population = (SELECT MIN(Population) FROM country);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of countries from the 'country' table that are located in a specific continent and have a population less than the maximum population of any country within the same continent. The placeholders in the WHERE clause represent the continent's name.\",\n    \"1\": \"This virtual table lists the names of countries from the 'country' table that are located in a specific continent and have a population greater than the minimum population of countries within the same continent. The placeholders in the WHERE clause represent the continent's name.\",\n    \"2\": \"This virtual table summarizes the total population and average life expectancy of countries grouped by continent. It filters the results to only include continents where the average life expectancy is below a specified threshold. The placeholder in the HAVING clause represents the life expectancy limit.\"\n}\n"}
{"sample_id": "dev.793", "db_id": "world_1", "question": "What are the names of countries that speak more than 2 languages, as well as how many languages they speak?", "rationale": ["Identify the tables needed: We need data from the 'country' table for country names and the 'countrylanguage' table for language information.", "Join the 'country' table with the 'countrylanguage' table on the country code to associate countries with their languages.", "Group the results by country name to count the number of languages spoken in each country.", "Use the COUNT function to count the number of languages for each country.", "Apply a HAVING clause to filter the results to only include countries that speak more than 2 languages."], "gold_sql": "SELECT COUNT(T2.Language) ,  T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Name HAVING COUNT(*)  >  2", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT c.Name, COUNT(cl.Language) AS LanguageCount\nFROM country c\nJOIN countrylanguage cl ON c.Code = cl.CountryCode\nGROUP BY c.Name\nHAVING COUNT(cl.Language) > 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of countries where a specific language is spoken as an official language. The placeholders in the query represent the language name and the official status of the language.\",\n    \"1\": \"This virtual table describes the languages spoken in countries that have a specific form of government. The query retrieves the languages from the 'countrylanguage' table by joining it with the 'country' table based on the country code. The placeholder in the WHERE clause represents the type of government, and the placeholder in the HAVING clause indicates the required count of countries that speak each language.\",\n    \"2\": \"This virtual table describes the languages spoken in countries that have a specific form of government. The query retrieves the languages from the 'countrylanguage' table by joining it with the 'country' table based on the country code. The placeholder in the WHERE clause represents the type of government, and the placeholder in the HAVING clause indicates the required count of languages spoken in those countries.\"\n}\n"}
{"sample_id": "dev.796", "db_id": "world_1", "question": "Find the government form name and total population for each government form whose average life expectancy is longer than 72.", "rationale": ["Identify the relevant table: The 'country' table contains the columns for GovernmentForm and Population, as well as LifeExpectancy.", "Filter the results: We need to filter the countries where the average life expectancy is greater than 72. This is done using a WHERE clause.", "Group the results: We want to summarize the total population for each government form, so we will use GROUP BY on the GovernmentForm column.", "Calculate the total population: We will use the SUM function to calculate the total population for each government form after filtering and grouping."], "gold_sql": "SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  72", "source_tables": ["country"], "pred_sql": "SELECT GovernmentForm, SUM(Population) AS TotalPopulation\nFROM country\nWHERE LifeExpectancy > 72\nGROUP BY GovernmentForm;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total population and average life expectancy of countries grouped by continent. It filters the results to only include continents where the average life expectancy is below a specified threshold. The placeholder in the HAVING clause represents the life expectancy limit.\",\n    \"1\": \"This virtual table lists the names of countries from the 'country' table that are located in a specific continent and have a population less than the maximum population of any country within the same continent. The placeholders in the WHERE clause represent the continent's name.\",\n    \"2\": \"This virtual table lists the names of countries from the 'country' table that are located in a specific continent and have a population greater than the minimum population of countries within the same continent. The placeholders in the WHERE clause represent the continent's name.\"\n}\n"}
{"sample_id": "dev.797", "db_id": "world_1", "question": "What are the different government forms and what is the total population of each for government forms that have an average life expectancy greater than 72?", "rationale": ["Identify the relevant table: The 'country' table contains the columns for GovernmentForm, Population, and LifeExpectancy.", "Filter the results: We need to filter for countries with an average LifeExpectancy greater than 72.", "Group the results: We want to group the results by GovernmentForm to get the total population for each form of government.", "Calculate the total population: Use the SUM function to calculate the total population for each government form."], "gold_sql": "SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  72", "source_tables": ["country"], "pred_sql": "SELECT GovernmentForm, SUM(Population) AS TotalPopulation\nFROM country\nWHERE LifeExpectancy > 72\nGROUP BY GovernmentForm;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total population and average life expectancy of countries grouped by continent. It filters the results to only include continents where the average life expectancy is below a specified threshold. The placeholder in the HAVING clause represents the life expectancy limit.\",\n    \"1\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\",\n    \"2\": \"This virtual table lists the names of countries from the 'country' table that are located in a specific continent and have a population less than the maximum population of any country within the same continent. The placeholders in the WHERE clause represent the continent's name.\"\n}\n"}
{"sample_id": "dev.801", "db_id": "world_1", "question": "Return the names and surface areas of the 5 largest countries.", "rationale": ["Identify the table needed: The 'country' table contains the names and surface areas of countries.", "Determine the required columns: We need 'Name' and 'SurfaceArea' from the 'country' table.", "Sort the countries by population: To find the largest countries, we will order the results by the 'Population' column in descending order.", "Limit the results: We only want the top 5 largest countries, so we will use 'LIMIT 5' in the query."], "gold_sql": "SELECT Name ,  SurfaceArea FROM country ORDER BY SurfaceArea DESC LIMIT 5", "source_tables": ["country"], "pred_sql": "SELECT Name, SurfaceArea FROM country ORDER BY Population DESC LIMIT 5;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of countries from the 'country' table that are located in a specific continent and have a population greater than the minimum population of countries within the same continent. The placeholders in the WHERE clause represent the continent's name.\",\n    \"1\": \"This virtual table lists the names of countries from the 'country' table that are located in a specific continent and have a population less than the maximum population of any country within the same continent. The placeholders in the WHERE clause represent the continent's name.\",\n    \"2\": \"This virtual table summarizes the total population and average life expectancy of countries grouped by continent. It filters the results to only include continents where the average life expectancy is below a specified threshold. The placeholder in the HAVING clause represents the life expectancy limit.\"\n}\n"}
{"sample_id": "dev.810", "db_id": "world_1", "question": "What is the total population and average area of countries in the continent of North America whose area is bigger than 3000 ?", "rationale": ["Identify the relevant table: The 'country' table contains the necessary information about countries, including population and surface area.", "Determine the required fields: We need to calculate the total population and average surface area, so we will use SUM(Population) and AVG(SurfaceArea).", "Apply the necessary filters: We need to filter the countries to only include those in the continent of North America and with a surface area greater than 3000.", "Construct the SQL query: Combine the selected fields and filters into a complete SQL query."], "gold_sql": "select sum(population) ,  avg(surfacearea) from country where continent  =  'north america' and surfacearea  >  3000", "source_tables": ["country"], "pred_sql": "SELECT SUM(Population) AS TotalPopulation, AVG(SurfaceArea) AS AverageArea \nFROM country \nWHERE Continent = 'North America' AND SurfaceArea > 3000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of countries from the 'country' table that are located in a specific continent and have a population greater than the minimum population of countries within the same continent. The placeholders in the WHERE clause represent the continent's name.\",\n    \"1\": \"This virtual table lists the names of countries from the 'country' table that are located in a specific continent and have a population less than the maximum population of any country within the same continent. The placeholders in the WHERE clause represent the continent's name.\",\n    \"2\": \"This virtual table summarizes the total population and average life expectancy of countries grouped by continent. It filters the results to only include continents where the average life expectancy is below a specified threshold. The placeholder in the HAVING clause represents the life expectancy limit.\"\n}\n"}
{"sample_id": "dev.811", "db_id": "world_1", "question": "Give the total population and average surface area corresponding to countries in North America that have a surface area greater than 3000 .", "rationale": ["Identify the relevant table: The 'country' table contains the necessary columns for population and surface area.", "Determine the required calculations: We need to calculate the total population and average surface area.", "Filter the results: We need to focus on countries in North America with a surface area greater than 3000.", "Construct the SQL query: Use SUM() for total population and AVG() for average surface area, applying the necessary WHERE clause to filter by continent and surface area."], "gold_sql": "select sum(population) ,  avg(surfacearea) from country where continent  =  'north america' and surfacearea  >  3000", "source_tables": ["country"], "pred_sql": "SELECT SUM(Population) AS TotalPopulation, AVG(SurfaceArea) AS AverageSurfaceArea \nFROM country \nWHERE Continent = 'North America' AND SurfaceArea > 3000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total population and average life expectancy of countries grouped by continent. It filters the results to only include continents where the average life expectancy is below a specified threshold. The placeholder in the HAVING clause represents the life expectancy limit.\",\n    \"1\": \"This virtual table lists the names of countries from the 'country' table that are located in a specific continent and have a population greater than the minimum population of countries within the same continent. The placeholders in the WHERE clause represent the continent's name.\",\n    \"2\": \"This virtual table lists the names of countries from the 'country' table that are located in a specific continent and have a population less than the maximum population of any country within the same continent. The placeholders in the WHERE clause represent the continent's name.\"\n}\n"}
{"sample_id": "dev.812", "db_id": "world_1", "question": "What are the cities whose population is between 160000 and 900000?", "rationale": ["Identify the table to query: The 'city' table contains the population data.", "Determine the condition for the population: We need cities with a population between 160000 and 900000.", "Construct the SQL query using the SELECT statement to retrieve all columns from the 'city' table where the population meets the specified range."], "gold_sql": "SELECT name FROM city WHERE Population BETWEEN 160000 AND 900000", "source_tables": ["city"], "pred_sql": "SELECT * FROM city WHERE Population BETWEEN 160000 AND 900000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of countries from the 'country' table that are located in a specific continent and have a population less than the maximum population of any country within the same continent. The placeholders in the WHERE clause represent the continent's name.\",\n    \"1\": \"This virtual table lists the names of countries from the 'country' table that are located in a specific continent and have a population greater than the minimum population of countries within the same continent. The placeholders in the WHERE clause represent the continent's name.\"\n}\n"}
{"sample_id": "dev.921", "db_id": "dog_kennels", "question": "Find the average age of the dogs who went through treatments.", "rationale": ["Identify the relevant tables: Dogs and Treatments.", "We need to find the average age of dogs that have undergone treatments, so we will join the Dogs table with the Treatments table on the dog_id.", "Use the AVG() function to calculate the average age of the dogs from the Dogs table after the join."], "gold_sql": "SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )", "source_tables": ["dogs", "treatments"], "pred_sql": "SELECT AVG(D.age) AS average_age\nFROM Dogs D\nJOIN Treatments T ON D.dog_id = T.dog_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of dogs from the 'Dogs' table that have not received treatments exceeding a specified total cost. The placeholder in the HAVING clause represents the maximum treatment cost threshold.\",\n    \"1\": \"This virtual table provides a list of owners along with their last names who have had dogs treated, sorted by the number of treatments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of owners to display.\",\n    \"2\": \"This virtual table provides a list of unique first and last names of professionals who have administered treatments that cost less than the average cost of treatments recorded in the database. The placeholders in the query allow for dynamic filtering based on treatment costs.\"\n}\n"}
{"sample_id": "dev.924", "db_id": "dog_kennels", "question": "Which dogs have not cost their owner more than 1000 for treatment ? List the dog names .", "rationale": ["Identify the main table to query from, which is the 'Dogs' table, to get the names of the dogs.", "We need to filter the dogs based on their treatment costs, so we will use a subquery to find dogs that have treatment costs exceeding 1000.", "The subquery will select 'dog_id' from the 'Treatments' table, grouping by 'dog_id' and using the HAVING clause to sum the 'cost_of_treatment' and filter those that exceed 1000.", "The main query will select the 'name' of dogs whose 'dog_id' is not in the result set of the subquery, effectively giving us the dogs that have not cost their owner more than 1000 for treatment."], "gold_sql": "select name from dogs where dog_id not in ( select dog_id from treatments group by dog_id having sum(cost_of_treatment)  >  1000 )", "source_tables": ["dogs", "treatments"], "pred_sql": "SELECT name FROM Dogs \nWHERE dog_id NOT IN (\n    SELECT dog_id FROM Treatments \n    GROUP BY dog_id \n    HAVING SUM(cost_of_treatment) > 1000\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of dogs from the 'Dogs' table that have not received treatments exceeding a specified total cost. The placeholder in the HAVING clause represents the maximum treatment cost threshold.\",\n    \"1\": \"This virtual table provides a list of owners along with their last names who have had dogs treated, sorted by the number of treatments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of owners to display.\",\n    \"2\": \"This virtual table provides a list of unique first and last names of professionals who have administered treatments that cost less than the average cost of treatments recorded in the database. The placeholders in the query allow for dynamic filtering based on treatment costs.\"\n}\n"}
{"sample_id": "dev.937", "db_id": "dog_kennels", "question": "Tell me the owner id and last name of the owner who spent the most on treatments of his or her dogs.", "rationale": ["Identify the relevant tables: Owners, Dogs, and Treatments.", "Join the Owners table with the Dogs table on owner_id to link owners to their dogs.", "Join the resulting table with the Treatments table on dog_id to link treatments to the respective dogs.", "Group the results by owner_id and last_name to aggregate treatment costs for each owner.", "Use SUM to calculate the total cost of treatments for each owner.", "Order the results in descending order based on the total treatment cost to find the owner who spent the most.", "Limit the results to 1 to get only the top owner."], "gold_sql": "SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["owners", "dogs", "treatments"], "pred_sql": "SELECT Owners.owner_id, Owners.last_name\nFROM Owners\nJOIN Dogs ON Owners.owner_id = Dogs.owner_id\nJOIN Treatments ON Dogs.dog_id = Treatments.dog_id\nGROUP BY Owners.owner_id, Owners.last_name\nORDER BY SUM(Treatments.cost_of_treatment) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of owners along with their last names who have had dogs treated, sorted by the number of treatments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of owners to display.\",\n    \"1\": \"This virtual table lists the names of dogs from the 'Dogs' table that have not received treatments exceeding a specified total cost. The placeholder in the HAVING clause represents the maximum treatment cost threshold.\",\n    \"2\": \"This virtual table provides a list of unique first and last names of professionals who have administered treatments that cost less than the average cost of treatments recorded in the database. The placeholders in the query allow for dynamic filtering based on treatment costs.\"\n}\n"}
{"sample_id": "dev.942", "db_id": "dog_kennels", "question": "Which professionals have done at least two types of treatments? List the professional id and cell phone.", "rationale": ["Identify the relevant tables: Professionals and Treatments.", "We need to find professionals who have administered at least two types of treatments, which means we will group the Treatments by professional_id and count the distinct treatment_type_code.", "Use a subquery to filter professionals based on the count of distinct treatment types they have administered.", "Select the professional_id and cell_number from the Professionals table where the professional_id is in the result of the subquery."], "gold_sql": "SELECT T1.professional_id ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  2", "source_tables": ["professionals", "treatments"], "pred_sql": "SELECT professional_id, cell_number\nFROM Professionals\nWHERE professional_id IN (\n    SELECT professional_id\n    FROM Treatments\n    GROUP BY professional_id\n    HAVING COUNT(DISTINCT treatment_type_code) >= 2\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique first and last names of professionals who have administered treatments that cost less than the average cost of treatments recorded in the database. The placeholders in the query allow for dynamic filtering based on treatment costs.\",\n    \"1\": \"This virtual table provides a list of unique first and last names of professionals who have administered treatments that cost less than the average treatment cost. The query joins the 'Professionals' table with the 'Treatments' table to filter based on the treatment cost, using a subquery to calculate the average cost of treatments.\"\n}\n"}
{"sample_id": "dev.943", "db_id": "dog_kennels", "question": "Find the id and cell phone of the professionals who operate two or more types of treatments.", "rationale": ["Identify the relevant tables: Professionals and Treatments.", "We need to find professionals who operate two or more types of treatments, which means we will join the Professionals table with the Treatments table on the professional_id.", "We will group the results by professional_id to count the distinct treatment types each professional has administered.", "Using the HAVING clause, we will filter the groups to include only those with a count of distinct treatment types greater than or equal to 2.", "Finally, we will select the professional_id and cell_number from the filtered results."], "gold_sql": "SELECT T1.professional_id ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  2", "source_tables": ["professionals", "treatments"], "pred_sql": "SELECT p.professional_id, p.cell_number\nFROM Professionals p\nJOIN Treatments t ON p.professional_id = t.professional_id\nGROUP BY p.professional_id\nHAVING COUNT(DISTINCT t.treatment_type_code) >= 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique first and last names of professionals who have administered treatments that cost less than the average cost of treatments recorded in the database. The placeholders in the query allow for dynamic filtering based on treatment costs.\",\n    \"1\": \"This virtual table provides a list of unique first and last names of professionals who have administered treatments that cost less than the average treatment cost. The query joins the 'Professionals' table with the 'Treatments' table to filter based on the treatment cost, using a subquery to calculate the average cost of treatments.\"\n}\n"}
{"sample_id": "dev.950", "db_id": "dog_kennels", "question": "List each owner's first name, last name, and the size of his for her dog.", "rationale": ["Identify the required information: owner's first name, last name, and dog's size.", "Determine the relevant tables: Owners, Dogs, and Sizes.", "Establish the relationships between the tables: Owners to Dogs (via owner_id) and Dogs to Sizes (via size_code).", "Use JOIN clauses to combine the tables based on these relationships.", "Select the appropriate columns from the combined tables."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id", "source_tables": ["owners", "dogs"], "pred_sql": "SELECT Owners.first_name, Owners.last_name, Sizes.size_description \nFROM Owners \nJOIN Dogs ON Owners.owner_id = Dogs.owner_id \nJOIN Sizes ON Dogs.size_code = Sizes.size_code;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of owners along with their last names who have had dogs treated, sorted by the number of treatments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of owners to display.\"\n}\n"}
{"sample_id": "dev.954", "db_id": "dog_kennels", "question": "List the names of the dogs of the rarest breed and the treatment dates of them.", "rationale": ["Identify the tables needed: Dogs, Breeds, and Treatments.", "We need to list dog names and treatment dates, so we will select 'name' from Dogs and 'date_of_treatment' from Treatments.", "Join the Dogs table with the Breeds table to filter by breed.", "Join the Treatments table to get the treatment dates for the dogs.", "To find the rarest breed, we will use a subquery that counts the number of dogs per breed and orders them in ascending order, limiting the result to the first one (the rarest).", "The final query will select the dog names and their corresponding treatment dates for dogs of the rarest breed."], "gold_sql": "SELECT T1.name ,  T2.date_of_treatment FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id WHERE T1.breed_code  =  ( SELECT breed_code FROM Dogs GROUP BY breed_code ORDER BY count(*) ASC LIMIT 1 )", "source_tables": ["dogs", "treatments"], "pred_sql": "SELECT d.name, t.date_of_treatment \nFROM Dogs d \nJOIN Breeds b ON d.breed_code = b.breed_code \nJOIN Treatments t ON d.dog_id = t.dog_id \nWHERE b.breed_code = (SELECT breed_code \n                      FROM Breeds \n                      GROUP BY breed_code \n                      ORDER BY COUNT(*) ASC \n                      LIMIT 1)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of owners along with their last names who have had dogs treated, sorted by the number of treatments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of owners to display.\",\n    \"1\": \"This virtual table lists the names of dogs from the 'Dogs' table that have not received treatments exceeding a specified total cost. The placeholder in the HAVING clause represents the maximum treatment cost threshold.\",\n    \"2\": \"This virtual table provides a list of unique first and last names of professionals who have administered treatments that cost less than the average cost of treatments recorded in the database. The placeholders in the query allow for dynamic filtering based on treatment costs.\"\n}\n"}
{"sample_id": "dev.958", "db_id": "dog_kennels", "question": "What are the arriving date and the departing date of the dogs who have gone through a treatment?", "rationale": ["Identify the relevant tables: Dogs and Treatments.", "Determine the columns needed: date_arrived and date_departed from Dogs.", "Establish the relationship between Dogs and Treatments using the dog_id foreign key.", "Construct the SQL query to select the required columns from Dogs, joining with Treatments on dog_id."], "gold_sql": "SELECT DISTINCT T1.date_arrived ,  T1.date_departed FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id", "source_tables": ["dogs", "treatments"], "pred_sql": "SELECT d.date_arrived, d.date_departed\nFROM Dogs d\nJOIN Treatments t ON d.dog_id = t.dog_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of dogs from the 'Dogs' table that have not received treatments exceeding a specified total cost. The placeholder in the HAVING clause represents the maximum treatment cost threshold.\",\n    \"1\": \"This virtual table provides a list of owners along with their last names who have had dogs treated, sorted by the number of treatments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of owners to display.\",\n    \"2\": \"This virtual table provides a list of unique first and last names of professionals who have administered treatments that cost less than the average cost of treatments recorded in the database. The placeholders in the query allow for dynamic filtering based on treatment costs.\"\n}\n"}
{"sample_id": "dev.960", "db_id": "dog_kennels", "question": "List the last name of the owner owning the youngest dog.", "rationale": ["Identify the relevant tables: Owners and Dogs.", "We need to find the last name of the owner, so we will select Owners.last_name.", "To find the youngest dog, we need to order the Dogs table by age in ascending order.", "We will join the Owners table with the Dogs table on the owner_id to link owners with their dogs.", "Finally, we will limit the results to 1 to get only the owner of the youngest dog."], "gold_sql": "SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )", "source_tables": ["owners", "dogs"], "pred_sql": "SELECT Owners.last_name\nFROM Owners\nJOIN Dogs ON Owners.owner_id = Dogs.owner_id\nORDER BY Dogs.age ASC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of owners along with their last names who have had dogs treated, sorted by the number of treatments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of owners to display.\",\n    \"1\": \"This virtual table lists the names of dogs from the 'Dogs' table that have not received treatments exceeding a specified total cost. The placeholder in the HAVING clause represents the maximum treatment cost threshold.\"\n}\n"}
{"sample_id": "dev.997", "db_id": "dog_kennels", "question": "Find the distinct breed type and size type combinations for dogs.", "rationale": ["Identify the tables needed: Dogs, Breeds, and Sizes.", "We need to get distinct combinations of breed types and size types, so we will select breed names from the Breeds table and size descriptions from the Sizes table.", "Join the Dogs table with the Breeds table on the breed_code to get the breed names.", "Join the Dogs table with the Sizes table on the size_code to get the size descriptions.", "Use SELECT DISTINCT to ensure that we only get unique combinations of breed names and size descriptions."], "gold_sql": "SELECT DISTINCT breed_code ,  size_code FROM dogs", "source_tables": ["dogs"], "pred_sql": "SELECT DISTINCT B.breed_name, S.size_description\nFROM Dogs D\nJOIN Breeds B ON D.breed_code = B.breed_code\nJOIN Sizes S ON D.size_code = S.size_code;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of owners along with their last names who have had dogs treated, sorted by the number of treatments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of owners to display.\",\n    \"1\": \"This virtual table lists the names of dogs from the 'Dogs' table that have not received treatments exceeding a specified total cost. The placeholder in the HAVING clause represents the maximum treatment cost threshold.\"\n}\n"}
{"sample_id": "dev.999", "db_id": "dog_kennels", "question": "What are each professional's first name and description of the treatment they have performed?", "rationale": ["Identify the required information: first name of professionals and description of treatments they performed.", "Determine the relevant tables: 'Professionals' for professional details and 'Treatments' for treatment details.", "Establish the relationship between tables: 'Treatments' links to 'Professionals' via professional_id, and 'Treatments' links to 'Treatment_Types' via treatment_type_code.", "Construct the SQL query to select the first name from 'Professionals' and the treatment description from 'Treatment_Types', using JOINs to connect the tables."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code", "source_tables": ["professionals", "treatments", "treatment_types"], "pred_sql": "SELECT Professionals.first_name, Treatment_Types.treatment_type_description \nFROM Professionals \nJOIN Treatments ON Professionals.professional_id = Treatments.professional_id \nJOIN Treatment_Types ON Treatments.treatment_type_code = Treatment_Types.treatment_type_code;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique first and last names of professionals who have administered treatments that cost less than the average cost of treatments recorded in the database. The placeholders in the query allow for dynamic filtering based on treatment costs.\",\n    \"1\": \"This virtual table provides a list of unique first and last names of professionals who have administered treatments that cost less than the average treatment cost. The query joins the 'Professionals' table with the 'Treatments' table to filter based on the treatment cost, using a subquery to calculate the average cost of treatments.\"\n}\n"}
