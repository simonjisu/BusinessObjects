{"sample_id": "train.64", "db_id": "student_assessment", "question": "List the id of students who attended some courses?", "rationale": ["We need to find the IDs of students who have attended courses.", "The relevant table for attendance is 'Student_Course_Attendance', which contains the 'student_id' of students who attended courses.", "To get unique student IDs, we will use the DISTINCT keyword to avoid duplicates in the results."], "gold_sql": "SELECT student_id FROM student_course_attendance", "source_tables": ["student_course_attendance"], "pred_sql": "SELECT DISTINCT student_id FROM Student_Course_Attendance;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve course names. The result is grouped by course ID to count the number of students per course.\"\n}\n"}
{"sample_id": "train.68", "db_id": "student_assessment", "question": "What details do we have on the students who registered for courses most recently?", "rationale": ["Identify the relevant tables: Students, Student_Course_Registrations, and Courses.", "Join the Students table with the Student_Course_Registrations table to link students to their course registrations.", "Join the result with the Courses table to retrieve course names.", "Select the student details and registration date, along with the course name.", "Order the results by registration date in descending order to get the most recent registrations first.", "Limit the results to the top 10 to focus on the most recent registrations."], "gold_sql": "SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT 1", "source_tables": ["student_course_registrations", "students"], "pred_sql": "SELECT s.student_id, s.student_details, scr.registration_date, c.course_name \nFROM Students s \nJOIN Student_Course_Registrations scr ON s.student_id = scr.student_id \nJOIN Courses c ON scr.course_id = c.course_id \nORDER BY scr.registration_date DESC \nLIMIT 10;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve course names. The result is grouped by course ID to count the number of students per course.\"\n}\n"}
{"sample_id": "train.76", "db_id": "student_assessment", "question": "What is the id of the candidate who most recently accessed the course?", "rationale": ["Identify the relevant tables: Candidates, Student_Course_Attendance, and Student_Course_Registrations.", "We need to find the candidate who accessed a course, which means we need to join Candidates with Student_Course_Attendance.", "The join condition will be on the candidate_id from Candidates and student_id from Student_Course_Attendance.", "We also need to ensure that we are considering the course registration, so we will join Student_Course_Registrations on student_id and course_id.", "To find the most recent access, we will order the results by date_of_attendance in descending order.", "Finally, we will limit the results to 1 to get the most recent candidate."], "gold_sql": "SELECT candidate_id FROM candidate_assessments ORDER BY assessment_date DESC LIMIT 1", "source_tables": ["candidate_assessments"], "pred_sql": "SELECT DISTINCT c.candidate_id\nFROM Candidates c\nJOIN Student_Course_Attendance sca ON c.candidate_id = sca.student_id\nJOIN Student_Course_Registrations scr ON sca.student_id = scr.student_id AND sca.course_id = scr.course_id\nORDER BY sca.date_of_attendance DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.78", "db_id": "student_assessment", "question": "What are the details of the student who registered for the most number of courses?", "rationale": ["Identify the relevant tables: Students and Student_Course_Registrations.", "Join the Students table with the Student_Course_Registrations table to link students to their course registrations.", "Group the results by student_id to count the number of courses each student is registered for.", "Order the results in descending order based on the count of registered courses to find the student with the most registrations.", "Limit the results to 1 to get only the student with the highest number of course registrations."], "gold_sql": "SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_course_registrations", "students"], "pred_sql": "SELECT s.student_id, s.student_details \nFROM Students s \nJOIN Student_Course_Registrations scr ON s.student_id = scr.student_id \nGROUP BY s.student_id \nORDER BY COUNT(scr.course_id) DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve course names. The result is grouped by course ID to count the number of students per course.\"\n}\n"}
{"sample_id": "train.82", "db_id": "student_assessment", "question": "For each course id, how many students are registered and what are the course names?", "rationale": ["We need to retrieve the course ID and course names along with the count of registered students for each course.", "To achieve this, we will select the 'course_id' and 'course_name' from the 'Courses' table.", "We will also count the number of students registered for each course using the 'COUNT' function on 'student_id' from the 'Student_Course_Registrations' table.", "To link the courses with their registrations, we will perform a LEFT JOIN between the 'Courses' table and the 'Student_Course_Registrations' table on the 'course_id'.", "Finally, we will group the results by 'course_id' and 'course_name' to get the count of students for each course."], "gold_sql": "SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id", "source_tables": ["courses", "student_course_registrations", "students"], "pred_sql": "SELECT Courses.course_id, Courses.course_name, COUNT(Student_Course_Registrations.student_id) AS student_count\nFROM Courses\nLEFT JOIN Student_Course_Registrations ON Courses.course_id = Student_Course_Registrations.course_id\nGROUP BY Courses.course_id, Courses.course_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve course names. The result is grouped by course ID to count the number of students per course.\"\n}\n"}
{"sample_id": "train.89", "db_id": "student_assessment", "question": "What is the id of the student who most recently registered course 301?", "rationale": ["Identify the relevant table for course registrations, which is 'Student_Course_Registrations'.", "Filter the records in 'Student_Course_Registrations' to only include those where the 'course_id' is '301'.", "Order the results by 'registration_date' in descending order to get the most recent registration first.", "Limit the results to 1 to get only the most recent student registration for course 301."], "gold_sql": "SELECT student_id FROM student_course_attendance WHERE course_id = 301 ORDER BY date_of_attendance DESC LIMIT 1", "source_tables": ["student_course_attendance"], "pred_sql": "SELECT student_id FROM Student_Course_Registrations WHERE course_id = '301' ORDER BY registration_date DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve course names. The result is grouped by course ID to count the number of students per course.\"\n}\n"}
{"sample_id": "train.92", "db_id": "student_assessment", "question": "What are the different cities where people live?", "rationale": ["We need to find unique cities where people live, which means we will use the DISTINCT keyword to avoid duplicates.", "The relevant tables for this query are 'Addresses', 'People_Addresses', and 'Students'.", "We will join 'Addresses' with 'People_Addresses' on the address_id to link addresses to people.", "Next, we will join 'People_Addresses' with 'Students' on person_id to link people to their student records.", "Finally, we will select the city from the 'Addresses' table to get the list of cities."], "gold_sql": "SELECT DISTINCT T1.city FROM addresses AS T1 JOIN people_addresses AS T2 ON T1.address_id = T2.address_id", "source_tables": ["addresses", "people_addresses"], "pred_sql": "SELECT DISTINCT Addresses.city FROM Addresses JOIN People_Addresses ON Addresses.address_id = People_Addresses.address_id JOIN Students ON People_Addresses.person_id = Students.student_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique cities where students are located, by joining the 'Addresses', 'People_Addresses', and 'Students' tables. The placeholders in the query represent the necessary identifiers for the relationships between these tables.\"\n}\n"}
{"sample_id": "train.105", "db_id": "student_assessment", "question": "List the id of students who registered course statistics in the order of registration date.", "rationale": ["Identify the relevant tables: Students, Student_Course_Registrations, and Courses.", "Join the Students table with the Student_Course_Registrations table to link students to their course registrations.", "Join the result with the Courses table to filter for the course named 'Statistics'.", "Select the student_id from the Students table.", "Order the results by the registration_date from the Student_Course_Registrations table."], "gold_sql": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = 'statistics' ORDER BY T2.registration_date", "source_tables": ["courses", "student_course_registrations"], "pred_sql": "SELECT s.student_id \nFROM Students s \nJOIN Student_Course_Registrations scr ON s.student_id = scr.student_id \nJOIN Courses c ON scr.course_id = c.course_id \nWHERE c.course_name = 'Statistics' \nORDER BY scr.registration_date;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve course names. The result is grouped by course ID to count the number of students per course.\"\n}\n"}
{"sample_id": "train.106", "db_id": "student_assessment", "question": "What are the ids of the students who registered course statistics by order of registration date?", "rationale": ["Identify the relevant tables: Students, Student_Course_Registrations, and Courses.", "Join the Students table with the Student_Course_Registrations table to link students to their course registrations.", "Join the result with the Courses table to filter for the course named 'Statistics'.", "Select the student_id from the resulting joined table.", "Order the results by the registration_date to get the ids in the order of registration."], "gold_sql": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = 'statistics' ORDER BY T2.registration_date", "source_tables": ["courses", "student_course_registrations"], "pred_sql": "SELECT s.student_id \nFROM Students s \nJOIN Student_Course_Registrations scr ON s.student_id = scr.student_id \nJOIN Courses c ON scr.course_id = c.course_id \nWHERE c.course_name = 'Statistics' \nORDER BY scr.registration_date;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve course names. The result is grouped by course ID to count the number of students per course.\"\n}\n"}
{"sample_id": "train.387", "db_id": "flight_1", "question": "Show origins of all flights with destination Honolulu.", "rationale": ["Identify the table that contains the relevant information: the 'flight' table.", "Determine the columns needed: we need the 'origin' column for the flights.", "Apply a filter to get only those flights that have 'Honolulu' as the destination.", "Construct the SQL query using the SELECT statement to retrieve the 'origin' from the 'flight' table where the 'destination' is 'Honolulu'."], "gold_sql": "SELECT origin FROM Flight WHERE destination  =  'Honolulu'", "source_tables": ["flight"], "pred_sql": "SELECT origin FROM flight WHERE destination = 'Honolulu';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of employees who hold certificates for aircraft that can travel a distance greater than a specified value. The results are grouped by employee ID and ordered by the number of certificates held, with a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.390", "db_id": "flight_1", "question": "What are the departure and arrival dates of all flights from LA to Honolulu?", "rationale": ["Identify the relevant table: The 'flight' table contains the information about flights, including departure and arrival dates.", "Determine the columns needed: We need 'departure_date' and 'arrival_date' for the flights.", "Specify the conditions: We want flights that originate from 'LA' and have 'Honolulu' as the destination.", "Construct the SQL query: Use a SELECT statement to retrieve the required columns from the 'flight' table with the specified conditions."], "gold_sql": "SELECT departure_date ,  arrival_date FROM Flight WHERE origin  =  'Los Angeles' AND destination  =  'Honolulu'", "source_tables": ["flight"], "pred_sql": "SELECT departure_date, arrival_date FROM flight WHERE origin = 'LA' AND destination = 'Honolulu';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of employees who hold certificates for aircraft that can travel a distance greater than a specified value. The results are grouped by employee ID and ordered by the number of certificates held, with a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.400", "db_id": "flight_1", "question": "What are the numbers of the shortest flights?", "rationale": ["Identify the relevant table: The 'flight' table contains information about flights, including their distances.", "Determine the requirement: The user wants to find the shortest flights, which means we need to sort the flights by distance.", "Construct the SQL query: We will select the flight number (flno) from the flight table, order the results by distance in ascending order, and limit the results to the shortest flight."], "gold_sql": "SELECT flno FROM Flight ORDER BY distance ASC LIMIT 3", "source_tables": ["flight"], "pred_sql": "SELECT flno FROM flight ORDER BY distance ASC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of employees who hold certificates for aircraft that can travel a distance greater than a specified value. The results are grouped by employee ID and ordered by the number of certificates held, with a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.408", "db_id": "flight_1", "question": "What place has the most flights coming from there?", "rationale": ["Identify the table that contains flight information, which is the 'flight' table.", "We need to find the place with the most flights coming from there, which means we need to count the number of flights grouped by their origin.", "Use the COUNT() function to count the number of flights for each origin.", "Group the results by the 'origin' column to aggregate the flight counts.", "Order the results in descending order based on the flight count to get the place with the most flights at the top.", "Limit the results to 1 to get only the top place."], "gold_sql": "SELECT origin FROM Flight GROUP BY origin ORDER BY count(*) DESC LIMIT 1", "source_tables": ["flight"], "pred_sql": "SELECT origin, COUNT(*) AS flight_count \nFROM flight \nGROUP BY origin \nORDER BY flight_count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of employees who hold certificates for aircraft that can travel a distance greater than a specified value. The results are grouped by employee ID and ordered by the number of certificates held, with a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.416", "db_id": "flight_1", "question": "What is the name of each aircraft and how many flights does each one complete?", "rationale": ["Identify the tables needed: 'aircraft' for aircraft names and 'flight' for flight counts.", "Use a LEFT JOIN to connect 'aircraft' and 'flight' on the aircraft ID (aid) to ensure all aircraft are included, even those with no flights.", "Select the aircraft name from the 'aircraft' table and count the number of flights from the 'flight' table.", "Group the results by aircraft ID and name to get the count of flights for each aircraft."], "gold_sql": "SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid", "source_tables": ["aircraft", "flight"], "pred_sql": "SELECT a.name, COUNT(f.flno) AS flight_count\nFROM aircraft a\nLEFT JOIN flight f ON a.aid = f.aid\nGROUP BY a.aid, a.name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of employees who hold certificates for aircraft that can travel a distance greater than a specified value. The results are grouped by employee ID and ordered by the number of certificates held, with a limit on the number of results returned.\",\n    \"1\": \"This virtual table lists the names of employees from the 'Employee' table who do not hold a certificate for a specific aircraft model. The placeholder in the query represents the name of the aircraft model.\"\n}\n"}
{"sample_id": "train.429", "db_id": "flight_1", "question": "Show names for all employees who do not have certificate of Boeing 737-800.", "rationale": ["Identify the main table to query from, which is the 'employee' table to get employee names.", "We need to find employees who do not have a certificate for the Boeing 737-800.", "To do this, we will use a subquery that selects employee IDs (eid) from the 'certificate' table where the aircraft name is 'Boeing 737-800'.", "We will join the 'certificate' table with the 'aircraft' table to filter by the aircraft name.", "The main query will select names from the 'employee' table where the employee ID is not in the list of IDs returned by the subquery."], "gold_sql": "SELECT name FROM Employee EXCEPT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  'Boeing 737-800'", "source_tables": ["employee", "certificate", "aircraft"], "pred_sql": "SELECT name FROM employee WHERE eid NOT IN (SELECT eid FROM certificate INNER JOIN aircraft ON certificate.aid = aircraft.aid WHERE aircraft.name = 'Boeing 737-800');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of employees from the 'Employee' table who do not hold a certificate for a specific aircraft model. The placeholder in the query represents the name of the aircraft model.\",\n    \"1\": \"This virtual table provides the names of employees who hold certificates for aircraft that can travel a distance greater than a specified value. The results are grouped by employee ID and ordered by the number of certificates held, with a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.433", "db_id": "flight_1", "question": "Show the name and distance of the aircrafts with more than 5000 distance and which at least 5 people have its certificate.", "rationale": ["Identify the tables needed: aircraft and certificate.", "We need to select the name and distance of aircraft, so we will select 'a.name' and 'a.distance' from the aircraft table.", "We need to filter aircraft with a distance greater than 5000, so we will use a WHERE clause: 'WHERE a.distance > 5000'.", "We need to count the number of certificates for each aircraft, so we will join the certificate table on the aircraft ID: 'JOIN certificate c ON a.aid = c.aid'.", "To ensure we only get aircraft with at least 5 certificates, we will group the results by aircraft ID and use a HAVING clause: 'GROUP BY a.aid HAVING COUNT(c.eid) >= 5'."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  5000 GROUP BY T1.aid ORDER BY count(*)  >=  5", "source_tables": ["aircraft", "certificate"], "pred_sql": "SELECT a.name, a.distance \nFROM aircraft a \nJOIN certificate c ON a.aid = c.aid \nWHERE a.distance > 5000 \nGROUP BY a.aid \nHAVING COUNT(c.eid) >= 5;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of employees who hold certificates for aircraft that can travel a distance greater than a specified value. The results are grouped by employee ID and ordered by the number of certificates held, with a limit on the number of results returned.\",\n    \"1\": \"This virtual table lists the names of employees from the 'Employee' table who do not hold a certificate for a specific aircraft model. The placeholder in the query represents the name of the aircraft model.\"\n}\n"}
{"sample_id": "train.434", "db_id": "flight_1", "question": "What is the name and distance of every aircraft that can cover a distance of more than 5000 and which at least 5 people can fly?", "rationale": ["Identify the relevant table: We need information from the 'aircraft' table for aircraft names and distances.", "Set the condition for distance: We want aircraft that can cover a distance of more than 5000.", "Determine the condition for the number of flights: We need to ensure that at least 5 flights are associated with the aircraft. This can be done by checking the 'flight' table and grouping by 'aid' to count the number of distinct flights (flno).", "Combine the conditions: Use a subquery to filter aircraft IDs (aid) that have at least 5 flights, and combine this with the distance condition in the main query.", "Construct the final SQL query: Select the name and distance from the 'aircraft' table where the distance is greater than 5000 and the aircraft ID is in the list of IDs returned by the subquery."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  5000 GROUP BY T1.aid ORDER BY count(*)  >=  5", "source_tables": ["aircraft", "certificate"], "pred_sql": "SELECT name, distance FROM aircraft WHERE distance > 5000 AND aid IN (SELECT aid FROM flight GROUP BY aid HAVING COUNT(DISTINCT flno) >= 5);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of employees who hold certificates for aircraft that can travel a distance greater than a specified value. The results are grouped by employee ID and ordered by the number of certificates held, with a limit on the number of results returned.\",\n    \"1\": \"This virtual table lists the names of employees from the 'Employee' table who do not hold a certificate for a specific aircraft model. The placeholder in the query represents the name of the aircraft model.\"\n}\n"}
{"sample_id": "train.437", "db_id": "flight_1", "question": "What is the salary and name of the employee who has the most number of certificates on aircrafts with distance more than 5000?", "rationale": ["Identify the relevant tables: employee, certificate, and aircraft.", "We need to find employees who hold certificates for aircraft with a distance greater than 5000.", "Join the employee table with the certificate table on employee ID (eid) and with the aircraft table on aircraft ID (aid).", "Filter the results to include only those aircraft where the distance is greater than 5000.", "Group the results by employee ID to count the number of certificates each employee holds.", "Order the results by the count of certificates in descending order to find the employee with the most certificates.", "Limit the results to 1 to get only the top employee."], "gold_sql": "SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  5000 GROUP BY T1.eid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employee", "certificate", "aircraft"], "pred_sql": "SELECT e.name, e.salary\nFROM employee e\nJOIN certificate c ON e.eid = c.eid\nJOIN aircraft a ON c.aid = a.aid\nWHERE a.distance > 5000\nGROUP BY e.eid\nORDER BY COUNT(c.aid) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of employees who hold certificates for aircraft that can travel a distance greater than a specified value. The results are grouped by employee ID and ordered by the number of certificates held, with a limit on the number of results returned.\",\n    \"1\": \"This virtual table lists the names of employees from the 'Employee' table who do not hold a certificate for a specific aircraft model. The placeholder in the query represents the name of the aircraft model.\"\n}\n"}
{"sample_id": "train.448", "db_id": "allergy_1", "question": "What are all the different food allergies?", "rationale": ["The question asks for all the different food allergies, which implies we need to retrieve unique allergy names.", "The relevant table for allergies is 'Allergy_Type', which contains a column named 'Allergy'.", "To get all different food allergies, we can use the SELECT statement with DISTINCT to ensure we only get unique allergy names."], "gold_sql": "SELECT DISTINCT allergy FROM Allergy_type WHERE allergytype  =  'food'", "source_tables": ["allergy_type"], "pred_sql": "SELECT DISTINCT Allergy FROM Allergy_Type;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\",\n    \"1\": \"This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the WHERE clause represent the gender of the students and the type of allergy they have.\",\n    \"2\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the allergy types to be excluded.\"\n}\n"}
{"sample_id": "train.456", "db_id": "allergy_1", "question": "Which allergy type is most common?", "rationale": ["Identify the relevant tables: Allergy_Type and Has_Allergy are needed to determine the allergy types and their occurrences.", "Join the Allergy_Type table with the Has_Allergy table on the Allergy column to associate each allergy with its type.", "Group the results by AllergyType to count how many students have each type of allergy.", "Use COUNT(*) to count the number of occurrences of each allergy type.", "Order the results in descending order based on the count to find the most common allergy type.", "Limit the results to 1 to get only the most common allergy type."], "gold_sql": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT 1", "source_tables": ["allergy_type"], "pred_sql": "SELECT AllergyType, COUNT(*) as AllergyCount\nFROM Allergy_Type\nJOIN Has_Allergy ON Allergy_Type.Allergy = Has_Allergy.Allergy\nGROUP BY AllergyType\nORDER BY AllergyCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\",\n    \"1\": \"This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the WHERE clause represent the gender of the students and the type of allergy they have.\",\n    \"2\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the allergy types to be excluded.\"\n}\n"}
{"sample_id": "train.458", "db_id": "allergy_1", "question": "Which allergy type is the least common?", "rationale": ["Identify the tables involved: We need to find the allergy type and the count of students with each allergy type, so we will use the 'Allergy_Type' and 'Has_Allergy' tables.", "Join the tables: We will join 'Has_Allergy' with 'Allergy_Type' on the 'Allergy' column to get the allergy type for each student.", "Group by allergy type: We will group the results by 'AllergyType' to count how many students have each type of allergy.", "Count the number of students: We will use COUNT(*) to count the number of students for each allergy type.", "Order the results: We will order the results in ascending order based on the count of students to find the least common allergy type.", "Limit the results: We will limit the results to 1 to get only the least common allergy type."], "gold_sql": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) ASC LIMIT 1", "source_tables": ["allergy_type"], "pred_sql": "SELECT AllergyType, COUNT(*) AS AllergyCount\nFROM Has_Allergy\nJOIN Allergy_Type ON Has_Allergy.Allergy = Allergy_Type.Allergy\nGROUP BY AllergyType\nORDER BY AllergyCount ASC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\",\n    \"1\": \"This virtual table provides the first and last names of students from the 'Student' table who do not have a specific type of allergy. The placeholder in the subquery represents the allergy type that is being filtered out.\",\n    \"2\": \"This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the WHERE clause represent the gender of the students and the type of allergy they have.\"\n}\n"}
{"sample_id": "train.462", "db_id": "allergy_1", "question": "What are the full names of all students", "rationale": ["Identify the table that contains student information, which is the 'Student' table.", "Determine the columns needed to get the full names of the students, which are 'Fname' and 'LName'.", "Construct the SQL query to select 'Fname' and 'LName' from the 'Student' table."], "gold_sql": "SELECT Fname ,  Lname FROM Student", "source_tables": ["student"], "pred_sql": "SELECT Fname, LName FROM Student;", "hint": "\n"}
{"sample_id": "train.472", "db_id": "allergy_1", "question": "What are the student ids for all male students?", "rationale": ["Identify the relevant table: The 'Student' table contains the information about students, including their gender.", "Determine the required information: We need the student IDs (StuID) for all male students.", "Construct the SQL query: Use a SELECT statement to retrieve the StuID from the Student table where the Sex is 'Male'."], "gold_sql": "SELECT StuID FROM Student WHERE Sex  =  'M'", "source_tables": ["student"], "pred_sql": "SELECT StuID FROM Student WHERE Sex = 'Male';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the WHERE clause represent the gender of the students and the type of allergy they have.\"\n}\n"}
{"sample_id": "train.492", "db_id": "allergy_1", "question": "What is the largest major?", "rationale": ["Identify the table that contains the major information, which is the 'Student' table.", "To find the largest major, we need to count the number of students in each major.", "We will use the COUNT function to count the number of students for each major.", "We will group the results by the 'Major' column to get the count for each major.", "To find the largest major, we will order the results in descending order based on the count of students.", "Finally, we will limit the results to 1 to get only the largest major."], "gold_sql": "SELECT major FROM Student GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Major FROM Student GROUP BY Major ORDER BY COUNT(*) DESC LIMIT 1;", "hint": "\n"}
{"sample_id": "train.501", "db_id": "allergy_1", "question": "Which advisor has most number of students?", "rationale": ["Identify the relevant table: The 'Student' table contains the 'Advisor' and 'StuID' columns.", "Count the number of students for each advisor: Use COUNT(StuID) to count the number of students associated with each advisor.", "Group the results by advisor: Use GROUP BY Advisor to aggregate the counts for each advisor.", "Order the results to find the advisor with the most students: Use ORDER BY StudentCount DESC to sort the counts in descending order.", "Limit the results to the top advisor: Use LIMIT 1 to get only the advisor with the highest count."], "gold_sql": "SELECT advisor FROM Student GROUP BY advisor ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Advisor, COUNT(StuID) AS StudentCount\nFROM Student\nGROUP BY Advisor\nORDER BY StudentCount DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.504", "db_id": "allergy_1", "question": "How many students are affected by cat allergies?", "rationale": ["Identify the relevant tables: We need to find students with cat allergies, so we will use the Has_Allergy table.", "Determine the necessary columns: We need to count the unique student IDs (StuID) from the Has_Allergy table where the allergy is 'cat'.", "Construct the SQL query: We will use the COUNT function to count distinct StuID values that match the condition for cat allergies."], "gold_sql": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  'Cat'", "source_tables": ["has_allergy"], "pred_sql": "SELECT COUNT(DISTINCT Has_Allergy.StuID) AS affected_students\nFROM Has_Allergy\nWHERE Allergy = 'cat';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\",\n    \"1\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the allergy types to be excluded.\",\n    \"2\": \"This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the WHERE clause represent the gender of the students and the type of allergy they have.\"\n}\n"}
{"sample_id": "train.508", "db_id": "allergy_1", "question": "Which students are unaffected by allergies?", "rationale": ["Identify the main goal: to find students who are unaffected by allergies.", "To determine students without allergies, we need to check the 'Has_Allergy' table for any entries related to each student.", "We can use a subquery to select all 'StuID's from the 'Has_Allergy' table.", "The main query will select the first and last names from the 'Student' table where the 'StuID' is not in the list of 'StuID's from the 'Has_Allergy' table."], "gold_sql": "SELECT StuID FROM Student EXCEPT SELECT StuID FROM Has_allergy", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT Fname, LName \nFROM Student \nWHERE StuID NOT IN (SELECT StuID FROM Has_Allergy)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\",\n    \"1\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the allergy types to be excluded.\",\n    \"2\": \"This virtual table provides the first and last names of students from the 'Student' table who do not have a specific type of allergy. The placeholder in the subquery represents the allergy type that is being filtered out.\"\n}\n"}
{"sample_id": "train.509", "db_id": "allergy_1", "question": "How many female students have milk or egg allergies?", "rationale": ["Identify the tables needed: We need to count female students with specific allergies, so we will use the 'Student' and 'Has_Allergy' tables.", "Determine the criteria: We are looking for female students, so we will filter by 'Sex' = 'Female'.", "Identify the allergies of interest: We need to check for 'Milk' and 'Egg' allergies.", "Join the tables: We will join 'Student' and 'Has_Allergy' on 'StuID' to link students with their allergies.", "Count distinct students: We will use COUNT(DISTINCT Student.StuID) to ensure we count each student only once, even if they have multiple allergies."], "gold_sql": "SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  'F' AND T1.allergy  =  'Milk' OR T1.allergy  =  'Eggs'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT COUNT(DISTINCT Student.StuID) \nFROM Student \nJOIN Has_Allergy ON Student.StuID = Has_Allergy.StuID \nWHERE Student.Sex = 'Female' \nAND Has_Allergy.Allergy IN ('Milk', 'Egg');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\",\n    \"1\": \"This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the WHERE clause represent the gender of the students and the type of allergy they have.\",\n    \"2\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the allergy types to be excluded.\"\n}\n"}
{"sample_id": "train.510", "db_id": "allergy_1", "question": "How many students who are female are allergic to milk or eggs?", "rationale": ["Identify the relevant tables: We need to use the 'Student' table to filter by gender and the 'Has_Allergy' table to check for specific allergies.", "We need to count the number of distinct students who are female and have allergies to either milk or eggs.", "Join the 'Student' table with the 'Has_Allergy' table on the StuID to combine student information with their allergies.", "Filter the results to include only female students by adding a WHERE clause for Student.Sex = 'Female'.", "Add another condition to check if the allergy is either 'Milk' or 'Eggs' using the IN clause.", "Finally, use COUNT(DISTINCT Student.StuID) to get the number of unique female students with the specified allergies."], "gold_sql": "SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  'F' AND T1.allergy  =  'Milk' OR T1.allergy  =  'Eggs'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT COUNT(DISTINCT Student.StuID) \nFROM Student \nJOIN Has_Allergy ON Student.StuID = Has_Allergy.StuID \nWHERE Student.Sex = 'Female' \nAND Has_Allergy.Allergy IN ('Milk', 'Eggs');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\",\n    \"1\": \"This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the WHERE clause represent the gender of the students and the type of allergy they have.\",\n    \"2\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the allergy types to be excluded.\"\n}\n"}
{"sample_id": "train.513", "db_id": "allergy_1", "question": "Which allergy has most number of students affected?", "rationale": ["Identify the relevant tables: We need to find out which allergy has the most number of students affected, so we will focus on the 'Has_Allergy' table which links students to their allergies.", "Count the number of students for each allergy: We will use the COUNT function to count the number of unique 'StuID' entries for each 'Allergy'.", "Group the results by allergy: To get the count of students for each allergy, we will use the GROUP BY clause on the 'Allergy' column.", "Order the results: To find the allergy with the most students, we will order the results in descending order based on the count of students.", "Limit the results to the top entry: Finally, we will limit the results to just one entry to get the allergy with the highest count."], "gold_sql": "SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT 1", "source_tables": ["has_allergy"], "pred_sql": "SELECT Allergy, COUNT(StuID) AS StudentCount\nFROM Has_Allergy\nGROUP BY Allergy\nORDER BY StudentCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\",\n    \"1\": \"This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the WHERE clause represent the gender of the students and the type of allergy they have.\",\n    \"2\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the allergy types to be excluded.\"\n}\n"}
{"sample_id": "train.518", "db_id": "allergy_1", "question": "How many students are affected by each allergy type?", "rationale": ["Identify the tables needed: We need to count students affected by each allergy type, so we will use the 'Allergy_Type', 'Has_Allergy', and 'Student' tables.", "Determine the relationship: The 'Has_Allergy' table links students to their allergies, and the 'Allergy_Type' table categorizes those allergies.", "Join the tables: We will join 'Allergy_Type' and 'Has_Allergy' on the 'Allergy' column to associate each allergy with its type.", "Count distinct students: We need to count the unique students (StuID) for each allergy type, so we will use COUNT(DISTINCT ha.StuID).", "Group by allergy type: To get the count for each allergy type, we will group the results by 'AllergyType' from the 'Allergy_Type' table."], "gold_sql": "SELECT T2.allergytype ,  count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy GROUP BY T2.allergytype", "source_tables": ["has_allergy", "allergy_type"], "pred_sql": "SELECT at.AllergyType, COUNT(DISTINCT ha.StuID) AS StudentCount\nFROM Allergy_Type at\nJOIN Has_Allergy ha ON at.Allergy = ha.Allergy\nGROUP BY at.AllergyType;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\",\n    \"1\": \"This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the WHERE clause represent the gender of the students and the type of allergy they have.\",\n    \"2\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the allergy types to be excluded.\"\n}\n"}
{"sample_id": "train.520", "db_id": "allergy_1", "question": "What are the last names and ages of the students who are allergic to milk and cat?", "rationale": ["Identify the required information: last names and ages of students with specific allergies (milk and cat).", "Determine the relevant tables: 'Student' for student details and 'Has_Allergy' for allergy information.", "Use a subquery to find students who have both allergies. This involves filtering the 'Has_Allergy' table for entries with 'milk' and 'cat'.", "Group the results by 'StuID' and use HAVING to ensure that only students with both allergies are selected (count of distinct allergies should be 2).", "Select the last names and ages from the 'Student' table where the 'StuID' matches those found in the subquery."], "gold_sql": "SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT LName, Age \nFROM Student \nWHERE StuID IN (\n    SELECT StuID \n    FROM Has_Allergy \n    WHERE Allergy IN ('milk', 'cat') \n    GROUP BY StuID \n    HAVING COUNT(DISTINCT Allergy) = 2\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\",\n    \"1\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the allergy types to be excluded.\",\n    \"2\": \"This virtual table provides the first and last names of students from the 'Student' table who do not have a specific type of allergy. The placeholder in the subquery represents the allergy type that is being filtered out.\"\n}\n"}
{"sample_id": "train.522", "db_id": "allergy_1", "question": "What are the allergies the girl named Lisa has? And what are the types of them? Order the result by allergy names.", "rationale": ["Identify the tables needed: We need to get information from the Student, Has_Allergy, and Allergy_Type tables.", "We need to join these tables to get the allergies associated with the student named Lisa.", "Filter the results to only include female students named Lisa.", "Select the Allergy and AllergyType columns from the Allergy_Type table.", "Order the results by the Allergy names."], "gold_sql": "SELECT T1.Allergy ,  T1.AllergyType FROM Allergy_type AS T1 JOIN Has_allergy AS T2 ON T1.Allergy  =  T2.Allergy JOIN Student AS T3 ON T3.StuID  =  T2.StuID WHERE T3.Fname  =  'Lisa' ORDER BY T1.Allergy", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT a.Allergy, a.AllergyType \nFROM Student s \nJOIN Has_Allergy ha ON s.StuID = ha.StuID \nJOIN Allergy_Type a ON ha.Allergy = a.Allergy \nWHERE s.Fname = 'Lisa' AND s.Sex = 'Female' \nORDER BY a.Allergy;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\",\n    \"1\": \"This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the WHERE clause represent the gender of the students and the type of allergy they have.\",\n    \"2\": \"This virtual table provides the first and last names of students from the 'Student' table who do not have a specific type of allergy. The placeholder in the subquery represents the allergy type that is being filtered out.\"\n}\n"}
{"sample_id": "train.525", "db_id": "allergy_1", "question": "Find the average age of the students who have allergies with food and animal types.", "rationale": ["Identify the tables needed: We need to get student ages from the 'Student' table and filter based on allergies from the 'Has_Allergy' and 'Allergy_Type' tables.", "Join the tables: We will join 'Student' with 'Has_Allergy' on 'StuID' and then join 'Has_Allergy' with 'Allergy_Type' on 'Allergy' to access the allergy types.", "Filter by allergy types: We need to filter the results to include only those students who have allergies categorized as 'food' or 'animal'.", "Calculate the average age: We will use the AVG function to calculate the average age of the filtered students, ensuring to cast the age to an integer for accurate calculation."], "gold_sql": "SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food' INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'animal')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT AVG(CAST(S.Age AS INTEGER)) AS Average_Age\nFROM Student S\nJOIN Has_Allergy HA ON S.StuID = HA.StuID\nJOIN Allergy_Type AT ON HA.Allergy = AT.Allergy\nWHERE AT.AllergyType IN ('food', 'animal');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\",\n    \"1\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the allergy types to be excluded.\",\n    \"2\": \"This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the WHERE clause represent the gender of the students and the type of allergy they have.\"\n}\n"}
{"sample_id": "train.527", "db_id": "allergy_1", "question": "List the first and last name of the students who do not have any food type allergy.", "rationale": ["We need to list the first and last names of students who do not have any food type allergy.", "To achieve this, we will select the first name (Fname) and last name (LName) from the Student table.", "We will filter the students based on their StuID, ensuring that we exclude those who have a food allergy.", "To find students with food allergies, we will use a subquery that selects StuID from the Has_Allergy table, joining it with the Allergy_Type table to filter by AllergyType = 'Food'.", "The main query will use a NOT IN clause to exclude any students whose StuID appears in the subquery results."], "gold_sql": "SELECT fname ,  lname FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT Fname, LName \nFROM Student \nWHERE StuID NOT IN (\n    SELECT StuID \n    FROM Has_Allergy \n    JOIN Allergy_Type ON Has_Allergy.Allergy = Allergy_Type.Allergy \n    WHERE AllergyType = 'Food'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of students from the 'Student' table who do not have a specific type of allergy. The placeholder in the subquery represents the allergy type that is being filtered out.\",\n    \"1\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\",\n    \"2\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the allergy types to be excluded.\"\n}\n"}
{"sample_id": "train.529", "db_id": "allergy_1", "question": "Find the number of male (sex is 'M') students who have some food type allery.", "rationale": ["Identify the tables needed: We need to access the 'Student', 'Has_Allergy', and 'Allergy_Type' tables to get the required information about students and their allergies.", "Determine the conditions: We are looking for male students (Sex = 'M') who have a food type allergy. This means we need to filter based on the 'Sex' column in the 'Student' table and the 'AllergyType' column in the 'Allergy_Type' table.", "Join the tables: We need to join 'Student' with 'Has_Allergy' on 'StuID' to link students with their allergies, and then join 'Has_Allergy' with 'Allergy_Type' on 'Allergy' to get the type of allergy.", "Count distinct students: We want to count the number of unique students who meet the criteria, so we will use COUNT(DISTINCT s.StuID) in the SELECT statement."], "gold_sql": "SELECT count(*) FROM Student WHERE sex  =  'M' AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT COUNT(DISTINCT s.StuID) \nFROM Student s \nJOIN Has_Allergy ha ON s.StuID = ha.StuID \nJOIN Allergy_Type at ON ha.Allergy = at.Allergy \nWHERE s.Sex = 'M' AND at.AllergyType = 'Food';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the WHERE clause represent the gender of the students and the type of allergy they have.\",\n    \"1\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\",\n    \"2\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the allergy types to be excluded.\"\n}\n"}
{"sample_id": "train.531", "db_id": "allergy_1", "question": "Find the different first names and cities of the students who have allergy to milk or cat.", "rationale": ["Identify the tables needed: We need information from the 'Student' table for first names and city codes, and from the 'Has_Allergy' table to filter students with specific allergies.", "Determine the relationship: The 'Has_Allergy' table links students to their allergies via the 'StuID' column, which is common in both 'Student' and 'Has_Allergy'.", "Use a JOIN operation: We will join the 'Student' table with the 'Has_Allergy' table on 'StuID' to get the relevant student information for those with allergies.", "Filter the results: We need to filter the results to include only those students who have allergies to either 'milk' or 'cat'.", "Select distinct values: Since we want different first names and cities, we will use DISTINCT to avoid duplicate entries in the results."], "gold_sql": "SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  'Milk' OR T2.Allergy  =  'Cat'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT DISTINCT S.Fname, S.city_code \nFROM Student S \nJOIN Has_Allergy HA ON S.StuID = HA.StuID \nWHERE HA.Allergy IN ('milk', 'cat');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\",\n    \"1\": \"This virtual table provides the first and last names of students from the 'Student' table who do not have a specific type of allergy. The placeholder in the subquery represents the allergy type that is being filtered out.\",\n    \"2\": \"This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the WHERE clause represent the gender of the students and the type of allergy they have.\"\n}\n"}
{"sample_id": "train.533", "db_id": "allergy_1", "question": "Find the number of students who are older than 18 and do not have allergy to either food or animal.", "rationale": ["Identify the main requirement: count students older than 18 without food or animal allergies.", "Use the Student table to filter students based on age.", "Use the Has_Allergy table to find students with specific allergies.", "Create a subquery to select students with food or animal allergies.", "Use NOT IN to exclude these students from the main count query."], "gold_sql": "SELECT count(*) FROM Student WHERE age  >  18 AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food' OR T2.allergytype  =  'animal')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT COUNT(*) \nFROM Student s \nWHERE s.Age > 18 \nAND s.StuID NOT IN (\n    SELECT ha.StuID \n    FROM Has_Allergy ha \n    WHERE ha.Allergy IN (\n        SELECT at.Allergy \n        FROM Allergy_Type at \n        WHERE at.AllergyType IN ('food', 'animal')\n    )\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the allergy types to be excluded.\",\n    \"1\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\",\n    \"2\": \"This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the WHERE clause represent the gender of the students and the type of allergy they have.\"\n}\n"}
{"sample_id": "train.535", "db_id": "allergy_1", "question": "Find the first name and major of the students who are not allegry to soy.", "rationale": ["Identify the columns needed: first name (Fname) and major (Major) from the Student table.", "Determine the condition: we want students who do not have an allergy to soy.", "To find students without a soy allergy, we can use a subquery to select all StuID from the Has_Allergy table where the Allergy is 'soy'.", "Use the NOT IN clause to filter out those students from the main query that selects from the Student table."], "gold_sql": "SELECT fname ,  major FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Soy')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT Fname, Major FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_Allergy WHERE Allergy = 'soy');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of students from the 'Student' table who do not have a specific type of allergy. The placeholder in the subquery represents the allergy type that is being filtered out.\",\n    \"1\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\",\n    \"2\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the allergy types to be excluded.\"\n}\n"}
{"sample_id": "train.542", "db_id": "store_1", "question": "What are the names of the countries and average invoice size of the top countries by size?", "rationale": ["Identify the relevant table: invoices, which contains billing information and total amounts.", "Select the columns needed: billing_country for the country names and AVG(total) for the average invoice size.", "Group the results by billing_country to calculate the average for each country.", "Order the results by average_invoice_size in descending order to get the top countries by size."], "gold_sql": "SELECT billing_country ,  AVG(total) FROM invoices GROUP BY billing_country ORDER BY AVG(total) DESC LIMIT 10;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_country, AVG(total) AS average_invoice_size\nFROM invoices\nGROUP BY billing_country\nORDER BY average_invoice_size DESC;", "hint": "\n"}
{"sample_id": "train.553", "db_id": "store_1", "question": "List every album ordered by album title in ascending order.", "rationale": ["Identify the table that contains album information, which is the 'albums' table.", "Determine the column that holds the album titles, which is 'title'.", "Specify that we want to select the 'title' column from the 'albums' table.", "Add an ORDER BY clause to sort the results by 'title' in ascending order."], "gold_sql": "SELECT title FROM albums ORDER BY title;", "source_tables": ["albums"], "pred_sql": "SELECT title FROM albums ORDER BY title ASC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of tracks from the 'tracks' table that have been purchased by customers with a specific first and last name. The placeholders in the WHERE clause represent the customer's first and last names.\",\n    \"1\": \"This virtual table describes the names of tracks from the 'tracks' table that belong to a specific genre and media type. The placeholders in the WHERE clause represent the genre's name and the media type's name.\"\n}\n"}
{"sample_id": "train.560", "db_id": "store_1", "question": "What are the total amount of money in the invoices billed from Chicago, Illinois?", "rationale": ["Identify the relevant table: invoices, as it contains billing information and total amounts.", "Determine the columns needed: total for the amount and billing_city, billing_state for filtering.", "Construct the SQL query to sum the total amounts from invoices where the billing city is 'Chicago' and the billing state is 'Illinois'."], "gold_sql": "SELECT sum(total) FROM invoices WHERE billing_city  =  'Chicago' AND billing_state  =  'IL';", "source_tables": ["invoices"], "pred_sql": "SELECT SUM(total) AS total_amount FROM invoices WHERE billing_city = 'Chicago' AND billing_state = 'Illinois';", "hint": "\n"}
{"sample_id": "train.564", "db_id": "store_1", "question": "How many invoices were billed from each state?", "rationale": ["Identify the relevant table: The invoices table contains the billing information including the state.", "Determine the required fields: We need the billing_state and a count of invoices for each state.", "Use the COUNT() function to count the number of invoices for each state.", "Group the results by billing_state to get the count for each state."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_state, COUNT(*) AS invoice_count\nFROM invoices\nGROUP BY billing_state;", "hint": "\n"}
{"sample_id": "train.565", "db_id": "store_1", "question": "List the state in the US with the most invoices.", "rationale": ["We need to find the state in the US with the most invoices.", "The relevant table for invoices is the 'invoices' table, which contains a column 'billing_state'.", "To count the number of invoices per state, we will use the COUNT() function and group the results by 'billing_state'.", "We will order the results in descending order based on the count of invoices to get the state with the most invoices at the top.", "Finally, we will limit the results to 1 to get only the state with the highest count."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT 1;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_state, COUNT(*) as invoice_count\nFROM invoices\nGROUP BY billing_state\nORDER BY invoice_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.566", "db_id": "store_1", "question": "What are the states with the most invoices?", "rationale": ["Identify the relevant table: The 'invoices' table contains the 'billing_state' column and is where invoices are recorded.", "Count the number of invoices per state: Use the COUNT() function to count the number of invoices for each state.", "Group the results by state: Use GROUP BY to aggregate the results based on 'billing_state'.", "Order the results: Use ORDER BY to sort the results in descending order based on the count of invoices, so that states with the most invoices appear first."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT 1;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_state, COUNT(*) AS invoice_count\nFROM invoices\nGROUP BY billing_state\nORDER BY invoice_count DESC;", "hint": "\n"}
{"sample_id": "train.567", "db_id": "store_1", "question": "List the number of invoices and the invoice total from California.", "rationale": ["We need to count the number of invoices and sum the total from invoices issued to customers in California.", "The relevant tables are 'invoices' and 'customers'.", "We will join the 'invoices' table with the 'customers' table on the customer ID to filter by state.", "We will use the COUNT() function to get the number of invoices and the SUM() function to get the total invoice amount.", "The WHERE clause will filter the results to only include customers from California."], "gold_sql": "SELECT billing_state ,  COUNT(*) ,  SUM(total) FROM invoices WHERE billing_state  =  'CA';", "source_tables": ["invoices"], "pred_sql": "SELECT COUNT(*) AS number_of_invoices, SUM(total) AS invoice_total\nFROM invoices\nJOIN customers ON invoices.customer_id = customers.id\nWHERE customers.state = 'California';", "hint": "\n"}
{"sample_id": "train.575", "db_id": "store_1", "question": "What is Astrid Gruber's email and phone number?", "rationale": ["Identify the table that contains employee information, which is the 'employees' table.", "Determine the columns needed for the output, which are 'email' and 'phone'.", "Filter the results to find the specific employee by their first name 'Astrid' and last name 'Gruber'.", "Construct the SQL SELECT statement to retrieve the desired columns from the 'employees' table with the appropriate WHERE clause."], "gold_sql": "SELECT email ,  phone FROM customers WHERE first_name = 'Astrid' AND last_name = 'Gruber';", "source_tables": ["customers"], "pred_sql": "SELECT email, phone FROM employees WHERE first_name = 'Astrid' AND last_name = 'Gruber';", "hint": "\n"}
{"sample_id": "train.593", "db_id": "store_1", "question": "Find the full name of employee who supported the most number of customers.", "rationale": ["Identify the relevant tables: employees and customers.", "We need to find the employee who supported the most customers, which means we need to join the employees table with the customers table on the support_rep_id.", "We will group the results by employee ID to count the number of customers each employee supports.", "We will order the results by the count of customers in descending order to get the employee with the most customers at the top.", "Finally, we will limit the results to 1 to get only the top employee.", "Select the full name of the employee by concatenating first_name and last_name."], "gold_sql": "SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employees", "customers"], "pred_sql": "SELECT e.first_name || ' ' || e.last_name AS full_name\nFROM employees e\nJOIN customers c ON e.id = c.support_rep_id\nGROUP BY e.id\nORDER BY COUNT(c.id) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.594", "db_id": "store_1", "question": "What is the full name of the employee who has the most customers?", "rationale": ["Identify the relevant tables: employees and customers.", "We need to find the employee who has the most customers, so we will join the employees table with the customers table on the support_rep_id.", "We will group the results by employee ID to count the number of customers each employee has.", "We will order the results in descending order based on the count of customers to find the employee with the most customers.", "Finally, we will limit the results to 1 to get only the top employee.", "We will select the full name of the employee by concatenating first_name and last_name."], "gold_sql": "SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employees", "customers"], "pred_sql": "SELECT e.first_name || ' ' || e.last_name AS full_name\nFROM employees e\nJOIN customers c ON e.id = c.support_rep_id\nGROUP BY e.id\nORDER BY COUNT(c.id) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.604", "db_id": "store_1", "question": "How many employees who are IT staff are from each city?", "rationale": ["Identify the relevant table: The 'employees' table contains information about employees, including their job titles and cities.", "Determine the criteria: We need to filter employees who are in the IT staff, which can be identified by checking if the 'title' column contains 'IT'.", "Count the number of employees: We will use the COUNT() function to count the number of employees that meet the criteria.", "Group the results: We will group the results by 'city' to get the count of IT staff from each city."], "gold_sql": "SELECT count(*) ,  city FROM employees WHERE title  =  'IT Staff' GROUP BY city", "source_tables": ["employees"], "pred_sql": "SELECT city, COUNT(*) AS employee_count \nFROM employees \nWHERE title LIKE '%IT%' \nGROUP BY city;", "hint": "\n"}
{"sample_id": "train.624", "db_id": "store_1", "question": "What is the name of the album that has the track Ball to the Wall?", "rationale": ["Identify the relevant tables: We need to find the album title, which is in the 'albums' table, and we need to link it to the 'tracks' table to find the specific track.", "Determine the relationship: The 'tracks' table has a foreign key 'album_id' that links to the 'albums' table's 'id'.", "Formulate the SQL query: We will select the album title from the 'albums' table and join it with the 'tracks' table on the album_id. We will filter the results where the track name is 'Ball to the Wall'."], "gold_sql": "SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T2.name = 'Balls to the Wall';", "source_tables": ["albums", "tracks"], "pred_sql": "SELECT albums.title \nFROM albums \nJOIN tracks ON albums.id = tracks.album_id \nWHERE tracks.name = 'Ball to the Wall';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of tracks from the 'tracks' table that have been purchased by customers with a specific first and last name. The placeholders in the WHERE clause represent the customer's first and last names.\",\n    \"1\": \"This virtual table describes the names of tracks from the 'tracks' table that belong to a specific genre and media type. The placeholders in the WHERE clause represent the genre's name and the media type's name.\"\n}\n"}
{"sample_id": "train.632", "db_id": "store_1", "question": "What are the names of all tracks that belong to the Rock genre and whose media type is MPEG?", "rationale": ["Identify the relevant tables: 'tracks', 'genres', and 'media_types'.", "Determine the relationships: 'tracks' has foreign keys to 'genres' (genre_id) and 'media_types' (media_type_id).", "Select the track names from the 'tracks' table.", "Join the 'tracks' table with the 'genres' table on the genre_id to filter by genre name.", "Join the 'tracks' table with the 'media_types' table on the media_type_id to filter by media type name.", "Apply the WHERE clause to filter tracks that belong to the 'Rock' genre and have the media type 'MPEG'."], "gold_sql": "SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = 'Rock' OR T3.name = 'MPEG audio file';", "source_tables": ["tracks", "genres", "media_types"], "pred_sql": "SELECT tracks.name \nFROM tracks \nJOIN genres ON tracks.genre_id = genres.id \nJOIN media_types ON tracks.media_type_id = media_types.id \nWHERE genres.name = 'Rock' AND media_types.name = 'MPEG';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of tracks from the 'tracks' table that belong to a specific genre and media type. The placeholders in the WHERE clause represent the genre's name and the media type's name.\",\n    \"1\": \"This virtual table describes the names of tracks from the 'tracks' table that have been purchased by customers with a specific first and last name. The placeholders in the WHERE clause represent the customer's first and last names.\"\n}\n"}
{"sample_id": "train.946", "db_id": "medicine_enzyme_interaction", "question": "What are the names and trade names of the medcines that are FDA approved?", "rationale": ["Identify the relevant table: The 'medicine' table contains the information about medicines.", "Determine the required columns: We need the 'name' and 'Trade_Name' columns from the 'medicine' table.", "Specify the condition: We only want medicines that are FDA approved, which is indicated by the 'FDA_approved' column being equal to 'yes'.", "Construct the SQL query: Use a SELECT statement to retrieve the specified columns from the 'medicine' table with the appropriate WHERE clause."], "gold_sql": "SELECT name ,  trade_name FROM medicine WHERE FDA_approved  =  'Yes'", "source_tables": ["medicine"], "pred_sql": "SELECT name, Trade_Name FROM medicine WHERE FDA_approved = 'yes';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names and trade names of medicines from the 'medicine' table that do not interact with a specific enzyme product. The placeholder in the EXCEPT clause represents the product associated with the enzyme.\"\n}\n"}
{"sample_id": "train.951", "db_id": "medicine_enzyme_interaction", "question": "What are the ids, names and FDA approval status of medicines in descending order of the number of enzymes that it can interact with.", "rationale": ["Identify the relevant tables: medicine and medicine_enzyme_interaction.", "We need to select the id, name, and FDA approval status from the medicine table.", "To find the number of enzymes each medicine interacts with, we will join the medicine table with the medicine_enzyme_interaction table on the medicine_id.", "We will group the results by the medicine's id, name, and FDA approval status to aggregate the count of enzyme interactions.", "Finally, we will order the results in descending order based on the count of enzyme interactions."], "gold_sql": "SELECT T1.id ,  T1.Name ,  T1.FDA_approved FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id GROUP BY T1.id ORDER BY count(*) DESC", "source_tables": ["medicine", "medicine_enzyme_interaction"], "pred_sql": "SELECT m.id, m.name, m.FDA_approved\nFROM medicine m\nJOIN medicine_enzyme_interaction mei ON m.id = mei.medicine_id\nGROUP BY m.id, m.name, m.FDA_approved\nORDER BY COUNT(mei.enzyme_id) DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names and trade names of medicines from the 'medicine' table that do not interact with a specific enzyme product. The placeholder in the EXCEPT clause represents the product associated with the enzyme.\"\n}\n"}
{"sample_id": "train.953", "db_id": "medicine_enzyme_interaction", "question": "What is the id and name of the enzyme with most number of medicines that can interact as 'activator'?", "rationale": ["Identify the relevant tables: We need to use the 'enzyme' and 'medicine_enzyme_interaction' tables to find the enzyme that interacts with the most medicines as 'activator'.", "Join the 'enzyme' table with the 'medicine_enzyme_interaction' table on the enzyme ID to link enzymes with their interactions.", "Filter the results to only include interactions where the interaction type is 'activator'.", "Group the results by enzyme ID and name to count the number of medicines that interact with each enzyme as an activator.", "Order the results in descending order based on the count of interacting medicines to find the enzyme with the most interactions.", "Limit the results to 1 to get only the enzyme with the highest count."], "gold_sql": "SELECT T1.id ,  T1.name FROM enzyme AS T1 JOIN medicine_enzyme_interaction AS T2 ON T1.id  =  T2.enzyme_id WHERE T2.interaction_type  =  'activitor' GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["enzyme", "medicine_enzyme_interaction"], "pred_sql": "SELECT e.id, e.name\nFROM enzyme e\nJOIN medicine_enzyme_interaction mei ON e.id = mei.enzyme_id\nWHERE mei.interaction_type = 'activator'\nGROUP BY e.id, e.name\nORDER BY COUNT(mei.medicine_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names and trade names of medicines from the 'medicine' table that do not interact with a specific enzyme product. The placeholder in the EXCEPT clause represents the product associated with the enzyme.\"\n}\n"}
{"sample_id": "train.968", "db_id": "medicine_enzyme_interaction", "question": "What are the medicine and trade names that can interact as an inhibitor and activitor with enzymes?", "rationale": ["Identify the relevant tables: medicine, enzyme, and medicine_enzyme_interaction.", "We need to select the medicine names and trade names, which are in the medicine table.", "Join the medicine table with the medicine_enzyme_interaction table on the medicine_id to get the interactions.", "Join the enzyme table to get the enzyme details, although we are primarily interested in the interaction types.", "Filter the results to include only those interactions that are either 'inhibitor' or 'activator'.", "Group the results by medicine id, name, and trade name to avoid duplicates."], "gold_sql": "SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id WHERE interaction_type  =  'inhibitor' INTERSECT SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id WHERE interaction_type  =  'activitor'", "source_tables": ["medicine", "medicine_enzyme_interaction"], "pred_sql": "SELECT m.name, m.Trade_Name \nFROM medicine m \nJOIN medicine_enzyme_interaction mei ON m.id = mei.medicine_id \nJOIN enzyme e ON mei.enzyme_id = e.id \nWHERE mei.interaction_type IN ('inhibitor', 'activator') \nGROUP BY m.id, m.name, m.Trade_Name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names and trade names of medicines from the 'medicine' table that do not interact with a specific enzyme product. The placeholder in the EXCEPT clause represents the product associated with the enzyme.\"\n}\n"}
{"sample_id": "train.970", "db_id": "medicine_enzyme_interaction", "question": "What are the medicine and trade names that cannot interact with the enzyme with the product 'Heme'?", "rationale": ["Identify the columns needed: medicine name and trade name from the 'medicine' table.", "Use the EXCEPT clause to find medicines that do not interact with a specific enzyme product.", "Join the 'medicine' table with 'medicine_enzyme_interaction' to find medicines that interact with enzymes.", "Join the 'enzyme' table to filter by the specific product 'Heme'.", "Construct the SQL query to select the required columns and apply the necessary joins and conditions."], "gold_sql": "SELECT name ,  trade_name FROM medicine EXCEPT SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id JOIN enzyme AS T3 ON T3.id  =  T2.enzyme_id WHERE T3.product  =  'Protoporphyrinogen IX'", "source_tables": ["enzyme", "medicine", "medicine_enzyme_interaction"], "pred_sql": "SELECT name, Trade_Name FROM medicine\nEXCEPT\nSELECT m.name, m.Trade_Name\nFROM medicine m\nJOIN medicine_enzyme_interaction mei ON m.id = mei.medicine_id\nJOIN enzyme e ON mei.enzyme_id = e.id\nWHERE e.Product = 'Heme';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names and trade names of medicines from the 'medicine' table that do not interact with a specific enzyme product. The placeholder in the EXCEPT clause represents the product associated with the enzyme.\"\n}\n"}
{"sample_id": "train.1355", "db_id": "college_2", "question": "What is the name of the department with an instructure who has a name like 'Soisalon'?", "rationale": ["Identify the main requirement: We need to find the name of the department associated with an instructor whose name is like 'Soisalon'.", "The relevant tables are 'department' and 'instructor'.", "We need to join these tables based on the 'dept_name' column, which is common to both tables.", "We will filter the 'instructor' table to find instructors with names matching 'Soisalon'.", "Finally, we will select the 'dept_name' from the 'department' table where the department matches the filtered instructors."], "gold_sql": "SELECT dept_name FROM instructor WHERE name LIKE '%Soisalon%'", "source_tables": ["instructor"], "pred_sql": "SELECT dept_name FROM department WHERE dept_name IN (SELECT dept_name FROM instructor WHERE name LIKE 'Soisalon');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of distinct students and instructors associated with each academic department. It joins the 'department', 'student', and 'instructor' tables based on the department name, and groups the results by department name to provide a count of unique students and instructors for each department.\",\n    \"1\": \"This virtual table summarizes the number of distinct students and instructors associated with each academic department. It joins the 'department', 'student', and 'instructor' tables based on the department name, and groups the results by department name to provide a count of unique students and instructors for each department.\",\n    \"2\": \"This virtual table lists the names of students who are not enrolled in any courses offered by a specific department. The placeholder in the subquery represents the department's name.\"\n}\n"}
{"sample_id": "train.1365", "db_id": "college_2", "question": "What are the titles of courses that are in the Statistics department but not the Psychology department?", "rationale": ["Identify the courses offered by the Statistics department by filtering the 'course' table for 'dept_name' = 'Statistics'.", "To find courses that are not in the Psychology department, we need to exclude those courses from our results. This can be done using a subquery that selects 'course_id' from the 'course' table where 'dept_name' = 'Psychology'.", "Combine the two conditions using an AND clause to ensure we only get courses from the Statistics department that are not also in the Psychology department."], "gold_sql": "SELECT title FROM course WHERE dept_name  =  'Statistics' EXCEPT SELECT title FROM course WHERE dept_name  =  'Psychology'", "source_tables": ["course"], "pred_sql": "SELECT title FROM course WHERE dept_name = 'Statistics' AND course_id NOT IN (SELECT course_id FROM course WHERE dept_name = 'Psychology');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of students who are not enrolled in any courses offered by a specific department. The placeholder in the subquery represents the department's name.\",\n    \"1\": \"This virtual table summarizes the number of distinct students and instructors associated with each academic department. It joins the 'department', 'student', and 'instructor' tables based on the department name, and groups the results by department name to provide a count of unique students and instructors for each department.\",\n    \"2\": \"This virtual table summarizes the number of distinct students and instructors associated with each academic department. It joins the 'department', 'student', and 'instructor' tables based on the department name, and groups the results by department name to provide a count of unique students and instructors for each department.\"\n}\n"}
{"sample_id": "train.1424", "db_id": "college_2", "question": "Find the title of course whose prerequisite is course Differential Geometry.", "rationale": ["Identify the table that contains course titles, which is the 'course' table.", "Identify the table that contains prerequisites, which is the 'prereq' table.", "To find the course title whose prerequisite is 'Differential Geometry', we need to join the 'course' table with the 'prereq' table on the course_id.", "We need to filter the results to only include those courses that have 'Differential Geometry' as a prerequisite.", "To do this, we can use a subquery to find the course_id of 'Differential Geometry' and use it in the WHERE clause."], "gold_sql": "SELECT title FROM course WHERE course_id IN (SELECT T1.course_id FROM prereq AS T1 JOIN course AS T2 ON T1.prereq_id  =  T2.course_id WHERE T2.title  =  'Differential Geometry')", "source_tables": ["course", "prereq"], "pred_sql": "SELECT c.title \nFROM course c \nJOIN prereq p ON c.course_id = p.course_id \nWHERE p.prereq_id = (SELECT course_id FROM course WHERE title = 'Differential Geometry');", "hint": "\n"}
{"sample_id": "train.1426", "db_id": "college_2", "question": "Find the names of students who have taken any course in the fall semester of year 2003.", "rationale": ["We need to find the names of students who have taken any course in the fall semester of year 2003.", "To do this, we will join the 'student' table with the 'takes' table on the student ID.", "Next, we will join the 'takes' table with the 'section' table to access the semester and year information for the courses taken by the students.", "We will filter the results to include only those records where the semester is 'Fall' and the year is '2003'.", "Finally, we will select the distinct names of the students from the resulting dataset."], "gold_sql": "SELECT name FROM student WHERE id IN (SELECT id FROM takes WHERE semester  =  'Fall' AND YEAR  =  2003)", "source_tables": ["student", "takes"], "pred_sql": "SELECT DISTINCT student.name \nFROM student \nJOIN takes ON student.ID = takes.ID \nJOIN section ON takes.course_id = section.course_id AND takes.sec_id = section.sec_id \nWHERE section.semester = 'Fall' AND section.year = '2003';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of students who are not enrolled in any courses offered by a specific department. The placeholder in the subquery represents the department's name.\",\n    \"1\": \"This virtual table lists the names of instructors who are advisors to students, ordered by the total credits earned by the students in descending order. The placeholder in the LIMIT clause represents the maximum number of instructor names to be returned.\"\n}\n"}
{"sample_id": "train.1435", "db_id": "college_2", "question": "What are the names of all instructors who advise students in the math depart sorted by total credits of the student.", "rationale": ["Identify the tables involved: instructor, advisor, and student.", "We need to find instructors who advise students, so we will join the instructor table with the advisor table on the instructor ID.", "Next, we join the advisor table with the student table on the student ID to get the students being advised.", "We need to filter the results to only include students from the math department, so we add a WHERE clause for student.dept_name.", "Finally, we want to sort the results by the total credits earned by the students in descending order, so we use ORDER BY student.tot_cred DESC."], "gold_sql": "SELECT T2.name FROM advisor AS T1 JOIN instructor AS T2 ON T1.i_id  =  T2.id JOIN student AS T3 ON T1.s_id  =  T3.id WHERE T3.dept_name  =  'Math' ORDER BY T3.tot_cred", "source_tables": ["instructor", "student", "advisor"], "pred_sql": "SELECT instructor.name \nFROM instructor \nJOIN advisor ON instructor.ID = advisor.i_ID \nJOIN student ON advisor.s_ID = student.ID \nWHERE student.dept_name = 'math' \nORDER BY student.tot_cred DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of instructors who are advisors to students, ordered by the total credits earned by the students in descending order. The placeholder in the LIMIT clause represents the maximum number of instructor names to be returned.\",\n    \"1\": \"This virtual table summarizes the number of distinct students and instructors associated with each academic department. It joins the 'department', 'student', and 'instructor' tables based on the department name, and groups the results by department name to provide a count of unique students and instructors for each department.\",\n    \"2\": \"This virtual table summarizes the number of distinct students and instructors associated with each academic department. It joins the 'department', 'student', and 'instructor' tables based on the department name, and groups the results by department name to provide a count of unique students and instructors for each department.\"\n}\n"}
{"sample_id": "train.1436", "db_id": "college_2", "question": "What is the course title of the prerequisite of course Mobile Computing?", "rationale": ["Identify the course title of the prerequisite for 'Mobile Computing'.", "First, find the course_id for 'Mobile Computing' from the course table.", "Next, use the prereq table to find the prerequisite course_id associated with 'Mobile Computing'.", "Finally, join the course table again to get the title of the course that corresponds to the prerequisite course_id."], "gold_sql": "SELECT title FROM course WHERE course_id IN (SELECT T1.prereq_id FROM prereq AS T1 JOIN course AS T2 ON T1.course_id  =  T2.course_id WHERE T2.title  =  'Mobile Computing')", "source_tables": ["course", "prereq"], "pred_sql": "SELECT c.title \nFROM course c \nJOIN prereq p ON c.course_id = p.prereq_id \nWHERE p.course_id = (SELECT course_id FROM course WHERE title = 'Mobile Computing');", "hint": "\n"}
{"sample_id": "train.1439", "db_id": "college_2", "question": "What is the name of the instructor who advises the student with the greatest number of total credits?", "rationale": ["Identify the tables involved: instructor, advisor, and student.", "We need to find the instructor who advises a specific student, so we will join the instructor and advisor tables on the instructor ID.", "Next, we will join the advisor table with the student table to link the advisor to the student.", "To find the student with the greatest number of total credits, we will use a subquery that selects the maximum total credits from the student table.", "Finally, we will select the name of the instructor who advises that student."], "gold_sql": "SELECT T2.name FROM advisor AS T1 JOIN instructor AS T2 ON T1.i_id  =  T2.id JOIN student AS T3 ON T1.s_id  =  T3.id ORDER BY T3.tot_cred DESC LIMIT 1", "source_tables": ["instructor", "student", "advisor"], "pred_sql": "SELECT i.name \nFROM instructor i \nJOIN advisor a ON i.ID = a.i_ID \nJOIN student s ON a.s_ID = s.ID \nWHERE s.tot_cred = (SELECT MAX(tot_cred) FROM student)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of instructors who are advisors to students, ordered by the total credits earned by the students in descending order. The placeholder in the LIMIT clause represents the maximum number of instructor names to be returned.\",\n    \"1\": \"This virtual table summarizes the number of distinct students and instructors associated with each academic department. It joins the 'department', 'student', and 'instructor' tables based on the department name, and groups the results by department name to provide a count of unique students and instructors for each department.\"\n}\n"}
{"sample_id": "train.1448", "db_id": "college_2", "question": "Find the number and averaged salary of all instructors who are in the department with the highest budget.", "rationale": ["Identify the department with the highest budget by selecting the 'dept_name' from the 'department' table and ordering by 'budget' in descending order, limiting the result to 1.", "Use the result from the previous step to filter the 'instructor' table, selecting the count of distinct instructor IDs and the average salary of instructors in that department.", "The final SQL query combines these elements to provide the required count and average salary of instructors in the department with the highest budget."], "gold_sql": "SELECT avg(T1.salary) ,  count(*) FROM instructor AS T1 JOIN department AS T2 ON T1.dept_name  =  T2.dept_name ORDER BY T2.budget DESC LIMIT 1", "source_tables": ["instructor", "department"], "pred_sql": "SELECT COUNT(ID) AS instructor_count, AVG(salary) AS average_salary\nFROM instructor\nWHERE dept_name = (SELECT dept_name FROM department ORDER BY budget DESC LIMIT 1);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of distinct students and instructors associated with each academic department. It joins the 'department', 'student', and 'instructor' tables based on the department name, and groups the results by department name to provide a count of unique students and instructors for each department.\",\n    \"1\": \"This virtual table summarizes the number of distinct students and instructors associated with each academic department. It joins the 'department', 'student', and 'instructor' tables based on the department name, and groups the results by department name to provide a count of unique students and instructors for each department.\",\n    \"2\": \"This virtual table lists the names of instructors who are advisors to students, ordered by the total credits earned by the students in descending order. The placeholder in the LIMIT clause represents the maximum number of instructor names to be returned.\"\n}\n"}
{"sample_id": "train.1449", "db_id": "college_2", "question": "How many instructors are in the department with the highest budget, and what is their average salary?", "rationale": ["Identify the department with the highest budget by using a subquery to select the maximum budget from the department table.", "Join the instructor table with the department table on the department name to filter instructors belonging to the department with the highest budget.", "Count the number of instructors in that department using COUNT(i.ID).", "Calculate the average salary of those instructors using AVG(i.salary).", "Select both the count of instructors and the average salary in the final output."], "gold_sql": "SELECT avg(T1.salary) ,  count(*) FROM instructor AS T1 JOIN department AS T2 ON T1.dept_name  =  T2.dept_name ORDER BY T2.budget DESC LIMIT 1", "source_tables": ["instructor", "department"], "pred_sql": "SELECT COUNT(i.ID) AS instructor_count, AVG(i.salary) AS average_salary\nFROM instructor i\nJOIN department d ON i.dept_name = d.dept_name\nWHERE d.budget = (SELECT MAX(budget) FROM department);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of distinct students and instructors associated with each academic department. It joins the 'department', 'student', and 'instructor' tables based on the department name, and groups the results by department name to provide a count of unique students and instructors for each department.\",\n    \"1\": \"This virtual table summarizes the number of distinct students and instructors associated with each academic department. It joins the 'department', 'student', and 'instructor' tables based on the department name, and groups the results by department name to provide a count of unique students and instructors for each department.\",\n    \"2\": \"This virtual table lists the names of instructors who are advisors to students, ordered by the total credits earned by the students in descending order. The placeholder in the LIMIT clause represents the maximum number of instructor names to be returned.\"\n}\n"}
{"sample_id": "train.1452", "db_id": "college_2", "question": "Find the name of students who didn't take any course from Biology department.", "rationale": ["Identify the students from the 'student' table.", "We need to find students who are not enrolled in any courses from the Biology department.", "To do this, we will use a subquery to find all course IDs from the 'course' table where the department name is 'Biology'.", "Next, we will check the 'takes' table to see if any of these course IDs are associated with the students.", "The main query will select the names of students whose IDs do not match any IDs in the 'takes' table for the Biology courses."], "gold_sql": "SELECT name FROM student WHERE id NOT IN (SELECT T1.id FROM takes AS T1 JOIN course AS T2 ON T1.course_id  =  T2.course_id WHERE T2.dept_name  =  'Biology')", "source_tables": ["course", "student", "takes"], "pred_sql": "SELECT name \nFROM student \nWHERE dept_name NOT IN (SELECT dept_name \n                      FROM course \n                      WHERE dept_name = 'Biology' \n                      AND course_id IN (SELECT course_id \n                                       FROM takes \n                                       WHERE ID = student.ID));", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of students who are not enrolled in any courses offered by a specific department. The placeholder in the subquery represents the department's name.\",\n    \"1\": \"This virtual table summarizes the number of distinct students and instructors associated with each academic department. It joins the 'department', 'student', and 'instructor' tables based on the department name, and groups the results by department name to provide a count of unique students and instructors for each department.\",\n    \"2\": \"This virtual table summarizes the number of distinct students and instructors associated with each academic department. It joins the 'department', 'student', and 'instructor' tables based on the department name, and groups the results by department name to provide a count of unique students and instructors for each department.\"\n}\n"}
{"sample_id": "train.1458", "db_id": "college_2", "question": "Find the name and salary of instructors whose salary is below the average salary of the instructors in the Physics department.", "rationale": ["Identify the relevant tables: We need the 'instructor' table for instructor details and salary.", "Determine the condition: We want instructors whose salary is below the average salary of those in the Physics department.", "Calculate the average salary: Use a subquery to calculate the average salary of instructors in the Physics department.", "Construct the main query: Select the name and salary of instructors where their salary is less than the average calculated in the subquery."], "gold_sql": "SELECT name ,  salary FROM instructor WHERE salary  <  (SELECT avg(salary) FROM instructor WHERE dept_name  =  'Physics')", "source_tables": ["instructor"], "pred_sql": "SELECT name, salary FROM instructor WHERE salary < (SELECT AVG(salary) FROM instructor WHERE dept_name = 'Physics');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of instructors who are advisors to students, ordered by the total credits earned by the students in descending order. The placeholder in the LIMIT clause represents the maximum number of instructor names to be returned.\",\n    \"1\": \"This virtual table summarizes the number of distinct students and instructors associated with each academic department. It joins the 'department', 'student', and 'instructor' tables based on the department name, and groups the results by department name to provide a count of unique students and instructors for each department.\",\n    \"2\": \"This virtual table summarizes the number of distinct students and instructors associated with each academic department. It joins the 'department', 'student', and 'instructor' tables based on the department name, and groups the results by department name to provide a count of unique students and instructors for each department.\"\n}\n"}
{"sample_id": "train.1461", "db_id": "college_2", "question": "What are the names of students who have taken Statistics courses?", "rationale": ["Identify the relevant tables: We need to find student names and their course enrollments, so we will use the 'student' and 'takes' tables, along with the 'course' table to filter for Statistics courses.", "Join the 'student' table with the 'takes' table on the student ID to get the courses they have taken.", "Join the resulting table with the 'course' table on the course ID to access course titles.", "Filter the results to only include courses where the title is 'Statistics'.", "Select the names of the students from the final result."], "gold_sql": "SELECT T3.name FROM course AS T1 JOIN takes AS T2 ON T1.course_id  =  T2.course_id JOIN student AS T3 ON T2.id  =  T3.id WHERE T1.dept_name  =  'Statistics'", "source_tables": ["course", "student", "takes"], "pred_sql": "SELECT student.name \nFROM student \nJOIN takes ON student.ID = takes.ID \nJOIN course ON takes.course_id = course.course_id \nWHERE course.title = 'Statistics';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of students who are not enrolled in any courses offered by a specific department. The placeholder in the subquery represents the department's name.\",\n    \"1\": \"This virtual table summarizes the number of distinct students and instructors associated with each academic department. It joins the 'department', 'student', and 'instructor' tables based on the department name, and groups the results by department name to provide a count of unique students and instructors for each department.\",\n    \"2\": \"This virtual table summarizes the number of distinct students and instructors associated with each academic department. It joins the 'department', 'student', and 'instructor' tables based on the department name, and groups the results by department name to provide a count of unique students and instructors for each department.\"\n}\n"}
{"sample_id": "train.1464", "db_id": "college_2", "question": "Find the names of all instructors in computer science department", "rationale": ["Identify the table that contains instructor information, which is the 'instructor' table.", "Determine the relevant column for the instructor's name, which is 'name'.", "Identify the condition needed to filter instructors by their department, which is 'dept_name'.", "Specify the department of interest, which is 'computer science'.", "Construct the SQL query to select the names of instructors from the 'instructor' table where the 'dept_name' matches 'computer science'."], "gold_sql": "SELECT name FROM instructor WHERE dept_name  =  'Comp. Sci.'", "source_tables": ["instructor"], "pred_sql": "SELECT name FROM instructor WHERE dept_name = 'computer science';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of instructors who are advisors to students, ordered by the total credits earned by the students in descending order. The placeholder in the LIMIT clause represents the maximum number of instructor names to be returned.\",\n    \"1\": \"This virtual table summarizes the number of distinct students and instructors associated with each academic department. It joins the 'department', 'student', and 'instructor' tables based on the department name, and groups the results by department name to provide a count of unique students and instructors for each department.\",\n    \"2\": \"This virtual table summarizes the number of distinct students and instructors associated with each academic department. It joins the 'department', 'student', and 'instructor' tables based on the department name, and groups the results by department name to provide a count of unique students and instructors for each department.\"\n}\n"}
{"sample_id": "train.1480", "db_id": "college_2", "question": "Find courses that ran in Fall 2009 but not in Spring 2010.", "rationale": ["Identify the courses that were offered in Fall 2009.", "Join the course table with the section table to filter by semester and year.", "Use a subquery to find courses that were offered in Spring 2010.", "Use NOT IN to exclude the courses found in the Spring 2010 subquery from the Fall 2009 results."], "gold_sql": "SELECT course_id FROM SECTION WHERE semester  =  'Fall' AND YEAR  =  2009 EXCEPT SELECT course_id FROM SECTION WHERE semester  =  'Spring' AND YEAR  =  2010", "source_tables": ["section"], "pred_sql": "SELECT DISTINCT c.title \nFROM course c \nJOIN section s1 ON c.course_id = s1.course_id \nWHERE s1.semester = 'Fall' AND s1.year = '2009' \nAND c.course_id NOT IN (\n    SELECT s2.course_id \n    FROM section s2 \n    WHERE s2.semester = 'Spring' AND s2.year = '2010'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of students who are not enrolled in any courses offered by a specific department. The placeholder in the subquery represents the department's name.\"\n}\n"}
{"sample_id": "train.1489", "db_id": "college_2", "question": "What are the names of instructors who earn more than at least one instructor from the Biology department?", "rationale": ["Identify the main requirement: we need the names of instructors who earn more than at least one instructor from the Biology department.", "To find this, we need to compare the salaries of instructors with those in the Biology department.", "We can use a subquery to find the maximum salary of instructors in the Biology department.", "The outer query will select the names of instructors whose salary is greater than the maximum salary found in the subquery."], "gold_sql": "SELECT name FROM instructor WHERE salary  >  (SELECT min(salary) FROM instructor WHERE dept_name  =  'Biology')", "source_tables": ["instructor"], "pred_sql": "SELECT name FROM instructor WHERE salary > (SELECT MAX(salary) FROM instructor WHERE dept_name = 'Biology');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of instructors who are advisors to students, ordered by the total credits earned by the students in descending order. The placeholder in the LIMIT clause represents the maximum number of instructor names to be returned.\",\n    \"1\": \"This virtual table summarizes the number of distinct students and instructors associated with each academic department. It joins the 'department', 'student', and 'instructor' tables based on the department name, and groups the results by department name to provide a count of unique students and instructors for each department.\",\n    \"2\": \"This virtual table summarizes the number of distinct students and instructors associated with each academic department. It joins the 'department', 'student', and 'instructor' tables based on the department name, and groups the results by department name to provide a count of unique students and instructors for each department.\"\n}\n"}
{"sample_id": "train.1515", "db_id": "insurance_and_eClaims", "question": "Find the total and average amount paid in claim headers.", "rationale": ["Identify the relevant table: The 'Claim_Headers' table contains the 'Amount_Paid' column which is needed to calculate the total and average amount paid.", "Use aggregate functions: To find the total amount paid, use the SUM() function, and to find the average amount paid, use the AVG() function.", "Construct the SQL query: Combine the aggregate functions in a SELECT statement from the 'Claim_Headers' table."], "gold_sql": "SELECT sum(amount_piad) ,  avg(amount_piad) FROM claim_headers", "source_tables": ["claim_headers"], "pred_sql": "SELECT SUM(Amount_Paid) AS Total_Amount_Paid, AVG(Amount_Paid) AS Average_Amount_Paid\nFROM Claim_Headers;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves detailed information about customers associated with claims that have the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to their respective policies, and then joins with the 'Customers' table to get customer details. The placeholder in the WHERE clause represents the minimum amount paid for claims.\",\n    \"1\": \"This virtual table retrieves the detailed information about customers associated with the claim that has the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to policies, and then joins with the 'Customers' table to get customer details. The placeholder in the WHERE clause represents the minimum amount paid for claims.\"\n}\n"}
{"sample_id": "train.1516", "db_id": "insurance_and_eClaims", "question": "What are the total amount and average amount paid in claim headers?", "rationale": ["The question asks for the total and average amount paid in claim headers, which indicates that we need to aggregate data from the 'Claim_Headers' table.", "To find the total amount paid, we can use the SUM() function on the 'Amount_Paid' column.", "To find the average amount paid, we can use the AVG() function on the same 'Amount_Paid' column.", "We will select both the total and average amounts in a single SQL query, using appropriate aliases for clarity."], "gold_sql": "SELECT sum(amount_piad) ,  avg(amount_piad) FROM claim_headers", "source_tables": ["claim_headers"], "pred_sql": "SELECT SUM(Amount_Paid) AS Total_Amount_Paid, AVG(Amount_Paid) AS Average_Amount_Paid FROM Claim_Headers;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves detailed information about customers associated with claims that have the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to their respective policies, and then joins with the 'Customers' table to get customer details. The placeholder in the WHERE clause represents the minimum amount paid for claims.\",\n    \"1\": \"This virtual table retrieves the detailed information about customers associated with the claim that has the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to policies, and then joins with the 'Customers' table to get customer details. The placeholder in the WHERE clause represents the minimum amount paid for claims.\"\n}\n"}
{"sample_id": "train.1517", "db_id": "insurance_and_eClaims", "question": "Find the total amount claimed in the most recently created document.", "rationale": ["Identify the relevant tables: Claim_Headers for claims and Claims_Documents for documents.", "We need to find the total amount claimed, so we will use the SUM function on the Amount_Claimed column from the Claim_Headers table.", "To find the most recently created document, we will use a subquery to get the maximum Created_Date from the Claims_Documents table.", "Join the Claim_Headers table with the Claims_Documents table on Claim_Header_ID to link claims with their documents.", "Filter the results to only include claims associated with the most recently created document using the WHERE clause with the subquery."], "gold_sql": "SELECT sum(t1.amount_claimed) FROM claim_headers AS t1 JOIN claims_documents AS t2 ON t1.claim_header_id  =  t2.claim_id WHERE t2.created_date  =  (SELECT created_date FROM claims_documents ORDER BY created_date LIMIT 1)", "source_tables": ["claims_documents", "claim_headers"], "pred_sql": "SELECT SUM(ch.Amount_Claimed) AS Total_Amount_Claimed\nFROM Claim_Headers ch\nJOIN Claims_Documents cd ON ch.Claim_Header_ID = cd.Claim_ID\nWHERE cd.Created_Date = (SELECT MAX(Created_Date) FROM Claims_Documents);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the detailed information about customers associated with the claim that has the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to policies, and then joins with the 'Customers' table to get customer details. The placeholder in the WHERE clause represents the minimum amount paid for claims.\",\n    \"1\": \"This virtual table retrieves detailed information about customers associated with claims that have the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to their respective policies, and then joins with the 'Customers' table to get customer details. The placeholder in the WHERE clause represents the minimum amount paid for claims.\"\n}\n"}
{"sample_id": "train.1519", "db_id": "insurance_and_eClaims", "question": "What is the name of the customer who has made the largest amount of claim in a single claim?", "rationale": ["Identify the relevant tables: Customers, Claim_Headers, and Policies are needed to get customer details and their claims.", "Join the Claim_Headers table with the Policies table using the Policy_ID to link claims to their respective policies.", "Join the resulting table with the Customers table using the Customer_ID to get customer details.", "Use a subquery to find the maximum amount paid from the Claim_Headers table.", "Filter the results to only include the customer(s) who made the claim with the maximum amount paid."], "gold_sql": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_claimed  =  (SELECT max(amount_claimed) FROM claim_headers)", "source_tables": ["policies", "customers", "claim_headers"], "pred_sql": "SELECT Customers.Customer_Details \nFROM Claim_Headers \nJOIN Policies ON Claim_Headers.Policy_ID = Policies.Policy_ID \nJOIN Customers ON Policies.Customer_ID = Customers.Customer_ID \nWHERE Claim_Headers.Amount_Paid = (SELECT MAX(Amount_Paid) FROM Claim_Headers);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the detailed information about customers associated with the claim that has the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to policies, and then joins with the 'Customers' table to get customer details. The placeholder in the WHERE clause represents the minimum amount paid for claims.\",\n    \"1\": \"This virtual table retrieves detailed information about customers associated with claims that have the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to their respective policies, and then joins with the 'Customers' table to get customer details. The placeholder in the WHERE clause represents the minimum amount paid for claims.\"\n}\n"}
{"sample_id": "train.1527", "db_id": "insurance_and_eClaims", "question": "What is the name of the claim processing stage that most of the claims are on?", "rationale": ["Identify the relevant tables: Claims_Processing and Claims_Processing_Stages are needed to get the claim processing stage names and their counts.", "Join the Claims_Processing table with Claims_Processing_Stages on Claim_Stage_ID to get the names of the claim processing stages.", "Group the results by Claim_Status_Name to count how many claims are in each stage.", "Order the results by the count of claims in descending order to find the stage with the most claims.", "Limit the results to 1 to get only the stage with the highest count."], "gold_sql": "SELECT t2.claim_status_name FROM claims_processing AS t1 JOIN claims_processing_stages AS t2 ON t1.claim_stage_id  =  t2.claim_stage_id GROUP BY t1.claim_stage_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["claims_processing", "claims_processing_stages"], "pred_sql": "SELECT Claim_Status_Name, COUNT(*) as Claim_Count\nFROM Claims_Processing\nJOIN Claims_Processing_Stages ON Claims_Processing.Claim_Stage_ID = Claims_Processing_Stages.Claim_Stage_ID\nGROUP BY Claim_Status_Name\nORDER BY Claim_Count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the detailed information about customers associated with the claim that has the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to policies, and then joins with the 'Customers' table to get customer details. The placeholder in the WHERE clause represents the minimum amount paid for claims.\",\n    \"1\": \"This virtual table retrieves detailed information about customers associated with claims that have the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to their respective policies, and then joins with the 'Customers' table to get customer details. The placeholder in the WHERE clause represents the minimum amount paid for claims.\"\n}\n"}
{"sample_id": "train.1535", "db_id": "insurance_and_eClaims", "question": "Find the names of all the customers and staff members.", "rationale": ["Identify the tables needed: Customers and Staff.", "Determine the columns to select: Customer_Details from Customers and Staff_Details from Staff.", "Use a SELECT statement to retrieve the desired columns.", "Since we want to find names from both tables, we can use a cross join (implicit join) by listing both tables in the FROM clause."], "gold_sql": "SELECT customer_details FROM customers UNION SELECT staff_details FROM staff", "source_tables": ["staff", "customers"], "pred_sql": "SELECT Customers.Customer_Details AS Customer_Name, Staff.Staff_Details AS Staff_Name \nFROM Customers, Staff;", "hint": "\n"}
{"sample_id": "train.1545", "db_id": "insurance_and_eClaims", "question": "Which customer is associated with the latest policy?", "rationale": ["Identify the relevant tables: Customers and Policies.", "Determine the relationship between Customers and Policies using the Customer_ID.", "To find the latest policy, we need to look for the maximum Start_Date in the Policies table.", "Use a subquery to find the maximum Start_Date and filter the Policies table accordingly.", "Join the Customers table with the Policies table to retrieve the customer details associated with the latest policy."], "gold_sql": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)", "source_tables": ["policies", "customers"], "pred_sql": "SELECT Customers.Customer_ID, Customers.Customer_Details \nFROM Customers \nJOIN Policies ON Customers.Customer_ID = Policies.Customer_ID \nWHERE Policies.Start_Date = (SELECT MAX(Start_Date) FROM Policies);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the detailed information about customers associated with the claim that has the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to policies, and then joins with the 'Customers' table to get customer details. The placeholder in the WHERE clause represents the minimum amount paid for claims.\",\n    \"1\": \"This virtual table retrieves detailed information about customers associated with claims that have the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to their respective policies, and then joins with the 'Customers' table to get customer details. The placeholder in the WHERE clause represents the minimum amount paid for claims.\"\n}\n"}
{"sample_id": "train.1546", "db_id": "insurance_and_eClaims", "question": "Find the customer who started a policy most recently.", "rationale": ["Identify the relevant tables: Customers and Policies are needed to find customer details and their policy start dates.", "We need to find the most recent policy, which requires looking at the Start_Date in the Policies table.", "To get the customer who started the most recent policy, we will join the Customers table with the Policies table on Customer_ID.", "We will use a subquery to find the maximum Start_Date from the Policies table, which represents the most recent policy start date.", "Finally, we will select the Customer_ID and Customer_Details from the Customers table where the Start_Date matches the most recent date found in the subquery."], "gold_sql": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)", "source_tables": ["policies", "customers"], "pred_sql": "SELECT Customers.Customer_ID, Customers.Customer_Details \nFROM Policies \nJOIN Customers ON Policies.Customer_ID = Customers.Customer_ID \nWHERE Policies.Start_Date = (SELECT MAX(Start_Date) FROM Policies);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the detailed information about customers associated with the claim that has the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to policies, and then joins with the 'Customers' table to get customer details. The placeholder in the WHERE clause represents the minimum amount paid for claims.\",\n    \"1\": \"This virtual table retrieves detailed information about customers associated with claims that have the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to their respective policies, and then joins with the 'Customers' table to get customer details. The placeholder in the WHERE clause represents the minimum amount paid for claims.\"\n}\n"}
{"sample_id": "train.1553", "db_id": "customers_and_invoices", "question": "Show the id, the account name, and other account details for all accounts by the customer with first name 'Meaghan'.", "rationale": ["Identify the relevant tables: Accounts and Customers.", "Determine the columns needed: account_id, account_name, and other_account_details from Accounts.", "Establish the relationship between Accounts and Customers using the customer_id foreign key.", "Filter the results to include only those accounts associated with the customer whose first name is 'Meaghan'.", "Construct the SQL query using SELECT, JOIN, and WHERE clauses."], "gold_sql": "SELECT T1.account_id ,  T1.date_account_opened ,  T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  'Meaghan'", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT Accounts.account_id, Accounts.account_name, Accounts.other_account_details \nFROM Accounts \nJOIN Customers ON Accounts.customer_id = Customers.customer_id \nWHERE Customers.customer_first_name = 'Meaghan';", "hint": "\n"}
{"sample_id": "train.1556", "db_id": "customers_and_invoices", "question": "What are the names and other details for accounts corresponding to the customer named Meaghan Keeling?", "rationale": ["Identify the relevant tables: Customers and Accounts.", "We need to retrieve account details for a specific customer, so we will join the Customers table with the Accounts table using the customer_id.", "Filter the results to only include the customer named 'Meaghan Keeling' by checking both the first and last name in the WHERE clause.", "Select the desired columns: account_name and other_account_details from the Accounts table."], "gold_sql": "SELECT T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  'Meaghan' AND T2.customer_last_name  =  'Keeling'", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT Accounts.account_name, Accounts.other_account_details \nFROM Customers \nJOIN Accounts ON Customers.customer_id = Accounts.customer_id \nWHERE Customers.customer_first_name = 'Meaghan' AND Customers.customer_last_name = 'Keeling';", "hint": "\n"}
{"sample_id": "train.1558", "db_id": "customers_and_invoices", "question": "What are the full names of customers with the account name 900?", "rationale": ["Identify the relevant tables: Customers and Accounts.", "Determine the columns needed: full names (first and last) from Customers and account name from Accounts.", "Join the Customers table with the Accounts table on the customer_id field to link customers with their accounts.", "Filter the results to include only those accounts with the name '900'.", "Select the concatenated first and last names as the full name."], "gold_sql": "SELECT T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T1.account_name  =  '900'", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT customer_first_name || ' ' || customer_last_name AS full_name\nFROM Customers\nJOIN Accounts ON Customers.customer_id = Accounts.customer_id\nWHERE Accounts.account_name = '900';", "hint": "\n"}
{"sample_id": "train.1569", "db_id": "customers_and_invoices", "question": "Show id, first name and last name for all customers and the number of accounts.", "rationale": ["Identify the required fields: customer_id, customer_first_name, customer_last_name from the Customers table, and the count of accounts from the Accounts table.", "To get the number of accounts per customer, a JOIN operation is needed between the Customers table and the Accounts table using the customer_id as the key.", "Since not all customers may have accounts, a LEFT JOIN is appropriate to ensure all customers are included in the results, even those with zero accounts.", "Use the COUNT function to count the number of accounts for each customer, and alias this count as number_of_accounts.", "Group the results by customer_id, customer_first_name, and customer_last_name to ensure the count is calculated correctly for each customer."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT c.customer_id, c.customer_first_name, c.customer_last_name, COUNT(a.account_id) AS number_of_accounts\nFROM Customers c\nLEFT JOIN Accounts a ON c.customer_id = a.customer_id\nGROUP BY c.customer_id, c.customer_first_name, c.customer_last_name;", "hint": "\n"}
{"sample_id": "train.1570", "db_id": "customers_and_invoices", "question": "What are the the full names and ids for all customers, and how many accounts does each have?", "rationale": ["Identify the required fields: customer_id, full name (first and last), and account count.", "To get the full name, concatenate customer_first_name and customer_last_name.", "To count the number of accounts for each customer, use the COUNT function on account_id.", "Join the Customers table with the Accounts table on customer_id to link customers with their accounts.", "Use a LEFT JOIN to ensure all customers are included, even those without accounts.", "Group the results by customer_id and full name to get the count of accounts per customer."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT c.customer_id, c.customer_first_name || ' ' || c.customer_last_name AS full_name, COUNT(a.account_id) AS account_count\nFROM Customers c\nLEFT JOIN Accounts a ON c.customer_id = a.customer_id\nGROUP BY c.customer_id, c.customer_first_name, c.customer_last_name;", "hint": "\n"}
{"sample_id": "train.1580", "db_id": "customers_and_invoices", "question": "Count the number of financial transactions that correspond to each account id.", "rationale": ["Identify the relevant table: Financial_Transactions contains the account_id and transaction_id.", "We need to count the number of transactions for each account, so we will use the COUNT() function.", "To group the results by account_id, we will use the GROUP BY clause.", "The final query will select the account_id and the count of transaction_id, giving us the number of transactions per account."], "gold_sql": "SELECT count(*) ,  account_id FROM Financial_transactions", "source_tables": ["financial_transactions"], "pred_sql": "SELECT account_id, COUNT(transaction_id) AS transaction_count\nFROM Financial_Transactions\nGROUP BY account_id;", "hint": "\n"}
{"sample_id": "train.1607", "db_id": "customers_and_invoices", "question": "Show the order ids and the number of invoices for each order.", "rationale": ["We need to retrieve the order ids and the number of invoices for each order.", "To do this, we will select the 'order_id' from the 'Orders' table.", "We will also count the number of invoices associated with each order, which can be done using the COUNT function on 'invoice_number' from the 'Invoices' table.", "To link the 'Orders' and 'Invoices' tables, we will use a LEFT JOIN on the 'order_id' field, as we want to include all orders even if they have no invoices.", "Finally, we will group the results by 'order_id' to get the count of invoices for each order."], "gold_sql": "SELECT order_id ,  count(*) FROM Invoices GROUP BY order_id", "source_tables": ["invoices"], "pred_sql": "SELECT Orders.order_id, COUNT(Invoices.invoice_number) AS number_of_invoices\nFROM Orders\nLEFT JOIN Invoices ON Orders.order_id = Invoices.order_id\nGROUP BY Orders.order_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total quantity of each product ordered from the 'Products' table by joining it with the 'Order_Items' and 'Orders' tables. The placeholder in the SELECT statement represents the product name, and the count function aggregates the total number of items ordered for each product.\"\n}\n"}
{"sample_id": "train.1617", "db_id": "customers_and_invoices", "question": "Show the order ids and the number of items in each order.", "rationale": ["We need to retrieve the order ids and the number of items in each order.", "To do this, we will select the 'order_id' from the 'Orders' table.", "We will also need to count the number of items in each order, which can be done using the COUNT function on 'order_item_id' from the 'Order_Items' table.", "To get the relevant data, we will join the 'Orders' table with the 'Order_Items' table on the 'order_id'.", "Finally, we will group the results by 'Orders.order_id' to get the count of items for each order."], "gold_sql": "SELECT order_id ,  count(*) FROM Order_items GROUP BY order_id", "source_tables": ["order_items"], "pred_sql": "SELECT Orders.order_id, COUNT(Order_Items.order_item_id) AS number_of_items\nFROM Orders\nJOIN Order_Items ON Orders.order_id = Order_Items.order_id\nGROUP BY Orders.order_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total quantity of each product ordered from the 'Products' table by joining it with the 'Order_Items' and 'Orders' tables. The placeholder in the SELECT statement represents the product name, and the count function aggregates the total number of items ordered for each product.\"\n}\n"}
{"sample_id": "train.1622", "db_id": "customers_and_invoices", "question": "What are teh names of the different products, as well as the number of customers who have ordered each product.", "rationale": ["Identify the tables involved: Products, Order_Items, and Orders.", "We need to select the product names from the Products table.", "We need to count the number of customers who have ordered each product, which can be done by counting the occurrences of product_id in the Order_Items table.", "Join the Products table with the Order_Items table on product_id to link products with their orders.", "Join the Order_Items table with the Orders table to ensure we are counting orders correctly.", "Group the results by product name to get the count of customers for each product."], "gold_sql": "SELECT T2.product_name ,  count(*) FROM Order_items AS T1 JOIN Products AS T2 ON T1.product_id  =  T2.product_id JOIN Orders AS T3 ON T3.order_id  =  T1.order_id GROUP BY T2.product_name", "source_tables": ["orders", "products", "order_items"], "pred_sql": "SELECT Products.product_name, COUNT(Order_Items.product_id) AS number_of_customers_ordered\nFROM Products\nJOIN Order_Items ON Products.product_id = Order_Items.product_id\nJOIN Orders ON Order_Items.order_id = Orders.order_id\nGROUP BY Products.product_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total quantity of each product ordered from the 'Products' table by joining it with the 'Order_Items' and 'Orders' tables. The placeholder in the SELECT statement represents the product name, and the count function aggregates the total number of items ordered for each product.\"\n}\n"}
{"sample_id": "train.2050", "db_id": "party_people", "question": "Which ministers are not a part of the Progress Party?", "rationale": ["Identify the relevant tables: We need to look at the 'member' table to find ministers and the 'party' table to identify the party they belong to.", "We need to join the 'member' table with the 'party' table on the Party_ID to access the party names associated with each member.", "The query should filter out members who belong to the 'Progress Party'.", "We will select distinct member names to ensure we do not have duplicates in the results."], "gold_sql": "SELECT minister FROM party WHERE party_name != 'Progress Party'", "source_tables": ["party"], "pred_sql": "SELECT DISTINCT m.Member_Name \nFROM member m \nJOIN party p ON m.Party_ID = p.Party_ID \nWHERE p.Party_name != 'Progress Party';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of party events that are associated with a specific region and event name. The placeholders in the WHERE clause represent the region's name and the event's name, allowing users to filter the results based on their input.\"\n}\n"}
{"sample_id": "train.2057", "db_id": "party_people", "question": "Show all party names and the number of members in each party.", "rationale": ["Identify the tables needed: We need data from the 'party' table for party names and the 'member' table for counting members.", "Join the 'party' table with the 'member' table on the Party_ID to associate members with their respective parties.", "Use COUNT() function to count the number of members for each party.", "Group the results by party name to get the count of members for each party."], "gold_sql": "SELECT T2.party_name ,  count(*) FROM Member AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id", "source_tables": ["party", "member"], "pred_sql": "SELECT party.Party_name, COUNT(member.Member_ID) AS Number_of_Members\nFROM party\nLEFT JOIN member ON party.Party_ID = member.Party_ID\nGROUP BY party.Party_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of party events that are associated with a specific region and event name. The placeholders in the WHERE clause represent the region's name and the event's name, allowing users to filter the results based on their input.\"\n}\n"}
{"sample_id": "train.2072", "db_id": "party_people", "question": "How many events are there for each party?", "rationale": ["Identify the tables involved: We need to count events for each party, so we will use the 'party' and 'party_events' tables.", "Determine the relationship: The 'party' table has a unique identifier 'Party_ID' which is also present in the 'party_events' table, allowing us to join these tables.", "Use a LEFT JOIN: This will ensure that we include all parties even if they have no events associated with them.", "Count the events: We will use the COUNT function to count the number of events for each party.", "Group the results: We will group the results by 'Party_name' to get the count of events for each party."], "gold_sql": "SELECT T2.party_name ,  count(*) FROM party_events AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id", "source_tables": ["party", "party_events"], "pred_sql": "SELECT party.Party_name, COUNT(party_events.Event_ID) AS Event_Count\nFROM party\nLEFT JOIN party_events ON party.Party_ID = party_events.Party_ID\nGROUP BY party.Party_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of party events that are associated with a specific region and event name. The placeholders in the WHERE clause represent the region's name and the event's name, allowing users to filter the results based on their input.\"\n}\n"}
{"sample_id": "train.2081", "db_id": "party_people", "question": "How many Annual Meeting events happened in the United Kingdom region?", "rationale": ["Identify the tables involved: party_events, party, and region.", "We need to count the number of events, so we will use COUNT(*) in the SELECT statement.", "Join the party_events table with the party table on Party_ID to link events to their respective parties.", "Join the party table with the region table on Region_ID to filter events by region.", "Use a WHERE clause to specify that we are only interested in events in the 'United Kingdom' region and that the event name is 'Annual Meeting'."], "gold_sql": "SELECT count(*) FROM region AS t1 JOIN party AS t2 ON t1.region_id  =  t2.region_id JOIN party_events AS t3 ON t2.party_id  =  t3.party_id WHERE t1.region_name  =  'United Kingdom' AND t3.Event_Name  =  'Annaual Meeting'", "source_tables": ["party", "party_events", "region"], "pred_sql": "SELECT COUNT(*) AS Annual_Meeting_Count \nFROM party_events pe \nJOIN party p ON pe.Party_ID = p.Party_ID \nJOIN region r ON p.Region_ID = r.Region_ID \nWHERE r.Region_name = 'United Kingdom' AND pe.Event_Name = 'Annual Meeting';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of party events that are associated with a specific region and event name. The placeholders in the WHERE clause represent the region's name and the event's name, allowing users to filter the results based on their input.\"\n}\n"}
{"sample_id": "train.2167", "db_id": "formula_1", "question": "What is the id and family name of the driver who has the longest laptime?", "rationale": ["We need to find the driver with the longest lap time, which is stored in the lapTimes table.", "To get the driver's family name, we will join the drivers table with the lapTimes table on the driverId.", "We will order the results by the lap time in descending order to get the longest lap time at the top.", "Finally, we will limit the results to 1 to get only the driver with the longest lap time."], "gold_sql": "SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT 1", "source_tables": ["laptimes", "drivers"], "pred_sql": "SELECT drivers.driverId, drivers.surname \nFROM drivers \nJOIN lapTimes ON drivers.driverId = lapTimes.driverId \nORDER BY lapTimes.time DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and years of races in which a specific driver participated, identified by their first name. The placeholders in the WHERE clause allow for filtering based on the driver's first name.\",\n    \"1\": \"This virtual table describes the first and last names of drivers who participated in a specific race, excluding those who participated in another specified race. The placeholders in the WHERE clause represent the names of the races.\"\n}\n"}
{"sample_id": "train.2174", "db_id": "formula_1", "question": "How many drivers did not race in 2009?", "rationale": ["Identify the total number of drivers from the 'drivers' table.", "Use a subquery to find all driverIds that participated in races in the year 2009 by joining the 'results' and 'races' tables.", "The subquery selects distinct driverIds from the results of races that occurred in 2009.", "The main query counts all drivers whose driverId is not in the list of driverIds returned by the subquery."], "gold_sql": "SELECT count(DISTINCT driverId) FROM results WHERE raceId NOT IN( SELECT raceId FROM races WHERE YEAR != 2009 )", "source_tables": ["results", "races"], "pred_sql": "SELECT COUNT(*) AS drivers_not_in_2009\nFROM drivers\nWHERE driverId NOT IN (\n    SELECT DISTINCT driverId\n    FROM results\n    JOIN races ON results.raceId = races.raceId\n    WHERE races.year = 2009\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of drivers who participated in a specific race, excluding those who participated in another specified race. The placeholders in the WHERE clause represent the names of the races.\",\n    \"1\": \"This virtual table provides the names and years of races in which a specific driver participated, identified by their first name. The placeholders in the WHERE clause allow for filtering based on the driver's first name.\"\n}\n"}
{"sample_id": "train.2179", "db_id": "formula_1", "question": "Find the id and forenames of drivers who participated both the races with name Australian Grand Prix and the races with name Chinese Grand Prix?", "rationale": ["Identify the tables needed: We need the 'drivers' table to get driver information and the 'results' and 'races' tables to filter based on race names.", "Join the 'drivers' table with the 'results' table to link drivers to their race results.", "Join the 'results' table with the 'races' table to filter races by name (Australian Grand Prix).", "Use a subquery to find drivers who also participated in the Chinese Grand Prix by joining the 'drivers', 'results', and 'races' tables again.", "Use the IN clause to ensure that we only select drivers who are present in both the Australian and Chinese Grand Prix races.", "Select the required fields: driverId and forename from the 'drivers' table."], "gold_sql": "SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = 'Australian Grand Prix' INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = 'Chinese Grand Prix'", "source_tables": ["races", "drivers", "results"], "pred_sql": "SELECT d.driverId, d.forename\nFROM drivers d\nJOIN results r1 ON d.driverId = r1.driverId\nJOIN races ra ON r1.raceId = ra.raceId\nWHERE ra.name = 'Australian Grand Prix'\nAND d.driverId IN (\n    SELECT d2.driverId\n    FROM drivers d2\n    JOIN results r2 ON d2.driverId = r2.driverId\n    JOIN races rb ON r2.raceId = rb.raceId\n    WHERE rb.name = 'Chinese Grand Prix'\n)\nGROUP BY d.driverId, d.forename;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and years of races in which a specific driver participated, identified by their first name. The placeholders in the WHERE clause allow for filtering based on the driver's first name.\",\n    \"1\": \"This virtual table describes the first and last names of drivers who participated in a specific race, excluding those who participated in another specified race. The placeholders in the WHERE clause represent the names of the races.\"\n}\n"}
{"sample_id": "train.2180", "db_id": "formula_1", "question": "What is the id and first name of all the drivers who participated in the Australian Grand Prix and the Chinese Grand Prix?", "rationale": ["Identify the tables needed: drivers, results, and races.", "We need to find drivers who participated in both the Australian Grand Prix and the Chinese Grand Prix.", "Join the drivers table with the results table on driverId to get the race results for each driver.", "Join the results table with the races table on raceId to filter the races by name.", "Use a WHERE clause to filter for the races named 'Australian Grand Prix' and 'Chinese Grand Prix'.", "Select distinct driverId and forename to avoid duplicates and get the required information."], "gold_sql": "SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = 'Australian Grand Prix' INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = 'Chinese Grand Prix'", "source_tables": ["races", "drivers", "results"], "pred_sql": "SELECT DISTINCT d.driverId, d.forename \nFROM drivers d \nJOIN results r ON d.driverId = r.driverId \nJOIN races ra ON r.raceId = ra.raceId \nWHERE ra.name = 'Australian Grand Prix' \n   OR ra.name = 'Chinese Grand Prix';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and years of races in which a specific driver participated, identified by their first name. The placeholders in the WHERE clause allow for filtering based on the driver's first name.\",\n    \"1\": \"This virtual table describes the first and last names of drivers who participated in a specific race, excluding those who participated in another specified race. The placeholders in the WHERE clause represent the names of the races.\"\n}\n"}
{"sample_id": "train.2182", "db_id": "formula_1", "question": "What are the first and last names of all drivers who participated in the Australian Grand Prix but not the Chinese Grand Prix?", "rationale": ["Identify the tables needed: drivers, results, and races.", "We need to find drivers who participated in the Australian Grand Prix, so we will join the drivers table with the results table and then with the races table to filter by the race name.", "We also need to exclude drivers who participated in the Chinese Grand Prix. This requires a subquery that selects driverIds from the results of the Chinese Grand Prix.", "The main query selects the first and last names of drivers from the drivers table who are linked to the Australian Grand Prix in the results table, while ensuring that their driverId is not in the list of driverIds from the subquery for the Chinese Grand Prix."], "gold_sql": "SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Australian Grand Prix' EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Chinese Grand Prix'", "source_tables": ["races", "drivers", "results"], "pred_sql": "SELECT d.forename, d.surname \nFROM drivers d \nJOIN results r1 ON d.driverId = r1.driverId \nJOIN races ra ON r1.raceId = ra.raceId \nWHERE ra.name = 'Australian Grand Prix' \nAND d.driverId NOT IN (\n    SELECT r2.driverId \n    FROM results r2 \n    JOIN races rb ON r2.raceId = rb.raceId \n    WHERE rb.name = 'Chinese Grand Prix'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of drivers who participated in a specific race, excluding those who participated in another specified race. The placeholders in the WHERE clause represent the names of the races.\",\n    \"1\": \"This virtual table provides the names and years of races in which a specific driver participated, identified by their first name. The placeholders in the WHERE clause allow for filtering based on the driver's first name.\"\n}\n"}
{"sample_id": "train.2190", "db_id": "formula_1", "question": "For each constructor id, how many races are there?", "rationale": ["We need to count the number of races for each constructor id.", "The relevant table for this information is 'constructorResults', which links constructors to races.", "We will select the 'constructorId' and count the 'raceId' for each constructor.", "To get the count of races per constructor, we will use the COUNT() function and group the results by 'constructorId'."], "gold_sql": "SELECT count(*) ,  constructorid FROM constructorStandings GROUP BY constructorid", "source_tables": ["constructorstandings"], "pred_sql": "SELECT constructorId, COUNT(raceId) AS race_count \nFROM constructorResults \nGROUP BY constructorId;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and years of races in which a specific driver participated, identified by their first name. The placeholders in the WHERE clause allow for filtering based on the driver's first name.\",\n    \"1\": \"This virtual table describes the first and last names of drivers who participated in a specific race, excluding those who participated in another specified race. The placeholders in the WHERE clause represent the names of the races.\"\n}\n"}
{"sample_id": "train.2194", "db_id": "formula_1", "question": "What are the names of all races held after 2000 in Spain?", "rationale": ["Identify the relevant tables: 'races' for race information and 'circuits' for circuit location.", "We need to filter races held after the year 2000, so we will use the 'year' column from the 'races' table.", "We also need to filter for races held in Spain, which requires joining the 'circuits' table to access the 'country' column.", "The join condition is based on the 'circuitId' which is common in both 'races' and 'circuits' tables.", "Select the 'name' of the races that meet both conditions."], "gold_sql": "SELECT DISTINCT T1.name FROM races AS T1 JOIN circuits AS T2 ON T1.circuitid = T2.circuitid WHERE T2.country = 'Spain' AND T1.year > 2000", "source_tables": ["races", "circuits"], "pred_sql": "SELECT races.name \nFROM races \nJOIN circuits ON races.circuitId = circuits.circuitId \nWHERE races.year > 2000 AND circuits.country = 'Spain';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of drivers who participated in a specific race, excluding those who participated in another specified race. The placeholders in the WHERE clause represent the names of the races.\",\n    \"1\": \"This virtual table provides the names and years of races in which a specific driver participated, identified by their first name. The placeholders in the WHERE clause allow for filtering based on the driver's first name.\"\n}\n"}
{"sample_id": "train.2217", "db_id": "formula_1", "question": "Find the names of Japanese constructors that have once earned more than 5 points?", "rationale": ["Identify the relevant tables: We need to find constructors and their results, so we will use the 'constructors' and 'constructorResults' tables.", "Determine the condition: We are looking for constructors that have earned more than 5 points, which is specified in the 'constructorResults' table.", "Filter by nationality: We need to ensure that the constructors are Japanese, which is a condition on the 'constructors' table.", "Join the tables: We will join 'constructors' with 'constructorResults' on the 'constructorId' to link constructors with their results.", "Select distinct names: Since we only want the names of the constructors, we will select the 'name' column from the 'constructors' table and use DISTINCT to avoid duplicates."], "gold_sql": "SELECT T1.name FROM constructors AS T1 JOIN constructorstandings AS T2 ON T1.constructorid = T2.constructorid WHERE T1.nationality = 'Japanese' AND T2.points > 5", "source_tables": ["constructorstandings", "constructors"], "pred_sql": "SELECT DISTINCT constructors.name \nFROM constructors \nJOIN constructorResults ON constructors.constructorId = constructorResults.constructorId \nWHERE constructorResults.points > 5 \nAND constructors.nationality = 'Japanese';", "hint": "\n"}
{"sample_id": "train.2218", "db_id": "formula_1", "question": "What are the names of all the Japanese constructors that have earned more than 5 points?", "rationale": ["Identify the relevant table: We need to look at the 'constructors' table to get the names of constructors and their nationalities.", "Filter for Japanese constructors: We will add a WHERE clause to filter constructors by nationality, specifically 'Japanese'.", "Aggregate points: To find constructors that have earned more than 5 points, we will use the 'constructorResults' table, which contains points scored by constructors in races.", "Group by constructorId: We will group the results by 'constructorId' to aggregate the points for each constructor.", "Use HAVING clause: We will use the HAVING clause to filter those constructors whose total points exceed 5.", "Combine results: Finally, we will combine the results from the 'constructors' table with the aggregated points from the 'constructorResults' table using a subquery."], "gold_sql": "SELECT T1.name FROM constructors AS T1 JOIN constructorstandings AS T2 ON T1.constructorid = T2.constructorid WHERE T1.nationality = 'Japanese' AND T2.points > 5", "source_tables": ["constructorstandings", "constructors"], "pred_sql": "SELECT name FROM constructors WHERE nationality = 'Japanese' AND constructorId IN (SELECT constructorId FROM constructorResults GROUP BY constructorId HAVING SUM(points) > 5);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and years of races in which a specific driver participated, identified by their first name. The placeholders in the WHERE clause allow for filtering based on the driver's first name.\",\n    \"1\": \"This virtual table describes the first and last names of drivers who participated in a specific race, excluding those who participated in another specified race. The placeholders in the WHERE clause represent the names of the races.\"\n}\n"}
{"sample_id": "train.2220", "db_id": "formula_1", "question": "What is the average fastest lap speed for the Monaco Grand Prix in 2008?", "rationale": ["Identify the relevant tables: races, lapTimes, and circuits are needed to find the average fastest lap speed for a specific race.", "We need to join the races table with the lapTimes table on raceId to access the fastest lap speeds.", "We also need to join the circuits table to filter for the Monaco Grand Prix.", "The WHERE clause will specify the circuit name as 'Monaco Grand Prix' and the year as 2008.", "Finally, we will use the AVG() function to calculate the average of the fastest lap speeds."], "gold_sql": "SELECT avg(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "pred_sql": "SELECT AVG(lapTimes.fastestLapSpeed) AS average_fastest_lap_speed\nFROM races\nJOIN lapTimes ON races.raceId = lapTimes.raceId\nJOIN circuits ON races.circuitId = circuits.circuitId\nWHERE circuits.name = 'Monaco Grand Prix' AND races.year = 2008;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and years of races in which a specific driver participated, identified by their first name. The placeholders in the WHERE clause allow for filtering based on the driver's first name.\",\n    \"1\": \"This virtual table describes the first and last names of drivers who participated in a specific race, excluding those who participated in another specified race. The placeholders in the WHERE clause represent the names of the races.\"\n}\n"}
{"sample_id": "train.2222", "db_id": "formula_1", "question": "What is the maximum fastest lap speed in the Monaco Grand Prix in 2008?", "rationale": ["Identify the relevant tables: races, lapTimes, and circuits are needed to find the fastest lap speed for the Monaco Grand Prix in 2008.", "We need to filter the races table for the Monaco Grand Prix in the year 2008. This can be done by checking the circuit name and the year of the race.", "Join the races table with the lapTimes table on raceId to access the fastest lap speeds for the races.", "Join the circuits table to ensure we are only looking at the Monaco circuit.", "Use the MAX function to find the maximum fastest lap speed from the filtered results."], "gold_sql": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "pred_sql": "SELECT MAX(lapTimes.fastestLapSpeed) AS max_fastest_lap_speed\nFROM races\nJOIN lapTimes ON races.raceId = lapTimes.raceId\nJOIN circuits ON races.circuitId = circuits.circuitId\nWHERE circuits.name = 'Monaco' AND races.year = 2008;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and years of races in which a specific driver participated, identified by their first name. The placeholders in the WHERE clause allow for filtering based on the driver's first name.\",\n    \"1\": \"This virtual table describes the first and last names of drivers who participated in a specific race, excluding those who participated in another specified race. The placeholders in the WHERE clause represent the names of the races.\"\n}\n"}
{"sample_id": "train.2223", "db_id": "formula_1", "question": "What are the maximum fastest lap speed in races held after 2004 grouped by race name and ordered by year?", "rationale": ["Identify the relevant tables: races and lapTimes are needed to get race names and fastest lap speeds.", "We need to select the race name and the maximum fastest lap speed, so we will use the MAX() function on the fastestLapSpeed column from the lapTimes table.", "Join the races table with the lapTimes table on the raceId to correlate races with their lap times.", "Filter the results to include only races held after the year 2004 using the WHERE clause.", "Group the results by race name to get the maximum fastest lap speed for each race.", "Order the final results by year to see the races in chronological order."], "gold_sql": "SELECT max(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "pred_sql": "SELECT r.name AS race_name, MAX(l.fastestLapSpeed) AS max_fastest_lap_speed\nFROM races r\nJOIN lapTimes l ON r.raceId = l.raceId\nWHERE r.year > 2004\nGROUP BY r.name\nORDER BY r.year;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and years of races in which a specific driver participated, identified by their first name. The placeholders in the WHERE clause allow for filtering based on the driver's first name.\",\n    \"1\": \"This virtual table describes the first and last names of drivers who participated in a specific race, excluding those who participated in another specified race. The placeholders in the WHERE clause represent the names of the races.\"\n}\n"}
{"sample_id": "train.2224", "db_id": "formula_1", "question": "For each race name, What is the maximum fastest lap speed for races after 2004 ordered by year?", "rationale": ["Identify the relevant tables: races, results, and lapTimes.", "We need to get the race names and the maximum fastest lap speed for each race.", "Join the races table with the results table on raceId to link races with their results.", "Join the results table with the lapTimes table on raceId and driverId to access the fastest lap speeds.", "Filter the results to include only races after the year 2004 using a WHERE clause.", "Group the results by race name and year to calculate the maximum fastest lap speed for each race.", "Select the race name and the maximum fastest lap speed, and order the results by year."], "gold_sql": "SELECT max(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "pred_sql": "SELECT r.name AS race_name, MAX(l.fastestLapSpeed) AS max_fastest_lap_speed\nFROM races r\nJOIN results res ON r.raceId = res.raceId\nJOIN lapTimes l ON res.raceId = l.raceId AND res.driverId = l.driverId\nWHERE r.year > 2004\nGROUP BY r.name, r.year\nORDER BY r.year;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and years of races in which a specific driver participated, identified by their first name. The placeholders in the WHERE clause allow for filtering based on the driver's first name.\",\n    \"1\": \"This virtual table describes the first and last names of drivers who participated in a specific race, excluding those who participated in another specified race. The placeholders in the WHERE clause represent the names of the races.\"\n}\n"}
{"sample_id": "train.2325", "db_id": "csu_1", "question": "What campuses are located in the county of Los Angeles?", "rationale": ["Identify the relevant table: The question asks about campuses, so we will focus on the 'Campuses' table.", "Determine the filtering condition: The question specifies that we are looking for campuses located in 'Los Angeles', which corresponds to the 'County' column in the 'Campuses' table.", "Construct the SQL query: We will select all columns from the 'Campuses' table where the 'County' is 'Los Angeles'."], "gold_sql": "SELECT campus FROM campuses WHERE county  =  'Los Angeles'", "source_tables": ["campuses"], "pred_sql": "SELECT * FROM Campuses WHERE County = 'Los Angeles';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to associate campuses with their respective faculty data and also joins the 'degrees' table to ensure that the faculty data corresponds to the same year as the degrees awarded. The placeholders in the WHERE clause represent the year of interest and the limit on the number of results to return.\",\n    \"1\": \"This virtual table provides the number of faculty members from the 'faculty' table for campuses that have awarded degrees in a specific year. The query joins the 'campuses' table with the 'faculty' and 'degrees' tables based on the campus identifier and filters the results for a particular year. The placeholders in the WHERE clause represent the year of interest and the limit for the number of results returned.\"\n}\n"}
{"sample_id": "train.2347", "db_id": "csu_1", "question": "In what year was the most degrees conferred?", "rationale": ["Identify the table that contains the information about degrees awarded, which is the 'degrees' table.", "To find out in which year the most degrees were conferred, we need to count the number of degrees awarded per year.", "We will use the COUNT function to count the number of degrees for each year.", "We will group the results by year using GROUP BY clause to aggregate the counts for each year.", "To find the year with the maximum degrees, we will order the results in descending order based on the count of degrees.", "Finally, we will limit the results to only the top entry using LIMIT 1 to get the year with the most degrees conferred."], "gold_sql": "SELECT YEAR FROM degrees GROUP BY YEAR ORDER BY sum(degrees) DESC LIMIT 1", "source_tables": ["degrees"], "pred_sql": "SELECT Year, COUNT(Degrees) AS TotalDegrees\nFROM degrees\nGROUP BY Year\nORDER BY TotalDegrees DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of faculty members from the 'faculty' table for campuses that have awarded degrees in a specific year. The query joins the 'campuses' table with the 'faculty' and 'degrees' tables based on the campus identifier and filters the results for a particular year. The placeholders in the WHERE clause represent the year of interest and the limit for the number of results returned.\",\n    \"1\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to associate campuses with their respective faculty data and also joins the 'degrees' table to ensure that the faculty data corresponds to the same year as the degrees awarded. The placeholders in the WHERE clause represent the year of interest and the limit on the number of results to return.\"\n}\n"}
{"sample_id": "train.2348", "db_id": "csu_1", "question": "Which campus has the most degrees conferred in all times?", "rationale": ["Identify the relevant table for degrees awarded, which is the 'degrees' table.", "We need to count the total number of degrees conferred for each campus, so we will use the COUNT function on the 'Degrees' column.", "Group the results by 'Campus' to aggregate the counts for each campus.", "Order the results in descending order to get the campus with the most degrees at the top.", "Limit the results to 1 to get only the campus with the highest count of degrees."], "gold_sql": "SELECT campus FROM degrees GROUP BY campus ORDER BY sum(degrees) DESC LIMIT 1", "source_tables": ["degrees"], "pred_sql": "SELECT Campus, COUNT(Degrees) AS TotalDegrees\nFROM degrees\nGROUP BY Campus\nORDER BY TotalDegrees DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of faculty members from the 'faculty' table for campuses that have awarded degrees in a specific year. The query joins the 'campuses' table with the 'faculty' and 'degrees' tables based on the campus identifier and filters the results for a particular year. The placeholders in the WHERE clause represent the year of interest and the limit for the number of results returned.\",\n    \"1\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to associate campuses with their respective faculty data and also joins the 'degrees' table to ensure that the faculty data corresponds to the same year as the degrees awarded. The placeholders in the WHERE clause represent the year of interest and the limit on the number of results to return.\"\n}\n"}
{"sample_id": "train.2349", "db_id": "csu_1", "question": "What campus has the most degrees  conferrred over its entire existence?", "rationale": ["Identify the table that contains the information about degrees awarded, which is the 'degrees' table.", "To find the campus with the most degrees conferred, we need to count the number of degrees for each campus.", "We will use the COUNT function to count the degrees and group the results by campus.", "To get the campus with the highest count, we will order the results in descending order and limit the output to 1."], "gold_sql": "SELECT campus FROM degrees GROUP BY campus ORDER BY sum(degrees) DESC LIMIT 1", "source_tables": ["degrees"], "pred_sql": "SELECT Campus, COUNT(Degrees) AS TotalDegrees\nFROM degrees\nGROUP BY Campus\nORDER BY TotalDegrees DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of faculty members from the 'faculty' table for campuses that have awarded degrees in a specific year. The query joins the 'campuses' table with the 'faculty' and 'degrees' tables based on the campus identifier and filters the results for a particular year. The placeholders in the WHERE clause represent the year of interest and the limit for the number of results returned.\",\n    \"1\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to associate campuses with their respective faculty data and also joins the 'degrees' table to ensure that the faculty data corresponds to the same year as the degrees awarded. The placeholders in the WHERE clause represent the year of interest and the limit on the number of results to return.\"\n}\n"}
{"sample_id": "train.2351", "db_id": "csu_1", "question": "What campus has the most faculties in 2003?", "rationale": ["Identify the relevant tables: 'Campuses' and 'faculty'.", "We need to find the campus with the most faculty members in the year 2003, so we will filter the 'faculty' table by the year 2003.", "Join the 'Campuses' table with the 'faculty' table on the campus identifier to get the campus names along with their faculty counts.", "Order the results by the number of faculty members in descending order to get the campus with the most faculty at the top.", "Limit the results to 1 to get only the campus with the highest number of faculty."], "gold_sql": "SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  2003 ORDER BY T2.faculty DESC LIMIT 1", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT c.Campus, f.Faculty \nFROM Campuses c \nJOIN faculty f ON c.Id = f.Campus \nWHERE f.Year = 2003 \nORDER BY f.Faculty DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of faculty members from the 'faculty' table for campuses that have awarded degrees in a specific year. The query joins the 'campuses' table with the 'faculty' and 'degrees' tables based on the campus identifier and filters the results for a particular year. The placeholders in the WHERE clause represent the year of interest and the limit for the number of results returned.\",\n    \"1\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to associate campuses with their respective faculty data and also joins the 'degrees' table to ensure that the faculty data corresponds to the same year as the degrees awarded. The placeholders in the WHERE clause represent the year of interest and the limit on the number of results to return.\"\n}\n"}
{"sample_id": "train.2358", "db_id": "csu_1", "question": "For each Orange county campus, report the number of degrees granted after 2000.", "rationale": ["Identify the relevant tables: Campuses and degrees.", "We need to filter campuses located in Orange County, so we will use the County column from the Campuses table.", "We need to count the number of degrees granted after the year 2000, so we will filter the degrees table for records where Year > '2000'.", "We will join the Campuses table with the degrees table on the Campus identifier (Id in Campuses and Campus in degrees).", "We will group the results by campus to get the count of degrees for each campus."], "gold_sql": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  'Orange' AND T2.year  >=  2000 GROUP BY T1.campus", "source_tables": ["degrees", "campuses"], "pred_sql": "SELECT c.Campus, COUNT(d.Degrees) AS DegreesGranted\nFROM Campuses c\nJOIN degrees d ON c.Id = d.Campus\nWHERE c.County = 'Orange' AND d.Year > '2000'\nGROUP BY c.Campus;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of faculty members from the 'faculty' table for campuses that have awarded degrees in a specific year. The query joins the 'campuses' table with the 'faculty' and 'degrees' tables based on the campus identifier and filters the results for a particular year. The placeholders in the WHERE clause represent the year of interest and the limit for the number of results returned.\",\n    \"1\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to associate campuses with their respective faculty data and also joins the 'degrees' table to ensure that the faculty data corresponds to the same year as the degrees awarded. The placeholders in the WHERE clause represent the year of interest and the limit on the number of results to return.\"\n}\n"}
{"sample_id": "train.2359", "db_id": "csu_1", "question": "What is the total number of degrees granted after 2000 for each Orange county campus?", "rationale": ["Identify the relevant tables: Campuses and degrees.", "We need to count the total number of degrees granted, so we will use the COUNT function on the Degrees column from the degrees table.", "We need to filter the results to only include campuses in Orange County, so we will add a WHERE clause to check the County column in the Campuses table.", "We also need to filter for degrees granted after the year 2000, so we will add another condition in the WHERE clause to check that the Year in the degrees table is greater than 2000.", "We will join the Campuses table with the degrees table on the campus identifier (Id in Campuses and Campus in degrees).", "Finally, we will group the results by campus to get the total number of degrees for each campus."], "gold_sql": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  'Orange' AND T2.year  >=  2000 GROUP BY T1.campus", "source_tables": ["degrees", "campuses"], "pred_sql": "SELECT c.Campus, COUNT(d.Degrees) AS TotalDegrees\nFROM Campuses c\nJOIN degrees d ON c.Id = d.Campus\nWHERE c.County = 'Orange' AND d.Year > '2000'\nGROUP BY c.Campus;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of faculty members from the 'faculty' table for campuses that have awarded degrees in a specific year. The query joins the 'campuses' table with the 'faculty' and 'degrees' tables based on the campus identifier and filters the results for a particular year. The placeholders in the WHERE clause represent the year of interest and the limit for the number of results returned.\",\n    \"1\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to associate campuses with their respective faculty data and also joins the 'degrees' table to ensure that the faculty data corresponds to the same year as the degrees awarded. The placeholders in the WHERE clause represent the year of interest and the limit on the number of results to return.\"\n}\n"}
{"sample_id": "train.2362", "db_id": "csu_1", "question": "What campus had more than 400 total enrollment but more than 200 full time enrollment in year 1956?", "rationale": ["Identify the relevant tables: Campuses and enrollments.", "We need to find campuses with specific enrollment criteria: total enrollment greater than 400 and full-time equivalent enrollment greater than 200.", "Join the Campuses table with the enrollments table on the campus identifier.", "Filter the results based on the specified year (1956) and the enrollment criteria.", "Select the Campus name from the Campuses table that meets the criteria."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN enrollments AS t2 ON t1.id  =  t2.campus WHERE t2.year  =  1956 AND totalenrollment_ay  >  400 AND FTE_AY  >  200", "source_tables": ["enrollments", "campuses"], "pred_sql": "SELECT c.Campus \nFROM Campuses c \nJOIN enrollments e ON c.Id = e.Campus \nWHERE e.TotalEnrollment_AY > 400 \nAND e.FTE_AY > 200 \nAND e.Year = '1956';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of faculty members from the 'faculty' table for campuses that have awarded degrees in a specific year. The query joins the 'campuses' table with the 'faculty' and 'degrees' tables based on the campus identifier and filters the results for a particular year. The placeholders in the WHERE clause represent the year of interest and the limit for the number of results returned.\",\n    \"1\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to associate campuses with their respective faculty data and also joins the 'degrees' table to ensure that the faculty data corresponds to the same year as the degrees awarded. The placeholders in the WHERE clause represent the year of interest and the limit on the number of results to return.\"\n}\n"}
{"sample_id": "train.2367", "db_id": "csu_1", "question": "What campuses are in Los Angeles county?", "rationale": ["Identify the relevant table: The 'Campuses' table contains information about campuses, including their location and county.", "Determine the filtering criteria: The user is interested in campuses located in Los Angeles county, which corresponds to the 'County' column in the 'Campuses' table.", "Construct the SQL query: Use a SELECT statement to retrieve all columns from the 'Campuses' table where the 'County' is 'Los Angeles'."], "gold_sql": "SELECT campus FROM campuses WHERE county  =  'Los Angeles'", "source_tables": ["campuses"], "pred_sql": "SELECT * FROM Campuses WHERE County = 'Los Angeles';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to associate campuses with their respective faculty data and also joins the 'degrees' table to ensure that the faculty data corresponds to the same year as the degrees awarded. The placeholders in the WHERE clause represent the year of interest and the limit on the number of results to return.\",\n    \"1\": \"This virtual table provides the number of faculty members from the 'faculty' table for campuses that have awarded degrees in a specific year. The query joins the 'campuses' table with the 'faculty' and 'degrees' tables based on the campus identifier and filters the results for a particular year. The placeholders in the WHERE clause represent the year of interest and the limit for the number of results returned.\"\n}\n"}
{"sample_id": "train.2368", "db_id": "csu_1", "question": "How many degrees were conferred in \"San Jose State University\" in 2000?", "rationale": ["Identify the relevant tables: 'degrees' for the number of degrees conferred and 'Campuses' to filter by campus name.", "Join the 'degrees' table with the 'Campuses' table on the campus identifier to associate degrees with the correct campus.", "Filter the results to only include degrees awarded in the year 2000 and for the campus 'San Jose State University'.", "Use the SUM function to calculate the total number of degrees conferred for the specified campus and year."], "gold_sql": "SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  'San Jose State University' AND t2.year  =  2000", "source_tables": ["degrees", "campuses"], "pred_sql": "SELECT SUM(Degrees) AS TotalDegreesConferred\nFROM degrees\nJOIN Campuses ON degrees.Campus = Campuses.Id\nWHERE Campuses.Campus = 'San Jose State University' AND degrees.Year = '2000';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of faculty members from the 'faculty' table for campuses that have awarded degrees in a specific year. The query joins the 'campuses' table with the 'faculty' and 'degrees' tables based on the campus identifier and filters the results for a particular year. The placeholders in the WHERE clause represent the year of interest and the limit for the number of results returned.\",\n    \"1\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to associate campuses with their respective faculty data and also joins the 'degrees' table to ensure that the faculty data corresponds to the same year as the degrees awarded. The placeholders in the WHERE clause represent the year of interest and the limit on the number of results to return.\"\n}\n"}
{"sample_id": "train.2377", "db_id": "csu_1", "question": "How many faculty lines are there at San Francisco State University in 2004?", "rationale": ["Identify the relevant tables: 'faculty' for faculty data and 'Campuses' for campus identification.", "Join the 'faculty' table with the 'Campuses' table on the campus identifier to filter by campus name.", "Filter the results to only include records for 'San Francisco State University' and the year 2004.", "Use the SUM function to calculate the total number of faculty lines for the specified campus and year."], "gold_sql": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  2004 AND T2.campus  =  'San Francisco State University'", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT SUM(f.Faculty) AS TotalFaculty\nFROM faculty f\nJOIN Campuses c ON f.Campus = c.Id\nWHERE c.Campus = 'San Francisco State University' AND f.Year = 2004;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to associate campuses with their respective faculty data and also joins the 'degrees' table to ensure that the faculty data corresponds to the same year as the degrees awarded. The placeholders in the WHERE clause represent the year of interest and the limit on the number of results to return.\",\n    \"1\": \"This virtual table provides the number of faculty members from the 'faculty' table for campuses that have awarded degrees in a specific year. The query joins the 'campuses' table with the 'faculty' and 'degrees' tables based on the campus identifier and filters the results for a particular year. The placeholders in the WHERE clause represent the year of interest and the limit for the number of results returned.\"\n}\n"}
{"sample_id": "train.2378", "db_id": "csu_1", "question": "List the campus that have between 600 and 1000 faculty lines in year 2004.", "rationale": ["Identify the relevant tables: Campuses and faculty.", "Join the Campuses table with the faculty table on the campus identifier.", "Filter the results for the year 2004 using the faculty.Year column.", "Apply a condition to filter faculty counts between 600 and 1000 using the faculty.Faculty column."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  600 AND t2.faculty  <=  1000 AND T1.year  =  2004", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT Campuses.Campus \nFROM Campuses \nJOIN faculty ON Campuses.Id = faculty.Campus \nWHERE faculty.Year = 2004 \nAND faculty.Faculty BETWEEN 600 AND 1000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to associate campuses with their respective faculty data and also joins the 'degrees' table to ensure that the faculty data corresponds to the same year as the degrees awarded. The placeholders in the WHERE clause represent the year of interest and the limit on the number of results to return.\",\n    \"1\": \"This virtual table provides the number of faculty members from the 'faculty' table for campuses that have awarded degrees in a specific year. The query joins the 'campuses' table with the 'faculty' and 'degrees' tables based on the campus identifier and filters the results for a particular year. The placeholders in the WHERE clause represent the year of interest and the limit for the number of results returned.\"\n}\n"}
{"sample_id": "train.2379", "db_id": "csu_1", "question": "What are the campuses that had between 600 and 1000 faculty members in 2004?", "rationale": ["Identify the relevant tables: 'Campuses' for campus names and 'faculty' for faculty member counts.", "Join the 'Campuses' table with the 'faculty' table on the campus identifier to get the faculty data associated with each campus.", "Filter the results to only include records from the year 2004 by adding a condition in the WHERE clause.", "Add another condition to filter campuses that have between 600 and 1000 faculty members using the BETWEEN clause."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  600 AND t2.faculty  <=  1000 AND T1.year  =  2004", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT c.Campus \nFROM Campuses c \nJOIN faculty f ON c.Id = f.Campus \nWHERE f.Year = 2004 \nAND f.Faculty BETWEEN 600 AND 1000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to associate campuses with their respective faculty data and also joins the 'degrees' table to ensure that the faculty data corresponds to the same year as the degrees awarded. The placeholders in the WHERE clause represent the year of interest and the limit on the number of results to return.\",\n    \"1\": \"This virtual table provides the number of faculty members from the 'faculty' table for campuses that have awarded degrees in a specific year. The query joins the 'campuses' table with the 'faculty' and 'degrees' tables based on the campus identifier and filters the results for a particular year. The placeholders in the WHERE clause represent the year of interest and the limit for the number of results returned.\"\n}\n"}
{"sample_id": "train.2380", "db_id": "csu_1", "question": "How many faculty lines are there in the university that conferred the most number of degrees in year 2002?", "rationale": ["Identify the year of interest, which is 2002, for degrees awarded.", "Join the 'faculty' table with the 'degrees' table to link faculty data with the campuses that awarded degrees in 2002.", "Join the 'Campuses' table to get the campus names and ensure we are working with the correct identifiers.", "Use a subquery to find the campus that awarded the most degrees in 2002 by grouping by campus and counting the degrees, ordering by the count in descending order, and limiting the result to the top campus.", "Count the number of faculty members associated with the campus that awarded the most degrees in 2002."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2002 ORDER BY t3.degrees DESC LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "pred_sql": "SELECT COUNT(f.Faculty) AS FacultyCount\nFROM faculty f\nJOIN degrees d ON f.Campus = d.Campus\nJOIN Campuses c ON f.Campus = c.Id\nWHERE d.Year = '2002'\nAND c.Campus = (SELECT d2.Campus\n                FROM degrees d2\n                WHERE d2.Year = '2002'\n                GROUP BY d2.Campus\n                ORDER BY COUNT(d2.Degrees) DESC\n                LIMIT 1);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of faculty members from the 'faculty' table for campuses that have awarded degrees in a specific year. The query joins the 'campuses' table with the 'faculty' and 'degrees' tables based on the campus identifier and filters the results for a particular year. The placeholders in the WHERE clause represent the year of interest and the limit for the number of results returned.\",\n    \"1\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to associate campuses with their respective faculty data and also joins the 'degrees' table to ensure that the faculty data corresponds to the same year as the degrees awarded. The placeholders in the WHERE clause represent the year of interest and the limit on the number of results to return.\"\n}\n"}
{"sample_id": "train.2383", "db_id": "csu_1", "question": "How many faculty members are at the university that gave the least number of degrees in 2001?", "rationale": ["Identify the relevant tables: 'faculty' for faculty members and 'degrees' for the number of degrees awarded.", "Join the 'faculty' table with the 'degrees' table on the 'Campus' identifier to correlate faculty data with degree data.", "Filter the results to only include records from the year 2001 using the WHERE clause.", "Order the results by the number of degrees awarded in ascending order to find the campus with the least degrees awarded.", "Limit the results to 1 to get only the campus with the least degrees awarded."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2001 ORDER BY t3.degrees LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "pred_sql": "SELECT f.Faculty \nFROM faculty f \nJOIN degrees d ON f.Campus = d.Campus \nWHERE d.Year = '2001' \nORDER BY d.Degrees ASC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of faculty members from the 'faculty' table for campuses that have awarded degrees in a specific year. The query joins the 'campuses' table with the 'faculty' and 'degrees' tables based on the campus identifier and filters the results for a particular year. The placeholders in the WHERE clause represent the year of interest and the limit for the number of results returned.\",\n    \"1\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to associate campuses with their respective faculty data and also joins the 'degrees' table to ensure that the faculty data corresponds to the same year as the degrees awarded. The placeholders in the WHERE clause represent the year of interest and the limit on the number of results to return.\"\n}\n"}
{"sample_id": "train.2385", "db_id": "csu_1", "question": "How many undergraduates are there at San Jose State", "rationale": ["Identify the relevant table for undergraduate enrollments, which is 'discipline_enrollments'.", "Determine the necessary columns: we need to sum the 'Undergraduate' column to get the total number of undergraduates.", "Join the 'discipline_enrollments' table with the 'Campuses' table to filter by the specific campus name 'San Jose State'.", "Use a WHERE clause to specify the campus name to ensure we are only counting undergraduates at San Jose State."], "gold_sql": "SELECT sum(t1.undergraduate) FROM discipline_enrollments AS t1 JOIN campuses AS t2 ON t1.campus  =  t2.id WHERE t1.year  =  2004 AND t2.campus  =  'San Jose State University'", "source_tables": ["discipline_enrollments", "campuses"], "pred_sql": "SELECT SUM(Undergraduate) AS TotalUndergraduates\nFROM discipline_enrollments\nJOIN Campuses ON discipline_enrollments.Campus = Campuses.Id\nWHERE Campuses.Campus = 'San Jose State';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of faculty members from the 'faculty' table for campuses that have awarded degrees in a specific year. The query joins the 'campuses' table with the 'faculty' and 'degrees' tables based on the campus identifier and filters the results for a particular year. The placeholders in the WHERE clause represent the year of interest and the limit for the number of results returned.\",\n    \"1\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to associate campuses with their respective faculty data and also joins the 'degrees' table to ensure that the faculty data corresponds to the same year as the degrees awarded. The placeholders in the WHERE clause represent the year of interest and the limit on the number of results to return.\"\n}\n"}
{"sample_id": "train.3131", "db_id": "assets_maintenance", "question": "Which engineer has visited the most times? Show the engineer id, first name and last name.", "rationale": ["Identify the relevant tables: Engineer_Visits and Maintenance_Engineers.", "We need to count the number of visits for each engineer, so we will use COUNT(*) to aggregate the visits.", "Join the Engineer_Visits table with the Maintenance_Engineers table on the engineer_id to get the first and last names of the engineers.", "Group the results by engineer_id, first_name, and last_name to get the count of visits for each engineer.", "Order the results by visit_count in descending order to find the engineer with the most visits.", "Limit the results to 1 to get only the engineer with the highest visit count."], "gold_sql": "SELECT T1.engineer_id ,  T1.first_name ,  T1.last_name FROM Maintenance_Engineers AS T1 JOIN Engineer_Visits AS T2 GROUP BY T1.engineer_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["maintenance_engineers", "engineer_visits"], "pred_sql": "SELECT engineer_id, first_name, last_name, COUNT(*) as visit_count\nFROM Engineer_Visits\nJOIN Maintenance_Engineers ON Engineer_Visits.engineer_id = Maintenance_Engineers.engineer_id\nGROUP BY engineer_id, first_name, last_name\nORDER BY visit_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3139", "db_id": "assets_maintenance", "question": "How many fault status codes are recorded in the fault log parts table?", "rationale": ["The question asks for the number of unique fault status codes recorded in the Fault_Log_Parts table.", "To find the unique fault status codes, we need to count the distinct values in the 'fault_status' column of the Fault_Log_Parts table.", "The SQL query will use the COUNT function along with DISTINCT to achieve this."], "gold_sql": "SELECT DISTINCT fault_status FROM Fault_Log_Parts", "source_tables": ["fault_log_parts"], "pred_sql": "SELECT COUNT(DISTINCT fault_status) AS unique_fault_status_count FROM Fault_Log_Parts;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of fault short names along with their corresponding skill descriptions required to fix those faults. The data is sourced from the 'Part_Faults' table, which contains information about faults related to parts, and is joined with the 'Skills_Required_To_Fix' table to identify the necessary skills, and the 'Skills' table to get detailed descriptions of those skills.\",\n    \"1\": \"This virtual table describes assets that have a specific number of associated parts and a lesser number of recorded faults. The placeholders in the HAVING clauses represent the numeric values for the counts of parts and faults.\"\n}\n"}
{"sample_id": "train.3143", "db_id": "assets_maintenance", "question": "Which part fault requires the most number of skills to fix? List part id and name.", "rationale": ["Identify the relevant tables: Part_Faults, Skills_Required_To_Fix, Skills, and Parts.", "Join the Part_Faults table with Skills_Required_To_Fix to get the skills required for each part fault.", "Join with the Skills table to get the skill descriptions, although we only need the count of skills for each part fault.", "Join with the Parts table to get the part name associated with each part fault.", "Group the results by part_id and part_name to aggregate the count of skills for each part fault.", "Order the results by the count of skills in descending order to find the part fault that requires the most skills.", "Limit the results to 1 to get only the top result."], "gold_sql": "SELECT T1.part_id ,  T1.part_name FROM Parts AS T1 JOIN Part_Faults AS T2 ON T1.part_id  =  T2.part_id JOIN Skills_Required_To_Fix AS T3 ON T2.part_fault_id  =  T3.part_fault_id GROUP BY T1.part_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["part_faults", "parts", "skills_required_to_fix"], "pred_sql": "SELECT pf.part_id, p.part_name\nFROM Part_Faults pf\nJOIN Skills_Required_To_Fix srf ON pf.part_fault_id = srf.part_fault_id\nJOIN Skills s ON s.skill_id = srf.skill_id\nJOIN Parts p ON pf.part_id = p.part_id\nGROUP BY pf.part_id, p.part_name\nORDER BY COUNT(s.skill_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of fault short names along with their corresponding skill descriptions required to fix those faults. The data is sourced from the 'Part_Faults' table, which contains information about faults related to parts, and is joined with the 'Skills_Required_To_Fix' table to identify the necessary skills, and the 'Skills' table to get detailed descriptions of those skills.\",\n    \"1\": \"This virtual table describes assets that have a specific number of associated parts and a lesser number of recorded faults. The placeholders in the HAVING clauses represent the numeric values for the counts of parts and faults.\"\n}\n"}
{"sample_id": "train.3176", "db_id": "college_1", "question": "How many professors teach a class with the code ACCT-211?", "rationale": ["Identify the relevant tables: CLASS and PROFESSOR.", "We need to count the number of distinct professors teaching a specific class, so we will use COUNT(DISTINCT p.EMP_NUM).", "Join the CLASS table with the PROFESSOR table on the common key PROF_NUM.", "Filter the results to only include the class with the code 'ACCT-211'.", "Construct the SQL query to select the count of distinct professors for the specified class."], "gold_sql": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["class"], "pred_sql": "SELECT COUNT(DISTINCT p.EMP_NUM) AS ProfessorCount\nFROM CLASS c\nJOIN PROFESSOR p ON c.PROF_NUM = p.EMP_NUM\nWHERE c.CLASS_CODE = 'ACCT-211';", "hint": "\n"}
{"sample_id": "train.3180", "db_id": "college_1", "question": "What are the first names and birthdates of the professors in charge of ACCT-211?", "rationale": ["Identify the tables needed: EMPLOYEE, PROFESSOR, CLASS, and COURSE.", "We need to retrieve the first names and birthdates of professors, so we will select EMP_FNAME and EMP_DOB from the EMPLOYEE table.", "Professors are linked to classes through the PROFESSOR table, so we will join EMPLOYEE with PROFESSOR on EMP_NUM.", "Next, we join the CLASS table to link classes to professors using the PROF_NUM foreign key.", "Finally, we join the COURSE table to filter by the specific course code 'ACCT-211'.", "The WHERE clause is used to specify the course code we are interested in."], "gold_sql": "SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["employee", "class"], "pred_sql": "SELECT EMP_FNAME, EMP_DOB \nFROM EMPLOYEE \nJOIN PROFESSOR ON EMPLOYEE.EMP_NUM = PROFESSOR.EMP_NUM \nJOIN CLASS ON PROFESSOR.EMP_NUM = CLASS.PROF_NUM \nJOIN COURSE ON CLASS.CRS_CODE = COURSE.CRS_CODE \nWHERE COURSE.CRS_CODE = 'ACCT-211';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students enrolled in classes associated with a specific course code and who have received a particular grade. The placeholders in the WHERE clause represent the course code and the grade received by the students.\",\n    \"1\": \"This virtual table provides the first names of employees and the office locations of professors from the 'employee' and 'professor' tables, respectively. It filters the results based on a specific department name and the highest degree obtained by the professors, both represented by placeholders for string values.\"\n}\n"}
{"sample_id": "train.3189", "db_id": "college_1", "question": "How many different locations does the school with code BUS has?", "rationale": ["Identify the table that contains the location information, which is the DEPARTMENT table.", "We need to count the distinct addresses (DEPT_ADDRESS) to find out how many different locations there are.", "We filter the results to only include departments that belong to the school with the code 'BUS'.", "The SQL query uses COUNT(DISTINCT ...) to count unique addresses, ensuring we only count different locations."], "gold_sql": "SELECT count(DISTINCT dept_address) FROM department WHERE school_code  =  'BUS'", "source_tables": ["department"], "pred_sql": "SELECT COUNT(DISTINCT DEPT_ADDRESS) AS different_locations\nFROM DEPARTMENT\nWHERE SCHOOL_CODE = 'BUS';", "hint": "\n"}
{"sample_id": "train.3190", "db_id": "college_1", "question": "What are the different locations of the school with the code BUS?", "rationale": ["Identify the table that contains the school locations, which is the DEPARTMENT table.", "Determine the relevant column for the school code, which is SCHOOL_CODE in the DEPARTMENT table.", "Use the DISTINCT keyword to ensure that only unique addresses are returned.", "Construct the SQL query to select the DEPT_ADDRESS from the DEPARTMENT table where the SCHOOL_CODE is 'BUS'."], "gold_sql": "SELECT count(DISTINCT dept_address) FROM department WHERE school_code  =  'BUS'", "source_tables": ["department"], "pred_sql": "SELECT DISTINCT DEPT_ADDRESS FROM DEPARTMENT WHERE SCHOOL_CODE = 'BUS';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students enrolled in classes associated with a specific course code and who have received a particular grade. The placeholders in the WHERE clause represent the course code and the grade received by the students.\"\n}\n"}
{"sample_id": "train.3206", "db_id": "college_1", "question": "How many classes are held in each department?", "rationale": ["We need to count the number of classes held in each department.", "To do this, we will join the DEPARTMENT table with the COURSE table using the DEPT_CODE, since each course is associated with a department.", "Next, we will join the CLASS table with the COURSE table using the CRS_CODE, as each class is associated with a course.", "After joining these tables, we will group the results by department name to get the count of classes for each department.", "Finally, we will use the COUNT function to count the number of CLASS_CODE entries for each department."], "gold_sql": "SELECT count(*) ,  dept_code FROM CLASS AS T1 JOIN course AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY dept_code", "source_tables": ["course", "class"], "pred_sql": "SELECT D.DEPT_NAME, COUNT(C.CLASS_CODE) AS CLASS_COUNT\nFROM DEPARTMENT D\nJOIN COURSE CRS ON D.DEPT_CODE = CRS.DEPT_CODE\nJOIN CLASS C ON CRS.CRS_CODE = C.CRS_CODE\nGROUP BY D.DEPT_NAME;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of department names from the 'DEPARTMENT' table, which are associated with courses from the 'COURSE' table. The query joins the 'COURSE' and 'CLASS' tables to link courses to their respective classes, and then joins the 'DEPARTMENT' table to retrieve the department names. The results are grouped by department code and ordered by the total sum of credit hours for the courses in descending order, with a limit on the number of departments returned as specified by a placeholder.\",\n    \"1\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the name of the department.\",\n    \"2\": \"This virtual table provides a distinct list of first names of employees and their highest degrees from the 'CLASS', 'EMPLOYEE', 'PROFESSOR', and 'DEPARTMENT' tables. The results are filtered based on a specific department name provided as a placeholder.\"\n}\n"}
{"sample_id": "train.3209", "db_id": "college_1", "question": "What is the number of professors for different school?", "rationale": ["Identify the relevant tables: DEPARTMENT and PROFESSOR.", "We need to count the number of professors, so we will use the COUNT() function.", "To relate professors to their respective schools, we will join the DEPARTMENT table with the PROFESSOR table on the DEPT_CODE column.", "We will group the results by SCHOOL_CODE to get the count of professors for each school."], "gold_sql": "SELECT count(*) ,  T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code", "source_tables": ["department", "professor"], "pred_sql": "SELECT SCHOOL_CODE, COUNT(PROF_NUM) AS NUMBER_OF_PROFESSORS\nFROM DEPARTMENT\nJOIN PROFESSOR ON DEPARTMENT.DEPT_CODE = PROFESSOR.DEPT_CODE\nGROUP BY SCHOOL_CODE;", "hint": "\n"}
{"sample_id": "train.3210", "db_id": "college_1", "question": "How many different professors are there for the different schools?", "rationale": ["Identify the tables needed: PROFESSOR, DEPARTMENT, and CLASS.", "We need to count distinct professors, so we will use COUNT(DISTINCT PROFESSOR.EMP_NUM).", "To find professors associated with different schools, we need to join the PROFESSOR table with the DEPARTMENT table on DEPT_CODE.", "The CLASS table is not necessary for counting professors, so we will exclude it from the final query.", "The final SQL query will select the count of distinct professors from the joined tables."], "gold_sql": "SELECT count(*) ,  T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code", "source_tables": ["department", "professor"], "pred_sql": "SELECT COUNT(DISTINCT PROFESSOR.EMP_NUM) AS different_professors\nFROM PROFESSOR\nJOIN DEPARTMENT ON PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE\nJOIN CLASS ON DEPARTMENT.DEPT_CODE = CLASS.CRS_CODE;", "hint": "\n"}
{"sample_id": "train.3217", "db_id": "college_1", "question": "Find the number of students for each department.", "rationale": ["We need to find the number of students for each department, which involves counting students grouped by their department.", "The relevant tables are DEPARTMENT and STUDENT, as we need to get department names and the count of students in each department.", "We will perform a LEFT JOIN between DEPARTMENT and STUDENT on the DEPT_CODE to ensure we include all departments even if they have no students.", "We will use the COUNT function to count the number of students (STU_NUM) for each department.", "Finally, we will group the results by DEPARTMENT.DEPT_NAME to get the count for each department."], "gold_sql": "SELECT count(*) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME, COUNT(STUDENT.STU_NUM) AS NUM_STUDENTS\nFROM DEPARTMENT\nLEFT JOIN STUDENT ON DEPARTMENT.DEPT_CODE = STUDENT.DEPT_CODE\nGROUP BY DEPARTMENT.DEPT_NAME;", "hint": "\n"}
{"sample_id": "train.3218", "db_id": "college_1", "question": "How many students are in each department?", "rationale": ["We need to count the number of students in each department.", "To do this, we will join the DEPARTMENT table with the STUDENT table on the DEPT_CODE column, which is common to both tables.", "We will select the DEPT_NAME from the DEPARTMENT table and count the number of unique STU_NUM from the STUDENT table to get the number of students in each department.", "Finally, we will group the results by DEPT_NAME to get the count for each department."], "gold_sql": "SELECT count(*) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT DEPT_NAME, COUNT(STU_NUM) AS student_count \nFROM DEPARTMENT \nJOIN STUDENT ON DEPARTMENT.DEPT_CODE = STUDENT.DEPT_CODE \nGROUP BY DEPT_NAME;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the name of the department.\",\n    \"1\": \"This virtual table provides a list of department names from the 'DEPARTMENT' table, which are associated with courses from the 'COURSE' table. The query joins the 'COURSE' and 'CLASS' tables to link courses to their respective classes, and then joins the 'DEPARTMENT' table to retrieve the department names. The results are grouped by department code and ordered by the total sum of credit hours for the courses in descending order, with a limit on the number of departments returned as specified by a placeholder.\"\n}\n"}
{"sample_id": "train.3220", "db_id": "college_1", "question": "How many hours do the students spend studying in each department?", "rationale": ["Identify the relevant tables: DEPARTMENT, COURSE, CLASS, ENROLL, and STUDENT are needed to gather information about departments and the credit hours associated with courses.", "Join the DEPARTMENT table with the COURSE table on DEPT_CODE to link courses to their respective departments.", "Join the COURSE table with the CLASS table on CRS_CODE to link classes to their respective courses.", "Join the CLASS table with the ENROLL table on CLASS_CODE to find which students are enrolled in those classes.", "Join the ENROLL table with the STUDENT table on STU_NUM to get the students' information.", "Use SUM to calculate the total credit hours for each department by summing the CRS_CREDIT from the COURSE table.", "Group the results by DEPT_NAME to get the total hours spent studying in each department.", "Order the results by the total credit hours in descending order to see which department has the most hours."], "gold_sql": "SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT DEPT.DEPT_NAME, SUM(COURSE.CRS_CREDIT) AS TOTAL_CREDIT_HOURS\nFROM DEPARTMENT DEPT\nJOIN COURSE CRS ON DEPT.DEPT_CODE = CRS.DEPT_CODE\nJOIN CLASS CLS ON CRS.CRS_CODE = CLS.CRS_CODE\nJOIN ENROLL ENR ON CLS.CLASS_CODE = ENR.CLASS_CODE\nJOIN STUDENT STU ON ENR.STU_NUM = STU.STU_NUM\nGROUP BY DEPT.DEPT_NAME\nORDER BY TOTAL_CREDIT_HOURS DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of department names from the 'DEPARTMENT' table, which are associated with courses from the 'COURSE' table. The query joins the 'COURSE' and 'CLASS' tables to link courses to their respective classes, and then joins the 'DEPARTMENT' table to retrieve the department names. The results are grouped by department code and ordered by the total sum of credit hours for the courses in descending order, with a limit on the number of departments returned as specified by a placeholder.\",\n    \"1\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the name of the department.\"\n}\n"}
{"sample_id": "train.3222", "db_id": "college_1", "question": "What is the highest, lowest, and average student GPA for every department?", "rationale": ["Identify the required information: highest, lowest, and average GPA for students, grouped by department.", "Determine the relevant tables: DEPARTMENT for department names and STUDENT for student GPAs.", "Join the DEPARTMENT and STUDENT tables on the DEPT_CODE to associate students with their respective departments.", "Use aggregate functions: MAX() for highest GPA, MIN() for lowest GPA, and AVG() for average GPA.", "Group the results by department name to get the statistics for each department."], "gold_sql": "SELECT max(stu_gpa) ,  avg(stu_gpa) ,  min(stu_gpa) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME, \n       MAX(STUDENT.STU_GPA) AS Highest_GPA, \n       MIN(STUDENT.STU_GPA) AS Lowest_GPA, \n       AVG(STUDENT.STU_GPA) AS Average_GPA \nFROM DEPARTMENT \nJOIN STUDENT ON DEPARTMENT.DEPT_CODE = STUDENT.DEPT_CODE \nGROUP BY DEPARTMENT.DEPT_NAME;", "hint": "\n"}
{"sample_id": "train.3234", "db_id": "college_1", "question": "How many courses does the department of Computer Information Systmes offer?", "rationale": ["Identify the relevant tables: COURSE and DEPARTMENT.", "We need to count the number of courses offered by a specific department, which is 'Computer Information Systems'.", "Join the COURSE table with the DEPARTMENT table on the DEPT_CODE to filter courses by department.", "Use a WHERE clause to specify the department name as 'Computer Information Systems'.", "Use the COUNT function to count the number of courses (CRS_CODE) in the result set."], "gold_sql": "SELECT count(*) FROM department AS T1 JOIN course AS T2 ON T1.dept_code  =  T2.dept_code WHERE dept_name  =  'Computer Info. Systems'", "source_tables": ["course", "department"], "pred_sql": "SELECT COUNT(C.CRS_CODE) AS CourseCount\nFROM COURSE C\nJOIN DEPARTMENT D ON C.DEPT_CODE = D.DEPT_CODE\nWHERE D.DEPT_NAME = 'Computer Information Systems';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of department names from the 'DEPARTMENT' table, which are associated with courses from the 'COURSE' table. The query joins the 'COURSE' and 'CLASS' tables to link courses to their respective classes, and then joins the 'DEPARTMENT' table to retrieve the department names. The results are grouped by department code and ordered by the total sum of credit hours for the courses in descending order, with a limit on the number of departments returned as specified by a placeholder.\"\n}\n"}
{"sample_id": "train.3238", "db_id": "college_1", "question": "What are the total number of credits offered by each department?", "rationale": ["Identify the tables needed: DEPARTMENT, COURSE, and CLASS.", "Determine the relationships: DEPARTMENT is linked to COURSE via DEPT_CODE, and COURSE is linked to CLASS via CRS_CODE.", "Select the department name from DEPARTMENT and the sum of credits from COURSE.", "Group the results by department name to get the total credits per department.", "Order the results by the total credits in descending order to see which department offers the most credits."], "gold_sql": "SELECT sum(T1.crs_credit) ,  T1.dept_code FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY T1.dept_code", "source_tables": ["course", "class"], "pred_sql": "SELECT D.DEPT_NAME, SUM(C.CRS_CREDIT) AS TOTAL_CREDITS\nFROM DEPARTMENT D\nJOIN COURSE C ON D.DEPT_CODE = C.DEPT_CODE\nJOIN CLASS CL ON C.CRS_CODE = CL.CRS_CODE\nGROUP BY D.DEPT_NAME\nORDER BY TOTAL_CREDITS DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of department names from the 'DEPARTMENT' table, which are associated with courses from the 'COURSE' table. The query joins the 'COURSE' and 'CLASS' tables to link courses to their respective classes, and then joins the 'DEPARTMENT' table to retrieve the department names. The results are grouped by department code and ordered by the total sum of credit hours for the courses in descending order, with a limit on the number of departments returned as specified by a placeholder.\"\n}\n"}
{"sample_id": "train.3243", "db_id": "college_1", "question": "What is the first name of each student enrolled in class ACCT-211?", "rationale": ["Identify the tables involved: STUDENT, ENROLL, and CLASS.", "We need to find the first names of students, so we will select the 'STU_FNAME' column from the STUDENT table.", "Students are enrolled in classes, so we will join the ENROLL table with the STUDENT table on 'STU_NUM'.", "Next, we need to link the ENROLL table with the CLASS table using 'CLASS_CODE'.", "To filter the results to only those students enrolled in the class ACCT-211, we will add a WHERE clause that specifies 'CLASS.CRS_CODE = 'ACCT-211'."], "gold_sql": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  'ACCT-211'", "source_tables": ["student", "class", "enroll"], "pred_sql": "SELECT STU_FNAME FROM STUDENT INNER JOIN ENROLL ON STUDENT.STU_NUM = ENROLL.STU_NUM INNER JOIN CLASS ON ENROLL.CLASS_CODE = CLASS.CLASS_CODE WHERE CLASS.CRS_CODE = 'ACCT-211';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students enrolled in classes associated with a specific course code and who have received a particular grade. The placeholders in the WHERE clause represent the course code and the grade received by the students.\",\n    \"1\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the name of the department.\"\n}\n"}
{"sample_id": "train.3253", "db_id": "college_1", "question": "What is the name of the department that has the largest number of students enrolled?", "rationale": ["Identify the relevant tables: We need to find the department with the largest number of students enrolled, so we will use the STUDENT and DEPARTMENT tables.", "Count the number of students per department: We can group the STUDENT table by DEPT_CODE and count the number of students in each department using COUNT(STU_NUM).", "Order the results: To find the department with the largest number of students, we will order the results in descending order based on the count of students.", "Limit the results: We only need the top result, so we will use LIMIT 1 to get the department with the highest count.", "Select the department name: Finally, we will select the DEPT_NAME from the DEPARTMENT table where the DEPT_CODE matches the one we found in the previous step."], "gold_sql": "SELECT T4.dept_name FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code GROUP BY T3.dept_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["course", "department", "class", "enroll"], "pred_sql": "SELECT DEPT_NAME\nFROM DEPARTMENT\nWHERE DEPT_CODE IN (\n    SELECT STUDENT.DEPT_CODE\n    FROM STUDENT\n    GROUP BY STUDENT.DEPT_CODE\n    ORDER BY COUNT(STU_NUM) DESC\n    LIMIT 1\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the name of the department.\"\n}\n"}
{"sample_id": "train.3254", "db_id": "college_1", "question": "What is the name of the department with the most students enrolled?", "rationale": ["Identify the relevant tables: DEPARTMENT and STUDENT are needed to find the department with the most students enrolled.", "Count the number of students in each department by grouping the STUDENT table by DEPT_CODE.", "Order the results by the count of students in descending order to find the department with the most students.", "Limit the results to 1 to get only the top department.", "Select the DEPT_NAME from the DEPARTMENT table where the DEPT_CODE matches the one with the most students."], "gold_sql": "SELECT T4.dept_name FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code GROUP BY T3.dept_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["course", "department", "class", "enroll"], "pred_sql": "SELECT DEPT_NAME\nFROM DEPARTMENT\nWHERE DEPT_CODE IN (\n    SELECT DEPT_CODE\n    FROM STUDENT\n    GROUP BY DEPT_CODE\n    ORDER BY COUNT(STU_NUM) DESC\n    LIMIT 1\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the name of the department.\",\n    \"1\": \"This virtual table provides a distinct list of first names of employees and their highest degrees from the 'CLASS', 'EMPLOYEE', 'PROFESSOR', and 'DEPARTMENT' tables. The results are filtered based on a specific department name provided as a placeholder.\"\n}\n"}
{"sample_id": "train.3258", "db_id": "college_1", "question": "What are the codes of all the courses that are located in room KLR209?", "rationale": ["Identify the relevant table: The CLASS table contains information about class locations, including the CLASS_ROOM column.", "Determine the required information: We need the course codes (CRS_CODE) for classes held in room KLR209.", "Construct the SQL query: Use a SELECT statement to retrieve distinct CRS_CODE values from the CLASS table where CLASS_ROOM matches 'KLR209'."], "gold_sql": "SELECT class_code FROM CLASS WHERE class_room  =  'KLR209'", "source_tables": ["class"], "pred_sql": "SELECT DISTINCT CRS_CODE FROM CLASS WHERE CLASS_ROOM = 'KLR209';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students enrolled in classes associated with a specific course code and who have received a particular grade. The placeholders in the WHERE clause represent the course code and the grade received by the students.\"\n}\n"}
{"sample_id": "train.3267", "db_id": "college_1", "question": "What is the first name of students who got grade C in any class?", "rationale": ["Identify the relevant tables: STUDENT, ENROLL, and CLASS are needed to find students and their grades.", "Join the ENROLL table with the STUDENT table on the student number to get the first names of students along with their grades.", "Join the CLASS table to link the enrolled classes with the grades.", "Filter the results to include only those students who received a grade of 'C'.", "Select the distinct first names of the students to avoid duplicates."], "gold_sql": "SELECT DISTINCT stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE enroll_grade  =  'C'", "source_tables": ["enroll", "student"], "pred_sql": "SELECT DISTINCT STUDENT.STU_FNAME \nFROM STUDENT \nJOIN ENROLL ON STUDENT.STU_NUM = ENROLL.STU_NUM \nJOIN CLASS ON ENROLL.CLASS_CODE = CLASS.CLASS_CODE \nWHERE ENROLL.ENROLL_GRADE = 'C';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students enrolled in classes associated with a specific course code and who have received a particular grade. The placeholders in the WHERE clause represent the course code and the grade received by the students.\",\n    \"1\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the name of the department.\"\n}\n"}
{"sample_id": "train.3273", "db_id": "college_1", "question": "What are the first names of the professors who do not teach a class.", "rationale": ["Identify the relevant tables: We need to find professors from the EMPLOYEE table who do not teach any classes, which are listed in the CLASS table.", "Determine the relationship: The CLASS table has a column PROF_NUM that links to the EMP_NUM in the EMPLOYEE table, indicating which professors teach which classes.", "Construct the subquery: We will create a subquery that selects all PROF_NUM from the CLASS table to identify professors who are teaching classes.", "Use the NOT IN clause: We will use the NOT IN clause to filter out professors whose EMP_NUM is present in the list of PROF_NUM from the CLASS table.", "Select the first names: Finally, we will select the first names (EMP_FNAME) of the professors who are not teaching any classes."], "gold_sql": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  'PROF' EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num", "source_tables": ["employee", "class"], "pred_sql": "SELECT EMP_FNAME \nFROM EMPLOYEE \nWHERE EMP_NUM NOT IN (SELECT PROF_NUM FROM CLASS)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first names of employees and the office locations of professors from the 'employee' and 'professor' tables, respectively. It filters the results based on a specific department name and the highest degree obtained by the professors, both represented by placeholders for string values.\",\n    \"1\": \"This virtual table describes the first names of students enrolled in classes associated with a specific course code and who have received a particular grade. The placeholders in the WHERE clause represent the course code and the grade received by the students.\"\n}\n"}
{"sample_id": "train.3274", "db_id": "college_1", "question": "What are the first names of all professors not teaching any classes?", "rationale": ["Identify the tables involved: EMPLOYEE and PROFESSOR.", "We need to find professors who are not teaching any classes, so we will look for professors in the PROFESSOR table.", "We will use a subquery to find all professors who are teaching classes by checking the CLASS table.", "The main query will select the first names of employees from the EMPLOYEE table where the employee number is in the PROFESSOR table but not in the CLASS table."], "gold_sql": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  'PROF' EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num", "source_tables": ["employee", "class"], "pred_sql": "SELECT EMP_FNAME FROM EMPLOYEE WHERE EMP_NUM IN (SELECT PROF_NUM FROM PROFESSOR) AND EMP_NUM NOT IN (SELECT PROF_NUM FROM CLASS)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first names of employees and the office locations of professors from the 'employee' and 'professor' tables, respectively. It filters the results based on a specific department name and the highest degree obtained by the professors, both represented by placeholders for string values.\"\n}\n"}
{"sample_id": "train.3288", "db_id": "college_1", "question": "How many professors attained either Ph.D. or Masters degrees?", "rationale": ["Identify the relevant table: The PROFESSOR table contains information about professors, including their highest degree obtained.", "Determine the criteria: We need to count professors who have either a Ph.D. or a Masters degree.", "Construct the SQL query: Use the COUNT function to count the number of professors that meet the criteria, filtering with a WHERE clause that checks if the PROF_HIGH_DEGREE is either 'Ph.D.' or 'Masters'."], "gold_sql": "SELECT count(*) FROM professor WHERE prof_high_degree  =  'Ph.D.' OR prof_high_degree  =  'MA'", "source_tables": ["professor"], "pred_sql": "SELECT COUNT(*) AS NumberOfProfessors\nFROM PROFESSOR\nWHERE PROF_HIGH_DEGREE IN ('Ph.D.', 'Masters');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first names of employees and the office locations of professors from the 'employee' and 'professor' tables, respectively. It filters the results based on a specific department name and the highest degree obtained by the professors, both represented by placeholders for string values.\"\n}\n"}
{"sample_id": "train.3293", "db_id": "college_1", "question": "Find the first name of student who is taking classes from accounting and Computer Info. Systems departments", "rationale": ["Identify the tables needed: STUDENT, CLASS, ENROLL, COURSE, and DEPARTMENT.", "Join the STUDENT table with the ENROLL table to get the classes each student is enrolled in.", "Join the CLASS table with the COURSE table to get the department information for each class.", "Use the DEPARTMENT table to filter classes by department names: 'Accounting' and 'Computer Info. Systems'.", "Use the INTERSECT operation to find students who are enrolled in classes from both departments.", "Select the distinct first names of students who meet the criteria."], "gold_sql": "SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Accounting' INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Computer Info. Systems'", "source_tables": ["course", "enroll", "department", "class", "student"], "pred_sql": "SELECT DISTINCT STUDENT.STU_FNAME \nFROM STUDENT \nJOIN CLASS ON STUDENT.STU_NUM = ENROLL.STU_NUM \nJOIN ENROLL ON CLASS.CLASS_CODE = ENROLL.CLASS_CODE \nJOIN COURSE ON CLASS.CRS_CODE = COURSE.CRS_CODE \nJOIN DEPARTMENT AS D1 ON COURSE.DEPT_CODE = D1.DEPT_CODE \nJOIN DEPARTMENT AS D2 ON COURSE.DEPT_CODE = D2.DEPT_CODE \nWHERE D1.DEPT_NAME = 'Accounting' \nINTERSECT \nSELECT DISTINCT STUDENT.STU_FNAME \nFROM STUDENT \nJOIN CLASS ON STUDENT.STU_NUM = ENROLL.STU_NUM \nJOIN ENROLL ON CLASS.CLASS_CODE = ENROLL.CLASS_CODE \nJOIN COURSE ON CLASS.CRS_CODE = COURSE.CRS_CODE \nJOIN DEPARTMENT AS D3 ON COURSE.DEPT_CODE = D3.DEPT_CODE \nWHERE D3.DEPT_NAME = 'Computer Info. Systems';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the name of the department.\",\n    \"1\": \"This virtual table provides a distinct list of first names of employees and their highest degrees from the 'CLASS', 'EMPLOYEE', 'PROFESSOR', and 'DEPARTMENT' tables. The results are filtered based on a specific department name provided as a placeholder.\",\n    \"2\": \"This virtual table describes the first names of students enrolled in classes associated with a specific course code and who have received a particular grade. The placeholders in the WHERE clause represent the course code and the grade received by the students.\"\n}\n"}
{"sample_id": "train.3300", "db_id": "college_1", "question": "What is the name of the department with the student that has the lowest GPA?", "rationale": ["Identify the relevant tables: STUDENT and DEPARTMENT are needed to find the department name associated with the student.", "We need to find the student with the lowest GPA, which requires a subquery to get the minimum GPA from the STUDENT table.", "Join the STUDENT table with the DEPARTMENT table on the DEPT_CODE to access the department name for the student.", "Select the DEPT_NAME from the DEPARTMENT table where the GPA of the student matches the minimum GPA found in the subquery."], "gold_sql": "SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT 1", "source_tables": ["department", "student"], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME \nFROM STUDENT \nJOIN DEPARTMENT ON STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE \nWHERE STUDENT.STU_GPA = (SELECT MIN(STU_GPA) FROM STUDENT);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the name of the department.\",\n    \"1\": \"This virtual table describes the first names of students enrolled in classes associated with a specific course code and who have received a particular grade. The placeholders in the WHERE clause represent the course code and the grade received by the students.\",\n    \"2\": \"This virtual table provides a distinct list of first names of employees and their highest degrees from the 'CLASS', 'EMPLOYEE', 'PROFESSOR', and 'DEPARTMENT' tables. The results are filtered based on a specific department name provided as a placeholder.\"\n}\n"}
{"sample_id": "train.3314", "db_id": "college_1", "question": "What are the first names, office locations of all lecturers who have taught some course?", "rationale": ["Identify the tables needed: EMPLOYEE for first names and PROFESSOR for office locations.", "Join the EMPLOYEE and PROFESSOR tables on the common key EMP_NUM to get the relevant data.", "Select the first names (EMP_FNAME) from the EMPLOYEE table and office locations (PROF_OFFICE) from the PROFESSOR table."], "gold_sql": "SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num", "source_tables": ["course", "employee", "professor", "class"], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME, PROFESSOR.PROF_OFFICE \nFROM EMPLOYEE \nJOIN PROFESSOR ON EMPLOYEE.EMP_NUM = PROFESSOR.EMP_NUM;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first names of employees and the office locations of professors from the 'employee' and 'professor' tables, respectively. It filters the results based on a specific department name and the highest degree obtained by the professors, both represented by placeholders for string values.\",\n    \"1\": \"This virtual table describes the first names of students enrolled in classes associated with a specific course code and who have received a particular grade. The placeholders in the WHERE clause represent the course code and the grade received by the students.\"\n}\n"}
{"sample_id": "train.3315", "db_id": "college_1", "question": "Find the first names and offices of all instructors who have taught some course and the course description and the department name.", "rationale": ["Identify the required fields: first names of instructors (from EMPLOYEE), their office locations (from PROFESSOR), course descriptions (from COURSE), and department names (from DEPARTMENT).", "Determine the relationships between the tables: EMPLOYEE is linked to PROFESSOR through EMP_NUM, PROFESSOR is linked to CLASS through PROF_NUM, CLASS is linked to COURSE through CRS_CODE, and COURSE is linked to DEPARTMENT through DEPT_CODE.", "Construct the SQL query using JOINs to connect these tables based on their relationships, ensuring to select the required fields."], "gold_sql": "SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description ,  T5.dept_name FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num JOIN department AS T5 ON T4.dept_code  =  T5.dept_code", "source_tables": ["course", "department", "professor", "class", "employee"], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME, PROFESSOR.PROF_OFFICE, COURSE.CRS_DESCRIPTION, DEPARTMENT.DEPT_NAME \nFROM EMPLOYEE \nJOIN PROFESSOR ON EMPLOYEE.EMP_NUM = PROFESSOR.EMP_NUM \nJOIN CLASS ON PROFESSOR.EMP_NUM = CLASS.PROF_NUM \nJOIN COURSE ON CLASS.CRS_CODE = COURSE.CRS_CODE \nJOIN DEPARTMENT ON COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first names of employees and the office locations of professors from the 'employee' and 'professor' tables, respectively. It filters the results based on a specific department name and the highest degree obtained by the professors, both represented by placeholders for string values.\",\n    \"1\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the name of the department.\",\n    \"2\": \"This virtual table provides a distinct list of first names of employees and their highest degrees from the 'CLASS', 'EMPLOYEE', 'PROFESSOR', and 'DEPARTMENT' tables. The results are filtered based on a specific department name provided as a placeholder.\"\n}\n"}
{"sample_id": "train.3333", "db_id": "college_1", "question": "Find the name of department that offers the class whose description has the word \"Statistics\".", "rationale": ["Identify the relevant tables: DEPARTMENT, COURSE, and CLASS are needed to find the department offering a class with a specific description.", "Join the DEPARTMENT table with the COURSE table on DEPT_CODE to link courses to their respective departments.", "Join the COURSE table with the CLASS table on CRS_CODE to link classes to their respective courses.", "Use a subquery to filter classes based on the description containing the word 'Statistics'.", "Select the distinct department names from the DEPARTMENT table that are associated with the classes found in the subquery."], "gold_sql": "SELECT T2.dept_name FROM course AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.crs_description LIKE '%Statistics%'", "source_tables": ["course", "department"], "pred_sql": "SELECT DISTINCT DEPARTMENT.DEPT_NAME \nFROM DEPARTMENT \nJOIN COURSE ON DEPARTMENT.DEPT_CODE = COURSE.DEPT_CODE \nJOIN CLASS ON COURSE.CRS_CODE = CLASS.CRS_CODE \nWHERE CLASS.CLASS_CODE IN (\n    SELECT CLASS.CLASS_CODE \n    FROM CLASS \n    JOIN COURSE ON CLASS.CRS_CODE = COURSE.CRS_CODE \n    WHERE COURSE.CRS_DESCRIPTION LIKE '%Statistics%'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a distinct list of first names of employees and their highest degrees from the 'CLASS', 'EMPLOYEE', 'PROFESSOR', and 'DEPARTMENT' tables. The results are filtered based on a specific department name provided as a placeholder.\",\n    \"1\": \"This virtual table provides a list of department names from the 'DEPARTMENT' table, which are associated with courses from the 'COURSE' table. The query joins the 'COURSE' and 'CLASS' tables to link courses to their respective classes, and then joins the 'DEPARTMENT' table to retrieve the department names. The results are grouped by department code and ordered by the total sum of credit hours for the courses in descending order, with a limit on the number of departments returned as specified by a placeholder.\",\n    \"2\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the name of the department.\"\n}\n"}
{"sample_id": "train.3417", "db_id": "hr_1", "question": "display the full name (first and last), hire date, salary, and department number for those employees whose first name does not containing the letter M.", "rationale": ["Identify the required fields: full name (first and last), hire date, salary, and department number.", "To get the full name, concatenate the FIRST_NAME and LAST_NAME fields.", "The hire date and salary are directly taken from the employees table.", "The department number is represented by the DEPARTMENT_ID field in the employees table.", "The condition specifies that the first name should not contain the letter 'M', which can be checked using the NOT LIKE operator with a wildcard."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%'", "source_tables": ["employees"], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, HIRE_DATE, SALARY, DEPARTMENT_ID \nFROM employees \nWHERE FIRST_NAME NOT LIKE '%M%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.\",\n    \"1\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\"\n}\n"}
{"sample_id": "train.3418", "db_id": "hr_1", "question": "What are the full name, hire date, salary, and department id for employees without the letter M in their first name?", "rationale": ["Identify the required fields: full name (first and last), hire date, salary, and department id.", "To get the full name, concatenate the FIRST_NAME and LAST_NAME fields with a space in between.", "The data is sourced from the 'employees' table, which contains all the necessary fields.", "Filter the results to exclude employees whose first name contains the letter 'M' using the NOT LIKE operator."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%'", "source_tables": ["employees"], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, HIRE_DATE, SALARY, DEPARTMENT_ID \nFROM employees \nWHERE FIRST_NAME NOT LIKE '%M%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n    \"1\": \"This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.\",\n    \"2\": \"The virtual table describes the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables.\"\n}\n"}
{"sample_id": "train.3419", "db_id": "hr_1", "question": "display the full name (first and last), hire date, salary, and department number for those employees whose first name does not containing the letter M and make the result set in ascending order by department number.", "rationale": ["Identify the required fields: full name (first and last), hire date, salary, and department number.", "To get the full name, concatenate FIRST_NAME and LAST_NAME with a space in between.", "Filter employees whose first name does not contain the letter 'M'. This can be done using the NOT LIKE operator with a wildcard.", "Sort the results in ascending order by department number, which corresponds to the DEPARTMENT_ID column.", "Construct the SQL SELECT statement with the identified fields, filtering condition, and ordering clause."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, HIRE_DATE, SALARY, DEPARTMENT_ID \nFROM employees \nWHERE FIRST_NAME NOT LIKE '%M%' \nORDER BY DEPARTMENT_ID ASC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.\",\n    \"1\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\"\n}\n"}
{"sample_id": "train.3442", "db_id": "hr_1", "question": "Which job titles correspond to jobs with salaries over 9000?", "rationale": ["Identify the relevant table: The question pertains to job titles and salaries, so we will focus on the 'jobs' table.", "Determine the condition: We need to find jobs with salaries over 9000, which refers to the 'MAX_SALARY' column in the 'jobs' table.", "Construct the SQL query: We will select the 'JOB_TITLE' from the 'jobs' table where the 'MAX_SALARY' is greater than 9000."], "gold_sql": "SELECT job_title FROM jobs WHERE min_salary  >  9000", "source_tables": ["jobs"], "pred_sql": "SELECT JOB_TITLE FROM jobs WHERE MAX_SALARY > 9000;", "hint": "\n"}
{"sample_id": "train.3444", "db_id": "hr_1", "question": "What are the job titles, and range of salaries for jobs with maximum salary between 12000 and 18000?", "rationale": ["Identify the relevant table: The question asks for job titles and salary ranges, which are found in the 'jobs' table.", "Determine the columns needed: We need 'JOB_TITLE', 'MIN_SALARY', and 'MAX_SALARY' from the 'jobs' table.", "Apply the filter condition: The question specifies that we need jobs with a maximum salary between 12000 and 18000, so we will use a WHERE clause with the BETWEEN operator to filter the results accordingly."], "gold_sql": "SELECT job_title ,  max_salary - min_salary FROM jobs WHERE max_salary BETWEEN 12000 AND 18000", "source_tables": ["jobs"], "pred_sql": "SELECT JOB_TITLE, MIN_SALARY, MAX_SALARY \nFROM jobs \nWHERE MAX_SALARY BETWEEN 12000 AND 18000;", "hint": "\n"}
{"sample_id": "train.3448", "db_id": "hr_1", "question": "What are the employee ids for each employee and final dates of employment at their last job?", "rationale": ["We need to find the employee IDs and the final dates of employment at their last job.", "The relevant tables are 'employees' and 'job_history'.", "We will join the 'employees' table with the 'job_history' table on the EMPLOYEE_ID column.", "To get the final date of employment, we need to find the maximum END_DATE for each employee in the job_history table.", "The SQL query will select the EMPLOYEE_ID from the employees table and the maximum END_DATE from the job_history table, ensuring we only get the last job's end date for each employee."], "gold_sql": "SELECT employee_id ,  MAX(end_date) FROM job_history GROUP BY employee_id", "source_tables": ["job_history"], "pred_sql": "SELECT e.EMPLOYEE_ID, j.END_DATE\nFROM employees e\nJOIN job_history j ON e.EMPLOYEE_ID = j.EMPLOYEE_ID\nWHERE j.END_DATE = (SELECT MAX(END_DATE) FROM job_history WHERE EMPLOYEE_ID = e.EMPLOYEE_ID);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n    \"1\": \"The virtual table describes the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables.\"\n}\n"}
{"sample_id": "train.3451", "db_id": "hr_1", "question": "Find the ids of the departments where any manager is managing 4 or more employees.", "rationale": ["Identify the departments and their managers from the 'departments' table.", "Join the 'departments' table with the 'employees' table to link employees to their respective departments.", "Use a subquery to find managers who manage 4 or more employees by grouping the employees by their MANAGER_ID and counting the number of employees for each manager.", "Filter the departments based on the managers identified in the subquery."], "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"], "pred_sql": "SELECT d.DEPARTMENT_ID\nFROM departments d\nJOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID\nWHERE d.MANAGER_ID IN (\n    SELECT e2.MANAGER_ID\n    FROM employees e2\n    GROUP BY e2.MANAGER_ID\n    HAVING COUNT(e2.EMPLOYEE_ID) >= 4\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\"\n}\n"}
{"sample_id": "train.3457", "db_id": "hr_1", "question": "display job ID for those jobs that were done by two or more for more than 300 days.", "rationale": ["Identify the relevant tables: job_history for job records and employees for employee details.", "We need to find jobs that were held for more than 300 days, so we will calculate the difference between START_DATE and END_DATE in the job_history table.", "We need to group the results by JOB_ID to count how many employees held each job.", "We will use the HAVING clause to filter groups where the count of employees is 2 or more.", "Finally, we will select the JOB_ID from the filtered results."], "gold_sql": "SELECT job_id FROM job_history WHERE end_date - start_date  > 300 GROUP BY job_id HAVING COUNT(*) >= 2", "source_tables": ["job_history"], "pred_sql": "SELECT j.JOB_ID\nFROM job_history j\nJOIN employees e ON j.EMPLOYEE_ID = e.EMPLOYEE_ID\nWHERE (j.END_DATE - j.START_DATE) > 300\nGROUP BY j.JOB_ID\nHAVING COUNT(e.EMPLOYEE_ID) >= 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\"\n}\n"}
{"sample_id": "train.3458", "db_id": "hr_1", "question": "What are the job ids for jobs done more than once for a period of more than 300 days?", "rationale": ["We need to find job IDs for jobs that have been done more than once by employees.", "To do this, we will use the job_history table, which records the job history of employees.", "We will join the job_history table with itself to find instances where the same employee has the same job ID.", "The join condition will be on EMPLOYEE_ID and JOB_ID to ensure we are comparing the same job for the same employee.", "We will also need to check that the period between the two job records is more than 300 days.", "This can be done by comparing the START_DATE of the second record with the END_DATE of the first record.", "We will group the results by JOB_ID and use HAVING to filter for those job IDs that appear more than once."], "gold_sql": "SELECT job_id FROM job_history WHERE end_date - start_date  > 300 GROUP BY job_id HAVING COUNT(*) >= 2", "source_tables": ["job_history"], "pred_sql": "SELECT j1.JOB_ID\nFROM job_history j1\nJOIN job_history j2 ON j1.EMPLOYEE_ID = j2.EMPLOYEE_ID AND j1.JOB_ID = j2.JOB_ID\nWHERE j1.START_DATE < j2.START_DATE\nAND (j2.END_DATE - j1.START_DATE) > 300\nGROUP BY j1.JOB_ID\nHAVING COUNT(*) > 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\"\n}\n"}
{"sample_id": "train.3463", "db_id": "hr_1", "question": "display the department name and number of employees in each of the department.", "rationale": ["We need to display the department name and the number of employees in each department.", "To get the department name, we will select it from the 'departments' table.", "To count the number of employees in each department, we will use the COUNT() function on the 'EMPLOYEE_ID' from the 'employees' table.", "We will join the 'departments' table with the 'employees' table on the 'DEPARTMENT_ID' to link employees to their respective departments.", "Since some departments may not have any employees, we will use a LEFT JOIN to ensure all departments are included in the result.", "Finally, we will group the results by department name to get the count of employees per department."], "gold_sql": "SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name", "source_tables": ["employees", "departments"], "pred_sql": "SELECT d.DEPARTMENT_NAME, COUNT(e.EMPLOYEE_ID) AS NUMBER_OF_EMPLOYEES\nFROM departments d\nLEFT JOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID\nGROUP BY d.DEPARTMENT_NAME;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\"\n}\n"}
{"sample_id": "train.3470", "db_id": "hr_1", "question": "Provide the full names of employees earning more than the employee with id 163.", "rationale": ["Identify the main table to query: 'employees' for employee names and salaries.", "We need to select the first and last names of employees, so we will use 'FIRST_NAME' and 'LAST_NAME' columns from the 'employees' table.", "To find employees earning more than the employee with ID 163, we need a subquery that retrieves the salary of that specific employee.", "The subquery will select the salary from the 'employees' table where the EMPLOYEE_ID is 163.", "The main query will filter employees whose salary is greater than the result of the subquery."], "gold_sql": "SELECT first_name ,  last_name FROM employees WHERE salary  >  (SELECT salary FROM employees WHERE employee_id = 163 )", "source_tables": ["employees"], "pred_sql": "SELECT e.FIRST_NAME, e.LAST_NAME \nFROM employees e \nWHERE e.SALARY > (SELECT e2.SALARY FROM employees e2 WHERE e2.EMPLOYEE_ID = '163');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n    \"1\": \"This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.\"\n}\n"}
{"sample_id": "train.3471", "db_id": "hr_1", "question": "return the smallest salary for every departments.", "rationale": ["We need to return the smallest salary for every department.", "To achieve this, we will select the department name and the minimum salary from the employees.", "We will join the 'departments' table with the 'employees' table on the 'DEPARTMENT_ID' column to link employees to their respective departments.", "We will use the MIN() function to find the smallest salary for each department.", "Finally, we will group the results by the department name to ensure we get the minimum salary for each department."], "gold_sql": "SELECT MIN(salary) ,  department_id FROM employees GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT d.DEPARTMENT_NAME, MIN(e.SALARY) AS MIN_SALARY\nFROM departments d\nJOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID\nGROUP BY d.DEPARTMENT_NAME;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.\"\n}\n"}
{"sample_id": "train.3472", "db_id": "hr_1", "question": "What is the minimum salary in each department?", "rationale": ["We need to find the minimum salary in each department.", "To do this, we will select the department name and the minimum salary.", "The relevant tables are 'departments' and 'employees'.", "We will join these two tables on the DEPARTMENT_ID column, which is common to both tables.", "We will use the MIN() function to calculate the minimum salary for each department.", "Finally, we will group the results by department name to get the minimum salary for each department."], "gold_sql": "SELECT MIN(salary) ,  department_id FROM employees GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT d.DEPARTMENT_NAME, MIN(e.SALARY) AS MIN_SALARY\nFROM departments d\nJOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID\nGROUP BY d.DEPARTMENT_NAME;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.\"\n}\n"}
{"sample_id": "train.3482", "db_id": "hr_1", "question": "What is all the information regarding employees who are managers?", "rationale": ["Identify the tables involved: employees, departments, locations, and countries.", "Select all columns from the employees table (e.*) to get all information regarding employees.", "Join the departments table to get department names using the DEPARTMENT_ID.", "Join the locations table to get the city and state/province of the department's location using LOCATION_ID.", "Join the countries table to get the country name using COUNTRY_ID.", "Filter the results to include only those employees who are managers by checking if their EMPLOYEE_ID exists in the MANAGER_ID column of the employees table."], "gold_sql": "SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T1.employee_id  =  T2.manager_id", "source_tables": ["employees", "departments"], "pred_sql": "SELECT e.*, d.DEPARTMENT_NAME, l.CITY, l.STATE_PROVINCE, c.COUNTRY_NAME \nFROM employees e \nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nJOIN locations l ON d.LOCATION_ID = l.LOCATION_ID \nJOIN countries c ON l.COUNTRY_ID = c.COUNTRY_ID \nWHERE e.EMPLOYEE_ID IN (SELECT DISTINCT MANAGER_ID FROM employees WHERE MANAGER_ID IS NOT NULL);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n    \"1\": \"The virtual table describes the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables.\",\n    \"2\": \"This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.\"\n}\n"}
{"sample_id": "train.3488", "db_id": "hr_1", "question": "Give the distinct department ids of departments in which a manager is in charge of 4 or more employees?", "rationale": ["We need to find distinct department IDs where a manager oversees 4 or more employees.", "To do this, we will first identify managers who have 4 or more employees reporting to them. This can be done by grouping the employees by their MANAGER_ID and counting the number of employees for each manager.", "We will use a subquery to get the MANAGER_IDs that have 4 or more employees.", "Next, we will join the departments table with the employees table to link departments with their respective employees.", "Finally, we will select the distinct DEPARTMENT_IDs from the departments where the MANAGER_ID is in the list of managers identified in the subquery."], "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"], "pred_sql": "SELECT DISTINCT d.DEPARTMENT_ID\nFROM departments d\nJOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID\nWHERE d.MANAGER_ID IN (\n    SELECT e2.MANAGER_ID\n    FROM employees e2\n    GROUP BY e2.MANAGER_ID\n    HAVING COUNT(e2.EMPLOYEE_ID) >= 4\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\"\n}\n"}
{"sample_id": "train.3497", "db_id": "hr_1", "question": "Find the ids of the employees who does not work in those departments where some employees works whose manager id within the range 100 and 200.", "rationale": ["Identify the main requirement: Find employee IDs who do not work in certain departments.", "Determine the departments to exclude: These are the departments where employees have a manager ID between 100 and 200.", "Construct a subquery to find the department IDs that meet the manager ID condition: SELECT DISTINCT DEPARTMENT_ID FROM employees WHERE MANAGER_ID BETWEEN '100' AND '200'.", "Use the NOT IN clause to filter out these department IDs from the main query: SELECT EMPLOYEE_ID FROM employees WHERE DEPARTMENT_ID NOT IN (subquery).", "Combine the subquery with the main query to form the complete SQL statement."], "gold_sql": "SELECT * FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN 100 AND 200)", "source_tables": ["employees", "departments"], "pred_sql": "SELECT EMPLOYEE_ID FROM employees WHERE DEPARTMENT_ID NOT IN (SELECT DISTINCT DEPARTMENT_ID FROM employees WHERE MANAGER_ID BETWEEN '100' AND '200');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\"\n}\n"}
{"sample_id": "train.3502", "db_id": "hr_1", "question": "What are the full names and hire dates for employees in the same department as someone with the first name Clara, not including Clara?", "rationale": ["Identify the requirement: We need the full names and hire dates of employees who work in the same department as an employee named Clara, excluding Clara herself.", "To get the full names, we will concatenate the first and last names of the employees.", "We need to join the employees table with itself to find employees in the same department as Clara. This is done by matching the DEPARTMENT_ID of both employee records.", "We will filter the results to only include those employees whose first name is not Clara, while ensuring we only consider those in the same department as Clara."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  ( SELECT department_id FROM employees WHERE first_name  =  'Clara') AND first_name != 'Clara'", "source_tables": ["employees"], "pred_sql": "SELECT e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.HIRE_DATE \nFROM employees e \nJOIN employees c ON e.DEPARTMENT_ID = c.DEPARTMENT_ID \nWHERE c.FIRST_NAME = 'Clara' AND e.FIRST_NAME != 'Clara';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.\",\n    \"1\": \"The virtual table describes the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables.\",\n    \"2\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\"\n}\n"}
{"sample_id": "train.3506", "db_id": "hr_1", "question": "What are the ids, full names, and salaries for employees making more than average and who work in a department with employees who have the letter J in their first name?", "rationale": ["Identify the required fields: employee IDs, full names (first and last), and salaries.", "Calculate the average salary using a subquery: SELECT AVG(SALARY) FROM employees.", "Filter employees whose salary is greater than the average salary.", "Identify departments that have employees with 'J' in their first name using a subquery that joins employees and departments.", "Use the IN clause to filter employees based on the department IDs obtained from the previous step."], "gold_sql": "SELECT employee_id ,  first_name ,  last_name ,  salary FROM employees WHERE salary  >  ( SELECT AVG (salary) FROM employees ) AND department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE '%J%')", "source_tables": ["employees"], "pred_sql": "SELECT e.EMPLOYEE_ID, e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.SALARY \nFROM employees e \nWHERE e.SALARY > (SELECT AVG(SALARY) FROM employees) \nAND e.DEPARTMENT_ID IN (SELECT DISTINCT d.DEPARTMENT_ID \n                        FROM employees emp \n                        JOIN departments d ON emp.DEPARTMENT_ID = d.DEPARTMENT_ID \n                        WHERE emp.FIRST_NAME LIKE '%J%');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.\",\n    \"1\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\"\n}\n"}
{"sample_id": "train.3507", "db_id": "hr_1", "question": "display the employee number and job id for all employees whose salary is smaller than any salary of those employees whose job title is MK_MAN.", "rationale": ["Identify the main requirement: We need to display the employee number (EMPLOYEE_ID) and job id (JOB_ID) for employees whose salary is less than any salary of employees with the job title 'MK_MAN'.", "To achieve this, we will use a subquery to find the minimum salary of employees with the job title 'MK_MAN'.", "The subquery will join the 'employees' table with the 'jobs' table to filter employees based on the job title.", "The main query will select the EMPLOYEE_ID and JOB_ID from the 'employees' table where the salary is less than the result of the subquery."], "gold_sql": "SELECT employee_id ,  job_id FROM employees WHERE salary  <  ( SELECT min(salary) FROM employees WHERE job_id  =  'MK_MAN' )", "source_tables": ["employees"], "pred_sql": "SELECT EMPLOYEE_ID, JOB_ID \nFROM employees \nWHERE SALARY < (SELECT MIN(SALARY) \n                  FROM employees e \n                  JOIN jobs j ON e.JOB_ID = j.JOB_ID \n                  WHERE j.JOB_TITLE = 'MK_MAN');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.\"\n}\n"}
{"sample_id": "train.3510", "db_id": "hr_1", "question": "What are the employee ids, full names, and job ids for employees who make more than the highest earning employee with title PU_MAN?", "rationale": ["Identify the columns needed: employee ids, full names (first and last), and job ids.", "To get the full names, concatenate the FIRST_NAME and LAST_NAME columns with a space in between.", "Filter employees based on their salary being greater than the highest salary of employees with the job title 'PU_MAN'.", "Use a subquery to find the maximum salary of employees with the job title 'PU_MAN'.", "Join the employees table with the jobs table to access the job title for filtering."], "gold_sql": "SELECT employee_id ,  first_name ,  last_name ,  job_id FROM employees WHERE salary  >  ( SELECT max(salary) FROM employees WHERE job_id  =  'PU_MAN' )", "source_tables": ["employees"], "pred_sql": "SELECT EMPLOYEE_ID, FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, JOB_ID \nFROM employees \nWHERE SALARY > (SELECT MAX(SALARY) \n                 FROM employees \n                 JOIN jobs ON employees.JOB_ID = jobs.JOB_ID \n                 WHERE JOB_TITLE = 'PU_MAN');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\"\n}\n"}
{"sample_id": "train.3512", "db_id": "hr_1", "question": "What are total salaries and department id for each department that has more than 2 employees?", "rationale": ["We need to find the total salaries and department IDs for departments with more than 2 employees.", "To do this, we will use the 'employees' table to get employee salaries and the 'departments' table to get department IDs.", "We will join the 'employees' table with the 'departments' table on the DEPARTMENT_ID column to associate employees with their respective departments.", "Next, we will group the results by DEPARTMENT_ID to calculate the total salary for each department using the SUM function.", "We will also count the number of employees in each department using the COUNT function.", "Finally, we will filter the results using the HAVING clause to include only those departments that have more than 2 employees."], "gold_sql": "SELECT department_id ,  SUM(salary) FROM employees GROUP BY department_id HAVING count(*)  >=  2", "source_tables": ["employees"], "pred_sql": "SELECT d.DEPARTMENT_ID, SUM(e.SALARY) AS total_salaries\nFROM employees e\nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID\nGROUP BY d.DEPARTMENT_ID\nHAVING COUNT(e.EMPLOYEE_ID) > 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n    \"1\": \"This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.\"\n}\n"}
{"sample_id": "train.3515", "db_id": "hr_1", "question": "display the department ID, full name (first and last name), salary for those employees who is highest salary in every department.", "rationale": ["We need to display the department ID, full name, and salary of employees with the highest salary in each department.", "To get the full name, we can concatenate the first name and last name of the employee using '||' operator.", "We will select the department ID and the concatenated full name as 'FULL_NAME'.", "To find the highest salary in each department, we can use a subquery that selects the maximum salary from the employees table, grouped by department ID.", "The main query will filter employees whose salary matches the maximum salary for their respective department."], "gold_sql": "SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT e.DEPARTMENT_ID, e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.SALARY \nFROM employees e \nWHERE e.SALARY = (SELECT MAX(SALARY) \n                  FROM employees \n                  WHERE DEPARTMENT_ID = e.DEPARTMENT_ID)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.\"\n}\n"}
{"sample_id": "train.3516", "db_id": "hr_1", "question": "What are the department ids, full names, and salaries for employees who make the most in their departments?", "rationale": ["We need to find the department ids, full names, and salaries of employees who make the most in their departments.", "To do this, we will select the DEPARTMENT_ID, concatenate FIRST_NAME and LAST_NAME to get the FULL_NAME, and select the SALARY from the employees table.", "We will use a subquery to find the maximum salary for each department. The subquery will select the maximum salary from the employees table where the DEPARTMENT_ID matches the current employee's DEPARTMENT_ID.", "The main query will filter employees to only include those whose salary matches the maximum salary found in the subquery."], "gold_sql": "SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT e.DEPARTMENT_ID, e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.SALARY \nFROM employees e \nWHERE e.SALARY = (SELECT MAX(SALARY) \n                  FROM employees \n                  WHERE DEPARTMENT_ID = e.DEPARTMENT_ID)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.\",\n    \"1\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\"\n}\n"}
{"sample_id": "train.3520", "db_id": "hr_1", "question": "What are the full names and cities of employees who have the letter Z in their first names?", "rationale": ["Identify the tables needed: 'employees' for names, 'departments' for department IDs, and 'locations' for city names.", "Join the 'employees' table with the 'departments' table on 'DEPARTMENT_ID' to get department information.", "Join the resulting table with the 'locations' table on 'LOCATION_ID' to get city information.", "Filter the results to include only those employees whose first names contain the letter 'Z' using the LIKE operator."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T3.city FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id WHERE T1.first_name LIKE '%z%'", "source_tables": ["employees", "departments", "locations"], "pred_sql": "SELECT e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, l.CITY \nFROM employees e \nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nJOIN locations l ON d.LOCATION_ID = l.LOCATION_ID \nWHERE e.FIRST_NAME LIKE '%Z%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.\",\n    \"1\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n    \"2\": \"The virtual table describes the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables.\"\n}\n"}
{"sample_id": "train.3523", "db_id": "hr_1", "question": "display the full name (first and last name ) of employee with ID and name of the country presently where (s)he is working.", "rationale": ["Identify the tables needed: employees, departments, locations, and countries.", "Determine the relationships between the tables: employees are linked to departments, departments to locations, and locations to countries.", "Select the required fields: first name and last name from employees, and country name from countries.", "Use JOIN clauses to connect the tables based on their foreign key relationships.", "Add a WHERE clause to filter the results for a specific employee ID."], "gold_sql": "SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id", "source_tables": ["countries", "employees", "departments", "locations"], "pred_sql": "SELECT e.FIRST_NAME, e.LAST_NAME, c.COUNTRY_NAME \nFROM employees e \nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nJOIN locations l ON d.LOCATION_ID = l.LOCATION_ID \nJOIN countries c ON l.COUNTRY_ID = c.COUNTRY_ID \nWHERE e.EMPLOYEE_ID = ?;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n    \"1\": \"This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.\",\n    \"2\": \"The virtual table describes the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables.\"\n}\n"}
{"sample_id": "train.3525", "db_id": "hr_1", "question": "display the department name and number of employees in each of the department.", "rationale": ["We need to display the department name and the number of employees in each department.", "To get the department name, we will select it from the 'departments' table.", "To count the number of employees in each department, we will use the COUNT function on the 'EMPLOYEE_ID' from the 'employees' table.", "We will join the 'departments' table with the 'employees' table on the 'DEPARTMENT_ID' to link employees to their respective departments.", "Since some departments may not have any employees, we will use a LEFT JOIN to ensure all departments are included in the result.", "Finally, we will group the results by the department name to get the count of employees for each department."], "gold_sql": "SELECT department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY department_name", "source_tables": ["employees", "departments"], "pred_sql": "SELECT d.DEPARTMENT_NAME, COUNT(e.EMPLOYEE_ID) AS NUMBER_OF_EMPLOYEES\nFROM departments d\nLEFT JOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID\nGROUP BY d.DEPARTMENT_NAME;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\"\n}\n"}
{"sample_id": "train.3526", "db_id": "hr_1", "question": "What are the department names and how many employees work in each of them?", "rationale": ["We need to retrieve the names of departments and the count of employees in each department.", "The relevant tables for this query are 'departments' and 'employees'.", "We will perform a LEFT JOIN between 'departments' and 'employees' on the 'DEPARTMENT_ID' column to ensure we get all departments even if they have no employees.", "We will use the COUNT function to count the number of employees in each department.", "Finally, we will group the results by 'DEPARTMENT_NAME' to get the count for each department."], "gold_sql": "SELECT department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY department_name", "source_tables": ["employees", "departments"], "pred_sql": "SELECT d.DEPARTMENT_NAME, COUNT(e.EMPLOYEE_ID) AS EMPLOYEE_COUNT\nFROM departments d\nLEFT JOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID\nGROUP BY d.DEPARTMENT_NAME;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n    \"1\": \"The virtual table describes the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables.\",\n    \"2\": \"This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.\"\n}\n"}
{"sample_id": "train.3528", "db_id": "hr_1", "question": "What are full names and salaries of employees working in the city of London?", "rationale": ["Identify the tables needed: employees, departments, and locations.", "We need to join these tables to get the full names and salaries of employees.", "The full name can be constructed by concatenating the FIRST_NAME and LAST_NAME from the employees table.", "To filter employees based on the city, we will use the locations table and specifically look for the city 'London'.", "The JOIN conditions will be based on the foreign keys: employees.DEPARTMENT_ID to departments.DEPARTMENT_ID and departments.LOCATION_ID to locations.LOCATION_ID."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  'London'", "source_tables": ["employees", "departments", "locations"], "pred_sql": "SELECT e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.SALARY \nFROM employees e \nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nJOIN locations l ON d.LOCATION_ID = l.LOCATION_ID \nWHERE l.CITY = 'London';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.\",\n    \"1\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n    \"2\": \"The virtual table describes the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables.\"\n}\n"}
{"sample_id": "train.3641", "db_id": "baseball_1", "question": "In 2014, what are the id and rank of the team that has the largest average number of attendance?", "rationale": ["Identify the relevant table: The 'team' table contains the necessary information about teams, including their attendance and rank.", "Filter by year: We need to focus on the year 2014, so we will add a WHERE clause to filter the results for that year.", "Sort by attendance: To find the team with the largest average attendance, we will order the results by the 'attendance' column in descending order.", "Limit the results: Since we only want the team with the largest attendance, we will use LIMIT 1 to get the top result."], "gold_sql": "SELECT T2.team_id ,  T2.rank FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id WHERE T1.year  =  2014 GROUP BY T1.team_id ORDER BY avg(T1.attendance) DESC LIMIT 1;", "source_tables": ["team", "home_game"], "pred_sql": "SELECT team_id, rank FROM team WHERE year = 2014 ORDER BY attendance DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\"\n}\n"}
{"sample_id": "train.3647", "db_id": "baseball_1", "question": "Which 3 players won the most player awards? List their full name and id.", "rationale": ["We need to find players who have won the most awards, so we will use the player_award table which contains the awards won by players.", "We will join the player table to get the full names of the players along with their IDs.", "We will group the results by player ID to count the number of awards each player has won.", "We will order the results in descending order based on the count of awards to get the players with the most awards at the top.", "Finally, we will limit the results to the top 3 players."], "gold_sql": "SELECT T1.name_first ,  T1.name_last ,  T1.player_id FROM player AS T1 JOIN player_award AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.player_id ORDER BY count(*) DESC LIMIT 3;", "source_tables": ["player_award", "player"], "pred_sql": "SELECT p.player_id, p.name_first, p.name_last, COUNT(pa.award_id) AS award_count\nFROM player p\nJOIN player_award pa ON p.player_id = pa.player_id\nGROUP BY p.player_id\nORDER BY award_count DESC\nLIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\"\n}\n"}
{"sample_id": "train.3649", "db_id": "baseball_1", "question": "List three countries which are the origins of the least players.", "rationale": ["Identify the relevant table: The 'player' table contains information about players, including their country of birth.", "Count the number of players from each country: Use COUNT(player_id) to count the number of players grouped by 'birth_country'.", "Group the results by country: Use GROUP BY birth_country to aggregate the counts for each country.", "Order the results to find the least represented countries: Use ORDER BY player_count ASC to sort the countries by the number of players in ascending order.", "Limit the results to the top three countries: Use LIMIT 3 to restrict the output to the three countries with the least players."], "gold_sql": "SELECT birth_country FROM player GROUP BY birth_country ORDER BY count(*) ASC LIMIT 3;", "source_tables": ["player"], "pred_sql": "SELECT birth_country, COUNT(player_id) AS player_count \nFROM player \nGROUP BY birth_country \nORDER BY player_count ASC \nLIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\"\n}\n"}
{"sample_id": "train.3650", "db_id": "baseball_1", "question": "What are the three countries that the least players are from?", "rationale": ["We need to find the countries with the least number of players.", "The relevant table for player information is the 'player' table, which contains the 'birth_country' and 'player_id' columns.", "To count the number of players from each country, we will use the COUNT() function and group the results by 'birth_country'.", "We will order the results in ascending order based on the count of players to get the countries with the least players first.", "Finally, we will limit the results to the top 3 countries using the LIMIT clause."], "gold_sql": "SELECT birth_country FROM player GROUP BY birth_country ORDER BY count(*) ASC LIMIT 3;", "source_tables": ["player"], "pred_sql": "SELECT birth_country, COUNT(player_id) AS player_count\nFROM player\nGROUP BY birth_country\nORDER BY player_count ASC\nLIMIT 3;", "hint": "\n"}
{"sample_id": "train.3651", "db_id": "baseball_1", "question": "Find all the players' first name and last name who have empty death record.", "rationale": ["Identify the relevant table: The 'player' table contains the first and last names of players along with their death records.", "Determine the condition for empty death records: A player has an empty death record if the 'death_year', 'death_month', and 'death_day' fields are all NULL.", "Construct the SQL query: Use a SELECT statement to retrieve 'name_first' and 'name_last' from the 'player' table where the death records are empty."], "gold_sql": "SELECT name_first ,  name_last FROM player WHERE death_year = '';", "source_tables": ["player"], "pred_sql": "SELECT name_first, name_last FROM player WHERE death_year IS NULL AND death_month IS NULL AND death_day IS NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\"\n}\n"}
{"sample_id": "train.3657", "db_id": "baseball_1", "question": "What is the highest salary among each team? List the team name, id and maximum salary.", "rationale": ["We need to find the highest salary for each team, which requires us to aggregate salary data by team.", "The salary table contains the salary records, and the team table contains the team names and IDs.", "To get the maximum salary for each team, we will use the MAX() function on the salary column.", "We will join the salary table with the team table on the team_id to get the team names along with their IDs.", "Finally, we will group the results by team ID and name to ensure we get the maximum salary for each team."], "gold_sql": "SELECT T1.name ,  T1.team_id ,  max(T2.salary) FROM team AS T1 JOIN salary AS T2 ON T1.team_id  =  T2.team_id GROUP BY T1.team_id;", "source_tables": ["team", "salary"], "pred_sql": "SELECT team.name, team.team_id, MAX(salary.salary) AS max_salary\nFROM salary\nJOIN team ON salary.team_id = team.team_id\nGROUP BY team.team_id, team.name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\"\n}\n"}
{"sample_id": "train.3662", "db_id": "baseball_1", "question": "Which players won awards in both 1960 and 1961? Return their first names and last names.", "rationale": ["Identify the relevant tables: player_award for awards and player for player names.", "Join the player_award table to itself to find players who won awards in both 1960 and 1961.", "Join the player table to get the first and last names of the players.", "Filter the results to include only those who won awards in the specified years (1960 and 1961).", "Select the first and last names of the players from the final result."], "gold_sql": "SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1960 INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1961", "source_tables": ["player_award", "player"], "pred_sql": "SELECT p.name_first, p.name_last\nFROM player_award pa1\nJOIN player_award pa2 ON pa1.player_id = pa2.player_id\nJOIN player p ON pa1.player_id = p.player_id\nWHERE pa1.year = 1960 AND pa2.year = 1961;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\"\n}\n"}
{"sample_id": "train.3665", "db_id": "baseball_1", "question": "List the maximum scores of the team Boston Red Stockings when the team won in postseason?", "rationale": ["Identify the relevant tables: postseason and team.", "We need to find the maximum scores (wins) of the team Boston Red Stockings when they won in postseason.", "Join the postseason table with the team table on the winning team ID.", "Filter the results to only include records where the team name is 'Boston Red Stockings'.", "Select the maximum wins from the filtered results."], "gold_sql": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings';", "source_tables": ["postseason", "team"], "pred_sql": "SELECT MAX(p.wins) AS max_wins\nFROM postseason p\nJOIN team t ON p.team_id_winner = t.team_id\nWHERE t.name = 'Boston Red Stockings';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\"\n}\n"}
{"sample_id": "train.3666", "db_id": "baseball_1", "question": "What are the maximum scores the team Boston Red Stockings got when the team won in postseason?", "rationale": ["Identify the relevant tables: postseason and team.", "We need to find the maximum scores (wins) for the team Boston Red Stockings when they won in postseason.", "Join the postseason table with the team table on the winning team ID.", "Filter the results to only include records where the team name is 'Boston Red Stockings'.", "Use the MAX function to get the maximum wins from the filtered results."], "gold_sql": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings';", "source_tables": ["postseason", "team"], "pred_sql": "SELECT MAX(p.wins) AS max_wins\nFROM postseason p\nJOIN team t ON p.team_id_winner = t.team_id\nWHERE t.name = 'Boston Red Stockings'", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\"\n}\n"}
{"sample_id": "train.3669", "db_id": "baseball_1", "question": "What are the name and id of the team with the most victories in 2008 postseason?", "rationale": ["Identify the relevant tables: We need to find the team with the most victories in the postseason for the year 2008, which involves the 'team' and 'postseason' tables.", "Determine the join condition: The 'postseason' table contains the winning team information, and we can join it with the 'team' table using the 'team_id_winner' field.", "Select the required fields: We need the name and id of the team, which are found in the 'team' table as 'name' and 'team_id'.", "Filter the results: We need to filter the results to only include records from the year 2008 in the 'postseason' table.", "Order the results: To find the team with the most victories, we will order the results by the 'wins' column in descending order.", "Limit the results: Since we only want the team with the most victories, we will limit the results to 1."], "gold_sql": "SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  2008 GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["postseason", "team"], "pred_sql": "SELECT team.name, team.team_id \nFROM team \nJOIN postseason ON team.team_id = postseason.team_id_winner \nWHERE postseason.year = 2008 \nORDER BY postseason.wins DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\"\n}\n"}
{"sample_id": "train.3673", "db_id": "baseball_1", "question": "What is the total number of postseason games that team Boston Red Stockings participated in?", "rationale": ["Identify the relevant table for postseason games, which is 'batting_postseason'.", "Determine the column that represents the number of games played in postseason, which is 'g'.", "To find the total number of postseason games for the team 'Boston Red Stockings', we need to filter the records by the team's ID.", "The team ID can be obtained from the 'team' table by filtering for the team name 'Boston Red Stockings'.", "Use a subquery to get the team ID from the 'team' table and sum the 'g' column from the 'batting_postseason' table for that team."], "gold_sql": "SELECT count(*) FROM ( SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' UNION SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' );", "source_tables": ["postseason", "team"], "pred_sql": "SELECT SUM(g) AS total_postseason_games\nFROM batting_postseason\nWHERE team_id = (SELECT team_id FROM team WHERE name = 'Boston Red Stockings')", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\"\n}\n"}
{"sample_id": "train.3678", "db_id": "baseball_1", "question": "What is the total salary expenses of team Boston Red Stockings in 2010?", "rationale": ["Identify the relevant table for salary information, which is the 'salary' table.", "We need to calculate the total salary expenses, so we will use the SUM function on the 'salary' column.", "We need to filter the records for the year 2010, so we will add a WHERE clause for 'year = 2010'.", "To filter by the team 'Boston Red Stockings', we need to find the corresponding 'team_id'. This requires a subquery to select the 'team_id' from the 'team' table where the 'name' is 'Boston Red Stockings'.", "Combine all these conditions in the SQL query to get the total salary expenses for the specified team and year."], "gold_sql": "SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings' AND T1.year  =  2010", "source_tables": ["team", "salary"], "pred_sql": "SELECT SUM(salary) AS total_salary_expenses \nFROM salary \nWHERE year = 2010 AND team_id = (SELECT team_id FROM team WHERE name = 'Boston Red Stockings')", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\"\n}\n"}
{"sample_id": "train.3679", "db_id": "baseball_1", "question": "How many players were in the team Boston Red Stockings in 2000?", "rationale": ["Identify the relevant tables: salary, team, and player.", "We need to count the distinct players associated with the team 'Boston Red Stockings' in the year 2000.", "Join the salary table with the team table on team_id to get the team information for each player's salary record.", "Join the player table to get the player details associated with the salary records.", "Filter the results to only include records for the year 2000 and the team 'Boston Red Stockings'.", "Use COUNT(DISTINCT player.player_id) to get the number of unique players."], "gold_sql": "SELECT count(*) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings' AND T1.year  =  2000", "source_tables": ["team", "salary"], "pred_sql": "SELECT COUNT(DISTINCT player.player_id) AS player_count\nFROM salary\nJOIN team ON salary.team_id = team.team_id\nJOIN player ON salary.player_id = player.player_id\nWHERE salary.year = 2000 AND team.name = 'Boston Red Stockings';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\"\n}\n"}
{"sample_id": "train.3681", "db_id": "baseball_1", "question": "List the 3 highest salaries of the players in 2001?", "rationale": ["Identify the relevant table: The 'salary' table contains the salary records for players, including the year and salary amount.", "Filter the records: We need to filter the records to only include those from the year 2001.", "Sort the results: To find the highest salaries, we will sort the results in descending order based on the salary column.", "Limit the results: We only want the top 3 highest salaries, so we will limit the results to 3."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2001 ORDER BY salary DESC LIMIT 3;", "source_tables": ["salary"], "pred_sql": "SELECT player_id, salary FROM salary WHERE year = 2001 ORDER BY salary DESC LIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\"\n}\n"}
{"sample_id": "train.3684", "db_id": "baseball_1", "question": "List all the salary values players received in 2010 and 2001.", "rationale": ["Identify the relevant table: The salary table contains the salary records for players.", "Determine the columns needed: We need the player_id and salary columns.", "Specify the years of interest: The user wants salary values for the years 2010 and 2001.", "Construct the SQL query: Use a SELECT statement to retrieve player_id and salary from the salary table where the year is either 2010 or 2001."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2010 UNION SELECT salary FROM salary WHERE YEAR  =  2001", "source_tables": ["salary"], "pred_sql": "SELECT player_id, salary FROM salary WHERE year IN (2010, 2001);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\"\n}\n"}
{"sample_id": "train.3685", "db_id": "baseball_1", "question": "In which year did the least people enter hall of fame?", "rationale": ["We need to find the year with the least number of players inducted into the Hall of Fame.", "To do this, we will count the number of inductees for each year using the COUNT function on the 'hall_of_fame' table.", "We will group the results by the 'yearid' column to get the count for each year.", "Next, we will order the results in ascending order based on the count of inductees to find the year with the least inductees.", "Finally, we will limit the results to 1 to get only the year with the least inductees."], "gold_sql": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT 1;", "source_tables": ["hall_of_fame"], "pred_sql": "SELECT yearid, COUNT(*) AS num_inductees \nFROM hall_of_fame \nGROUP BY yearid \nORDER BY num_inductees ASC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\"\n}\n"}
{"sample_id": "train.3686", "db_id": "baseball_1", "question": "Find the year in which the least people enter hall of fame.", "rationale": ["We need to find the year with the least number of players inducted into the Hall of Fame.", "The relevant table for this information is 'hall_of_fame', which contains the 'yearid' and 'player_id'.", "To find the number of inductees per year, we can use the COUNT function on 'player_id' and group the results by 'yearid'.", "We will then order the results in ascending order based on the count of inductees to get the year with the least inductees at the top.", "Finally, we will limit the results to 1 to get only the year with the least inductees."], "gold_sql": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT 1;", "source_tables": ["hall_of_fame"], "pred_sql": "SELECT yearid, COUNT(player_id) AS num_inductees\nFROM hall_of_fame\nGROUP BY yearid\nORDER BY num_inductees ASC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\"\n}\n"}
{"sample_id": "train.3689", "db_id": "baseball_1", "question": "How many games were played in park \"Columbia Park\" in 1907?", "rationale": ["Identify the relevant tables: 'home_game' for games played and 'park' for park details.", "We need to sum the total games played in a specific park for a specific year.", "Join the 'home_game' table with the 'park' table on the park_id to access park names.", "Filter the results to only include games played in 'Columbia Park' in the year 1907.", "Use the SUM function to calculate the total number of games played."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 1907 AND T2.park_name = 'Columbia Park';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(home_game.games) AS total_games\nFROM home_game\nJOIN park ON home_game.park_id = park.park_id\nWHERE park.park_name = 'Columbia Park' AND home_game.year = 1907;", "hint": "\n"}
{"sample_id": "train.3690", "db_id": "baseball_1", "question": "Count the number of games taken place in park \"Columbia Park\" in 1907.", "rationale": ["Identify the relevant tables: 'home_game' for game statistics and 'park' for park details.", "We need to count the total number of games played in a specific park in a specific year, so we will sum the 'games' column from the 'home_game' table.", "Join the 'home_game' table with the 'park' table on the 'park_id' to access the park name.", "Filter the results to only include games played in 'Columbia Park' and in the year 1907."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 1907 AND T2.park_name = 'Columbia Park';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(games) AS total_games\nFROM home_game\nJOIN park ON home_game.park_id = park.park_id\nWHERE park.park_name = 'Columbia Park' AND home_game.year = 1907;", "hint": "\n"}
{"sample_id": "train.3691", "db_id": "baseball_1", "question": "How many games were played in city Atlanta in 2000?", "rationale": ["Identify the relevant table: The 'home_game' table contains information about games played, including the year and city.", "Determine the columns needed: We need to sum the 'games' column to get the total number of games played.", "Apply the conditions: We need to filter the results for the year 2000 and the city of Atlanta.", "Construct the SQL query: Use the SUM function to aggregate the total games played in Atlanta for the specified year."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year  =  2000 AND T2.city  =  'Atlanta';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(games) AS total_games\nFROM home_game\nWHERE city = 'Atlanta' AND year = 2000;", "hint": "\n"}
{"sample_id": "train.3692", "db_id": "baseball_1", "question": "Find the number of games taken place in city Atlanta in 2000.", "rationale": ["Identify the relevant tables: 'home_game' for game statistics and 'park' for location details.", "We need to find the total number of games played in Atlanta in the year 2000.", "Join the 'home_game' table with the 'park' table on the park_id to access city information.", "Filter the results to only include games played in Atlanta and in the year 2000.", "Use the SUM function to calculate the total number of games from the filtered results."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year  =  2000 AND T2.city  =  'Atlanta';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(games) AS total_games\nFROM home_game h\nJOIN park p ON h.park_id = p.park_id\nWHERE p.city = 'Atlanta' AND h.year = 2000;", "hint": "\n"}
{"sample_id": "train.3697", "db_id": "baseball_1", "question": "List players' first name and last name who received salary from team Washington Nationals in both 2005 and 2007.", "rationale": ["Identify the relevant tables: We need the 'salary' table to find players' salaries and the 'player' table to get their names.", "Join the 'salary' table with the 'player' table on 'player_id' to access player names along with their salary records.", "Filter the results to include only those records where the team is 'Washington Nationals' and the year is either 2005 or 2007.", "Use a subquery to get the 'team_id' for 'Washington Nationals' from the 'team' table.", "Group the results by 'player_id' to ensure we can count the number of distinct years for each player.", "Use the HAVING clause to ensure that only players who have salary records for both years (2005 and 2007) are included in the final result."], "gold_sql": "SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2005 AND T3.name = 'Washington Nationals' INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2007 AND T3.name = 'Washington Nationals'", "source_tables": ["team", "player", "salary"], "pred_sql": "SELECT p.name_first, p.name_last \nFROM salary s1 \nJOIN player p ON s1.player_id = p.player_id \nWHERE s1.team_id = (SELECT team_id FROM team WHERE name = 'Washington Nationals') \nAND s1.year IN (2005, 2007) \nGROUP BY p.player_id \nHAVING COUNT(DISTINCT s1.year) = 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\"\n}\n"}
{"sample_id": "train.3699", "db_id": "baseball_1", "question": "How many home games did the team Boston Red Stockings play from 1990 to 2000 in total?", "rationale": ["Identify the relevant table: The 'home_game' table contains information about home games played by teams.", "Determine the columns needed: We need to sum the 'games' column to get the total number of home games.", "Filter by team: We need to find the 'team_id' for 'Boston Red Stockings' from the 'team' table.", "Filter by year: We need to restrict the results to the years between 1990 and 2000.", "Construct the SQL query: Use a subquery to find the 'team_id' and sum the 'games' for the specified years."], "gold_sql": "SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = 'Boston Red Stockings' AND T1.year BETWEEN 1990 AND 2000;", "source_tables": ["team", "home_game"], "pred_sql": "SELECT SUM(games) AS total_home_games\nFROM home_game\nWHERE team_id = (SELECT team_id FROM team WHERE name = 'Boston Red Stockings')\nAND year BETWEEN 1990 AND 2000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\"\n}\n"}
{"sample_id": "train.3702", "db_id": "baseball_1", "question": "Find the team that attended the least number of home games in 1980.", "rationale": ["Identify the relevant table: The 'home_game' table contains information about home games played by teams, including the year and the number of games.", "Specify the year: We are interested in the year 1980, so we will filter the records in the 'home_game' table for that year.", "Select the team and games: We need to select the 'team_id' and the 'games' columns from the 'home_game' table.", "Order the results: To find the team with the least number of home games, we will order the results by the 'games' column in ascending order.", "Limit the results: Since we only want the team with the least number of home games, we will limit the results to 1."], "gold_sql": "SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = 1980 ORDER BY T1.attendance ASC LIMIT 1;", "source_tables": ["team", "home_game"], "pred_sql": "SELECT team_id, games FROM home_game WHERE year = 1980 ORDER BY games ASC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\"\n}\n"}
{"sample_id": "train.3710", "db_id": "baseball_1", "question": "Which park did the most people attend in 2008?", "rationale": ["Identify the relevant tables: 'home_game' for attendance data and 'park' for park names.", "We need to find the park with the highest attendance in the year 2008.", "Join the 'home_game' table with the 'park' table on the 'park_id' to get park names along with attendance.", "Filter the results to only include records from the year 2008.", "Order the results by attendance in descending order to get the highest attendance first.", "Limit the results to 1 to get only the park with the most attendance."], "gold_sql": "SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 2008 ORDER BY T1.attendance DESC LIMIT 1;", "source_tables": ["park", "home_game"], "pred_sql": "SELECT park.park_name, home_game.attendance\nFROM home_game\nJOIN park ON home_game.park_id = park.park_id\nWHERE home_game.year = 2008\nORDER BY home_game.attendance DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3898", "db_id": "hospital_1", "question": "Which department has the largest number of employees?", "rationale": ["Identify the relevant tables: Department and Physician.", "We need to count the number of employees in each department, which includes the head of the department (who is a physician).", "Use a LEFT JOIN to connect the Department table with the Physician table on the Head column.", "Group the results by department name to count the number of employees in each department.", "Order the results by the count of employees in descending order to find the department with the largest number of employees.", "Limit the results to 1 to get only the department with the largest number of employees."], "gold_sql": "SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT 1;", "source_tables": ["department"], "pred_sql": "SELECT d.Name, COUNT(p.EmployeeID) AS EmployeeCount\nFROM Department d\nLEFT JOIN Physician p ON d.Head = p.EmployeeID\nGROUP BY d.Name\nORDER BY EmployeeCount DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3899", "db_id": "hospital_1", "question": "Find the department with the most employees.", "rationale": ["To find the department with the most employees, we need to count the number of physicians affiliated with each department.", "We will join the 'Department' table with the 'Affiliated_With' table on the department ID.", "We will group the results by the department name to get the count of physicians in each department.", "We will use the COUNT function to count the number of physicians for each department.", "To find the department with the most employees, we will order the results by the count of employees in descending order.", "Finally, we will limit the results to 1 to get only the department with the highest count."], "gold_sql": "SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT 1;", "source_tables": ["department"], "pred_sql": "SELECT Department.Name, COUNT(Affiliated_With.Physician) AS EmployeeCount\nFROM Department\nJOIN Affiliated_With ON Department.DepartmentID = Affiliated_With.Department\nGROUP BY Department.Name\nORDER BY EmployeeCount DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3902", "db_id": "hospital_1", "question": "what is the name and position of the head whose department has least number of employees?", "rationale": ["We need to find the name and position of the head of the department with the least number of employees.", "The head of a department is identified by the 'Head' column in the Department table, which corresponds to the 'EmployeeID' in the Physician table.", "To find the department with the least number of employees, we can use the Affiliated_With table to count the number of physicians affiliated with each department.", "We will group the results by department and order them by the count of physicians in ascending order, limiting the result to the first one to get the department with the least employees.", "Finally, we will join the Physician and Department tables to get the name and position of the head of that department."], "gold_sql": "SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["physician", "department"], "pred_sql": "SELECT Physician.Name, Physician.Position \nFROM Physician \nJOIN Department ON Physician.EmployeeID = Department.Head \nWHERE Department.DepartmentID = \n  (SELECT Affiliated_With.Department \n   FROM Affiliated_With \n   GROUP BY Affiliated_With.Department \n   ORDER BY COUNT(Affiliated_With.Physician) ASC \n   LIMIT 1);", "hint": "\n"}
{"sample_id": "train.3904", "db_id": "hospital_1", "question": "What are names of patients who made an appointment?", "rationale": ["Identify the relevant tables: Appointment and Patient.", "We need to find the names of patients who have made appointments, which means we will join the Appointment table with the Patient table using the Patient's SSN.", "Use DISTINCT to ensure we only get unique patient names in case a patient has multiple appointments."], "gold_sql": "SELECT name FROM appointment AS T1 JOIN patient AS T2 ON T1.patient  =  T2.ssn", "source_tables": ["patient", "appointment"], "pred_sql": "SELECT DISTINCT Patient.Name\nFROM Appointment\nJOIN Patient ON Appointment.Patient = Patient.SSN;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct names of physicians who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\",\n    \"1\": \"This virtual table provides a list of unique physician names who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\",\n    \"2\": \"This virtual table describes the names of physicians who are trained in specific procedures that have a cost exceeding a certain amount. The placeholders in the WHERE clause represent the cost threshold for the procedures.\"\n}\n"}
{"sample_id": "train.3905", "db_id": "hospital_1", "question": "List the names of patients who have made appointments.", "rationale": ["We need to list the names of patients who have made appointments.", "The relevant table for appointments is the 'Appointment' table, which contains a reference to the patient via the 'Patient' column.", "The 'Patient' table contains the names of the patients, and we can join it with the 'Appointment' table using the 'Patient' identifier (SSN).", "To avoid duplicate names, we will use the DISTINCT keyword in our SELECT statement."], "gold_sql": "SELECT name FROM appointment AS T1 JOIN patient AS T2 ON T1.patient  =  T2.ssn", "source_tables": ["patient", "appointment"], "pred_sql": "SELECT DISTINCT Patient.Name\nFROM Appointment\nJOIN Patient ON Appointment.Patient = Patient.SSN;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct names of physicians who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\",\n    \"1\": \"This virtual table provides a list of unique physician names who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\",\n    \"2\": \"This virtual table describes the names of physicians who are trained in specific procedures that have a cost exceeding a certain amount. The placeholders in the WHERE clause represent the cost threshold for the procedures.\"\n}\n"}
{"sample_id": "train.3914", "db_id": "hospital_1", "question": "Find the names of all physicians and their primary affiliated departments' names.", "rationale": ["Identify the tables needed: Physician, Affiliated_With, and Department.", "We need to retrieve the names of physicians and their affiliated departments, so we will select the 'Name' column from both the Physician and Department tables.", "To link the physicians to their departments, we will use the Affiliated_With table, which connects physicians to departments.", "We will perform a JOIN operation between Physician and Affiliated_With on the EmployeeID and Physician columns, respectively.", "Next, we will join the Department table on the DepartmentID to get the department names.", "Since we are interested in primary affiliations, we will filter the results where 'PrimaryAffiliation' is 'Yes'."], "gold_sql": "SELECT T1.name ,  T3.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T2.PrimaryAffiliation  =  1", "source_tables": ["physician", "department", "affiliated_with"], "pred_sql": "SELECT Physician.Name, Department.Name \nFROM Physician \nJOIN Affiliated_With ON Physician.EmployeeID = Affiliated_With.Physician \nJOIN Department ON Affiliated_With.Department = Department.DepartmentID \nWHERE Affiliated_With.PrimaryAffiliation = 'Yes';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct names of physicians who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\",\n    \"1\": \"This virtual table provides a list of unique physician names who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\",\n    \"2\": \"This virtual table provides a list of medical procedures that either exceed a specified cost or are associated with a physician who has been trained in those procedures. The first part of the query retrieves procedure names based on a cost threshold, while the second part retrieves procedure names linked to a specific physician's training. The placeholders represent the cost limit and the physician's name, respectively.\"\n}\n"}
{"sample_id": "train.3915", "db_id": "hospital_1", "question": "What are the name and primarily affiliated department name of each physician?", "rationale": ["Identify the tables needed: Physician, Affiliated_With, and Department.", "We need the names of physicians and their primarily affiliated department names.", "Join the Physician table with the Affiliated_With table on the EmployeeID and Physician columns.", "Join the resulting table with the Department table on the Department column from Affiliated_With and DepartmentID from Department.", "Filter the results to include only those affiliations marked as primary by checking the PrimaryAffiliation column."], "gold_sql": "SELECT T1.name ,  T3.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T2.PrimaryAffiliation  =  1", "source_tables": ["physician", "department", "affiliated_with"], "pred_sql": "SELECT Physician.Name, Department.Name \nFROM Physician \nJOIN Affiliated_With ON Physician.EmployeeID = Affiliated_With.Physician \nJOIN Department ON Affiliated_With.Department = Department.DepartmentID \nWHERE Affiliated_With.PrimaryAffiliation = 'Yes';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct names of physicians who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\",\n    \"1\": \"This virtual table provides a list of unique physician names who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\",\n    \"2\": \"This virtual table describes the names of physicians who are trained in specific procedures that have a cost exceeding a certain amount. The placeholders in the WHERE clause represent the cost threshold for the procedures.\"\n}\n"}
{"sample_id": "train.3929", "db_id": "hospital_1", "question": "Return the name of each physician and the number of patients he or she treats.", "rationale": ["Identify the tables needed: Physician, Prescribes, and Patient.", "We need to count the number of patients treated by each physician, which implies a relationship between physicians and patients through prescriptions.", "Join the Physician table with the Prescribes table on the Physician's EmployeeID and the Prescribes table's Physician field.", "Then, join the resulting table with the Patient table on the Patient's SSN and the Prescribes table's Patient field.", "Use COUNT to count the number of patients for each physician and GROUP BY the physician's name to get the count per physician."], "gold_sql": "SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid", "source_tables": ["physician", "patient"], "pred_sql": "SELECT Physician.Name, COUNT(Patient.SSN) AS NumberOfPatients\nFROM Physician\nJOIN Prescribes ON Physician.EmployeeID = Prescribes.Physician\nJOIN Patient ON Prescribes.Patient = Patient.SSN\nGROUP BY Physician.Name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct names of physicians who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\",\n    \"1\": \"This virtual table provides a list of unique physician names who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\",\n    \"2\": \"This virtual table describes the names of physicians who are trained in specific procedures that have a cost exceeding a certain amount. The placeholders in the WHERE clause represent the cost threshold for the procedures.\"\n}\n"}
{"sample_id": "train.3930", "db_id": "hospital_1", "question": "Find the name of physicians who are in charge of more than one patient.", "rationale": ["Identify the relevant tables: Physician and Prescribes.", "We need to find physicians who have prescribed medications to patients, so we will join the Physician table with the Prescribes table on the Physician's EmployeeID.", "Group the results by the physician's name to aggregate the data.", "Use the HAVING clause to filter the groups where the count of distinct patients is greater than one."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  1", "source_tables": ["physician", "patient"], "pred_sql": "SELECT Physician.Name\nFROM Physician\nJOIN Prescribes ON Physician.EmployeeID = Prescribes.Physician\nGROUP BY Physician.Name\nHAVING COUNT(DISTINCT Prescribes.Patient) > 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct names of physicians who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\",\n    \"1\": \"This virtual table describes the names of physicians who are trained in specific procedures that have a cost exceeding a certain amount. The placeholders in the WHERE clause represent the cost threshold for the procedures.\",\n    \"2\": \"This virtual table provides a list of unique physician names who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\"\n}\n"}
{"sample_id": "train.3931", "db_id": "hospital_1", "question": "Which physicians are in charge of more than one patient? Give me their names.", "rationale": ["We need to find physicians who are in charge of more than one patient, which implies we need to look at the relationship between physicians and patients.", "The relevant table for this relationship is the 'Prescribes' table, which links physicians to patients through prescriptions.", "We will join the 'Physician' table with the 'Prescribes' table on the 'Physician.EmployeeID' and 'Prescribes.Physician' columns.", "To find physicians in charge of more than one patient, we will group the results by 'Physician.EmployeeID' and count the distinct patients associated with each physician.", "Finally, we will use the HAVING clause to filter the groups to only include those with a count greater than 1, indicating they are in charge of more than one patient."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  1", "source_tables": ["physician", "patient"], "pred_sql": "SELECT Physician.Name\nFROM Physician\nJOIN Prescribes ON Physician.EmployeeID = Prescribes.Physician\nGROUP BY Physician.EmployeeID\nHAVING COUNT(DISTINCT Prescribes.Patient) > 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct names of physicians who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\",\n    \"1\": \"This virtual table describes the names of physicians who are trained in specific procedures that have a cost exceeding a certain amount. The placeholders in the WHERE clause represent the cost threshold for the procedures.\",\n    \"2\": \"This virtual table provides a list of unique physician names who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\"\n}\n"}
{"sample_id": "train.3934", "db_id": "hospital_1", "question": "Find the number of rooms for different block code?", "rationale": ["We need to find the number of rooms for different block codes.", "The relevant table for room information is the 'Room' table, which contains 'RoomNumber' and 'BlockCode'.", "To count the number of rooms for each block code, we will use the COUNT() function.", "We will group the results by 'BlockCode' to get the count for each unique block code."], "gold_sql": "SELECT count(*) ,  T1.blockcode FROM BLOCK AS T1 JOIN room AS T2 ON T1.blockfloor  =  T2.blockfloor AND T1.blockcode  =  T2.blockcode GROUP BY T1.blockcode", "source_tables": ["block", "room"], "pred_sql": "SELECT BlockCode, COUNT(RoomNumber) AS NumberOfRooms\nFROM Room\nGROUP BY BlockCode;", "hint": "\n"}
{"sample_id": "train.3944", "db_id": "hospital_1", "question": "Find the number of medications prescribed for each brand.", "rationale": ["We need to find the number of medications prescribed for each brand.", "To do this, we will join the 'Medication' table with the 'Prescribes' table on the medication code.", "We will select the brand from the 'Medication' table and count the number of prescriptions from the 'Prescribes' table.", "Finally, we will group the results by the brand to get the count of prescriptions for each brand."], "gold_sql": "SELECT count(*) ,  T1.name FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand", "source_tables": ["prescribes", "medication"], "pred_sql": "SELECT m.Brand, COUNT(p.Medication) AS NumberOfPrescriptions\nFROM Medication m\nJOIN Prescribes p ON m.Code = p.Medication\nGROUP BY m.Brand;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct names of physicians who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\",\n    \"1\": \"This virtual table provides a list of unique physician names who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\",\n    \"2\": \"This virtual table counts the number of patients who have not been prescribed a specific medication. It filters the patients based on their Social Security Number (SSN) and checks against a subquery that retrieves patients who have received the specified medication by joining the 'Prescribes' and 'Medication' tables. The placeholder in the query represents the name of the medication.\"\n}\n"}
{"sample_id": "train.3959", "db_id": "hospital_1", "question": "Find the physician who prescribed the highest dose. What is his or her name?", "rationale": ["Identify the relevant tables: We need to find the physician who prescribed the highest dose, so we will use the 'Prescribes' table to get the dose information and the 'Physician' table to get the physician's name.", "Join the tables: We will join the 'Prescribes' table with the 'Physician' table on the physician's identifier (EmployeeID) to access the physician's name along with the prescribed doses.", "Order the results: We will order the results by the 'Dose' column in descending order to get the highest dose at the top.", "Limit the results: Since we only need the physician who prescribed the highest dose, we will limit the results to 1."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT 1", "source_tables": ["physician", "prescribes"], "pred_sql": "SELECT Physician.Name\nFROM Prescribes\nJOIN Physician ON Prescribes.Physician = Physician.EmployeeID\nORDER BY Prescribes.Dose DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct names of physicians who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\",\n    \"1\": \"This virtual table provides a list of unique physician names who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\",\n    \"2\": \"This virtual table describes the names of physicians who are trained in specific procedures that have a cost exceeding a certain amount. The placeholders in the WHERE clause represent the cost threshold for the procedures.\"\n}\n"}
{"sample_id": "train.3960", "db_id": "hospital_1", "question": "List the physicians' employee ids together with their primary affiliation departments' ids.", "rationale": ["Identify the relevant tables: Physician and Affiliated_With.", "We need to select the EmployeeID from the Physician table and the Department from the Affiliated_With table.", "To link these two tables, we will use the common column: Physician.EmployeeID and Affiliated_With.Physician.", "We are interested in the primary affiliation, so we will filter the results where Affiliated_With.PrimaryAffiliation is 'Yes'.", "Construct the SQL SELECT statement to retrieve the desired columns and apply the necessary JOIN and WHERE clauses."], "gold_sql": "SELECT physician ,  department FROM affiliated_with WHERE primaryaffiliation  =  1", "source_tables": ["affiliated_with"], "pred_sql": "SELECT Physician.EmployeeID, Affiliated_With.Department \nFROM Physician \nJOIN Affiliated_With ON Physician.EmployeeID = Affiliated_With.Physician \nWHERE Affiliated_With.PrimaryAffiliation = 'Yes';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct names of physicians who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\",\n    \"1\": \"This virtual table provides a list of unique physician names who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\"\n}\n"}
{"sample_id": "train.3961", "db_id": "hospital_1", "question": "What are each physician's employee id and department id primarily affiliated.", "rationale": ["Identify the required columns: EmployeeID from the Physician table and Department from the Affiliated_With table.", "Determine the relationship between the tables: Physician is linked to Affiliated_With through the EmployeeID and Physician columns.", "Use a JOIN clause to combine the Physician and Affiliated_With tables based on the matching EmployeeID and Physician.", "Filter the results to include only those records where the PrimaryAffiliation is marked as 'Yes', indicating the primary department affiliation."], "gold_sql": "SELECT physician ,  department FROM affiliated_with WHERE primaryaffiliation  =  1", "source_tables": ["affiliated_with"], "pred_sql": "SELECT Physician.EmployeeID, Affiliated_With.Department \nFROM Physician \nJOIN Affiliated_With ON Physician.EmployeeID = Affiliated_With.Physician \nWHERE Affiliated_With.PrimaryAffiliation = 'Yes';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct names of physicians who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\"\n}\n"}
{"sample_id": "train.3970", "db_id": "hospital_1", "question": "Find the three most expensive procedures.", "rationale": ["Identify the table that contains the procedures and their costs, which is the Procedures table.", "To find the most expensive procedures, we need to sort the procedures by their cost in descending order.", "We will limit the results to the top three entries to get the three most expensive procedures."], "gold_sql": "SELECT name FROM procedures ORDER BY cost LIMIT 3", "source_tables": ["procedures"], "pred_sql": "SELECT Name, Cost FROM Procedures ORDER BY Cost DESC LIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of medical procedures that either exceed a specified cost or are associated with a physician who has been trained in those procedures. The first part of the query retrieves procedure names based on a cost threshold, while the second part retrieves procedure names linked to a specific physician's training. The placeholders represent the cost limit and the physician's name, respectively.\",\n    \"1\": \"This virtual table provides a list of medical procedures that either exceed a specified cost or are associated with a physician who has been trained in those procedures. The first part of the query retrieves procedure names based on a cost threshold, while the second part retrieves procedure names linked to a specific physician's training. The placeholders represent the cost limit and the physician's name, respectively.\",\n    \"2\": \"This virtual table describes the names of physicians who are trained in specific procedures that have a cost exceeding a certain amount. The placeholders in the WHERE clause represent the cost threshold for the procedures.\"\n}\n"}
{"sample_id": "train.3971", "db_id": "hospital_1", "question": "What are the three most costly procedures?", "rationale": ["Identify the table that contains the procedures and their costs, which is the Procedures table.", "To find the most costly procedures, we need to select the Name and Cost columns from the Procedures table.", "We will order the results by the Cost column in descending order to get the highest costs first.", "Finally, we limit the results to the top three entries using LIMIT 3."], "gold_sql": "SELECT name FROM procedures ORDER BY cost LIMIT 3", "source_tables": ["procedures"], "pred_sql": "SELECT Name, Cost FROM Procedures ORDER BY Cost DESC LIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of medical procedures that either exceed a specified cost or are associated with a physician who has been trained in those procedures. The first part of the query retrieves procedure names based on a cost threshold, while the second part retrieves procedure names linked to a specific physician's training. The placeholders represent the cost limit and the physician's name, respectively.\",\n    \"1\": \"This virtual table provides a list of medical procedures that either exceed a specified cost or are associated with a physician who has been trained in those procedures. The first part of the query retrieves procedure names based on a cost threshold, while the second part retrieves procedure names linked to a specific physician's training. The placeholders represent the cost limit and the physician's name, respectively.\",\n    \"2\": \"This virtual table describes the names of physicians who are trained in specific procedures that have a cost exceeding a certain amount. The placeholders in the WHERE clause represent the cost threshold for the procedures.\"\n}\n"}
{"sample_id": "train.3973", "db_id": "hospital_1", "question": "Which physicians are trained in procedures that are more expensive than 5000?", "rationale": ["We need to find physicians trained in procedures that cost more than 5000.", "To do this, we will join the Physician table with the Trained_In table to get the physicians and their trained procedures.", "Next, we will join the Procedures table to access the cost of those procedures.", "Finally, we will filter the results using a WHERE clause to only include procedures with a cost greater than 5000."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  5000", "source_tables": ["physician", "procedures", "trained_in"], "pred_sql": "SELECT DISTINCT Physician.Name \nFROM Physician \nJOIN Trained_In ON Physician.EmployeeID = Trained_In.Physician \nJOIN Procedures ON Trained_In.Treatment = Procedures.Code \nWHERE Procedures.Cost > 5000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of physicians who are trained in specific procedures that have a cost exceeding a certain amount. The placeholders in the WHERE clause represent the cost threshold for the procedures.\",\n    \"1\": \"This virtual table provides a list of medical procedures that either exceed a specified cost or are associated with a physician who has been trained in those procedures. The first part of the query retrieves procedure names based on a cost threshold, while the second part retrieves procedure names linked to a specific physician's training. The placeholders represent the cost limit and the physician's name, respectively.\",\n    \"2\": \"This virtual table provides a list of medical procedures that either exceed a specified cost or are associated with a physician who has been trained in those procedures. The first part of the query retrieves procedure names based on a cost threshold, while the second part retrieves procedure names linked to a specific physician's training. The placeholders represent the cost limit and the physician's name, respectively.\"\n}\n"}
{"sample_id": "train.3974", "db_id": "hospital_1", "question": "Find the physician who was trained in the most expensive procedure?", "rationale": ["Identify the relevant tables: Physician, Trained_In, and Procedures are needed to find the physician trained in the most expensive procedure.", "Join the Physician table with the Trained_In table on the EmployeeID to get the physicians and their trained procedures.", "Join the resulting table with the Procedures table on the Treatment code to access the cost of each procedure.", "Use a subquery to find the maximum cost from the Procedures table.", "Filter the results to only include physicians trained in the procedure that has the maximum cost."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment ORDER BY T3.cost DESC LIMIT 1", "source_tables": ["physician", "procedures", "trained_in"], "pred_sql": "SELECT Physician.Name\nFROM Physician\nJOIN Trained_In ON Physician.EmployeeID = Trained_In.Physician\nJOIN Procedures ON Trained_In.Treatment = Procedures.Code\nWHERE Procedures.Cost = (SELECT MAX(Cost) FROM Procedures);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of physicians who are trained in specific procedures that have a cost exceeding a certain amount. The placeholders in the WHERE clause represent the cost threshold for the procedures.\",\n    \"1\": \"This virtual table provides a list of medical procedures that either exceed a specified cost or are associated with a physician who has been trained in those procedures. The first part of the query retrieves procedure names based on a cost threshold, while the second part retrieves procedure names linked to a specific physician's training. The placeholders represent the cost limit and the physician's name, respectively.\",\n    \"2\": \"This virtual table provides a list of medical procedures that either exceed a specified cost or are associated with a physician who has been trained in those procedures. The first part of the query retrieves procedure names based on a cost threshold, while the second part retrieves procedure names linked to a specific physician's training. The placeholders represent the cost limit and the physician's name, respectively.\"\n}\n"}
{"sample_id": "train.3985", "db_id": "hospital_1", "question": "What procedures cost less than 5000 and have John Wen as a trained physician?", "rationale": ["Identify the relevant tables: Procedures, Trained_In, and Physician are needed to find procedures trained by a specific physician.", "Join Procedures with Trained_In on the procedure code to link procedures with their trained physicians.", "Join Trained_In with Physician on the physician's employee ID to filter by the physician's name.", "Apply the WHERE clause to filter procedures that cost less than 5000 and are associated with the physician named 'John Wen'.", "Select the procedure names that meet the criteria."], "gold_sql": "SELECT name FROM procedures WHERE cost  <  5000 INTERSECT SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  'John Wen'", "source_tables": ["procedures", "physician", "trained_in"], "pred_sql": "SELECT Procedures.Name \nFROM Procedures \nJOIN Trained_In ON Procedures.Code = Trained_In.Treatment \nJOIN Physician ON Trained_In.Physician = Physician.EmployeeID \nWHERE Procedures.Cost < 5000 AND Physician.Name = 'John Wen';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of physicians who are trained in specific procedures that have a cost exceeding a certain amount. The placeholders in the WHERE clause represent the cost threshold for the procedures.\",\n    \"1\": \"This virtual table provides a list of medical procedures that either exceed a specified cost or are associated with a physician who has been trained in those procedures. The first part of the query retrieves procedure names based on a cost threshold, while the second part retrieves procedure names linked to a specific physician's training. The placeholders represent the cost limit and the physician's name, respectively.\",\n    \"2\": \"This virtual table provides a list of medical procedures that either exceed a specified cost or are associated with a physician who has been trained in those procedures. The first part of the query retrieves procedure names based on a cost threshold, while the second part retrieves procedure names linked to a specific physician's training. The placeholders represent the cost limit and the physician's name, respectively.\"\n}\n"}
{"sample_id": "train.4321", "db_id": "tracking_grants_for_research", "question": "What are the different grant amounts for documents sent before '1986-08-26 20:49:27' and after the grant ended on '1989-03-16 18:27:16'?", "rationale": ["Identify the relevant tables: Grants and Documents are needed to access grant amounts and document sent dates.", "Join the Grants table with the Documents table on the grant_id to link documents to their respective grants.", "Filter the results to include only those documents sent before '1986-08-26 20:49:27'.", "Also, filter to ensure that the grant end date is before '1989-03-16 18:27:16'.", "Select distinct grant amounts to avoid duplicates in the results."], "gold_sql": "SELECT T1.grant_amount FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id WHERE T2.sent_date  <  '1986-08-26 20:49:27' INTERSECT SELECT grant_amount FROM grants WHERE grant_end_date  >  '1989-03-16 18:27:16'", "source_tables": ["grants", "documents"], "pred_sql": "SELECT DISTINCT Grants.grant_amount \nFROM Grants \nJOIN Documents ON Grants.grant_id = Documents.grant_id \nWHERE Documents.sent_date < '1986-08-26 20:49:27' \nAND Grants.grant_end_date < '1989-03-16 18:27:16';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the sent dates of documents from the 'Documents' table that are associated with grants exceeding a specified amount. The query joins multiple tables: 'Grants' to link grants with documents, 'Organisations' to connect grants to their respective organisations, and 'Organisation_Types' to filter organisations based on their type description. The placeholders in the WHERE clause represent the grant amount and the organisation type description.\",\n    \"1\": \"This virtual table retrieves the start dates of grants from the 'Grants' table that are associated with documents of a specific type. It uses joins to connect the 'Grants', 'Documents', and 'Document_Types' tables based on their foreign key relationships. The placeholder in the WHERE clause represents the description of the document type, allowing users to specify which document type they are interested in. The INTERSECT operation ensures that only the start dates of grants that meet the criteria in both queries are returned.\",\n    \"2\": \"This virtual table retrieves the response received dates of documents from the 'Documents' table, joining with 'Document_Types' to filter by a specific document description and with 'Grants' to filter by grant amount. The placeholders in the WHERE clause represent the document description and the grant amount criteria.\"\n}\n"}
{"sample_id": "train.4322", "db_id": "tracking_grants_for_research", "question": "List the project details of the project both producing patent and paper as outcomes.", "rationale": ["Identify the main table to retrieve project details, which is the 'Projects' table.", "Join the 'Project_Outcomes' table to link projects with their outcomes using the project_id.", "Join the 'Research_Outcomes' table to filter the outcomes based on their descriptions.", "Use a WHERE clause to specify that we want projects with outcomes that are either 'patent' or 'paper'.", "Group the results by project_id to ensure unique project details are returned."], "gold_sql": "SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  'Paper' INTERSECT SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  'Patent'", "source_tables": ["project_outcomes", "projects"], "pred_sql": "SELECT p.project_details \nFROM Projects p \nJOIN Project_Outcomes po ON p.project_id = po.project_id \nJOIN Research_Outcomes ro ON po.outcome_code = ro.outcome_code \nWHERE ro.outcome_description IN ('patent', 'paper') \nGROUP BY p.project_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the project details from the 'Projects' table that are associated with specific research outcomes. The query filters the results based on a description of the research outcome, represented by a placeholder for string values.\",\n    \"1\": \"This virtual table retrieves the response received dates of documents from the 'Documents' table, joining with 'Document_Types' to filter by a specific document description and with 'Grants' to filter by grant amount. The placeholders in the WHERE clause represent the document description and the grant amount criteria.\"\n}\n"}
{"sample_id": "train.4324", "db_id": "tracking_grants_for_research", "question": "What is the total grant amount of the organisations described as research?", "rationale": ["Identify the tables involved: Grants, Organisations, and Organisation_Types.", "Determine the relationship between these tables: Grants are linked to Organisations via organisation_id, and Organisations are linked to Organisation_Types via organisation_type.", "We need to calculate the total grant amount, so we will use the SUM function on the grant_amount column from the Grants table.", "To filter the results to only include organisations described as 'research', we will add a WHERE clause that checks the organisation_type_description in the Organisation_Types table.", "Construct the SQL query using the identified tables, relationships, and conditions."], "gold_sql": "SELECT sum(grant_amount) FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id JOIN organisation_Types AS T3 ON T2.organisation_type  =  T3.organisation_type WHERE T3.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations"], "pred_sql": "SELECT SUM(grant_amount) AS total_grant_amount\nFROM Grants\nJOIN Organisations ON Grants.organisation_id = Organisations.organisation_id\nJOIN Organisation_Types ON Organisations.organisation_type = Organisation_Types.organisation_type\nWHERE Organisation_Types.organisation_type_description = 'research';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the total grant amount from the 'Grants' table for organisations of a specific type. It joins the 'Grants' table with the 'Organisations' table to link grants to their respective organisations, and further joins with the 'Organisation_Types' table to filter based on the organisation type description. The placeholder in the WHERE clause represents the specific organisation type description being queried.\",\n    \"1\": \"This virtual table provides the sent dates of documents from the 'Documents' table that are associated with grants exceeding a specified amount. The query joins multiple tables: 'Grants' to link grants with documents, 'Organisations' to connect grants to their respective organisations, and 'Organisation_Types' to filter organisations based on their type description. The placeholders in the WHERE clause represent the grant amount and the organisation type description.\",\n    \"2\": \"This virtual table describes the project details from the 'Projects' table that are associated with specific research outcomes. The query filters the results based on a description of the research outcome, represented by a placeholder for string values.\"\n}\n"}
{"sample_id": "train.4327", "db_id": "tracking_grants_for_research", "question": "From what date and to what date do the staff work on a project that has the most staff and has staff in a leader role?", "rationale": ["Identify the role code for the 'Leader' role from the Staff_Roles table.", "Find the project_id(s) that have staff members with the 'Leader' role by filtering Project_Staff based on the identified role code.", "Group the results by project_id and count the number of staff members for each project to determine which project has the most staff.", "Order the results in descending order based on the count of staff members and limit the results to the top project (the one with the most staff).", "Select the date_from and date_to for the staff members working on the project identified in the previous step."], "gold_sql": "SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT 1 ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  'leader'", "source_tables": ["project_staff"], "pred_sql": "SELECT date_from, date_to \nFROM Project_Staff \nWHERE project_id = (\n    SELECT project_id \n    FROM Project_Staff \n    WHERE role_code = (SELECT role_code FROM Staff_Roles WHERE role_description = 'Leader') \n    GROUP BY project_id \n    ORDER BY COUNT(staff_id) DESC \n    LIMIT 1\n)", "hint": "\n"}
{"sample_id": "train.4330", "db_id": "tracking_grants_for_research", "question": "What is the organisation type and id of the organisation which has the most number of research staff?", "rationale": ["Identify the relevant tables: Organisations and Research_Staff.", "Join the Organisations table with the Research_Staff table on the organisation_id and employer_organisation_id fields.", "Group the results by organisation_id and organisation_type to count the number of research staff per organisation.", "Order the results by the count of research staff in descending order to find the organisation with the most staff.", "Limit the results to 1 to get only the top organisation."], "gold_sql": "SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT o.organisation_type, o.organisation_id\nFROM Organisations o\nJOIN Research_Staff rs ON o.organisation_id = rs.employer_organisation_id\nGROUP BY o.organisation_id, o.organisation_type\nORDER BY COUNT(rs.staff_id) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.4334", "db_id": "tracking_grants_for_research", "question": "Find out the send dates of the documents with the grant amount of more than 5000 were granted by organisation type described", "rationale": ["Identify the tables involved: Documents, Grants, Organisations, and Organisation_Types.", "Determine the relationships: Documents are linked to Grants via grant_id, Grants are linked to Organisations via organisation_id, and Organisations are linked to Organisation_Types via organisation_type.", "Select the relevant columns: We need the sent_date from the Documents table.", "Apply the necessary filters: We need to filter grants with a grant_amount greater than 5000.", "Construct the SQL query using JOINs to connect the tables and apply the WHERE clause for filtering."], "gold_sql": "SELECT T1.sent_date FROM documents AS T1 JOIN Grants AS T2 ON T1.grant_id  =  T2.grant_id JOIN Organisations AS T3 ON T2.organisation_id  =  T3.organisation_id JOIN organisation_Types AS T4 ON T3.organisation_type  =  T4.organisation_type WHERE T2.grant_amount  >  5000 AND T4.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations", "documents"], "pred_sql": "SELECT Documents.sent_date \nFROM Documents \nJOIN Grants ON Documents.grant_id = Grants.grant_id \nJOIN Organisations ON Grants.organisation_id = Organisations.organisation_id \nJOIN Organisation_Types ON Organisations.organisation_type = Organisation_Types.organisation_type \nWHERE Grants.grant_amount > 5000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the sent dates of documents from the 'Documents' table that are associated with grants exceeding a specified amount. The query joins multiple tables: 'Grants' to link grants with documents, 'Organisations' to connect grants to their respective organisations, and 'Organisation_Types' to filter organisations based on their type description. The placeholders in the WHERE clause represent the grant amount and the organisation type description.\",\n    \"1\": \"This virtual table retrieves the response received dates of documents from the 'Documents' table, joining with 'Document_Types' to filter by a specific document description and with 'Grants' to filter by grant amount. The placeholders in the WHERE clause represent the document description and the grant amount criteria.\",\n    \"2\": \"This virtual table retrieves the start dates of grants from the 'Grants' table that are associated with documents of a specific type. It uses joins to connect the 'Grants', 'Documents', and 'Document_Types' tables based on their foreign key relationships. The placeholder in the WHERE clause represents the description of the document type, allowing users to specify which document type they are interested in. The INTERSECT operation ensures that only the start dates of grants that meet the criteria in both queries are returned.\"\n}\n"}
{"sample_id": "train.4338", "db_id": "tracking_grants_for_research", "question": "List the project details of the projects which did not hire any staff for a researcher role.", "rationale": ["We need to list project details from the 'Projects' table.", "We will use a LEFT JOIN to connect the 'Projects' table with the 'Project_Staff' table on the project_id.", "We will filter the join to only include staff members with a role code that corresponds to the 'Researcher' role.", "To find projects that did not hire any staff for a researcher role, we will check for NULL values in the staff_id from the 'Project_Staff' table after the join."], "gold_sql": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_Staff WHERE role_code  =  'researcher' )", "source_tables": ["project_staff", "projects"], "pred_sql": "SELECT p.project_details \nFROM Projects p \nLEFT JOIN Project_Staff ps ON p.project_id = ps.project_id AND ps.role_code = (SELECT role_code FROM Staff_Roles WHERE role_description = 'Researcher') \nWHERE ps.staff_id IS NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the project details from the 'Projects' table that are associated with specific research outcomes. The query filters the results based on a description of the research outcome, represented by a placeholder for string values.\"\n}\n"}
{"sample_id": "train.4339", "db_id": "tracking_grants_for_research", "question": "What are the details for all projects that did not hire any staff in a research role?", "rationale": ["Identify the relevant tables: Projects and Project_Staff.", "We need to find projects that did not hire any staff in a research role, so we will use a LEFT JOIN between Projects and Project_Staff.", "The join condition will be on project_id, and we will filter for staff roles that are related to research by using a subquery on Staff_Roles to get role_codes that match research roles.", "In the WHERE clause, we check for NULL in the staff_id of Project_Staff to ensure that there are no associated staff members in research roles for those projects."], "gold_sql": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_Staff WHERE role_code  =  'researcher' )", "source_tables": ["project_staff", "projects"], "pred_sql": "SELECT p.project_id, p.project_details \nFROM Projects p \nLEFT JOIN Project_Staff ps ON p.project_id = ps.project_id AND ps.role_code IN (SELECT role_code FROM Staff_Roles WHERE role_description LIKE '%research%') \nWHERE ps.staff_id IS NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the project details from the 'Projects' table that are associated with specific research outcomes. The query filters the results based on a description of the research outcome, represented by a placeholder for string values.\"\n}\n"}
{"sample_id": "train.4342", "db_id": "tracking_grants_for_research", "question": "When do all the researcher role staff start to work, and when do they stop working?", "rationale": ["Identify the relevant table: Project_Staff contains information about staff members, including their roles and dates of involvement.", "Determine the specific role of interest: We are looking for staff members with a role related to 'researcher'.", "Use the Staff_Roles table to find the role_code associated with 'researcher'.", "Construct a SQL query to select the date_from and date_to columns from Project_Staff where the role_code matches the researcher role code."], "gold_sql": "SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  'researcher'", "source_tables": ["project_staff"], "pred_sql": "SELECT date_from, date_to \nFROM Project_Staff \nWHERE role_code IN (SELECT role_code FROM Staff_Roles WHERE role_description LIKE '%researcher%');", "hint": "\n"}
{"sample_id": "train.4350", "db_id": "tracking_grants_for_research", "question": "How many staff does each project has? List the project id and the number in an ascending order.", "rationale": ["Identify the relevant table: The question asks about staff associated with projects, so we will use the Project_Staff table.", "Count the number of staff members for each project: We will use the COUNT() function to count the staff_id for each project_id.", "Group the results by project_id: We will use GROUP BY to aggregate the counts for each project.", "Order the results in ascending order: We will use ORDER BY to sort the results by project_id in ascending order."], "gold_sql": "SELECT T1.project_id ,  count(*) FROM Project_Staff AS T1 JOIN Projects AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) ASC", "source_tables": ["project_staff", "projects"], "pred_sql": "SELECT project_id, COUNT(staff_id) AS staff_count\nFROM Project_Staff\nGROUP BY project_id\nORDER BY project_id ASC;", "hint": "\n"}
{"sample_id": "train.4351", "db_id": "tracking_grants_for_research", "question": "For each project id, how many staff does it have? List them in increasing order.", "rationale": ["Identify the relevant table: The question asks about the number of staff associated with each project, so we will focus on the Project_Staff table.", "Count the staff members: We need to count the number of staff members for each project, which can be done using the COUNT() function.", "Group by project_id: To get the count of staff for each project, we will use GROUP BY on the project_id column.", "Order the results: The results should be listed in increasing order of project_id, so we will use ORDER BY project_id ASC."], "gold_sql": "SELECT T1.project_id ,  count(*) FROM Project_Staff AS T1 JOIN Projects AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) ASC", "source_tables": ["project_staff", "projects"], "pred_sql": "SELECT project_id, COUNT(staff_id) AS staff_count \nFROM Project_Staff \nGROUP BY project_id \nORDER BY project_id ASC;", "hint": "\n"}
{"sample_id": "train.4356", "db_id": "tracking_grants_for_research", "question": "Which project made the most number of outcomes? List the project details and the project id.", "rationale": ["Identify the tables involved: Projects and Project_Outcomes.", "We need to count the number of outcomes for each project, so we will join the Projects table with the Project_Outcomes table on the project_id.", "Group the results by project_id and project_details to aggregate the outcomes for each project.", "Use COUNT() to count the number of outcomes for each project.", "Order the results in descending order based on the count of outcomes to find the project with the most outcomes.", "Limit the results to 1 to get only the project with the highest count."], "gold_sql": "SELECT T1.project_details ,  T1.project_id FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "projects"], "pred_sql": "SELECT p.project_id, p.project_details\nFROM Projects p\nJOIN Project_Outcomes po ON p.project_id = po.project_id\nGROUP BY p.project_id, p.project_details\nORDER BY COUNT(po.outcome_code) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the project details from the 'Projects' table that are associated with specific research outcomes. The query filters the results based on a description of the research outcome, represented by a placeholder for string values.\"\n}\n"}
{"sample_id": "train.4359", "db_id": "tracking_grants_for_research", "question": "What are the details of the project with no outcomes?", "rationale": ["Identify the main table to query: Projects.", "Determine the condition: We need projects with no outcomes.", "To find projects with no outcomes, we can use a subquery that selects project_ids from the Project_Outcomes table.", "The main query will select all columns from the Projects table where the project_id is not in the list of project_ids returned by the subquery."], "gold_sql": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_outcomes )", "source_tables": ["project_outcomes", "projects"], "pred_sql": "SELECT * FROM Projects WHERE project_id NOT IN (SELECT project_id FROM Project_Outcomes);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the project details from the 'Projects' table that are associated with specific research outcomes. The query filters the results based on a description of the research outcome, represented by a placeholder for string values.\"\n}\n"}
{"sample_id": "train.4360", "db_id": "tracking_grants_for_research", "question": "Which organisation hired the most number of research staff? List the organisation id, type and detail.", "rationale": ["Identify the relevant tables: Organisations and Research_Staff.", "We need to find the organisation that hired the most research staff, so we will join the Organisations table with the Research_Staff table on the organisation_id.", "We will group the results by organisation_id, organisation_type, and organisation_details to count the number of research staff for each organisation.", "We will use the COUNT function to count the number of staff members for each organisation.", "To find the organisation with the most staff, we will order the results in descending order based on the count of staff members.", "Finally, we will limit the results to 1 to get only the organisation with the highest count."], "gold_sql": "SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT o.organisation_id, o.organisation_type, o.organisation_details\nFROM Organisations o\nJOIN Research_Staff rs ON o.organisation_id = rs.employer_organisation_id\nGROUP BY o.organisation_id, o.organisation_type, o.organisation_details\nORDER BY COUNT(rs.staff_id) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.4363", "db_id": "tracking_grants_for_research", "question": "For each staff id, what is the description of the role that is involved with the most number of projects?", "rationale": ["Identify the relevant tables: Project_Staff for staff involvement in projects and Staff_Roles for role descriptions.", "Join the Project_Staff table with the Staff_Roles table on the role_code to get the role descriptions for each staff member.", "Group the results by staff_id and role_description to count the number of projects each staff member is involved in for each role.", "Order the results by the count of projects in descending order to find the role with the most projects for each staff member.", "Limit the results to 1 to get the role description of the role involved with the most number of projects for each staff id."], "gold_sql": "SELECT T1.role_description ,  T2.staff_id FROM Staff_Roles AS T1 JOIN Project_Staff AS T2 ON T1.role_code  =  T2.role_code JOIN Project_outcomes AS T3 ON T2.project_id  =  T3.project_id GROUP BY T2.staff_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "project_staff", "staff_roles"], "pred_sql": "SELECT ps.staff_id, sr.role_description\nFROM Project_Staff ps\nJOIN Staff_Roles sr ON ps.role_code = sr.role_code\nGROUP BY ps.staff_id, sr.role_description\nORDER BY COUNT(ps.project_id) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.4364", "db_id": "tracking_grants_for_research", "question": "Which document type is described with the prefix 'Initial'?", "rationale": ["Identify the relevant table: The question asks about document types, so we will focus on the Document_Types table.", "Determine the filtering criteria: The user is looking for document types that start with the prefix 'Initial'.", "Construct the SQL query: We will use a SELECT statement to retrieve the document_description from the Document_Types table where the document_description matches the specified prefix using the LIKE operator."], "gold_sql": "SELECT document_type_code FROM Document_Types WHERE document_description LIKE 'Initial%'", "source_tables": ["document_types"], "pred_sql": "SELECT document_description FROM Document_Types WHERE document_description LIKE 'Initial%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the start dates of grants from the 'Grants' table that are associated with documents of a specific type. It uses joins to connect the 'Grants', 'Documents', and 'Document_Types' tables based on their foreign key relationships. The placeholder in the WHERE clause represents the description of the document type, allowing users to specify which document type they are interested in. The INTERSECT operation ensures that only the start dates of grants that meet the criteria in both queries are returned.\",\n    \"1\": \"This virtual table retrieves the response received dates of documents from the 'Documents' table, joining with 'Document_Types' to filter by a specific document description and with 'Grants' to filter by grant amount. The placeholders in the WHERE clause represent the document description and the grant amount criteria.\",\n    \"2\": \"This virtual table provides the sent dates of documents from the 'Documents' table that are associated with grants exceeding a specified amount. The query joins multiple tables: 'Grants' to link grants with documents, 'Organisations' to connect grants to their respective organisations, and 'Organisation_Types' to filter organisations based on their type description. The placeholders in the WHERE clause represent the grant amount and the organisation type description.\"\n}\n"}
{"sample_id": "train.4369", "db_id": "tracking_grants_for_research", "question": "For each grant id, how many documents does it have, and which one has the most?", "rationale": ["Identify the relevant tables: We need to work with the 'Documents' and 'Grants' tables to get the required information about documents associated with each grant.", "Count the number of documents for each grant: We can use the COUNT() function to count the number of documents for each grant by grouping the results by 'grant_id'.", "Select the grant_id and the count of documents: The SELECT statement will include 'grant_id' and the count of documents as 'document_count'.", "Determine which grant has the most documents: We can order the results by 'document_count' in descending order to find the grant with the most documents.", "Limit the results to the top grant: Using LIMIT 1 will ensure we only get the grant with the highest document count."], "gold_sql": "SELECT grant_id ,  count(*) FROM Documents GROUP BY grant_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["documents"], "pred_sql": "SELECT d.grant_id, COUNT(d.document_id) AS document_count, d.document_id \nFROM Documents d \nJOIN Grants g ON d.grant_id = g.grant_id \nGROUP BY d.grant_id \nORDER BY document_count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the sent dates of documents from the 'Documents' table that are associated with grants exceeding a specified amount. The query joins multiple tables: 'Grants' to link grants with documents, 'Organisations' to connect grants to their respective organisations, and 'Organisation_Types' to filter organisations based on their type description. The placeholders in the WHERE clause represent the grant amount and the organisation type description.\",\n    \"1\": \"This virtual table retrieves the response received dates of documents from the 'Documents' table, joining with 'Document_Types' to filter by a specific document description and with 'Grants' to filter by grant amount. The placeholders in the WHERE clause represent the document description and the grant amount criteria.\",\n    \"2\": \"This virtual table retrieves the start dates of grants from the 'Grants' table that are associated with documents of a specific type. It uses joins to connect the 'Grants', 'Documents', and 'Document_Types' tables based on their foreign key relationships. The placeholder in the WHERE clause represents the description of the document type, allowing users to specify which document type they are interested in. The INTERSECT operation ensures that only the start dates of grants that meet the criteria in both queries are returned.\"\n}\n"}
{"sample_id": "train.4374", "db_id": "tracking_grants_for_research", "question": "How many Patent outcomes are generated from all the projects?", "rationale": ["Identify the relevant tables: Project_Outcomes and Research_Outcomes are needed to find the patent outcomes related to projects.", "Determine the relationship: Project_Outcomes has a foreign key relationship with Research_Outcomes through the outcome_code.", "Filter the results: We need to count only those outcomes that are described as 'Patent'.", "Construct the SQL query: Use COUNT(*) to count the number of patent outcomes, joining the two tables and applying the filter in the WHERE clause."], "gold_sql": "SELECT count(*) FROM Project_outcomes WHERE outcome_code  =  'Patent'", "source_tables": ["project_outcomes"], "pred_sql": "SELECT COUNT(*) AS patent_outcome_count\nFROM Project_Outcomes\nJOIN Research_Outcomes ON Project_Outcomes.outcome_code = Research_Outcomes.outcome_code\nWHERE Research_Outcomes.outcome_description LIKE '%Patent%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the project details from the 'Projects' table that are associated with specific research outcomes. The query filters the results based on a description of the research outcome, represented by a placeholder for string values.\"\n}\n"}
{"sample_id": "train.4376", "db_id": "tracking_grants_for_research", "question": "How many project staff worked as leaders or started working before '1989-04-24 23:51:54'?", "rationale": ["Identify the relevant table: Project_Staff contains information about staff members associated with projects.", "Determine the criteria for counting staff: We need to count staff who worked as leaders or started before a specific date.", "Identify the role codes for leaders: Use the Staff_Roles table to find role codes where the role description includes 'leader'.", "Filter the Project_Staff table: Use a subquery to filter Project_Staff based on the role codes obtained from the Staff_Roles table and also check the date_from column to ensure it is before '1989-04-24 23:51:54'.", "Construct the SQL query to count the number of staff members meeting these criteria."], "gold_sql": "SELECT count(*) FROM Project_Staff WHERE role_code  =  'leader' OR date_from  <  '1989-04-24 23:51:54'", "source_tables": ["project_staff"], "pred_sql": "SELECT COUNT(*) \nFROM Project_Staff \nWHERE role_code IN (SELECT role_code FROM Staff_Roles WHERE role_description LIKE '%leader%') \nAND date_from < '1989-04-24 23:51:54';", "hint": "\n"}
{"sample_id": "train.4380", "db_id": "tracking_grants_for_research", "question": "What are the result description of the project whose detail is 'sint'?", "rationale": ["Identify the relevant tables: Projects, Project_Outcomes, and Research_Outcomes are needed to get the project details and their associated outcomes.", "Join the Projects table with Project_Outcomes on project_id to link projects with their outcomes.", "Join the resulting table with Research_Outcomes on outcome_code to get the details of the outcomes.", "Filter the results where the project details match the specified value 'sint'.", "Select the outcome_details from the Research_Outcomes table as the final output."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code JOIN Projects AS T3 ON T2.project_id  =  T3.project_id WHERE T3.project_details  =  'sint'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "pred_sql": "SELECT Research_Outcomes.outcome_details \nFROM Projects \nJOIN Project_Outcomes ON Projects.project_id = Project_Outcomes.project_id \nJOIN Research_Outcomes ON Project_Outcomes.outcome_code = Research_Outcomes.outcome_code \nWHERE Projects.project_details = 'sint';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the project details from the 'Projects' table that are associated with specific research outcomes. The query filters the results based on a description of the research outcome, represented by a placeholder for string values.\",\n    \"1\": \"This virtual table retrieves the response received dates of documents from the 'Documents' table, joining with 'Document_Types' to filter by a specific document description and with 'Grants' to filter by grant amount. The placeholders in the WHERE clause represent the document description and the grant amount criteria.\"\n}\n"}
{"sample_id": "train.4381", "db_id": "tracking_grants_for_research", "question": "What is the description for the results whose project detail is 'sint'?", "rationale": ["Identify the relevant tables: Projects, Project_Outcomes, and Research_Outcomes are needed to get the project details and their associated outcomes.", "Join the Projects table with Project_Outcomes on project_id to link projects with their outcomes.", "Join the Project_Outcomes table with Research_Outcomes on outcome_code to get the descriptions of the outcomes.", "Filter the results where the project details match the specified value 'sint'.", "Select the outcome_description from the Research_Outcomes table as the final output."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code JOIN Projects AS T3 ON T2.project_id  =  T3.project_id WHERE T3.project_details  =  'sint'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "pred_sql": "SELECT Research_Outcomes.outcome_description \nFROM Projects \nJOIN Project_Outcomes ON Projects.project_id = Project_Outcomes.project_id \nJOIN Research_Outcomes ON Project_Outcomes.outcome_code = Research_Outcomes.outcome_code \nWHERE Projects.project_details = 'sint';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the project details from the 'Projects' table that are associated with specific research outcomes. The query filters the results based on a description of the research outcome, represented by a placeholder for string values.\",\n    \"1\": \"This virtual table retrieves the response received dates of documents from the 'Documents' table, joining with 'Document_Types' to filter by a specific document description and with 'Grants' to filter by grant amount. The placeholders in the WHERE clause represent the document description and the grant amount criteria.\"\n}\n"}
{"sample_id": "train.4385", "db_id": "tracking_grants_for_research", "question": "What are the details for the projects which were launched by the organization with the most projects?", "rationale": ["Identify the main goal: Retrieve details of projects launched by the organization with the most projects.", "To find the organization with the most projects, we need to count the number of projects associated with each organization.", "We will use a subquery to count projects grouped by organization_id and order them in descending order to get the organization with the highest count.", "The outer query will select all project details from the Projects table where the organization_id matches the one found in the subquery."], "gold_sql": "SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT 1 )", "source_tables": ["projects"], "pred_sql": "SELECT p.* \nFROM Projects p \nWHERE p.organisation_id = (\n    SELECT o.organisation_id \n    FROM Organisations o \n    JOIN Projects pr ON o.organisation_id = pr.organisation_id \n    GROUP BY o.organisation_id \n    ORDER BY COUNT(pr.project_id) DESC \n    LIMIT 1\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the project details from the 'Projects' table that are associated with specific research outcomes. The query filters the results based on a description of the research outcome, represented by a placeholder for string values.\",\n    \"1\": \"This virtual table provides the sent dates of documents from the 'Documents' table that are associated with grants exceeding a specified amount. The query joins multiple tables: 'Grants' to link grants with documents, 'Organisations' to connect grants to their respective organisations, and 'Organisation_Types' to filter organisations based on their type description. The placeholders in the WHERE clause represent the grant amount and the organisation type description.\"\n}\n"}
{"sample_id": "train.4391", "db_id": "tracking_grants_for_research", "question": "For each project id, how many tasks are there?", "rationale": ["Identify the relevant table: The question asks about tasks associated with projects, so we will use the 'Tasks' table.", "Count the number of tasks for each project: We need to group the results by 'project_id' and count the 'task_id' for each group.", "Construct the SQL query: We will select 'project_id' and the count of 'task_id' as 'task_count', and use GROUP BY to aggregate the results by 'project_id'."], "gold_sql": "SELECT count(*) ,  T1.project_details FROM Projects AS T1 JOIN Tasks AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id", "source_tables": ["tasks", "projects"], "pred_sql": "SELECT project_id, COUNT(task_id) AS task_count\nFROM Tasks\nGROUP BY project_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the project details from the 'Projects' table that are associated with specific research outcomes. The query filters the results based on a description of the research outcome, represented by a placeholder for string values.\"\n}\n"}
{"sample_id": "train.4392", "db_id": "tracking_grants_for_research", "question": "What are the staff roles of the staff who", "rationale": ["Identify the relevant table for staff roles, which is 'Staff_Roles'.", "Select the columns 'role_code' and 'role_description' from the 'Staff_Roles' table to get the information about staff roles."], "gold_sql": "SELECT role_code FROM Project_Staff WHERE date_from  >  '2003-04-19 15:06:20' AND date_to  <  '2016-03-15 00:33:18'", "source_tables": ["project_staff"], "pred_sql": "SELECT role_code, role_description FROM Staff_Roles;", "hint": "\n"}
{"sample_id": "train.4397", "db_id": "tracking_grants_for_research", "question": "What is the most common role for the staff?", "rationale": ["Identify the table that contains staff roles, which is 'Project_Staff'.", "To find the most common role, we need to count the occurrences of each role code in the 'Project_Staff' table.", "Use the COUNT() function to count the number of staff members for each role code.", "Group the results by 'role_code' to aggregate the counts for each role.", "Order the results in descending order based on the count to get the most common role at the top.", "Limit the results to 1 to get only the most common role."], "gold_sql": "SELECT role_code FROM Project_Staff GROUP BY role_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_staff"], "pred_sql": "SELECT role_code, COUNT(*) as role_count \nFROM Project_Staff \nGROUP BY role_code \nORDER BY role_count DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5534", "db_id": "products_gen_characteristics", "question": "Find the number of products with category \"Spices\" and typically sold above 1000.", "rationale": ["Identify the relevant tables: Products and Ref_Product_Categories.", "We need to count the number of products, so we will use COUNT(*) in the SELECT statement.", "Join the Products table with the Ref_Product_Categories table on the product_category_code to filter by category.", "Add a WHERE clause to filter for products in the 'Spices' category.", "Add another condition in the WHERE clause to filter for products with a typical selling price greater than 1000."], "gold_sql": "SELECT count(*) FROM products WHERE product_category_code  =  'Spices' AND typical_buying_price  >  1000", "source_tables": ["products"], "pred_sql": "SELECT COUNT(*) \nFROM Products p \nJOIN Ref_Product_Categories c ON p.product_category_code = c.product_category_code \nWHERE c.product_category_description = 'Spices' \nAND p.typical_selling_price > 1000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n    \"1\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n    \"2\": \"This virtual table provides a count of products that either match a specific color description or have a specific characteristic name. It combines data from multiple tables, including 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors', using joins based on their relationships. The placeholders in the WHERE clause represent the color description and characteristic name that the user can specify.\"\n}\n"}
{"sample_id": "train.5543", "db_id": "products_gen_characteristics", "question": "What are the descriptions of the categories that products with product descriptions that contain the letter t are in?", "rationale": ["Identify the relevant tables: Products and Ref_Product_Categories.", "We need to retrieve the product category descriptions, so we will select from Ref_Product_Categories.", "Join the Products table with Ref_Product_Categories on the product_category_code to link products to their categories.", "Filter the products based on their descriptions containing the letter 't' using the LIKE operator.", "Use DISTINCT to ensure that we only get unique product category descriptions."], "gold_sql": "SELECT T1.product_category_description FROM ref_product_categories AS T1 JOIN products AS T2 ON T1.product_category_code  =  T2.product_category_code WHERE T2.product_description LIKE '%t%'", "source_tables": ["products", "ref_product_categories"], "pred_sql": "SELECT DISTINCT rpc.product_category_description \nFROM Products p \nJOIN Ref_Product_Categories rpc ON p.product_category_code = rpc.product_category_code \nWHERE p.product_description LIKE '%t%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of characteristics associated with a specific product from the 'Products' table. The query filters the results based on the product's name and the type of characteristic, using placeholders for both values.\",\n    \"1\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n    \"2\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\"\n}\n"}
{"sample_id": "train.5576", "db_id": "products_gen_characteristics", "question": "Count the products that have the color description \"white\" or have the characteristic name \"hot\".", "rationale": ["We need to count the products that either have the color description 'white' or have the characteristic name 'hot'.", "To achieve this, we will select from the 'Products' table and join it with the 'Ref_Colors' table to filter by color description.", "We also need to join the 'Product_Characteristics' table to access the characteristics associated with each product.", "Then, we join the 'Characteristics' table to filter by characteristic name.", "In the WHERE clause, we will specify the conditions for color description and characteristic name.", "Finally, we will use COUNT(DISTINCT p.product_id) to count the unique products that meet either of the conditions."], "gold_sql": "SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  'white' OR t3.characteristic_name  =  'hot'", "source_tables": ["products", "ref_colors", "characteristics", "product_characteristics"], "pred_sql": "SELECT COUNT(DISTINCT p.product_id) \nFROM Products p \nLEFT JOIN Ref_Colors c ON p.color_code = c.color_code \nLEFT JOIN Product_Characteristics pc ON p.product_id = pc.product_id \nLEFT JOIN Characteristics ch ON pc.characteristic_id = ch.characteristic_id \nWHERE c.color_description = 'white' OR ch.characteristic_name = 'hot';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of products that either match a specific color description or have a specific characteristic name. It combines data from multiple tables, including 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors', using joins based on their relationships. The placeholders in the WHERE clause represent the color description and characteristic name that the user can specify.\",\n    \"1\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n    \"2\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\"\n}\n"}
{"sample_id": "train.5579", "db_id": "products_gen_characteristics", "question": "Return the unit of measure for 'Herb' products.", "rationale": ["Identify the relevant tables: Products, Product_Characteristics, and Characteristics are needed to get the unit of measure for 'Herb' products.", "The Products table contains the product information including the unit of measure.", "The Product_Characteristics table links products to their characteristics.", "We need to filter the products based on the name containing 'Herb'.", "The final query will select the unit of measure from the Products table for those products that match the name criteria."], "gold_sql": "SELECT unit_of_measure FROM ref_product_categories WHERE product_category_code  =  'Herbs'", "source_tables": ["ref_product_categories"], "pred_sql": "SELECT pc.product_id, p.unit_of_measure \nFROM Products p \nJOIN Product_Characteristics pc ON p.product_id = pc.product_id \nJOIN Characteristics c ON pc.characteristic_id = c.characteristic_id \nWHERE p.product_name LIKE '%Herb%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n    \"1\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n    \"2\": \"This virtual table describes the names of characteristics associated with a specific product from the 'Products' table. The query filters the results based on the product's name and the type of characteristic, using placeholders for both values.\"\n}\n"}
{"sample_id": "train.5586", "db_id": "products_gen_characteristics", "question": "Find the unit of measurement and product category code of product named \"chervil\".", "rationale": ["Identify the relevant tables: Products and Ref_Product_Categories.", "Determine the columns needed: product_category_code from Ref_Product_Categories and product_name from Products.", "Establish the relationship between the tables using the foreign key: Products.product_category_code links to Ref_Product_Categories.product_category_code.", "Filter the results based on the product name 'chervil'.", "Construct the SQL query to select the required columns and apply the necessary join and where clause."], "gold_sql": "SELECT t2.unit_of_measure ,  t2.product_category_code FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code WHERE t1.product_name  =  'chervil'", "source_tables": ["products", "ref_product_categories"], "pred_sql": "SELECT pc.product_category_code, p.product_name\nFROM Products p\nJOIN Ref_Product_Categories pc ON p.product_category_code = pc.product_category_code\nWHERE p.product_name = 'chervil';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n    \"1\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n    \"2\": \"This virtual table describes the names of characteristics associated with a specific product from the 'Products' table. The query filters the results based on the product's name and the type of characteristic, using placeholders for both values.\"\n}\n"}
{"sample_id": "train.5589", "db_id": "products_gen_characteristics", "question": "What are the names of products that are not 'white' in color and are not measured by the unit 'Handful'?", "rationale": ["Identify the relevant tables: Products, Ref_Colors, Product_Characteristics, Characteristics, and Ref_Product_Categories.", "Join the Products table with Ref_Colors to filter out products that are white in color.", "Join the Products table with Product_Characteristics to access the characteristics of each product.", "Join the Product_Characteristics table with Characteristics to get the details of the characteristics.", "Join the Products table with Ref_Product_Categories to access the unit of measure for each product.", "Use a WHERE clause to filter out products that are not 'white' in color and do not have a unit of measure of 'Handful'.", "Select the product_name from the resulting joined tables."], "gold_sql": "SELECT t1.product_name FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code JOIN ref_colors AS t3 ON t1.color_code  =  t3.color_code WHERE t3.color_description  =  'white' AND t2.unit_of_measure != 'Handful'", "source_tables": ["products", "ref_colors", "ref_product_categories"], "pred_sql": "SELECT product_name \nFROM Products \nJOIN Ref_Colors ON Products.color_code = Ref_Colors.color_code \nJOIN Product_Characteristics ON Products.product_id = Product_Characteristics.product_id \nJOIN Characteristics ON Product_Characteristics.characteristic_id = Characteristics.characteristic_id \nJOIN Ref_Product_Categories ON Products.product_category_code = Ref_Product_Categories.product_category_code \nWHERE Ref_Colors.color_description != 'white' \nAND Ref_Product_Categories.unit_of_measure != 'Handful';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of products that either match a specific color description or have a specific characteristic name. It combines data from multiple tables, including 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors', using joins based on their relationships. The placeholders in the WHERE clause represent the color description and characteristic name that the user can specify.\",\n    \"1\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n    \"2\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\"\n}\n"}
{"sample_id": "train.5592", "db_id": "products_gen_characteristics", "question": "What is the description of the color used by least products?", "rationale": ["Identify the color descriptions from the Ref_Colors table.", "To find the color used by the least products, we need to count the number of products associated with each color.", "This requires a subquery that groups the Products table by color_code and counts the number of product_id for each color.", "We then order this count in ascending order to find the color with the least products.", "Finally, we limit the results to 1 to get the color code of the least used color, and use this in the main query to get the corresponding color description."], "gold_sql": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) ASC LIMIT 1", "source_tables": ["products", "ref_colors"], "pred_sql": "SELECT color_description\nFROM Ref_Colors\nWHERE color_code = (\n    SELECT color_code\n    FROM Products\n    GROUP BY color_code\n    ORDER BY COUNT(product_id) ASC\n    LIMIT 1\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of products that either match a specific color description or have a specific characteristic name. It combines data from multiple tables, including 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors', using joins based on their relationships. The placeholders in the WHERE clause represent the color description and characteristic name that the user can specify.\",\n    \"1\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n    \"2\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\"\n}\n"}
{"sample_id": "train.5599", "db_id": "products_gen_characteristics", "question": "Give the names of characteristics that are in two or more products?", "rationale": ["We need to find the names of characteristics that are associated with two or more products.", "To do this, we will join the Characteristics table with the Product_Characteristics table to link characteristics to products.", "Next, we will join the Products table to get the product information associated with each characteristic.", "We will group the results by the characteristic name to count how many distinct products each characteristic is associated with.", "Finally, we will use the HAVING clause to filter the results to only include characteristics that are linked to two or more products."], "gold_sql": "SELECT t3.characteristic_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id GROUP BY t3.characteristic_name HAVING count(*)  >= 2", "source_tables": ["products", "characteristics", "product_characteristics"], "pred_sql": "SELECT c.characteristic_name\nFROM Characteristics c\nJOIN Product_Characteristics pc ON c.characteristic_id = pc.characteristic_id\nJOIN Products p ON pc.product_id = p.product_id\nGROUP BY c.characteristic_name\nHAVING COUNT(DISTINCT p.product_id) >= 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of characteristics associated with a specific product from the 'Products' table. The query filters the results based on the product's name and the type of characteristic, using placeholders for both values.\",\n    \"1\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n    \"2\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\"\n}\n"}
{"sample_id": "train.5669", "db_id": "dorm_1", "question": "What are the names of the all-female dorms?", "rationale": ["Identify the relevant table: The question asks about dorms, so we will focus on the 'Dorm' table.", "Determine the condition: The question specifies 'all-female' dorms, which indicates we need to filter by the 'gender' column in the 'Dorm' table.", "Construct the SQL query: We will select the 'dorm_name' from the 'Dorm' table where the 'gender' is 'female'."], "gold_sql": "SELECT dorm_name FROM dorm WHERE gender  =  'F'", "source_tables": ["dorm"], "pred_sql": "SELECT dorm_name FROM Dorm WHERE gender = 'female';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first names and ages of students who live in dormitories that do not offer a specific amenity. The placeholder in the subquery represents the name of the amenity being checked.\",\n    \"1\": \"This virtual table describes the first names of students who live in dormitories that have the most amenities. The query joins the 'Student' table with the 'Lives_in' table to find students residing in specific dorms. It filters the dorms based on a subquery that counts the number of amenities in each dorm, ordering them by the count and limiting the results to a specified number of dormitories. The placeholder in the LIMIT clause represents the maximum number of dormitories to consider.\"\n}\n"}
{"sample_id": "train.5688", "db_id": "dorm_1", "question": "Find the average and total capacity of dorms for the students with gender X.", "rationale": ["Identify the tables needed: Dorm, Lives_in, and Student.", "We need to calculate the average and total capacity of dorms, so we will use the 'student_capacity' column from the Dorm table.", "To find the relevant dorms, we need to join the Dorm table with the Lives_in table on 'dormid', and then join with the Student table on 'stuid'.", "We will filter the results based on the gender of the students, specifically where 'Sex' equals 'X'.", "Finally, we will use the AVG() function to calculate the average capacity and the SUM() function to calculate the total capacity of the dorms that meet the criteria."], "gold_sql": "SELECT avg(student_capacity) ,  sum(student_capacity) FROM dorm WHERE gender  =  'X'", "source_tables": ["dorm"], "pred_sql": "SELECT AVG(Dorm.student_capacity) AS average_capacity, SUM(Dorm.student_capacity) AS total_capacity \nFROM Dorm \nJOIN Lives_in ON Dorm.dormid = Lives_in.dormid \nJOIN Student ON Lives_in.stuid = Student.StuID \nWHERE Student.Sex = 'X';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first names and ages of students who live in dormitories that do not offer a specific amenity. The placeholder in the subquery represents the name of the amenity being checked.\",\n    \"1\": \"This virtual table describes the first names of students who live in dormitories that have the most amenities. The query joins the 'Student' table with the 'Lives_in' table to find students residing in specific dorms. It filters the dorms based on a subquery that counts the number of amenities in each dorm, ordering them by the count and limiting the results to a specified number of dormitories. The placeholder in the LIMIT clause represents the maximum number of dormitories to consider.\"\n}\n"}
{"sample_id": "train.5699", "db_id": "dorm_1", "question": "What are the names and types of the dorms that have a capacity greater than 300 or less than 100?", "rationale": ["Identify the relevant table: The Dorm table contains information about dormitories, including their names and capacities.", "Determine the columns needed: We need the dorm_name and student_capacity columns from the Dorm table.", "Set the condition for filtering: We want dorms with a capacity greater than 300 or less than 100.", "Construct the SQL query: Use a SELECT statement to retrieve the required columns from the Dorm table with the specified conditions in the WHERE clause."], "gold_sql": "SELECT dorm_name ,  gender FROM dorm WHERE student_capacity  >  300 OR student_capacity  <  100", "source_tables": ["dorm"], "pred_sql": "SELECT dorm_name, student_capacity \nFROM Dorm \nWHERE student_capacity > 300 OR student_capacity < 100;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students who live in dormitories that have the most amenities. The query joins the 'Student' table with the 'Lives_in' table to find students residing in specific dorms. It filters the dorms based on a subquery that counts the number of amenities in each dorm, ordering them by the count and limiting the results to a specified number of dormitories. The placeholder in the LIMIT clause represents the maximum number of dormitories to consider.\",\n    \"1\": \"This virtual table provides the first names and ages of students who live in dormitories that do not offer a specific amenity. The placeholder in the subquery represents the name of the amenity being checked.\"\n}\n"}
{"sample_id": "train.5747", "db_id": "dorm_1", "question": "What are the total number of students who are living in a male dorm?", "rationale": ["Identify the tables needed: We need to count students living in male dorms, so we will use the 'Lives_in', 'Dorm', and 'Student' tables.", "Join the 'Lives_in' table with the 'Dorm' table on 'dormid' to get information about the dorms where students live.", "Join the result with the 'Student' table on 'StuID' to access student information.", "Filter the results to include only those dorms where the gender is 'male'.", "Use the COUNT function to get the total number of students that meet the criteria."], "gold_sql": "SELECT count(*) FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T3.gender  =  'M'", "source_tables": ["student", "lives_in", "dorm"], "pred_sql": "SELECT COUNT(*) AS total_students\nFROM Lives_in li\nJOIN Dorm d ON li.dormid = d.dormid\nJOIN Student s ON li.stuid = s.StuID\nWHERE d.gender = 'male';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students who live in dormitories that have the most amenities. The query joins the 'Student' table with the 'Lives_in' table to find students residing in specific dorms. It filters the dorms based on a subquery that counts the number of amenities in each dorm, ordering them by the count and limiting the results to a specified number of dormitories. The placeholder in the LIMIT clause represents the maximum number of dormitories to consider.\",\n    \"1\": \"This virtual table provides the first names and ages of students who live in dormitories that do not offer a specific amenity. The placeholder in the subquery represents the name of the amenity being checked.\"\n}\n"}
{"sample_id": "train.5755", "db_id": "dorm_1", "question": "What is the most common amenity in the dorms?", "rationale": ["To find the most common amenity in the dorms, we need to count how many times each amenity appears in the Has_amenity table.", "We will join the Has_amenity table with the Dorm table to ensure we are counting amenities that are associated with existing dorms.", "We will group the results by the amenity identifier (amenid) to get the count of each amenity.", "Next, we will order the results in descending order based on the count of amenities to find the most common one.", "Finally, we will limit the results to 1 to get only the most common amenity."], "gold_sql": "SELECT T1.amenity_name FROM dorm_amenity AS T1 JOIN has_amenity AS T2 ON T1.amenid  =  T2.amenid GROUP BY T2.amenid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["has_amenity", "dorm_amenity"], "pred_sql": "SELECT ha.amenid, COUNT(ha.amenid) AS amenity_count\nFROM Has_amenity ha\nJOIN Dorm d ON ha.dormid = d.dormid\nGROUP BY ha.amenid\nORDER BY amenity_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first names and ages of students who live in dormitories that do not offer a specific amenity. The placeholder in the subquery represents the name of the amenity being checked.\",\n    \"1\": \"This virtual table describes the first names of students who live in dormitories that have the most amenities. The query joins the 'Student' table with the 'Lives_in' table to find students residing in specific dorms. It filters the dorms based on a subquery that counts the number of amenities in each dorm, ordering them by the count and limiting the results to a specified number of dormitories. The placeholder in the LIMIT clause represents the maximum number of dormitories to consider.\"\n}\n"}
{"sample_id": "train.5757", "db_id": "dorm_1", "question": "What are the first names of all students who live in the dorm with the most amenities?", "rationale": ["Identify the main goal: to find the first names of students living in the dorm with the most amenities.", "Determine the relationship between the tables: Students live in dorms, and dorms have amenities.", "Use the Lives_in table to link students to their respective dorms.", "Count the number of amenities for each dorm using the Has_amenity table, grouping by dormid.", "Order the results of the count in descending order to find the dorm with the most amenities.", "Limit the results to the top dorm (the one with the most amenities).", "Use the dormid from the previous step to filter the Lives_in table to find students living in that dorm.", "Finally, select the first names of those students from the Student table."], "gold_sql": "SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["has_amenity", "lives_in", "student", "dorm_amenity", "dorm"], "pred_sql": "SELECT Fname FROM Student WHERE StuID IN (SELECT stuid FROM Lives_in WHERE dormid IN (SELECT dormid FROM Has_amenity GROUP BY dormid ORDER BY COUNT(amenid) DESC LIMIT 1));", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students who live in dormitories that have the most amenities. The query joins the 'Student' table with the 'Lives_in' table to find students residing in specific dorms. It filters the dorms based on a subquery that counts the number of amenities in each dorm, ordering them by the count and limiting the results to a specified number of dormitories. The placeholder in the LIMIT clause represents the maximum number of dormitories to consider.\",\n    \"1\": \"This virtual table provides the first names and ages of students who live in dormitories that do not offer a specific amenity. The placeholder in the subquery represents the name of the amenity being checked.\"\n}\n"}
{"sample_id": "train.5776", "db_id": "customer_complaints", "question": "Find the emails of customers who has filed a complaints of the product with the most complaints.", "rationale": ["Identify the product with the most complaints by grouping the Complaints table by product_id and counting the number of complaints for each product.", "Use a subquery to find the product_id that has the highest count of complaints.", "Join the Customers table with the Complaints table to get the email addresses of customers who filed complaints for the identified product.", "Select distinct email addresses to avoid duplicates in the results."], "gold_sql": "SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "customers"], "pred_sql": "SELECT DISTINCT c.email_address\nFROM Customers c\nJOIN Complaints comp ON c.customer_id = comp.customer_id\nWHERE comp.product_id = (\n    SELECT product_id\n    FROM Complaints\n    GROUP BY product_id\n    ORDER BY COUNT(*) DESC\n    LIMIT 1\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct product names from the 'Products' table that have been associated with complaints. The query joins the 'Products' table with the 'Complaints' table based on the product identifier, and it groups the results by customer identifiers from the 'Customers' table. The results are ordered by the count of complaints for each customer, and a limit is applied to restrict the number of results returned based on a specified numeric value.\",\n    \"1\": \"This virtual table provides a list of last names of staff members who are handling complaints related to products, ordered by the price of those products. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\"\n}\n"}
{"sample_id": "train.5777", "db_id": "customer_complaints", "question": "What are the emails of customers who have filed complaints on the product which has had the greatest number of complaints?", "rationale": ["Identify the goal: We need to find the emails of customers who have filed complaints about the product with the greatest number of complaints.", "To achieve this, we will need to join the Customers table with the Complaints table on the customer_id.", "Next, we need to determine which product has the greatest number of complaints. This can be done by grouping the Complaints table by product_id and counting the number of complaints for each product.", "We will order the results of this grouping in descending order based on the count of complaints and limit the results to 1 to get the product with the highest count.", "Finally, we will use the product_id obtained from the subquery to filter the main query to get the email addresses of the customers who complained about that product."], "gold_sql": "SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "customers"], "pred_sql": "SELECT c.email_address\nFROM Customers c\nJOIN Complaints comp ON c.customer_id = comp.customer_id\nWHERE comp.product_id = (\n    SELECT product_id\n    FROM Complaints\n    GROUP BY product_id\n    ORDER BY COUNT(*) DESC\n    LIMIT 1\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of last names of staff members who are handling complaints related to products, ordered by the price of those products. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n    \"1\": \"This virtual table provides a list of distinct product names from the 'Products' table that have been associated with complaints. The query joins the 'Products' table with the 'Complaints' table based on the product identifier, and it groups the results by customer identifiers from the 'Customers' table. The results are ordered by the count of complaints for each customer, and a limit is applied to restrict the number of results returned based on a specified numeric value.\"\n}\n"}
{"sample_id": "train.5779", "db_id": "customer_complaints", "question": "Return the names of products that have had complaints filed by the customer who has filed the fewest complaints.", "rationale": ["We need to find the names of products that have had complaints filed by the customer who has filed the fewest complaints.", "To do this, we will join the Products table with the Complaints table on the product_id, as we want to get product names related to complaints.", "Next, we will join the Customers table to the Complaints table on customer_id to associate complaints with customers.", "We will group the results by customer_id to count the number of complaints each customer has filed.", "We will order the results by the count of complaints in ascending order to find the customer with the fewest complaints.", "Finally, we will select the distinct product names and limit the results to 1 to get the products associated with the customer who has filed the fewest complaints."], "gold_sql": "SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "products", "customers"], "pred_sql": "SELECT DISTINCT p.product_name \nFROM Products p \nJOIN Complaints c ON p.product_id = c.product_id \nJOIN Customers cu ON c.customer_id = cu.customer_id \nGROUP BY cu.customer_id \nORDER BY COUNT(c.complaint_id) ASC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct product names from the 'Products' table that have been associated with complaints. The query joins the 'Products' table with the 'Complaints' table based on the product identifier, and it groups the results by customer identifiers from the 'Customers' table. The results are ordered by the count of complaints for each customer, and a limit is applied to restrict the number of results returned based on a specified numeric value.\",\n    \"1\": \"This virtual table provides a list of last names of staff members who are handling complaints related to products, ordered by the price of those products. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\"\n}\n"}
{"sample_id": "train.5795", "db_id": "customer_complaints", "question": "What is the last name of the staff member in charge of the complaint on the product with the lowest price?", "rationale": ["Identify the tables involved: Staff, Complaints, and Products.", "We need to find the last name of the staff member handling a complaint related to the product with the lowest price.", "Join the Staff table with the Complaints table on staff_id to link staff members to complaints.", "Join the Complaints table with the Products table on product_id to link complaints to products.", "Use a subquery to find the minimum product price from the Products table.", "Filter the results to only include complaints related to the product with the lowest price.", "Select the last name of the staff member from the resulting joined tables."], "gold_sql": "SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT 1", "source_tables": ["complaints", "products", "staff"], "pred_sql": "SELECT Staff.last_name \nFROM Staff \nJOIN Complaints ON Staff.staff_id = Complaints.staff_id \nJOIN Products ON Complaints.product_id = Products.product_id \nWHERE Products.product_price = (SELECT MIN(product_price) FROM Products) \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of last names of staff members who are handling complaints related to products, ordered by the price of those products. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n    \"1\": \"This virtual table provides a list of distinct product names from the 'Products' table that have been associated with complaints. The query joins the 'Products' table with the 'Complaints' table based on the product identifier, and it groups the results by customer identifiers from the 'Customers' table. The results are ordered by the count of complaints for each customer, and a limit is applied to restrict the number of results returned based on a specified numeric value.\"\n}\n"}
{"sample_id": "train.5800", "db_id": "customer_complaints", "question": "How many customers are there in the customer type with the most customers?", "rationale": ["Identify the relevant table: The question pertains to customers, so we will focus on the 'Customers' table.", "Determine the required information: We need to count the number of customers for each customer type.", "Group the results: We will group the results by 'customer_type_code' to get the count for each type.", "Count the customers: Use COUNT(customer_id) to count the number of customers in each type.", "Order the results: We will order the results in descending order based on the count of customers to find the type with the most customers.", "Limit the results: Finally, we will limit the results to 1 to get only the customer type with the highest count."], "gold_sql": "SELECT count(*) FROM customers GROUP BY customer_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers"], "pred_sql": "SELECT customer_type_code, COUNT(customer_id) AS customer_count\nFROM Customers\nGROUP BY customer_type_code\nORDER BY customer_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct product names from the 'Products' table that have been associated with complaints. The query joins the 'Products' table with the 'Complaints' table based on the product identifier, and it groups the results by customer identifiers from the 'Customers' table. The results are ordered by the count of complaints for each customer, and a limit is applied to restrict the number of results returned based on a specified numeric value.\",\n    \"1\": \"This virtual table provides a list of last names of staff members who are handling complaints related to products, ordered by the price of those products. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\"\n}\n"}
{"sample_id": "train.5810", "db_id": "customer_complaints", "question": "What is first names of the top 5 staff who have handled the greatest number of complaints?", "rationale": ["Identify the main goal: Retrieve the first names of the top 5 staff members who have handled the greatest number of complaints.", "To achieve this, we need to count the number of complaints handled by each staff member. This can be done by grouping the Complaints table by staff_id and counting the complaint_id.", "Next, we will order the results in descending order based on the count of complaints to get the staff who handled the most complaints at the top.", "We will limit the results to the top 5 staff members using the LIMIT clause.", "Finally, we will select the first names of these top 5 staff members from the Staff table using a subquery that retrieves the staff_ids of the top 5 staff members."], "gold_sql": "SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT 5", "source_tables": ["complaints", "staff"], "pred_sql": "SELECT first_name FROM Staff WHERE staff_id IN (SELECT staff_id FROM Complaints GROUP BY staff_id ORDER BY COUNT(complaint_id) DESC LIMIT 5)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of last names of staff members who are handling complaints related to products, ordered by the price of those products. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\"\n}\n"}
{"sample_id": "train.5812", "db_id": "customer_complaints", "question": "Which state has the most customers?", "rationale": ["Identify the relevant table: The question asks about customers, so we will focus on the 'Customers' table.", "Determine the required information: We need to find out which state has the most customers, which means we need to count the number of customers in each state.", "Group the results: To count the customers by state, we will use the GROUP BY clause on the 'state' column.", "Count the customers: We will use the COUNT function to count the number of customer IDs for each state.", "Order the results: To find the state with the most customers, we will order the results in descending order based on the count of customers.", "Limit the results: Since we only want the state with the most customers, we will use the LIMIT clause to restrict the output to 1 result."], "gold_sql": "SELECT state FROM customers GROUP BY state ORDER BY count(*) LIMIT 1", "source_tables": ["customers"], "pred_sql": "SELECT state, COUNT(customer_id) AS customer_count\nFROM Customers\nGROUP BY state\nORDER BY customer_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of last names of staff members who are handling complaints related to products, ordered by the price of those products. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n    \"1\": \"This virtual table provides a list of distinct product names from the 'Products' table that have been associated with complaints. The query joins the 'Products' table with the 'Complaints' table based on the product identifier, and it groups the results by customer identifiers from the 'Customers' table. The results are ordered by the count of complaints for each customer, and a limit is applied to restrict the number of results returned based on a specified numeric value.\"\n}\n"}
{"sample_id": "train.5813", "db_id": "customer_complaints", "question": "Give the state that has the most customers.", "rationale": ["Identify the table that contains customer information, which is the 'Customers' table.", "To find the state with the most customers, we need to count the number of customers in each state.", "Use the COUNT function to count the 'customer_id' for each state.", "Group the results by 'state' to aggregate the counts for each state.", "Order the results in descending order based on the count of customers to get the state with the most customers at the top.", "Limit the results to 1 to get only the state with the highest count."], "gold_sql": "SELECT state FROM customers GROUP BY state ORDER BY count(*) LIMIT 1", "source_tables": ["customers"], "pred_sql": "SELECT state, COUNT(customer_id) AS customer_count\nFROM Customers\nGROUP BY state\nORDER BY customer_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of last names of staff members who are handling complaints related to products, ordered by the price of those products. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\"\n}\n"}
{"sample_id": "train.5865", "db_id": "tracking_share_transactions", "question": "What are the lot details of lots associated with transactions whose share count is bigger than 100 and whose type code is \"PUR\"?", "rationale": ["Identify the tables involved: Lots, Transactions, and Transactions_Lots.", "Determine the relationship between these tables: Lots are linked to Transactions through Transactions_Lots.", "Specify the required fields: We need the 'lot_details' from the Lots table.", "Set the conditions for the query: We want transactions with a share count greater than 100 and a transaction type code of 'PUR'.", "Construct the SQL query using JOINs to connect the tables and apply the WHERE conditions."], "gold_sql": "SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON  T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  >  100 AND T3.transaction_type_code  =  'PUR'", "source_tables": ["lots", "transactions_lots", "transactions"], "pred_sql": "SELECT Lots.lot_details \nFROM Lots \nJOIN Transactions_Lots ON Lots.lot_id = Transactions_Lots.lot_id \nJOIN Transactions ON Transactions_Lots.transaction_id = Transactions.transaction_id \nWHERE Transactions.share_count > 100 \nAND Transactions.transaction_type_code = 'PUR';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the details of lots associated with transactions where the number of shares involved in the transaction is less than a specified amount. The placeholders in the WHERE clause represent the numeric value for the share count.\"\n}\n"}
{"sample_id": "train.5866", "db_id": "tracking_share_transactions", "question": "Show the average transaction amount for different transaction types.", "rationale": ["Identify the tables involved: Transactions and Ref_Transaction_Types.", "We need to calculate the average transaction amount, so we will use the AVG() function on the amount_of_transaction column from the Transactions table.", "To categorize the average amounts by transaction type, we will join the Transactions table with the Ref_Transaction_Types table on the transaction_type_code.", "We will select the transaction_type_description from the Ref_Transaction_Types table and the average of the amount_of_transaction from the Transactions table.", "Finally, we will group the results by transaction_type_description to get the average for each type."], "gold_sql": "SELECT transaction_type_code ,  avg(amount_of_transaction) FROM TRANSACTIONS GROUP BY transaction_type_code", "source_tables": ["transactions"], "pred_sql": "SELECT rt.transaction_type_description, AVG(t.amount_of_transaction) AS average_transaction_amount\nFROM Transactions t\nJOIN Ref_Transaction_Types rt ON t.transaction_type_code = rt.transaction_type_code\nGROUP BY rt.transaction_type_description;", "hint": "\n"}
{"sample_id": "train.5873", "db_id": "tracking_share_transactions", "question": "Show the number of transactions with transaction type code \"SALE\" for different investors if it is larger than 0.", "rationale": ["We need to count the number of transactions for each investor where the transaction type is 'SALE'.", "To do this, we will join the Investors table with the Transactions table on the investor_id column.", "We will filter the results to only include transactions where the transaction_type_code is 'SALE'.", "Next, we will group the results by investor_id to get the count of transactions for each investor.", "Finally, we will use the HAVING clause to only include those investors who have more than 0 transactions."], "gold_sql": "SELECT investor_id ,  COUNT(*) FROM TRANSACTIONS WHERE transaction_type_code  =  'SALE' GROUP BY investor_id", "source_tables": ["transactions"], "pred_sql": "SELECT Investors.investor_id, COUNT(Transactions.transaction_id) AS transaction_count\nFROM Investors\nJOIN Transactions ON Investors.investor_id = Transactions.investor_id\nWHERE Transactions.transaction_type_code = 'SALE'\nGROUP BY Investors.investor_id\nHAVING transaction_count > 0;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the details of lots associated with transactions where the number of shares involved in the transaction is less than a specified amount. The placeholders in the WHERE clause represent the numeric value for the share count.\"\n}\n"}
{"sample_id": "train.5876", "db_id": "tracking_share_transactions", "question": "Show the transaction type code that occurs the most frequently.", "rationale": ["Identify the relevant table: The Transactions table contains the transaction_type_code that we need to analyze.", "Group the data: We need to group the results by transaction_type_code to count the occurrences of each type.", "Count occurrences: Use COUNT(*) to count how many times each transaction_type_code appears.", "Order the results: We will order the results in descending order based on the count to find the most frequent transaction type.", "Limit the results: Since we only want the transaction type code that occurs the most frequently, we will limit the results to 1."], "gold_sql": "SELECT transaction_type_code FROM TRANSACTIONS GROUP BY transaction_type_code ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["transactions"], "pred_sql": "SELECT transaction_type_code\nFROM Transactions\nGROUP BY transaction_type_code\nORDER BY COUNT(*) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5884", "db_id": "tracking_share_transactions", "question": "What are the details of the lots which are not used in any transactions?", "rationale": ["Identify the Lots table to retrieve details of lots.", "Determine that we need to find lots that are not associated with any transactions.", "Use a subquery to select lot_ids from the Transactions_Lots table, which links transactions to lots.", "Use the NOT IN clause to filter out those lot_ids from the Lots table, ensuring we only get lots that are not used in any transactions."], "gold_sql": "SELECT lot_details FROM Lots EXCEPT SELECT T1.lot_details FROM Lots AS T1 JOIN transactions_lots AS T2 ON T1.lot_id  =  T2.lot_id", "source_tables": ["lots", "transactions_lots"], "pred_sql": "SELECT * FROM Lots WHERE lot_id NOT IN (SELECT lot_id FROM Transactions_Lots);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the details of lots associated with transactions where the number of shares involved in the transaction is less than a specified amount. The placeholders in the WHERE clause represent the numeric value for the share count.\"\n}\n"}
{"sample_id": "train.5893", "db_id": "cre_Theme_park", "question": "Show details of all visitors.", "rationale": ["The task is to show details of all visitors, which means we need to select all columns from the Visitors table.", "The SQL query to retrieve all records from a table is done using 'SELECT * FROM table_name'.", "In this case, the table name is 'Visitors', so the full SQL query becomes 'SELECT * FROM Visitors;'."], "gold_sql": "SELECT Tourist_Details FROM VISITORS", "source_tables": ["visitors"], "pred_sql": "SELECT * FROM Visitors;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, excluding those that have been visited by another specified tourist. The placeholders in the WHERE clause represent the details of the tourists.\",\n    \"1\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n    \"2\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist. The query joins the 'Tourist_Attractions' table with the 'Visits' table to link attractions to visits, and then further joins with the 'Visitors' table to filter by the specific tourist's details. The placeholder in the WHERE clause represents the details of the tourist.\"\n}\n"}
{"sample_id": "train.5901", "db_id": "cre_Theme_park", "question": "What is the detail of the location UK Gallery?", "rationale": ["Identify the table that contains location details, which is the 'Locations' table.", "Determine the specific location we are interested in, which is 'UK Gallery'.", "Construct a SQL query to select all columns from the 'Locations' table where the 'Location_Name' matches 'UK Gallery'."], "gold_sql": "SELECT Other_Details FROM LOCATIONS WHERE Location_Name  =  'UK Gallery'", "source_tables": ["locations"], "pred_sql": "SELECT * FROM Locations WHERE Location_Name = 'UK Gallery';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n    \"1\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, excluding those that have been visited by another specified tourist. The placeholders in the WHERE clause represent the details of the tourists.\"\n}\n"}
{"sample_id": "train.5902", "db_id": "cre_Theme_park", "question": "Return the detail of the location named \"UK Gallery\".", "rationale": ["Identify the table that contains location details, which is the 'Locations' table.", "Determine the specific column that holds the name of the location, which is 'Location_Name'.", "Formulate a SQL query to select all columns from the 'Locations' table where the 'Location_Name' matches 'UK Gallery'."], "gold_sql": "SELECT Other_Details FROM LOCATIONS WHERE Location_Name  =  'UK Gallery'", "source_tables": ["locations"], "pred_sql": "SELECT * FROM Locations WHERE Location_Name = 'UK Gallery';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n    \"1\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, excluding those that have been visited by another specified tourist. The placeholders in the WHERE clause represent the details of the tourists.\"\n}\n"}
{"sample_id": "train.5914", "db_id": "cre_Theme_park", "question": "Give me the star rating descriptions of the hotels that cost more than 10000.", "rationale": ["Identify the relevant tables: Hotels and Ref_Hotel_Star_Ratings.", "Determine the columns needed: star_rating_description from Ref_Hotel_Star_Ratings and price_range from Hotels.", "Establish the relationship between the tables using the foreign key: Hotels.star_rating_code links to Ref_Hotel_Star_Ratings.star_rating_code.", "Filter the results based on the price range condition: only include hotels that cost more than 10000."], "gold_sql": "SELECT T2.star_rating_description FROM HOTELS AS T1 JOIN Ref_Hotel_Star_Ratings AS T2 ON T1.star_rating_code  =  T2.star_rating_code WHERE T1.price_range  >  10000", "source_tables": ["ref_hotel_star_ratings", "hotels"], "pred_sql": "SELECT Ref_Hotel_Star_Ratings.star_rating_description \nFROM Hotels \nJOIN Ref_Hotel_Star_Ratings ON Hotels.star_rating_code = Ref_Hotel_Star_Ratings.star_rating_code \nWHERE Hotels.price_range = 'More than 10000';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n    \"1\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, excluding those that have been visited by another specified tourist. The placeholders in the WHERE clause represent the details of the tourists.\"\n}\n"}
{"sample_id": "train.5915", "db_id": "cre_Theme_park", "question": "What are the details and opening hours of the museums?", "rationale": ["Identify the relevant table: Museums, which contains details about museums and their opening hours.", "Select the columns needed: Museum_ID, Museum_Details, and Opening_Hours.", "Construct the SQL query to retrieve these columns from the Museums table."], "gold_sql": "SELECT T1.Museum_Details ,  T2.Opening_Hours FROM MUSEUMS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Museum_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["tourist_attractions", "museums"], "pred_sql": "SELECT Museum_ID, Museum_Details, Opening_Hours FROM Museums", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n    \"1\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, excluding those that have been visited by another specified tourist. The placeholders in the WHERE clause represent the details of the tourists.\",\n    \"2\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist. The query joins the 'Tourist_Attractions' table with the 'Visits' table to link attractions to visits, and then further joins with the 'Visitors' table to filter by the specific tourist's details. The placeholder in the WHERE clause represents the details of the tourist.\"\n}\n"}
{"sample_id": "train.5922", "db_id": "cre_Theme_park", "question": "Which tourist attractions are related to royal family? Tell me their details and how we can get there.", "rationale": ["Identify the relevant tables: Tourist_Attractions and Royal_Family.", "Determine the relationship between the tables: Tourist_Attractions has a foreign key linking to Royal_Family.", "Select the required fields: Name, Description, and How_to_Get_There from Tourist_Attractions.", "Join the Tourist_Attractions table with the Royal_Family table on the appropriate foreign key.", "Construct the SQL query to retrieve the desired information."], "gold_sql": "SELECT T1.Royal_Family_Details ,  T2.How_to_Get_There FROM ROYAL_FAMILY AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Royal_Family_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["royal_family", "tourist_attractions"], "pred_sql": "SELECT Tourist_Attractions.Name, Tourist_Attractions.Description, Tourist_Attractions.How_to_Get_There \nFROM Tourist_Attractions \nJOIN Royal_Family ON Tourist_Attractions.Tourist_Attraction_ID = Royal_Family.Royal_Family_ID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n    \"1\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, excluding those that have been visited by another specified tourist. The placeholders in the WHERE clause represent the details of the tourists.\",\n    \"2\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist. The query joins the 'Tourist_Attractions' table with the 'Visits' table to link attractions to visits, and then further joins with the 'Visitors' table to filter by the specific tourist's details. The placeholder in the WHERE clause represents the details of the tourist.\"\n}\n"}
{"sample_id": "train.5924", "db_id": "cre_Theme_park", "question": "Find the details of the shops that can be reached by walk.", "rationale": ["Identify the relevant tables: Shops and Tourist_Attractions.", "Determine the relationship between Shops and Tourist_Attractions: Shops are linked to Tourist_Attractions through the Shop_ID and Tourist_Attraction_ID.", "To find shops that can be reached by walking, we need to filter the Tourist_Attractions based on the 'How_to_Get_There' column.", "Use a SQL JOIN to combine Shops and Tourist_Attractions on the appropriate keys.", "Apply a WHERE clause to filter for attractions that mention 'walk' in the 'How_to_Get_There' description."], "gold_sql": "SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  'walk'", "source_tables": ["shops", "tourist_attractions"], "pred_sql": "SELECT Shops.Shop_ID, Shops.Shop_Details \nFROM Shops \nJOIN Tourist_Attractions ON Shops.Shop_ID = Tourist_Attractions.Tourist_Attraction_ID \nWHERE Tourist_Attractions.How_to_Get_There LIKE '%walk%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n    \"1\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, excluding those that have been visited by another specified tourist. The placeholders in the WHERE clause represent the details of the tourists.\",\n    \"2\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist. The query joins the 'Tourist_Attractions' table with the 'Visits' table to link attractions to visits, and then further joins with the 'Visitors' table to filter by the specific tourist's details. The placeholder in the WHERE clause represents the details of the tourist.\"\n}\n"}
{"sample_id": "train.5927", "db_id": "cre_Theme_park", "question": "What are the details of the markets that can be accessed by walk or bus?", "rationale": ["Identify the relevant tables: Street_Markets and Tourist_Attractions.", "We need to retrieve details from the Street_Markets table, specifically Market_ID and Market_Details.", "To find markets accessible by walk or bus, we need to join the Street_Markets table with the Tourist_Attractions table using the Market_ID and Tourist_Attraction_ID.", "The condition for accessibility is specified in the How_to_Get_There column of the Tourist_Attractions table, where we check if it contains 'walk' or 'bus'.", "Construct the SQL query to select the required fields and apply the necessary join and where conditions."], "gold_sql": "SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  'walk' OR  T2.How_to_Get_There  =  'bus'", "source_tables": ["street_markets", "tourist_attractions"], "pred_sql": "SELECT Street_Markets.Market_ID, Street_Markets.Market_Details \nFROM Street_Markets \nJOIN Tourist_Attractions ON Street_Markets.Market_ID = Tourist_Attractions.Tourist_Attraction_ID \nWHERE Tourist_Attractions.How_to_Get_There LIKE '%walk%' OR Tourist_Attractions.How_to_Get_There LIKE '%bus%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n    \"1\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, excluding those that have been visited by another specified tourist. The placeholders in the WHERE clause represent the details of the tourists.\",\n    \"2\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist. The query joins the 'Tourist_Attractions' table with the 'Visits' table to link attractions to visits, and then further joins with the 'Visitors' table to filter by the specific tourist's details. The placeholder in the WHERE clause represents the details of the tourist.\"\n}\n"}
{"sample_id": "train.5928", "db_id": "cre_Theme_park", "question": "Find the details of all the markets that are accessible by walk or bus.", "rationale": ["Identify the relevant tables: Street_Markets and Tourist_Attractions.", "We need to find markets that are accessible by walk or bus, which implies checking the 'How_to_Get_There' column in the Tourist_Attractions table.", "Join the Street_Markets table with the Tourist_Attractions table on the Market_ID and Tourist_Attraction_ID respectively.", "Use a WHERE clause to filter the results based on the accessibility criteria (i.e., 'How_to_Get_There' contains 'walk' or 'bus').", "Select the necessary columns from the Street_Markets table to display the market details."], "gold_sql": "SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  'walk' OR  T2.How_to_Get_There  =  'bus'", "source_tables": ["street_markets", "tourist_attractions"], "pred_sql": "SELECT Street_Markets.Market_ID, Street_Markets.Market_Details \nFROM Street_Markets \nJOIN Tourist_Attractions ON Street_Markets.Market_ID = Tourist_Attractions.Tourist_Attraction_ID \nWHERE Tourist_Attractions.How_to_Get_There LIKE '%walk%' OR Tourist_Attractions.How_to_Get_There LIKE '%bus%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n    \"1\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, excluding those that have been visited by another specified tourist. The placeholders in the WHERE clause represent the details of the tourists.\",\n    \"2\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist. The query joins the 'Tourist_Attractions' table with the 'Visits' table to link attractions to visits, and then further joins with the 'Visitors' table to filter by the specific tourist's details. The placeholder in the WHERE clause represents the details of the tourist.\"\n}\n"}
{"sample_id": "train.5942", "db_id": "cre_Theme_park", "question": "What are the details of the three most expensive hotels?", "rationale": ["Identify the table that contains hotel details, which is the 'Hotels' table.", "To find the most expensive hotels, we need to sort the hotels by their price range in descending order.", "We will limit the results to the top three entries to get the three most expensive hotels."], "gold_sql": "SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT 3", "source_tables": ["hotels"], "pred_sql": "SELECT * FROM Hotels ORDER BY price_range DESC LIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n    \"1\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, excluding those that have been visited by another specified tourist. The placeholders in the WHERE clause represent the details of the tourists.\"\n}\n"}
{"sample_id": "train.5943", "db_id": "cre_Theme_park", "question": "Show the details and star ratings of the 3 least expensive hotels.", "rationale": ["Identify the relevant tables: Hotels and Ref_Hotel_Star_Ratings.", "We need to select hotel details and their star ratings, so we will select columns from both tables: hotel_id, star_rating_code, price_range, other_hotel_details from Hotels and star_rating_description from Ref_Hotel_Star_Ratings.", "Join the Hotels table with Ref_Hotel_Star_Ratings on the star_rating_code to get the star rating descriptions.", "Order the results by price_range in ascending order to get the least expensive hotels first.", "Limit the results to 3 to get only the 3 least expensive hotels."], "gold_sql": "SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT 3", "source_tables": ["hotels"], "pred_sql": "SELECT h.hotel_id, h.star_rating_code, h.price_range, h.other_hotel_details, r.star_rating_description \nFROM Hotels h \nJOIN Ref_Hotel_Star_Ratings r ON h.star_rating_code = r.star_rating_code \nORDER BY h.price_range ASC \nLIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n    \"1\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, excluding those that have been visited by another specified tourist. The placeholders in the WHERE clause represent the details of the tourists.\"\n}\n"}
{"sample_id": "train.5945", "db_id": "cre_Theme_park", "question": "Show the transportation method most people choose to get to tourist attractions.", "rationale": ["Identify the relevant tables: 'Tourist_Attractions' for attraction details and 'Visits' for visit records.", "Determine the required information: we need to find the transportation method (How_to_Get_There) and count how many times each method was used.", "Join the 'Tourist_Attractions' table with the 'Visits' table on the Tourist_Attraction_ID to link visits to their respective attractions.", "Group the results by the transportation method (How_to_Get_There) to count the number of visits for each method.", "Order the results by the count of visits in descending order to find the most popular transportation method.", "Limit the results to 1 to get only the top transportation method."], "gold_sql": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["tourist_attractions"], "pred_sql": "SELECT How_to_Get_There, COUNT(*) as Visit_Count\nFROM Tourist_Attractions\nJOIN Visits ON Tourist_Attractions.Tourist_Attraction_ID = Visits.Tourist_Attraction_ID\nGROUP BY How_to_Get_There\nORDER BY Visit_Count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n    \"1\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, excluding those that have been visited by another specified tourist. The placeholders in the WHERE clause represent the details of the tourists.\",\n    \"2\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist. The query joins the 'Tourist_Attractions' table with the 'Visits' table to link attractions to visits, and then further joins with the 'Visitors' table to filter by the specific tourist's details. The placeholder in the WHERE clause represents the details of the tourist.\"\n}\n"}
{"sample_id": "train.5946", "db_id": "cre_Theme_park", "question": "Which transportation method is used the most often to get to tourist attractions?", "rationale": ["Identify the relevant tables: Tourist_Attractions and Visits are needed to determine how tourists get to attractions.", "Join the Tourist_Attractions table with the Visits table on the Tourist_Attraction_ID to link visits to their respective attractions.", "Select the How_to_Get_There column from the Tourist_Attractions table to find out the transportation methods used.", "Count the number of visits for each transportation method using COUNT(*) and group the results by How_to_Get_There.", "Order the results in descending order based on the count of visits to find the most used transportation method.", "Limit the results to 1 to get the top transportation method."], "gold_sql": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["tourist_attractions"], "pred_sql": "SELECT How_to_Get_There, COUNT(*) as Visit_Count\nFROM Tourist_Attractions\nJOIN Visits ON Tourist_Attractions.Tourist_Attraction_ID = Visits.Tourist_Attraction_ID\nGROUP BY How_to_Get_There\nORDER BY Visit_Count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n    \"1\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, excluding those that have been visited by another specified tourist. The placeholders in the WHERE clause represent the details of the tourists.\",\n    \"2\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist. The query joins the 'Tourist_Attractions' table with the 'Visits' table to link attractions to visits, and then further joins with the 'Visitors' table to filter by the specific tourist's details. The placeholder in the WHERE clause represents the details of the tourist.\"\n}\n"}
{"sample_id": "train.5951", "db_id": "cre_Theme_park", "question": "Show different tourist attractions' names, ids, and the corresponding number of visits.", "rationale": ["We need to show the names and IDs of different tourist attractions along with the number of visits they received.", "To achieve this, we will select the 'Name' and 'Tourist_Attraction_ID' from the 'Tourist_Attractions' table.", "We will also count the number of visits for each attraction, which can be done by counting the 'Visit_ID' from the 'Visits' table.", "To link the 'Tourist_Attractions' with the 'Visits', we will use a LEFT JOIN on the 'Tourist_Attraction_ID'.", "Finally, we will group the results by 'Tourist_Attraction_ID' and 'Name' to get the count of visits for each attraction."], "gold_sql": "SELECT T1.Name ,  T2.Tourist_Attraction_ID ,   COUNT(*) FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID", "source_tables": ["visits", "tourist_attractions"], "pred_sql": "SELECT Tourist_Attractions.Name, Tourist_Attractions.Tourist_Attraction_ID, COUNT(Visits.Visit_ID) AS Number_of_Visits\nFROM Tourist_Attractions\nLEFT JOIN Visits ON Tourist_Attractions.Tourist_Attraction_ID = Visits.Tourist_Attraction_ID\nGROUP BY Tourist_Attractions.Tourist_Attraction_ID, Tourist_Attractions.Name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n    \"1\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, excluding those that have been visited by another specified tourist. The placeholders in the WHERE clause represent the details of the tourists.\",\n    \"2\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist. The query joins the 'Tourist_Attractions' table with the 'Visits' table to link attractions to visits, and then further joins with the 'Visitors' table to filter by the specific tourist's details. The placeholder in the WHERE clause represents the details of the tourist.\"\n}\n"}
{"sample_id": "train.5959", "db_id": "cre_Theme_park", "question": "What are the names of the tourist attractions that have parking or shopping as their feature details?", "rationale": ["Identify the relevant tables: Tourist_Attractions, Tourist_Attraction_Features, and Features.", "We need to find the names of tourist attractions that have specific features (parking or shopping).", "Join the Tourist_Attractions table with the Tourist_Attraction_Features table to link attractions to their features.", "Then, join the Features table to get the details of those features.", "Use a WHERE clause to filter the results to only include attractions that have 'parking' or 'shopping' as their feature details."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'park' UNION SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'shopping'", "source_tables": ["features", "tourist_attractions", "tourist_attraction_features"], "pred_sql": "SELECT Tourist_Attractions.Name \nFROM Tourist_Attractions \nJOIN Tourist_Attraction_Features ON Tourist_Attractions.Tourist_Attraction_ID = Tourist_Attraction_Features.Tourist_Attraction_ID \nJOIN Features ON Tourist_Attraction_Features.Feature_ID = Features.Feature_ID \nWHERE Features.Feature_Details IN ('parking', 'shopping');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n    \"1\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, excluding those that have been visited by another specified tourist. The placeholders in the WHERE clause represent the details of the tourists.\",\n    \"2\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist. The query joins the 'Tourist_Attractions' table with the 'Visits' table to link attractions to visits, and then further joins with the 'Visitors' table to filter by the specific tourist's details. The placeholder in the WHERE clause represents the details of the tourist.\"\n}\n"}
{"sample_id": "train.5960", "db_id": "cre_Theme_park", "question": "Find the tourist attractions that have parking or shopping as their feature details. What are the names of the attractions?", "rationale": ["Identify the relevant tables: Tourist_Attractions, Tourist_Attraction_Features, and Features.", "We need to find tourist attractions that have specific features (parking or shopping).", "Join the Tourist_Attractions table with the Tourist_Attraction_Features table to link attractions to their features.", "Then, join with the Features table to access the feature details.", "Use a WHERE clause to filter the results for features that are either 'parking' or 'shopping'.", "Select the Name of the tourist attractions that meet the criteria."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'park' UNION SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'shopping'", "source_tables": ["features", "tourist_attractions", "tourist_attraction_features"], "pred_sql": "SELECT Tourist_Attractions.Name \nFROM Tourist_Attractions \nJOIN Tourist_Attraction_Features ON Tourist_Attractions.Tourist_Attraction_ID = Tourist_Attraction_Features.Tourist_Attraction_ID \nJOIN Features ON Tourist_Attraction_Features.Feature_ID = Features.Feature_ID \nWHERE Features.Feature_Details IN ('parking', 'shopping');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n    \"1\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, excluding those that have been visited by another specified tourist. The placeholders in the WHERE clause represent the details of the tourists.\",\n    \"2\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist. The query joins the 'Tourist_Attractions' table with the 'Visits' table to link attractions to visits, and then further joins with the 'Visitors' table to filter by the specific tourist's details. The placeholder in the WHERE clause represents the details of the tourist.\"\n}\n"}
{"sample_id": "train.5964", "db_id": "cre_Theme_park", "question": "Which tourist attractions do the tourists Vincent and Marcelle visit? Tell me the names of the attractions.", "rationale": ["Identify the tables involved: Tourist_Attractions, Visits, and Visitors.", "We need to find the names of tourist attractions visited by both Vincent and Marcelle.", "Join the Tourist_Attractions table with the Visits table on Tourist_Attraction_ID to link attractions to visits.", "Join the resulting table with the Visitors table on Tourist_ID to filter by the specific tourists.", "Use a WHERE clause to filter the results for tourists named Vincent and Marcelle.", "Group the results by the name of the tourist attractions to aggregate the visits.", "Use HAVING to ensure that only attractions visited by both tourists are included, which means the count of distinct tourist names should equal 2."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  'Vincent' INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  'Marcelle'", "source_tables": ["visits", "visitors", "tourist_attractions"], "pred_sql": "SELECT ta.Name\nFROM Tourist_Attractions ta\nJOIN Visits v ON ta.Tourist_Attraction_ID = v.Tourist_Attraction_ID\nJOIN Visitors vi ON v.Tourist_ID = vi.Tourist_ID\nWHERE vi.Tourist_Details IN ('Vincent', 'Marcelle')\nGROUP BY ta.Name\nHAVING COUNT(DISTINCT vi.Tourist_Details) = 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n    \"1\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, excluding those that have been visited by another specified tourist. The placeholders in the WHERE clause represent the details of the tourists.\",\n    \"2\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist. The query joins the 'Tourist_Attractions' table with the 'Visits' table to link attractions to visits, and then further joins with the 'Visitors' table to filter by the specific tourist's details. The placeholder in the WHERE clause represents the details of the tourist.\"\n}\n"}
{"sample_id": "train.6059", "db_id": "customers_and_addresses", "question": "What is the average amount of items ordered in each order?", "rationale": ["To find the average amount of items ordered in each order, we need to focus on the 'Order_Items' table, which contains the 'order_quantity' for each product ordered in an order.", "We can use the AVG() function to calculate the average of the 'order_quantity' column.", "The SQL query will select the average quantity from the 'Order_Items' table."], "gold_sql": "SELECT avg(order_quantity) FROM order_items", "source_tables": ["order_items"], "pred_sql": "SELECT AVG(order_quantity) AS average_items_ordered\nFROM Order_Items;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of customers who have placed orders containing the maximum quantity of any product. It joins the 'Customers' table with the 'Customer_Orders' table to link customers to their orders, and then further joins with the 'Order_Items' table to access the order quantities. The placeholder in the WHERE clause is used to filter for the maximum order quantity across all orders.\"\n}\n"}
{"sample_id": "train.6066", "db_id": "customers_and_addresses", "question": "Find the payment method that is used most frequently.", "rationale": ["Identify the relevant table: The question asks about payment methods, which are stored in the Customers table.", "Count the occurrences of each payment method: Use COUNT() to tally how many times each payment method appears.", "Group the results by payment method: Use GROUP BY to aggregate the counts for each unique payment method.", "Order the results by frequency: Use ORDER BY to sort the counts in descending order, so the most frequent payment method appears first.", "Limit the results to one: Use LIMIT 1 to return only the most frequently used payment method."], "gold_sql": "SELECT payment_method FROM customers GROUP BY payment_method ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers"], "pred_sql": "SELECT payment_method, COUNT(payment_method) AS frequency\nFROM Customers\nGROUP BY payment_method\nORDER BY frequency DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6085", "db_id": "customers_and_addresses", "question": "Which city has the most customers living in?", "rationale": ["Identify the relevant tables: Customers, Customer_Addresses, and Addresses are needed to find the city associated with each customer.", "Join the Customers table with Customer_Addresses on customer_id to link customers to their addresses.", "Join the resulting table with Addresses on address_id to access the city information.", "Group the results by city to count the number of customers in each city.", "Order the results in descending order based on the customer count to find the city with the most customers.", "Limit the results to 1 to get only the city with the highest number of customers."], "gold_sql": "SELECT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id GROUP BY t3.city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "customers", "customer_addresses"], "pred_sql": "SELECT a.city, COUNT(c.customer_id) AS customer_count\nFROM Customers c\nJOIN Customer_Addresses ca ON c.customer_id = ca.customer_id\nJOIN Addresses a ON ca.address_id = a.address_id\nGROUP BY a.city\nORDER BY customer_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of cities where customers are located, derived from the 'Customers', 'Customer_Addresses', and 'Addresses' tables. The results are grouped by city and ordered by the number of customers in each city, with a limit on the number of cities returned based on a specified number.\"\n}\n"}
{"sample_id": "train.6098", "db_id": "customers_and_addresses", "question": "Find the contact channel code that was used by the customer named \"Tillman Ernser\".", "rationale": ["Identify the relevant tables: Customers and Customer_Contact_Channels.", "We need to find the contact channel code, which is in the Customer_Contact_Channels table.", "We need to link the Customers table with the Customer_Contact_Channels table using the customer_id foreign key.", "Filter the results to only include the customer named 'Tillman Ernser'.", "Construct the SQL query to select the channel_code from the joined tables with the specified condition."], "gold_sql": "SELECT DISTINCT channel_code FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  'Tillman Ernser'", "source_tables": ["customer_contact_channels", "customers"], "pred_sql": "SELECT Customer_Contact_Channels.channel_code \nFROM Customers \nJOIN Customer_Contact_Channels ON Customers.customer_id = Customer_Contact_Channels.customer_id \nWHERE Customers.customer_name = 'Tillman Ernser';", "hint": "\n"}
{"sample_id": "train.6099", "db_id": "customers_and_addresses", "question": "What is the \"active to date\" of the latest contact channel used by \"Tillman Ernser\"?", "rationale": ["Identify the relevant tables: Customer_Contact_Channels and Customers.", "We need to find the 'active to date' for the contact channel associated with the customer named 'Tillman Ernser'.", "Join the Customer_Contact_Channels table with the Customers table on the customer_id to link contact channels to the customer.", "Filter the results to only include the customer with the name 'Tillman Ernser'.", "To get the latest contact channel, we will order the results by 'active_from_date' in descending order.", "Limit the results to 1 to get only the latest contact channel's 'active to date'."], "gold_sql": "SELECT max(t2.active_to_date) FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  'Tillman Ernser'", "source_tables": ["customer_contact_channels", "customers"], "pred_sql": "SELECT Customer_Contact_Channels.active_to_date \nFROM Customer_Contact_Channels \nJOIN Customers ON Customer_Contact_Channels.customer_id = Customers.customer_id \nWHERE Customers.customer_name = 'Tillman Ernser' \nORDER BY Customer_Contact_Channels.active_from_date DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6100", "db_id": "customers_and_addresses", "question": "Return the the \"active to date\" of the latest contact channel used by the customer named \"Tillman Ernser\".", "rationale": ["Identify the customer ID for 'Tillman Ernser' from the Customers table.", "Use the identified customer ID to find the contact channels in the Customer_Contact_Channels table.", "Select the 'active_to_date' from the Customer_Contact_Channels table for the identified customer.", "Order the results by 'active_from_date' in descending order to get the latest contact channel.", "Limit the results to 1 to get only the latest 'active_to_date'."], "gold_sql": "SELECT max(t2.active_to_date) FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  'Tillman Ernser'", "source_tables": ["customer_contact_channels", "customers"], "pred_sql": "SELECT active_to_date \nFROM Customer_Contact_Channels \nWHERE customer_id = (\n    SELECT customer_id \n    FROM Customers \n    WHERE customer_name = 'Tillman Ernser'\n) \nORDER BY active_from_date DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6101", "db_id": "customers_and_addresses", "question": "What is the average time span of contact channels in the database?", "rationale": ["Identify the relevant table: The question pertains to contact channels, which are stored in the 'Customer_Contact_Channels' table.", "Determine the relevant columns: We need the 'active_from_date' and 'active_to_date' columns to calculate the time span of each contact channel.", "Calculate the time span: The time span can be calculated by subtracting 'active_from_date' from 'active_to_date'. In SQLite, we can use the 'julianday()' function to convert these dates into a format that allows for subtraction.", "Calculate the average: We can use the 'AVG()' function to find the average of these time spans.", "Filter out inactive channels: We should only consider channels that have an 'active_to_date' that is not null, as this indicates they were active for a period."], "gold_sql": "SELECT avg(active_to_date - active_from_date) FROM customer_contact_channels", "source_tables": ["customer_contact_channels"], "pred_sql": "SELECT AVG(julianday(active_to_date) - julianday(active_from_date)) AS average_time_span\nFROM Customer_Contact_Channels\nWHERE active_to_date IS NOT NULL;", "hint": "\n"}
{"sample_id": "train.6102", "db_id": "customers_and_addresses", "question": "Compute the average active time span of contact channels.", "rationale": ["Identify the relevant table: Customer_Contact_Channels contains the data about contact channels and their active periods.", "Determine the columns needed: active_from_date and active_to_date are necessary to calculate the active time span.", "Calculate the time span: Use the julianday function to convert the dates to Julian day numbers and subtract to find the difference in days.", "Use AVG function: To compute the average of the active time spans, apply the AVG function to the calculated differences.", "Filter out inactive channels: Ensure that only channels with a defined active_to_date are included in the average calculation."], "gold_sql": "SELECT avg(active_to_date - active_from_date) FROM customer_contact_channels", "source_tables": ["customer_contact_channels"], "pred_sql": "SELECT AVG(julianday(active_to_date) - julianday(active_from_date)) AS average_active_time_span\nFROM Customer_Contact_Channels\nWHERE active_to_date IS NOT NULL;", "hint": "\n"}
{"sample_id": "train.6104", "db_id": "customers_and_addresses", "question": "Return the channel code and contact number of the customer contact channel whose active duration was the longest.", "rationale": ["Identify the relevant table: Customer_Contact_Channels contains the channel code and contact number.", "Determine the duration of activity for each contact channel by calculating the difference between active_to_date and active_from_date.", "Use the ORDER BY clause to sort the results based on the calculated duration in descending order, so the longest active duration comes first.", "Limit the results to 1 to get only the channel with the longest active duration."], "gold_sql": "SELECT channel_code ,  contact_number FROM customer_contact_channels WHERE active_to_date - active_from_date  =  (SELECT active_to_date - active_from_date FROM customer_contact_channels ORDER BY (active_to_date - active_from_date) DESC LIMIT 1)", "source_tables": ["customer_contact_channels"], "pred_sql": "SELECT channel_code, contact_number\nFROM Customer_Contact_Channels\nORDER BY (julianday(active_to_date) - julianday(active_from_date)) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of customers who have placed orders containing the maximum quantity of any product. It joins the 'Customers' table with the 'Customer_Orders' table to link customers to their orders, and then further joins with the 'Order_Items' table to access the order quantities. The placeholder in the WHERE clause is used to filter for the maximum order quantity across all orders.\"\n}\n"}
{"sample_id": "train.6105", "db_id": "customers_and_addresses", "question": "Find the name and active date of the customer that use email as the contact channel.", "rationale": ["Identify the relevant tables: Customers and Customer_Contact_Channels.", "We need to retrieve the customer name and the active date of the contact channel.", "Join the Customers table with the Customer_Contact_Channels table on the customer_id field.", "Filter the results to include only those records where the channel_code is 'email'.", "Additionally, check that the contact channel is currently active by ensuring active_to_date is NULL."], "gold_sql": "SELECT t1.customer_name ,  t2.active_from_date FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t2.channel_code  =  'Email'", "source_tables": ["customer_contact_channels", "customers"], "pred_sql": "SELECT c.customer_name, cc.active_from_date \nFROM Customers c \nJOIN Customer_Contact_Channels cc ON c.customer_id = cc.customer_id \nWHERE cc.channel_code = 'email' AND cc.active_to_date IS NULL;", "hint": "\n"}
{"sample_id": "train.6127", "db_id": "customers_and_addresses", "question": "Who made the latest order?", "rationale": ["Identify the relevant tables: Customers and Customer_Orders.", "We need to find the customer who made the latest order, so we will join the Customers table with the Customer_Orders table on customer_id.", "To find the latest order, we will use a subquery to get the maximum order_date from the Customer_Orders table.", "Finally, we will select the customer_name from the Customers table where the order_date matches the maximum order_date."], "gold_sql": "SELECT t1.customer_name FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id ORDER BY t2.order_date DESC LIMIT 1", "source_tables": ["customer_orders", "customers"], "pred_sql": "SELECT c.customer_name \nFROM Customers c \nJOIN Customer_Orders co ON c.customer_id = co.customer_id \nWHERE co.order_date = (SELECT MAX(order_date) FROM Customer_Orders);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of customers who have placed orders containing the maximum quantity of any product. It joins the 'Customers' table with the 'Customer_Orders' table to link customers to their orders, and then further joins with the 'Order_Items' table to access the order quantities. The placeholder in the WHERE clause is used to filter for the maximum order quantity across all orders.\"\n}\n"}
{"sample_id": "train.6131", "db_id": "customers_and_addresses", "question": "Find the name and ID of the product whose total order quantity is the largest.", "rationale": ["Identify the tables involved: Products and Order_Items are relevant for product details and order quantities.", "Join the Products table with the Order_Items table on product_id to access the order quantities for each product.", "Group the results by product_id to aggregate the order quantities for each product.", "Use SUM(Order_Items.order_quantity) to calculate the total order quantity for each product.", "Order the results in descending order based on the total order quantity to find the product with the largest quantity.", "Limit the results to 1 to get only the product with the maximum order quantity."], "gold_sql": "SELECT t2.product_details ,  t2.product_id FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY sum(t1.order_quantity) LIMIT 1", "source_tables": ["products", "order_items"], "pred_sql": "SELECT Products.product_id, Products.product_details\nFROM Products\nJOIN Order_Items ON Products.product_id = Order_Items.product_id\nGROUP BY Products.product_id\nORDER BY SUM(Order_Items.order_quantity) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of customers who have placed orders containing the maximum quantity of any product. It joins the 'Customers' table with the 'Customer_Orders' table to link customers to their orders, and then further joins with the 'Order_Items' table to access the order quantities. The placeholder in the WHERE clause is used to filter for the maximum order quantity across all orders.\"\n}\n"}
{"sample_id": "train.6133", "db_id": "customers_and_addresses", "question": "Find all the addresses in East Julianaside, Texas or in Gleasonmouth, Arizona.", "rationale": ["Identify the relevant table: The Addresses table contains the information about addresses, including city and state.", "Determine the conditions: We need to find addresses in two specific cities (East Julianaside and Gleasonmouth) and their corresponding states (Texas and Arizona).", "Construct the SQL query: Use a SELECT statement to retrieve all columns from the Addresses table where the city and state match the specified criteria.", "Combine the conditions using OR to ensure that either of the two sets of conditions can be satisfied."], "gold_sql": "SELECT address_content FROM addresses WHERE city  =  'East Julianaside' AND state_province_county  =  'Texas' UNION SELECT address_content FROM addresses WHERE city  =  'Gleasonmouth' AND state_province_county  =  'Arizona'", "source_tables": ["addresses"], "pred_sql": "SELECT * FROM Addresses WHERE (city = 'East Julianaside' AND state_province_county = 'Texas') OR (city = 'Gleasonmouth' AND state_province_county = 'Arizona');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of cities where customers are located, derived from the 'Customers', 'Customer_Addresses', and 'Addresses' tables. The results are grouped by city and ordered by the number of customers in each city, with a limit on the number of cities returned based on a specified number.\"\n}\n"}
{"sample_id": "train.6134", "db_id": "customers_and_addresses", "question": "What are all the addresses in East Julianaside, Texas or in Gleasonmouth, Arizona.", "rationale": ["Identify the relevant tables: We need to query the Addresses table to get the addresses based on city and state.", "Determine the conditions: We are looking for addresses in two specific cities (East Julianaside and Gleasonmouth) and their respective states (Texas and Arizona).", "Construct the SQL query: Use a SELECT statement to retrieve all columns from the Addresses table where the city and state match the specified conditions.", "Combine the conditions using OR to ensure that either of the two sets of conditions can be satisfied."], "gold_sql": "SELECT address_content FROM addresses WHERE city  =  'East Julianaside' AND state_province_county  =  'Texas' UNION SELECT address_content FROM addresses WHERE city  =  'Gleasonmouth' AND state_province_county  =  'Arizona'", "source_tables": ["addresses"], "pred_sql": "SELECT * FROM Addresses WHERE (city = 'East Julianaside' AND state_province_county = 'Texas') OR (city = 'Gleasonmouth' AND state_province_county = 'Arizona');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of cities where customers are located, derived from the 'Customers', 'Customer_Addresses', and 'Addresses' tables. The results are grouped by city and ordered by the number of customers in each city, with a limit on the number of cities returned based on a specified number.\"\n}\n"}
{"sample_id": "train.6271", "db_id": "city_record", "question": "What is the match id of the competition called \"1994 FIFA World Cup qualification\"?", "rationale": ["Identify the table that contains the competition information, which is the 'match' table.", "Determine that we need to select the 'Match_ID' from the 'match' table.", "Use a subquery to find the 'Competition' that matches '1994 FIFA World Cup qualification'.", "Construct the SQL query to select the 'Match_ID' where the competition matches the specified name."], "gold_sql": "SELECT match_id FROM MATCH WHERE competition = '1994 FIFA World Cup qualification'", "source_tables": ["match"], "pred_sql": "SELECT Match_ID FROM match WHERE Competition = (SELECT Competition FROM match WHERE Competition = '1994 FIFA World Cup qualification');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the venue information for matches hosted in a specific city during a particular competition. The placeholders in the WHERE clause represent the city name and the competition identifier.\",\n    \"1\": \"This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n    \"2\": \"This virtual table identifies cities that have a higher average temperature in March compared to December, excluding those cities that have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\"\n}\n"}
{"sample_id": "train.6275", "db_id": "city_record", "question": "Find the city that hosted the most events.", "rationale": ["To find the city that hosted the most events, we need to look at the hosting_city table which contains the Host_City and Match_ID.", "We will count the number of matches (events) hosted by each city using COUNT(Match_ID).", "We will group the results by Host_City to aggregate the counts for each city.", "To get the city with the most events, we will order the results in descending order by the count of events (Event_Count).", "Finally, we will limit the results to 1 to get only the city that hosted the most events."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["hosting_city", "city"], "pred_sql": "SELECT Host_City, COUNT(Match_ID) AS Event_Count\nFROM hosting_city\nGROUP BY Host_City\nORDER BY Event_Count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the venue information for matches hosted in a specific city during a particular competition. The placeholders in the WHERE clause represent the city name and the competition identifier.\",\n    \"1\": \"This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n    \"2\": \"This virtual table identifies cities that have a higher average temperature in March compared to December, excluding those cities that have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\"\n}\n"}
{"sample_id": "train.6282", "db_id": "city_record", "question": "Which three cities have the largest regional population?", "rationale": ["Identify the table that contains the relevant data: the 'city' table has the 'Regional_Population' column.", "We need to select the 'City' name and 'Regional_Population' from the 'city' table.", "To find the cities with the largest populations, we will order the results by 'Regional_Population' in descending order.", "Finally, we limit the results to the top three cities using 'LIMIT 3'."], "gold_sql": "SELECT city FROM city ORDER BY regional_population DESC LIMIT 3", "source_tables": ["city"], "pred_sql": "SELECT City, Regional_Population FROM city ORDER BY Regional_Population DESC LIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n    \"1\": \"This virtual table identifies cities that have a higher average temperature in March compared to December, excluding those cities that have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\"\n}\n"}
{"sample_id": "train.6283", "db_id": "city_record", "question": "What are the three largest cities in terms of regional population?", "rationale": ["Identify the table that contains the relevant data for cities and their populations, which is the 'city' table.", "To find the largest cities by regional population, we need to select the 'City' and 'Regional_Population' columns from the 'city' table.", "We need to order the results by 'Regional_Population' in descending order to get the largest cities first.", "Finally, we limit the results to the top 3 cities using 'LIMIT 3'."], "gold_sql": "SELECT city FROM city ORDER BY regional_population DESC LIMIT 3", "source_tables": ["city"], "pred_sql": "SELECT City, Regional_Population FROM city ORDER BY Regional_Population DESC LIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n    \"1\": \"This virtual table identifies cities that have a higher average temperature in March compared to December, excluding those cities that have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n    \"2\": \"This virtual table provides the venue information for matches hosted in a specific city during a particular competition. The placeholders in the WHERE clause represent the city name and the competition identifier.\"\n}\n"}
{"sample_id": "train.6286", "db_id": "city_record", "question": "Which city has the highest temperature in February?", "rationale": ["Identify the relevant tables: We need data from the 'city' table for city names and the 'temperature' table for February temperatures.", "Join the 'city' table with the 'temperature' table on the 'City_ID' to get the temperature data associated with each city.", "Select the city name and the average temperature in February from the joined tables.", "Order the results by the February temperature in descending order to find the highest temperature.", "Limit the results to 1 to get only the city with the highest temperature in February."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id ORDER BY T2.Feb DESC LIMIT 1", "source_tables": ["city", "temperature"], "pred_sql": "SELECT City, Feb FROM city JOIN temperature ON city.City_ID = temperature.City_ID ORDER BY Feb DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies cities that have a higher average temperature in March compared to December, excluding those cities that have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n    \"1\": \"This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n    \"2\": \"This virtual table provides the venue information for matches hosted in a specific city during a particular competition. The placeholders in the WHERE clause represent the city name and the competition identifier.\"\n}\n"}
{"sample_id": "train.6288", "db_id": "city_record", "question": "Give me a list of cities whose temperature in March is lower than that in July or higher than that in Oct?", "rationale": ["Identify the relevant tables: 'city' for city names and 'temperature' for temperature data.", "Join the 'city' table with the 'temperature' table on 'City_ID' to access temperature data for each city.", "Use the WHERE clause to filter cities based on the conditions: temperature in March is lower than in July or higher than in October.", "Select the city name and the relevant temperature data for clarity in the results."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul OR T2.Mar  >  T2.Oct", "source_tables": ["city", "temperature"], "pred_sql": "SELECT c.City, t.Mar, t.Jul, t.Oct \nFROM city c \nJOIN temperature t ON c.City_ID = t.City_ID \nWHERE t.Mar < t.Jul OR t.Mar > t.Oct;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n    \"1\": \"This virtual table identifies cities that have a higher average temperature in March compared to December, excluding those cities that have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\"\n}\n"}
{"sample_id": "train.6290", "db_id": "city_record", "question": "Give me a list of cities whose temperature in Mar is lower than that in July and which have also served as host cities?", "rationale": ["Identify the relevant tables: city, temperature, and hosting_city.", "We need to find cities where the average temperature in March (t.Mar) is lower than in July (t.Jul).", "We also need to ensure that these cities have hosted a match, which is indicated by the hosting_city table.", "Join the city table with the temperature table on City_ID to access temperature data.", "Join the city table with the hosting_city table to filter for cities that have hosted matches.", "Use a WHERE clause to filter for cities where the temperature in March is less than in July."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul INTERSECT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "pred_sql": "SELECT c.City, c.Hanzi, c.Hanyu_Pinyin, c.Regional_Population, c.GDP \nFROM city c \nJOIN temperature t ON c.City_ID = t.City_ID \nJOIN hosting_city h ON c.City_ID = h.Host_City \nWHERE t.Mar < t.Jul;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n    \"1\": \"This virtual table identifies cities that have a higher average temperature in March compared to December, excluding those cities that have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n    \"2\": \"This virtual table provides the venue information for matches hosted in a specific city during a particular competition. The placeholders in the WHERE clause represent the city name and the competition identifier.\"\n}\n"}
{"sample_id": "train.6293", "db_id": "city_record", "question": "Which cities have lower temperature in March than in Dec and have never served as host cities?", "rationale": ["Identify the cities from the 'city' table that we want to query.", "Join the 'city' table with the 'temperature' table on 'City_ID' to access temperature data for each city.", "Filter the results to include only those cities where the average temperature in March (t.Mar) is lower than in December (t.Dec).", "Exclude cities that have hosted matches by using a subquery that selects 'Host_City' from the 'hosting_city' table.", "Select the city names that meet the above criteria."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "pred_sql": "SELECT c.City \nFROM city c \nJOIN temperature t ON c.City_ID = t.City_ID \nWHERE t.Mar < t.Dec \nAND c.City_ID NOT IN (SELECT Host_City FROM hosting_city)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n    \"1\": \"This virtual table identifies cities that have a higher average temperature in March compared to December, excluding those cities that have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n    \"2\": \"This virtual table provides the venue information for matches hosted in a specific city during a particular competition. The placeholders in the WHERE clause represent the city name and the competition identifier.\"\n}\n"}
{"sample_id": "train.6295", "db_id": "city_record", "question": "Which cities have higher temperature in Feb than in Jun or have once served as host cities?", "rationale": ["Identify the cities from the 'city' table.", "Join the 'temperature' table to get temperature data for each city.", "Use a LEFT JOIN with the 'hosting_city' table to find cities that have hosted matches.", "Set the condition to filter cities where the average temperature in February is higher than in June or where the city has hosted a match."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Feb  >  T2.Jun UNION SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "pred_sql": "SELECT DISTINCT c.City \nFROM city c \nJOIN temperature t ON c.City_ID = t.City_ID \nLEFT JOIN hosting_city h ON c.City_ID = h.Host_City \nWHERE (t.Feb > t.Jun) OR (h.Host_City IS NOT NULL);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n    \"1\": \"This virtual table identifies cities that have a higher average temperature in March compared to December, excluding those cities that have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n    \"2\": \"This virtual table provides the venue information for matches hosted in a specific city during a particular competition. The placeholders in the WHERE clause represent the city name and the competition identifier.\"\n}\n"}
{"sample_id": "train.6324", "db_id": "e_government", "question": "Find the last name of the first ever contact person of the organization with the highest UK Vat number.", "rationale": ["Identify the organization with the highest UK VAT number by using a subquery to select the maximum value from the Organizations table.", "Join the Organizations table with the Organization_Contact_Individuals table to link organizations with their contact individuals.", "Join the Individuals table to get the last names of the individuals who contacted the organization.", "Filter the results to only include the organization with the highest UK VAT number.", "Order the results by the start date of the contact period to find the first contact person.", "Limit the results to 1 to get only the first contact person's last name."], "gold_sql": "SELECT t3.individual_last_name FROM organizations AS t1 JOIN organization_contact_individuals AS t2 ON t1.organization_id  =  t2.organization_id JOIN individuals AS t3 ON t2.individual_id  =  t3.individual_id WHERE t1.uk_vat_number  =  (SELECT max(uk_vat_number) FROM organizations) ORDER BY t2.date_contact_to ASC LIMIT 1", "source_tables": ["organizations", "organization_contact_individuals", "individuals"], "pred_sql": "SELECT i.individual_last_name \nFROM Organizations o \nJOIN Organization_Contact_Individuals oci ON o.organization_id = oci.organization_id \nJOIN Individuals i ON oci.individual_id = i.individual_id \nWHERE o.uk_vat_number = (SELECT MAX(uk_vat_number) FROM Organizations) \nORDER BY oci.date_contact_from \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the last names of individuals who have contacted a specific organization. It retrieves data from the 'Organizations', 'Organization_Contact_Individuals', and 'Individuals' tables, filtering based on the organization's name. The results are ordered by the end date of the contact period, and a limit is applied to the number of results returned.\"\n}\n"}
{"sample_id": "train.6328", "db_id": "e_government", "question": "Find name of the services that has never been used.", "rationale": ["Identify the table that contains the service names, which is the Services table.", "We need to find services that have never been used, which means we need to check against the Party_Services table where service bookings are recorded.", "To find services that have never been used, we can select service names from the Services table where the service_id is not present in the Party_Services table.", "Construct the SQL query using a subquery to filter out the used services from the Services table."], "gold_sql": "SELECT service_name FROM services EXCEPT SELECT t1.service_name FROM services AS t1 JOIN party_services AS t2 ON t1.service_id  =  t2.service_id", "source_tables": ["services", "party_services"], "pred_sql": "SELECT service_name \nFROM Services \nWHERE service_id NOT IN (SELECT service_id FROM Party_Services);", "hint": "\n"}
{"sample_id": "train.6330", "db_id": "e_government", "question": "Find the name of all the cities and states.", "rationale": ["Identify the relevant table: The question asks for cities and states, which are found in the Addresses table.", "Select the appropriate columns: We need to select 'town_city' for cities and 'state_province_county' for states.", "Use DISTINCT to avoid duplicate entries: Since we want the names of all cities and states, using DISTINCT will ensure that we only get unique combinations of town/city and state.", "Construct the SQL query: Combine the selected columns and the table name into a SQL SELECT statement."], "gold_sql": "SELECT town_city FROM addresses UNION SELECT state_province_county FROM addresses", "source_tables": ["addresses"], "pred_sql": "SELECT DISTINCT town_city, state_province_county FROM Addresses;", "hint": "\n"}
{"sample_id": "train.6331", "db_id": "e_government", "question": "What are the names of all cities and states?", "rationale": ["Identify the relevant table: The question asks for city and state names, which are found in the Addresses table.", "Select the appropriate columns: We need to select 'town_city' and 'state_province_county' from the Addresses table.", "Use DISTINCT to avoid duplicate entries: Since cities and states may repeat, we use DISTINCT to get unique combinations.", "Construct the SQL query: Combine the selected columns and table into a SQL SELECT statement."], "gold_sql": "SELECT town_city FROM addresses UNION SELECT state_province_county FROM addresses", "source_tables": ["addresses"], "pred_sql": "SELECT DISTINCT town_city, state_province_county FROM Addresses;", "hint": "\n"}
{"sample_id": "train.6346", "db_id": "e_government", "question": "Find the last name of the individuals that have been contact individuals of an organization.", "rationale": ["Identify the relevant tables: Organization_Contact_Individuals, Individuals, and Organizations.", "We need to retrieve the last names of individuals, so we will select Individuals.individual_last_name.", "To link the individuals to the organizations they contacted, we will join Organization_Contact_Individuals with Individuals on individual_id.", "We also need to join Organizations to ensure we are considering the correct organization context, using organization_id.", "The results should be ordered by the end date of the contact period (date_contact_to) in descending order to get the most recent contacts first."], "gold_sql": "SELECT DISTINCT t1.individual_last_name FROM individuals AS t1 JOIN organization_contact_individuals AS t2 ON t1.individual_id  =  t2.individual_id", "source_tables": ["organization_contact_individuals", "individuals"], "pred_sql": "SELECT Individuals.individual_last_name \nFROM Organization_Contact_Individuals \nJOIN Individuals ON Organization_Contact_Individuals.individual_id = Individuals.individual_id \nJOIN Organizations ON Organization_Contact_Individuals.organization_id = Organizations.organization_id \nORDER BY Organization_Contact_Individuals.date_contact_to DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the last names of individuals who have contacted a specific organization. It retrieves data from the 'Organizations', 'Organization_Contact_Individuals', and 'Individuals' tables, filtering based on the organization's name. The results are ordered by the end date of the contact period, and a limit is applied to the number of results returned.\"\n}\n"}
{"sample_id": "train.6723", "db_id": "activity_1", "question": "Show the first name, last name, and phone number for all female faculty members.", "rationale": ["Identify the table needed: Faculty table contains the information about faculty members.", "Select the columns required: We need the first name (Fname), last name (Lname), and phone number (Phone) of faculty members.", "Apply the filter: We need to filter the results to include only female faculty members, which is done using the condition 'Sex = 'Female''."], "gold_sql": "SELECT Fname ,  Lname ,  phone FROM Faculty WHERE Sex  =  'F'", "source_tables": ["faculty"], "pred_sql": "SELECT Fname, Lname, Phone \nFROM Faculty \nWHERE Sex = 'Female';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of activities in which a specific faculty member participates. The placeholders in the WHERE clause represent the first and last names of the faculty member.\",\n    \"1\": \"This virtual table lists the last names of faculty members who hold a specific academic rank but do not participate in certain activities. The placeholders in the query represent the rank of the faculty and the names of the activities they do not participate in.\",\n    \"2\": \"This virtual table describes the last names of faculty members who participate in a specific activity. The query uses an INTERSECT operation to find faculty members who are involved in the same activity twice, ensuring that the results are distinct. The placeholders in the WHERE clause represent the name of the activity.\"\n}\n"}
{"sample_id": "train.6725", "db_id": "activity_1", "question": "Show ids for all the male faculty.", "rationale": ["Identify the table that contains faculty information, which is the Faculty table.", "Determine the column that stores the gender of faculty members, which is the 'Sex' column.", "Formulate a SQL query to select the 'FacID' from the Faculty table where the 'Sex' is 'Male'."], "gold_sql": "SELECT FacID FROM Faculty WHERE Sex  =  'M'", "source_tables": ["faculty"], "pred_sql": "SELECT FacID FROM Faculty WHERE Sex = 'Male';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the last names of faculty members who hold a specific academic rank but do not participate in certain activities. The placeholders in the query represent the rank of the faculty and the names of the activities they do not participate in.\",\n    \"1\": \"This virtual table describes the names of activities in which a specific faculty member participates. The placeholders in the WHERE clause represent the first and last names of the faculty member.\"\n}\n"}
{"sample_id": "train.6738", "db_id": "activity_1", "question": "Find the building that has the largest number of faculty members.", "rationale": ["We need to find the building with the largest number of faculty members.", "To do this, we will count the number of faculty members (FacID) grouped by their building.", "We will use the COUNT function to count the number of faculty members in each building.", "We will group the results by the 'Building' column to get the count per building.", "To find the building with the largest number of faculty members, we will order the results in descending order based on the count.", "Finally, we will limit the results to 1 to get only the building with the highest count."], "gold_sql": "SELECT building FROM Faculty GROUP BY building ORDER BY count(*) DESC LIMIT 1", "source_tables": ["faculty"], "pred_sql": "SELECT Building, COUNT(FacID) AS FacultyCount\nFROM Faculty\nGROUP BY Building\nORDER BY FacultyCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the last names of faculty members who hold a specific academic rank but do not participate in certain activities. The placeholders in the query represent the rank of the faculty and the names of the activities they do not participate in.\"\n}\n"}
{"sample_id": "train.6740", "db_id": "activity_1", "question": "In which buildings are there at least ten professors?", "rationale": ["Identify the relevant table: The Faculty table contains information about faculty members, including their building and unique identifiers.", "We need to find buildings with at least ten professors, so we will group the results by the Building column.", "Using the COUNT function, we can count the number of faculty members (FacID) in each building.", "The HAVING clause will filter the groups to include only those with a count of ten or more faculty members."], "gold_sql": "SELECT building FROM Faculty WHERE rank  =  'Professor' GROUP BY building HAVING count(*)  >=  10", "source_tables": ["faculty"], "pred_sql": "SELECT Building\nFROM Faculty\nGROUP BY Building\nHAVING COUNT(FacID) >= 10;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the last names of faculty members who hold a specific academic rank but do not participate in certain activities. The placeholders in the query represent the rank of the faculty and the names of the activities they do not participate in.\",\n    \"1\": \"This virtual table describes the names of activities in which a specific faculty member participates. The placeholders in the WHERE clause represent the first and last names of the faculty member.\"\n}\n"}
{"sample_id": "train.6747", "db_id": "activity_1", "question": "Show the number of male and female assistant professors.", "rationale": ["Identify the relevant table: Faculty, which contains information about faculty members including their rank and gender.", "Filter the records to include only those faculty members who are assistant professors by using the condition `WHERE Rank = 'Assistant Professor'`.", "Group the results by gender using `GROUP BY Sex` to get counts for each gender.", "Count the number of faculty members in each gender group using `COUNT(*)` and select the gender and count in the final output."], "gold_sql": "SELECT sex ,  count(*) FROM Faculty WHERE rank  =  'AsstProf' GROUP BY sex", "source_tables": ["faculty"], "pred_sql": "SELECT Sex, COUNT(*) as Count \nFROM Faculty \nWHERE Rank = 'Assistant Professor' \nGROUP BY Sex;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the last names of faculty members who hold a specific academic rank but do not participate in certain activities. The placeholders in the query represent the rank of the faculty and the names of the activities they do not participate in.\"\n}\n"}
{"sample_id": "train.6750", "db_id": "activity_1", "question": "Who is the advisor of Linda Smith? Give me the first name and last name.", "rationale": ["Identify the relevant table: The Student table contains information about students, including their names and advisors.", "Determine the specific student: We are looking for a student named Linda Smith, so we will filter the Student table by first name (Fname) and last name (LName).", "Select the advisor: The query needs to return the advisor of the identified student, which is stored in the Advisor column of the Student table."], "gold_sql": "SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T2.fname  =  'Linda' AND T2.lname  =  'Smith'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT Advisor FROM Student WHERE Fname = 'Linda' AND LName = 'Smith';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the last names of faculty members who hold a specific academic rank but do not participate in certain activities. The placeholders in the query represent the rank of the faculty and the names of the activities they do not participate in.\"\n}\n"}
{"sample_id": "train.6751", "db_id": "activity_1", "question": "Show the ids of students whose advisors are professors.", "rationale": ["Identify the relevant tables: We need to find students and their advisors, so we will use the Student and Faculty tables.", "Determine the relationship: The Student table has a column 'Advisor' that references 'FacID' in the Faculty table, indicating which faculty member is the advisor for each student.", "Construct the SQL query: We will select the distinct student IDs (StuID) from the Student table where there is a matching faculty member in the Faculty table based on the advisor relationship."], "gold_sql": "SELECT T2.StuID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.rank  =  'Professor'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT DISTINCT Student.StuID \nFROM Student \nJOIN Faculty ON Student.Advisor = Faculty.FacID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the last names of faculty members who hold a specific academic rank but do not participate in certain activities. The placeholders in the query represent the rank of the faculty and the names of the activities they do not participate in.\"\n}\n"}
{"sample_id": "train.6753", "db_id": "activity_1", "question": "Show first name and last name for all the students advised by Michael Goodrich.", "rationale": ["Identify the tables needed: We need the Student table to get student names and the Faculty table to find the advisor's name.", "Join the Student table with the Faculty table on the Advisor field, which links students to their advisors.", "Filter the results to only include students whose advisor's first name is 'Michael' and last name is 'Goodrich'.", "Select the first name and last name of the students from the joined tables."], "gold_sql": "SELECT T2.fname ,  T2.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.fname  =  'Michael' AND T1.lname  =  'Goodrich'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT S.Fname, S.LName \nFROM Student S \nJOIN Faculty F ON S.Advisor = F.FacID \nWHERE F.Fname = 'Michael' AND F.Lname = 'Goodrich';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the last names of faculty members who hold a specific academic rank but do not participate in certain activities. The placeholders in the query represent the rank of the faculty and the names of the activities they do not participate in.\",\n    \"1\": \"This virtual table describes the names of activities in which a specific faculty member participates. The placeholders in the WHERE clause represent the first and last names of the faculty member.\"\n}\n"}
{"sample_id": "train.6759", "db_id": "activity_1", "question": "What are the first and last name of the faculty who has the most students?", "rationale": ["Identify the tables involved: Faculty, Faculty_Participates_in, and Participates_in.", "We need to find the faculty members and the number of students they have, which requires joining the Faculty table with the Faculty_Participates_in table to get the activities they participate in, and then joining with the Participates_in table to count the students in those activities.", "Use GROUP BY to group the results by faculty member, allowing us to count the number of students associated with each faculty member.", "Use COUNT to count the number of students for each faculty member.", "Order the results in descending order based on the count of students to find the faculty member with the most students.", "Limit the results to 1 to get only the faculty member with the highest count."], "gold_sql": "SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID ORDER BY count(*) DESC LIMIT 1", "source_tables": ["faculty", "student"], "pred_sql": "SELECT Faculty.Fname, Faculty.Lname\nFROM Faculty\nJOIN Faculty_Participates_in ON Faculty.FacID = Faculty_Participates_in.FacID\nJOIN Participates_in ON Faculty_Participates_in.actid = Participates_in.actid\nGROUP BY Faculty.FacID\nORDER BY COUNT(Participates_in.stuid) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the last names of faculty members who hold a specific academic rank but do not participate in certain activities. The placeholders in the query represent the rank of the faculty and the names of the activities they do not participate in.\",\n    \"1\": \"This virtual table describes the last names of faculty members who participate in a specific activity. The query uses an INTERSECT operation to find faculty members who are involved in the same activity twice, ensuring that the results are distinct. The placeholders in the WHERE clause represent the name of the activity.\",\n    \"2\": \"This virtual table describes the last names of faculty members who participate in a specific activity. The query uses an INTERSECT operation to find faculty members who are involved in the same activity twice, ensuring that the results are distinct. The placeholders in the WHERE clause represent the name of the activity.\"\n}\n"}
{"sample_id": "train.6765", "db_id": "activity_1", "question": "What activities do we have?", "rationale": ["The question asks for a list of activities, which corresponds to the 'activity_name' column in the 'Activity' table.", "To retrieve the names of all activities, we need to select the 'activity_name' from the 'Activity' table without any conditions or filters."], "gold_sql": "SELECT activity_name FROM Activity", "source_tables": ["activity"], "pred_sql": "SELECT activity_name FROM Activity;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of activities in which a specific faculty member participates. The placeholders in the WHERE clause represent the first and last names of the faculty member.\",\n    \"1\": \"This virtual table lists the last names of faculty members who hold a specific academic rank but do not participate in certain activities. The placeholders in the query represent the rank of the faculty and the names of the activities they do not participate in.\",\n    \"2\": \"This virtual table describes the last names of faculty members who participate in a specific activity. The query uses an INTERSECT operation to find faculty members who are involved in the same activity twice, ensuring that the results are distinct. The placeholders in the WHERE clause represent the name of the activity.\"\n}\n"}
{"sample_id": "train.6766", "db_id": "activity_1", "question": "List all the activities we have.", "rationale": ["The user wants to list all activities, which means we need to retrieve data from the Activity table.", "The relevant column in the Activity table that contains the names of the activities is 'activity_name'.", "To get all activities, we will select the 'activity_name' column from the Activity table without any filtering conditions."], "gold_sql": "SELECT activity_name FROM Activity", "source_tables": ["activity"], "pred_sql": "SELECT activity_name FROM Activity;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of activities in which a specific faculty member participates. The placeholders in the WHERE clause represent the first and last names of the faculty member.\",\n    \"1\": \"This virtual table describes the last names of faculty members who participate in a specific activity. The query uses an INTERSECT operation to find faculty members who are involved in the same activity twice, ensuring that the results are distinct. The placeholders in the WHERE clause represent the name of the activity.\",\n    \"2\": \"This virtual table describes the last names of faculty members who participate in a specific activity. The query uses an INTERSECT operation to find faculty members who are involved in the same activity twice, ensuring that the results are distinct. The placeholders in the WHERE clause represent the name of the activity.\"\n}\n"}
{"sample_id": "train.6780", "db_id": "activity_1", "question": "What is the first and last name of the faculty members who participated in at least one activity? For each of them, also show the number of activities they participated in.", "rationale": ["We need to find the first and last names of faculty members who participated in at least one activity.", "To do this, we will join the Faculty table with the Faculty_Participates_in table on the FacID column.", "We will select the first name (Fname) and last name (Lname) of the faculty members.", "We also need to count the number of activities each faculty member participated in, which can be done using COUNT on the actid from the Faculty_Participates_in table.", "To ensure we only get faculty members who participated in at least one activity, we will group the results by Faculty.FacID and use HAVING to filter for counts greater than 0."], "gold_sql": "SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID", "source_tables": ["faculty", "faculty_participates_in"], "pred_sql": "SELECT Faculty.Fname, Faculty.Lname, COUNT(Faculty_Participates_in.actid) AS activity_count\nFROM Faculty\nJOIN Faculty_Participates_in ON Faculty.FacID = Faculty_Participates_in.FacID\nGROUP BY Faculty.FacID\nHAVING COUNT(Faculty_Participates_in.actid) > 0;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of activities in which a specific faculty member participates. The placeholders in the WHERE clause represent the first and last names of the faculty member.\",\n    \"1\": \"This virtual table lists the last names of faculty members who hold a specific academic rank but do not participate in certain activities. The placeholders in the query represent the rank of the faculty and the names of the activities they do not participate in.\",\n    \"2\": \"This virtual table describes the last names of faculty members who participate in a specific activity. The query uses an INTERSECT operation to find faculty members who are involved in the same activity twice, ensuring that the results are distinct. The placeholders in the WHERE clause represent the name of the activity.\"\n}\n"}
{"sample_id": "train.6781", "db_id": "activity_1", "question": "Show all the activity names and the number of faculty involved in each activity.", "rationale": ["We need to retrieve the names of activities and count the number of faculty members involved in each activity.", "To do this, we will select the 'activity_name' from the 'Activity' table.", "We will also count the number of faculty members associated with each activity, which can be done using the COUNT function on 'FacID' from the 'Faculty_Participates_in' table.", "To link the two tables, we will perform a LEFT JOIN on 'Activity' and 'Faculty_Participates_in' using the 'actid' column, which is common to both tables.", "Finally, we will group the results by 'activity_name' to get the count of faculty members for each activity."], "gold_sql": "SELECT T1.activity_name ,  count(*) FROM Activity AS T1 JOIN Faculty_participates_in AS T2 ON T1.actID  =  T2.actID GROUP BY T1.actID", "source_tables": ["activity", "faculty_participates_in"], "pred_sql": "SELECT Activity.activity_name, COUNT(Faculty_Participates_in.FacID) AS faculty_count\nFROM Activity\nLEFT JOIN Faculty_Participates_in ON Activity.actid = Faculty_Participates_in.actid\nGROUP BY Activity.activity_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of activities in which a specific faculty member participates. The placeholders in the WHERE clause represent the first and last names of the faculty member.\",\n    \"1\": \"This virtual table describes the last names of faculty members who participate in a specific activity. The query uses an INTERSECT operation to find faculty members who are involved in the same activity twice, ensuring that the results are distinct. The placeholders in the WHERE clause represent the name of the activity.\",\n    \"2\": \"This virtual table describes the last names of faculty members who participate in a specific activity. The query uses an INTERSECT operation to find faculty members who are involved in the same activity twice, ensuring that the results are distinct. The placeholders in the WHERE clause represent the name of the activity.\"\n}\n"}
{"sample_id": "train.6782", "db_id": "activity_1", "question": "How many faculty members participate in each activity? Return the activity names and the number of faculty members.", "rationale": ["Identify the tables needed: We need the Activity table to get activity names and the Faculty_Participates_in table to count faculty members participating in each activity.", "Join the Faculty_Participates_in table with the Activity table on the actid to link faculty participation with activity names.", "Use COUNT() to count the number of faculty members for each activity.", "Group the results by activity name to get the count of faculty members for each specific activity."], "gold_sql": "SELECT T1.activity_name ,  count(*) FROM Activity AS T1 JOIN Faculty_participates_in AS T2 ON T1.actID  =  T2.actID GROUP BY T1.actID", "source_tables": ["activity", "faculty_participates_in"], "pred_sql": "SELECT Activity.activity_name, COUNT(Faculty_FacID) AS faculty_count\nFROM Faculty_Participates_in\nJOIN Activity ON Faculty_Participates_in.actid = Activity.actid\nGROUP BY Activity.activity_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of activities in which a specific faculty member participates. The placeholders in the WHERE clause represent the first and last names of the faculty member.\",\n    \"1\": \"This virtual table describes the last names of faculty members who participate in a specific activity. The query uses an INTERSECT operation to find faculty members who are involved in the same activity twice, ensuring that the results are distinct. The placeholders in the WHERE clause represent the name of the activity.\",\n    \"2\": \"This virtual table describes the last names of faculty members who participate in a specific activity. The query uses an INTERSECT operation to find faculty members who are involved in the same activity twice, ensuring that the results are distinct. The placeholders in the WHERE clause represent the name of the activity.\"\n}\n"}
{"sample_id": "train.6789", "db_id": "activity_1", "question": "Show the ids for all the students who participate in an activity and are under 20.", "rationale": ["Identify the relevant tables: We need to find students who participate in activities, so we will use the 'Participates_in' and 'Student' tables.", "Select the student IDs: We want to show the IDs of the students, which is the 'stuid' column from the 'Participates_in' table.", "Join the tables: We need to join 'Participates_in' with 'Student' on the student ID to access the age of the students.", "Filter by age: We need to filter the results to include only those students who are under 20 years old.", "Use DISTINCT: Since a student may participate in multiple activities, we use DISTINCT to ensure each student ID is listed only once."], "gold_sql": "SELECT StuID FROM Participates_in INTERSECT SELECT StuID FROM Student WHERE age  <  20", "source_tables": ["student", "participates_in"], "pred_sql": "SELECT DISTINCT Participates_in.stuid \nFROM Participates_in \nJOIN Student ON Participates_in.stuid = Student.StuID \nWHERE Student.Age < 20;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of activities in which a specific faculty member participates. The placeholders in the WHERE clause represent the first and last names of the faculty member.\"\n}\n"}
{"sample_id": "train.6795", "db_id": "activity_1", "question": "Find the first names of the faculty members who are playing Canoeing or Kayaking.", "rationale": ["Identify the tables involved: Faculty, Faculty_Participates_in, and Activity.", "We need to find faculty members, so we will select from the Faculty table.", "To find out which activities the faculty members participate in, we will join the Faculty table with the Faculty_Participates_in table on the FacID.", "Next, we need to join the Faculty_Participates_in table with the Activity table on the actid to get the activity names.", "We are specifically looking for faculty members who participate in either 'Canoeing' or 'Kayaking', so we will use a WHERE clause with the IN operator to filter the activities."], "gold_sql": "SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT Faculty.Fname \nFROM Faculty \nJOIN Faculty_Participates_in ON Faculty.FacID = Faculty_Participates_in.FacID \nJOIN Activity ON Faculty_Participates_in.actid = Activity.actid \nWHERE Activity.activity_name IN ('Canoeing', 'Kayaking');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of activities in which a specific faculty member participates. The placeholders in the WHERE clause represent the first and last names of the faculty member.\",\n    \"1\": \"This virtual table lists the last names of faculty members who hold a specific academic rank but do not participate in certain activities. The placeholders in the query represent the rank of the faculty and the names of the activities they do not participate in.\",\n    \"2\": \"This virtual table describes the last names of faculty members who participate in a specific activity. The query uses an INTERSECT operation to find faculty members who are involved in the same activity twice, ensuring that the results are distinct. The placeholders in the WHERE clause represent the name of the activity.\"\n}\n"}
{"sample_id": "train.6796", "db_id": "activity_1", "question": "Which faculty members are playing either Canoeing or Kayaking? Tell me their first names.", "rationale": ["Identify the tables involved: Faculty, Faculty_Participates_in, and Activity.", "We need to retrieve the first names of faculty members, so we will select Faculty.Fname.", "To find faculty members participating in Canoeing or Kayaking, we need to join the Faculty table with the Faculty_Participates_in table on FacID.", "Next, we join the Activity table to get the activity names associated with the activities in which faculty members participate.", "We will filter the results using a WHERE clause to include only those activities that are either 'Canoeing' or 'Kayaking'."], "gold_sql": "SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT Faculty.Fname \nFROM Faculty \nJOIN Faculty_Participates_in ON Faculty.FacID = Faculty_Participates_in.FacID \nJOIN Activity ON Faculty_Participates_in.actid = Activity.actid \nWHERE Activity.activity_name IN ('Canoeing', 'Kayaking');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of activities in which a specific faculty member participates. The placeholders in the WHERE clause represent the first and last names of the faculty member.\",\n    \"1\": \"This virtual table lists the last names of faculty members who hold a specific academic rank but do not participate in certain activities. The placeholders in the query represent the rank of the faculty and the names of the activities they do not participate in.\",\n    \"2\": \"This virtual table describes the last names of faculty members who participate in a specific activity. The query uses an INTERSECT operation to find faculty members who are involved in the same activity twice, ensuring that the results are distinct. The placeholders in the WHERE clause represent the name of the activity.\"\n}\n"}
{"sample_id": "train.6798", "db_id": "activity_1", "question": "What are the first names of the professors who do not play Canoeing or Kayaking as activities?", "rationale": ["Identify the table that contains faculty information, which is the Faculty table.", "We need to select the first names of faculty members, so we will select the 'Fname' column from the Faculty table.", "We need to filter out faculty members who participate in either 'Canoeing' or 'Kayaking'.", "To do this, we will use a subquery that selects the FacID of faculty members who participate in these activities from the Faculty_Participates_in table joined with the Activity table.", "The subquery will check for activities with names 'Canoeing' and 'Kayaking'.", "Finally, we will use the NOT IN clause to exclude those faculty members from our main query."], "gold_sql": "SELECT lname FROM faculty WHERE rank  =  'Professor' EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT F.Fname \nFROM Faculty F \nWHERE F.FacID NOT IN (\n    SELECT FP.FacID \n    FROM Faculty_Participates_in FP \n    JOIN Activity A ON FP.actid = A.actid \n    WHERE A.activity_name IN ('Canoeing', 'Kayaking')\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the last names of faculty members who hold a specific academic rank but do not participate in certain activities. The placeholders in the query represent the rank of the faculty and the names of the activities they do not participate in.\",\n    \"1\": \"This virtual table describes the names of activities in which a specific faculty member participates. The placeholders in the WHERE clause represent the first and last names of the faculty member.\",\n    \"2\": \"This virtual table describes the last names of faculty members who participate in a specific activity. The query uses an INTERSECT operation to find faculty members who are involved in the same activity twice, ensuring that the results are distinct. The placeholders in the WHERE clause represent the name of the activity.\"\n}\n"}
{"sample_id": "train.6801", "db_id": "activity_1", "question": "Find the ids of the students who participate in Canoeing and Kayaking.", "rationale": ["Identify the tables involved: We need to find student IDs from the Participates_in table and the activity names from the Activity table.", "Determine the relationship: The Participates_in table has a foreign key relationship with the Activity table through the actid column.", "Filter the activities: We need to filter the activities to only include 'Canoeing' and 'Kayaking'.", "Construct the SQL query: Use a SELECT statement to retrieve the student IDs from the Participates_in table, joining it with the Activity table to filter by activity names."], "gold_sql": "SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  'Canoeing' INTERSECT SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  'Kayaking'", "source_tables": ["activity", "participates_in"], "pred_sql": "SELECT p.stuid \nFROM Participates_in p \nJOIN Activity a ON p.actid = a.actid \nWHERE a.activity_name IN ('Canoeing', 'Kayaking');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of activities in which a specific faculty member participates. The placeholders in the WHERE clause represent the first and last names of the faculty member.\",\n    \"1\": \"This virtual table describes the last names of faculty members who participate in a specific activity. The query uses an INTERSECT operation to find faculty members who are involved in the same activity twice, ensuring that the results are distinct. The placeholders in the WHERE clause represent the name of the activity.\",\n    \"2\": \"This virtual table describes the last names of faculty members who participate in a specific activity. The query uses an INTERSECT operation to find faculty members who are involved in the same activity twice, ensuring that the results are distinct. The placeholders in the WHERE clause represent the name of the activity.\"\n}\n"}
{"sample_id": "dev.95", "db_id": "car_1", "question": "Which model of the car has the minimum horsepower?", "rationale": ["Identify the relevant tables: model_list, car_names, and cars_data are needed to find car models and their horsepower.", "Join the model_list table with the car_names table to get the make of each model.", "Join the resulting table with the cars_data table to access the horsepower of each model.", "Use the MIN() function to find the minimum horsepower among the models.", "Group the results by Model to ensure we get the minimum horsepower for each model.", "Order the results by the minimum horsepower in ascending order to get the model with the least horsepower at the top.", "Limit the results to 1 to get only the model with the minimum horsepower."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT Model, MIN(Horsepower) AS MinHorsepower\nFROM model_list\nJOIN car_names ON model_list.Model = car_names.Model\nJOIN cars_data ON car_names.MakeId = cars_data.Id\nGROUP BY Model\nORDER BY MinHorsepower ASC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n    \"1\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n    \"2\": \"This virtual table provides the count of car models from the 'model_list' table that are associated with car makers from a specific country. The placeholders in the WHERE clause represent the name of the country being queried.\"\n}\n"}
{"sample_id": "dev.97", "db_id": "car_1", "question": "Find the model of the car whose weight is below the average weight.", "rationale": ["Identify the relevant tables: We need to find car models and their weights, so we will use the 'car_names' and 'cars_data' tables.", "Join the tables: We will join 'cars_data' with 'car_names' on the 'MakeId' to get the model names associated with their weights.", "Calculate the average weight: We will use a subquery to calculate the average weight of all cars in the 'cars_data' table.", "Filter the results: We will filter the results to include only those car models whose weight is below the average weight calculated in the subquery."], "gold_sql": "SELECT T1.model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Weight  <  (SELECT avg(Weight) FROM CARS_DATA)", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT DISTINCT car_names.Model \nFROM cars_data \nJOIN car_names ON cars_data.Id = car_names.MakeId \nWHERE cars_data.Weight < (SELECT AVG(Weight) FROM cars_data);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n    \"1\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n    \"2\": \"This virtual table provides the count of car models from the 'model_list' table that are associated with car makers from a specific country. The placeholders in the WHERE clause represent the name of the country being queried.\"\n}\n"}
{"sample_id": "dev.111", "db_id": "car_1", "question": "What is the accelerate of the car make amc hornet sportabout (sw)?", "rationale": ["Identify the relevant tables: We need to find the accelerate of a specific car make, which involves the 'car_names', 'model_list', 'car_makers', 'countries', and 'continents' tables.", "Determine the relationships: 'car_names' is linked to 'model_list' through the Model column, 'model_list' is linked to 'car_makers' through the Maker column, 'car_makers' is linked to 'countries' through the Country column, and 'countries' is linked to 'continents' through the Continent column.", "Select the required column: We need to retrieve the 'Accelerate' column from the 'cars_data' table, which is linked to 'car_names' through the MakeId.", "Filter the results: We need to filter the results to only include the car make 'amc hornet sportabout (sw)'.", "Construct the SQL query: Combine all the information into a SQL SELECT statement that joins the necessary tables and applies the filter."], "gold_sql": "SELECT T1.Accelerate FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Make  =  'amc hornet sportabout (sw)';", "source_tables": ["cars_data", "car_names"], "pred_sql": "SELECT cars_data.Accelerate \nFROM car_names \nJOIN model_list ON car_names.Model = model_list.Model \nJOIN car_makers ON model_list.Maker = car_makers.Id \nJOIN countries ON car_makers.Country = countries.CountryId \nJOIN continents ON countries.Continent = continents.ContId \nWHERE car_names.Make = 'amc hornet sportabout (sw)';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of car makers associated with each continent by joining the 'continents', 'countries', and 'car_makers' tables. The placeholder in the SELECT statement represents the continent's name, and the count function aggregates the number of car makers per continent.\",\n    \"1\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n    \"2\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\"\n}\n"}
{"sample_id": "dev.112", "db_id": "car_1", "question": "How much does the car accelerate that makes amc hornet sportabout (sw)?", "rationale": ["Identify the relevant tables: We need to find the acceleration data for a specific car model, which involves the 'model_list', 'car_names', and 'cars_data' tables.", "Determine the joins needed: The 'model_list' table needs to be joined with the 'car_names' table to get the make of the car, and then the 'car_names' table needs to be joined with the 'cars_data' table to access the acceleration data.", "Specify the conditions: We need to filter the results to find the specific model 'hornet sportabout' from the maker 'amc'.", "Construct the SQL query: Using the identified tables, joins, and conditions, we can construct the SQL query to retrieve the acceleration data."], "gold_sql": "SELECT T1.Accelerate FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Make  =  'amc hornet sportabout (sw)';", "source_tables": ["cars_data", "car_names"], "pred_sql": "SELECT cars_data.Accelerate \nFROM model_list \nJOIN car_names ON model_list.Model = car_names.Model \nJOIN cars_data ON car_names.MakeId = cars_data.Id \nWHERE car_names.Model = 'hornet sportabout' AND car_names.Make = 'amc';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n    \"1\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n    \"2\": \"This virtual table provides the count of car models from the 'model_list' table that are associated with car makers from a specific country. The placeholders in the WHERE clause represent the name of the country being queried.\"\n}\n"}
{"sample_id": "dev.113", "db_id": "car_1", "question": "How many car makers are there in france?", "rationale": ["Identify the relevant tables: 'car_makers' for car makers and 'countries' for country information.", "We need to count the number of car makers based in France, so we will filter the 'car_makers' table by the country.", "To find the country ID for France, we will use a subquery on the 'countries' table to get the 'CountryId' where 'CountryName' is 'France'.", "The final SQL query will count the number of entries in the 'car_makers' table that match the country ID for France."], "gold_sql": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  'france';", "source_tables": ["car_makers", "countries"], "pred_sql": "SELECT COUNT(*) AS NumberOfCarMakers FROM car_makers WHERE Country = (SELECT CountryId FROM countries WHERE CountryName = 'France');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of car makers associated with each continent by joining the 'continents', 'countries', and 'car_makers' tables. The placeholder in the SELECT statement represents the continent's name, and the count function aggregates the number of car makers per continent.\",\n    \"1\": \"This virtual table provides the count of car models from the 'model_list' table that are associated with car makers from a specific country. The placeholders in the WHERE clause represent the name of the country being queried.\",\n    \"2\": \"This virtual table provides the count of car models from the 'model_list' table that are associated with car makers from a specific country. The placeholders in the WHERE clause represent the name of the country being queried.\"\n}\n"}
{"sample_id": "dev.121", "db_id": "car_1", "question": "What are all the makers and models?", "rationale": ["The question asks for all the makers and models of cars.", "To get the makers and models, we need to join the 'model_list' table with the 'car_names' table to get the model names associated with each maker.", "We also need to join the 'car_makers' table to get the maker names associated with each model.", "Using SELECT DISTINCT ensures that we get unique combinations of makers and models without duplicates."], "gold_sql": "SELECT Maker ,  Model FROM MODEL_LIST;", "source_tables": ["model_list"], "pred_sql": "SELECT DISTINCT car_makers.Maker, model_list.Model \nFROM model_list \nJOIN car_names ON model_list.Model = car_names.Model \nJOIN car_makers ON model_list.Maker = car_makers.Id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n    \"1\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n    \"2\": \"This virtual table summarizes the number of car makers associated with each continent by joining the 'continents', 'countries', and 'car_makers' tables. The placeholder in the SELECT statement represents the continent's name, and the count function aggregates the number of car makers per continent.\"\n}\n"}
{"sample_id": "dev.129", "db_id": "car_1", "question": "Which countries in europe have at least 3 car manufacturers?", "rationale": ["Identify the relevant tables: countries, car_makers, and continents.", "Join the countries table with the car_makers table to associate countries with their car manufacturers.", "Join the continents table to filter for countries in Europe.", "Group the results by country name to count the number of car manufacturers per country.", "Use the HAVING clause to filter countries that have at least 3 car manufacturers."], "gold_sql": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  'europe' GROUP BY T1.CountryName HAVING count(*)  >=  3;", "source_tables": ["continents", "car_makers", "countries"], "pred_sql": "SELECT c.CountryName\nFROM countries c\nJOIN car_makers cm ON c.CountryId = cm.Country\nJOIN continents con ON c.Continent = con.ContId\nWHERE con.Continent = 'Europe'\nGROUP BY c.CountryName\nHAVING COUNT(cm.Id) >= 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of car makers associated with each continent by joining the 'continents', 'countries', and 'car_makers' tables. The placeholder in the SELECT statement represents the continent's name, and the count function aggregates the number of car makers per continent.\",\n    \"1\": \"This virtual table provides the count of car models from the 'model_list' table that are associated with car makers from a specific country. The placeholders in the WHERE clause represent the name of the country being queried.\",\n    \"2\": \"This virtual table provides the count of car models from the 'model_list' table that are associated with car makers from a specific country. The placeholders in the WHERE clause represent the name of the country being queried.\"\n}\n"}
{"sample_id": "dev.130", "db_id": "car_1", "question": "What are the names of all European countries with at least 3 manufacturers?", "rationale": ["Identify the relevant tables: countries, car_makers, and model_list.", "We need to find countries in Europe, so we will filter the countries table based on the continent.", "Join the countries table with the car_makers table to link countries to their respective manufacturers.", "Next, join the car_makers table with the model_list table to count the number of car models associated with each manufacturer.", "Group the results by country name to aggregate the count of manufacturers per country.", "Use the HAVING clause to filter countries that have at least 3 manufacturers."], "gold_sql": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  'europe' GROUP BY T1.CountryName HAVING count(*)  >=  3;", "source_tables": ["continents", "car_makers", "countries"], "pred_sql": "SELECT c.CountryName \nFROM countries c \nJOIN car_makers cm ON c.CountryId = cm.Country \nJOIN model_list ml ON cm.Id = ml.Maker \nWHERE c.Continent = (SELECT ContId FROM continents WHERE Continent = 'Europe') \nGROUP BY c.CountryName \nHAVING COUNT(DISTINCT ml.ModelId) >= 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of car makers associated with each continent by joining the 'continents', 'countries', and 'car_makers' tables. The placeholder in the SELECT statement represents the continent's name, and the count function aggregates the number of car makers per continent.\",\n    \"1\": \"This virtual table provides the count of car models from the 'model_list' table that are associated with car makers from a specific country. The placeholders in the WHERE clause represent the name of the country being queried.\",\n    \"2\": \"This virtual table provides the count of car models from the 'model_list' table that are associated with car makers from a specific country. The placeholders in the WHERE clause represent the name of the country being queried.\"\n}\n"}
{"sample_id": "dev.131", "db_id": "car_1", "question": "What is the maximum horsepower and the make of the car models with 3 cylinders?", "rationale": ["Identify the required data: maximum horsepower and the make of car models with 3 cylinders.", "The relevant tables are 'cars_data' for horsepower and cylinders, 'car_names' for the make of the car, and 'model_list' to link the models with their respective makes.", "Use a JOIN to connect 'cars_data' with 'car_names' on the MakeId, and then join 'model_list' to ensure we are looking at the correct models.", "Filter the results using a WHERE clause to only include cars with 3 cylinders.", "Use the MAX() function to get the maximum horsepower from the filtered results."], "gold_sql": "SELECT T2.horsepower ,  T1.Make FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.cylinders  =  3 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT MAX(cars_data.Horsepower) AS MaxHorsepower, car_names.Make \nFROM cars_data \nJOIN car_names ON cars_data.Id = car_names.MakeId \nJOIN model_list ON car_names.Model = model_list.Model \nWHERE cars_data.Cylinders = 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n    \"1\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n    \"2\": \"This virtual table provides the count of car models from the 'model_list' table that are associated with car makers from a specific country. The placeholders in the WHERE clause represent the name of the country being queried.\"\n}\n"}
{"sample_id": "dev.141", "db_id": "car_1", "question": "Which model has the most version(make) of cars?", "rationale": ["Identify the relevant tables: model_list, car_names, and cars_data are needed to find car models and their makes.", "Join the model_list table with the car_names table to associate each model with its respective make.", "Join the resulting table with the cars_data table to ensure we are considering all versions of each model.", "Group the results by Model to count the distinct makes associated with each model.", "Use COUNT(DISTINCT Make) to count the number of different makes for each model.", "Order the results by the count of makes in descending order to find the model with the most versions.", "Limit the results to 1 to get only the top model with the most versions."], "gold_sql": "SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["car_names"], "pred_sql": "SELECT Model, COUNT(DISTINCT Make) AS VersionCount\nFROM model_list\nJOIN car_names ON model_list.Model = car_names.Model\nJOIN cars_data ON car_names.MakeId = cars_data.Id\nGROUP BY Model\nORDER BY VersionCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n    \"1\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n    \"2\": \"This virtual table summarizes the number of car makers associated with each continent by joining the 'continents', 'countries', and 'car_makers' tables. The placeholder in the SELECT statement represents the continent's name, and the count function aggregates the number of car makers per continent.\"\n}\n"}
{"sample_id": "dev.142", "db_id": "car_1", "question": "What model has the most different versions?", "rationale": ["Identify the table that contains car models, which is 'model_list'.", "Join 'model_list' with 'car_names' to get the names of the car models.", "Join the result with 'cars_data' to access the different versions of each model.", "Group the results by the car model to count the number of versions for each model.", "Order the results by the count of versions in descending order to find the model with the most versions.", "Limit the results to 1 to get only the model with the highest count."], "gold_sql": "SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["car_names"], "pred_sql": "SELECT Model, COUNT(*) as VersionCount\nFROM model_list\nJOIN car_names ON model_list.Model = car_names.Model\nJOIN cars_data ON car_names.MakeId = cars_data.Id\nGROUP BY Model\nORDER BY VersionCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n    \"1\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n    \"2\": \"This virtual table provides the count of car models from the 'model_list' table that are associated with car makers from a specific country. The placeholders in the WHERE clause represent the name of the country being queried.\"\n}\n"}
{"sample_id": "dev.150", "db_id": "car_1", "question": "What are the names and ids of all makers with more than 3 models?", "rationale": ["Identify the tables involved: We need to get information from the 'car_makers' and 'model_list' tables.", "Determine the relationship: The 'model_list' table has a foreign key 'Maker' that references the 'Id' in the 'car_makers' table.", "Select the required fields: We need the 'Id' and 'Maker' from the 'car_makers' table.", "Group the results: We need to group by 'Id' and 'Maker' to count the number of models associated with each maker.", "Apply the condition: We want only those makers that have more than 3 models, so we use the HAVING clause with COUNT(ml.ModelId) > 3."], "gold_sql": "SELECT T1.FullName ,  T1.Id FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >  3;", "source_tables": ["car_makers", "model_list"], "pred_sql": "SELECT cm.Id, cm.Maker \nFROM car_makers cm \nJOIN model_list ml ON cm.Id = ml.Maker \nGROUP BY cm.Id, cm.Maker \nHAVING COUNT(ml.ModelId) > 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n    \"1\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n    \"2\": \"This virtual table summarizes the number of car makers associated with each continent by joining the 'continents', 'countries', and 'car_makers' tables. The placeholder in the SELECT statement represents the continent's name, and the count function aggregates the number of car makers per continent.\"\n}\n"}
{"sample_id": "dev.161", "db_id": "car_1", "question": "How many countries has more than 2 car makers ?", "rationale": ["We need to count the number of countries that have more than 2 car makers.", "To do this, we will join the 'countries' table with the 'car_makers' table on the country identifier.", "We will group the results by the country identifier to count the number of car makers for each country.", "Using the COUNT function, we will count the number of car makers for each country.", "Finally, we will use the HAVING clause to filter the results to only include countries with more than 2 car makers."], "gold_sql": "select count(*) from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  2", "source_tables": ["car_makers", "countries"], "pred_sql": "SELECT COUNT(DISTINCT countries.CountryId) AS CountryCount\nFROM countries\nJOIN car_makers ON countries.CountryId = car_makers.Country\nGROUP BY countries.CountryId\nHAVING COUNT(car_makers.Id) > 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of car makers associated with each continent by joining the 'continents', 'countries', and 'car_makers' tables. The placeholder in the SELECT statement represents the continent's name, and the count function aggregates the number of car makers per continent.\",\n    \"1\": \"This virtual table provides the count of car models from the 'model_list' table that are associated with car makers from a specific country. The placeholders in the WHERE clause represent the name of the country being queried.\",\n    \"2\": \"This virtual table provides the count of car models from the 'model_list' table that are associated with car makers from a specific country. The placeholders in the WHERE clause represent the name of the country being queried.\"\n}\n"}
{"sample_id": "dev.165", "db_id": "car_1", "question": "For the cars with 4 cylinders, which model has the largest horsepower?", "rationale": ["Identify the relevant tables: We need to look at the 'cars_data' table for horsepower and cylinder information, and the 'model_list' table for car models.", "Filter the cars based on the number of cylinders: We will filter the results to only include cars with 4 cylinders.", "Select the model and the maximum horsepower: We want to find the model with the largest horsepower, so we will use the MAX function on the horsepower column.", "Join the necessary tables: We need to join 'cars_data' with 'car_names' to get the model names, and then join with 'model_list' to ensure we have the correct model information.", "Group the results by model: This allows us to calculate the maximum horsepower for each model.", "Order the results to get the model with the largest horsepower: We will order the results in descending order of horsepower and limit the output to 1 to get the top result."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  4 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT model_list.Model, MAX(cars_data.Horsepower) AS MaxHorsepower\nFROM cars_data\nJOIN car_names ON cars_data.Id = car_names.MakeId\nJOIN model_list ON car_names.Model = model_list.Model\nWHERE cars_data.Cylinders = 4\nGROUP BY model_list.Model\nORDER BY MaxHorsepower DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of car models from the 'model_list' table that are associated with car makers from a specific country. The placeholders in the WHERE clause represent the name of the country being queried.\",\n    \"1\": \"This virtual table provides the count of car models from the 'model_list' table that are associated with car makers from a specific country. The placeholders in the WHERE clause represent the name of the country being queried.\",\n    \"2\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\"\n}\n"}
{"sample_id": "dev.171", "db_id": "car_1", "question": "Which models are lighter than 3500 but not built by the 'Ford Motor Company'?", "rationale": ["Identify the relevant tables: model_list, car_names, and cars_data are needed to get the car models and their weights.", "Join the model_list table with the car_names table to get the make of each model.", "Join the resulting table with the cars_data table to access the weight of each car model.", "Filter the results to include only those models with a weight less than 3500.", "Exclude models made by 'Ford Motor Company' using a NOT EQUAL condition in the WHERE clause."], "gold_sql": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.Model  =  T2.Model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.Id JOIN CAR_MAKERS AS T4 ON T1.Maker  =  T4.Id WHERE T3.weight  <  3500 AND T4.FullName != 'Ford Motor Company';", "source_tables": ["car_makers", "model_list", "car_names", "cars_data"], "pred_sql": "SELECT DISTINCT ml.Model \nFROM model_list ml \nJOIN car_names cn ON ml.Model = cn.Model \nJOIN cars_data cd ON cn.MakeId = cd.Id \nWHERE cd.Weight < 3500 \nAND cn.Make != 'Ford Motor Company';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n    \"1\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n    \"2\": \"This virtual table provides the count of car models from the 'model_list' table that are associated with car makers from a specific country. The placeholders in the WHERE clause represent the name of the country being queried.\"\n}\n"}
{"sample_id": "dev.175", "db_id": "car_1", "question": "Which are the car makers which produce at least 2 models and more than 3 car makers ? List the id and the maker .", "rationale": ["Identify the relevant tables: We need to work with the 'car_makers' and 'model_list' tables to find car makers and their models.", "Join the 'car_makers' table with the 'model_list' table on the Maker ID to associate each car maker with their respective models.", "Group the results by car maker ID and name to aggregate the number of models each maker produces.", "Use the HAVING clause to filter for car makers that produce at least 2 models.", "Additionally, use a subquery to ensure that there are more than 3 distinct car makers in total."], "gold_sql": "select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker group by t1.id having count(*)  >=  2 intersect select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker join car_names as t3 on t2.model  =  t3.model group by t1.id having count(*)  >  3;", "source_tables": ["car_makers", "car_names", "model_list"], "pred_sql": "SELECT cm.Id, cm.Maker\nFROM car_makers cm\nJOIN model_list ml ON cm.Id = ml.Maker\nGROUP BY cm.Id, cm.Maker\nHAVING COUNT(ml.ModelId) >= 2\nAND (SELECT COUNT(DISTINCT cm2.Id) FROM car_makers cm2) > 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of car makers associated with each continent by joining the 'continents', 'countries', and 'car_makers' tables. The placeholder in the SELECT statement represents the continent's name, and the count function aggregates the number of car makers per continent.\",\n    \"1\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n    \"2\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\"\n}\n"}
{"sample_id": "dev.176", "db_id": "car_1", "question": "What are the ids and makers of all car makers that produce at least 2 models and make more than 3 cars?", "rationale": ["Identify the relevant tables: car_makers, model_list, car_names, and cars_data.", "Join the car_makers table with model_list to associate car makers with their models.", "Join the model_list with car_names to get the make information.", "Join car_names with cars_data to count the number of cars produced by each maker.", "Group the results by car maker's Id and Maker name to aggregate the counts.", "Use the HAVING clause to filter for car makers that produce at least 2 distinct models and have more than 3 cars."], "gold_sql": "SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >=  2 INTERSECT SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker JOIN CAR_NAMES AS T3 ON T2.model  =  T3.model GROUP BY T1.Id HAVING count(*)  >  3;", "source_tables": ["car_makers", "car_names", "model_list"], "pred_sql": "SELECT cm.Id, cm.Maker\nFROM car_makers cm\nJOIN model_list ml ON cm.Id = ml.Maker\nJOIN car_names cn ON ml.Model = cn.Model\nJOIN cars_data cd ON cn.MakeId = cd.Id\nGROUP BY cm.Id, cm.Maker\nHAVING COUNT(DISTINCT ml.Model) >= 2 AND COUNT(cd.Id) > 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of car makers associated with each continent by joining the 'continents', 'countries', and 'car_makers' tables. The placeholder in the SELECT statement represents the continent's name, and the count function aggregates the number of car makers per continent.\",\n    \"1\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n    \"2\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\"\n}\n"}
{"sample_id": "dev.526", "db_id": "student_transcripts_tracking", "question": "What are the names and ids of every course with less than 2 sections?", "rationale": ["Identify the relevant tables: Courses and Sections.", "We need to find courses that have less than 2 sections, so we will join the Courses table with the Sections table on the course_id.", "Use a LEFT JOIN to ensure we include courses that may not have any sections.", "Group the results by course_id and course_name to aggregate the section counts for each course.", "Use the HAVING clause to filter the grouped results to only include courses with a count of sections less than 2."], "gold_sql": "SELECT T1.course_name ,  T1.course_id FROM Courses AS T1 JOIN Sections AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_id HAVING count(*)  <=  2", "source_tables": ["courses", "sections"], "pred_sql": "SELECT c.course_id, c.course_name \nFROM Courses c \nLEFT JOIN Sections s ON c.course_id = s.course_id \nGROUP BY c.course_id, c.course_name \nHAVING COUNT(s.section_id) < 2;", "hint": "\n"}
{"sample_id": "dev.534", "db_id": "student_transcripts_tracking", "question": "What are the first, middle, and last names, along with the ids, of all students who enrolled in 2 degree programs in one semester?", "rationale": ["Identify the relevant tables: Students, Student_Enrolment, and Student_Enrolment_Courses are needed to get student details and their enrolment information.", "Join the Students table with Student_Enrolment on student_id to link students with their enrolment records.", "Join the resulting table with Student_Enrolment_Courses on student_enrolment_id to link enrolment records with the courses they are enrolled in.", "Group the results by student_id to aggregate the enrolment data for each student.", "Use the HAVING clause to filter the grouped results to only include students who are enrolled in exactly 2 distinct degree programs."], "gold_sql": "SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  2", "source_tables": ["student_enrolment", "students"], "pred_sql": "SELECT s.student_id, s.first_name, s.middle_name, s.last_name\nFROM Students s\nJOIN Student_Enrolment se ON s.student_id = se.student_id\nJOIN Student_Enrolment_Courses sec ON se.student_enrolment_id = sec.student_enrolment_id\nGROUP BY s.student_id\nHAVING COUNT(DISTINCT se.degree_program_id) = 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholder in the WHERE clause represents the name of the degree program.\"\n}\n"}
{"sample_id": "dev.535", "db_id": "student_transcripts_tracking", "question": "Who is enrolled in a Bachelor degree program? List the first name, middle name, last name.", "rationale": ["Identify the relevant tables: Students, Student_Enrolment, and Degree_Programs.", "We need to join these tables to get the names of students enrolled in a Bachelor degree program.", "The Students table contains the first, middle, and last names of students.", "The Student_Enrolment table links students to their degree programs.", "The Degree_Programs table contains the degree program names, and we need to filter for those that include 'Bachelor'.", "Construct the SQL query using SELECT to get the names and JOIN to connect the tables based on their relationships."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  'Bachelor'", "source_tables": ["student_enrolment", "degree_programs", "students"], "pred_sql": "SELECT s.first_name, s.middle_name, s.last_name\nFROM Students s\nJOIN Student_Enrolment se ON s.student_id = se.student_id\nJOIN Degree_Programs dp ON se.degree_program_id = dp.degree_program_id\nWHERE dp.degree_summary_name LIKE '%Bachelor%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholder in the WHERE clause represents the name of the degree program.\"\n}\n"}
{"sample_id": "dev.539", "db_id": "student_transcripts_tracking", "question": "Find the program which most number of students are enrolled in. List both the id and the summary.", "rationale": ["Identify the relevant tables: Degree_Programs and Student_Enrolment are needed to find the degree programs and their enrollments.", "Join the Degree_Programs table with the Student_Enrolment table on the degree_program_id to link programs with their enrolled students.", "Group the results by degree_program_id and degree_summary_name to aggregate the number of students enrolled in each program.", "Use COUNT(se.student_id) to count the number of students enrolled in each program.", "Order the results in descending order based on the count of students to find the program with the most enrollments.", "Limit the results to 1 to get only the program with the highest number of students."], "gold_sql": "SELECT T1.degree_program_id ,  T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_program_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "degree_programs"], "pred_sql": "SELECT dp.degree_program_id, dp.degree_summary_name\nFROM Degree_Programs dp\nJOIN Student_Enrolment se ON dp.degree_program_id = se.degree_program_id\nGROUP BY dp.degree_program_id, dp.degree_summary_name\nORDER BY COUNT(se.student_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholder in the WHERE clause represents the name of the degree program.\"\n}\n"}
{"sample_id": "dev.541", "db_id": "student_transcripts_tracking", "question": "Which student has enrolled for the most times in any program? List the id, first name, middle name, last name, the number of enrollments and student id.", "rationale": ["Identify the relevant tables: Students and Student_Enrolment are needed to find student details and their enrollments.", "Join the Students table with the Student_Enrolment table on student_id to link students with their enrollments.", "Use COUNT() to count the number of enrollments for each student.", "Group the results by student_id to aggregate the enrollment counts per student.", "Order the results by the count of enrollments in descending order to find the student with the most enrollments.", "Limit the results to 1 to get only the top student."], "gold_sql": "SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "students"], "pred_sql": "SELECT s.student_id, s.first_name, s.middle_name, s.last_name, COUNT(se.student_enrolment_id) AS number_of_enrollments\nFROM Students s\nJOIN Student_Enrolment se ON s.student_id = se.student_id\nGROUP BY s.student_id\nORDER BY number_of_enrollments DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholder in the WHERE clause represents the name of the degree program.\"\n}\n"}
{"sample_id": "dev.547", "db_id": "student_transcripts_tracking", "question": "What's the name of the course with most number of enrollments?", "rationale": ["Identify the relevant tables: Courses, Student_Enrolment_Courses, and Student_Enrolment are needed to find the course with the most enrollments.", "Join the Courses table with the Student_Enrolment_Courses table on course_id to link courses with their enrollments.", "Join the Student_Enrolment table to ensure we are counting valid enrollments.", "Group the results by course_id to count the number of enrollments for each course.", "Order the results by the count of enrollments in descending order to get the course with the most enrollments at the top.", "Limit the results to 1 to get only the course with the highest number of enrollments."], "gold_sql": "SELECT  T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["courses", "student_enrolment_courses"], "pred_sql": "SELECT C.course_name\nFROM Courses C\nJOIN Student_Enrolment_Courses SEC ON C.course_id = SEC.course_id\nJOIN Student_Enrolment SE ON SEC.student_enrolment_id = SE.student_enrolment_id\nGROUP BY C.course_id\nORDER BY COUNT(SEC.student_course_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholder in the WHERE clause represents the name of the degree program.\"\n}\n"}
{"sample_id": "dev.548", "db_id": "student_transcripts_tracking", "question": "What is the name of the course with the most students enrolled?", "rationale": ["Identify the relevant tables: Courses, Student_Enrolment_Courses, and Student_Enrolment.", "Join the Courses table with Student_Enrolment_Courses on course_id to link courses with student enrolments.", "Join the result with Student_Enrolment on student_enrolment_id to access student information.", "Group the results by course_id to count the number of students enrolled in each course.", "Order the results by the count of students in descending order to find the course with the most students.", "Limit the results to 1 to get only the top course."], "gold_sql": "SELECT  T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["courses", "student_enrolment_courses"], "pred_sql": "SELECT C.course_name\nFROM Courses C\nJOIN Student_Enrolment_Courses SEC ON C.course_id = SEC.course_id\nJOIN Student_Enrolment SE ON SEC.student_enrolment_id = SE.student_enrolment_id\nGROUP BY C.course_id\nORDER BY COUNT(SE.student_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholder in the WHERE clause represents the name of the degree program.\"\n}\n"}
{"sample_id": "dev.550", "db_id": "student_transcripts_tracking", "question": "What are the last name of the students who live in North Carolina but have not registered in any degree programs?", "rationale": ["Identify the relevant tables: Students and Addresses for student information and their current address.", "Join the Students table with the Addresses table on the current_address_id to filter students based on their current state.", "Filter the results to include only those students who live in 'North Carolina'.", "Use the EXCEPT clause to exclude students who are enrolled in any degree programs by joining the Students table with the Student_Enrolment table.", "Select only the last names of the students who meet the criteria."], "gold_sql": "SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  'NorthCarolina' EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id", "source_tables": ["addresses", "student_enrolment", "students"], "pred_sql": "SELECT last_name \nFROM Students \nJOIN Addresses ON Students.current_address_id = Addresses.address_id \nWHERE Addresses.state_province_county = 'North Carolina' \nEXCEPT \nSELECT Students.last_name \nFROM Students \nJOIN Student_Enrolment ON Students.student_id = Student_Enrolment.student_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the last names of students who currently reside in a specific state, excluding those who are enrolled in any degree program. The query joins the 'Students' table with the 'Addresses' table to filter by the current address's state, and uses an EXCEPT clause to remove students who are found in the 'Student_Enrolment' table.\",\n    \"1\": \"This virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholder in the WHERE clause represents the name of the degree program.\"\n}\n"}
{"sample_id": "dev.554", "db_id": "student_transcripts_tracking", "question": "What is the mobile phone number of the student named Timmothy Ward ?", "rationale": ["Identify the relevant table: The question pertains to student information, specifically the mobile phone number, which is found in the Students table.", "Determine the necessary columns: We need the 'cell_mobile_number' column from the Students table.", "Formulate the WHERE clause: We need to filter the results to find the student with the first name 'Timmothy' and last name 'Ward'.", "Combine the SELECT statement with the WHERE clause to create the full SQL query."], "gold_sql": "select cell_mobile_number from students where first_name  =  'timmothy' and last_name  =  'ward'", "source_tables": ["students"], "pred_sql": "SELECT cell_mobile_number FROM Students WHERE first_name = 'Timmothy' AND last_name = 'Ward';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholder in the WHERE clause represents the name of the degree program.\"\n}\n"}
{"sample_id": "dev.561", "db_id": "student_transcripts_tracking", "question": "Which address holds the most number of students currently? List the address id and all lines.", "rationale": ["Identify the relevant tables: 'Addresses' for address details and 'Students' for student information.", "Join the 'Addresses' table with the 'Students' table on the current address ID to associate students with their addresses.", "Group the results by address ID and address lines to count the number of students per address.", "Order the results by the count of students in descending order to find the address with the most students.", "Limit the results to 1 to get only the address with the highest count of students."], "gold_sql": "SELECT T1.address_id ,  T1.line_1 ,  T1.line_2 FROM Addresses AS T1 JOIN Students AS T2 ON T1.address_id  =  T2.current_address_id GROUP BY T1.address_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "students"], "pred_sql": "SELECT a.address_id, a.line_1, a.line_2, a.line_3\nFROM Addresses a\nJOIN Students s ON a.address_id = s.current_address_id\nGROUP BY a.address_id, a.line_1, a.line_2, a.line_3\nORDER BY COUNT(s.student_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the last names of students who currently reside in a specific state, excluding those who are enrolled in any degree program. The query joins the 'Students' table with the 'Addresses' table to filter by the current address's state, and uses an EXCEPT clause to remove students who are found in the 'Student_Enrolment' table.\"\n}\n"}
{"sample_id": "dev.578", "db_id": "student_transcripts_tracking", "question": "What are the different addresses that have students living there?", "rationale": ["We need to find different addresses where students are living.", "This requires joining the 'Addresses' table with the 'Students' table based on the current address of the students.", "The join condition is that the 'address_id' in the 'Addresses' table matches the 'current_address_id' in the 'Students' table.", "To get unique addresses, we will use SELECT DISTINCT to avoid duplicate entries."], "gold_sql": "SELECT count(DISTINCT current_address_id) FROM Students", "source_tables": ["students"], "pred_sql": "SELECT DISTINCT Addresses.*\nFROM Addresses\nJOIN Students ON Addresses.address_id = Students.current_address_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the last names of students who currently reside in a specific state, excluding those who are enrolled in any degree program. The query joins the 'Students' table with the 'Addresses' table to filter by the current address's state, and uses an EXCEPT clause to remove students who are found in the 'Student_Enrolment' table.\",\n    \"1\": \"This virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholder in the WHERE clause represents the name of the degree program.\"\n}\n"}
{"sample_id": "dev.581", "db_id": "student_transcripts_tracking", "question": "Describe the section h.", "rationale": ["The user wants to describe a specific section identified by the name 'h'.", "To retrieve information about a section, we need to select all columns from the Sections table.", "We will use a WHERE clause to filter the results to only include the section with the name 'h'."], "gold_sql": "SELECT section_description FROM Sections WHERE section_name  =  'h'", "source_tables": ["sections"], "pred_sql": "SELECT * FROM Sections WHERE section_name = 'h';", "hint": "\n"}
{"sample_id": "dev.705", "db_id": "world_1", "question": "How many countries have governments that are republics?", "rationale": ["Identify the table that contains information about countries, which is the 'country' table.", "Determine the relevant column that indicates the type of government, which is 'GovernmentForm'.", "Formulate a query to count the number of countries where the 'GovernmentForm' contains the word 'Republic'.", "Use the COUNT() function to get the total number of such countries."], "gold_sql": "SELECT count(*) FROM country WHERE GovernmentForm  =  'Republic'", "source_tables": ["country"], "pred_sql": "SELECT COUNT(*) FROM country WHERE GovernmentForm LIKE '%Republic%';", "hint": "\n"}
{"sample_id": "dev.723", "db_id": "world_1", "question": "How many people live in Asia, and what is the largest GNP among them?", "rationale": ["Identify the relevant tables: 'country' for GNP and continent, and 'city' for population.", "We need to sum the population of cities in Asia, which requires joining the 'city' and 'country' tables on the CountryCode.", "Filter the results to only include countries in Asia by using a WHERE clause on the continent.", "Calculate the total population using SUM() and the largest GNP using MAX() in the SELECT statement."], "gold_sql": "SELECT sum(Population) ,  max(GNP) FROM country WHERE Continent  =  'Asia'", "source_tables": ["country"], "pred_sql": "SELECT SUM(c.Population) AS TotalPopulation, MAX(co.GNP) AS LargestGNP\nFROM country AS co\nJOIN city AS ci ON co.Code = ci.CountryCode\nWHERE co.Continent = 'Asia';", "hint": "\n"}
{"sample_id": "dev.724", "db_id": "world_1", "question": "What is the average life expectancy in African countries that are republics?", "rationale": ["Identify the relevant table: The 'country' table contains information about countries, including their life expectancy and government form.", "Determine the conditions: We need to filter for countries in the continent of Africa and those that have a government form that includes 'Republic'.", "Use the AVG() function: To calculate the average life expectancy, we will use the AVG() function on the 'LifeExpectancy' column.", "Construct the SQL query: Combine the SELECT statement with the WHERE clause to filter the results accordingly."], "gold_sql": "SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  'Africa' AND GovernmentForm  =  'Republic'", "source_tables": ["country"], "pred_sql": "SELECT AVG(LifeExpectancy) AS AverageLifeExpectancy\nFROM country\nWHERE Continent = 'Africa' AND GovernmentForm LIKE '%Republic%';", "hint": "\n"}
{"sample_id": "dev.725", "db_id": "world_1", "question": "Give the average life expectancy for countries in Africa which are republics?", "rationale": ["Identify the relevant table: The 'country' table contains the information about countries, including life expectancy and government form.", "Determine the columns needed: We need the 'LifeExpectancy' column to calculate the average and the 'GovernmentForm' column to filter for republics.", "Set the conditions for the query: We want countries that are in the continent of Africa and have a government form that includes 'Republic'.", "Use the AVG() function to calculate the average life expectancy for the filtered results."], "gold_sql": "SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  'Africa' AND GovernmentForm  =  'Republic'", "source_tables": ["country"], "pred_sql": "SELECT AVG(LifeExpectancy) AS AverageLifeExpectancy \nFROM country \nWHERE Continent = 'Africa' \nAND GovernmentForm LIKE '%Republic%';", "hint": "\n"}
{"sample_id": "dev.731", "db_id": "world_1", "question": "Give the mean GNP and total population of nations which are considered US territory.", "rationale": ["Identify the relevant table: The 'country' table contains information about countries, including their GNP and population.", "Determine the criteria for US territories: We will filter the countries that are considered US territories. This can be done by checking if the country name contains 'United States' or 'US'.", "Calculate the mean GNP: Use the AVG() function to calculate the average GNP of the filtered countries.", "Calculate the total population: Use the SUM() function to calculate the total population of the filtered countries.", "Combine the calculations in a SELECT statement: We will select both the average GNP and total population in one query."], "gold_sql": "SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  'US Territory'", "source_tables": ["country"], "pred_sql": "SELECT AVG(GNP) AS Mean_GNP, SUM(Population) AS Total_Population \nFROM country \nWHERE Name LIKE '%United States%' OR Name LIKE '%US%';", "hint": "\n"}
{"sample_id": "dev.735", "db_id": "world_1", "question": "How many different forms of governments are there in Africa?", "rationale": ["Identify the relevant table: The 'country' table contains information about countries, including their government forms and continent.", "Determine the specific continent of interest: The question specifies Africa.", "Count the distinct forms of government: Use COUNT(DISTINCT GovernmentForm) to find the number of unique government forms in Africa."], "gold_sql": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  'Africa'", "source_tables": ["country"], "pred_sql": "SELECT COUNT(DISTINCT GovernmentForm) AS DifferentFormsOfGovernment \nFROM country \nWHERE Continent = 'Africa';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.\"\n}\n"}
{"sample_id": "dev.754", "db_id": "world_1", "question": "What are the countries where either English or Dutch is the official language ?", "rationale": ["Identify the relevant tables: We need to look at the 'country' and 'countrylanguage' tables to find countries with specific official languages.", "We need to select distinct country names, so we will use SELECT DISTINCT country.Name.", "To find the countries where either English or Dutch is an official language, we will join the 'country' table with the 'countrylanguage' table on the country code.", "We will filter the results using a WHERE clause to check if the language is official (IsOfficial = 'T') and if the language is either English or Dutch."], "gold_sql": "select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  'english' and isofficial  =  't' union select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  'dutch' and isofficial  =  't'", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT DISTINCT country.Name \nFROM country \nJOIN countrylanguage ON country.Code = countrylanguage.CountryCode \nWHERE countrylanguage.IsOfficial = 'T' \nAND (countrylanguage.Language = 'English' OR countrylanguage.Language = 'Dutch');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.\",\n    \"1\": \"This virtual table provides a list of distinct city names from the 'city' table that are located in a specific continent, as defined in the 'country' table. Additionally, it filters out cities from countries where a specified language is an official language, ensuring that only cities from countries without that official language are included. The placeholders in the WHERE clause represent the continent and the language criteria.\"\n}\n"}
{"sample_id": "dev.755", "db_id": "world_1", "question": "Which countries have either English or Dutch as an official language?", "rationale": ["Identify the relevant tables: We need to look at the 'country' and 'countrylanguage' tables to find countries with specific official languages.", "Determine the filtering criteria: We are interested in countries where either 'English' or 'Dutch' is an official language.", "Use a JOIN operation: We will join the 'country' table with the 'countrylanguage' table on the 'Code' and 'CountryCode' fields to link countries with their languages.", "Select distinct country names: We want to retrieve unique country names that meet the language criteria.", "Apply the WHERE clause: We will filter the results to include only those countries where the language is either 'English' or 'Dutch' and is marked as official."], "gold_sql": "SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English' AND IsOfficial  =  'T' UNION SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'Dutch' AND IsOfficial  =  'T'", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT DISTINCT country.Name \nFROM country \nJOIN countrylanguage ON country.Code = countrylanguage.CountryCode \nWHERE countrylanguage.Language IN ('English', 'Dutch') AND countrylanguage.IsOfficial = 'T';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.\",\n    \"1\": \"This virtual table provides a list of distinct city names from the 'city' table that are located in a specific continent, as defined in the 'country' table. Additionally, it filters out cities from countries where a specified language is an official language, ensuring that only cities from countries without that official language are included. The placeholders in the WHERE clause represent the continent and the language criteria.\"\n}\n"}
{"sample_id": "dev.758", "db_id": "world_1", "question": "Which languages are spoken by only one country in republic governments?", "rationale": ["Identify the relevant tables: We need to look at the 'countrylanguage' table for languages and the 'country' table for government forms.", "We need to filter for languages that are official (IsOfficial = 'T') and are spoken in countries with a republican form of government (GovernmentForm LIKE '%Republic%').", "We want to find languages that are spoken in only one country, so we will group by the language and use HAVING COUNT(DISTINCT c.Code) = 1 to ensure that only languages spoken in one country are selected."], "gold_sql": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.GovernmentForm  =  'Republic' GROUP BY T2.Language HAVING COUNT(*)  =  1", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT cl.Language\nFROM countrylanguage cl\nJOIN country c ON cl.CountryCode = c.Code\nWHERE cl.IsOfficial = 'T' AND c.GovernmentForm LIKE '%Republic%'\nGROUP BY cl.Language\nHAVING COUNT(DISTINCT c.Code) = 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.\",\n    \"1\": \"This virtual table provides a list of distinct city names from the 'city' table that are located in a specific continent, as defined in the 'country' table. Additionally, it filters out cities from countries where a specified language is an official language, ensuring that only cities from countries without that official language are included. The placeholders in the WHERE clause represent the continent and the language criteria.\"\n}\n"}
{"sample_id": "dev.759", "db_id": "world_1", "question": "What languages are only used by a single country with a republic government?", "rationale": ["Identify the relevant tables: We need to look at the 'countrylanguage' table for languages and the 'country' table for government forms.", "Join the 'countrylanguage' table with the 'country' table on the CountryCode to access both languages and their corresponding countries.", "Filter the results to include only official languages (IsOfficial = 'T') and countries with a republic government (GovernmentForm = 'Republic').", "Group the results by language to count how many distinct countries speak each language.", "Use the HAVING clause to filter the grouped results to only include languages that are spoken in exactly one country (COUNT(DISTINCT c.Code) = 1)."], "gold_sql": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.GovernmentForm  =  'Republic' GROUP BY T2.Language HAVING COUNT(*)  =  1", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT cl.Language\nFROM countrylanguage cl\nJOIN country c ON cl.CountryCode = c.Code\nWHERE cl.IsOfficial = 'T'\nAND c.GovernmentForm = 'Republic'\nGROUP BY cl.Language\nHAVING COUNT(DISTINCT c.Code) = 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.\",\n    \"1\": \"This virtual table provides a list of distinct city names from the 'city' table that are located in a specific continent, as defined in the 'country' table. Additionally, it filters out cities from countries where a specified language is an official language, ensuring that only cities from countries without that official language are included. The placeholders in the WHERE clause represent the continent and the language criteria.\"\n}\n"}
{"sample_id": "dev.760", "db_id": "world_1", "question": "Find the city with the largest population that uses English.", "rationale": ["Identify the requirement to find the city with the largest population that uses English.", "To find cities that use English, we need to look at the 'countrylanguage' table to filter countries where English is an official language.", "We will then use the 'country' table to get the country codes of those countries.", "Next, we will filter the 'city' table to find cities that belong to those countries.", "Finally, we will order the results by population in descending order and limit the results to 1 to get the city with the largest population."], "gold_sql": "SELECT T1.Name ,  T1.Population FROM city AS T1 JOIN countrylanguage AS T2 ON T1.CountryCode  =  T2.CountryCode WHERE T2.Language  =  'English' ORDER BY T1.Population DESC LIMIT 1", "source_tables": ["city", "countrylanguage"], "pred_sql": "SELECT Name, Population FROM city WHERE CountryCode IN (SELECT Code FROM country WHERE Code IN (SELECT CountryCode FROM countrylanguage WHERE Language = 'English' AND IsOfficial = 'T')) ORDER BY Population DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.\",\n    \"1\": \"This virtual table provides a list of distinct city names from the 'city' table that are located in a specific continent, as defined in the 'country' table. Additionally, it filters out cities from countries where a specified language is an official language, ensuring that only cities from countries without that official language are included. The placeholders in the WHERE clause represent the continent and the language criteria.\"\n}\n"}
{"sample_id": "dev.766", "db_id": "world_1", "question": "What is the total number of people living in the nations that do not use English?", "rationale": ["Identify the main goal: Calculate the total population of countries that do not have English as an official language.", "To achieve this, we need to sum the population from the 'country' table.", "We need to filter out countries where English is an official language. This requires a subquery that selects the country codes from the 'countrylanguage' table where the language is English and it is marked as official (IsOfficial = 'T').", "The main query will sum the populations of countries whose codes are not in the result of the subquery."], "gold_sql": "SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English')", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT SUM(country.Population) AS TotalPopulation\nFROM country\nWHERE Code NOT IN (\n    SELECT CountryCode\n    FROM countrylanguage\n    WHERE Language = 'English' AND IsOfficial = 'T'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.\"\n}\n"}
{"sample_id": "dev.774", "db_id": "world_1", "question": "What are the African countries that have a  population less than any country in Asia?", "rationale": ["Identify the countries in Africa by filtering the 'country' table for 'Continent = Africa'.", "Determine the population criteria by finding the minimum population of countries in Asia using a subquery on the 'country' table where 'Continent = Asia'.", "Combine these two criteria to select the names of African countries that have a population less than the minimum population of any Asian country."], "gold_sql": "SELECT Name FROM country WHERE Continent  =  'Africa'  AND population  <  (SELECT max(population) FROM country WHERE Continent  =  'Asia')", "source_tables": ["country"], "pred_sql": "SELECT Name FROM country WHERE Continent = 'Africa' AND Population < (SELECT MIN(Population) FROM country WHERE Continent = 'Asia');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.\"\n}\n"}
{"sample_id": "dev.777", "db_id": "world_1", "question": "What are the Asian countries which have a population larger than that of any country in Africa?", "rationale": ["Identify the countries in Asia by filtering the 'country' table where the 'Continent' is 'Asia'.", "We need to compare the population of these Asian countries with the population of countries in Africa.", "To find the maximum population in Africa, we can use a subquery that selects the maximum population from the 'country' table where the 'Continent' is 'Africa'.", "The final query selects the names of Asian countries whose population is greater than the maximum population found in the African countries."], "gold_sql": "SELECT Name FROM country WHERE Continent  =  'Asia'  AND population  >  (SELECT min(population) FROM country WHERE Continent  =  'Africa')", "source_tables": ["country"], "pred_sql": "SELECT c.Name \nFROM country c \nWHERE c.Continent = 'Asia' \nAND c.Population > (SELECT MAX(Population) FROM country WHERE Continent = 'Africa');", "hint": "\n"}
{"sample_id": "dev.778", "db_id": "world_1", "question": "What are the country codes for countries that do not speak English?", "rationale": ["Identify the countries that do not have English as an official language.", "To do this, we need to find the country codes from the 'country' table.", "We will use a subquery to select the country codes from the 'countrylanguage' table where the language is 'English' and it is marked as an official language.", "The main query will select distinct country codes from the 'country' table that are not in the list returned by the subquery."], "gold_sql": "SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  'English'", "source_tables": ["countrylanguage"], "pred_sql": "SELECT DISTINCT Code FROM country WHERE Code NOT IN (SELECT CountryCode FROM countrylanguage WHERE Language = 'English' AND IsOfficial = 'T');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.\",\n    \"1\": \"This virtual table provides a list of distinct city names from the 'city' table that are located in a specific continent, as defined in the 'country' table. Additionally, it filters out cities from countries where a specified language is an official language, ensuring that only cities from countries without that official language are included. The placeholders in the WHERE clause represent the continent and the language criteria.\"\n}\n"}
{"sample_id": "dev.786", "db_id": "world_1", "question": "Which unique cities are in Asian countries where Chinese is the official language ?", "rationale": ["Identify the relevant tables: 'city', 'country', and 'countrylanguage'.", "We need to find unique city names, so we will use SELECT DISTINCT on the city names from the 'city' table.", "Join the 'city' table with the 'country' table on the CountryCode to filter cities by their countries.", "Join the 'country' table with the 'countrylanguage' table to filter countries by the official language.", "Apply a WHERE clause to filter for countries in Asia and where Chinese is an official language."], "gold_sql": "select distinct t3.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode join city as t3 on t1.code  =  t3.countrycode where t2.isofficial  =  't' and t2.language  =  'chinese' and t1.continent  =  'asia'", "source_tables": ["country", "city", "countrylanguage"], "pred_sql": "SELECT DISTINCT c.Name \nFROM city c \nJOIN country co ON c.CountryCode = co.Code \nJOIN countrylanguage cl ON co.Code = cl.CountryCode \nWHERE co.Continent = 'Asia' \nAND cl.Language = 'Chinese' \nAND cl.IsOfficial = 'T';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.\",\n    \"1\": \"This virtual table provides a list of distinct city names from the 'city' table that are located in a specific continent, as defined in the 'country' table. Additionally, it filters out cities from countries where a specified language is an official language, ensuring that only cities from countries without that official language are included. The placeholders in the WHERE clause represent the continent and the language criteria.\"\n}\n"}
{"sample_id": "dev.789", "db_id": "world_1", "question": "Give the name, year of independence, and surface area of the country that has the lowest population.", "rationale": ["Identify the columns needed: Name, IndepYear, and SurfaceArea from the country table.", "Determine the condition to find the country with the lowest population: use a subquery to find the minimum population.", "Construct the main query to select the required columns from the country table where the population matches the minimum population found in the subquery."], "gold_sql": "SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT 1", "source_tables": ["country"], "pred_sql": "SELECT Name, IndepYear, SurfaceArea FROM country WHERE Population = (SELECT MIN(Population) FROM country);", "hint": "\n"}
{"sample_id": "dev.793", "db_id": "world_1", "question": "What are the names of countries that speak more than 2 languages, as well as how many languages they speak?", "rationale": ["Identify the relevant tables: We need to use the 'country' table to get country names and the 'countrylanguage' table to count the languages spoken in each country.", "Join the 'country' table with the 'countrylanguage' table on the 'Code' and 'CountryCode' fields to associate countries with their languages.", "Group the results by country name to aggregate the language counts for each country.", "Use the COUNT function to count the number of languages spoken in each country.", "Filter the results using the HAVING clause to include only those countries that speak more than 2 languages."], "gold_sql": "SELECT COUNT(T2.Language) ,  T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Name HAVING COUNT(*)  >  2", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT c.Name, COUNT(cl.Language) AS LanguageCount\nFROM country c\nJOIN countrylanguage cl ON c.Code = cl.CountryCode\nGROUP BY c.Name\nHAVING COUNT(cl.Language) > 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.\",\n    \"1\": \"This virtual table provides a list of distinct city names from the 'city' table that are located in a specific continent, as defined in the 'country' table. Additionally, it filters out cities from countries where a specified language is an official language, ensuring that only cities from countries without that official language are included. The placeholders in the WHERE clause represent the continent and the language criteria.\"\n}\n"}
{"sample_id": "dev.797", "db_id": "world_1", "question": "What are the different government forms and what is the total population of each for government forms that have an average life expectancy greater than 72?", "rationale": ["Identify the relevant table: The question pertains to government forms and population, which are found in the 'country' table.", "Select the columns needed: We need 'GovernmentForm' and the total population, so we will select 'GovernmentForm' and use SUM(Population) to get the total population for each government form.", "Apply the condition: We need to filter the results to include only those government forms with an average life expectancy greater than 72, so we will use a WHERE clause with LifeExpectancy > 72.", "Group the results: Since we want the total population for each government form, we will use GROUP BY on 'GovernmentForm' to aggregate the population data accordingly."], "gold_sql": "SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  72", "source_tables": ["country"], "pred_sql": "SELECT GovernmentForm, SUM(Population) AS TotalPopulation\nFROM country\nWHERE LifeExpectancy > 72\nGROUP BY GovernmentForm;", "hint": "\n"}
{"sample_id": "dev.812", "db_id": "world_1", "question": "What are the cities whose population is between 160000 and 900000?", "rationale": ["Identify the relevant table: The 'city' table contains the population data we need.", "Determine the condition: We need to filter cities based on their population being between 160000 and 900000.", "Construct the SQL query: Use the SELECT statement to retrieve the 'Name' of cities from the 'city' table where the 'Population' falls within the specified range."], "gold_sql": "SELECT name FROM city WHERE Population BETWEEN 160000 AND 900000", "source_tables": ["city"], "pred_sql": "SELECT Name FROM city WHERE Population BETWEEN '160000' AND '900000';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.\",\n    \"1\": \"This virtual table provides a list of distinct city names from the 'city' table that are located in a specific continent, as defined in the 'country' table. Additionally, it filters out cities from countries where a specified language is an official language, ensuring that only cities from countries without that official language are included. The placeholders in the WHERE clause represent the continent and the language criteria.\"\n}\n"}
{"sample_id": "dev.820", "db_id": "world_1", "question": "What are the codes of countries where Spanish is spoken by the largest percentage of people?", "rationale": ["Identify the relevant table: The 'countrylanguage' table contains information about languages spoken in different countries.", "Filter for the specific language: We need to filter the records to only include those where the Language is 'Spanish'.", "Sort by percentage: To find the countries where Spanish is spoken by the largest percentage of people, we will order the results by the Percentage column in descending order.", "Select the country codes: Finally, we will select the CountryCode from the filtered and sorted results."], "gold_sql": "SELECT CountryCode ,  max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  'Spanish' GROUP BY CountryCode", "source_tables": ["countrylanguage"], "pred_sql": "SELECT CountryCode FROM countrylanguage WHERE Language = 'Spanish' ORDER BY Percentage DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.\",\n    \"1\": \"This virtual table provides a list of distinct city names from the 'city' table that are located in a specific continent, as defined in the 'country' table. Additionally, it filters out cities from countries where a specified language is an official language, ensuring that only cities from countries without that official language are included. The placeholders in the WHERE clause represent the continent and the language criteria.\"\n}\n"}
{"sample_id": "dev.821", "db_id": "world_1", "question": "Return the codes of countries for which Spanish is the predominantly spoken language.", "rationale": ["Identify the requirement: We need to find the codes of countries where Spanish is the predominantly spoken language.", "Understand the schema: The 'countrylanguage' table contains information about languages spoken in each country, including whether they are official languages.", "Formulate the inner query: We will select the 'CountryCode' from the 'countrylanguage' table where the 'Language' is 'Spanish' and 'IsOfficial' is 'Yes'. This will give us the countries where Spanish is an official language.", "Formulate the outer query: We will select the distinct 'Code' from the 'country' table where the 'Code' is in the result of the inner query. This will give us the country codes for countries where Spanish is predominantly spoken."], "gold_sql": "SELECT CountryCode ,  max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  'Spanish' GROUP BY CountryCode", "source_tables": ["countrylanguage"], "pred_sql": "SELECT DISTINCT Code FROM country WHERE Code IN (SELECT CountryCode FROM countrylanguage WHERE Language = 'Spanish' AND IsOfficial = 'Yes')", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.\",\n    \"1\": \"This virtual table provides a list of distinct city names from the 'city' table that are located in a specific continent, as defined in the 'country' table. Additionally, it filters out cities from countries where a specified language is an official language, ensuring that only cities from countries without that official language are included. The placeholders in the WHERE clause represent the continent and the language criteria.\"\n}\n"}
{"sample_id": "dev.920", "db_id": "dog_kennels", "question": "What is the average age of the dogs who have gone through any treatments?", "rationale": ["Identify the relevant tables: Dogs and Treatments.", "We need to find the average age of dogs that have undergone treatments, so we will join the Dogs table with the Treatments table on the dog_id.", "Use the AVG() function to calculate the average age of the dogs from the Dogs table after the join."], "gold_sql": "SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )", "source_tables": ["dogs", "treatments"], "pred_sql": "SELECT AVG(D.age) AS average_age\nFROM Dogs D\nJOIN Treatments T ON D.dog_id = T.dog_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of owners along with their last names who have had dogs treated, sorted by the number of treatments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of owners to display.\"\n}\n"}
{"sample_id": "dev.936", "db_id": "dog_kennels", "question": "Which owner has paid for the most treatments on his or her dogs? List the owner id and last name.", "rationale": ["Identify the relevant tables: Owners, Dogs, and Treatments.", "Join the Owners table with the Dogs table on owner_id to link owners to their dogs.", "Join the resulting table with the Treatments table on dog_id to link treatments to the respective dogs.", "Group the results by owner_id and last_name to aggregate the treatment counts for each owner.", "Count the number of treatments for each owner using COUNT(Treatments.treatment_id).", "Order the results in descending order to find the owner with the most treatments.", "Limit the results to 1 to get only the top owner."], "gold_sql": "SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["owners", "dogs", "treatments"], "pred_sql": "SELECT Owners.owner_id, Owners.last_name\nFROM Owners\nJOIN Dogs ON Owners.owner_id = Dogs.owner_id\nJOIN Treatments ON Dogs.dog_id = Treatments.dog_id\nGROUP BY Owners.owner_id, Owners.last_name\nORDER BY COUNT(Treatments.treatment_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of owners along with their last names who have had dogs treated, sorted by the number of treatments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of owners to display.\",\n    \"1\": \"This virtual table provides a list of unique first names of professionals along with the descriptions of the treatment types they have administered. The data is sourced from the 'Professionals', 'Treatments', and 'Treatment_Types' tables, ensuring that only distinct combinations of professional names and treatment descriptions are displayed.\"\n}\n"}
{"sample_id": "dev.942", "db_id": "dog_kennels", "question": "Which professionals have done at least two types of treatments? List the professional id and cell phone.", "rationale": ["We need to find professionals who have administered at least two different types of treatments.", "To do this, we will join the 'Professionals' table with the 'Treatments' table on the professional_id.", "We will group the results by professional_id and cell_number to aggregate the treatments for each professional.", "Using the HAVING clause, we will filter the groups to include only those with a count of distinct treatment types greater than or equal to 2.", "Finally, we will select the professional_id and cell_number from the filtered results."], "gold_sql": "SELECT T1.professional_id ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  2", "source_tables": ["professionals", "treatments"], "pred_sql": "SELECT p.professional_id, p.cell_number\nFROM Professionals p\nJOIN Treatments t ON p.professional_id = t.professional_id\nGROUP BY p.professional_id, p.cell_number\nHAVING COUNT(DISTINCT t.treatment_type_code) >= 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique first names of professionals along with the descriptions of the treatment types they have administered. The data is sourced from the 'Professionals', 'Treatments', and 'Treatment_Types' tables, ensuring that only distinct combinations of professional names and treatment descriptions are displayed.\"\n}\n"}
{"sample_id": "dev.944", "db_id": "dog_kennels", "question": "What are the first name and last name of the professionals who have done treatment with cost below average?", "rationale": ["Identify the tables needed: Professionals and Treatments.", "We need to select the first name and last name of professionals, so we will select p.first_name and p.last_name from the Professionals table.", "Join the Professionals table with the Treatments table on the professional_id to link treatments to professionals.", "We need to filter the treatments based on their cost being below average, so we will use a subquery to calculate the average cost of treatments.", "The subquery will select the average cost from the Treatments table, and we will use this in the WHERE clause to filter the results."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T1.last_name FROM Professionals AS T1 JOIN Treatments AS T2 WHERE cost_of_treatment  <  ( SELECT avg(cost_of_treatment) FROM Treatments )", "source_tables": ["professionals", "treatments"], "pred_sql": "SELECT DISTINCT p.first_name, p.last_name \nFROM Professionals p \nJOIN Treatments t ON p.professional_id = t.professional_id \nWHERE t.cost_of_treatment < (SELECT AVG(cost_of_treatment) FROM Treatments);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique first names of professionals along with the descriptions of the treatment types they have administered. The data is sourced from the 'Professionals', 'Treatments', and 'Treatment_Types' tables, ensuring that only distinct combinations of professional names and treatment descriptions are displayed.\",\n    \"1\": \"This virtual table provides a list of owners along with their last names who have had dogs treated, sorted by the number of treatments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of owners to display.\"\n}\n"}
{"sample_id": "dev.950", "db_id": "dog_kennels", "question": "List each owner's first name, last name, and the size of his for her dog.", "rationale": ["Identify the required information: owner's first name, last name, and dog's size.", "Determine the relevant tables: Owners, Dogs, and Sizes.", "Establish relationships between the tables: Owners to Dogs (via owner_id) and Dogs to Sizes (via size_code).", "Use JOIN clauses to combine the tables based on these relationships.", "Select the appropriate columns from the combined result set."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id", "source_tables": ["owners", "dogs"], "pred_sql": "SELECT Owners.first_name, Owners.last_name, Sizes.size_description \nFROM Owners \nJOIN Dogs ON Owners.owner_id = Dogs.owner_id \nJOIN Sizes ON Dogs.size_code = Sizes.size_code;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of owners along with their last names who have had dogs treated, sorted by the number of treatments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of owners to display.\"\n}\n"}
{"sample_id": "dev.951", "db_id": "dog_kennels", "question": "What are each owner's first name, last name, and the size of their dog?", "rationale": ["Identify the required information: owner's first name, last name, and dog's size.", "Determine the relevant tables: Owners, Dogs, and Sizes.", "Establish relationships between the tables: Owners are linked to Dogs via owner_id, and Dogs are linked to Sizes via size_code.", "Use JOIN clauses to combine the tables based on these relationships.", "Select the appropriate columns from the combined tables."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id", "source_tables": ["owners", "dogs"], "pred_sql": "SELECT Owners.first_name, Owners.last_name, Sizes.size_description \nFROM Owners \nJOIN Dogs ON Owners.owner_id = Dogs.owner_id \nJOIN Sizes ON Dogs.size_code = Sizes.size_code;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of owners along with their last names who have had dogs treated, sorted by the number of treatments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of owners to display.\"\n}\n"}
{"sample_id": "dev.958", "db_id": "dog_kennels", "question": "What are the arriving date and the departing date of the dogs who have gone through a treatment?", "rationale": ["Identify the relevant tables: Dogs and Treatments.", "Determine the columns needed: arriving date (date_arrived) and departing date (date_departed) from Dogs.", "Establish the relationship between Dogs and Treatments using the dog_id foreign key.", "Construct the SQL query to select the required columns from Dogs, joining with Treatments on the dog_id."], "gold_sql": "SELECT DISTINCT T1.date_arrived ,  T1.date_departed FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id", "source_tables": ["dogs", "treatments"], "pred_sql": "SELECT Dogs.date_arrived, Dogs.date_departed \nFROM Dogs \nJOIN Treatments ON Dogs.dog_id = Treatments.dog_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of owners along with their last names who have had dogs treated, sorted by the number of treatments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of owners to display.\"\n}\n"}
{"sample_id": "dev.961", "db_id": "dog_kennels", "question": "Who owns the youngest dog? Give me his or her last name.", "rationale": ["Identify the relevant tables: Owners and Dogs.", "We need to find the youngest dog, which requires accessing the Dogs table to sort by date_of_birth.", "Join the Owners table with the Dogs table on the owner_id to link owners with their dogs.", "Sort the results by date_of_birth in descending order to get the youngest dog first.", "Limit the results to 1 to get only the owner of the youngest dog."], "gold_sql": "SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )", "source_tables": ["owners", "dogs"], "pred_sql": "SELECT Owners.last_name \nFROM Owners \nJOIN Dogs ON Owners.owner_id = Dogs.owner_id \nORDER BY Dogs.date_of_birth DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of owners along with their last names who have had dogs treated, sorted by the number of treatments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of owners to display.\"\n}\n"}
{"sample_id": "dev.997", "db_id": "dog_kennels", "question": "Find the distinct breed type and size type combinations for dogs.", "rationale": ["Identify the tables needed: Dogs, Breeds, and Sizes.", "We need to find distinct combinations of breed types and size types for dogs.", "Join the Dogs table with the Breeds table on the breed_code to get breed names.", "Join the Dogs table with the Sizes table on the size_code to get size descriptions.", "Select distinct breed names and size descriptions to avoid duplicates."], "gold_sql": "SELECT DISTINCT breed_code ,  size_code FROM dogs", "source_tables": ["dogs"], "pred_sql": "SELECT DISTINCT B.breed_name, S.size_description\nFROM Dogs D\nJOIN Breeds B ON D.breed_code = B.breed_code\nJOIN Sizes S ON D.size_code = S.size_code;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of owners along with their last names who have had dogs treated, sorted by the number of treatments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of owners to display.\",\n    \"1\": \"This virtual table provides a list of unique first names of professionals along with the descriptions of the treatment types they have administered. The data is sourced from the 'Professionals', 'Treatments', and 'Treatment_Types' tables, ensuring that only distinct combinations of professional names and treatment descriptions are displayed.\"\n}\n"}
{"sample_id": "dev.999", "db_id": "dog_kennels", "question": "What are each professional's first name and description of the treatment they have performed?", "rationale": ["We need to retrieve the first names of professionals and the descriptions of the treatments they have performed.", "The relevant tables for this query are 'Professionals', 'Treatments', and 'Treatment_Types'.", "We will join the 'Professionals' table with the 'Treatments' table on the 'professional_id' to link professionals to the treatments they have administered.", "Next, we will join the 'Treatments' table with the 'Treatment_Types' table on 'treatment_type_code' to get the description of each treatment.", "We will select the distinct combinations of 'first_name' from 'Professionals' and 'treatment_type_description' from 'Treatment_Types' to ensure we do not have duplicate entries."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code", "source_tables": ["professionals", "treatments", "treatment_types"], "pred_sql": "SELECT DISTINCT Professionals.first_name, Treatment_Types.treatment_type_description\nFROM Professionals\nJOIN Treatments ON Professionals.professional_id = Treatments.professional_id\nJOIN Treatment_Types ON Treatments.treatment_type_code = Treatment_Types.treatment_type_code;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique first names of professionals along with the descriptions of the treatment types they have administered. The data is sourced from the 'Professionals', 'Treatments', and 'Treatment_Types' tables, ensuring that only distinct combinations of professional names and treatment descriptions are displayed.\"\n}\n"}
